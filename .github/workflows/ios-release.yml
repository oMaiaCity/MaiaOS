name: iOS Release to TestFlight

on:
  workflow_run:
    workflows: ['Release']
    types:
      - completed
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., 0.1.1)'
        required: false

jobs:
  build-and-upload:
    runs-on: macos-latest
    timeout-minutes: 45 # Prevent hanging builds
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    permissions:
      contents: read
      # Note: Organization secrets are automatically available if the repository
      # has access. Repository secrets take precedence over organization secrets.
    steps:
      # ============================================
      # Setup & Dependencies
      # ============================================
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.workflow_run.head_branch || github.ref }}

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Cache Bun dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.bun/install/cache
            node_modules
          key: ${{ runner.os }}-bun-${{ hashFiles('**/bun.lock') }}
          restore-keys: |
            ${{ runner.os }}-bun-

      - name: Install dependencies
        run: bun install --frozen-lockfile

      # ============================================
      # Build Tools Setup
      # ============================================
      - name: Setup Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: '16.1' # Use stable version with iOS SDK installed

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: aarch64-apple-ios

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'
          cache-on-failure: true

      - name: Cache frontend build
        uses: actions/cache@v4
        with:
          path: build
          key: ${{ runner.os }}-frontend-${{ hashFiles('package.json', 'bun.lock', 'src/**', 'static/**') }}
          restore-keys: |
            ${{ runner.os }}-frontend-

      - name: Build frontend
        run: bun run build

      # ============================================
      # Code Signing Setup
      # ============================================
      - name: Setup App Store Connect API key
        run: |
          mkdir -p ~/.appstoreconnect/private_keys
          echo "${{ secrets.APPSTORE_CONNECT_API_KEY }}" > ~/.appstoreconnect/private_keys/AuthKey_${{ secrets.APPSTORE_CONNECT_API_KEY_ID }}.p8
          chmod 600 ~/.appstoreconnect/private_keys/AuthKey_${{ secrets.APPSTORE_CONNECT_API_KEY_ID }}.p8

      - name: Import code signing certificates and profiles
        run: |
          # Debug: Check if secrets are accessible (without exposing values)
          echo "Checking secret availability..."
          if [ -z "${{ secrets.IOS_DISTRIBUTION_CERTIFICATE }}" ]; then
            echo "⚠️  IOS_DISTRIBUTION_CERTIFICATE is empty or not accessible"
          else
            echo "✅ IOS_DISTRIBUTION_CERTIFICATE is available"
          fi

          if [ -z "${{ secrets.IOS_PROVISIONING_PROFILE }}" ]; then
            echo "⚠️  IOS_PROVISIONING_PROFILE is empty or not accessible"
          else
            echo "✅ IOS_PROVISIONING_PROFILE is available"
          fi

          if [ -z "${{ secrets.IOS_DISTRIBUTION_CERTIFICATE_PASSWORD }}" ]; then
            echo "⚠️  IOS_DISTRIBUTION_CERTIFICATE_PASSWORD is empty or not accessible"
          else
            echo "✅ IOS_DISTRIBUTION_CERTIFICATE_PASSWORD is available"
          fi

          # Check if secrets are provided (they may be empty)
          CERT="${{ secrets.IOS_DISTRIBUTION_CERTIFICATE }}"
          PROFILE="${{ secrets.IOS_PROVISIONING_PROFILE }}"

          if [ -z "$CERT" ] || [ -z "$PROFILE" ] || [ "$CERT" = "" ] || [ "$PROFILE" = "" ]; then
            echo "❌ Certificates/profiles not provided or not accessible"
            echo "Please ensure secrets are set at either repository or organization level"
            echo "Repository secrets take precedence over organization secrets"
            exit 1
          fi
          # Create a temporary keychain for code signing
          security create-keychain -p "" build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "" build.keychain
          security set-keychain-settings -t 3600 -u build.keychain

          # Import distribution certificate (.p12)
          echo "${{ secrets.IOS_DISTRIBUTION_CERTIFICATE }}" | base64 --decode > certificate.p12
          security import certificate.p12 -k build.keychain -P "${{ secrets.IOS_DISTRIBUTION_CERTIFICATE_PASSWORD }}" -T /usr/bin/codesign || true
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "" build.keychain || true

          # Import provisioning profile
          mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
          PROFILE_PATH=~/Library/MobileDevice/Provisioning\ Profiles/profile.mobileprovision
          echo "${{ secrets.IOS_PROVISIONING_PROFILE }}" | base64 --decode > "$PROFILE_PATH"

          # Decode the CMS-encoded provisioning profile
          echo "Decoding provisioning profile..."
          PROFILE_XML=$(security cms -D -i "$PROFILE_PATH" 2>&1)
          DECODE_EXIT_CODE=$?

          # Check if decoding succeeded
          if [ $DECODE_EXIT_CODE -ne 0 ] || [ -z "$PROFILE_XML" ] || echo "$PROFILE_XML" | grep -q "security:"; then
            echo "Warning: CMS decoding may have failed, trying alternative method..."
            # Try using plutil if available
            if command -v plutil &> /dev/null; then
              PROFILE_XML=$(plutil -convert xml1 -o - "$PROFILE_PATH" 2>/dev/null || cat "$PROFILE_PATH")
            else
              # Fallback: try to read as-is (might be already decoded or binary)
              PROFILE_XML=$(cat "$PROFILE_PATH")
            fi
          fi

          # Extract UUID using multiple methods
          echo "Extracting UUID from profile..."

          # Method 1: Parse XML plist (accepts both uppercase and lowercase)
          PROFILE_UUID=$(echo "$PROFILE_XML" | grep -a "<key>UUID</key>" -A 1 | grep -oi "<string>[-A-Z0-9a-z]\{36\}</string>" | sed 's/<string>\(.*\)<\/string>/\1/' | head -1)

          # Method 2: Use PlistBuddy if available
          if [ -z "$PROFILE_UUID" ] && command -v /usr/libexec/PlistBuddy &> /dev/null; then
            # Save decoded XML to temp file
            TEMP_PLIST=$(mktemp)
            echo "$PROFILE_XML" > "$TEMP_PLIST"
            PROFILE_UUID=$(/usr/libexec/PlistBuddy -c "Print :UUID" "$TEMP_PLIST" 2>/dev/null || echo "")
            rm -f "$TEMP_PLIST"
          fi

          # Method 3: Extract UUID pattern directly from binary/encoded file (case-insensitive)
          if [ -z "$PROFILE_UUID" ]; then
            PROFILE_UUID=$(strings "$PROFILE_PATH" | grep -iE "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$" | head -1)
          fi

          # Method 4: Try grep for UUID pattern in decoded XML (case-insensitive)
          if [ -z "$PROFILE_UUID" ]; then
            PROFILE_UUID=$(echo "$PROFILE_XML" | grep -oiE "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}" | head -1)
          fi

          if [ -z "$PROFILE_UUID" ]; then
            echo "Error: Could not extract UUID from provisioning profile"
            echo "Profile file size: $(wc -c < "$PROFILE_PATH") bytes"
            echo "First 100 characters of decoded profile:"
            echo "$PROFILE_XML" | head -c 100
            echo ""
            exit 1
          fi

          # Validate UUID format (should be 36 characters with dashes)
          if [ ${#PROFILE_UUID} -ne 36 ]; then
            echo "Error: Extracted UUID has invalid length: $PROFILE_UUID (length: ${#PROFILE_UUID})"
            exit 1
          fi

          # Rename profile to match UUID (Xcode expects this)
          FINAL_PROFILE_PATH=~/Library/MobileDevice/Provisioning\ Profiles/${PROFILE_UUID}.mobileprovision
          mv "$PROFILE_PATH" "$FINAL_PROFILE_PATH"
          echo "✅ Imported provisioning profile with UUID: $PROFILE_UUID"
          echo "Profile saved to: $FINAL_PROFILE_PATH"

          # List imported profiles
          echo "Available provisioning profiles:"
          ls -la ~/Library/MobileDevice/Provisioning\ Profiles/
        working-directory: ${{ github.workspace }}

      # ============================================
      # Build iOS App
      # ============================================
      - name: Prepare Rust library for iOS
        env:
          APPLE_DEVELOPMENT_TEAM: ${{ secrets.APPLE_DEVELOPMENT_TEAM }}
          CI: true
        run: |
          cd src-tauri

          # Ensure output directory exists
          mkdir -p gen/apple/Externals/arm64/release

          # Debug: Check what's in the cache
          echo "Checking for cached Rust library..."
          echo "Target directory exists: $([ -d target/aarch64-apple-ios/release ] && echo 'yes' || echo 'no')"
          if [ -d target/aarch64-apple-ios/release ]; then
            echo "Files in target/aarch64-apple-ios/release:"
            ls -la target/aarch64-apple-ios/release/ | grep -E "\.(a|rlib)$" | head -5 || echo "  (none found)"
          fi

          # Check if library exists in target directory first (this is cached)
          LIBRARY=$(find target/aarch64-apple-ios/release -name "libapp*.a" -type f 2>/dev/null | head -1)

          if [ -n "$LIBRARY" ]; then
            echo "✅ Found Rust library in cache: $LIBRARY"
            cp "$LIBRARY" gen/apple/Externals/arm64/release/libapp.a
            echo "✅ Rust library ready: $(ls -lh gen/apple/Externals/arm64/release/libapp.a)"
          elif [ -f "gen/apple/Externals/arm64/release/libapp.a" ]; then
            echo "✅ Rust library found in gen/apple (from previous step), skipping build"
            ls -lh gen/apple/Externals/arm64/release/libapp.a
          else
            # Only build if library doesn't exist anywhere
            echo "⚠️  No cached library found, building Rust library for iOS..."
            echo "This will download and compile dependencies (may take 2-3 minutes)"
            cargo build --release --target aarch64-apple-ios
            
            LIBRARY=$(find target/aarch64-apple-ios/release -name "libapp*.a" -type f | head -1)
            if [ -z "$LIBRARY" ]; then
              echo "Error: No Rust library found after build"
              ls -la target/aarch64-apple-ios/release/ | grep -E "\.(a|rlib)$" || true
              exit 1
            fi
            
            cp "$LIBRARY" gen/apple/Externals/arm64/release/libapp.a
            echo "✅ Rust library built and ready: $(ls -lh gen/apple/Externals/arm64/release/libapp.a)"
          fi

      - name: Configure Xcode project for manual signing
        run: |
          cd src-tauri/gen/apple

          # Find the provisioning profile UUID
          PROFILE_FILE=$(ls ~/Library/MobileDevice/Provisioning\ Profiles/*.mobileprovision 2>/dev/null | head -1)

          if [ -n "$PROFILE_FILE" ] && [ -f "$PROFILE_FILE" ]; then
            PROFILE_UUID=$(basename "$PROFILE_FILE" .mobileprovision)
            echo "Found provisioning profile UUID: $PROFILE_UUID"
            
            # Update project.yml using sed - no Python needed!
            # This is simpler and avoids pip installation issues
            # We'll add the provisioning profile settings after DEVELOPMENT_TEAM line
            if grep -q "PROVISIONING_PROFILE_SPECIFIER" project.yml; then
              # Update existing entries
              sed -i.bak "s/PROVISIONING_PROFILE_SPECIFIER:.*/PROVISIONING_PROFILE_SPECIFIER: $PROFILE_UUID/" project.yml
              sed -i.bak "s/PROVISIONING_PROFILE:.*/PROVISIONING_PROFILE: $PROFILE_UUID/" project.yml
            else
              # Add new entries after DEVELOPMENT_TEAM
              sed -i.bak "/DEVELOPMENT_TEAM: 2P6VCHVJWB/a\\
          PROVISIONING_PROFILE_SPECIFIER: $PROFILE_UUID\\
          PROVISIONING_PROFILE: $PROFILE_UUID" project.yml
            fi
            
            # Verify the update worked
            if grep -q "PROVISIONING_PROFILE_SPECIFIER.*$PROFILE_UUID" project.yml; then
              echo "✅ Verified project.yml contains provisioning profile UUID: $PROFILE_UUID"
            else
              echo "⚠️  Warning: project.yml might not have been updated correctly"
              echo "Current project.yml content around DEVELOPMENT_TEAM:"
              grep -A 3 "DEVELOPMENT_TEAM" project.yml || true
            fi
            
            echo "✅ Configured project.yml for manual signing with profile: $PROFILE_UUID"
          else
            echo "⚠️  No provisioning profile found, will use automatic signing"
          fi
        working-directory: ${{ github.workspace }}

      - name: Verify code signing setup
        run: |
          echo "=== Code Signing Verification ==="
          echo "Available certificates:"
          security find-identity -v -p codesigning || echo "No certificates found"
          echo ""
          echo "Available provisioning profiles:"
          ls -la ~/Library/MobileDevice/Provisioning\ Profiles/ || echo "No profiles found"
          echo ""
          echo "Default keychain:"
          security default-keychain || echo "No default keychain"
        working-directory: ${{ github.workspace }}

      - name: Archive and export iOS app with xcodebuild
        env:
          APPLE_DEVELOPMENT_TEAM: ${{ secrets.APPLE_DEVELOPMENT_TEAM }}
          CI: 'true'
          TAURI_BUILD: '1'
          RUST_BACKTRACE: '1'
        run: |
          cd src-tauri/gen/apple

          IOS_SDK=$(xcodebuild -showsdks | grep -i "iphoneos" | head -1 | awk '{print $NF}' || echo "iphoneos")
          echo "Using iOS SDK: $IOS_SDK"

          # Explicitly export CI environment variables so they're available to Xcode build scripts
          # Xcode build scripts run in a separate shell and need these exported
          export CI=true
          export TAURI_BUILD=1
          export RUST_BACKTRACE=1
          echo "CI mode enabled - Tauri should skip dev server connection"
          echo "Environment variables: CI=$CI, TAURI_BUILD=$TAURI_BUILD"

          # Create server address file that Tauri's xcode-script expects
          # This prevents the "failed to read missing addr file" error
          # Tauri checks this file to see if dev server is running - in CI we create a dummy one
          SERVER_ADDR_FILE="${TMPDIR}/me.hominio.app-server-addr"
          if [ -z "$TMPDIR" ]; then
            # Fallback to common temp directories
            SERVER_ADDR_FILE="/tmp/me.hominio.app-server-addr"
          fi
          echo "http://localhost:5173" > "$SERVER_ADDR_FILE"
          echo "✅ Created server address file: $SERVER_ADDR_FILE"

          # Also create in /var/folders/*/T/ directories (macOS temp pattern)
          find /var/folders -type d -name "T" 2>/dev/null | head -5 | while read T_DIR; do
            echo "http://localhost:5173" > "${T_DIR}/me.hominio.app-server-addr" 2>/dev/null && echo "✅ Created: ${T_DIR}/me.hominio.app-server-addr" || true
          done

          # Find the provisioning profile UUID
          PROFILE_FILE=$(ls ~/Library/MobileDevice/Provisioning\ Profiles/*.mobileprovision 2>/dev/null | head -1)

          if [ -n "$PROFILE_FILE" ] && [ -f "$PROFILE_FILE" ]; then
            PROFILE_UUID=$(basename "$PROFILE_FILE" .mobileprovision)
            echo "Using provisioning profile UUID: $PROFILE_UUID"
            
            # Build with manual code signing
            xcodebuild \
              -workspace app.xcodeproj/project.xcworkspace \
              -scheme app_iOS \
              -sdk "$IOS_SDK" \
              -configuration release \
              -destination 'generic/platform=iOS' \
              CODE_SIGN_STYLE=Manual \
              CODE_SIGN_IDENTITY="Apple Distribution" \
              DEVELOPMENT_TEAM="${{ secrets.APPLE_DEVELOPMENT_TEAM }}" \
              PROVISIONING_PROFILE_SPECIFIER="$PROFILE_UUID" \
              PROVISIONING_PROFILE="$PROFILE_UUID" \
              archive \
              -archivePath build/app.xcarchive \
              2>&1 | tee build.log || {
                echo "Build failed, showing last 50 lines of log:"
                tail -50 build.log
                exit 1
              }
          else
            echo "⚠️  No provisioning profile found, trying automatic signing..."
            xcodebuild -allowProvisioningUpdates \
              -workspace app.xcodeproj/project.xcworkspace \
              -scheme app_iOS \
              -sdk "$IOS_SDK" \
              -configuration release \
              -destination 'generic/platform=iOS' \
              CODE_SIGN_STYLE=Automatic \
              DEVELOPMENT_TEAM="${{ secrets.APPLE_DEVELOPMENT_TEAM }}" \
              archive \
              -archivePath build/app.xcarchive || {
                echo "Automatic signing failed - manual signing required"
                exit 1
              }
          fi

          # Export IPA
          xcodebuild -exportArchive \
            -archivePath build/app.xcarchive \
            -exportPath build \
            -exportOptionsPlist ExportOptions.plist
        working-directory: ${{ github.workspace }}

      # ============================================
      # Upload to TestFlight
      # ============================================
      - name: Find IPA file
        id: find-ipa
        run: |
          # Tauri ios build outputs IPA in src-tauri/gen/apple/build/arm64/APPNAME.ipa
          # Search in multiple possible locations
          IPA_PATH=$(find src-tauri/gen/apple/build -name "*.ipa" -type f 2>/dev/null | head -1)

          if [ -z "$IPA_PATH" ]; then
            # Try alternative locations
            IPA_PATH=$(find src-tauri/gen/apple -name "*.ipa" -type f 2>/dev/null | head -1)
          fi

          if [ -z "$IPA_PATH" ]; then
            echo "Error: IPA file not found"
            echo "Searching in common locations:"
            find src-tauri/gen/apple -name "*.ipa" -type f 2>/dev/null || echo "No IPA found in gen/apple"
            find src-tauri/target -name "*.ipa" -type f 2>/dev/null || echo "No IPA in target"
            echo "Build output directories:"
            ls -la src-tauri/gen/apple/build/ 2>/dev/null || echo "Build directory not found"
            exit 1
          fi

          echo "ipa_path=$IPA_PATH" >> $GITHUB_OUTPUT
          echo "Found IPA: $IPA_PATH"
          ls -lh "$IPA_PATH"

      - name: Create API key file
        run: |
          echo "${{ secrets.APPSTORE_CONNECT_API_KEY }}" > /tmp/api_key.p8
          chmod 600 /tmp/api_key.p8

      - name: Upload to TestFlight
        uses: apple-actions/upload-testflight-build@v1
        with:
          app-path: ${{ steps.find-ipa.outputs.ipa_path }}
          issuer-id: ${{ secrets.APPSTORE_CONNECT_ISSUER_ID }}
          api-key-id: ${{ secrets.APPSTORE_CONNECT_API_KEY_ID }}
          api-private-key: ${{ secrets.APPSTORE_CONNECT_API_KEY }}

      - name: Upload IPA artifact
        uses: actions/upload-artifact@v4
        with:
          name: ios-ipa-${{ github.ref_name }}
          path: ${{ steps.find-ipa.outputs.ipa_path }}
          retention-days: 30
