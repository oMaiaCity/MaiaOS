name: iOS Release to TestFlight

on:
  workflow_run:
    workflows: ['Release']
    types:
      - completed
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., 0.1.1)'
        required: false

jobs:
  build-and-upload:
    runs-on: macos-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    permissions:
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.workflow_run.head_branch || github.ref }}

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install

      - name: Setup Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: '16.1' # Use stable version with iOS SDK installed

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: aarch64-apple-ios

      - name: Cache Rust dependencies and built library
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            src-tauri/target/
            src-tauri/gen/apple/Externals/
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Build frontend
        run: bun run build

      - name: Setup App Store Connect API key
        run: |
          mkdir -p ~/.appstoreconnect/private_keys
          echo "${{ secrets.APPSTORE_CONNECT_API_KEY }}" > ~/.appstoreconnect/private_keys/AuthKey_${{ secrets.APPSTORE_CONNECT_API_KEY_ID }}.p8
          chmod 600 ~/.appstoreconnect/private_keys/AuthKey_${{ secrets.APPSTORE_CONNECT_API_KEY_ID }}.p8

      - name: Import code signing certificates and profiles
        run: |
          # Check if secrets are provided (they may be empty)
          CERT="${{ secrets.IOS_DISTRIBUTION_CERTIFICATE }}"
          PROFILE="${{ secrets.IOS_PROVISIONING_PROFILE }}"

          if [ -z "$CERT" ] || [ -z "$PROFILE" ] || [ "$CERT" = "" ] || [ "$PROFILE" = "" ]; then
            echo "Certificates/profiles not provided, skipping import..."
            exit 0
          fi
          # Create a temporary keychain for code signing
          security create-keychain -p "" build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "" build.keychain
          security set-keychain-settings -t 3600 -u build.keychain

          # Import distribution certificate (.p12)
          echo "${{ secrets.IOS_DISTRIBUTION_CERTIFICATE }}" | base64 --decode > certificate.p12
          security import certificate.p12 -k build.keychain -P "${{ secrets.IOS_DISTRIBUTION_CERTIFICATE_PASSWORD }}" -T /usr/bin/codesign || true
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "" build.keychain || true

          # Import provisioning profile
          mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
          PROFILE_PATH=~/Library/MobileDevice/Provisioning\ Profiles/profile.mobileprovision
          echo "${{ secrets.IOS_PROVISIONING_PROFILE }}" | base64 --decode > "$PROFILE_PATH"

          # Decode the CMS-encoded provisioning profile
          echo "Decoding provisioning profile..."
          PROFILE_XML=$(security cms -D -i "$PROFILE_PATH" 2>&1)
          DECODE_EXIT_CODE=$?

          # Check if decoding succeeded
          if [ $DECODE_EXIT_CODE -ne 0 ] || [ -z "$PROFILE_XML" ] || echo "$PROFILE_XML" | grep -q "security:"; then
            echo "Warning: CMS decoding may have failed, trying alternative method..."
            # Try using plutil if available
            if command -v plutil &> /dev/null; then
              PROFILE_XML=$(plutil -convert xml1 -o - "$PROFILE_PATH" 2>/dev/null || cat "$PROFILE_PATH")
            else
              # Fallback: try to read as-is (might be already decoded or binary)
              PROFILE_XML=$(cat "$PROFILE_PATH")
            fi
          fi

          # Extract UUID using multiple methods
          echo "Extracting UUID from profile..."

          # Method 1: Parse XML plist (accepts both uppercase and lowercase)
          PROFILE_UUID=$(echo "$PROFILE_XML" | grep -a "<key>UUID</key>" -A 1 | grep -oi "<string>[-A-Z0-9a-z]\{36\}</string>" | sed 's/<string>\(.*\)<\/string>/\1/' | head -1)

          # Method 2: Use PlistBuddy if available
          if [ -z "$PROFILE_UUID" ] && command -v /usr/libexec/PlistBuddy &> /dev/null; then
            # Save decoded XML to temp file
            TEMP_PLIST=$(mktemp)
            echo "$PROFILE_XML" > "$TEMP_PLIST"
            PROFILE_UUID=$(/usr/libexec/PlistBuddy -c "Print :UUID" "$TEMP_PLIST" 2>/dev/null || echo "")
            rm -f "$TEMP_PLIST"
          fi

          # Method 3: Extract UUID pattern directly from binary/encoded file (case-insensitive)
          if [ -z "$PROFILE_UUID" ]; then
            PROFILE_UUID=$(strings "$PROFILE_PATH" | grep -iE "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$" | head -1)
          fi

          # Method 4: Try grep for UUID pattern in decoded XML (case-insensitive)
          if [ -z "$PROFILE_UUID" ]; then
            PROFILE_UUID=$(echo "$PROFILE_XML" | grep -oiE "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}" | head -1)
          fi

          if [ -z "$PROFILE_UUID" ]; then
            echo "Error: Could not extract UUID from provisioning profile"
            echo "Profile file size: $(wc -c < "$PROFILE_PATH") bytes"
            echo "First 100 characters of decoded profile:"
            echo "$PROFILE_XML" | head -c 100
            echo ""
            exit 1
          fi

          # Validate UUID format (should be 36 characters with dashes)
          if [ ${#PROFILE_UUID} -ne 36 ]; then
            echo "Error: Extracted UUID has invalid length: $PROFILE_UUID (length: ${#PROFILE_UUID})"
            exit 1
          fi

          # Rename profile to match UUID (Xcode expects this)
          FINAL_PROFILE_PATH=~/Library/MobileDevice/Provisioning\ Profiles/${PROFILE_UUID}.mobileprovision
          mv "$PROFILE_PATH" "$FINAL_PROFILE_PATH"
          echo "✅ Imported provisioning profile with UUID: $PROFILE_UUID"
          echo "Profile saved to: $FINAL_PROFILE_PATH"

          # List imported profiles
          echo "Available provisioning profiles:"
          ls -la ~/Library/MobileDevice/Provisioning\ Profiles/
        working-directory: ${{ github.workspace }}

      - name: Prepare Rust library for iOS
        env:
          APPLE_DEVELOPMENT_TEAM: ${{ secrets.APPLE_DEVELOPMENT_TEAM }}
          CI: true
        run: |
          cd src-tauri

          # Ensure output directory exists
          mkdir -p gen/apple/Externals/arm64/release

          # Debug: Check what's in the cache
          echo "Checking for cached Rust library..."
          echo "Target directory exists: $([ -d target/aarch64-apple-ios/release ] && echo 'yes' || echo 'no')"
          if [ -d target/aarch64-apple-ios/release ]; then
            echo "Files in target/aarch64-apple-ios/release:"
            ls -la target/aarch64-apple-ios/release/ | grep -E "\.(a|rlib)$" | head -5 || echo "  (none found)"
          fi

          # Check if library exists in target directory first (this is cached)
          LIBRARY=$(find target/aarch64-apple-ios/release -name "libapp*.a" -type f 2>/dev/null | head -1)

          if [ -n "$LIBRARY" ]; then
            echo "✅ Found Rust library in cache: $LIBRARY"
            cp "$LIBRARY" gen/apple/Externals/arm64/release/libapp.a
            echo "✅ Rust library ready: $(ls -lh gen/apple/Externals/arm64/release/libapp.a)"
          elif [ -f "gen/apple/Externals/arm64/release/libapp.a" ]; then
            echo "✅ Rust library found in gen/apple (from previous step), skipping build"
            ls -lh gen/apple/Externals/arm64/release/libapp.a
          else
            # Only build if library doesn't exist anywhere
            echo "⚠️  No cached library found, building Rust library for iOS..."
            echo "This will download and compile dependencies (may take 2-3 minutes)"
            cargo build --release --target aarch64-apple-ios
            
            LIBRARY=$(find target/aarch64-apple-ios/release -name "libapp*.a" -type f | head -1)
            if [ -z "$LIBRARY" ]; then
              echo "Error: No Rust library found after build"
              ls -la target/aarch64-apple-ios/release/ | grep -E "\.(a|rlib)$" || true
              exit 1
            fi
            
            cp "$LIBRARY" gen/apple/Externals/arm64/release/libapp.a
            echo "✅ Rust library built and ready: $(ls -lh gen/apple/Externals/arm64/release/libapp.a)"
          fi

      - name: Archive and export iOS app
        env:
          APPLE_DEVELOPMENT_TEAM: ${{ secrets.APPLE_DEVELOPMENT_TEAM }}
        run: |
          cd src-tauri/gen/apple

          IOS_SDK=$(xcodebuild -showsdks | grep -i "iphoneos" | head -1 | awk '{print $NF}' || echo "iphoneos")
          echo "Using iOS SDK: $IOS_SDK"

          # Create server address file that Tauri's xcode-script expects (must exist when Xcode runs)
          # Tauri checks this file to see if dev server is running - create empty file to prevent panic
          echo "Creating server address file for Tauri..."
          if [ -n "$TMPDIR" ] && [ -d "$TMPDIR" ]; then
            echo "" > "${TMPDIR}/me.hominio.app-server-addr" && echo "✅ Created: ${TMPDIR}/me.hominio.app-server-addr"
          fi
          # Also create in /var/folders/*/T/ directories (macOS temp pattern)
          find /var/folders -type d -name "T" 2>/dev/null | head -5 | while read T_DIR; do
            echo "" > "${T_DIR}/me.hominio.app-server-addr" 2>/dev/null && echo "✅ Created: ${T_DIR}/me.hominio.app-server-addr" || true
          done

          # Build with code signing
          # If certificates/profiles are imported, use manual signing
          # Otherwise, try automatic signing with -allowProvisioningUpdates
          PROFILE_FILE=$(ls ~/Library/MobileDevice/Provisioning\ Profiles/*.mobileprovision 2>/dev/null | head -1)

          if [ -n "$PROFILE_FILE" ] && [ -f "$PROFILE_FILE" ]; then
            echo "Using manual code signing with imported certificates..."
            echo "Found provisioning profile: $PROFILE_FILE"
            
            # Extract UUID from filename (profile was renamed with UUID in previous step)
            PROFILE_UUID=$(basename "$PROFILE_FILE" .mobileprovision)
            
            # Validate UUID format (should be 36 characters with dashes, accepts both uppercase and lowercase)
            if [ ${#PROFILE_UUID} -ne 36 ] || ! echo "$PROFILE_UUID" | grep -qiE "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$"; then
              echo "Error: Invalid UUID format extracted from filename: $PROFILE_UUID"
              echo "Available profiles:"
              ls -la ~/Library/MobileDevice/Provisioning\ Profiles/
              exit 1
            fi
            
            echo "Using provisioning profile UUID: $PROFILE_UUID"
            
            # Verify profile bundle ID matches (optional check)
            PROFILE_XML=$(security cms -D -i "$PROFILE_FILE" 2>/dev/null || echo "")
            if [ -n "$PROFILE_XML" ]; then
              PROFILE_BUNDLE_ID=$(echo "$PROFILE_XML" | grep -aA1 "<key>application-identifier</key>" | grep -o "<string>.*</string>" | sed 's/<string>\(.*\)<\/string>/\1/' | head -1 | cut -d. -f2-)
              EXPECTED_BUNDLE_ID="me.hominio.app"
              echo "Profile bundle ID: $PROFILE_BUNDLE_ID"
              echo "Expected bundle ID: $EXPECTED_BUNDLE_ID"
              
              if [ "$PROFILE_BUNDLE_ID" != "$EXPECTED_BUNDLE_ID" ]; then
                echo "Warning: Profile bundle ID ($PROFILE_BUNDLE_ID) doesn't match expected ($EXPECTED_BUNDLE_ID)"
              fi
            fi
            
            # List available certificates
            security find-identity -v -p codesigning
            
            # Set CI environment variables to skip dev server check
            export CI=true
            export TAURI_BUILD=1
            export RUST_BACKTRACE=1
            
            # Use UUID for PROVISIONING_PROFILE (Xcode expects UUID, not path)
            xcodebuild \
              -workspace app.xcodeproj/project.xcworkspace \
              -scheme app_iOS \
              -sdk "$IOS_SDK" \
              -configuration release \
              -destination 'generic/platform=iOS' \
              CODE_SIGN_STYLE=Manual \
              CODE_SIGN_IDENTITY="Apple Distribution" \
              DEVELOPMENT_TEAM="${{ secrets.APPLE_DEVELOPMENT_TEAM }}" \
              PROVISIONING_PROFILE_SPECIFIER="$PROFILE_UUID" \
              PROVISIONING_PROFILE="$PROFILE_UUID" \
              archive \
              -archivePath build/app.xcarchive \
              2>&1 | tee build.log || {
                echo "Build failed, showing last 50 lines of log:"
                tail -50 build.log
                exit 1
              }
          else
            echo "Using automatic code signing..."
            xcodebuild -allowProvisioningUpdates \
              -workspace app.xcodeproj/project.xcworkspace \
              -scheme app_iOS \
              -sdk "$IOS_SDK" \
              -configuration release \
              -destination 'generic/platform=iOS' \
              CODE_SIGN_STYLE=Automatic \
              DEVELOPMENT_TEAM="${{ secrets.APPLE_DEVELOPMENT_TEAM }}" \
              archive \
              -archivePath build/app.xcarchive
          fi

          # Export IPA
          xcodebuild -exportArchive \
            -archivePath build/app.xcarchive \
            -exportPath build \
            -exportOptionsPlist ExportOptions.plist
        working-directory: ${{ github.workspace }}

      - name: Find IPA file
        id: find-ipa
        run: |
          IPA_PATH=$(find src-tauri/gen/apple/build -name "*.ipa" -type f | head -1)
          if [ -z "$IPA_PATH" ]; then
            echo "Error: IPA file not found"
            find src-tauri/gen/apple/build -type f
            exit 1
          fi
          echo "ipa_path=$IPA_PATH" >> $GITHUB_OUTPUT
          echo "Found IPA: $IPA_PATH"
          ls -lh "$IPA_PATH"

      - name: Create API key file
        run: |
          echo "${{ secrets.APPSTORE_CONNECT_API_KEY }}" > /tmp/api_key.p8
          chmod 600 /tmp/api_key.p8

      - name: Upload to TestFlight
        uses: apple-actions/upload-testflight-build@v1
        with:
          app-path: ${{ steps.find-ipa.outputs.ipa_path }}
          issuer-id: ${{ secrets.APPSTORE_CONNECT_ISSUER_ID }}
          api-key-id: ${{ secrets.APPSTORE_CONNECT_API_KEY_ID }}
          api-private-key: ${{ secrets.APPSTORE_CONNECT_API_KEY }}

      - name: Upload IPA artifact
        uses: actions/upload-artifact@v4
        with:
          name: ios-ipa-${{ github.ref_name }}
          path: ${{ steps.find-ipa.outputs.ipa_path }}
          retention-days: 30
