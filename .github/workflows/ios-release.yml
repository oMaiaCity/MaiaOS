name: iOS Release to TestFlight

on:
  workflow_run:
    workflows: ['Release']
    types:
      - completed
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., 0.1.1)'
        required: false

jobs:
  build-and-upload:
    runs-on: macos-latest
    timeout-minutes: 45 # Prevent hanging builds
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    permissions:
      contents: read
    steps:
      # ============================================
      # Setup & Dependencies
      # ============================================
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.workflow_run.head_branch || github.ref }}

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Cache Bun dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.bun/install/cache
            node_modules
          key: ${{ runner.os }}-bun-${{ hashFiles('**/bun.lock') }}
          restore-keys: |
            ${{ runner.os }}-bun-

      - name: Install dependencies
        run: bun install --frozen-lockfile

      # ============================================
      # Build Tools Setup
      # ============================================
      - name: Setup Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: '16.1' # Use stable version with iOS SDK installed

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: aarch64-apple-ios

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'
          cache-on-failure: true

      - name: Cache frontend build
        uses: actions/cache@v4
        with:
          path: build
          key: ${{ runner.os }}-frontend-${{ hashFiles('package.json', 'bun.lock', 'src/**', 'static/**') }}
          restore-keys: |
            ${{ runner.os }}-frontend-

      - name: Build frontend
        run: bun run build

      # ============================================
      # Code Signing Setup
      # ============================================
      - name: Setup App Store Connect API key
        run: |
          mkdir -p ~/.appstoreconnect/private_keys
          echo "${{ secrets.APPSTORE_CONNECT_API_KEY }}" > ~/.appstoreconnect/private_keys/AuthKey_${{ secrets.APPSTORE_CONNECT_API_KEY_ID }}.p8
          chmod 600 ~/.appstoreconnect/private_keys/AuthKey_${{ secrets.APPSTORE_CONNECT_API_KEY_ID }}.p8

      - name: Import code signing certificates and profiles
        run: |
          # Check if secrets are provided (they may be empty)
          CERT="${{ secrets.IOS_DISTRIBUTION_CERTIFICATE }}"
          PROFILE="${{ secrets.IOS_PROVISIONING_PROFILE }}"

          if [ -z "$CERT" ] || [ -z "$PROFILE" ] || [ "$CERT" = "" ] || [ "$PROFILE" = "" ]; then
            echo "Certificates/profiles not provided, skipping import..."
            exit 0
          fi
          # Create a temporary keychain for code signing
          security create-keychain -p "" build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "" build.keychain
          security set-keychain-settings -t 3600 -u build.keychain

          # Import distribution certificate (.p12)
          echo "${{ secrets.IOS_DISTRIBUTION_CERTIFICATE }}" | base64 --decode > certificate.p12
          security import certificate.p12 -k build.keychain -P "${{ secrets.IOS_DISTRIBUTION_CERTIFICATE_PASSWORD }}" -T /usr/bin/codesign || true
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "" build.keychain || true

          # Import provisioning profile
          mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
          PROFILE_PATH=~/Library/MobileDevice/Provisioning\ Profiles/profile.mobileprovision
          echo "${{ secrets.IOS_PROVISIONING_PROFILE }}" | base64 --decode > "$PROFILE_PATH"

          # Decode the CMS-encoded provisioning profile
          echo "Decoding provisioning profile..."
          PROFILE_XML=$(security cms -D -i "$PROFILE_PATH" 2>&1)
          DECODE_EXIT_CODE=$?

          # Check if decoding succeeded
          if [ $DECODE_EXIT_CODE -ne 0 ] || [ -z "$PROFILE_XML" ] || echo "$PROFILE_XML" | grep -q "security:"; then
            echo "Warning: CMS decoding may have failed, trying alternative method..."
            # Try using plutil if available
            if command -v plutil &> /dev/null; then
              PROFILE_XML=$(plutil -convert xml1 -o - "$PROFILE_PATH" 2>/dev/null || cat "$PROFILE_PATH")
            else
              # Fallback: try to read as-is (might be already decoded or binary)
              PROFILE_XML=$(cat "$PROFILE_PATH")
            fi
          fi

          # Extract UUID using multiple methods
          echo "Extracting UUID from profile..."

          # Method 1: Parse XML plist (accepts both uppercase and lowercase)
          PROFILE_UUID=$(echo "$PROFILE_XML" | grep -a "<key>UUID</key>" -A 1 | grep -oi "<string>[-A-Z0-9a-z]\{36\}</string>" | sed 's/<string>\(.*\)<\/string>/\1/' | head -1)

          # Method 2: Use PlistBuddy if available
          if [ -z "$PROFILE_UUID" ] && command -v /usr/libexec/PlistBuddy &> /dev/null; then
            # Save decoded XML to temp file
            TEMP_PLIST=$(mktemp)
            echo "$PROFILE_XML" > "$TEMP_PLIST"
            PROFILE_UUID=$(/usr/libexec/PlistBuddy -c "Print :UUID" "$TEMP_PLIST" 2>/dev/null || echo "")
            rm -f "$TEMP_PLIST"
          fi

          # Method 3: Extract UUID pattern directly from binary/encoded file (case-insensitive)
          if [ -z "$PROFILE_UUID" ]; then
            PROFILE_UUID=$(strings "$PROFILE_PATH" | grep -iE "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$" | head -1)
          fi

          # Method 4: Try grep for UUID pattern in decoded XML (case-insensitive)
          if [ -z "$PROFILE_UUID" ]; then
            PROFILE_UUID=$(echo "$PROFILE_XML" | grep -oiE "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}" | head -1)
          fi

          if [ -z "$PROFILE_UUID" ]; then
            echo "Error: Could not extract UUID from provisioning profile"
            echo "Profile file size: $(wc -c < "$PROFILE_PATH") bytes"
            echo "First 100 characters of decoded profile:"
            echo "$PROFILE_XML" | head -c 100
            echo ""
            exit 1
          fi

          # Validate UUID format (should be 36 characters with dashes)
          if [ ${#PROFILE_UUID} -ne 36 ]; then
            echo "Error: Extracted UUID has invalid length: $PROFILE_UUID (length: ${#PROFILE_UUID})"
            exit 1
          fi

          # Rename profile to match UUID (Xcode expects this)
          FINAL_PROFILE_PATH=~/Library/MobileDevice/Provisioning\ Profiles/${PROFILE_UUID}.mobileprovision
          mv "$PROFILE_PATH" "$FINAL_PROFILE_PATH"
          echo "✅ Imported provisioning profile with UUID: $PROFILE_UUID"
          echo "Profile saved to: $FINAL_PROFILE_PATH"

          # List imported profiles
          echo "Available provisioning profiles:"
          ls -la ~/Library/MobileDevice/Provisioning\ Profiles/
        working-directory: ${{ github.workspace }}

      # ============================================
      # Build iOS App
      # ============================================
      - name: Prepare Rust library for iOS
        env:
          APPLE_DEVELOPMENT_TEAM: ${{ secrets.APPLE_DEVELOPMENT_TEAM }}
          CI: true
        run: |
          cd src-tauri

          # Ensure output directory exists
          mkdir -p gen/apple/Externals/arm64/release

          # Debug: Check what's in the cache
          echo "Checking for cached Rust library..."
          echo "Target directory exists: $([ -d target/aarch64-apple-ios/release ] && echo 'yes' || echo 'no')"
          if [ -d target/aarch64-apple-ios/release ]; then
            echo "Files in target/aarch64-apple-ios/release:"
            ls -la target/aarch64-apple-ios/release/ | grep -E "\.(a|rlib)$" | head -5 || echo "  (none found)"
          fi

          # Check if library exists in target directory first (this is cached)
          LIBRARY=$(find target/aarch64-apple-ios/release -name "libapp*.a" -type f 2>/dev/null | head -1)

          if [ -n "$LIBRARY" ]; then
            echo "✅ Found Rust library in cache: $LIBRARY"
            cp "$LIBRARY" gen/apple/Externals/arm64/release/libapp.a
            echo "✅ Rust library ready: $(ls -lh gen/apple/Externals/arm64/release/libapp.a)"
          elif [ -f "gen/apple/Externals/arm64/release/libapp.a" ]; then
            echo "✅ Rust library found in gen/apple (from previous step), skipping build"
            ls -lh gen/apple/Externals/arm64/release/libapp.a
          else
            # Only build if library doesn't exist anywhere
            echo "⚠️  No cached library found, building Rust library for iOS..."
            echo "This will download and compile dependencies (may take 2-3 minutes)"
            cargo build --release --target aarch64-apple-ios
            
            LIBRARY=$(find target/aarch64-apple-ios/release -name "libapp*.a" -type f | head -1)
            if [ -z "$LIBRARY" ]; then
              echo "Error: No Rust library found after build"
              ls -la target/aarch64-apple-ios/release/ | grep -E "\.(a|rlib)$" || true
              exit 1
            fi
            
            cp "$LIBRARY" gen/apple/Externals/arm64/release/libapp.a
            echo "✅ Rust library built and ready: $(ls -lh gen/apple/Externals/arm64/release/libapp.a)"
          fi

      - name: Configure Xcode project for manual signing
        run: |
          cd src-tauri/gen/apple

          # Install PyYAML for Python YAML manipulation
          pip3 install pyyaml --quiet || python3 -m pip install pyyaml --quiet

          # Find the provisioning profile UUID
          PROFILE_FILE=$(ls ~/Library/MobileDevice/Provisioning\ Profiles/*.mobileprovision 2>/dev/null | head -1)

          if [ -n "$PROFILE_FILE" ] && [ -f "$PROFILE_FILE" ]; then
            PROFILE_UUID=$(basename "$PROFILE_FILE" .mobileprovision)
            echo "Found provisioning profile UUID: $PROFILE_UUID"
            
            # Update project.yml to include provisioning profile UUID using Python
            # Write Python script to a temporary file using echo to avoid YAML heredoc issues
            echo 'import yaml' > /tmp/update_project_yml.py
            echo 'import sys' >> /tmp/update_project_yml.py
            echo 'import os' >> /tmp/update_project_yml.py
            echo 'profile_uuid = os.environ.get("PROFILE_UUID", "")' >> /tmp/update_project_yml.py
            echo 'try:' >> /tmp/update_project_yml.py
            echo '    with open("project.yml", "r") as f:' >> /tmp/update_project_yml.py
            echo '        data = yaml.safe_load(f)' >> /tmp/update_project_yml.py
            echo '    if "targets" in data and "app_iOS" in data["targets"]:' >> /tmp/update_project_yml.py
            echo '        if "settings" not in data["targets"]["app_iOS"]:' >> /tmp/update_project_yml.py
            echo '            data["targets"]["app_iOS"]["settings"] = {}' >> /tmp/update_project_yml.py
            echo '        if "base" not in data["targets"]["app_iOS"]["settings"]:' >> /tmp/update_project_yml.py
            echo '            data["targets"]["app_iOS"]["settings"]["base"] = {}' >> /tmp/update_project_yml.py
            echo '        data["targets"]["app_iOS"]["settings"]["base"]["PROVISIONING_PROFILE_SPECIFIER"] = profile_uuid' >> /tmp/update_project_yml.py
            echo '        data["targets"]["app_iOS"]["settings"]["base"]["PROVISIONING_PROFILE"] = profile_uuid' >> /tmp/update_project_yml.py
            echo '        with open("project.yml", "w") as f:' >> /tmp/update_project_yml.py
            echo '            yaml.dump(data, f, default_flow_style=False, sort_keys=False, allow_unicode=True)' >> /tmp/update_project_yml.py
            echo '        print(f"✅ Updated project.yml with provisioning profile UUID: {profile_uuid}")' >> /tmp/update_project_yml.py
            echo '    else:' >> /tmp/update_project_yml.py
            echo '        print("⚠️  Could not find app_iOS target in project.yml")' >> /tmp/update_project_yml.py
            echo '        sys.exit(1)' >> /tmp/update_project_yml.py
            echo 'except Exception as e:' >> /tmp/update_project_yml.py
            echo '    print(f"⚠️  Error updating project.yml: {e}")' >> /tmp/update_project_yml.py
            echo '    print("Will continue with existing configuration")' >> /tmp/update_project_yml.py
            
            # Execute the Python script with the profile UUID as an environment variable
            PROFILE_UUID="$PROFILE_UUID" python3 /tmp/update_project_yml.py
            
            if [ $? -ne 0 ]; then
              echo "⚠️  Failed to update project.yml, but continuing..."
            fi
            
            # Verify the update worked
            if grep -q "PROVISIONING_PROFILE_SPECIFIER.*$PROFILE_UUID" project.yml; then
              echo "✅ Verified project.yml contains provisioning profile UUID"
            else
              echo "⚠️  Warning: project.yml might not have been updated correctly"
            fi
            
            echo "✅ Configured project.yml for manual signing with profile: $PROFILE_UUID"
          else
            echo "⚠️  No provisioning profile found, will use automatic signing"
          fi
        working-directory: ${{ github.workspace }}

      - name: Verify code signing setup
        run: |
          echo "=== Code Signing Verification ==="
          echo "Available certificates:"
          security find-identity -v -p codesigning || echo "No certificates found"
          echo ""
          echo "Available provisioning profiles:"
          ls -la ~/Library/MobileDevice/Provisioning\ Profiles/ || echo "No profiles found"
          echo ""
          echo "Default keychain:"
          security default-keychain || echo "No default keychain"
        working-directory: ${{ github.workspace }}

      - name: Build iOS app with Tauri CLI
        env:
          APPLE_DEVELOPMENT_TEAM: ${{ secrets.APPLE_DEVELOPMENT_TEAM }}
          CI: 'true'
          TAURI_BUILD: '1'
          RUST_BACKTRACE: '1'
        run: |
          # Explicitly export CI environment variables so they're available to all child processes
          # This includes Tauri's xcode-script which runs during Xcode build
          export CI=true
          export TAURI_BUILD=1
          export RUST_BACKTRACE=1

          echo "CI mode enabled - Tauri should skip dev server connection"
          echo "Environment variables: CI=$CI, TAURI_BUILD=$TAURI_BUILD"

          # Use Tauri CLI to build iOS app - it will respect the manual signing settings
          # configured in project.yml and use the imported certificates/profiles
          cd ${{ github.workspace }}
          bun tauri ios build
        working-directory: ${{ github.workspace }}

      # ============================================
      # Upload to TestFlight
      # ============================================
      - name: Find IPA file
        id: find-ipa
        run: |
          # Tauri ios build outputs IPA in src-tauri/gen/apple/build/arm64/APPNAME.ipa
          # Search in multiple possible locations
          IPA_PATH=$(find src-tauri/gen/apple/build -name "*.ipa" -type f 2>/dev/null | head -1)

          if [ -z "$IPA_PATH" ]; then
            # Try alternative locations
            IPA_PATH=$(find src-tauri/gen/apple -name "*.ipa" -type f 2>/dev/null | head -1)
          fi

          if [ -z "$IPA_PATH" ]; then
            echo "Error: IPA file not found"
            echo "Searching in common locations:"
            find src-tauri/gen/apple -name "*.ipa" -type f 2>/dev/null || echo "No IPA found in gen/apple"
            find src-tauri/target -name "*.ipa" -type f 2>/dev/null || echo "No IPA in target"
            echo "Build output directories:"
            ls -la src-tauri/gen/apple/build/ 2>/dev/null || echo "Build directory not found"
            exit 1
          fi

          echo "ipa_path=$IPA_PATH" >> $GITHUB_OUTPUT
          echo "Found IPA: $IPA_PATH"
          ls -lh "$IPA_PATH"

      - name: Create API key file
        run: |
          echo "${{ secrets.APPSTORE_CONNECT_API_KEY }}" > /tmp/api_key.p8
          chmod 600 /tmp/api_key.p8

      - name: Upload to TestFlight
        uses: apple-actions/upload-testflight-build@v1
        with:
          app-path: ${{ steps.find-ipa.outputs.ipa_path }}
          issuer-id: ${{ secrets.APPSTORE_CONNECT_ISSUER_ID }}
          api-key-id: ${{ secrets.APPSTORE_CONNECT_API_KEY_ID }}
          api-private-key: ${{ secrets.APPSTORE_CONNECT_API_KEY }}

      - name: Upload IPA artifact
        uses: actions/upload-artifact@v4
        with:
          name: ios-ipa-${{ github.ref_name }}
          path: ${{ steps.find-ipa.outputs.ipa_path }}
          retention-days: 30
