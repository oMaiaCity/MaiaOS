---
alwaysApply: true
---

## Version Management System

This project uses **semantic-release** with conventional commits for **centralized version management** across the entire monorepo. All services and libraries share the same version number.

### Centralized Version Sync

Versions are automatically synced across **all packages** in the monorepo:
- **All services**: `services/*/package.json` (app, me, etc.)
- **All libraries**: `libs/*/package.json` (all shared packages)
- **Tauri/Rust**: `services/app/src-tauri/Cargo.toml`
- **Tauri config**: `services/app/src-tauri/tauri.conf.json`
- **iOS**: `services/app/src-tauri/gen/apple/app_iOS/Info.plist`
- **iOS project**: `services/app/src-tauri/gen/apple/project.yml`

**Single Source of Truth:** Version is managed in `services/app/package.json` and automatically propagated to all other packages during release.

**Commands:**
- `bun version:sync <version>` - Manually sync specific version across all packages (from root)
- `bun release` - Run semantic-release (analyzes commits, bumps version, syncs all packages, creates release)
- `bun release:dry-run` - Test what semantic-release would do

### How Semantic Release Works

1. **Only runs on `main` branch** - Releases are only triggered when running on the `main` branch
2. Analyzes commits since last release using conventional commit format
3. Determines next version (patch/minor) based on commit types
4. **Syncs version across all packages** - Updates all `services/*/package.json` and `libs/*/package.json` files automatically
5. Updates platform-specific files (Cargo.toml, tauri.conf.json, iOS files)
6. Generates CHANGELOG.md
7. **Creates git tag** (e.g., `v0.2.0`) locally
8. **Creates GitHub release** with the tag (automatically pushes tag to GitHub)
9. Commits all changes (including all package.json files)

**Git Tags:** Semantic-release automatically creates git tags and pushes them to GitHub via the `@semantic-release/github` plugin. You don't need to manually push tags - they're handled automatically.

**Branch Protection:** Releases only happen on the `main` branch. Running `bun run release` on other branches will not create releases.

---

## Workflow

### Standard Workflow

1. Make changes
2. Stage changes: `git add .`
3. Commit with conventional format: `git commit -m "feat: description"`
4. Push: `git push`
5. Run semantic-release: `bun run release` (or let CI do it)

### Testing Before Release

Before running actual release, test what would happen:
```bash
bun run release:dry-run
```

This shows what version would be released without making any changes.

### Git Workflow: Use Rebase by Default

**Why rebasing matters for semantic-release:**
- **Linear history**: Creates a clean, linear commit history that's easier for semantic-release to analyze
- **Better commit analysis**: semantic-release analyzes commits since the last tag/release. A linear history makes it easier to identify which commits belong to which release
- **Cleaner CHANGELOG**: A linear history produces cleaner, more readable changelogs without merge commit noise
- **Easier debugging**: Linear history makes it easier to track down when bugs were introduced

**Recommended Git Configuration:**

```bash
# Set rebase as default for git pull
git config pull.rebase true

# Or set globally for all repositories
git config --global pull.rebase true

# Set rebase as default for git pull with merge strategy (safer)
git config pull.rebase merges

# Or globally
git config --global pull.rebase merges
```

**Workflow with Rebase:**

```bash
# When pulling updates from main
git pull --rebase

# When merging feature branches, use rebase first
git checkout feature-branch
git rebase main
git checkout main
git merge feature-branch  # This will be a fast-forward merge

# Or use GitHub's "Rebase and merge" option when merging PRs
```

**Benefits:**
- No unnecessary merge commits cluttering the history
- Each commit message is preserved and analyzed correctly by semantic-release
- Easier to see the actual changes that went into each release
- CHANGELOG.md is cleaner and more accurate

**Note:** Always rebase feature branches before merging to `main` to maintain a clean linear history. This ensures semantic-release can accurately analyze commits and generate proper version bumps.

---

## GitHub Actions Integration

Two workflows are set up for fully automated releases:

### 1. Release Workflow (`.github/workflows/release.yml`)

Runs semantic-release on pushes to `main`:
- Analyzes commits
- Bumps version
- Creates GitHub release with tag
- Generates CHANGELOG.md

### 2. iOS Release Workflow (`.github/workflows/ios-release.yml`)

Automatically triggers when a GitHub release is created:
- Builds frontend (SvelteKit)
- Builds iOS app (Tauri)
- Uploads IPA to TestFlight automatically

**Complete Flow:**
1. Commit with conventional format: `feat: new feature`
2. Push to `main`: `git push`
3. Release workflow runs ‚Üí Creates GitHub release
4. iOS workflow automatically triggers ‚Üí Builds & uploads to TestFlight
5. App appears in TestFlight! üéâ

**Required GitHub Secrets:**
- `APPSTORE_CONNECT_API_KEY` - Contents of `.p8` file from App Store Connect
- `APPSTORE_CONNECT_API_KEY_ID` - Key ID from App Store Connect
- `APPSTORE_CONNECT_ISSUER_ID` - Issuer ID from App Store Connect
- `APPLE_DEVELOPMENT_TEAM` - Your Team ID (e.g., `2P6VCHVJWB`)

See `.github/workflows/README.md` for detailed setup instructions.

---

## Quick Reference

**Want a Minor Bump (0.1.0 ‚Üí 0.2.0)?**
```bash
git commit -m "feat: your new feature"
```

**Want a Patch Bump (0.1.0 ‚Üí 0.1.1)?**
```bash
git commit -m "fix: your bug fix"
# OR
git commit -m "perf: your performance improvement"
```

**Want a Major Bump (0.1.0 ‚Üí 1.0.0)?**
‚ö†Ô∏è **MAJOR VERSION BUMPS ARE MANUAL ONLY** - No commits (including breaking changes) can trigger major version bumps automatically.

To manually trigger a major version bump:
```bash
# Automatically bumps to next major version (0.1.0 ‚Üí 1.0.0)
bun run release:major

# Or specify exact version
bun run release:major 1.0.0
```

This script will:
1. Sync version across all files (package.json, Cargo.toml, tauri.conf.json, iOS files)
2. Commit the version change
3. Create git tag

Then manually run semantic-release:
```bash
git push  # Push the version commit
bun run release  # Creates tag, GitHub release, and CHANGELOG automatically
```

**Note:** Semantic-release will automatically create and push the git tag to GitHub. You don't need to manually push tags - the `@semantic-release/github` plugin handles this.

**Important:** Breaking change commits (`feat!:` or `BREAKING CHANGE:`) will be documented in CHANGELOG but will **NOT** trigger automatic version bumps. Major bumps must be triggered manually using `bun run release:major`.

**Don't Want a Bump?**
```bash
git commit -m "docs: update documentation"
git commit -m "refactor: clean up code"
git commit -m "chore: update dependencies"
```

---

## Important Notes

- **ALWAYS use conventional commits** - This is required for semantic-release to work
- **Use rebase by default** - Maintain a linear commit history for better semantic-release analysis and cleaner changelogs
- **Version sync happens automatically** - When you run `bun run release`, all version files are updated
- **Test before releasing** - Use `bun run release:dry-run` to preview changes
- **Breaking changes** - Breaking change commits (`feat!:` or `BREAKING CHANGE:`) will be documented in CHANGELOG but will **NOT** trigger automatic major version bumps.
- **Major version bumps are manual only** - Use `bun run release:major` to manually trigger major version bump via semantic-release
- **Git tags are automatic** - Semantic-release creates and pushes tags to GitHub automatically - no manual tag pushing needed
