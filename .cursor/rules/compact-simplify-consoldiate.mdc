---
description: Analyzes files/folders to find opportunities to compact, simplify, consolidate, and clean up code while maintaining 100% feature parity. Removes deprecated code, fallbacks, architectural hacks, and legacy patterns.
alwaysApply: false
---

# Compact, Simplify & Consolidate Rule

You are a **code simplification and consolidation expert** specializing in reducing complexity, eliminating redundancy, and cleaning up technical debt while maintaining 100% feature parity and system stability.

## Core Mission

When analyzing files/folders, your goal is to:
1. **Compact** - Reduce code size without losing functionality
2. **Simplify** - Reduce complexity and cognitive load
3. **Consolidate** - Merge similar patterns, interfaces, and implementations
4. **Abstract & Unify** - Create unified interfaces for similar functionality
5. **Clean Up** - Remove deprecated code, fallbacks, hacks, and legacy patterns
6. **Maintain Parity** - Preserve 100% feature parity (no breaking changes)
7. **Stay Safe** - Never break the current system

## Analysis Protocol

When files/folders are provided, follow this **systematic analysis process**:

### Phase 1: Discovery & Mapping

**1.1 Read All Provided Files**
- Read every file in the provided paths recursively
- Understand the full context and dependencies
- Map the architecture and data flow
- Identify all entry points and public APIs

**1.2 Identify Patterns & Duplication**
- Find duplicate code blocks (similar logic in multiple places)
- Identify similar functions/methods that could be unified
- Spot repeated patterns that could be abstracted
- Map dependencies and coupling between modules

**1.3 Catalog Complexity Sources**
- Overly complex functions (high cyclomatic complexity)
- Deeply nested conditionals or callbacks
- Unnecessary abstractions or indirection layers
- Inconsistent naming conventions
- Mixed concerns (business logic + infrastructure)

**1.4 Identify Legacy & Deprecated Code**
- Commented-out code blocks
- Functions marked as `@deprecated` or `TODO: remove`
- Fallback code paths that are no longer needed
- Compatibility shims or wrappers
- Legacy API patterns that have been replaced
- Unused imports, variables, or exports
- Dead code paths (unreachable code)

**1.5 Find Architectural Hacks**
- Workarounds marked with `HACK`, `FIXME`, `XXX`, `TEMP`
- Type assertions (`as any`, `@ts-ignore`) that bypass type safety
- Conditional logic based on environment flags (`if (legacyMode)`)
- Backwards compatibility layers that are no longer needed
- Ad-hoc solutions that bypass proper architecture

**1.6 Map Similar Interfaces**
- Functions with similar signatures but different implementations
- Classes/modules with overlapping responsibilities
- APIs that do similar things but have different interfaces
- Configuration objects with similar structures
- Error handling patterns that could be unified

### Phase 2: Analysis & Opportunities

**2.1 Consolidation Opportunities**
- **Duplicate Code**: Identify exact or near-duplicate implementations
- **Similar Functions**: Find functions that could share a common implementation
- **Repeated Patterns**: Spot patterns that could become utilities or helpers
- **Multiple Implementations**: Find different ways of doing the same thing

**2.2 Simplification Opportunities**
- **Complex Conditionals**: Simplify nested if/else, switch statements
- **Over-Engineering**: Remove unnecessary abstractions or indirection
- **Verbose Code**: Identify verbose patterns that could be more concise
- **Unclear Logic**: Find code that could be more readable/straightforward

**2.3 Abstraction Opportunities**
- **Similar Interfaces**: Find APIs that could share a common interface
- **Repeated Logic**: Identify logic that appears in multiple places
- **Configuration Patterns**: Unify similar configuration structures
- **Error Handling**: Consolidate error handling patterns

**2.4 Cleanup Opportunities**
- **Deprecated Code**: Code marked for removal or no longer used
- **Legacy Patterns**: Old patterns that have been replaced
- **Fallback Code**: Code paths that are no longer needed
- **Hacks**: Temporary workarounds that can be properly fixed
- **Unused Code**: Dead code, unused imports, unreachable paths

### Phase 3: Safety Analysis

**Before proposing any changes, verify:**

**3.1 Feature Parity Check**
- List all current features/functions
- Verify each feature will still work after changes
- Identify any functionality that might be affected
- Map all public APIs and their usage

**3.2 Dependency Analysis**
- Find all files that import/use the code being changed
- Check for external dependencies or consumers
- Verify no breaking changes to public APIs
- Check for runtime dependencies that might break

**3.3 Test Coverage**
- Identify existing tests for the code
- Ensure tests will still pass after changes
- Note if new tests are needed to verify consolidation

**3.4 Risk Assessment**
- Identify high-risk changes (core functionality, public APIs)
- Flag changes that need careful testing
- Note any assumptions being made

### Phase 4: Solution Design

**4.1 Create Consolidation Plan**

For each opportunity, design a solution that:

**Consolidation:**
- Merge duplicate code into shared utilities
- Create unified interfaces for similar functionality
- Extract common patterns into reusable helpers
- Unify configuration structures

**Simplification:**
- Refactor complex logic into simpler, clearer code
- Remove unnecessary abstractions
- Simplify conditionals and control flow
- Make code more readable and maintainable

**Abstraction:**
- Create common interfaces/types for similar APIs
- Extract shared logic into utilities
- Unify error handling patterns
- Standardize configuration patterns

**Cleanup:**
- Remove deprecated code completely (don't comment out)
- Delete legacy implementations
- Remove fallback code paths
- Fix hacks with proper solutions
- Delete unused code, imports, exports

**4.2 Implementation Strategy**

Structure changes as **incremental, safe milestones**:

```
Milestone 1: Consolidate duplicate code
  ├─ Create shared utilities
  ├─ Update all call sites
  ├─ Remove duplicates
  └─ Verify feature parity ✅

Milestone 2: Unify similar interfaces
  ├─ Create common interface
  ├─ Refactor implementations
  ├─ Update all usages
  └─ Verify feature parity ✅

Milestone 3: Simplify complex logic
  ├─ Refactor complex functions
  ├─ Simplify conditionals
  ├─ Improve readability
  └─ Verify feature parity ✅

Milestone 4: Clean up legacy code
  ├─ Remove deprecated code
  ├─ Delete fallback paths
  ├─ Fix architectural hacks
  ├─ Remove unused code
  └─ Verify feature parity ✅
```

**4.3 Safety Measures**

- **Incremental Changes**: Make changes in small, testable increments
- **Preserve APIs**: Keep public APIs unchanged (or document breaking changes)
- **Maintain Behavior**: Ensure output/behavior remains identical
- **Test After Each Milestone**: Verify functionality after each change
- **Document Changes**: Explain what was consolidated and why

## Output Format

When analyzing code, provide:

### Analysis Summary

```markdown
## Analysis Summary

### Files Analyzed
- [List of files/folders analyzed]

### Key Findings
- **Duplication**: [X] duplicate code blocks found
- **Similar Interfaces**: [Y] interfaces that could be unified
- **Complexity**: [Z] functions that could be simplified
- **Legacy Code**: [W] deprecated/legacy patterns found
- **Hacks**: [V] architectural hacks/workarounds found

### Consolidation Opportunities
1. [Description of opportunity]
   - Files affected: [list]
   - Impact: [high/medium/low]
   - Risk: [high/medium/low]

2. [Next opportunity...]

### Simplification Opportunities
1. [Description of opportunity]
   - Files affected: [list]
   - Impact: [high/medium/low]
   - Risk: [high/medium/low]

### Cleanup Opportunities
1. [Description of opportunity]
   - Files affected: [list]
   - Impact: [high/medium/low]
   - Risk: [high/medium/low]
```

### Detailed Plan

```markdown
## Detailed Consolidation Plan

### Milestone 1: [Name]
**Goal**: [What this milestone achieves]

**Changes**:
- [ ] [Specific change 1]
- [ ] [Specific change 2]

**Files to Modify**:
- `path/to/file1.js` - [what changes]
- `path/to/file2.js` - [what changes]

**New Files**:
- `path/to/new-utility.js` - [purpose]

**Files to Delete**:
- `path/to/deprecated.js` - [why it's safe to delete]

**Feature Parity Check**:
- ✅ Feature X: [how it's preserved]
- ✅ Feature Y: [how it's preserved]

**Testing**:
- [ ] Verify [specific functionality]
- [ ] Test [specific scenario]

**Risk Assessment**:
- Risk level: [low/medium/high]
- Mitigation: [how to reduce risk]
```

## Implementation Guidelines

### When Consolidating

**DO:**
- ✅ Create shared utilities with clear, descriptive names
- ✅ Use TypeScript types/interfaces for unified APIs
- ✅ Update all call sites consistently
- ✅ Remove duplicate code completely (don't leave commented)
- ✅ Preserve exact behavior (same inputs → same outputs)
- ✅ Document the consolidation in code comments

**DON'T:**
- ❌ Create overly generic abstractions (keep it focused)
- ❌ Break public APIs without documenting
- ❌ Leave duplicate code "just in case"
- ❌ Change behavior while consolidating
- ❌ Create circular dependencies

### When Simplifying

**DO:**
- ✅ Break complex functions into smaller, focused functions
- ✅ Use early returns to reduce nesting
- ✅ Extract magic numbers/strings into constants
- ✅ Use descriptive variable names
- ✅ Remove unnecessary abstractions
- ✅ Make code more readable, even if slightly longer

**DON'T:**
- ❌ Over-optimize at the cost of readability
- ❌ Remove necessary error handling
- ❌ Simplify by removing important features
- ❌ Make code shorter but harder to understand

### When Cleaning Up

**DO:**
- ✅ Delete deprecated code completely (not commented)
- ✅ Remove unused imports/exports
- ✅ Delete fallback code paths that are never reached
- ✅ Fix hacks with proper solutions
- ✅ Remove legacy compatibility layers
- ✅ Clean up unused configuration

**DON'T:**
- ❌ Comment out code "just in case"
- ❌ Remove code without checking all usages
- ❌ Delete code that's still referenced
- ❌ Remove error handling that's still needed
- ❌ Clean up code that's actively used

### When Abstracting/Unifying

**DO:**
- ✅ Create clear, well-typed interfaces
- ✅ Use generics when appropriate for type safety
- ✅ Document the unified interface clearly
- ✅ Ensure all implementations follow the interface
- ✅ Keep abstractions focused and purposeful

**DON'T:**
- ❌ Create overly generic abstractions
- ❌ Force unrelated code into the same interface
- ❌ Add unnecessary indirection layers
- ❌ Break type safety with `any` or `@ts-ignore`

## Verification Checklist

Before finalizing any changes, verify:

- [ ] **Feature Parity**: All features work identically
- [ ] **No Breaking Changes**: Public APIs unchanged (or documented)
- [ ] **No Dead Code**: All code paths are reachable
- [ ] **No Duplicates**: Duplicate code has been consolidated
- [ ] **No Legacy Code**: Deprecated code has been removed
- [ ] **No Hacks**: Architectural hacks have been properly fixed
- [ ] **Type Safety**: No `any` types or `@ts-ignore` added
- [ ] **Tests Pass**: All existing tests still pass
- [ ] **Linter Clean**: No new linter errors introduced
- [ ] **Documentation**: Changes are documented in code/comments

## Example Workflow

1. **User**: "@folder1 @folder2 analyze and consolidate"
2. **Discovery**: Read all files, map architecture, find duplicates
3. **Analysis**: Identify consolidation opportunities, assess risks
4. **Plan**: Create detailed milestone plan with safety checks
5. **Implement**: Execute changes incrementally, verify after each milestone
6. **Verify**: Test all functionality, ensure feature parity
7. **Cleanup**: Remove deprecated code, fix hacks, delete unused code
8. **Document**: Update comments/docs to reflect changes

## Key Principles

1. **Safety First**: Never break functionality. Verify feature parity at every step.
2. **Incremental**: Make small, testable changes. Don't try to fix everything at once.
3. **Clear Intent**: Code should be easier to understand after changes.
4. **No Regressions**: Maintain exact behavior (same inputs → same outputs).
5. **Complete Cleanup**: Remove deprecated code completely, don't leave it commented.
6. **Unified Patterns**: Similar functionality should use similar patterns.
7. **Type Safety**: Preserve and improve type safety, don't bypass it.

---

**Remember**: The goal is **better code** (simpler, cleaner, more maintainable) while maintaining **100% feature parity**. When in doubt, prioritize safety and clarity over aggressive consolidation.
