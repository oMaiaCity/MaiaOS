function _mergeNamespaces(n, m) {
  for (var i = 0; i < m.length; i++) {
    const e = m[i];
    if (typeof e !== "string" && !Array.isArray(e)) {
      for (const k in e) {
        if (k !== "default" && !(k in n)) {
          const d = Object.getOwnPropertyDescriptor(e, k);
          if (d) {
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: () => e[k]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
const encoder = new TextEncoder();
const decoder = new TextDecoder();
function base64URLtoBytes(base64) {
  base64 = base64.replace(/=/g, "");
  const n = base64.length;
  const rem = n % 4;
  const k = rem && rem - 1;
  const m = (n >> 2) * 3 + k;
  const encoded = new Uint8Array(n + 3);
  encoder.encodeInto(base64 + "===", encoded);
  for (let i = 0, j = 0; i < n; i += 4, j += 3) {
    const x = (lookup[encoded[i]] << 18) + (lookup[encoded[i + 1]] << 12) + (lookup[encoded[i + 2]] << 6) + lookup[encoded[i + 3]];
    encoded[j] = x >> 16;
    encoded[j + 1] = x >> 8 & 255;
    encoded[j + 2] = x & 255;
  }
  return new Uint8Array(encoded.buffer, 0, m);
}
function bytesToBase64url(bytes) {
  const m = bytes.length;
  const k = m % 3;
  const n = Math.floor(m / 3) * 4 + (k && k + 1);
  const N = Math.ceil(m / 3) * 4;
  const encoded = new Uint8Array(N);
  for (let i = 0, j = 0; j < m; i += 4, j += 3) {
    const y = (bytes[j] << 16) + (bytes[j + 1] << 8) + (bytes[j + 2] | 0);
    encoded[i] = encodeLookup[y >> 18];
    encoded[i + 1] = encodeLookup[y >> 12 & 63];
    encoded[i + 2] = encodeLookup[y >> 6 & 63];
    encoded[i + 3] = encodeLookup[y & 63];
  }
  let base64 = decoder.decode(new Uint8Array(encoded.buffer, 0, n));
  if (k === 1)
    base64 += "==";
  if (k === 2)
    base64 += "=";
  return base64;
}
const alphabet$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
const lookup = new Uint8Array(128);
for (const [i, a] of Array.from(alphabet$1).entries()) {
  lookup[a.charCodeAt(0)] = i;
}
lookup["=".charCodeAt(0)] = 0;
const encodeLookup = new Uint8Array(64);
for (const [i, a] of Array.from(alphabet$1).entries()) {
  encodeLookup[i] = a.charCodeAt(0);
}
var _globalThis = typeof globalThis === "object" ? globalThis : typeof self === "object" ? self : typeof window === "object" ? window : typeof globalThis === "object" ? globalThis : {};
var VERSION = "1.9.0";
var re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
function _makeCompatibilityCheck(ownVersion) {
  var acceptedVersions = /* @__PURE__ */ new Set([ownVersion]);
  var rejectedVersions = /* @__PURE__ */ new Set();
  var myVersionMatch = ownVersion.match(re);
  if (!myVersionMatch) {
    return function() {
      return false;
    };
  }
  var ownVersionParsed = {
    major: +myVersionMatch[1],
    minor: +myVersionMatch[2],
    patch: +myVersionMatch[3],
    prerelease: myVersionMatch[4]
  };
  if (ownVersionParsed.prerelease != null) {
    return function isExactmatch(globalVersion) {
      return globalVersion === ownVersion;
    };
  }
  function _reject(v) {
    rejectedVersions.add(v);
    return false;
  }
  function _accept(v) {
    acceptedVersions.add(v);
    return true;
  }
  return function isCompatible2(globalVersion) {
    if (acceptedVersions.has(globalVersion)) {
      return true;
    }
    if (rejectedVersions.has(globalVersion)) {
      return false;
    }
    var globalVersionMatch = globalVersion.match(re);
    if (!globalVersionMatch) {
      return _reject(globalVersion);
    }
    var globalVersionParsed = {
      major: +globalVersionMatch[1],
      minor: +globalVersionMatch[2],
      patch: +globalVersionMatch[3],
      prerelease: globalVersionMatch[4]
    };
    if (globalVersionParsed.prerelease != null) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major !== globalVersionParsed.major) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major === 0) {
      if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
        return _accept(globalVersion);
      }
      return _reject(globalVersion);
    }
    if (ownVersionParsed.minor <= globalVersionParsed.minor) {
      return _accept(globalVersion);
    }
    return _reject(globalVersion);
  };
}
var isCompatible = _makeCompatibilityCheck(VERSION);
var major = VERSION.split(".")[0];
var GLOBAL_OPENTELEMETRY_API_KEY = /* @__PURE__ */ Symbol.for("opentelemetry.js.api." + major);
var _global = _globalThis;
function registerGlobal(type2, instance, diag, allowOverride) {
  var _a;
  if (allowOverride === void 0) {
    allowOverride = false;
  }
  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a !== void 0 ? _a : {
    version: VERSION
  };
  if (!allowOverride && api[type2]) {
    var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type2);
    diag.error(err.stack || err.message);
    return false;
  }
  if (api.version !== VERSION) {
    var err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type2 + " does not match previously registered API v" + VERSION);
    diag.error(err.stack || err.message);
    return false;
  }
  api[type2] = instance;
  diag.debug("@opentelemetry/api: Registered a global for " + type2 + " v" + VERSION + ".");
  return true;
}
function getGlobal(type2) {
  var _a, _b;
  var globalVersion = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a === void 0 ? void 0 : _a.version;
  if (!globalVersion || !isCompatible(globalVersion)) {
    return;
  }
  return (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === void 0 ? void 0 : _b[type2];
}
function unregisterGlobal(type2, diag) {
  diag.debug("@opentelemetry/api: Unregistering a global for " + type2 + " v" + VERSION + ".");
  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
  if (api) {
    delete api[type2];
  }
}
var __read$4 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray$3 = function(to, from, pack) {
  if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var DiagComponentLogger = (
  /** @class */
  (function() {
    function DiagComponentLogger2(props) {
      this._namespace = props.namespace || "DiagComponentLogger";
    }
    DiagComponentLogger2.prototype.debug = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("debug", this._namespace, args);
    };
    DiagComponentLogger2.prototype.error = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("error", this._namespace, args);
    };
    DiagComponentLogger2.prototype.info = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("info", this._namespace, args);
    };
    DiagComponentLogger2.prototype.warn = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("warn", this._namespace, args);
    };
    DiagComponentLogger2.prototype.verbose = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("verbose", this._namespace, args);
    };
    return DiagComponentLogger2;
  })()
);
function logProxy(funcName, namespace, args) {
  var logger2 = getGlobal("diag");
  if (!logger2) {
    return;
  }
  args.unshift(namespace);
  return logger2[funcName].apply(logger2, __spreadArray$3([], __read$4(args), false));
}
var DiagLogLevel;
(function(DiagLogLevel2) {
  DiagLogLevel2[DiagLogLevel2["NONE"] = 0] = "NONE";
  DiagLogLevel2[DiagLogLevel2["ERROR"] = 30] = "ERROR";
  DiagLogLevel2[DiagLogLevel2["WARN"] = 50] = "WARN";
  DiagLogLevel2[DiagLogLevel2["INFO"] = 60] = "INFO";
  DiagLogLevel2[DiagLogLevel2["DEBUG"] = 70] = "DEBUG";
  DiagLogLevel2[DiagLogLevel2["VERBOSE"] = 80] = "VERBOSE";
  DiagLogLevel2[DiagLogLevel2["ALL"] = 9999] = "ALL";
})(DiagLogLevel || (DiagLogLevel = {}));
function createLogLevelDiagLogger(maxLevel, logger2) {
  if (maxLevel < DiagLogLevel.NONE) {
    maxLevel = DiagLogLevel.NONE;
  } else if (maxLevel > DiagLogLevel.ALL) {
    maxLevel = DiagLogLevel.ALL;
  }
  logger2 = logger2 || {};
  function _filterFunc(funcName, theLevel) {
    var theFunc = logger2[funcName];
    if (typeof theFunc === "function" && maxLevel >= theLevel) {
      return theFunc.bind(logger2);
    }
    return function() {
    };
  }
  return {
    error: _filterFunc("error", DiagLogLevel.ERROR),
    warn: _filterFunc("warn", DiagLogLevel.WARN),
    info: _filterFunc("info", DiagLogLevel.INFO),
    debug: _filterFunc("debug", DiagLogLevel.DEBUG),
    verbose: _filterFunc("verbose", DiagLogLevel.VERBOSE)
  };
}
var __read$3 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray$2 = function(to, from, pack) {
  if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME$4 = "diag";
var DiagAPI = (
  /** @class */
  (function() {
    function DiagAPI2() {
      function _logProxy(funcName) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var logger2 = getGlobal("diag");
          if (!logger2)
            return;
          return logger2[funcName].apply(logger2, __spreadArray$2([], __read$3(args), false));
        };
      }
      var self2 = this;
      var setLogger = function(logger2, optionsOrLogLevel) {
        var _a, _b, _c;
        if (optionsOrLogLevel === void 0) {
          optionsOrLogLevel = { logLevel: DiagLogLevel.INFO };
        }
        if (logger2 === self2) {
          var err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
          self2.error((_a = err.stack) !== null && _a !== void 0 ? _a : err.message);
          return false;
        }
        if (typeof optionsOrLogLevel === "number") {
          optionsOrLogLevel = {
            logLevel: optionsOrLogLevel
          };
        }
        var oldLogger = getGlobal("diag");
        var newLogger = createLogLevelDiagLogger((_b = optionsOrLogLevel.logLevel) !== null && _b !== void 0 ? _b : DiagLogLevel.INFO, logger2);
        if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
          var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : "<failed to generate stacktrace>";
          oldLogger.warn("Current logger will be overwritten from " + stack);
          newLogger.warn("Current logger will overwrite one already registered from " + stack);
        }
        return registerGlobal("diag", newLogger, self2, true);
      };
      self2.setLogger = setLogger;
      self2.disable = function() {
        unregisterGlobal(API_NAME$4, self2);
      };
      self2.createComponentLogger = function(options) {
        return new DiagComponentLogger(options);
      };
      self2.verbose = _logProxy("verbose");
      self2.debug = _logProxy("debug");
      self2.info = _logProxy("info");
      self2.warn = _logProxy("warn");
      self2.error = _logProxy("error");
    }
    DiagAPI2.instance = function() {
      if (!this._instance) {
        this._instance = new DiagAPI2();
      }
      return this._instance;
    };
    return DiagAPI2;
  })()
);
var __read$2 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __values = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var BaggageImpl = (
  /** @class */
  (function() {
    function BaggageImpl2(entries) {
      this._entries = entries ? new Map(entries) : /* @__PURE__ */ new Map();
    }
    BaggageImpl2.prototype.getEntry = function(key) {
      var entry = this._entries.get(key);
      if (!entry) {
        return void 0;
      }
      return Object.assign({}, entry);
    };
    BaggageImpl2.prototype.getAllEntries = function() {
      return Array.from(this._entries.entries()).map(function(_a) {
        var _b = __read$2(_a, 2), k = _b[0], v = _b[1];
        return [k, v];
      });
    };
    BaggageImpl2.prototype.setEntry = function(key, entry) {
      var newBaggage = new BaggageImpl2(this._entries);
      newBaggage._entries.set(key, entry);
      return newBaggage;
    };
    BaggageImpl2.prototype.removeEntry = function(key) {
      var newBaggage = new BaggageImpl2(this._entries);
      newBaggage._entries.delete(key);
      return newBaggage;
    };
    BaggageImpl2.prototype.removeEntries = function() {
      var e_1, _a;
      var keys = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        keys[_i] = arguments[_i];
      }
      var newBaggage = new BaggageImpl2(this._entries);
      try {
        for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
          var key = keys_1_1.value;
          newBaggage._entries.delete(key);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      return newBaggage;
    };
    BaggageImpl2.prototype.clear = function() {
      return new BaggageImpl2();
    };
    return BaggageImpl2;
  })()
);
DiagAPI.instance();
function createBaggage(entries) {
  if (entries === void 0) {
    entries = {};
  }
  return new BaggageImpl(new Map(Object.entries(entries)));
}
function createContextKey(description2) {
  return Symbol.for(description2);
}
var BaseContext = (
  /** @class */
  /* @__PURE__ */ (function() {
    function BaseContext2(parentContext) {
      var self2 = this;
      self2._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();
      self2.getValue = function(key) {
        return self2._currentContext.get(key);
      };
      self2.setValue = function(key, value) {
        var context = new BaseContext2(self2._currentContext);
        context._currentContext.set(key, value);
        return context;
      };
      self2.deleteValue = function(key) {
        var context = new BaseContext2(self2._currentContext);
        context._currentContext.delete(key);
        return context;
      };
    }
    return BaseContext2;
  })()
);
var ROOT_CONTEXT = new BaseContext();
var __extends = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var NoopMeter = (
  /** @class */
  (function() {
    function NoopMeter2() {
    }
    NoopMeter2.prototype.createGauge = function(_name, _options) {
      return NOOP_GAUGE_METRIC;
    };
    NoopMeter2.prototype.createHistogram = function(_name, _options) {
      return NOOP_HISTOGRAM_METRIC;
    };
    NoopMeter2.prototype.createCounter = function(_name, _options) {
      return NOOP_COUNTER_METRIC;
    };
    NoopMeter2.prototype.createUpDownCounter = function(_name, _options) {
      return NOOP_UP_DOWN_COUNTER_METRIC;
    };
    NoopMeter2.prototype.createObservableGauge = function(_name, _options) {
      return NOOP_OBSERVABLE_GAUGE_METRIC;
    };
    NoopMeter2.prototype.createObservableCounter = function(_name, _options) {
      return NOOP_OBSERVABLE_COUNTER_METRIC;
    };
    NoopMeter2.prototype.createObservableUpDownCounter = function(_name, _options) {
      return NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
    };
    NoopMeter2.prototype.addBatchObservableCallback = function(_callback, _observables) {
    };
    NoopMeter2.prototype.removeBatchObservableCallback = function(_callback) {
    };
    return NoopMeter2;
  })()
);
var NoopMetric = (
  /** @class */
  /* @__PURE__ */ (function() {
    function NoopMetric2() {
    }
    return NoopMetric2;
  })()
);
var NoopCounterMetric = (
  /** @class */
  (function(_super) {
    __extends(NoopCounterMetric2, _super);
    function NoopCounterMetric2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    NoopCounterMetric2.prototype.add = function(_value, _attributes) {
    };
    return NoopCounterMetric2;
  })(NoopMetric)
);
var NoopUpDownCounterMetric = (
  /** @class */
  (function(_super) {
    __extends(NoopUpDownCounterMetric2, _super);
    function NoopUpDownCounterMetric2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    NoopUpDownCounterMetric2.prototype.add = function(_value, _attributes) {
    };
    return NoopUpDownCounterMetric2;
  })(NoopMetric)
);
var NoopGaugeMetric = (
  /** @class */
  (function(_super) {
    __extends(NoopGaugeMetric2, _super);
    function NoopGaugeMetric2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    NoopGaugeMetric2.prototype.record = function(_value, _attributes) {
    };
    return NoopGaugeMetric2;
  })(NoopMetric)
);
var NoopHistogramMetric = (
  /** @class */
  (function(_super) {
    __extends(NoopHistogramMetric2, _super);
    function NoopHistogramMetric2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    NoopHistogramMetric2.prototype.record = function(_value, _attributes) {
    };
    return NoopHistogramMetric2;
  })(NoopMetric)
);
var NoopObservableMetric = (
  /** @class */
  (function() {
    function NoopObservableMetric2() {
    }
    NoopObservableMetric2.prototype.addCallback = function(_callback) {
    };
    NoopObservableMetric2.prototype.removeCallback = function(_callback) {
    };
    return NoopObservableMetric2;
  })()
);
var NoopObservableCounterMetric = (
  /** @class */
  (function(_super) {
    __extends(NoopObservableCounterMetric2, _super);
    function NoopObservableCounterMetric2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return NoopObservableCounterMetric2;
  })(NoopObservableMetric)
);
var NoopObservableGaugeMetric = (
  /** @class */
  (function(_super) {
    __extends(NoopObservableGaugeMetric2, _super);
    function NoopObservableGaugeMetric2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return NoopObservableGaugeMetric2;
  })(NoopObservableMetric)
);
var NoopObservableUpDownCounterMetric = (
  /** @class */
  (function(_super) {
    __extends(NoopObservableUpDownCounterMetric2, _super);
    function NoopObservableUpDownCounterMetric2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return NoopObservableUpDownCounterMetric2;
  })(NoopObservableMetric)
);
var NOOP_METER = new NoopMeter();
var NOOP_COUNTER_METRIC = new NoopCounterMetric();
var NOOP_GAUGE_METRIC = new NoopGaugeMetric();
var NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric();
var NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric();
var NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric();
var NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric();
var NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric();
var ValueType;
(function(ValueType2) {
  ValueType2[ValueType2["INT"] = 0] = "INT";
  ValueType2[ValueType2["DOUBLE"] = 1] = "DOUBLE";
})(ValueType || (ValueType = {}));
var defaultTextMapGetter = {
  get: function(carrier, key) {
    if (carrier == null) {
      return void 0;
    }
    return carrier[key];
  },
  keys: function(carrier) {
    if (carrier == null) {
      return [];
    }
    return Object.keys(carrier);
  }
};
var defaultTextMapSetter = {
  set: function(carrier, key, value) {
    if (carrier == null) {
      return;
    }
    carrier[key] = value;
  }
};
var __read$1 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray$1 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var NoopContextManager = (
  /** @class */
  (function() {
    function NoopContextManager2() {
    }
    NoopContextManager2.prototype.active = function() {
      return ROOT_CONTEXT;
    };
    NoopContextManager2.prototype.with = function(_context, fn, thisArg) {
      var args = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
      }
      return fn.call.apply(fn, __spreadArray$1([thisArg], __read$1(args), false));
    };
    NoopContextManager2.prototype.bind = function(_context, target) {
      return target;
    };
    NoopContextManager2.prototype.enable = function() {
      return this;
    };
    NoopContextManager2.prototype.disable = function() {
      return this;
    };
    return NoopContextManager2;
  })()
);
var __read = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray = function(to, from, pack) {
  if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME$3 = "context";
var NOOP_CONTEXT_MANAGER = new NoopContextManager();
var ContextAPI = (
  /** @class */
  (function() {
    function ContextAPI2() {
    }
    ContextAPI2.getInstance = function() {
      if (!this._instance) {
        this._instance = new ContextAPI2();
      }
      return this._instance;
    };
    ContextAPI2.prototype.setGlobalContextManager = function(contextManager) {
      return registerGlobal(API_NAME$3, contextManager, DiagAPI.instance());
    };
    ContextAPI2.prototype.active = function() {
      return this._getContextManager().active();
    };
    ContextAPI2.prototype.with = function(context, fn, thisArg) {
      var _a;
      var args = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
      }
      return (_a = this._getContextManager()).with.apply(_a, __spreadArray([context, fn, thisArg], __read(args), false));
    };
    ContextAPI2.prototype.bind = function(context, target) {
      return this._getContextManager().bind(context, target);
    };
    ContextAPI2.prototype._getContextManager = function() {
      return getGlobal(API_NAME$3) || NOOP_CONTEXT_MANAGER;
    };
    ContextAPI2.prototype.disable = function() {
      this._getContextManager().disable();
      unregisterGlobal(API_NAME$3, DiagAPI.instance());
    };
    return ContextAPI2;
  })()
);
var TraceFlags;
(function(TraceFlags2) {
  TraceFlags2[TraceFlags2["NONE"] = 0] = "NONE";
  TraceFlags2[TraceFlags2["SAMPLED"] = 1] = "SAMPLED";
})(TraceFlags || (TraceFlags = {}));
var INVALID_SPANID = "0000000000000000";
var INVALID_TRACEID = "00000000000000000000000000000000";
var INVALID_SPAN_CONTEXT = {
  traceId: INVALID_TRACEID,
  spanId: INVALID_SPANID,
  traceFlags: TraceFlags.NONE
};
var NonRecordingSpan = (
  /** @class */
  (function() {
    function NonRecordingSpan2(_spanContext) {
      if (_spanContext === void 0) {
        _spanContext = INVALID_SPAN_CONTEXT;
      }
      this._spanContext = _spanContext;
    }
    NonRecordingSpan2.prototype.spanContext = function() {
      return this._spanContext;
    };
    NonRecordingSpan2.prototype.setAttribute = function(_key, _value) {
      return this;
    };
    NonRecordingSpan2.prototype.setAttributes = function(_attributes) {
      return this;
    };
    NonRecordingSpan2.prototype.addEvent = function(_name, _attributes) {
      return this;
    };
    NonRecordingSpan2.prototype.addLink = function(_link) {
      return this;
    };
    NonRecordingSpan2.prototype.addLinks = function(_links) {
      return this;
    };
    NonRecordingSpan2.prototype.setStatus = function(_status) {
      return this;
    };
    NonRecordingSpan2.prototype.updateName = function(_name) {
      return this;
    };
    NonRecordingSpan2.prototype.end = function(_endTime) {
    };
    NonRecordingSpan2.prototype.isRecording = function() {
      return false;
    };
    NonRecordingSpan2.prototype.recordException = function(_exception, _time) {
    };
    return NonRecordingSpan2;
  })()
);
var SPAN_KEY = createContextKey("OpenTelemetry Context Key SPAN");
function getSpan(context) {
  return context.getValue(SPAN_KEY) || void 0;
}
function getActiveSpan() {
  return getSpan(ContextAPI.getInstance().active());
}
function setSpan(context, span) {
  return context.setValue(SPAN_KEY, span);
}
function deleteSpan(context) {
  return context.deleteValue(SPAN_KEY);
}
function setSpanContext(context, spanContext) {
  return setSpan(context, new NonRecordingSpan(spanContext));
}
function getSpanContext(context) {
  var _a;
  return (_a = getSpan(context)) === null || _a === void 0 ? void 0 : _a.spanContext();
}
var VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
var VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
function isValidTraceId(traceId) {
  return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;
}
function isValidSpanId(spanId) {
  return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;
}
function isSpanContextValid(spanContext) {
  return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
}
function wrapSpanContext(spanContext) {
  return new NonRecordingSpan(spanContext);
}
var contextApi = ContextAPI.getInstance();
var NoopTracer = (
  /** @class */
  (function() {
    function NoopTracer2() {
    }
    NoopTracer2.prototype.startSpan = function(name, options, context) {
      if (context === void 0) {
        context = contextApi.active();
      }
      var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
      if (root) {
        return new NonRecordingSpan();
      }
      var parentFromContext = context && getSpanContext(context);
      if (isSpanContext(parentFromContext) && isSpanContextValid(parentFromContext)) {
        return new NonRecordingSpan(parentFromContext);
      } else {
        return new NonRecordingSpan();
      }
    };
    NoopTracer2.prototype.startActiveSpan = function(name, arg2, arg3, arg4) {
      var opts;
      var ctx;
      var fn;
      if (arguments.length < 2) {
        return;
      } else if (arguments.length === 2) {
        fn = arg2;
      } else if (arguments.length === 3) {
        opts = arg2;
        fn = arg3;
      } else {
        opts = arg2;
        ctx = arg3;
        fn = arg4;
      }
      var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi.active();
      var span = this.startSpan(name, opts, parentContext);
      var contextWithSpanSet = setSpan(parentContext, span);
      return contextApi.with(contextWithSpanSet, fn, void 0, span);
    };
    return NoopTracer2;
  })()
);
function isSpanContext(spanContext) {
  return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
}
var NOOP_TRACER = new NoopTracer();
var ProxyTracer = (
  /** @class */
  (function() {
    function ProxyTracer2(_provider, name, version, options) {
      this._provider = _provider;
      this.name = name;
      this.version = version;
      this.options = options;
    }
    ProxyTracer2.prototype.startSpan = function(name, options, context) {
      return this._getTracer().startSpan(name, options, context);
    };
    ProxyTracer2.prototype.startActiveSpan = function(_name, _options, _context, _fn) {
      var tracer = this._getTracer();
      return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
    };
    ProxyTracer2.prototype._getTracer = function() {
      if (this._delegate) {
        return this._delegate;
      }
      var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
      if (!tracer) {
        return NOOP_TRACER;
      }
      this._delegate = tracer;
      return this._delegate;
    };
    return ProxyTracer2;
  })()
);
var NoopTracerProvider = (
  /** @class */
  (function() {
    function NoopTracerProvider2() {
    }
    NoopTracerProvider2.prototype.getTracer = function(_name, _version, _options) {
      return new NoopTracer();
    };
    return NoopTracerProvider2;
  })()
);
var NOOP_TRACER_PROVIDER = new NoopTracerProvider();
var ProxyTracerProvider = (
  /** @class */
  (function() {
    function ProxyTracerProvider2() {
    }
    ProxyTracerProvider2.prototype.getTracer = function(name, version, options) {
      var _a;
      return (_a = this.getDelegateTracer(name, version, options)) !== null && _a !== void 0 ? _a : new ProxyTracer(this, name, version, options);
    };
    ProxyTracerProvider2.prototype.getDelegate = function() {
      var _a;
      return (_a = this._delegate) !== null && _a !== void 0 ? _a : NOOP_TRACER_PROVIDER;
    };
    ProxyTracerProvider2.prototype.setDelegate = function(delegate) {
      this._delegate = delegate;
    };
    ProxyTracerProvider2.prototype.getDelegateTracer = function(name, version, options) {
      var _a;
      return (_a = this._delegate) === null || _a === void 0 ? void 0 : _a.getTracer(name, version, options);
    };
    return ProxyTracerProvider2;
  })()
);
ContextAPI.getInstance();
DiagAPI.instance();
var NoopMeterProvider = (
  /** @class */
  (function() {
    function NoopMeterProvider2() {
    }
    NoopMeterProvider2.prototype.getMeter = function(_name, _version, _options) {
      return NOOP_METER;
    };
    return NoopMeterProvider2;
  })()
);
var NOOP_METER_PROVIDER = new NoopMeterProvider();
var API_NAME$2 = "metrics";
var MetricsAPI = (
  /** @class */
  (function() {
    function MetricsAPI2() {
    }
    MetricsAPI2.getInstance = function() {
      if (!this._instance) {
        this._instance = new MetricsAPI2();
      }
      return this._instance;
    };
    MetricsAPI2.prototype.setGlobalMeterProvider = function(provider) {
      return registerGlobal(API_NAME$2, provider, DiagAPI.instance());
    };
    MetricsAPI2.prototype.getMeterProvider = function() {
      return getGlobal(API_NAME$2) || NOOP_METER_PROVIDER;
    };
    MetricsAPI2.prototype.getMeter = function(name, version, options) {
      return this.getMeterProvider().getMeter(name, version, options);
    };
    MetricsAPI2.prototype.disable = function() {
      unregisterGlobal(API_NAME$2, DiagAPI.instance());
    };
    return MetricsAPI2;
  })()
);
var metrics = MetricsAPI.getInstance();
var NoopTextMapPropagator = (
  /** @class */
  (function() {
    function NoopTextMapPropagator2() {
    }
    NoopTextMapPropagator2.prototype.inject = function(_context, _carrier) {
    };
    NoopTextMapPropagator2.prototype.extract = function(context, _carrier) {
      return context;
    };
    NoopTextMapPropagator2.prototype.fields = function() {
      return [];
    };
    return NoopTextMapPropagator2;
  })()
);
var BAGGAGE_KEY = createContextKey("OpenTelemetry Baggage Key");
function getBaggage(context) {
  return context.getValue(BAGGAGE_KEY) || void 0;
}
function getActiveBaggage() {
  return getBaggage(ContextAPI.getInstance().active());
}
function setBaggage(context, baggage) {
  return context.setValue(BAGGAGE_KEY, baggage);
}
function deleteBaggage(context) {
  return context.deleteValue(BAGGAGE_KEY);
}
var API_NAME$1 = "propagation";
var NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator();
var PropagationAPI = (
  /** @class */
  (function() {
    function PropagationAPI2() {
      this.createBaggage = createBaggage;
      this.getBaggage = getBaggage;
      this.getActiveBaggage = getActiveBaggage;
      this.setBaggage = setBaggage;
      this.deleteBaggage = deleteBaggage;
    }
    PropagationAPI2.getInstance = function() {
      if (!this._instance) {
        this._instance = new PropagationAPI2();
      }
      return this._instance;
    };
    PropagationAPI2.prototype.setGlobalPropagator = function(propagator) {
      return registerGlobal(API_NAME$1, propagator, DiagAPI.instance());
    };
    PropagationAPI2.prototype.inject = function(context, carrier, setter) {
      if (setter === void 0) {
        setter = defaultTextMapSetter;
      }
      return this._getGlobalPropagator().inject(context, carrier, setter);
    };
    PropagationAPI2.prototype.extract = function(context, carrier, getter) {
      if (getter === void 0) {
        getter = defaultTextMapGetter;
      }
      return this._getGlobalPropagator().extract(context, carrier, getter);
    };
    PropagationAPI2.prototype.fields = function() {
      return this._getGlobalPropagator().fields();
    };
    PropagationAPI2.prototype.disable = function() {
      unregisterGlobal(API_NAME$1, DiagAPI.instance());
    };
    PropagationAPI2.prototype._getGlobalPropagator = function() {
      return getGlobal(API_NAME$1) || NOOP_TEXT_MAP_PROPAGATOR;
    };
    return PropagationAPI2;
  })()
);
PropagationAPI.getInstance();
var API_NAME = "trace";
var TraceAPI = (
  /** @class */
  (function() {
    function TraceAPI2() {
      this._proxyTracerProvider = new ProxyTracerProvider();
      this.wrapSpanContext = wrapSpanContext;
      this.isSpanContextValid = isSpanContextValid;
      this.deleteSpan = deleteSpan;
      this.getSpan = getSpan;
      this.getActiveSpan = getActiveSpan;
      this.getSpanContext = getSpanContext;
      this.setSpan = setSpan;
      this.setSpanContext = setSpanContext;
    }
    TraceAPI2.getInstance = function() {
      if (!this._instance) {
        this._instance = new TraceAPI2();
      }
      return this._instance;
    };
    TraceAPI2.prototype.setGlobalTracerProvider = function(provider) {
      var success = registerGlobal(API_NAME, this._proxyTracerProvider, DiagAPI.instance());
      if (success) {
        this._proxyTracerProvider.setDelegate(provider);
      }
      return success;
    };
    TraceAPI2.prototype.getTracerProvider = function() {
      return getGlobal(API_NAME) || this._proxyTracerProvider;
    };
    TraceAPI2.prototype.getTracer = function(name, version) {
      return this.getTracerProvider().getTracer(name, version);
    };
    TraceAPI2.prototype.disable = function() {
      unregisterGlobal(API_NAME, DiagAPI.instance());
      this._proxyTracerProvider = new ProxyTracerProvider();
    };
    return TraceAPI2;
  })()
);
TraceAPI.getInstance();
class RawUnknownCoValue {
  constructor(core2) {
    this.totalValidTransactions = 0;
    this.version = 0;
    this.id = core2.id;
    this.core = core2;
  }
  get type() {
    return this.core.verified.header.type;
  }
  get headerMeta() {
    return this.core.verified.header.meta;
  }
  /** @category 6. Meta */
  get group() {
    return this.core.getGroup();
  }
  toJSON() {
    return {};
  }
  atTime() {
    return this;
  }
  subscribe(listener) {
    return this.core.subscribe((core2) => {
      listener(core2.getCurrentContent());
    });
  }
  processNewTransactions() {
  }
  rebuildFromCore() {
  }
}
function isBytes(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function isArrayOf(isString, arr) {
  if (!Array.isArray(arr))
    return false;
  if (arr.length === 0)
    return true;
  if (isString) {
    return arr.every((item) => typeof item === "string");
  } else {
    return arr.every((item) => Number.isSafeInteger(item));
  }
}
function astr(label, input) {
  if (typeof input !== "string")
    throw new Error(`${label}: string expected`);
  return true;
}
function anumber(n) {
  if (!Number.isSafeInteger(n))
    throw new Error(`invalid integer: ${n}`);
}
function aArr(input) {
  if (!Array.isArray(input))
    throw new Error("array expected");
}
function astrArr(label, input) {
  if (!isArrayOf(true, input))
    throw new Error(`${label}: array of strings expected`);
}
function anumArr(label, input) {
  if (!isArrayOf(false, input))
    throw new Error(`${label}: array of numbers expected`);
}
// @__NO_SIDE_EFFECTS__
function chain(...args) {
  const id2 = (a) => a;
  const wrap = (a, b) => (c) => a(b(c));
  const encode = args.map((x) => x.encode).reduceRight(wrap, id2);
  const decode = args.map((x) => x.decode).reduce(wrap, id2);
  return { encode, decode };
}
// @__NO_SIDE_EFFECTS__
function alphabet(letters) {
  const lettersA = typeof letters === "string" ? letters.split("") : letters;
  const len = lettersA.length;
  astrArr("alphabet", lettersA);
  const indexes = new Map(lettersA.map((l, i) => [l, i]));
  return {
    encode: (digits) => {
      aArr(digits);
      return digits.map((i) => {
        if (!Number.isSafeInteger(i) || i < 0 || i >= len)
          throw new Error(`alphabet.encode: digit index outside alphabet "${i}". Allowed: ${letters}`);
        return lettersA[i];
      });
    },
    decode: (input) => {
      aArr(input);
      return input.map((letter) => {
        astr("alphabet.decode", letter);
        const i = indexes.get(letter);
        if (i === void 0)
          throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
        return i;
      });
    }
  };
}
// @__NO_SIDE_EFFECTS__
function join(separator = "") {
  astr("join", separator);
  return {
    encode: (from) => {
      astrArr("join.decode", from);
      return from.join(separator);
    },
    decode: (to) => {
      astr("join.decode", to);
      return to.split(separator);
    }
  };
}
function convertRadix(data2, from, to) {
  if (from < 2)
    throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);
  if (to < 2)
    throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);
  aArr(data2);
  if (!data2.length)
    return [];
  let pos = 0;
  const res = [];
  const digits = Array.from(data2, (d) => {
    anumber(d);
    if (d < 0 || d >= from)
      throw new Error(`invalid integer: ${d}`);
    return d;
  });
  const dlen = digits.length;
  while (true) {
    let carry = 0;
    let done = true;
    for (let i = pos; i < dlen; i++) {
      const digit = digits[i];
      const fromCarry = from * carry;
      const digitBase = fromCarry + digit;
      if (!Number.isSafeInteger(digitBase) || fromCarry / from !== carry || digitBase - digit !== fromCarry) {
        throw new Error("convertRadix: carry overflow");
      }
      const div = digitBase / to;
      carry = digitBase % to;
      const rounded = Math.floor(div);
      digits[i] = rounded;
      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)
        throw new Error("convertRadix: carry overflow");
      if (!done)
        continue;
      else if (!rounded)
        pos = i;
      else
        done = false;
    }
    res.push(carry);
    if (done)
      break;
  }
  for (let i = 0; i < data2.length - 1 && data2[i] === 0; i++)
    res.push(0);
  return res.reverse();
}
// @__NO_SIDE_EFFECTS__
function radix(num) {
  anumber(num);
  const _256 = 2 ** 8;
  return {
    encode: (bytes) => {
      if (!isBytes(bytes))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix(Array.from(bytes), _256, num);
    },
    decode: (digits) => {
      anumArr("radix.decode", digits);
      return Uint8Array.from(convertRadix(digits, num, _256));
    }
  };
}
const genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc) => /* @__PURE__ */ chain(/* @__PURE__ */ radix(58), /* @__PURE__ */ alphabet(abc), /* @__PURE__ */ join(""));
const base58 = /* @__PURE__ */ genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
function stableStringify(data2) {
  const seen = [];
  let node = data2;
  if (node && node.toJSON && typeof node.toJSON === "function") {
    node = node.toJSON();
  }
  if (node === void 0)
    return;
  if (typeof node == "number")
    return isFinite(node) ? "" + node : "null";
  if (typeof node !== "object") {
    if (typeof node === "string" && (node.startsWith("encrypted_U") || node.startsWith("binary_U"))) {
      return `"${node}"`;
    }
    return JSON.stringify(node);
  }
  let i, out;
  if (Array.isArray(node)) {
    out = "[";
    for (i = 0; i < node.length; i++) {
      if (i)
        out += ",";
      out += stableStringify(node[i]) || "null";
    }
    return out + "]";
  }
  if (node === null)
    return "null";
  if (seen.indexOf(node) !== -1) {
    throw new TypeError("Converting circular structure to JSON");
  }
  const seenIndex = seen.push(node) - 1;
  const keys = Object.keys(node).sort();
  out = "";
  for (i = 0; i < keys.length; i++) {
    const key = keys[i];
    const value = stableStringify(node[key]);
    if (!value)
      continue;
    if (out)
      out += ",";
    out += JSON.stringify(key) + ":" + value;
  }
  seen.splice(seenIndex, 1);
  return "{" + out + "}";
}
function parseJSON(json) {
  return JSON.parse(json);
}
function safeParseJSON(json) {
  try {
    return JSON.parse(json);
  } catch (e) {
    return void 0;
  }
}
const LogLevel = {
  DEBUG: 0,
  INFO: 1,
  WARN: 2,
  ERROR: 3
};
class ConsoleLogSystem {
  debug(message, attributes) {
    console.debug(message, attributes);
  }
  info(message, attributes) {
    console.info(message, attributes);
  }
  warn(message, attributes) {
    console.warn(message, attributes);
  }
  error(message, attributes) {
    console.error(message, attributes);
  }
}
class Logger {
  constructor(level = LogLevel.INFO, logSystem = new ConsoleLogSystem()) {
    this.level = level;
    this.logSystem = logSystem;
  }
  setLevel(level) {
    this.level = level;
  }
  setLogSystem(logSystem) {
    this.logSystem = logSystem;
  }
  debug(message, attributes) {
    if (this.level <= LogLevel.DEBUG) {
      this.logSystem.debug(message, attributes);
    }
  }
  info(message, attributes) {
    if (this.level <= LogLevel.INFO) {
      this.logSystem.info(message, attributes);
    }
  }
  warn(message, attributes) {
    if (this.level <= LogLevel.WARN) {
      this.logSystem.warn(message, attributes);
    }
  }
  error(message, attributes) {
    if (this.level <= LogLevel.ERROR) {
      this.logSystem.error(message, attributes);
    }
  }
}
const logger = new Logger();
function randomBytes(bytesLength = 32) {
  return crypto.getRandomValues(new Uint8Array(bytesLength));
}
const textEncoder = new TextEncoder();
const textDecoder = new TextDecoder();
class CryptoProvider {
  constructor() {
    this.agentIdCache = /* @__PURE__ */ new Map();
  }
  randomBytes(length) {
    return randomBytes(length);
  }
  newRandomSigner() {
    return `signerSecret_z${base58.encode(this.newEd25519SigningKey())}`;
  }
  newRandomSealer() {
    return `sealerSecret_z${base58.encode(this.newX25519StaticSecret())}`;
  }
  newRandomAgentSecret() {
    return `${this.newRandomSealer()}/${this.newRandomSigner()}`;
  }
  getAgentID(secret) {
    const cacheKey = secret;
    let agentId = this.agentIdCache.get(cacheKey);
    if (!agentId) {
      const [sealerSecret, signerSecret] = secret.split("/");
      agentId = `${this.getSealerID(sealerSecret)}/${this.getSignerID(signerSecret)}`;
      this.agentIdCache.set(cacheKey, agentId);
    }
    return agentId;
  }
  getAgentSignerID(agentId) {
    return agentId.split("/")[1];
  }
  getAgentSignerSecret(agentSecret) {
    return agentSecret.split("/")[1];
  }
  getAgentSealerID(agentId) {
    return agentId.split("/")[0];
  }
  getAgentSealerSecret(agentSecret) {
    return agentSecret.split("/")[0];
  }
  secureHash(value) {
    return `hash_z${base58.encode(this.blake3HashOnce(textEncoder.encode(stableStringify(value))))}`;
  }
  shortHash(value) {
    return `shortHash_z${base58.encode(this.blake3HashOnce(textEncoder.encode(stableStringify(value))).slice(0, shortHashLength))}`;
  }
  decrypt(encrypted, keySecret, nOnceMaterial) {
    try {
      return parseJSON(this.decryptRaw(encrypted, keySecret, nOnceMaterial));
    } catch (e) {
      logger.error("Decryption error", { err: e });
      return void 0;
    }
  }
  newRandomKeySecret() {
    return {
      secret: `keySecret_z${base58.encode(this.randomBytes(32))}`,
      id: `key_z${base58.encode(this.randomBytes(12))}`
    };
  }
  encryptKeySecret(keys) {
    const nOnceMaterial = {
      encryptedID: keys.toEncrypt.id,
      encryptingID: keys.encrypting.id
    };
    return {
      encryptedID: keys.toEncrypt.id,
      encryptingID: keys.encrypting.id,
      encrypted: this.encrypt(keys.toEncrypt.secret, keys.encrypting.secret, nOnceMaterial)
    };
  }
  decryptKeySecret(encryptedInfo, sealingSecret) {
    const nOnceMaterial = {
      encryptedID: encryptedInfo.encryptedID,
      encryptingID: encryptedInfo.encryptingID
    };
    return this.decrypt(encryptedInfo.encrypted, sealingSecret, nOnceMaterial);
  }
  uniquenessForHeader() {
    return `z${base58.encode(this.randomBytes(12))}`;
  }
  createdNowUnique() {
    const createdAt = (/* @__PURE__ */ new Date()).toISOString();
    return {
      createdAt,
      uniqueness: this.uniquenessForHeader()
    };
  }
  newRandomSecretSeed() {
    return this.randomBytes(secretSeedLength);
  }
  agentSecretFromSecretSeed(secretSeed) {
    if (secretSeed.length !== secretSeedLength) {
      throw new Error(`Secret seed needs to be ${secretSeedLength} bytes long`);
    }
    return `sealerSecret_z${base58.encode(this.blake3HashOnceWithContext(secretSeed, {
      context: textEncoder.encode("seal")
    }))}/signerSecret_z${base58.encode(this.blake3HashOnceWithContext(secretSeed, {
      context: textEncoder.encode("sign")
    }))}`;
  }
  newRandomSessionID(accountID) {
    const randomPart = base58.encode(this.randomBytes(8));
    return `${accountID}_session_z${randomPart}`;
  }
  newDeleteSessionID(accountID) {
    const randomPart = base58.encode(this.randomBytes(7));
    return `${accountID}_session_d${randomPart}$`;
  }
}
const shortHashLength = 19;
const secretSeedLength = 32;
function isRawCoID(id2) {
  return typeof id2 === "string" && id2.startsWith("co_z");
}
function isAgentID(id2) {
  return typeof id2 === "string" && id2.startsWith("sealer_") && id2.includes("/signer_");
}
const CHAR_DOLLAR = "$".charCodeAt(0);
function isDeleteSessionID(sessionID) {
  return sessionID.charCodeAt(sessionID.length - 1) === CHAR_DOLLAR;
}
function isParentGroupReference(key) {
  return key.startsWith("parent_");
}
function getParentGroupId(key) {
  return key.slice("parent_".length);
}
function getGroupDependentKey(key) {
  if (typeof key !== "string")
    return void 0;
  if (isParentGroupReference(key)) {
    return getParentGroupId(key);
  } else if (key.startsWith("co_")) {
    return key;
  }
  return void 0;
}
function accountOrAgentIDfromSessionID(sessionID) {
  const until = sessionID.indexOf("_session");
  return sessionID.slice(0, until);
}
class RawCoList {
  resetInternalState() {
    this.afterStart = [];
    this.beforeEnd = [];
    this.insertions = {};
    this.deletionsByInsertion = {};
    this._cachedEntries = void 0;
    this.knownTransactions = { [this.core.id]: 0 };
    this.lastValidTransaction = void 0;
    this.totalValidTransactions = 0;
  }
  /** @internal */
  constructor(core2, atTimeFilter) {
    this.type = "colist";
    this.afterStart = [];
    this.beforeEnd = [];
    this.insertions = {};
    this.deletionsByInsertion = {};
    this.atTimeFilter = void 0;
    this.knownTransactions = {};
    this.version = 0;
    this.totalValidTransactions = 0;
    this.id = core2.id;
    this.core = core2;
    this.insertions = {};
    this.deletionsByInsertion = {};
    this.afterStart = [];
    this.beforeEnd = [];
    this.knownTransactions = { [core2.id]: 0 };
    this.atTimeFilter = atTimeFilter;
    this._processNewTransactions();
  }
  getInsertionsEntry(opID) {
    const index2 = getSessionIndex(opID);
    const sessionEntry = this.insertions[index2];
    if (!sessionEntry) {
      return void 0;
    }
    const txEntry = sessionEntry[opID.txIndex];
    if (!txEntry) {
      return void 0;
    }
    return txEntry[opID.changeIdx];
  }
  createInsertionsEntry(opID, value) {
    const index2 = getSessionIndex(opID);
    let sessionEntry = this.insertions[index2];
    if (!sessionEntry) {
      sessionEntry = {};
      this.insertions[index2] = sessionEntry;
    }
    let txEntry = sessionEntry[opID.txIndex];
    if (!txEntry) {
      txEntry = {};
      sessionEntry[opID.txIndex] = txEntry;
    }
    if (txEntry[opID.changeIdx]) {
      return false;
    }
    txEntry[opID.changeIdx] = value;
    return true;
  }
  isDeleted(opID) {
    const index2 = getSessionIndex(opID);
    const sessionEntry = this.deletionsByInsertion[index2];
    if (!sessionEntry) {
      return false;
    }
    const txEntry = sessionEntry[opID.txIndex];
    if (!txEntry) {
      return false;
    }
    return Boolean(txEntry[opID.changeIdx]?.length);
  }
  pushDeletionsByInsertionEntry(opID, value) {
    const index2 = getSessionIndex(opID);
    let sessionEntry = this.deletionsByInsertion[index2];
    if (!sessionEntry) {
      sessionEntry = {};
      this.deletionsByInsertion[index2] = sessionEntry;
    }
    let txEntry = sessionEntry[opID.txIndex];
    if (!txEntry) {
      txEntry = {};
      sessionEntry[opID.txIndex] = txEntry;
    }
    let list = txEntry[opID.changeIdx];
    if (!list) {
      list = [];
      txEntry[opID.changeIdx] = list;
    }
    list.push(value);
  }
  processNewTransactions() {
    if (this.isTimeTravelEntity()) {
      throw new Error("Cannot process transactions on a time travel entity");
    }
    this._processNewTransactions();
  }
  _processNewTransactions() {
    const transactions = this.core.getValidSortedTransactions({
      ignorePrivateTransactions: false,
      knownTransactions: this.knownTransactions
    });
    if (transactions.length === 0) {
      return;
    }
    let lastValidTransaction = void 0;
    let oldestValidTransaction = void 0;
    this._cachedEntries = void 0;
    for (const { txID, changes, madeAt } of transactions) {
      if (this.isFilteredOut(madeAt)) {
        continue;
      }
      lastValidTransaction = Math.max(lastValidTransaction ?? 0, madeAt);
      oldestValidTransaction = Math.min(oldestValidTransaction ?? Infinity, madeAt);
      for (const [changeIdx, changeUntyped] of changes.entries()) {
        const change = changeUntyped;
        const opID = {
          sessionID: txID.sessionID,
          txIndex: txID.txIndex,
          branch: txID.branch,
          changeIdx
        };
        if (change.op === "pre" || change.op === "app") {
          const created = this.createInsertionsEntry(opID, {
            madeAt,
            predecessors: [],
            successors: [],
            change
          });
          if (!created) {
            continue;
          }
          if (change.op === "pre") {
            if (change.before === "end") {
              this.beforeEnd.push(opID);
            } else {
              const beforeEntry = this.getInsertionsEntry(change.before);
              if (!beforeEntry) {
                continue;
              }
              beforeEntry.predecessors.push(opID);
            }
          } else {
            if (change.after === "start") {
              this.afterStart.push(opID);
            } else {
              const afterEntry = this.getInsertionsEntry(change.after);
              if (!afterEntry) {
                continue;
              }
              afterEntry.successors.push(opID);
            }
          }
        } else if (change.op === "del") {
          this.pushDeletionsByInsertionEntry(change.insertion, {
            madeAt,
            deletionID: opID,
            change
          });
        } else {
          throw new Error("Unknown list operation " + change.op);
        }
      }
    }
    if (this.lastValidTransaction && oldestValidTransaction && oldestValidTransaction < this.lastValidTransaction) {
      this.rebuildFromCore();
    } else {
      this.lastValidTransaction = lastValidTransaction;
    }
    this.totalValidTransactions += transactions.length;
  }
  rebuildFromCore() {
    this.version += 1;
    this.resetInternalState();
    this.processNewTransactions();
  }
  isTimeTravelEntity() {
    return Boolean(this.atTimeFilter);
  }
  isFilteredOut(time) {
    if (this.atTimeFilter === void 0) {
      return false;
    }
    return time > this.atTimeFilter;
  }
  /** @category 6. Meta */
  get headerMeta() {
    return this.core.verified.header.meta;
  }
  /** @category 6. Meta */
  get group() {
    return this.core.getGroup();
  }
  /**
   * Not yet implemented
   *
   * @category 4. Time travel
   */
  atTime(time) {
    return new RawCoList(this.core, time);
  }
  /**
   * Get the item currently at `idx`.
   *
   * @category 1. Reading
   */
  get(idx) {
    const entry = this.entries()[idx];
    if (!entry) {
      return void 0;
    }
    return entry.value;
  }
  /**
   * Returns the current items in the CoList as an array.
   *
   * @category 1. Reading
   **/
  asArray() {
    return this.entries().map((entry) => entry.value);
  }
  /** @internal */
  entries() {
    if (this._cachedEntries) {
      return this._cachedEntries;
    }
    const arr = this.entriesUncached();
    this._cachedEntries = arr;
    return arr;
  }
  length() {
    return this.entries().length;
  }
  /** @internal */
  entriesUncached() {
    const arr = [];
    for (const opID of this.afterStart) {
      this.fillArrayFromOpID(opID, arr);
    }
    for (const opID of this.beforeEnd) {
      this.fillArrayFromOpID(opID, arr);
    }
    return arr;
  }
  /** @internal */
  fillArrayFromOpID(opID, arr) {
    const todo = [opID];
    const predecessorsVisited = /* @__PURE__ */ new Set();
    while (todo.length > 0) {
      const currentOpID = todo[todo.length - 1];
      const entry = this.getInsertionsEntry(currentOpID);
      if (!entry) {
        throw new Error("Missing op " + currentOpID);
      }
      const shouldTraversePredecessors = entry.predecessors.length > 0 && !predecessorsVisited.has(currentOpID);
      if (shouldTraversePredecessors) {
        for (const predecessor of entry.predecessors) {
          todo.push(predecessor);
        }
        predecessorsVisited.add(currentOpID);
      } else {
        todo.pop();
        const deleted = this.isDeleted(currentOpID);
        if (!deleted) {
          arr.push({
            value: entry.change.value,
            madeAt: entry.madeAt,
            opID: currentOpID
          });
        }
        for (const successor of entry.successors) {
          todo.push(successor);
        }
      }
    }
  }
  /**
   * Returns the current items in the CoList as an array. (alias of `asArray`)
   *
   * @category 1. Reading
   */
  toJSON() {
    return this.asArray();
  }
  /** @category 5. Edit history */
  editAt(idx) {
    const entry = this.entries()[idx];
    if (!entry) {
      return void 0;
    }
    const madeAt = new Date(entry.madeAt);
    const by = accountOrAgentIDfromSessionID(entry.opID.sessionID);
    const value = entry.value;
    return {
      by,
      tx: {
        sessionID: entry.opID.sessionID,
        txIndex: entry.opID.txIndex
      },
      at: madeAt,
      value
    };
  }
  /** @category 5. Edit history */
  deletionEdits() {
    const edits = [];
    for (const sessionID in this.deletionsByInsertion) {
      const sessionEntry = this.deletionsByInsertion[sessionID];
      for (const txIdx in sessionEntry) {
        const txEntry = sessionEntry[Number(txIdx)];
        for (const changeIdx in txEntry) {
          const changeEntry = txEntry[Number(changeIdx)];
          for (const deletion of changeEntry || []) {
            const madeAt = new Date(deletion.madeAt);
            const by = accountOrAgentIDfromSessionID(deletion.deletionID.sessionID);
            edits.push({
              by,
              tx: deletion.deletionID,
              at: madeAt
            });
          }
        }
      }
    }
    return edits;
  }
  /** @category 3. Subscription */
  subscribe(listener) {
    return this.core.subscribe((core2) => {
      listener(core2.getCurrentContent());
    });
  }
  /** Appends `item` after the item currently at index `after`.
   *
   * If `privacy` is `"private"` **(default)**, `item` is encrypted in the transaction, only readable by other members of the group this `CoList` belongs to. Not even sync servers can see the content in plaintext.
   *
   * If `privacy` is `"trusting"`, `item` is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
   *
   * @category 2. Editing
   **/
  append(item, after, privacy = "private") {
    this.appendItems([item], after, privacy);
  }
  /**
   * Appends `items` to the list at index `after`. If `after` is negative, it is treated as `0`.
   *
   * If `privacy` is `"private"` **(default)**, `items` are encrypted in the transaction, only readable by other members of the group this `CoList` belongs to. Not even sync servers can see the content in plaintext.
   *
   * If `privacy` is `"trusting"`, `items` are stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
   *
   * @category 2. Editing
   */
  appendItems(items2, after, privacy = "private") {
    const entries = this.entries();
    after = after === void 0 ? entries.length > 0 ? entries.length - 1 : 0 : Math.max(0, after);
    let opIDBefore;
    if (entries.length > 0) {
      const entryBefore = entries[after];
      if (!entryBefore) {
        throw new Error("Invalid index " + after);
      }
      opIDBefore = entryBefore.opID;
    } else {
      if (after !== 0) {
        throw new Error("Invalid index " + after);
      }
      opIDBefore = "start";
    }
    const changes = items2.map((item) => ({
      op: "app",
      value: isCoValue(item) ? item.id : item,
      after: opIDBefore
    }));
    if (opIDBefore !== "start") {
      changes.reverse();
    }
    this.core.makeTransaction(changes, privacy);
    this.processNewTransactions();
  }
  /**
   * Prepends `item` before the item currently at index `before`.
   *
   * If `privacy` is `"private"` **(default)**, `item` is encrypted in the transaction, only readable by other members of the group this `CoList` belongs to. Not even sync servers can see the content in plaintext.
   *
   * If `privacy` is `"trusting"`, `item` is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
   *
   * @category 2. Editing
   */
  prepend(item, before, privacy = "private") {
    const entries = this.entries();
    before = before === void 0 ? 0 : before;
    let opIDAfter;
    if (entries.length > 0) {
      const entryAfter = entries[before];
      if (entryAfter) {
        opIDAfter = entryAfter.opID;
      } else {
        if (before !== entries.length) {
          throw new Error("Invalid index " + before);
        }
        opIDAfter = "end";
      }
    } else {
      if (before !== 0) {
        throw new Error("Invalid index " + before);
      }
      opIDAfter = "end";
    }
    this.core.makeTransaction([
      {
        op: "pre",
        value: isCoValue(item) ? item.id : item,
        before: opIDAfter
      }
    ], privacy);
    this.processNewTransactions();
  }
  /** Deletes the item at index `at`.
   *
   * If `privacy` is `"private"` **(default)**, the fact of this deletion is encrypted in the transaction, only readable by other members of the group this `CoList` belongs to. Not even sync servers can see the content in plaintext.
   *
   * If `privacy` is `"trusting"`, the fact of this deletion is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
   *
   * @category 2. Editing
   **/
  delete(at, privacy = "private") {
    const entries = this.entries();
    const entry = entries[at];
    if (!entry) {
      throw new Error("Invalid index " + at);
    }
    this.core.makeTransaction([
      {
        op: "del",
        insertion: entry.opID
      }
    ], privacy);
    this.processNewTransactions();
  }
  replace(at, newItem, privacy = "private") {
    const entries = this.entries();
    const entry = entries[at];
    if (!entry) {
      throw new Error("Invalid index " + at);
    }
    this.core.makeTransaction([
      {
        op: "app",
        value: isCoValue(newItem) ? newItem.id : newItem,
        after: entry.opID
      },
      {
        op: "del",
        insertion: entry.opID
      }
    ], privacy);
    this.processNewTransactions();
  }
}
function getSessionIndex(txID) {
  if (txID.branch) {
    return `${txID.sessionID}_branch_${txID.branch}`;
  }
  return txID.sessionID;
}
function isAccountID(id2) {
  return id2.startsWith("co_");
}
class RawCoStreamView {
  resetInternalState() {
    this.items = {};
    this.knownTransactions = { [this.core.id]: 0 };
    this.totalValidTransactions = 0;
  }
  constructor(core2) {
    this.type = "costream";
    this.totalValidTransactions = 0;
    this.version = 0;
    this.id = core2.id;
    this.core = core2;
    this.items = {};
    this.knownTransactions = { [core2.id]: 0 };
    this.processNewTransactions();
  }
  rebuildFromCore() {
    this.version++;
    this.resetInternalState();
    this.processNewTransactions();
  }
  get headerMeta() {
    return this.core.verified.header.meta;
  }
  get group() {
    return this.core.getGroup();
  }
  /** Not yet implemented */
  atTime(_time) {
    throw new Error("Not yet implemented");
  }
  /** @internal */
  compareStreamItems(a, b) {
    return a.madeAt - b.madeAt || (a.tx.sessionID === b.tx.sessionID ? 0 : a.tx.sessionID < b.tx.sessionID ? -1 : 1) || a.tx.txIndex - b.tx.txIndex;
  }
  /** @internal */
  processNewTransactions() {
    const changeEntries = /* @__PURE__ */ new Set();
    const newValidTransactions = this.core.getValidTransactions({
      ignorePrivateTransactions: false,
      knownTransactions: this.knownTransactions
    });
    if (newValidTransactions.length === 0) {
      return;
    }
    for (const { txID, madeAt, changes } of newValidTransactions) {
      for (const changeUntyped of changes) {
        const change = changeUntyped;
        let entries = this.items[txID.sessionID];
        if (!entries) {
          entries = [];
          this.items[txID.sessionID] = entries;
        }
        entries.push({ value: change, madeAt, tx: txID });
        changeEntries.add(entries);
      }
    }
    for (const entries of changeEntries) {
      entries.sort(this.compareStreamItems);
    }
    this.totalValidTransactions += newValidTransactions.length;
  }
  getSingleStream() {
    const streams = Object.values(this.items);
    const firstStream = streams[0];
    if (!firstStream) {
      return void 0;
    }
    if (streams.length > 1) {
      throw new Error("CoStream.getSingleStream() can only be called when there is exactly one stream");
    }
    return firstStream.map((item) => item.value);
  }
  sessions() {
    return Object.keys(this.items);
  }
  accounts() {
    return new Set(this.sessions().map(accountOrAgentIDfromSessionID).filter(isAccountID));
  }
  nthItemIn(sessionID, n) {
    const items2 = this.items[sessionID];
    if (!items2)
      return;
    const item = items2[n];
    if (!item)
      return;
    return {
      by: accountOrAgentIDfromSessionID(sessionID),
      tx: item.tx,
      at: new Date(item.madeAt),
      value: item.value
    };
  }
  lastItemIn(sessionID) {
    const items2 = this.items[sessionID];
    if (!items2)
      return;
    return this.nthItemIn(sessionID, items2.length - 1);
  }
  *itemsIn(sessionID) {
    const items2 = this.items[sessionID];
    if (!items2)
      return;
    for (const item of items2) {
      yield {
        by: accountOrAgentIDfromSessionID(sessionID),
        tx: item.tx,
        at: new Date(item.madeAt),
        value: item.value
      };
    }
  }
  lastItemBy(account) {
    let latestItem;
    for (const sessionID of Object.keys(this.items)) {
      if (sessionID.startsWith(account)) {
        const item = this.lastItemIn(sessionID);
        if (!item)
          continue;
        if (!latestItem || item.at > latestItem.at) {
          latestItem = {
            by: item.by,
            tx: item.tx,
            at: item.at,
            value: item.value
          };
        }
      }
    }
    return latestItem;
  }
  *itemsBy(account) {
    const items2 = [
      ...Object.keys(this.items).flatMap((sessionID) => sessionID.startsWith(account) ? [...this.itemsIn(sessionID)].map((item) => ({
        in: sessionID,
        ...item
      })) : [])
    ];
    items2.sort((a, b) => a.at.getTime() - b.at.getTime());
    for (const item of items2) {
      yield item;
    }
  }
  toJSON() {
    return Object.fromEntries(Object.entries(this.items).map(([sessionID, items2]) => [
      sessionID,
      items2.map((item) => item.value)
    ]));
  }
  subscribe(listener) {
    return this.core.subscribe((core2) => {
      listener(core2.getCurrentContent());
    });
  }
}
class RawCoStream extends RawCoStreamView {
  push(item, privacy = "private") {
    this.core.makeTransaction([isCoValue(item) ? item.id : item], privacy);
    this.processNewTransactions();
  }
}
const binary_U_prefixLength = 8;
class RawBinaryCoStreamView extends RawCoStreamView {
  isBinaryStreamEnded() {
    const items2 = this.getSingleStream();
    if (!items2 || items2.length === 0) {
      return false;
    }
    const lastItem = items2[items2.length - 1];
    return lastItem?.type === "end";
  }
  getBinaryStreamInfo() {
    const items2 = this.getSingleStream();
    if (!items2)
      return;
    const start = items2[0];
    if (start?.type !== "start") {
      logger.error("Invalid binary stream start", start);
      return;
    }
    return {
      mimeType: start.mimeType,
      fileName: start.fileName,
      totalSizeBytes: start.totalSizeBytes
    };
  }
  getBinaryChunks(allowUnfinished) {
    const items2 = this.getSingleStream();
    if (!items2)
      return;
    const info = this.getBinaryStreamInfo();
    if (!info)
      return;
    const end = items2[items2.length - 1];
    if (end?.type !== "end" && !allowUnfinished)
      return;
    const chunks = [];
    let finished = false;
    for (const item of items2.slice(1)) {
      if (item.type === "end") {
        finished = true;
        break;
      }
      if (item.type !== "chunk") {
        logger.error("Invalid binary stream chunk", item);
        return void 0;
      }
      const chunk = base64URLtoBytes(item.chunk.slice(binary_U_prefixLength));
      chunks.push(chunk);
    }
    return {
      ...info,
      chunks,
      finished
    };
  }
}
class RawBinaryCoStream extends RawBinaryCoStreamView {
  /** @internal */
  push(item, privacy = "private", updateView = true) {
    this.core.makeTransaction([item], privacy);
    if (updateView) {
      this.processNewTransactions();
    }
  }
  startBinaryStream(settings, privacy = "private") {
    this.push({
      type: "start",
      ...settings
    }, privacy, false);
  }
  pushBinaryStreamChunk(chunk, privacy = "private") {
    this.push({
      type: "chunk",
      chunk: `binary_U${bytesToBase64url(chunk)}`
    }, privacy, false);
  }
  endBinaryStream(privacy = "private") {
    this.push({
      type: "end"
    }, privacy, true);
  }
}
function isCoValue(value) {
  return value instanceof RawCoMap || value instanceof RawCoList || value instanceof RawCoStream || value instanceof RawBinaryCoStream;
}
class RawCoMap {
  /** @internal */
  get latestTxMadeAt() {
    return this.core.latestTxMadeAt;
  }
  /** @internal */
  get earliestTxMadeAt() {
    return this.core.earliestTxMadeAt;
  }
  resetInternalState() {
    this.ops = {};
    this.latest = {};
    this.knownTransactions = { [this.core.id]: 0 };
    this.totalValidTransactions = 0;
  }
  /** @internal */
  constructor(core2, options) {
    this.type = "comap";
    this.ops = {};
    this.latest = {};
    this.knownTransactions = {};
    this.totalValidTransactions = 0;
    this.version = 0;
    this.atTimeFilter = void 0;
    this.id = core2.id;
    this.core = core2;
    this.ignorePrivateTransactions = options?.ignorePrivateTransactions ?? false;
    this.processNewTransactions();
  }
  processNewTransactions() {
    if (this.isTimeTravelEntity()) {
      throw new Error("Cannot process transactions on a time travel entity");
    }
    const newValidTransactions = this.core.getValidTransactions({
      ignorePrivateTransactions: this.ignorePrivateTransactions,
      knownTransactions: this.knownTransactions
    });
    if (newValidTransactions.length === 0) {
      return;
    }
    const { ops } = this;
    const changedEntries = /* @__PURE__ */ new Map();
    for (const transaction of newValidTransactions) {
      const { txID, changes, madeAt, tx } = transaction;
      for (let changeIdx = 0; changeIdx < changes.length; changeIdx++) {
        const change = changes[changeIdx];
        const entry = {
          txID,
          madeAt,
          changeIdx,
          change,
          trusting: tx.privacy === "trusting"
        };
        const entries = ops[change.key];
        if (!entries) {
          const entries2 = [entry];
          ops[change.key] = entries2;
          changedEntries.set(change.key, entries2);
        } else {
          entries.push(entry);
          changedEntries.set(change.key, entries);
        }
      }
      this.handleNewTransaction(transaction);
    }
    for (const entries of changedEntries.values()) {
      entries.sort(this.core.compareTransactions);
    }
    for (const [key, entries] of changedEntries.entries()) {
      this.latest[key] = entries[entries.length - 1];
    }
    this.totalValidTransactions += newValidTransactions.length;
  }
  handleNewTransaction(transaction) {
  }
  rebuildFromCore() {
    this.version += 1;
    this.resetInternalState();
    this.processNewTransactions();
  }
  isTimeTravelEntity() {
    return Boolean(this.atTimeFilter);
  }
  /** @category 6. Meta */
  get headerMeta() {
    return this.core.verified.header.meta;
  }
  /** @category 6. Meta */
  get group() {
    return this.core.getGroup();
  }
  /** @category 4. Time travel */
  atTime(time) {
    const clone = Object.create(this);
    clone.atTimeFilter = time;
    clone.latest = {};
    return clone;
  }
  /** @internal */
  timeFilteredOps(key) {
    if (key === "constructor") {
      return void 0;
    }
    const atTimeFilter = this.atTimeFilter;
    if (atTimeFilter) {
      return this.ops[key]?.filter((op) => op.madeAt <= atTimeFilter);
    } else {
      return this.ops[key];
    }
  }
  /**
   * Get all keys currently in the map.
   *
   * @category 1. Reading */
  keys() {
    return Object.keys(this.ops).filter((key) => {
      const entry = this.getRaw(key);
      if (entry === void 0) {
        return false;
      }
      if (entry.change.op === "del") {
        return false;
      }
      return true;
    });
  }
  getRaw(key) {
    let latestChange = this.latest[key];
    if (latestChange === void 0) {
      const entries = this.ops[key];
      if (entries && !(key in this.latest)) {
        const atTimeFilter = this.atTimeFilter;
        if (!atTimeFilter) {
          latestChange = entries[entries.length - 1];
        } else {
          latestChange = entries.findLast((op) => op.madeAt <= atTimeFilter);
        }
        this.latest[key] = latestChange;
      }
      if (latestChange === void 0) {
        return void 0;
      }
    }
    return latestChange;
  }
  /**
   * Returns the current value for the given key.
   *
   * @category 1. Reading
   **/
  get(key) {
    const entry = this.getRaw(key);
    if (entry?.change === void 0) {
      return void 0;
    }
    if (entry.change.op === "del") {
      return void 0;
    } else {
      return entry.change.value;
    }
  }
  /** @category 1. Reading */
  asObject() {
    const object = {};
    for (const key of Object.keys(this.ops)) {
      const value = this.get(key);
      if (value !== void 0) {
        object[key] = value;
      }
    }
    return object;
  }
  /** @category 1. Reading */
  toJSON() {
    return this.asObject();
  }
  /** @category 5. Edit history */
  nthEditAt(key, n) {
    const ops = this.ops[key];
    const atTimeFilter = this.atTimeFilter;
    const entry = ops?.[n];
    if (!entry) {
      return void 0;
    }
    if (atTimeFilter && entry.madeAt > atTimeFilter) {
      return void 0;
    }
    return operationToEditEntry(entry);
  }
  /** @category 5. Edit history */
  lastEditAt(key) {
    const entry = this.getRaw(key);
    if (!entry) {
      return void 0;
    }
    return operationToEditEntry(entry);
  }
  /** @category 5. Edit history */
  *editsAt(key) {
    const entries = this.ops[key];
    if (!entries) {
      return;
    }
    const atTimeFilter = this.atTimeFilter;
    for (const entry of entries) {
      if (atTimeFilter && entry.madeAt > atTimeFilter) {
        return;
      }
      yield operationToEditEntry(entry);
    }
  }
  /** @category 3. Subscription */
  subscribe(listener) {
    return this.core.subscribe((core2) => {
      listener(core2.getCurrentContent());
    });
  }
  /** Set a new value for the given key.
   *
   * If `privacy` is `"private"` **(default)**, both `key` and `value` are encrypted in the transaction, only readable by other members of the group this `CoMap` belongs to. Not even sync servers can see the content in plaintext.
   *
   * If `privacy` is `"trusting"`, both `key` and `value` are stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
   *
   * @category 2. Editing
   **/
  set(key, value, privacy = "private") {
    if (this.isTimeTravelEntity()) {
      throw new Error("Cannot set value on a time travel entity");
    }
    this.core.makeTransaction([
      {
        op: "set",
        key,
        value: isCoValue(value) ? value.id : value
      }
    ], privacy);
    this.processNewTransactions();
  }
  assign(entries, privacy = "private") {
    if (this.isTimeTravelEntity()) {
      throw new Error("Cannot set value on a time travel entity");
    }
    this.core.makeTransaction(Object.entries(entries).map(([key, value]) => ({
      op: "set",
      key,
      value: isCoValue(value) ? value.id : value
    })), privacy);
    this.processNewTransactions();
  }
  /** Delete the given key (setting it to undefined).
   *
   * If `privacy` is `"private"` **(default)**, `key` is encrypted in the transaction, only readable by other members of the group this `CoMap` belongs to. Not even sync servers can see the content in plaintext.
   *
   * If `privacy` is `"trusting"`, `key` is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
   *
   * @category 2. Editing
   **/
  delete(key, privacy = "private") {
    if (this.isTimeTravelEntity()) {
      throw new Error("Cannot delete value on a time travel entity");
    }
    this.core.makeTransaction([
      {
        op: "del",
        key
      }
    ], privacy);
    this.processNewTransactions();
  }
}
function operationToEditEntry(op) {
  return {
    by: accountOrAgentIDfromSessionID(op.txID.sessionID),
    tx: op.txID,
    at: new Date(op.madeAt),
    value: op.change.op === "del" ? void 0 : op.change.value
  };
}
function expectGroup(content) {
  if (content.type !== "comap") {
    throw new Error("Expected group");
  }
  if (content.core.verified.header.ruleset.type !== "group") {
    throw new Error("Expected group ruleset in group");
  }
  if (!(content instanceof RawGroup)) {
    throw new Error("Expected group");
  }
  return content;
}
function isAccountRole(role) {
  return role === "manager" || role === "admin" || role === "writer" || role === "reader" || role === "writeOnly";
}
function canAdmin(role) {
  return role === "admin" || role === "manager";
}
function determineValidTransactions(coValue) {
  if (!coValue.isAvailable()) {
    throw new Error("determineValidTransactions CoValue is not available");
  }
  if (coValue.verified.header.ruleset.type === "group") {
    const initialAdmin = coValue.verified.header.ruleset.initialAdmin;
    if (!initialAdmin) {
      throw new Error("Group must have initialAdmin");
    }
    determineValidTransactionsForGroup(coValue, initialAdmin);
    return;
  }
  if (coValue.verified.header.ruleset.type === "ownedByGroup") {
    const groupContent = expectGroup(coValue.node.expectCoValueLoaded(coValue.verified.header.ruleset.group, "Determining valid transaction in owned object but its group wasn't loaded").getCurrentContent());
    if (groupContent.type !== "comap") {
      throw new Error("Group must be a map");
    }
    for (const tx of coValue.toValidateTransactions) {
      const groupAtTime = groupContent.atTime(tx.currentMadeAt);
      const effectiveTransactor = agentInAccountOrMemberInGroup(tx.author, groupAtTime);
      if (!effectiveTransactor) {
        tx.markInvalid("Transactor not found in group", {
          transactor: tx.author,
          group: groupAtTime.toJSON()
        });
        continue;
      }
      const transactorRoleAtTxTime = groupAtTime.roleOfInternal(effectiveTransactor);
      if (transactorRoleAtTxTime === "reader" && tx.meta?.branch && tx.meta?.ownerId) {
        tx.meta = {
          branch: tx.meta.branch,
          ownerId: tx.meta.ownerId
        };
        tx.changes = [];
        tx.markValid();
        continue;
      }
      if (transactorRoleAtTxTime !== "admin" && transactorRoleAtTxTime !== "manager" && transactorRoleAtTxTime !== "writer" && transactorRoleAtTxTime !== "writeOnly") {
        tx.markInvalid("Transactor has no write permissions", {
          transactor: tx.author,
          transactorRole: transactorRoleAtTxTime ?? "undefined"
        });
        continue;
      }
      tx.markValid();
    }
    return;
  }
  if (coValue.verified.header.ruleset.type === "unsafeAllowAll") {
    for (const tx of coValue.toValidateTransactions) {
      tx.markValid();
    }
    return;
  }
  throw new Error("Unknown ruleset type " + coValue.verified.header.ruleset.type);
}
function isHigherRole(a, b) {
  if (a === void 0 || a === "revoked")
    return false;
  if (b === void 0 || b === "revoked")
    return true;
  if (b === "admin")
    return false;
  if (a === "admin")
    return true;
  if (b === "manager")
    return false;
  if (a === "manager")
    return true;
  return a === "writer" && b === "reader";
}
class MemberRoleResolver {
  constructor() {
    this.parentGroups = /* @__PURE__ */ new Map();
    this.memberRoles = /* @__PURE__ */ new Map();
  }
  setDirectRole(member, role) {
    this.memberRoles.set(member, role);
  }
  removeMember(member) {
    this.memberRoles.delete(member);
  }
  addParentGroup(parentGroup, roleMapping) {
    this.parentGroups.set(parentGroup, roleMapping);
  }
  removeParentGroup(parentGroup) {
    this.parentGroups.delete(parentGroup);
  }
  getDirectRole(member) {
    return this.memberRoles.get(member);
  }
  getRoleAtTime(member, time) {
    let role = this.memberRoles.get(member);
    for (const [parentGroup, roleMapping] of this.parentGroups.entries()) {
      const parentRole = parentGroup.atTime(time).roleOfInternal(member);
      if (!parentRole || !isInheritableRole(parentRole)) {
        continue;
      }
      const resolvedParentRole = roleMapping === "extend" ? parentRole : roleMapping;
      if (isHigherRole(resolvedParentRole, role)) {
        role = resolvedParentRole;
      }
    }
    return role;
  }
}
function determineValidTransactionsForGroup(coValue, initialAdmin) {
  coValue.verifiedTransactions.sort(coValue.compareTransactions);
  const writeOnlyKeys = {};
  const writeKeys = /* @__PURE__ */ new Set();
  const memberRoleResolver = new MemberRoleResolver();
  const isGroup = coValue.isGroup();
  for (const transaction of coValue.verifiedTransactions) {
    let markTransactionSetRoleAsValid = function(change2) {
      if (change2.op !== "set") {
        throw new Error("Expected set operation");
      }
      memberRoleResolver.setDirectRole(change2.key, change2.value);
      transaction.markValid();
    };
    const transactor = transaction.author;
    const transactorRole = memberRoleResolver.getRoleAtTime(transactor, transaction.currentMadeAt);
    const tx = transaction.tx;
    if (tx.privacy === "private") {
      if (isGroup) {
        transaction.markInvalid("Can't make private transactions in groups");
        continue;
      }
      if (transactorRole === "admin") {
        transaction.markValid();
        continue;
      } else {
        transaction.markInvalid("Only admins can make private transactions in groups");
        continue;
      }
    }
    const changes = transaction.changes;
    if (!changes) {
      continue;
    }
    const change = changes[0];
    if (changes.length !== 1) {
      transaction.markInvalid("Group transaction must have exactly one change");
      continue;
    }
    if (change.op !== "set") {
      transaction.markInvalid("Group transaction must set a role or readKey");
      continue;
    }
    if (change.key === "readKey") {
      if (!canAdmin(transactorRole)) {
        transaction.markInvalid("Only admins can set readKeys");
        continue;
      }
      transaction.markValid();
      continue;
    } else if (change.key === "profile") {
      if (!canAdmin(transactorRole)) {
        transaction.markInvalid("Only admins can set profile");
        continue;
      }
      transaction.markValid();
      continue;
    } else if (change.key === "root") {
      if (!canAdmin(transactorRole)) {
        transaction.markInvalid("Only admins can set root");
        continue;
      }
      transaction.markValid();
      continue;
    } else if (isKeyForKeyField(change.key) || isKeyForAccountField(change.key)) {
      if (transactorRole !== "admin" && transactorRole !== "adminInvite" && transactorRole !== "manager" && transactorRole !== "managerInvite" && transactorRole !== "writerInvite" && transactorRole !== "readerInvite" && transactorRole !== "writeOnlyInvite" && !isOwnWriteKeyRevelation(change.key, transactor, writeOnlyKeys)) {
        transaction.markInvalid("Only admins and managers can reveal keys");
        continue;
      }
      transaction.markValid();
      continue;
    } else if (isParentExtension(change.key)) {
      if (!canAdmin(transactorRole)) {
        transaction.markInvalid("Only admins and managers can set parent extensions");
        continue;
      }
      const parentGroupId = getParentGroupId(change.key);
      const parentGroupCore = coValue.node.expectCoValueLoaded(parentGroupId, "Expected parent group to be loaded");
      if (!parentGroupCore.isGroup()) {
        transaction.markInvalid("Parent group is not a group");
        continue;
      }
      const parentGroup = expectGroup(parentGroupCore.getCurrentContent());
      if (isSelfExtension(coValue, parentGroup)) {
        transaction.markInvalid("Parent group is a circular dependency");
        continue;
      }
      const value = change.value;
      if (value === "revoked") {
        memberRoleResolver.removeParentGroup(parentGroup);
      } else {
        memberRoleResolver.addParentGroup(parentGroup, value);
      }
      transaction.markValid();
      continue;
    } else if (isChildExtension(change.key)) {
      transaction.markInvalid("Child extensions are not allowed anymore");
      continue;
    } else if (isWriteKeyForMember(change.key)) {
      const memberKey = getAccountOrAgentFromWriteKeyForMember(change.key);
      if (transactorRole !== "admin" && transactorRole !== "manager" && transactorRole !== "writeOnlyInvite" && memberKey !== transactor) {
        transaction.markInvalid("Only admins and managers can set writeKeys");
        continue;
      }
      writeOnlyKeys[memberKey] = change.value;
      if (writeKeys.has(change.key) && !canAdmin(transactorRole)) {
        transaction.markInvalid("Write key already exists and can't be overridden by invite");
        continue;
      }
      writeKeys.add(change.key);
      transaction.markValid();
      continue;
    }
    const affectedMember = change.key;
    const assignedRole = change.value;
    if (assignedRole !== "admin" && assignedRole !== "manager" && assignedRole !== "writer" && assignedRole !== "reader" && assignedRole !== "writeOnly" && assignedRole !== "revoked" && assignedRole !== "managerInvite" && assignedRole !== "adminInvite" && assignedRole !== "writerInvite" && assignedRole !== "readerInvite" && assignedRole !== "writeOnlyInvite") {
      transaction.markInvalid("Group transaction must set a valid role");
      continue;
    }
    if (affectedMember === EVERYONE && !(assignedRole === "reader" || assignedRole === "writer" || assignedRole === "writeOnly" || assignedRole === "revoked")) {
      transaction.markInvalid("Everyone can only be set to reader, writer, writeOnly or revoked");
      continue;
    }
    if (transactorRole === void 0 && transactor === initialAdmin && affectedMember === transactor && assignedRole === "admin") {
      markTransactionSetRoleAsValid(change);
      continue;
    }
    if (transactor === change.key && change.value === "revoked") {
      markTransactionSetRoleAsValid(change);
      continue;
    }
    const affectedMemberRole = memberRoleResolver.getRoleAtTime(affectedMember, transaction.currentMadeAt);
    if (transactorRole === "admin") {
      if (affectedMemberRole === "admin" && assignedRole !== "admin" && affectedMember !== transactor) {
        transaction.markInvalid("Admins can't demote admins.");
        continue;
      }
      markTransactionSetRoleAsValid(change);
      continue;
    }
    if (transactorRole === "manager") {
      if (affectedMemberRole === "admin") {
        transaction.markInvalid("Managers can't demote admins.");
        continue;
      }
      if (change.value === "admin") {
        transaction.markInvalid("Managers can't promote to admin.");
        continue;
      }
      if (change.value === "adminInvite") {
        transaction.markInvalid("Managers can't invite admins.");
        continue;
      }
      if (change.value === "managerInvite") {
        transaction.markInvalid("Managers can't invite managers.");
        continue;
      }
      markTransactionSetRoleAsValid(change);
      continue;
    }
    if (transactorRole === "adminInvite") {
      if (change.value !== "admin") {
        transaction.markInvalid("AdminInvites can only create admins.");
        continue;
      }
    } else if (transactorRole === "managerInvite") {
      if (change.value !== "manager") {
        transaction.markInvalid("managerInvite can only create managers.");
        continue;
      }
    } else if (transactorRole === "writerInvite") {
      if (change.value !== "writer") {
        transaction.markInvalid("WriterInvites can only create writers.");
        continue;
      }
    } else if (transactorRole === "readerInvite") {
      if (change.value !== "reader") {
        transaction.markInvalid("ReaderInvites can only create reader.");
        continue;
      }
    } else if (transactorRole === "writeOnlyInvite") {
      if (change.value !== "writeOnly") {
        transaction.markInvalid("WriteOnlyInvites can only create writeOnly.");
        continue;
      }
    } else {
      transaction.markInvalid("Group transaction must be made by current admin, manager, or invite");
      continue;
    }
    memberRoleResolver.setDirectRole(affectedMember, change.value);
    transaction.markValid();
  }
}
function agentInAccountOrMemberInGroup(transactor, groupAtTime) {
  if (transactor === groupAtTime.id && groupAtTime instanceof RawAccount) {
    return groupAtTime.currentAgentID();
  }
  return transactor;
}
function isWriteKeyForMember(co) {
  return co.startsWith("writeKeyFor_");
}
function getAccountOrAgentFromWriteKeyForMember(co) {
  return co.slice("writeKeyFor_".length);
}
function isKeyForKeyField(co) {
  return co.startsWith("key_") && co.includes("_for_key");
}
function isKeyForAccountField(co) {
  return co.startsWith("key_") && (co.includes("_for_sealer") || co.includes("_for_co")) || co.includes("_for_everyone");
}
function isParentExtension(key) {
  return key.startsWith("parent_");
}
function isChildExtension(key) {
  return key.startsWith("child_");
}
function isOwnWriteKeyRevelation(key, memberKey, writeOnlyKeys) {
  if (Object.keys(writeOnlyKeys).length === 0) {
    return false;
  }
  const keyID = key.slice(0, key.indexOf("_for_"));
  return writeOnlyKeys[memberKey] === keyID;
}
const EVERYONE = "everyone";
function healMissingKeyForEveryone(group) {
  const readKeyId = group.get("readKey");
  if (!readKeyId || !canRead(group, EVERYONE) || group.get(`${readKeyId}_for_${EVERYONE}`)) {
    return;
  }
  const hasAccessToReadKey = canRead(group, group.core.node.getCurrentAgent().id);
  if (hasAccessToReadKey) {
    const secret = group.getReadKey(readKeyId);
    if (secret) {
      group.set(`${readKeyId}_for_${EVERYONE}`, secret, "trusting");
    }
    return;
  }
  const keys = group.keys().filter((key) => key.startsWith("key_") && key.endsWith("_for_everyone"));
  let latestKey = keys[0];
  for (const key of keys) {
    if (!latestKey) {
      latestKey = key;
      continue;
    }
    const keyEntry = group.getRaw(key);
    const latestKeyEntry = group.getRaw(latestKey);
    if (keyEntry && latestKeyEntry && keyEntry.madeAt > latestKeyEntry.madeAt) {
      latestKey = key;
    }
  }
  if (latestKey) {
    group._lastReadableKeyId = latestKey.replace("_for_everyone", "");
  }
}
class TimeBasedEntry {
  constructor() {
    this.changes = [];
  }
  addChange(madeAt, value) {
    const changes = this.changes;
    const newChange = { madeAt, value };
    let insertIndex = changes.length;
    while (insertIndex > 0 && changes[insertIndex - 1].madeAt > madeAt) {
      insertIndex--;
    }
    if (insertIndex === changes.length) {
      changes.push(newChange);
    } else {
      changes.splice(insertIndex, 0, newChange);
    }
  }
  getLatest() {
    return this.changes[this.changes.length - 1]?.value;
  }
  getAtTime(atTime) {
    if (atTime === void 0) {
      return this.getLatest();
    }
    return this.changes.findLast((change) => change.madeAt <= atTime)?.value;
  }
}
class RawGroup extends RawCoMap {
  resetInternalState() {
    super.resetInternalState();
    this.parentGroupsChanges = /* @__PURE__ */ new Map();
    this.keyRevelations = /* @__PURE__ */ new Map();
    this._lastReadableKeyId = void 0;
  }
  constructor(core2, options) {
    super(core2, options);
    this.crypto = core2.node.crypto;
    this.migrate();
  }
  // We override the handleNewTransaction hook from CoMap to build the parent group cache
  // and key revelations cache
  handleNewTransaction(transaction) {
    if (!this.parentGroupsChanges) {
      this.parentGroupsChanges = /* @__PURE__ */ new Map();
    }
    if (!this.keyRevelations) {
      this.keyRevelations = /* @__PURE__ */ new Map();
    }
    for (const changeValue of transaction.changes) {
      const change = changeValue;
      if (change.op === "set") {
        if (isParentGroupReference(change.key)) {
          this.updateParentGroupCache(change.key, change.value, transaction.madeAt);
        } else if (isKeyForKeyField(change.key)) {
          this.updateKeyRevelationsCache(change.key);
        }
      }
    }
  }
  updateKeyRevelationsCache(key) {
    const parts = key.split("_for_");
    if (parts.length === 2) {
      const encryptedKeyID = parts[0];
      const encryptingKeyID = parts[1];
      let revelations = this.keyRevelations.get(encryptedKeyID);
      if (!revelations) {
        revelations = /* @__PURE__ */ new Set();
        this.keyRevelations.set(encryptedKeyID, revelations);
      }
      revelations.add(encryptingKeyID);
    }
  }
  updateParentGroupCache(key, value, timestamp) {
    const parentGroupId = key.substring(7);
    let entry = this.parentGroupsChanges.get(parentGroupId);
    if (!entry) {
      entry = new TimeBasedEntry();
      this.parentGroupsChanges.set(parentGroupId, entry);
    }
    entry.addChange(timestamp, value);
  }
  migrate() {
    if (!this.core.isGroup()) {
      return;
    }
    const runMigrations = () => {
      healMissingKeyForEveryone(this);
    };
    if (!this.core.isCompletelyDownloaded()) {
      this.core.waitFor({
        predicate: (core2) => core2.isCompletelyDownloaded(),
        onSuccess: runMigrations
      });
    } else {
      runMigrations();
    }
  }
  /**
   * Returns the current role of a given account.
   *
   * @category 1. Role reading
   */
  roleOf(accountID) {
    return this.roleOfInternal(accountID);
  }
  /**
   *  This is a performance-critical function, micro-optimizing it is important
   *
   *  Avoid to add objects/array allocations in this function
   */
  /** @internal */
  roleOfInternal(accountID) {
    let roleHere = this.get(accountID);
    if (roleHere === "revoked") {
      roleHere = void 0;
    }
    let roleInfo = roleHere;
    for (const [parentGroupId, entry] of this.parentGroupsChanges.entries()) {
      const role = entry.getAtTime(this.atTimeFilter);
      if (!role || role === "revoked")
        continue;
      const parentGroup = this.getParentGroup(parentGroupId, this.atTimeFilter);
      const parentRole = parentGroup.roleOfInternal(accountID);
      if (!isInheritableRole(parentRole)) {
        continue;
      }
      const roleToInherit = role !== "extend" ? role : parentRole;
      if (isMorePermissiveAndShouldInherit(roleToInherit, roleInfo)) {
        roleInfo = roleToInherit;
      }
    }
    if (!roleInfo && accountID !== "everyone") {
      const everyoneRole = this.get("everyone");
      if (everyoneRole && everyoneRole !== "revoked")
        return everyoneRole;
    }
    return roleInfo;
  }
  getParentGroup(id2, atTime) {
    const parent = this.core.node.expectCoValueLoaded(id2, "Expected parent group to be loaded");
    const group = expectGroup(parent.getCurrentContent());
    if (atTime) {
      return group.atTime(atTime);
    } else {
      return group;
    }
  }
  getParentGroups() {
    const groups = [];
    for (const [parentGroupId, entry] of this.parentGroupsChanges.entries()) {
      const role = entry.getAtTime(this.atTimeFilter);
      if (!role || role === "revoked")
        continue;
      groups.push(this.getParentGroup(parentGroupId, this.atTimeFilter));
    }
    return groups;
  }
  forEachChildGroup(callback) {
    for (const id2 of this.core.dependant) {
      const dependant = this.core.node.getCoValue(id2);
      if (!dependant.isGroup()) {
        continue;
      }
      const childGroup = expectGroup(dependant.getCurrentContent());
      const reference = childGroup.get(`parent_${this.id}`);
      if (reference && reference !== "revoked") {
        callback(childGroup);
      }
    }
  }
  /**
   * Returns the role of the current account in the group.
   *
   * @category 1. Role reading
   */
  myRole() {
    return this.roleOfInternal(this.core.node.getCurrentAccountOrAgentID());
  }
  /**
   * Directly grants a new member a role in the group. The current account must be an
   * admin to be able to do so. Throws otherwise.
   *
   * @category 2. Role changing
   */
  addMember(account, role) {
    this.addMemberInternal(account, role);
  }
  /** @internal */
  addMemberInternal(account, role) {
    const memberKey = typeof account === "string" ? account : account.id;
    const previousRole = this.get(memberKey);
    if (previousRole === role) {
      return;
    }
    if (memberKey === EVERYONE) {
      if (!(role === "reader" || role === "writer" || role === "writeOnly")) {
        throw new Error("Can't make everyone something other than reader, writer or writeOnly");
      }
      const currentReadKey = this.getCurrentReadKey();
      if (!currentReadKey.secret) {
        throw new Error("Can't add member without read key secret");
      }
      const previousRole2 = this.get(memberKey);
      this.set(memberKey, role, "trusting");
      if (this.get(memberKey) !== role) {
        throw new Error(`Failed to set role ${role} to ${memberKey} (role of current account is ${this.myRole()})`);
      }
      if (role === "writeOnly") {
        if (previousRole2 === "reader" || previousRole2 === "writer") {
          this.rotateReadKey("everyone");
        }
        this.delete(`${currentReadKey.id}_for_${EVERYONE}`);
      } else {
        this.set(`${currentReadKey.id}_for_${EVERYONE}`, currentReadKey.secret, "trusting");
      }
      return;
    }
    const agent = typeof account === "string" ? account : account.currentAgentID();
    if (agent === EVERYONE) {
      throw new Error("Agent should not be everyone");
    }
    if (role === "writeOnly" || role === "writeOnlyInvite") {
      if (previousRole === "reader" || previousRole === "writer" || previousRole === "manager" || previousRole === "admin") {
        this.rotateReadKey(memberKey);
      }
      this.set(memberKey, role, "trusting");
      if (this.get(memberKey) !== role) {
        throw new Error(`Failed to set role ${role} to ${memberKey} (role of current account is ${this.myRole()})`);
      }
      this.internalCreateWriteOnlyKeyForMember(memberKey, agent);
    } else {
      const currentReadKey = this.getCurrentReadKey();
      if (!currentReadKey.secret) {
        throw new Error("Can't add member without read key secret");
      }
      this.set(memberKey, role, "trusting");
      if (this.get(memberKey) !== role) {
        throw new Error(`Failed to set role ${role} to ${memberKey} (role of current account is ${this.myRole()})`);
      }
      this.storeKeyRevelationForMember(memberKey, agent, currentReadKey.id, currentReadKey.secret);
      for (const keyID of this.getWriteOnlyKeys()) {
        const secret = this.core.getReadKey(keyID);
        if (!secret) {
          logger.error("Can't find key " + keyID);
          continue;
        }
        this.storeKeyRevelationForMember(memberKey, agent, keyID, secret);
      }
    }
  }
  internalCreateWriteOnlyKeyForMember(memberKey, agent) {
    const writeKeyForNewMember = this.crypto.newRandomKeySecret();
    this.set(`writeKeyFor_${memberKey}`, writeKeyForNewMember.id, "trusting");
    this.storeKeyRevelationForMember(memberKey, agent, writeKeyForNewMember.id, writeKeyForNewMember.secret);
    for (const otherMemberKey of this.getMemberKeys()) {
      const memberRole = this.get(otherMemberKey);
      if (memberRole === "reader" || memberRole === "writer" || memberRole === "admin" || memberRole === "manager" || memberRole === "readerInvite" || memberRole === "writerInvite" || memberRole === "adminInvite") {
        const otherMemberAgent = this.core.node.resolveAccountAgent(otherMemberKey, "Expected member agent to be loaded").value;
        if (!otherMemberAgent) {
          throw new Error("Expected member agent to be loaded");
        }
        this.storeKeyRevelationForMember(otherMemberKey, otherMemberAgent, writeKeyForNewMember.id, writeKeyForNewMember.secret);
      }
    }
    for (const parentGroup of this.getParentGroups()) {
      this.revealReadKeyToParentGroup(parentGroup, writeKeyForNewMember.id, writeKeyForNewMember.secret, { revealAllWriteOnlyKeys: false });
    }
    return writeKeyForNewMember.id;
  }
  storeKeyRevelationForMember(memberKey, agent, keyID, secret) {
    this.set(`${keyID}_for_${memberKey}`, this.crypto.seal({
      message: secret,
      from: this.core.node.getCurrentAgent().currentSealerSecret(),
      to: this.crypto.getAgentSealerID(agent),
      nOnceMaterial: {
        in: this.id,
        tx: this.core.nextTransactionID()
      }
    }), "trusting");
  }
  storeKeyRevelationForParentGroup(parentReadKeyID, parentReadKeySecret, childReadKeyID, childReadKeySecret) {
    this.set(`${childReadKeyID}_for_${parentReadKeyID}`, this.crypto.encryptKeySecret({
      encrypting: {
        id: parentReadKeyID,
        secret: parentReadKeySecret
      },
      toEncrypt: {
        id: childReadKeyID,
        secret: childReadKeySecret
      }
    }).encrypted, "trusting");
  }
  getWriteOnlyKeys() {
    const keys = [];
    for (const key of this.keys()) {
      if (key.startsWith("writeKeyFor_")) {
        keys.push(this.get(key));
      }
    }
    return keys;
  }
  getCurrentReadKeyId() {
    if (this._lastReadableKeyId) {
      return this._lastReadableKeyId;
    }
    const myRole = this.myRole();
    if (myRole === "writeOnly") {
      const accountId = this.core.node.getCurrentAgent().id;
      const key = this.get(`writeKeyFor_${accountId}`);
      if (!key && this.get("everyone") === "writeOnly") {
        this.internalCreateWriteOnlyKeyForMember(accountId, this.core.node.getCurrentAgent().currentAgentID());
        return this.get(`writeKeyFor_${accountId}`);
      }
      return key;
    }
    if (!myRole) {
      const accountId = this.core.node.getCurrentAgent().id;
      const key = this.get(`writeKeyFor_${accountId}`);
      if (key) {
        return key;
      }
    }
    return this.get("readKey");
  }
  getMemberKeys() {
    return this.keys().filter((key) => {
      return key.startsWith("co_") || isAgentID(key);
    });
  }
  getAllMemberKeysSet() {
    const memberKeys = new Set(this.getMemberKeys());
    for (const group of this.getParentGroups()) {
      for (const key of group.getAllMemberKeysSet()) {
        memberKeys.add(key);
      }
    }
    return memberKeys;
  }
  getReadKey(keyID) {
    const cache = this.core.readKeyCache;
    let key = cache.get(keyID);
    if (!key) {
      key = this.getUncachedReadKey(keyID);
      if (key) {
        cache.set(keyID, key);
      }
    }
    return key;
  }
  getUncachedReadKey(keyID) {
    const core2 = this.core;
    const keyForEveryone = this.get(`${keyID}_for_everyone`);
    if (keyForEveryone) {
      return keyForEveryone;
    }
    const currentAgentOrAccountID = accountOrAgentIDfromSessionID(core2.node.currentSessionID);
    const lookupAccountOrAgentID = isAccountID(currentAgentOrAccountID) ? core2.id === currentAgentOrAccountID ? core2.node.crypto.getAgentID(core2.node.agentSecret) : currentAgentOrAccountID : currentAgentOrAccountID;
    const lastReadyKeyEdit = this.lastEditAt(`${keyID}_for_${lookupAccountOrAgentID}`);
    if (lastReadyKeyEdit?.value) {
      const revealer = lastReadyKeyEdit.by;
      const revealerAgent = core2.node.resolveAccountAgent(revealer, "Expected to know revealer").value;
      if (!revealerAgent) {
        throw new Error("Expected to know revealer");
      }
      const secret = this.crypto.unseal(
        lastReadyKeyEdit.value,
        this.crypto.getAgentSealerSecret(core2.node.agentSecret),
        // being careful here to avoid recursion
        this.crypto.getAgentSealerID(revealerAgent),
        {
          in: this.id,
          tx: lastReadyKeyEdit.tx
        }
      );
      if (secret) {
        return secret;
      }
    }
    const revelationsForKey = this.keyRevelations.get(keyID);
    if (revelationsForKey) {
      for (const encryptingKeyID of revelationsForKey) {
        const encryptingKeySecret = this.getReadKey(encryptingKeyID);
        if (!encryptingKeySecret) {
          continue;
        }
        const encryptedPreviousKey = this.get(`${keyID}_for_${encryptingKeyID}`);
        const secret = this.crypto.decryptKeySecret({
          encryptedID: keyID,
          encryptingID: encryptingKeyID,
          encrypted: encryptedPreviousKey
        }, encryptingKeySecret);
        if (secret) {
          return secret;
        } else {
          logger.warn(`Encrypting ${encryptingKeyID} key didn't decrypt ${keyID}`);
        }
      }
    }
    for (const parentGroupID of this.parentGroupsChanges.keys()) {
      const parentGroup = core2.node.expectCoValueLoaded(parentGroupID, "Expected parent group to be loaded");
      const parentKeys = this.findValidParentKeys(keyID, parentGroup);
      for (const parentKey of parentKeys) {
        const revelationForParentKey = this.get(`${keyID}_for_${parentKey.id}`);
        if (revelationForParentKey) {
          const secret = parentGroup.node.crypto.decryptKeySecret({
            encryptedID: keyID,
            encryptingID: parentKey.id,
            encrypted: revelationForParentKey
          }, parentKey.secret);
          if (secret) {
            return secret;
          } else {
            logger.warn(`Encrypting parent ${parentKey.id} key didn't decrypt ${keyID}`);
          }
        }
      }
    }
    return void 0;
  }
  findValidParentKeys(keyID, parentGroup) {
    const validParentKeys = [];
    const revelationsForKey = this.keyRevelations.get(keyID);
    if (revelationsForKey) {
      for (const encryptingKeyID of revelationsForKey) {
        const encryptingKeySecret = parentGroup.getReadKey(encryptingKeyID);
        if (!encryptingKeySecret) {
          continue;
        }
        validParentKeys.push({
          id: encryptingKeyID,
          secret: encryptingKeySecret
        });
      }
    }
    return validParentKeys;
  }
  /** @internal */
  rotateReadKey(removedMemberKey) {
    if (removedMemberKey !== EVERYONE && canRead(this, EVERYONE)) {
      return;
    }
    const memberKeys = this.getMemberKeys().filter((key) => key !== removedMemberKey);
    const currentlyPermittedReaders = memberKeys.filter((key) => canRead(this, key));
    const writeOnlyMembers = memberKeys.filter((key) => {
      const role = this.get(key);
      return role === "writeOnly" || role === "writeOnlyInvite";
    });
    const parentGroups = this.getParentGroups();
    const maybeCurrentReadKey = this.getCurrentReadKey();
    if (!maybeCurrentReadKey.secret) {
      throw new NoReadKeyAccessError("Can't rotate read key secret we don't have access to");
    }
    const currentReadKey = {
      id: maybeCurrentReadKey.id,
      secret: maybeCurrentReadKey.secret
    };
    const newReadKey = this.crypto.newRandomKeySecret();
    for (const readerID of currentlyPermittedReaders) {
      const agent = this.core.node.resolveAccountAgent(readerID, "Expected to know currently permitted reader").value;
      if (!agent) {
        throw new Error("Expected to know currently permitted reader");
      }
      this.storeKeyRevelationForMember(readerID, agent, newReadKey.id, newReadKey.secret);
    }
    for (const writeOnlyMemberID of writeOnlyMembers) {
      const agent = this.core.node.resolveAccountAgent(writeOnlyMemberID, "Expected to know writeOnly member").value;
      if (!agent) {
        throw new Error("Expected to know writeOnly member");
      }
      const writeOnlyKey = this.crypto.newRandomKeySecret();
      this.storeKeyRevelationForMember(writeOnlyMemberID, agent, writeOnlyKey.id, writeOnlyKey.secret);
      this.set(`writeKeyFor_${writeOnlyMemberID}`, writeOnlyKey.id, "trusting");
      for (const readerID of currentlyPermittedReaders) {
        const agent2 = this.core.node.resolveAccountAgent(readerID, "Expected to know currently permitted reader").value;
        if (!agent2) {
          throw new Error("Expected to know currently permitted reader");
        }
        this.storeKeyRevelationForMember(readerID, agent2, writeOnlyKey.id, writeOnlyKey.secret);
      }
      for (const parentGroup of this.getParentGroups()) {
        this.revealReadKeyToParentGroup(parentGroup, writeOnlyKey.id, writeOnlyKey.secret, { revealAllWriteOnlyKeys: false });
      }
    }
    this.set(`${currentReadKey.id}_for_${newReadKey.id}`, this.crypto.encryptKeySecret({
      encrypting: newReadKey,
      toEncrypt: currentReadKey
    }).encrypted, "trusting");
    this.set("readKey", newReadKey.id, "trusting");
    for (const parent of parentGroups) {
      const { id: parentReadKeyID, secret: parentReadKeySecret } = parent.getCurrentReadKey();
      if (!parentReadKeySecret) {
        logger.warn("Can't reveal new child key to parent where we don't have access to the parent read key");
        continue;
      }
      this.storeKeyRevelationForParentGroup(parentReadKeyID, parentReadKeySecret, newReadKey.id, newReadKey.secret);
    }
    this.forEachChildGroup((child) => {
      if (child.isSelfExtension(this)) {
        return;
      }
      try {
        child.rotateReadKey(removedMemberKey);
      } catch (error) {
        if (error instanceof NoReadKeyAccessError) {
          logger.warn(`Can't rotate read key on child ${child.id} because we don't have access to the read key`);
        } else {
          throw error;
        }
      }
    });
  }
  /** Detect circular references in group inheritance */
  isSelfExtension(parent) {
    return isSelfExtension(this.core, parent);
  }
  getCurrentReadKey() {
    const keyId = this.getCurrentReadKeyId();
    if (!keyId) {
      throw new Error("No readKey set");
    }
    return {
      secret: this.getReadKey(keyId),
      id: keyId
    };
  }
  extend(parent, role = "inherit") {
    if (this.isSelfExtension(parent)) {
      return;
    }
    if (this.myRole() !== "admin") {
      throw new Error("To extend a group, the current account must be an admin in the child group");
    }
    const value = role === "inherit" ? "extend" : role;
    this.set(`parent_${parent.id}`, value, "trusting");
    const { id: childReadKeyID, secret: childReadKeySecret } = this.getCurrentReadKey();
    if (childReadKeySecret === void 0) {
      throw new Error("Can't extend group without child read key secret");
    }
    this.revealReadKeyToParentGroup(parent, childReadKeyID, childReadKeySecret, { revealAllWriteOnlyKeys: true });
  }
  revealReadKeyToParentGroup(parent, readKeyId, readKeySecret, { revealAllWriteOnlyKeys }) {
    let writeOnlyKeyID;
    if (!isAccountRole(parent.myRole())) {
      writeOnlyKeyID = parent.internalCreateWriteOnlyKeyForMember(this.core.node.getCurrentAgent().id, this.core.node.getCurrentAgent().currentAgentID());
    }
    let { id: parentReadKeyID, secret: parentReadKeySecret } = parent.getCurrentReadKey();
    if (!parentReadKeySecret) {
      throw new Error("Can't extend group without parent read key secret");
    }
    this.storeKeyRevelationForParentGroup(parentReadKeyID, parentReadKeySecret, readKeyId, readKeySecret);
    if (revealAllWriteOnlyKeys) {
      for (const keyID of this.getWriteOnlyKeys()) {
        if (keyID === writeOnlyKeyID) {
          continue;
        }
        const secret = this.core.getReadKey(keyID);
        if (!secret) {
          logger.error("Can't find key " + keyID);
          continue;
        }
        this.storeKeyRevelationForParentGroup(parentReadKeyID, parentReadKeySecret, keyID, secret);
      }
    }
  }
  revokeExtend(parent) {
    if (this.myRole() !== "admin") {
      throw new Error("To unextend a group, the current account must be an admin in the child group");
    }
    if (!isAccountRole(parent.myRole())) {
      throw new Error("To unextend a group, the current account must be a member of the parent group");
    }
    if (!this.get(`parent_${parent.id}`) || this.get(`parent_${parent.id}`) === "revoked") {
      return;
    }
    this.set(`parent_${parent.id}`, "revoked", "trusting");
    if (parent.get(`child_${this.id}`)) {
      parent.set(`child_${this.id}`, "revoked", "trusting");
    }
    this.rotateReadKey();
  }
  /**
   * Strips the specified member of all roles (preventing future writes in
   *  the group and owned values) and rotates the read encryption key for that group
   * (preventing reads of new content in the group and owned values)
   *
   * @category 2. Role changing
   */
  removeMember(account) {
    const memberKey = typeof account === "string" ? account : account.id;
    if (this.myRole() === "admin" || this.myRole() === "manager") {
      this.rotateReadKey(memberKey);
    }
    this.set(memberKey, "revoked", "trusting");
    if (this.get(memberKey) !== "revoked") {
      throw new Error(`Failed to revoke role to ${memberKey} (role of current account is ${this.myRole()})`);
    }
  }
  /**
   * Creates an invite for new members to indirectly join the group,
   * allowing them to grant themselves the specified role with the InviteSecret
   * (a string starting with "inviteSecret_") - use `LocalNode.acceptInvite()` for this purpose.
   *
   * @category 2. Role changing
   */
  createInvite(role) {
    const secretSeed = this.crypto.newRandomSecretSeed();
    const inviteSecret = this.crypto.agentSecretFromSecretSeed(secretSeed);
    const inviteID = this.crypto.getAgentID(inviteSecret);
    this.addMemberInternal(inviteID, `${role}Invite`);
    return inviteSecretFromSecretSeed(secretSeed);
  }
  /**
   * Creates a new `CoMap` within this group, with the specified specialized
   * `CoMap` type `M` and optional static metadata.
   *
   * @category 3. Value creation
   */
  createMap(init, meta, initPrivacy = "private", uniqueness = this.crypto.createdNowUnique()) {
    const map = this.core.node.createCoValue({
      type: "comap",
      ruleset: {
        type: "ownedByGroup",
        group: this.id
      },
      meta: meta || null,
      ...uniqueness.createdAt !== void 0 ? { createdAt: uniqueness.createdAt } : {},
      uniqueness: uniqueness.uniqueness
    }).getCurrentContent();
    if (init) {
      map.assign(init, initPrivacy);
    } else if (!uniqueness.createdAt) {
      map.core.makeTransaction([], "trusting");
    }
    return map;
  }
  /**
   * Creates a new `CoList` within this group, with the specified specialized
   * `CoList` type `L` and optional static metadata.
   *
   * @category 3. Value creation
   */
  createList(init, meta, initPrivacy = "private", uniqueness = this.crypto.createdNowUnique()) {
    const list = this.core.node.createCoValue({
      type: "colist",
      ruleset: {
        type: "ownedByGroup",
        group: this.id
      },
      meta: meta || null,
      ...uniqueness.createdAt !== void 0 ? { createdAt: uniqueness.createdAt } : {},
      uniqueness: uniqueness.uniqueness
    }).getCurrentContent();
    if (init?.length) {
      list.appendItems(init, void 0, initPrivacy);
    } else if (!uniqueness.createdAt) {
      list.core.makeTransaction([], "trusting");
    }
    return list;
  }
  /**
   * Creates a new `CoPlainText` within this group, with the specified specialized
   * `CoPlainText` type `T` and optional static metadata.
   *
   * @category 3. Value creation
   */
  createPlainText(init, meta, initPrivacy = "private") {
    const text = this.core.node.createCoValue({
      type: "coplaintext",
      ruleset: {
        type: "ownedByGroup",
        group: this.id
      },
      meta: meta || null,
      ...this.crypto.createdNowUnique()
    }).getCurrentContent();
    if (init) {
      text.insertAfter(0, init, initPrivacy);
    }
    return text;
  }
  /** @category 3. Value creation */
  createStream(meta, uniqueness = this.crypto.createdNowUnique()) {
    const stream = this.core.node.createCoValue({
      type: "costream",
      ruleset: {
        type: "ownedByGroup",
        group: this.id
      },
      meta: meta || null,
      ...uniqueness.createdAt !== void 0 ? { createdAt: uniqueness.createdAt } : {},
      uniqueness: uniqueness.uniqueness
    }).getCurrentContent();
    if (!uniqueness.createdAt) {
      stream.core.makeTransaction([], "trusting");
    }
    return stream;
  }
  /** @category 3. Value creation */
  createBinaryStream(meta = { type: "binary" }, uniqueness = this.crypto.createdNowUnique()) {
    return this.core.node.createCoValue({
      type: "costream",
      ruleset: {
        type: "ownedByGroup",
        group: this.id
      },
      meta,
      ...uniqueness.createdAt !== void 0 ? { createdAt: uniqueness.createdAt } : {},
      uniqueness: uniqueness.uniqueness
    }).getCurrentContent();
  }
}
function isInheritableRole(roleInParent) {
  return roleInParent === "revoked" || roleInParent === "admin" || roleInParent === "manager" || roleInParent === "writer" || roleInParent === "reader";
}
function isMorePermissiveAndShouldInherit(roleInParent, roleInChild) {
  if (roleInParent === "revoked") {
    return true;
  }
  if (roleInParent === "manager") {
    return !roleInChild || roleInChild !== "manager" && roleInChild !== "admin";
  }
  if (roleInParent === "admin") {
    return !roleInChild || roleInChild !== "admin";
  }
  if (roleInParent === "writer") {
    return !roleInChild || roleInChild === "reader" || roleInChild === "writeOnly";
  }
  if (roleInParent === "reader") {
    return !roleInChild;
  }
  if (roleInParent === "writeOnly") {
    return false;
  }
  return false;
}
function inviteSecretFromSecretSeed(secretSeed) {
  return `inviteSecret_z${base58.encode(secretSeed)}`;
}
function secretSeedFromInviteSecret(inviteSecret) {
  if (!inviteSecret.startsWith("inviteSecret_z")) {
    throw new Error("Invalid invite secret");
  }
  return base58.decode(inviteSecret.slice("inviteSecret_z".length));
}
const canRead = (group, key) => {
  const role = group.get(key);
  return role === "admin" || role === "manager" || role === "writer" || role === "reader" || role === "adminInvite" || role === "writerInvite" || role === "readerInvite";
};
class NoReadKeyAccessError extends Error {
  constructor(message) {
    super(message);
    this.name = "NoReadKeyAccessError";
  }
}
function isSelfExtension(coValue, parent) {
  const checkedGroups = /* @__PURE__ */ new Set();
  const queue = [parent];
  while (true) {
    const current = queue.pop();
    if (!current) {
      return false;
    }
    if (current.id === coValue.id) {
      return true;
    }
    checkedGroups.add(current.id);
    const parentGroups = current.getParentGroups();
    for (const parent2 of parentGroups) {
      if (!checkedGroups.has(parent2.id)) {
        queue.push(parent2);
      }
    }
  }
}
function accountHeaderForInitialAgentSecret$1(agentSecret, crypto2) {
  const agent = crypto2.getAgentID(agentSecret);
  return {
    type: "comap",
    ruleset: { type: "group", initialAdmin: agent },
    meta: {
      type: "account"
    },
    createdAt: null,
    uniqueness: null
  };
}
class RawAccount extends RawGroup {
  currentAgentID() {
    if (this._cachedCurrentAgentID)
      return this._cachedCurrentAgentID;
    const header = this.core.verified.header;
    if (header.ruleset.type !== "group") {
      throw new Error("You can't get an agent id from a non-group value");
    }
    const initialAdmin = header.ruleset.initialAdmin;
    if (!isAgentID(initialAdmin)) {
      throw new Error("You can read agent ids only from account values");
    }
    this._cachedCurrentAgentID = initialAdmin;
    return initialAdmin;
  }
  createInvite(_) {
    throw new Error("Cannot create invite from an account");
  }
  roleOfInternal(accountID) {
    if (accountID === this.id) {
      return "admin";
    }
    return super.roleOfInternal(accountID);
  }
  addMember(account, role) {
    throw new Error("Cannot add a member to an account");
  }
  removeMember(account) {
    throw new Error("Cannot remove a member from an account");
  }
  extend(parent, role = "inherit") {
    throw new Error("Cannot extend an account");
  }
  revokeExtend(parent) {
    throw new Error("Cannot unextend an account");
  }
}
class ControlledAccount {
  constructor(account, agentSecret) {
    this.account = account;
    this.agentSecret = agentSecret;
    this.crypto = account.core.node.crypto;
  }
  get id() {
    return this.account.id;
  }
  currentAgentID() {
    const agentID = this.crypto.getAgentID(this.agentSecret);
    return agentID;
  }
  currentSignerID() {
    const signerID = this.crypto.getAgentSignerID(this.currentAgentID());
    return signerID;
  }
  currentSignerSecret() {
    const signerSecret = this.crypto.getAgentSignerSecret(this.agentSecret);
    return signerSecret;
  }
  currentSealerID() {
    const sealerID = this.crypto.getAgentSealerID(this.currentAgentID());
    return sealerID;
  }
  currentSealerSecret() {
    const sealerSecret = this.crypto.getAgentSealerSecret(this.agentSecret);
    return sealerSecret;
  }
}
class ControlledAgent {
  constructor(agentSecret, crypto2) {
    this.agentSecret = agentSecret;
    this.crypto = crypto2;
  }
  get id() {
    return this.crypto.getAgentID(this.agentSecret);
  }
  currentAgentID() {
    return this.crypto.getAgentID(this.agentSecret);
  }
  currentSignerID() {
    return this.crypto.getAgentSignerID(this.currentAgentID());
  }
  currentSignerSecret() {
    return this.crypto.getAgentSignerSecret(this.agentSecret);
  }
  currentSealerID() {
    return this.crypto.getAgentSealerID(this.currentAgentID());
  }
  currentSealerSecret() {
    return this.crypto.getAgentSealerSecret(this.agentSecret);
  }
}
function expectAccount(content) {
  if (!(content instanceof RawAccount)) {
    throw new Error("Expected an account");
  }
  return content;
}
function decodeUnicodeData(data2, cats = "") {
  let buf = (
    /** @type {Array<CategorizedUnicodeRange<T>>} */
    []
  ), nums = data2.split(",").map((s) => s ? parseInt(s, 36) : 0), n = 0;
  for (let i = 0; i < nums.length; i++)
    i % 2 ? buf.push([
      n,
      n + nums[i],
      /** @type {T} */
      cats ? parseInt(cats[i >> 1], 36) : 0
    ]) : n = nums[i];
  return buf;
}
function findUnicodeRangeIndex(cp, ranges) {
  let lo = 0, hi = ranges.length - 1;
  while (lo <= hi) {
    let mid = lo + hi >> 1, range = ranges[mid], l = range[0], h = range[1];
    if (l <= cp && cp <= h) return mid;
    else if (cp > h) lo = mid + 1;
    else hi = mid - 1;
  }
  return -1;
}
function isBMP(c) {
  return c <= 65535;
}
const grapheme_ranges = decodeUnicodeData(
  /** @type {UnicodeDataEncoding} */
  ",9,a,,b,1,d,,e,h,3j,w,4p,,4t,,4u,,lc,33,w3,6,13l,18,14v,,14x,1,150,1,153,,16o,5,174,a,17g,,18r,k,19s,,1cm,6,1ct,,1cv,5,1d3,1,1d6,3,1e7,,1e9,,1f4,q,1ie,a,1kb,8,1kt,,1li,3,1ln,8,1lx,2,1m1,4,1nd,2,1ow,1,1p3,8,1qi,n,1r6,,1r7,v,1s3,,1tm,,1tn,,1to,,1tq,2,1tt,7,1u1,3,1u5,,1u6,1,1u9,6,1uq,1,1vl,,1vm,1,1x8,,1xa,,1xb,1,1xd,3,1xj,1,1xn,1,1xp,,1xz,,1ya,1,1z2,,1z5,1,1z7,,20s,,20u,2,20x,1,213,1,217,2,21d,,228,1,22d,,22p,1,22r,,24c,,24e,2,24h,4,24n,1,24p,,24r,1,24t,,25e,1,262,5,269,,26a,1,27w,,27y,1,280,,281,3,287,1,28b,1,28d,,28l,2,28y,1,29u,,2bi,,2bj,,2bk,,2bl,1,2bq,2,2bu,2,2bx,,2c7,,2dc,,2dd,2,2dg,,2f0,,2f2,2,2f5,3,2fa,2,2fe,3,2fp,1,2g2,1,2gx,,2gy,1,2ik,,2im,,2in,1,2ip,,2iq,,2ir,1,2iu,2,2iy,3,2j9,1,2jm,1,2k3,,2kg,1,2ki,1,2m3,1,2m6,,2m7,1,2m9,3,2me,2,2mi,2,2ml,,2mm,,2mv,,2n6,1,2o1,,2o2,1,2q2,,2q7,,2q8,1,2qa,2,2qe,,2qg,6,2qn,,2r6,1,2sx,,2sz,,2t0,6,2tj,7,2wh,,2wj,,2wk,8,2x4,6,2zc,1,305,,307,,309,,30e,1,31t,d,327,,328,4,32e,1,32l,a,32x,z,346,,371,3,375,,376,5,37d,1,37f,1,37h,1,386,1,388,1,38e,2,38x,3,39e,,39g,,39h,1,39p,,3a5,,3cw,2n,3fk,1z,3hk,2f,3tp,2,4k2,3,4ky,2,4lu,1,4mq,1,4ok,1,4om,,4on,6,4ou,7,4p2,,4p3,1,4p5,a,4pp,,4qz,2,4r2,,4r3,,4ud,1,4vd,,4yo,2,4yr,3,4yv,1,4yx,2,4z4,1,4z6,,4z7,5,4zd,2,55j,1,55l,1,55n,,579,,57a,,57b,,57c,6,57k,,57m,,57p,7,57x,5,583,9,58f,,59s,u,5c0,3,5c4,,5dg,9,5dq,3,5du,2,5ez,8,5fk,1,5fm,,5gh,,5gi,3,5gm,1,5go,5,5ie,,5if,,5ig,1,5ii,2,5il,,5im,,5in,4,5k4,7,5kc,7,5kk,1,5km,1,5ow,2,5p0,c,5pd,,5pe,6,5pp,,5pw,,5pz,,5q0,1,5vk,1r,6bv,,6bw,,6bx,,6by,1,6co,6,6d8,,6dl,,6e8,f,6hc,w,6jm,,6k9,,6ms,5,6nd,1,6xm,1,6y0,,70o,,72n,,73d,a,73s,2,79e,,7fu,1,7g6,,7gg,,7i3,3,7i8,5,7if,b,7is,35,7m8,39,7pk,a,7pw,,7py,,7q5,,7q9,,7qg,,7qr,1,7r8,,7rb,,7rg,,7ri,,7rn,2,7rr,,7s3,4,7th,2,7tt,,7u8,,7un,,850,1,8hx,2,8ij,1,8k0,,8k5,,8vj,2,8zj,,928,v,9ii,5,9io,,9j1,,9ll,1,9zr,,9zt,,wvj,3,wvo,9,wwu,1,wz4,1,x6q,,x6u,,x6z,,x7n,1,x7p,1,x7r,,x7w,,xa8,1,xbo,f,xc4,1,xcw,h,xdr,,xeu,7,xfr,a,xg2,,xg3,,xgg,s,xhc,2,xhf,,xir,,xis,1,xiu,3,xiy,1,xj0,1,xj2,1,xj4,,xk5,,xm1,5,xm7,1,xm9,1,xmb,1,xmd,1,xmr,,xn0,,xn1,,xoc,,xps,,xpu,2,xpz,1,xq6,1,xq9,,xrf,,xrg,1,xri,1,xrp,,xrq,,xyb,1,xyd,,xye,1,xyg,,xyh,1,xyk,,xyl,,xz4,,xz5,q,xzw,,xzx,q,y0o,,y0p,q,y1g,,y1h,q,y28,,y29,q,y30,,y31,q,y3s,,y3t,q,y4k,,y4l,q,y5c,,y5d,q,y64,,y65,q,y6w,,y6x,q,y7o,,y7p,q,y8g,,y8h,q,y98,,y99,q,ya0,,ya1,q,yas,,yat,q,ybk,,ybl,q,ycc,,ycd,q,yd4,,yd5,q,ydw,,ydx,q,yeo,,yep,q,yfg,,yfh,q,yg8,,yg9,q,yh0,,yh1,q,yhs,,yht,q,yik,,yil,q,yjc,,yjd,q,yk4,,yk5,q,ykw,,ykx,q,ylo,,ylp,q,ymg,,ymh,q,yn8,,yn9,q,yo0,,yo1,q,yos,,yot,q,ypk,,ypl,q,yqc,,yqd,q,yr4,,yr5,q,yrw,,yrx,q,yso,,ysp,q,ytg,,yth,q,yu8,,yu9,q,yv0,,yv1,q,yvs,,yvt,q,ywk,,ywl,q,yxc,,yxd,q,yy4,,yy5,q,yyw,,yyx,q,yzo,,yzp,q,z0g,,z0h,q,z18,,z19,q,z20,,z21,q,z2s,,z2t,q,z3k,,z3l,q,z4c,,z4d,q,z54,,z55,q,z5w,,z5x,q,z6o,,z6p,q,z7g,,z7h,q,z88,,z89,q,z90,,z91,q,z9s,,z9t,q,zak,,zal,q,zbc,,zbd,q,zc4,,zc5,q,zcw,,zcx,q,zdo,,zdp,q,zeg,,zeh,q,zf8,,zf9,q,zg0,,zg1,q,zgs,,zgt,q,zhk,,zhl,q,zic,,zid,q,zj4,,zj5,q,zjw,,zjx,q,zko,,zkp,q,zlg,,zlh,q,zm8,,zm9,q,zn0,,zn1,q,zns,,znt,q,zok,,zol,q,zpc,,zpd,q,zq4,,zq5,q,zqw,,zqx,q,zro,,zrp,q,zsg,,zsh,q,zt8,,zt9,q,zu0,,zu1,q,zus,,zut,q,zvk,,zvl,q,zwc,,zwd,q,zx4,,zx5,q,zxw,,zxx,q,zyo,,zyp,q,zzg,,zzh,q,1008,,1009,q,1010,,1011,q,101s,,101t,q,102k,,102l,q,103c,,103d,q,1044,,1045,q,104w,,104x,q,105o,,105p,q,106g,,106h,q,1078,,1079,q,1080,,1081,q,108s,,108t,q,109k,,109l,q,10ac,,10ad,q,10b4,,10b5,q,10bw,,10bx,q,10co,,10cp,q,10dg,,10dh,q,10e8,,10e9,q,10f0,,10f1,q,10fs,,10ft,q,10gk,,10gl,q,10hc,,10hd,q,10i4,,10i5,q,10iw,,10ix,q,10jo,,10jp,q,10kg,,10kh,q,10l8,,10l9,q,10m0,,10m1,q,10ms,,10mt,q,10nk,,10nl,q,10oc,,10od,q,10p4,,10p5,q,10pw,,10px,q,10qo,,10qp,q,10rg,,10rh,q,10s8,,10s9,q,10t0,,10t1,q,10ts,,10tt,q,10uk,,10ul,q,10vc,,10vd,q,10w4,,10w5,q,10ww,,10wx,q,10xo,,10xp,q,10yg,,10yh,q,10z8,,10z9,q,1100,,1101,q,110s,,110t,q,111k,,111l,q,112c,,112d,q,1134,,1135,q,113w,,113x,q,114o,,114p,q,115g,,115h,q,1168,,1169,q,1170,,1171,q,117s,,117t,q,118k,,118l,q,119c,,119d,q,11a4,,11a5,q,11aw,,11ax,q,11bo,,11bp,q,11cg,,11ch,q,11d8,,11d9,q,11e0,,11e1,q,11es,,11et,q,11fk,,11fl,q,11gc,,11gd,q,11h4,,11h5,q,11hw,,11hx,q,11io,,11ip,q,11jg,,11jh,q,11k8,,11k9,q,11l0,,11l1,q,11ls,,11lt,q,11mk,,11ml,q,11nc,,11nd,q,11o4,,11o5,q,11ow,,11ox,q,11po,,11pp,q,11qg,,11qh,q,11r8,,11r9,q,11s0,,11s1,q,11ss,,11st,q,11tk,,11tl,q,11uc,,11ud,q,11v4,,11v5,q,11vw,,11vx,q,11wo,,11wp,q,11xg,,11xh,q,11y8,,11y9,q,11z0,,11z1,q,11zs,,11zt,q,120k,,120l,q,121c,,121d,q,1224,,1225,q,122w,,122x,q,123o,,123p,q,124g,,124h,q,1258,,1259,q,1260,,1261,q,126s,,126t,q,127k,,127l,q,128c,,128d,q,1294,,1295,q,129w,,129x,q,12ao,,12ap,q,12bg,,12bh,q,12c8,,12c9,q,12d0,,12d1,q,12ds,,12dt,q,12ek,,12el,q,12fc,,12fd,q,12g4,,12g5,q,12gw,,12gx,q,12ho,,12hp,q,12ig,,12ih,q,12j8,,12j9,q,12k0,,12k1,q,12ks,,12kt,q,12lk,,12ll,q,12mc,,12md,q,12n4,,12n5,q,12nw,,12nx,q,12oo,,12op,q,12pg,,12ph,q,12q8,,12q9,q,12r0,,12r1,q,12rs,,12rt,q,12sk,,12sl,q,12tc,,12td,q,12u4,,12u5,q,12uw,,12ux,q,12vo,,12vp,q,12wg,,12wh,q,12x8,,12x9,q,12y0,,12y1,q,12ys,,12yt,q,12zk,,12zl,q,130c,,130d,q,1314,,1315,q,131w,,131x,q,132o,,132p,q,133g,,133h,q,1348,,1349,q,1350,,1351,q,135s,,135t,q,136k,,136l,q,137c,,137d,q,1384,,1385,q,138w,,138x,q,139o,,139p,q,13ag,,13ah,q,13b8,,13b9,q,13c0,,13c1,q,13cs,,13ct,q,13dk,,13dl,q,13ec,,13ed,q,13f4,,13f5,q,13fw,,13fx,q,13go,,13gp,q,13hg,,13hh,q,13i8,,13i9,q,13j0,,13j1,q,13js,,13jt,q,13kk,,13kl,q,13lc,,13ld,q,13m4,,13m5,q,13mw,,13mx,q,13no,,13np,q,13og,,13oh,q,13p8,,13p9,q,13q0,,13q1,q,13qs,,13qt,q,13rk,,13rl,q,13sc,,13sd,q,13t4,,13t5,q,13tw,,13tx,q,13uo,,13up,q,13vg,,13vh,q,13w8,,13w9,q,13x0,,13x1,q,13xs,,13xt,q,13yk,,13yl,q,13zc,,13zd,q,1404,,1405,q,140w,,140x,q,141o,,141p,q,142g,,142h,q,1438,,1439,q,1440,,1441,q,144s,,144t,q,145k,,145l,q,146c,,146d,q,1474,,1475,q,147w,,147x,q,148o,,148p,q,149g,,149h,q,14a8,,14a9,q,14b0,,14b1,q,14bs,,14bt,q,14ck,,14cl,q,14dc,,14dd,q,14e4,,14e5,q,14ew,,14ex,q,14fo,,14fp,q,14gg,,14gh,q,14h8,,14h9,q,14i0,,14i1,q,14is,,14it,q,14jk,,14jl,q,14kc,,14kd,q,14l4,,14l5,q,14lw,,14lx,q,14mo,,14mp,q,14ng,,14nh,q,14o8,,14o9,q,14p0,,14p1,q,14ps,,14pt,q,14qk,,14ql,q,14rc,,14rd,q,14s4,,14s5,q,14sw,,14sx,q,14to,,14tp,q,14ug,,14uh,q,14v8,,14v9,q,14w0,,14w1,q,14ws,,14wt,q,14xk,,14xl,q,14yc,,14yd,q,14z4,,14z5,q,14zw,,14zx,q,150o,,150p,q,151g,,151h,q,1528,,1529,q,1530,,1531,q,153s,,153t,q,154k,,154l,q,155c,,155d,q,1564,,1565,q,156w,,156x,q,157o,,157p,q,158g,,158h,q,1598,,1599,q,15a0,,15a1,q,15as,,15at,q,15bk,,15bl,q,15cc,,15cd,q,15d4,,15d5,q,15dw,,15dx,q,15eo,,15ep,q,15fg,,15fh,q,15g8,,15g9,q,15h0,,15h1,q,15hs,,15ht,q,15ik,,15il,q,15jc,,15jd,q,15k4,,15k5,q,15kw,,15kx,q,15lo,,15lp,q,15mg,,15mh,q,15n8,,15n9,q,15o0,,15o1,q,15os,,15ot,q,15pk,,15pl,q,15qc,,15qd,q,15r4,,15r5,q,15rw,,15rx,q,15so,,15sp,q,15tg,,15th,q,15u8,,15u9,q,15v0,,15v1,q,15vs,,15vt,q,15wk,,15wl,q,15xc,,15xd,q,15y4,,15y5,q,15yw,,15yx,q,15zo,,15zp,q,160g,,160h,q,1618,,1619,q,1620,,1621,q,162s,,162t,q,163k,,163l,q,164c,,164d,q,1654,,1655,q,165w,,165x,q,166o,,166p,q,167g,,167h,q,1688,,1689,q,1690,,1691,q,169s,,169t,q,16ak,,16al,q,16bc,,16bd,q,16c4,,16c5,q,16cw,,16cx,q,16do,,16dp,q,16eg,,16eh,q,16f8,,16f9,q,16g0,,16g1,q,16gs,,16gt,q,16hk,,16hl,q,16ic,,16id,q,16j4,,16j5,q,16jw,,16jx,q,16ko,,16kp,q,16ls,m,16mj,1c,1dlq,,1e68,f,1e74,f,1edb,,1ehq,1,1ek0,b,1eyl,,1f4w,,1f92,4,1gjl,2,1gjp,1,1gjw,3,1gl4,2,1glb,,1gpx,1,1h5w,3,1h7t,4,1hgr,1,1hj0,3,1hl2,a,1hmq,3,1hq8,,1hq9,,1hqa,,1hrs,e,1htc,,1htf,1,1htr,2,1htu,,1hv4,2,1hv7,3,1hvb,1,1hvd,1,1hvh,,1hvm,,1hvx,,1hxc,2,1hyf,4,1hyk,,1hyl,7,1hz9,1,1i0j,,1i0w,1,1i0y,,1i2b,2,1i2e,8,1i2n,,1i2o,,1i2q,1,1i2x,3,1i32,,1i33,,1i5o,2,1i5r,2,1i5u,1,1i5w,3,1i66,,1i69,,1ian,,1iao,2,1iar,7,1ibk,1,1ibm,1,1id7,1,1ida,,1idb,,1idc,,1idd,3,1idj,1,1idn,1,1idp,,1idz,,1iea,1,1iee,6,1ieo,4,1igo,,1igp,1,1igr,5,1igy,,1ih1,,1ih3,2,1ih6,,1ih8,1,1iha,2,1ihd,,1ihe,,1iht,1,1ik5,2,1ik8,7,1ikg,1,1iki,2,1ikl,,1ikm,,1ila,,1ink,,1inl,1,1inn,5,1int,,1inu,,1inv,1,1inx,,1iny,,1inz,1,1io1,,1io2,1,1iun,,1iuo,1,1iuq,3,1iuw,3,1iv0,1,1iv2,,1iv3,1,1ivw,1,1iy8,2,1iyb,7,1iyj,1,1iyl,,1iym,,1iyn,1,1j1n,,1j1o,,1j1p,,1j1q,1,1j1s,7,1j4t,,1j4u,,1j4v,,1j4y,3,1j52,,1j53,4,1jcc,2,1jcf,8,1jco,,1jcp,1,1jjk,,1jjl,4,1jjr,1,1jjv,3,1jjz,,1jk0,,1jk1,,1jk2,,1jk3,,1jo1,2,1jo4,3,1joa,1,1joc,3,1jog,,1jok,,1jpd,9,1jqr,5,1jqx,,1jqy,,1jqz,3,1jrb,,1jrl,5,1jrr,1,1jrt,2,1jt0,5,1jt6,c,1jtj,,1jtk,1,1k4v,,1k4w,6,1k54,5,1k5a,,1k5b,,1k7m,l,1k89,,1k8a,6,1k8h,,1k8i,1,1k8k,,1k8l,1,1kc1,5,1kca,,1kcc,1,1kcf,6,1kcm,,1kcn,,1kei,4,1keo,1,1ker,1,1ket,,1keu,,1kev,,1koj,1,1kol,1,1kow,1,1koy,,1koz,,1kqc,1,1kqe,4,1kqm,1,1kqo,2,1kre,,1ovk,f,1ow0,,1ow7,e,1xr2,b,1xre,2,1xrh,2,1zow,4,1zqo,6,206b,,206f,3,20jz,,20k1,1i,20lr,3,20o4,,20og,1,2ftp,1,2fts,3,2jgg,19,2jhs,m,2jxh,4,2jxp,5,2jxv,7,2jy3,7,2jyd,6,2jze,3,2k3m,2,2lmo,1i,2lob,1d,2lpx,,2lqc,,2lqz,4,2lr5,e,2mtc,6,2mtk,g,2mu3,6,2mub,1,2mue,4,2mxb,,2n1s,6,2nce,,2ne4,3,2nsc,3,2nzi,1,2ok0,6,2on8,6,2pz4,73,2q6l,2,2q7j,,2q98,5,2q9q,1,2qa6,,2qa9,9,2qb1,1k,2qcm,p,2qdd,e,2qe2,,2qen,,2qeq,8,2qf0,3,2qfd,c1,2qrf,4,2qrk,8t,2r0m,7d,2r9c,3j,2rg4,b,2rit,16,2rkc,3,2rm0,7,2rmi,5,2rns,7,2rou,29,2rrg,1a,2rss,9,2rt3,c8,2scg,sd,jny8,v,jnz4,2n,jo1s,3j,jo5c,6n,joc0,2rz",
  "262122424333333393233393339333333333393393b3b3b3b3b333b33b3bb33333b3b3333333b3b33bb3333b33b3bb33333b3bbb333b333b33333b3b3b3b3333b3b33b3bb39333b33b33b3b3b333b333333b3b333333b33b3b3333b3335dc333333b3b3b33323333b3bb3b33b3b3b3333b3333b3b333bb3b33b3b3b3b3b333b333b3323e2244234444444444444444444444444444444444444444443333443443333333b3b3bb33333b353b3b3b3b333b3b333b333333b3bb3b3b3bb3787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878dc333232333333333333333b3b3333bb3b393933b3b33bb3b393b3b3b3333b33b33b3bbb33b333b3333bb3933b3b3b333b3b3b3b3b33b3b3b33b3b3b33b3b33b33b3b3b33bb39b9b3b33b3b33b9333b393b3b33b33b3b3b3333393b3b3b33b39bb3b332333b333dd3b33332333323333333333333333333333344444444a44444434444444444444423232"
);
const consonant_ranges = decodeUnicodeData(
  /** @type {UnicodeDataEncoding} */
  "1sl,10,1ug,7,1vc,7,1w5,j,1wq,6,1wy,,1x2,3,1y4,1,1y7,,1yo,1,239,j,23u,6,242,1,245,4,261,,26t,j,27e,6,27m,1,27p,4,28s,1,28v,,29d,,2dx,j,2ei,f,2fs,2,2l1,11"
);
function* graphemeSegments(input) {
  if (input === "") {
    return;
  }
  let cursor = 0;
  let len = input.length;
  let catBefore = null;
  let catAfter = null;
  let catBegin = null;
  let cache = [
    0,
    0,
    2
    /* GC_Control */
  ];
  let risCount = 0;
  let emoji = false;
  let consonant = false;
  let linker = false;
  let incb = false;
  let cp = (
    /** @type number */
    input.codePointAt(cursor)
  );
  let index2 = 0;
  let segment = "";
  while (true) {
    segment += input[cursor++];
    if (!isBMP(cp)) {
      segment += input[cursor++];
    }
    catBefore = catAfter;
    if (catBefore === null) {
      catBefore = cat(cp, cache);
      catBegin = catBefore;
    }
    if (!consonant && catBefore === 0) {
      consonant = isIndicConjunctCosonant(cp);
    } else if (catBefore === 3) {
      linker = isIndicConjunctLinker(cp);
    }
    if (cursor < len) {
      cp = /** @type {number} */
      input.codePointAt(cursor);
      catAfter = cat(cp, cache);
    } else {
      yield {
        segment,
        index: index2,
        input,
        _catBegin: (
          /** @type {typeof catBefore} */
          catBegin
        ),
        _catEnd: catBefore
      };
      return;
    }
    if (catBefore === 10) {
      risCount += 1;
    } else {
      risCount = 0;
      if (catAfter === 14 && (catBefore === 3 || catBefore === 4)) {
        emoji = true;
      } else if (catAfter === 0) {
        incb = consonant && linker && (consonant = isIndicConjunctCosonant(cp));
        linker = linker && !consonant;
      }
    }
    if (isBoundary(catBefore, catAfter, risCount, emoji, incb)) {
      yield {
        segment,
        index: index2,
        input,
        _catBegin: (
          /** @type {typeof catBefore} */
          catBegin
        ),
        _catEnd: catBefore
      };
      index2 = cursor;
      segment = "";
      emoji = false;
      incb = false;
      catBegin = catAfter;
    }
  }
}
function* splitGraphemes(text) {
  for (let s of graphemeSegments(text)) yield s.segment;
}
function cat(cp, cache) {
  if (cp < 127) {
    if (cp >= 32) {
      return 0;
    } else if (cp === 10) {
      return 6;
    } else if (cp === 13) {
      return 1;
    } else {
      return 2;
    }
  } else {
    if (cp < cache[0] || cp > cache[1]) {
      let index2 = findUnicodeRangeIndex(cp, grapheme_ranges);
      if (index2 < 0) {
        return 0;
      }
      let range = grapheme_ranges[index2];
      cache[0] = range[0];
      cache[1] = range[1];
      cache[2] = range[2];
    }
    return cache[2];
  }
}
function isIndicConjunctCosonant(cp) {
  return findUnicodeRangeIndex(cp, consonant_ranges) >= 0;
}
function isIndicConjunctLinker(cp) {
  return cp === 2381 || cp === 2509 || cp === 2765 || cp === 2893 || cp === 3149 || cp === 3405;
}
function isBoundary(catBefore, catAfter, risCount, emoji, incb) {
  if (catBefore === 1 && catAfter === 6) {
    return false;
  }
  if (catBefore === 1 || catBefore === 2 || catBefore === 6) {
    return true;
  }
  if (catAfter === 1 || catAfter === 2 || catAfter === 6) {
    return true;
  }
  if (catBefore === 5 && (catAfter === 5 || catAfter === 7 || catAfter === 8 || catAfter === 13)) {
    return false;
  }
  if ((catBefore === 7 || catBefore === 13) && (catAfter === 12 || catAfter === 13)) {
    return false;
  }
  if (catAfter === 12 && (catBefore === 8 || catBefore === 12)) {
    return false;
  }
  if (catAfter === 3 || catAfter === 14) {
    return false;
  }
  if (catAfter === 11) {
    return false;
  }
  if (catBefore === 9) {
    return false;
  }
  if (catAfter === 0 && incb) {
    return false;
  }
  if (catBefore === 14 && catAfter === 4) {
    return !emoji;
  }
  if (catBefore === 10 && catAfter === 10) {
    return risCount % 2 === 0;
  }
  return true;
}
const TRANSACTION_CONFIG = {
  MAX_RECOMMENDED_TX_SIZE: 100 * 1024
};
const CO_VALUE_LOADING_CONFIG = {
  MAX_RETRIES: 1,
  TIMEOUT: 6e4,
  RETRY_DELAY: 3e3,
  MAX_IN_FLIGHT_LOADS_PER_PEER: 1e3
};
const SYNC_SCHEDULER_CONFIG = {
  INCOMING_MESSAGES_TIME_BUDGET: 50
};
const GARBAGE_COLLECTOR_CONFIG = {
  MAX_AGE: 1e3 * 60 * 10,
  // 10 minutes
  INTERVAL: 1e3 * 60 * 5
  // 5 minutes
};
const WEBSOCKET_CONFIG$1 = {
  MAX_OUTGOING_MESSAGES_CHUNK_BYTES: 25e3
};
function stringifyOpID(opID) {
  return `${opID.sessionID}:${opID.txIndex}:${opID.changeIdx}`;
}
class RawCoPlainText extends RawCoList {
  constructor(core2, atTimeFilter) {
    super(core2, atTimeFilter);
    this.type = "coplaintext";
    this._cachedMapping = /* @__PURE__ */ new WeakMap();
  }
  get mapping() {
    const entries = this.entries();
    let mapping = this._cachedMapping.get(entries);
    if (mapping) {
      return mapping;
    }
    mapping = {
      opIDbeforeIdx: [],
      opIDafterIdx: [],
      idxAfterOpID: {},
      idxBeforeOpID: {}
    };
    let idxBefore = 0;
    for (const entry of entries) {
      const idxAfter = idxBefore + 1;
      mapping.opIDafterIdx[idxBefore] = entry.opID;
      mapping.opIDbeforeIdx[idxAfter] = entry.opID;
      mapping.idxAfterOpID[stringifyOpID(entry.opID)] = idxAfter;
      mapping.idxBeforeOpID[stringifyOpID(entry.opID)] = idxBefore;
      idxBefore = idxAfter;
    }
    this._cachedMapping.set(entries, mapping);
    return mapping;
  }
  toString() {
    return this.entries().map((entry) => entry.value).join("");
  }
  atTime(time) {
    return new RawCoPlainText(this.core, time);
  }
  /**
   * Inserts `text` before the character at index `idx`.
   * If idx is 0, inserts at the start of the text.
   *
   * @param idx - The index of the character to insert before
   * @param text - The text to insert
   * @param privacy - Whether the operation should be private or trusting
   * @category 2. Editing
   */
  insertBefore(idx, text, privacy = "private") {
    const graphemes = Array.from(splitGraphemes(text));
    if (idx === 0) {
      const firstChar = graphemes[0];
      if (firstChar) {
        this.prepend(firstChar, 0, privacy);
      }
      if (graphemes.length > 1) {
        this.appendChars(graphemes.slice(1), 0, privacy);
      }
    } else {
      this.appendChars(graphemes, idx - 1, privacy);
    }
  }
  appendChars(text, position, privacy = "private") {
    const chunks = splitIntoChunks(text);
    for (const chunk of chunks) {
      this.appendItems(chunk, position, privacy);
      position += chunk.length;
    }
  }
  /**
   * Inserts `text` after the character at index `idx`.
   *
   * @param idx - The index of the character to insert after
   * @param text - The text to insert
   * @param privacy - Whether the operation should be private or trusting
   * @category 2. Editing
   */
  insertAfter(idx, text, privacy = "private") {
    const graphemes = Array.from(splitGraphemes(text));
    if (idx >= this.entries().length) {
      this.appendChars(graphemes, idx - 1, privacy);
    } else {
      this.appendChars(graphemes, idx, privacy);
    }
  }
  deleteRange({ from, to }, privacy = "private") {
    const ops = [];
    for (let idx = from; idx < to; ) {
      const insertion = this.mapping.opIDafterIdx[idx];
      if (!insertion) {
        throw new Error("Invalid idx to delete " + idx);
      }
      ops.push({
        op: "del",
        insertion
      });
      let nextIdx = idx + 1;
      while (!this.mapping.opIDbeforeIdx[nextIdx] && nextIdx < to) {
        nextIdx++;
      }
      idx = nextIdx;
    }
    this.core.makeTransaction(ops, privacy);
    this.processNewTransactions();
  }
  /** @internal Helper method to split text into graphemes */
  toGraphemes(text) {
    return [...splitGraphemes(text)];
  }
  /** @internal Helper method to join graphemes into a string */
  fromGraphemes(graphemes) {
    return graphemes.join("");
  }
}
function splitIntoChunks(text) {
  const maxChunkSize = Math.ceil(TRANSACTION_CONFIG.MAX_RECOMMENDED_TX_SIZE / 200);
  const chunks = [];
  for (let i = 0; i < text.length; i += maxChunkSize) {
    chunks.push(text.slice(i, i + maxChunkSize));
  }
  return chunks;
}
function coreToCoValue(core2, options) {
  if (core2.verified.header.type === "comap") {
    if (core2.verified.header.ruleset.type === "group") {
      if (core2.verified.header.meta?.type === "account" && !options?.ignorePrivateTransactions) {
        return new RawAccount(core2);
      } else {
        return new RawGroup(core2, options);
      }
    } else {
      return new RawCoMap(core2);
    }
  } else if (core2.verified.header.type === "coplaintext") {
    return new RawCoPlainText(core2);
  } else if (core2.verified.header.type === "colist") {
    return new RawCoList(core2);
  } else if (core2.verified.header.type === "costream") {
    if (core2.verified.header.meta && core2.verified.header.meta.type === "binary") {
      return new RawBinaryCoStream(core2);
    } else {
      return new RawCoStream(core2);
    }
  } else {
    return new RawUnknownCoValue(core2);
  }
}
function getDependenciesFromHeader(header, deps = /* @__PURE__ */ new Set()) {
  if (header.ruleset.type === "ownedByGroup") {
    deps.add(header.ruleset.group);
  }
  if (header.meta?.source) {
    deps.add(header.meta.source);
  }
  return deps;
}
function getDependenciesFromSessions(sessions, deps) {
  for (const session of sessions) {
    const accountId = accountOrAgentIDfromSessionID(session);
    if (isAccountID(accountId)) {
      deps.add(accountId);
    }
  }
}
function getDependenciesFromGroupRawTransactions(transactions, deps = /* @__PURE__ */ new Set()) {
  for (const tx of transactions) {
    if (tx.privacy !== "trusting")
      continue;
    const changes = safeParseChanges(tx.changes);
    for (const change of changes) {
      if (change && typeof change === "object" && "op" in change && change.op === "set" && "key" in change && change.key) {
        const key = getGroupDependentKey(change.key);
        if (key) {
          deps.add(key);
        }
      }
    }
  }
  return deps;
}
function getDependedOnCoValuesFromRawData(id2, header, sessions, transactions) {
  const deps = /* @__PURE__ */ new Set();
  getDependenciesFromHeader(header, deps);
  getDependenciesFromSessions(sessions, deps);
  if (header.ruleset.type === "group") {
    for (const txs of transactions) {
      getDependenciesFromGroupRawTransactions(txs, deps);
    }
  }
  deps.delete(id2);
  return deps;
}
function getDependenciesFromContentMessage(coValue, contentMessage) {
  const deps = /* @__PURE__ */ new Set();
  if (contentMessage.header) {
    getDependenciesFromHeader(contentMessage.header, deps);
  }
  const sessions = Object.keys(contentMessage.new);
  getDependenciesFromSessions(sessions, deps);
  const header = coValue.verified?.header ?? contentMessage.header;
  if (header?.ruleset.type === "group") {
    for (const { newTransactions } of Object.values(contentMessage.new)) {
      getDependenciesFromGroupRawTransactions(newTransactions, deps);
    }
  }
  deps.delete(coValue.id);
  return deps;
}
function safeParseChanges(value) {
  try {
    return parseJSON(value);
  } catch (e) {
    return [];
  }
}
function emptyKnownState(id2) {
  return {
    id: id2,
    header: false,
    sessions: {}
  };
}
function knownStateFrom(input) {
  return {
    id: input.id,
    header: input.header,
    sessions: input.sessions
  };
}
function combineKnownStates(target, source) {
  combineKnownStateSessions(target.sessions, source.sessions);
  if (source.header && !target.header) {
    target.header = true;
  }
  return target;
}
function combineKnownStateSessions(target, source) {
  for (const [sessionID, count] of Object.entries(source)) {
    const currentCount = target[sessionID] || 0;
    if (count > currentCount) {
      target[sessionID] = count;
    }
  }
  return target;
}
function setSessionCounter(knownState, sessionId, value) {
  knownState[sessionId] = value;
}
function updateSessionCounter(knownState, sessionId, value) {
  knownState[sessionId] = Math.max(knownState[sessionId] || 0, value);
}
function cloneKnownState(knownState) {
  return {
    id: knownState.id,
    header: knownState.header,
    sessions: { ...knownState.sessions }
  };
}
function areCurrentSessionsInSyncWith(current, target) {
  for (const [sessionId, currentCount] of Object.entries(current)) {
    const targetCount = target[sessionId] ?? 0;
    if (currentCount !== targetCount) {
      return false;
    }
  }
  return true;
}
function isKnownStateSubsetOf(current, target) {
  for (const [sessionId, currentCount] of Object.entries(current)) {
    const targetCount = target[sessionId] ?? 0;
    if (currentCount > targetCount) {
      return false;
    }
  }
  return true;
}
function peerHasAllContent(storageKnownState, peerKnownState) {
  if (!peerKnownState) {
    return false;
  }
  if (!peerKnownState.header && storageKnownState.header) {
    return false;
  }
  return isKnownStateSubsetOf(storageKnownState.sessions, peerKnownState.sessions);
}
function getKnownStateToSend(current, target) {
  const toSend = {};
  for (const [sessionId, currentCount] of Object.entries(current)) {
    const targetCount = target[sessionId] ?? 0;
    if (currentCount > targetCount) {
      toSend[sessionId] = currentCount;
    }
  }
  return toSend;
}
const CO_VALUE_PRIORITY$1 = {
  HIGH: 0,
  MEDIUM: 3,
  LOW: 6
};
function getPriorityFromHeader(header) {
  if (typeof header === "boolean" || !header) {
    return CO_VALUE_PRIORITY$1.MEDIUM;
  }
  if (header.meta?.type === "account") {
    return CO_VALUE_PRIORITY$1.HIGH;
  }
  if (header.ruleset.type === "group") {
    return CO_VALUE_PRIORITY$1.HIGH;
  }
  if (header.type === "costream" && header.meta?.type === "binary") {
    return CO_VALUE_PRIORITY$1.LOW;
  }
  return CO_VALUE_PRIORITY$1.MEDIUM;
}
function createContentMessage(id2, header, includeHeader = true) {
  return {
    action: "content",
    id: id2,
    header: includeHeader ? header : void 0,
    priority: getPriorityFromHeader(header),
    new: {}
  };
}
function addTransactionToContentMessage(content, transaction, sessionID, signature, txIdx) {
  const sessionContent = content.new[sessionID];
  if (sessionContent) {
    sessionContent.newTransactions.push(transaction);
    sessionContent.lastSignature = signature;
  } else {
    content.new[sessionID] = {
      after: txIdx,
      newTransactions: [transaction],
      lastSignature: signature
    };
  }
}
function getTransactionSize(transaction) {
  return transaction.privacy === "private" ? transaction.encryptedChanges.length : transaction.changes.length;
}
function exceedsRecommendedSize(baseSize, transactionSize) {
  if (transactionSize === void 0) {
    return baseSize > TRANSACTION_CONFIG.MAX_RECOMMENDED_TX_SIZE;
  }
  return baseSize + transactionSize > TRANSACTION_CONFIG.MAX_RECOMMENDED_TX_SIZE;
}
function knownStateFromContent(content) {
  const knownState = emptyKnownState(content.id);
  knownState.header = Boolean(content.header);
  for (const [sessionID, session] of Object.entries(content.new)) {
    knownState.sessions[sessionID] = session.after + session.newTransactions.length;
  }
  return knownState;
}
function getContentMessageSize$2(msg) {
  return Object.values(msg.new).reduce((acc, sessionNewContent) => {
    return acc + sessionNewContent.newTransactions.reduce((acc2, tx) => {
      return acc2 + getTransactionSize(tx);
    }, 0);
  }, 0);
}
function getContenDebugInfo(msg) {
  return Object.entries(msg.new).map(([sessionID, sessionNewContent]) => `Session: ${sessionID} After: ${sessionNewContent.after} New: ${sessionNewContent.newTransactions.length}`);
}
function getNewTransactionsFromContentMessage(content, knownState, sessionID) {
  const ourKnownTxIdx = knownState.sessions[sessionID] ?? 0;
  const theirFirstNewTxIdx = content.after;
  if (ourKnownTxIdx < theirFirstNewTxIdx) {
    return void 0;
  }
  const alreadyKnownOffset = ourKnownTxIdx - theirFirstNewTxIdx;
  const newTransactions = content.newTransactions.slice(alreadyKnownOffset);
  return newTransactions;
}
function getSessionEntriesFromContentMessage(content) {
  return Object.entries(content.new);
}
class SessionMap {
  constructor(id2, crypto2, streamingKnownState) {
    this.id = id2;
    this.crypto = crypto2;
    this.isDeleted = false;
    this.sessions = /* @__PURE__ */ new Map();
    this.knownState = { id: this.id, header: true, sessions: {} };
    if (streamingKnownState) {
      this.streamingKnownState = { ...streamingKnownState };
      this.knownStateWithStreaming = {
        id: this.id,
        header: true,
        sessions: { ...streamingKnownState }
      };
    }
  }
  markAsDeleted() {
    this.isDeleted = true;
    this.knownState = { id: this.id, header: true, sessions: {} };
    this.knownStateWithStreaming = void 0;
    this.streamingKnownState = void 0;
    this.invalidateKnownStateCache();
    for (const [sessionID, sessionLog] of this.sessions.entries()) {
      if (!isDeleteSessionID(sessionID)) {
        continue;
      }
      this.knownState.sessions[sessionID] = sessionLog.transactions.length;
    }
  }
  setStreamingKnownState(streamingKnownState) {
    if (this.isDeleted) {
      return;
    }
    if (isKnownStateSubsetOf(streamingKnownState, this.knownState.sessions)) {
      return;
    }
    const actualStreamingKnownState = getKnownStateToSend(streamingKnownState, this.knownState.sessions);
    if (this.streamingKnownState) {
      combineKnownStateSessions(this.streamingKnownState, actualStreamingKnownState);
    } else {
      this.streamingKnownState = actualStreamingKnownState;
    }
    if (!this.knownStateWithStreaming) {
      this.knownStateWithStreaming = cloneKnownState(this.knownState);
    }
    combineKnownStateSessions(this.knownStateWithStreaming.sessions, actualStreamingKnownState);
  }
  invalidateKnownStateCache() {
    this.immutableKnownState = void 0;
    this.immutableKnownStateWithStreaming = void 0;
  }
  getImmutableKnownState() {
    if (!this.immutableKnownState) {
      this.immutableKnownState = cloneKnownState(this.knownState);
    }
    return this.immutableKnownState;
  }
  getImmutableKnownStateWithStreaming() {
    if (!this.knownStateWithStreaming) {
      return this.getImmutableKnownState();
    }
    if (!this.immutableKnownStateWithStreaming) {
      this.immutableKnownStateWithStreaming = cloneKnownState(this.knownStateWithStreaming);
    }
    return this.immutableKnownStateWithStreaming;
  }
  get(sessionID) {
    return this.sessions.get(sessionID);
  }
  getOrCreateSessionLog(sessionID, signerID) {
    let sessionLog = this.sessions.get(sessionID);
    if (!sessionLog) {
      sessionLog = {
        signerID,
        impl: this.crypto.createSessionLog(this.id, sessionID, signerID),
        transactions: [],
        lastSignature: void 0,
        signatureAfter: {},
        txSizeSinceLastInbetweenSignature: 0,
        sessionID
      };
      this.sessions.set(sessionID, sessionLog);
    }
    return sessionLog;
  }
  addTransaction(sessionID, signerID, newTransactions, newSignature, skipVerify = false) {
    if (this.isDeleted && !isDeleteSessionID(sessionID)) {
      throw new Error("Cannot add transactions to a deleted coValue");
    }
    const sessionLog = this.getOrCreateSessionLog(sessionID, signerID);
    sessionLog.impl.tryAdd(newTransactions, newSignature, skipVerify);
    this.addTransactionsToJsLog(sessionLog, newTransactions, newSignature);
  }
  makeNewPrivateTransaction(sessionID, signerAgent, changes, keyID, keySecret, meta, madeAt) {
    if (this.isDeleted) {
      throw new Error("Cannot make new private transaction on a deleted coValue");
    }
    const sessionLog = this.getOrCreateSessionLog(sessionID, signerAgent.currentSignerID());
    const result = sessionLog.impl.addNewPrivateTransaction(signerAgent, changes, keyID, keySecret, madeAt, meta);
    this.addTransactionsToJsLog(sessionLog, [result.transaction], result.signature);
    return result;
  }
  makeNewTrustingTransaction(sessionID, signerAgent, changes, meta, madeAt) {
    if (this.isDeleted) {
      throw new Error("Cannot make new trusting transaction on a deleted coValue");
    }
    const sessionLog = this.getOrCreateSessionLog(sessionID, signerAgent.currentSignerID());
    const result = sessionLog.impl.addNewTrustingTransaction(signerAgent, changes, madeAt, meta);
    this.addTransactionsToJsLog(sessionLog, [result.transaction], result.signature);
    return result;
  }
  addTransactionsToJsLog(sessionLog, newTransactions, signature) {
    for (const tx of newTransactions) {
      sessionLog.transactions.push(tx);
    }
    sessionLog.lastSignature = signature;
    sessionLog.txSizeSinceLastInbetweenSignature += newTransactions.reduce((sum, tx) => sum + (tx.privacy === "private" ? tx.encryptedChanges.length : tx.changes.length), 0);
    const transactionsCount = sessionLog.transactions.length;
    if (exceedsRecommendedSize(sessionLog.txSizeSinceLastInbetweenSignature)) {
      sessionLog.signatureAfter[transactionsCount - 1] = signature;
      sessionLog.txSizeSinceLastInbetweenSignature = 0;
    }
    updateSessionCounter(this.knownState.sessions, sessionLog.sessionID, transactionsCount);
    if (this.streamingKnownState && isKnownStateSubsetOf(this.streamingKnownState, this.knownState.sessions)) {
      this.streamingKnownState = void 0;
      this.knownStateWithStreaming = void 0;
    }
    if (this.knownStateWithStreaming) {
      updateSessionCounter(this.knownStateWithStreaming.sessions, sessionLog.sessionID, transactionsCount);
    }
    this.invalidateKnownStateCache();
  }
  decryptTransaction(sessionID, txIndex, keySecret) {
    const sessionLog = this.sessions.get(sessionID);
    if (!sessionLog) {
      return void 0;
    }
    const decrypted = sessionLog.impl.decryptNextTransactionChangesJson(txIndex, keySecret);
    if (!decrypted) {
      return void 0;
    }
    return parseJSON(decrypted);
  }
  decryptTransactionMeta(sessionID, txIndex, keySecret) {
    const sessionLog = this.sessions.get(sessionID);
    if (!sessionLog?.transactions[txIndex]?.meta) {
      return void 0;
    }
    const decrypted = sessionLog.impl.decryptNextTransactionMetaJson(txIndex, keySecret);
    if (!decrypted) {
      return void 0;
    }
    return parseJSON(decrypted);
  }
  get size() {
    return this.sessions.size;
  }
  entries() {
    return this.sessions.entries();
  }
  values() {
    return this.sessions.values();
  }
  keys() {
    return this.sessions.keys();
  }
  clone() {
    const clone = new SessionMap(this.id, this.crypto);
    for (const [sessionID, sessionLog] of this.sessions) {
      clone.sessions.set(sessionID, {
        impl: sessionLog.impl.clone(),
        transactions: sessionLog.transactions.slice(),
        lastSignature: sessionLog.lastSignature,
        signatureAfter: { ...sessionLog.signatureAfter },
        txSizeSinceLastInbetweenSignature: sessionLog.txSizeSinceLastInbetweenSignature,
        signerID: sessionLog.signerID,
        sessionID
      });
    }
    clone.streamingKnownState = this.streamingKnownState ? { ...this.streamingKnownState } : void 0;
    clone.knownState = cloneKnownState(this.knownState);
    clone.knownStateWithStreaming = this.knownStateWithStreaming ? cloneKnownState(this.knownStateWithStreaming) : void 0;
    return clone;
  }
}
class VerifiedState {
  constructor(id2, crypto2, header, sessions) {
    this.isDeleted = false;
    this.id = id2;
    this.crypto = crypto2;
    this.header = header;
    this.sessions = sessions ?? new SessionMap(id2, crypto2);
    this.branchSourceId = header.meta?.source;
    this.branchName = header.meta?.branch;
  }
  clone() {
    return new VerifiedState(this.id, this.crypto, this.header, this.sessions.clone());
  }
  markAsDeleted() {
    this.isDeleted = true;
    this.sessions.markAsDeleted();
  }
  tryAddTransactions(sessionID, signerID, newTransactions, newSignature, skipVerify = false) {
    this.sessions.addTransaction(sessionID, signerID, newTransactions, newSignature, skipVerify);
  }
  makeNewTrustingTransaction(sessionID, signerAgent, changes, meta, madeAt) {
    const result = this.sessions.makeNewTrustingTransaction(sessionID, signerAgent, changes, meta, madeAt);
    return result;
  }
  makeNewPrivateTransaction(sessionID, signerAgent, changes, keyID, keySecret, meta, madeAt) {
    const result = this.sessions.makeNewPrivateTransaction(sessionID, signerAgent, changes, keyID, keySecret, meta, madeAt);
    return result;
  }
  getLastSignatureCheckpoint(sessionID) {
    const sessionLog = this.sessions.get(sessionID);
    if (!sessionLog?.signatureAfter)
      return -1;
    return Object.keys(sessionLog.signatureAfter).reduce((max, idx) => Math.max(max, parseInt(idx)), -1);
  }
  setStreamingKnownState(streamingKnownState) {
    this.sessions.setStreamingKnownState(streamingKnownState);
  }
  newContentSince(knownState) {
    let currentPiece = createContentMessage(this.id, this.header, false);
    const pieces = [currentPiece];
    let pieceSize = 0;
    const startNewPiece = () => {
      currentPiece = createContentMessage(this.id, this.header, false);
      pieces.push(currentPiece);
      pieceSize = 0;
    };
    const moveSessionContentToNewPiece = (sessionID) => {
      const sessionContent = currentPiece.new[sessionID];
      if (!sessionContent) {
        throw new Error("Session content not found", {
          cause: {
            sessionID,
            currentPiece
          }
        });
      }
      delete currentPiece.new[sessionID];
      const newPiece = createContentMessage(this.id, this.header, false);
      newPiece.new[sessionID] = sessionContent;
      pieces.splice(pieces.length - 1, 0, newPiece);
    };
    const sessionSent = knownState?.sessions;
    for (const [sessionID, log] of this.sessions.sessions) {
      if (this.isDeleted && !isDeleteSessionID(sessionID)) {
        continue;
      }
      const startFrom = sessionSent?.[sessionID] ?? 0;
      let currentSessionSize = 0;
      for (let txIdx = startFrom; txIdx < log.transactions.length; txIdx++) {
        const isLastItem = txIdx === log.transactions.length - 1;
        const tx = log.transactions[txIdx];
        currentSessionSize += getTransactionSize(tx);
        const signatureAfter = log.signatureAfter[txIdx];
        if (signatureAfter) {
          addTransactionToContentMessage(currentPiece, tx, sessionID, signatureAfter, txIdx);
          moveSessionContentToNewPiece(sessionID);
          currentSessionSize = 0;
        } else if (isLastItem) {
          if (!log.lastSignature) {
            throw new Error("All the SessionLogs sent must have a lastSignature", {
              cause: log
            });
          }
          addTransactionToContentMessage(currentPiece, tx, sessionID, log.lastSignature, txIdx);
          if (exceedsRecommendedSize(currentSessionSize)) {
            assertLastSignature(sessionID, currentPiece);
            moveSessionContentToNewPiece(sessionID);
          } else if (exceedsRecommendedSize(pieceSize, currentSessionSize)) {
            assertLastSignature(sessionID, currentPiece);
            startNewPiece();
          } else {
            pieceSize += currentSessionSize;
          }
        } else {
          const signature = void 0;
          addTransactionToContentMessage(currentPiece, tx, sessionID, signature, txIdx);
        }
      }
      assertLastSignature(sessionID, currentPiece);
    }
    const firstPiece = pieces[0];
    if (!firstPiece) {
      throw new Error("First piece not found", {
        cause: pieces
      });
    }
    const includeHeader = !knownState?.header;
    if (includeHeader) {
      firstPiece.header = this.header;
    }
    const piecesWithContent = pieces.filter((piece) => piece.header || Object.keys(piece.new).length > 0);
    if (piecesWithContent.length > 1 || this.isStreaming()) {
      if (knownState) {
        firstPiece.expectContentUntil = getKnownStateToSend(this.knownStateWithStreaming().sessions, knownState.sessions);
      } else {
        firstPiece.expectContentUntil = {
          ...this.knownStateWithStreaming().sessions
        };
      }
    }
    if (piecesWithContent.length === 0) {
      return void 0;
    }
    return piecesWithContent;
  }
  knownState() {
    return this.sessions.knownState;
  }
  knownStateWithStreaming() {
    return this.sessions.knownStateWithStreaming ?? this.knownState();
  }
  immutableKnownState() {
    return this.sessions.getImmutableKnownState();
  }
  immutableKnownStateWithStreaming() {
    return this.sessions.getImmutableKnownStateWithStreaming();
  }
  isStreaming() {
    return Boolean(this.sessions.knownStateWithStreaming);
  }
  decryptTransaction(sessionID, txIndex, keySecret) {
    return this.sessions.decryptTransaction(sessionID, txIndex, keySecret);
  }
  decryptTransactionMeta(sessionID, txIndex, keySecret) {
    return this.sessions.decryptTransactionMeta(sessionID, txIndex, keySecret);
  }
}
function assertLastSignature(sessionID, content) {
  if (content.new[sessionID] && !content.new[sessionID].lastSignature) {
    throw new Error("The SessionContent sent must have a lastSignature", {
      cause: content.new[sessionID]
    });
  }
}
function getBranchHeader({ type: type2, branchName, ownerId, sourceId }) {
  return {
    type: type2,
    // Branch name and source id are stored in the meta field
    // and used to generate the unique id for the branch
    meta: {
      branch: branchName,
      source: sourceId
    },
    ruleset: {
      type: "ownedByGroup",
      // The owner is part of the id generation, making it possible to have multiple branches with the same name
      // but different owners
      group: ownerId
    },
    // The meta is enough to have reproducible unique id for the branch
    uniqueness: ""
  };
}
function canBeBranched(coValue) {
  return coValue.verified?.header.ruleset.type === "ownedByGroup";
}
function getBranchId(coValue, name, ownerId) {
  if (!coValue.verified) {
    throw new Error("CoValueCore: getBranchId called on coValue without verified state");
  }
  const currentOwnerId = ownerId ?? getBranchOwnerId(coValue);
  if (!currentOwnerId) {
    return coValue.id;
  }
  const header = getBranchHeader({
    type: coValue.verified.header.type,
    branchName: name,
    ownerId: currentOwnerId,
    sourceId: coValue.id
  });
  return idforHeader$1(header, coValue.node.crypto);
}
function getBranchOwnerId(coValue) {
  if (!coValue.verified) {
    throw new Error("CoValueCore: getBranchOwnerId called on coValue without verified state");
  }
  const header = coValue.verified.header;
  if (header.ruleset.type !== "ownedByGroup") {
    return void 0;
  }
  return header.ruleset.group;
}
function createBranch(coValue, name, ownerId) {
  if (!coValue.verified) {
    throw new Error("CoValueCore: createBranch called on coValue without verified state");
  }
  const branchOwnerId = ownerId ?? getBranchOwnerId(coValue);
  if (!branchOwnerId) {
    return coValue;
  }
  const myRole = coValue.safeGetGroup()?.myRole();
  if (!myRole || myRole === "reader" && !ownerId) {
    logger.warn("Trying to create a branch without enough access rights, returning the source coValue");
    return coValue;
  }
  const privacy = myRole === "reader" ? "trusting" : "private";
  const header = getBranchHeader({
    type: coValue.verified.header.type,
    branchName: name,
    ownerId: branchOwnerId,
    sourceId: coValue.id
  });
  const branch = coValue.node.createCoValue(header);
  const sessions = { ...coValue.knownState().sessions };
  branch.makeTransaction([], "private", {
    from: sessions
  });
  coValue.makeTransaction([], privacy, {
    branch: name,
    ownerId
  });
  return branch;
}
function getBranchSource(coValue) {
  if (!coValue.verified) {
    return void 0;
  }
  const sourceId = coValue.getCurrentBranchSourceId();
  if (!sourceId) {
    return void 0;
  }
  const source = coValue.node.getCoValue(sourceId);
  if (!source.isAvailable()) {
    return void 0;
  }
  return source;
}
function mergeBranch(branch) {
  if (!branch.verified) {
    throw new Error("CoValueCore: mergeBranch called on coValue without verified state");
  }
  if (!canBeBranched(branch)) {
    return branch;
  }
  const target = getBranchSource(branch);
  if (!target) {
    throw new Error("CoValueCore: unable to find source branch");
  }
  let mergedTransactions = {};
  for (const item of target.getMergeCommits()) {
    if (item.branch === branch.id) {
      combineKnownStateSessions(mergedTransactions, item.merged);
    }
  }
  const branchValidTransactions = branch.getValidTransactions({
    from: mergedTransactions,
    ignorePrivateTransactions: false,
    skipBranchSource: true
  }).filter((tx) => tx.changes.length > 0);
  if (branchValidTransactions.length === 0) {
    return target;
  }
  let lastSessionId = void 0;
  let lastBranchId = void 0;
  let lastOriginalMadeAt = 0;
  const now = Date.now();
  for (const tx of branchValidTransactions) {
    const mergeMeta = {
      mi: tx.txID.txIndex
    };
    if (tx.madeAt !== lastOriginalMadeAt) {
      mergeMeta.t = now - tx.madeAt;
    }
    if (lastSessionId !== tx.txID.sessionID) {
      mergeMeta.s = tx.txID.sessionID;
    }
    if (lastBranchId !== tx.txID.branch) {
      mergeMeta.b = tx.txID.branch;
    }
    target.makeTransaction(tx.changes, tx.tx.privacy, mergeMeta, now);
    lastSessionId = tx.txID.sessionID;
    lastBranchId = tx.txID.branch;
    lastOriginalMadeAt = tx.madeAt;
  }
  const currentSessions = branch.knownState().sessions;
  const prevMergedSessions = mergedTransactions;
  const diff = {};
  for (const [sessionId, count] of Object.entries(currentSessions)) {
    const prevMergedSession = prevMergedSessions[sessionId] ?? 0;
    if (prevMergedSession < count) {
      diff[sessionId] = count;
    }
  }
  target.makeTransaction([], "private", {
    merged: diff,
    branch: branch.id
  });
  return target;
}
function decryptTransactionChangesAndMeta(coValue, transaction) {
  if (!transaction.isValid || transaction.tx.privacy === "trusting") {
    return;
  }
  const needsChagesParsing = !transaction.changes;
  const needsMetaParsing = !transaction.meta && transaction.tx.meta;
  if (!needsChagesParsing && !needsMetaParsing) {
    return;
  }
  const readKey = coValue.getReadKey(transaction.tx.keyUsed);
  if (!readKey) {
    return;
  }
  if (needsChagesParsing) {
    const changes = coValue.verified.decryptTransaction(transaction.txID.sessionID, transaction.txID.txIndex, readKey);
    if (changes) {
      transaction.changes = changes;
    }
  }
  if (needsMetaParsing) {
    const meta = coValue.verified.decryptTransactionMeta(transaction.txID.sessionID, transaction.txID.txIndex, readKey);
    if (meta) {
      transaction.meta = meta;
    }
  }
}
var __classPrivateFieldGet$1 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _CoValueCore_instances, _CoValueCore_lastKnownStateSource, _CoValueCore_lastKnownState, _CoValueCore_isDeleteTransaction, _CoValueCore_markAsDeleted, _CoValueCore_getDeleteMarker, _CoValueCore_canAuthorDeleteCoValueAtTime, _CoValueCore_isNotificationScheduled, _CoValueCore_batchedUpdates, _CoValueCore_isNotifyUpdatePaused;
function validateUniqueness(uniqueness) {
  if (typeof uniqueness === "number" && !Number.isInteger(uniqueness)) {
    return {
      isOk: false,
      message: "Uniqueness cannot be a non-integer number, got " + uniqueness
    };
  }
  if (Array.isArray(uniqueness)) {
    return {
      isOk: false,
      message: "Uniqueness cannot be an array, got " + uniqueness
    };
  }
  if (typeof uniqueness === "object" && uniqueness !== null) {
    for (let [key, value] of Object.entries(uniqueness)) {
      if (typeof value !== "string") {
        return {
          isOk: false,
          message: "Uniqueness object values must be a string, got " + value + " for key " + key
        };
      }
    }
  }
  return { isOk: true };
}
function idforHeader$1(header, crypto2) {
  const hash = crypto2.shortHash(header);
  return `co_z${hash.slice("shortHash_z".length)}`;
}
class VerifiedTransaction {
  constructor(coValueId, sessionID, txIndex, tx, branchId, parsingCache, previous, dispatchTransaction) {
    this.isValidated = false;
    this.isValid = false;
    this.validationErrorMessage = void 0;
    this.dispatchTransaction = dispatchTransaction;
    this.author = accountOrAgentIDfromSessionID(sessionID);
    const txID = branchId ? {
      sessionID,
      txIndex,
      branch: branchId
    } : {
      sessionID,
      txIndex
    };
    this.coValueId = coValueId;
    this.currentTxID = txID;
    this.sourceTxID = void 0;
    this.tx = tx;
    this.currentMadeAt = tx.madeAt;
    this.sourceTxMadeAt = void 0;
    this.previous = previous;
    if (parsingCache) {
      this.changes = parsingCache.changes;
      this.meta = parsingCache.meta;
    } else {
      if (this.tx.privacy === "trusting") {
        this.changes = safeParseJSON(this.tx.changes);
        if (this.tx.meta) {
          this.meta = safeParseJSON(this.tx.meta);
        }
      }
    }
  }
  // The TxID that refers to the current position in the session map
  // If this is a merged transaction, the txID is the TxID of the merged transaction
  get txID() {
    return this.sourceTxID ?? this.currentTxID;
  }
  // The madeAt that refers to the time when the transaction was made
  // If this is a merged transaction, the madeAt is the time when the transaction has been made in the branch
  get madeAt() {
    return this.sourceTxMadeAt ?? this.currentMadeAt;
  }
  isValidTransactionWithChanges() {
    return Boolean(this.isValid && this.changes);
  }
  markValid() {
    this.isValid = true;
    this.validationErrorMessage = void 0;
    if (!this.isValidated) {
      this.isValidated = true;
      this.dispatchTransaction(this);
    }
  }
  markInvalid(errorMessage, attributes) {
    this.isValidated = true;
    this.isValid = false;
    this.validationErrorMessage = errorMessage;
  }
}
class CoValueCore {
  /** Holds the fundamental syncable content of a CoValue,
   * consisting of the header (verified by hash -> RawCoID)
   * and the sessions (verified by signature).
   *
   * It does not do any *validation* or *decryption* and as such doesn't
   * depend on other CoValues or the LocalNode.
   *
   * `CoValueCore.verified` may be null when a CoValue is requested to be
   * loaded but no content has been received from storage or peers yet.
   * In this case, it acts as a centralised entry to keep track of peer loading
   * state and to subscribe to its content when it does become available. */
  get verified() {
    return this._verified;
  }
  constructor(id2, node) {
    _CoValueCore_instances.add(this);
    this.isDeleted = false;
    this.loadingStatuses = /* @__PURE__ */ new Map();
    _CoValueCore_lastKnownStateSource.set(this, void 0);
    _CoValueCore_lastKnownState.set(this, void 0);
    this.listeners = /* @__PURE__ */ new Set();
    this.missingDependencies = /* @__PURE__ */ new Set();
    this.newContentQueue = [];
    _CoValueCore_isNotificationScheduled.set(this, false);
    _CoValueCore_batchedUpdates.set(this, false);
    _CoValueCore_isNotifyUpdatePaused.set(this, false);
    this.mergeCommits = [];
    this.branches = [];
    this.earliestTxMadeAt = Number.MAX_SAFE_INTEGER;
    this.latestTxMadeAt = 0;
    this.verifiedTransactions = [];
    this.toValidateTransactions = [];
    this.toDecryptTransactions = [];
    this.toParseMetaTransactions = [];
    this.toProcessTransactions = [];
    this.verifiedTransactionsKnownSessions = {};
    this.lastVerifiedTransactionBySessionID = {};
    this.parsingCache = /* @__PURE__ */ new Map();
    this.dispatchTransaction = (transaction) => {
      if (!transaction.isValidated) {
        this.toValidateTransactions.push(transaction);
        return;
      }
      if (transaction.changes) {
        this.toProcessTransactions.push(transaction);
      } else {
        this.toDecryptTransactions.push(transaction);
      }
      if (transaction.meta) {
        this.toParseMetaTransactions.push(transaction);
      }
    };
    this.dependencies = /* @__PURE__ */ new Set();
    this.incompleteDependencies = /* @__PURE__ */ new Set();
    this.dependant = /* @__PURE__ */ new Set();
    this.readKeyCache = /* @__PURE__ */ new Map();
    this.crypto = node.crypto;
    this.id = id2;
    this._verified = null;
    this.node = node;
    this.counter = metrics.getMeter("cojson").createUpDownCounter("jazz.covalues.loaded", {
      description: "The number of covalues in the system",
      unit: "covalue",
      valueType: ValueType.INT
    });
    this.updateCounter(null);
  }
  get loadingState() {
    if (this.verified) {
      return "available";
    }
    for (const peer of this.loadingStatuses.values()) {
      if (peer.type === "pending") {
        return "loading";
      }
    }
    if (__classPrivateFieldGet$1(this, _CoValueCore_lastKnownStateSource, "f")) {
      return __classPrivateFieldGet$1(this, _CoValueCore_lastKnownStateSource, "f");
    }
    if (this.loadingStatuses.size === 0) {
      return "unknown";
    }
    for (const peer of this.loadingStatuses.values()) {
      if (peer.type === "unknown") {
        return "unknown";
      }
    }
    return "unavailable";
  }
  hasMissingDependencies() {
    return this.missingDependencies.size > 0;
  }
  isAvailable() {
    return this.hasVerifiedContent();
  }
  isCompletelyDownloaded() {
    if (!this.hasVerifiedContent()) {
      return false;
    }
    if (this.isStreaming()) {
      return false;
    }
    if (this.incompleteDependencies.size > 0) {
      return false;
    }
    return true;
  }
  isStreaming() {
    return this.verified?.isStreaming() ?? false;
  }
  hasVerifiedContent() {
    return !!this.verified;
  }
  /**
   * Returns the CoValue data as NewContentMessage objects, excluding the transactions that are part of the given known state.
   *
   * Used to serialize the CoValue data to send it to peers and storage.
   */
  newContentSince(knownState) {
    return this.verified?.newContentSince(knownState);
  }
  isErroredInPeer(peerId) {
    return this.getLoadingStateForPeer(peerId) === "errored";
  }
  getErroredInPeerError(peerId) {
    const loadingState = this.loadingStatuses.get(peerId);
    if (loadingState?.type === "errored") {
      return loadingState.error;
    }
    return void 0;
  }
  waitFor(opts) {
    const { predicate, onSuccess } = opts;
    this.subscribe((core2, unsubscribe) => {
      if (predicate(core2)) {
        unsubscribe();
        onSuccess(core2);
      }
    }, true);
  }
  waitForAsync(callback) {
    return new Promise((resolve2) => {
      this.waitFor({ predicate: callback, onSuccess: resolve2 });
    });
  }
  waitForAvailableOrUnavailable() {
    return this.waitForAsync((core2) => core2.isAvailable() || core2.loadingState === "unavailable");
  }
  waitForAvailable() {
    return this.waitForAsync((core2) => core2.isAvailable());
  }
  waitForFullStreaming() {
    return this.waitForAsync((core2) => core2.isAvailable() && !core2.isStreaming());
  }
  getLoadingStateForPeer(peerId) {
    return this.loadingStatuses.get(peerId)?.type ?? "unknown";
  }
  updateCounter(previousState) {
    const newState = this.loadingState;
    if (previousState !== newState) {
      if (previousState) {
        this.counter.add(-1, { state: previousState });
      }
      this.counter.add(1, { state: newState });
    }
  }
  /**
   * Removes the CoValue content from memory but keeps a shell with cached knownState.
   * This enables accurate LOAD requests during peer reconciliation.
   *
   * @returns true if the coValue was successfully unmounted, false otherwise
   */
  unmount() {
    return this.node.internalUnmountCoValue(this.id);
  }
  /**
   * Decrements the counter for the current loading state.
   * Used during unmount to properly track state transitions.
   * @internal
   */
  decrementLoadingStateCounter() {
    this.counter.add(-1, { state: this.loadingState });
  }
  markNotFoundInPeer(peerId) {
    const previousState = this.loadingState;
    this.loadingStatuses.set(peerId, { type: "unavailable" });
    this.updateCounter(previousState);
    this.scheduleNotifyUpdate();
  }
  markFoundInPeer(peerId, previousState) {
    this.loadingStatuses.set(peerId, { type: "available" });
    this.updateCounter(previousState);
    this.scheduleNotifyUpdate();
  }
  /**
   * Clean up cached state when CoValue becomes available.
   * Called after the CoValue transitions from garbageCollected/onlyKnownState to available.
   */
  cleanupLastKnownState() {
    __classPrivateFieldSet(this, _CoValueCore_lastKnownStateSource, void 0, "f");
    __classPrivateFieldSet(this, _CoValueCore_lastKnownState, void 0, "f");
  }
  /**
   * Initialize this CoValueCore as a garbageCollected shell.
   * Called when creating a replacement CoValueCore after unmounting.
   */
  setGarbageCollectedState(knownState) {
    if (!this.node.storage) {
      return;
    }
    const previousState = this.loadingState;
    __classPrivateFieldSet(this, _CoValueCore_lastKnownStateSource, "garbageCollected", "f");
    __classPrivateFieldSet(this, _CoValueCore_lastKnownState, knownState, "f");
    this.updateCounter(previousState);
  }
  isCircularDependency(dependency) {
    if (dependency.id === this.id) {
      return true;
    }
    const visited = /* @__PURE__ */ new Set();
    const stack = [dependency];
    while (stack.length > 0) {
      const current = stack.pop();
      if (!current) {
        return false;
      }
      visited.add(current.id);
      for (const dependency2 of current.dependencies) {
        if (dependency2 === this.id) {
          return true;
        }
        if (!visited.has(dependency2)) {
          stack.push(this.node.getCoValue(dependency2));
        }
      }
    }
    return false;
  }
  /**
   * Add a new content to the queue and handle it when the dependencies are available
   */
  addNewContentToQueue(msg, from) {
    const alreadyEnqueued = this.newContentQueue.length > 0;
    this.newContentQueue.push({ msg, from });
    if (alreadyEnqueued) {
      return;
    }
    this.waitFor({
      predicate: (core2) => !core2.hasMissingDependencies(),
      onSuccess: () => {
        const enqueuedNewContent = this.newContentQueue;
        this.newContentQueue = [];
        for (const { msg: msg2, from: from2 } of enqueuedNewContent) {
          this.node.syncManager.handleNewContent(msg2, from2);
        }
      }
    });
  }
  addDependencyFromHeader(header) {
    for (const dep of getDependenciesFromHeader(header)) {
      this.addDependency(dep);
    }
  }
  provideHeader(header, streamingKnownState, skipVerify) {
    if (!skipVerify) {
      const validation2 = validateUniqueness(header.uniqueness);
      if (!validation2.isOk) {
        logger.error("Invalid uniqueness", {
          header,
          errorMessage: validation2.message
        });
        return false;
      }
      const expectedId = idforHeader$1(header, this.node.crypto);
      if (this.id !== expectedId) {
        return false;
      }
    }
    this.addDependencyFromHeader(header);
    if (this._verified?.sessions.size) {
      throw new Error("CoValueCore: provideHeader called on coValue with verified sessions present!");
    }
    this._verified = new VerifiedState(this.id, this.node.crypto, header, new SessionMap(this.id, this.node.crypto, streamingKnownState));
    if (this.isAvailable()) {
      this.cleanupLastKnownState();
    }
    return true;
  }
  markErrored(peerId, error) {
    const previousState = this.loadingState;
    this.loadingStatuses.set(peerId, { type: "errored", error });
    this.updateCounter(previousState);
    this.scheduleNotifyUpdate();
  }
  markPending(peerId) {
    const previousState = this.loadingState;
    this.loadingStatuses.set(peerId, { type: "pending" });
    this.updateCounter(previousState);
    this.scheduleNotifyUpdate();
  }
  contentInClonedNodeWithDifferentAccount(account) {
    return this.node.loadCoValueAsDifferentAgent(this.id, account.agentSecret, account.id).then((core2) => core2.getCurrentContent());
  }
  /**
   * Returns the known state considering the known state of the streaming source
   *
   * Used to correctly manage the content & subscriptions during the content streaming process
   */
  knownStateWithStreaming() {
    if (this.verified) {
      return this.verified.immutableKnownStateWithStreaming();
    }
    return this.knownState();
  }
  /**
   * Returns the known state of the CoValue
   *
   * The return value identity is going to be stable as long as the CoValue is not modified.
   *
   * On change the knownState is invalidated and a new object is returned.
   *
   * For garbageCollected/onlyKnownState CoValues, returns the cached knownState.
   */
  knownState() {
    if (this.verified) {
      return this.verified.immutableKnownState();
    }
    if (__classPrivateFieldGet$1(this, _CoValueCore_lastKnownState, "f")) {
      return __classPrivateFieldGet$1(this, _CoValueCore_lastKnownState, "f");
    }
    return emptyKnownState(this.id);
  }
  /**
   * Returns a known state message to signal to the peer that the coValue doesn't need to be synced anymore
   *
   * Implemented to be backward compatible with clients that don't support deleted coValues
   */
  stopSyncingKnownStateMessage(peerKnownState) {
    if (!peerKnownState) {
      return {
        action: "known",
        ...this.knownState()
      };
    }
    const knownState = cloneKnownState(this.knownState());
    combineKnownStateSessions(knownState.sessions, peerKnownState.sessions);
    return {
      action: "known",
      ...knownState
    };
  }
  get meta() {
    return this.verified?.header.meta ?? null;
  }
  nextTransactionID() {
    if (!this.verified) {
      throw new Error("CoValueCore: nextTransactionID called on coValue without verified state");
    }
    const sessionID = this.verified.header.meta?.type === "account" ? this.node.currentSessionID.replace(this.node.getCurrentAgent().id, this.node.getCurrentAgent().currentAgentID()) : this.node.currentSessionID;
    return {
      sessionID,
      txIndex: this.verified.sessions.get(sessionID)?.transactions.length || 0
    };
  }
  addDependenciesFromContentMessage(newContent) {
    const dependencies2 = getDependenciesFromContentMessage(this, newContent);
    for (const dependency of dependencies2) {
      this.addDependency(dependency);
    }
  }
  /**
   * Apply new transactions that were not generated by the current node to the CoValue
   */
  tryAddTransactions(sessionID, newTransactions, newSignature, skipVerify = false) {
    if (newTransactions.length === 0) {
      return;
    }
    let signerID;
    if (this.isDeleted && !isDeleteSessionID(sessionID)) {
      return {
        type: "CoValueDeleted",
        id: this.id,
        error: new Error("Cannot add transactions to a deleted coValue")
      };
    }
    if (!skipVerify) {
      const result = this.node.resolveAccountAgent(accountOrAgentIDfromSessionID(sessionID), "Expected to know signer of transaction");
      if (result.error || !result.value) {
        return {
          type: "ResolveAccountAgentError",
          id: this.id,
          error: result.error
        };
      }
      signerID = this.crypto.getAgentSignerID(result.value);
    }
    if (!this.verified) {
      return {
        type: "TriedToAddTransactionsWithoutVerifiedState",
        id: this.id,
        error: void 0
      };
    }
    const isDeleteTransaction = __classPrivateFieldGet$1(this, _CoValueCore_instances, "m", _CoValueCore_isDeleteTransaction).call(this, sessionID, newTransactions, skipVerify);
    if (isDeleteTransaction.err) {
      return isDeleteTransaction.err;
    }
    try {
      this.verified.tryAddTransactions(sessionID, signerID, newTransactions, newSignature, skipVerify);
      if (isDeleteTransaction.value) {
        __classPrivateFieldGet$1(this, _CoValueCore_instances, "m", _CoValueCore_markAsDeleted).call(this);
      }
      this.processNewTransactions();
      this.scheduleNotifyUpdate();
      this.invalidateDependants();
    } catch (e) {
      return { type: "InvalidSignature", id: this.id, error: e };
    }
  }
  notifyDependants() {
    if (!this.isGroup()) {
      return;
    }
    for (const dependency of this.dependant) {
      this.node.getCoValue(dependency).scheduleNotifyUpdate();
      this.node.getCoValue(dependency).notifyDependants();
    }
  }
  invalidateDependants() {
    if (!this.isGroup()) {
      return;
    }
    for (const dependency of this.dependant) {
      this.node.getCoValue(dependency).resetParsedTransactions();
      this.node.getCoValue(dependency).invalidateDependants();
    }
  }
  processNewTransactions() {
    if (this._cachedContent) {
      this._cachedContent.processNewTransactions();
    }
  }
  scheduleNotifyUpdate() {
    if (this.listeners.size === 0) {
      return;
    }
    __classPrivateFieldSet(this, _CoValueCore_batchedUpdates, true, "f");
    if (!__classPrivateFieldGet$1(this, _CoValueCore_isNotificationScheduled, "f")) {
      __classPrivateFieldSet(this, _CoValueCore_isNotificationScheduled, true, "f");
      queueMicrotask(() => {
        __classPrivateFieldSet(this, _CoValueCore_isNotificationScheduled, false, "f");
        if (__classPrivateFieldGet$1(this, _CoValueCore_batchedUpdates, "f")) {
          this.notifyUpdate();
        }
      });
    }
  }
  pauseNotifyUpdate() {
    __classPrivateFieldSet(this, _CoValueCore_isNotifyUpdatePaused, true, "f");
  }
  resumeNotifyUpdate() {
    __classPrivateFieldSet(this, _CoValueCore_isNotifyUpdatePaused, false, "f");
    this.notifyUpdate();
  }
  notifyUpdate() {
    if (this.listeners.size === 0 || __classPrivateFieldGet$1(this, _CoValueCore_isNotifyUpdatePaused, "f")) {
      return;
    }
    __classPrivateFieldSet(this, _CoValueCore_batchedUpdates, false, "f");
    for (const listener of this.listeners) {
      try {
        listener(this, () => {
          this.listeners.delete(listener);
        });
      } catch (e) {
        logger.error("Error in listener for coValue " + this.id, { err: e });
      }
    }
  }
  subscribe(listener, immediateInvoke = true) {
    this.listeners.add(listener);
    if (immediateInvoke) {
      listener(this, () => {
        this.listeners.delete(listener);
      });
    }
    return () => {
      this.listeners.delete(listener);
    };
  }
  validateDeletePermissions() {
    if (!this.verified) {
      return {
        ok: false,
        reason: "CannotVerifyPermissions",
        message: "Cannot verify delete permissions without verified state"
      };
    }
    if (this.isGroupOrAccount()) {
      return {
        ok: false,
        reason: "CoValueNotDeletable",
        message: "Cannot delete Group or Account coValues"
      };
    }
    const group = this.safeGetGroup();
    if (!group) {
      return {
        ok: false,
        reason: "CannotVerifyPermissions",
        message: "Cannot verify delete permissions for coValues not owned by a group"
      };
    }
    const role = group.myRole();
    if (role !== "admin") {
      return {
        ok: false,
        reason: "NotAdmin",
        message: "The current account lacks admin permissions to delete this coValue"
      };
    }
    return { ok: true };
  }
  /**
   * Creates a delete marker transaction for this CoValue and sets the coValue as deleted
   *
   * Constraints:
   * - Account and Group CoValues cannot be deleted.
   * - Only admins can delete a coValue.
   */
  deleteCoValue() {
    if (this.isDeleted) {
      return;
    }
    const result = this.validateDeletePermissions();
    if (!result.ok) {
      throw new Error(result.message);
    }
    this.makeTransaction(
      [],
      // Empty changes array
      "trusting",
      // Unencrypted
      { deleted: this.id }
    );
  }
  /**
   * Creates a new transaction with local changes and syncs it to all peers
   */
  makeTransaction(changes, privacy, meta, madeAt) {
    if (!this.verified) {
      throw new Error("CoValueCore: makeTransaction called on coValue without verified state");
    }
    const isDeleteTransaction = Boolean(meta?.deleted);
    if (this.isDeleted && !isDeleteTransaction) {
      logger.error("Cannot make transaction on a deleted coValue", {
        id: this.id
      });
      return false;
    }
    let sessionID = this.verified.header.meta?.type === "account" ? this.node.currentSessionID.replace(this.node.getCurrentAgent().id, this.node.getCurrentAgent().currentAgentID()) : this.node.currentSessionID;
    if (isDeleteTransaction) {
      sessionID = this.crypto.newDeleteSessionID(this.node.getCurrentAccountOrAgentID());
    }
    const signerAgent = this.node.getCurrentAgent();
    let result;
    const knownStateBefore = this.knownState();
    if (privacy === "private") {
      const { secret: keySecret, id: keyID } = this.getCurrentReadKey();
      if (!keySecret) {
        throw new Error("Can't make transaction without read key secret");
      }
      result = this.verified.makeNewPrivateTransaction(sessionID, signerAgent, changes, keyID, keySecret, meta, madeAt ?? Date.now());
    } else {
      result = this.verified.makeNewTrustingTransaction(sessionID, signerAgent, changes, meta, madeAt ?? Date.now());
    }
    if (isDeleteTransaction) {
      __classPrivateFieldGet$1(this, _CoValueCore_instances, "m", _CoValueCore_markAsDeleted).call(this);
    }
    const { transaction } = result;
    this.parsingCache.set(transaction, { changes, meta });
    this.node.syncManager.recordTransactionsSize([transaction], "local");
    this.processNewTransactions();
    this.addDependenciesFromNewTransaction(transaction);
    this.notifyUpdate();
    this.node.syncManager.syncLocalTransaction(this.verified, knownStateBefore);
    if (madeAt === void 0) {
      this.notifyDependants();
    } else {
      this.invalidateDependants();
    }
    return true;
  }
  addDependenciesFromNewTransaction(transaction) {
    if (this.verified?.header.ruleset.type === "group") {
      for (const dependency of getDependenciesFromGroupRawTransactions([
        transaction
      ])) {
        this.addDependency(dependency);
      }
    }
  }
  getCurrentContent(options) {
    if (!this.verified) {
      throw new Error("CoValueCore: getCurrentContent called on coValue without verified state");
    }
    if (!options?.ignorePrivateTransactions && this._cachedContent) {
      return this._cachedContent;
    }
    const newContent = coreToCoValue(this, options);
    if (!options?.ignorePrivateTransactions) {
      this._cachedContent = newContent;
    }
    return newContent;
  }
  // Reset the parsed transactions and branches, to validate them again from scratch when the group is updated
  resetParsedTransactions() {
    const verifiedTransactions = this.verifiedTransactions;
    if (verifiedTransactions.length === 0) {
      return;
    }
    this.branchStart = void 0;
    this.mergeCommits = [];
    const validityBeforeReset = new Array(verifiedTransactions.length);
    this.verifiedTransactions.forEach((transaction, index2) => {
      transaction.isValidated = false;
      validityBeforeReset[index2] = transaction.isValidTransactionWithChanges();
    });
    this.toValidateTransactions = verifiedTransactions.slice();
    this.toProcessTransactions = [];
    this.toDecryptTransactions = [];
    this.toParseMetaTransactions = [];
    this.parseNewTransactions(false);
    const sameAsBefore = validityBeforeReset.every((valid, index2) => valid === verifiedTransactions[index2]?.isValidTransactionWithChanges());
    if (!sameAsBefore) {
      this._cachedContent?.rebuildFromCore();
    }
    this.scheduleNotifyUpdate();
  }
  /**
     * Loads the new transaction from the SessionMap into verifiedTransactions as a VerifiedTransaction.
     *
     * If the transaction is already loaded from the SessionMap in the past, it will not be loaded again.
     *
     * Used to have a fast way to iterate over the CoValue transactions, and track their validation/decoding state.
  
    * @internal
     * */
  loadVerifiedTransactionsFromLogs() {
    if (!this.verified) {
      return;
    }
    const isBranched = this.isBranched();
    for (const [sessionID, sessionLog] of this.verified.sessions.entries()) {
      const count = this.verifiedTransactionsKnownSessions[sessionID] ?? 0;
      for (let txIndex = count; txIndex < sessionLog.transactions.length; txIndex++) {
        const tx = sessionLog.transactions[txIndex];
        if (!tx) {
          continue;
        }
        const cache = this.parsingCache.get(tx);
        if (cache) {
          this.parsingCache.delete(tx);
        }
        const verifiedTransaction = new VerifiedTransaction(this.id, sessionID, txIndex, tx, isBranched ? this.id : void 0, cache, this.lastVerifiedTransactionBySessionID[sessionID], this.dispatchTransaction);
        if (verifiedTransaction.madeAt > this.latestTxMadeAt) {
          this.latestTxMadeAt = verifiedTransaction.madeAt;
        }
        if (verifiedTransaction.madeAt < this.earliestTxMadeAt) {
          this.earliestTxMadeAt = verifiedTransaction.madeAt;
        }
        this.verifiedTransactions.push(verifiedTransaction);
        this.dispatchTransaction(verifiedTransaction);
        this.lastVerifiedTransactionBySessionID[sessionID] = verifiedTransaction;
      }
      this.verifiedTransactionsKnownSessions[sessionID] = sessionLog.transactions.length;
    }
  }
  /**
   * Iterates over the verifiedTransactions and marks them as valid or invalid, based on the group membership of the authors of the transactions  .
   */
  determineValidTransactions() {
    determineValidTransactions(this);
    this.toValidateTransactions = [];
  }
  /**
   * Parses the meta information of a transaction, and set the branchStart and mergeCommits.
   */
  parseMetaInformation(transaction) {
    if (!transaction.meta) {
      return;
    }
    if (this.isBranched()) {
      if ("from" in transaction.meta) {
        const meta = transaction.meta;
        if (this.branchStart) {
          this.branchStart = combineKnownStateSessions(this.branchStart, meta.from);
        } else {
          this.branchStart = meta.from;
        }
      }
    }
    if ("branch" in transaction.meta) {
      const branch = transaction.meta;
      this.branches.push(branch);
    }
    if ("merged" in transaction.meta) {
      const mergeCommit = transaction.meta;
      this.mergeCommits.push(mergeCommit);
    }
    if ("mi" in transaction.meta) {
      const meta = transaction.meta;
      const previousTransaction = transaction.previous;
      const sessionID = meta.s ?? previousTransaction?.txID.sessionID;
      if (meta.t) {
        transaction.sourceTxMadeAt = transaction.currentMadeAt - meta.t;
      } else if (previousTransaction) {
        transaction.sourceTxMadeAt = previousTransaction.madeAt;
      }
      if (transaction.sourceTxMadeAt && transaction.sourceTxMadeAt > transaction.currentMadeAt) {
        transaction.markInvalid("Transaction sourceMadeAt is after the currentMadeAt", {
          sourceTxMadeAt: transaction.sourceTxMadeAt,
          currentMadeAt: transaction.currentMadeAt
        });
      }
      if (sessionID) {
        transaction.sourceTxID = {
          sessionID,
          txIndex: meta.mi,
          branch: meta.b ?? previousTransaction?.txID.branch
        };
      } else {
        logger.error("Merge commit without session ID", {
          txID: transaction.txID,
          prevTxID: previousTransaction?.txID ?? null
        });
      }
    }
  }
  /**
   * Loads the new transactions from SessionMap and:
   * - Validates each transaction based on the group membership of the authors
   * - Decodes the changes & meta for each transaction
   * - Parses the meta information of the transaction
   */
  parseNewTransactions(ignorePrivateTransactions) {
    if (!this.isAvailable()) {
      return;
    }
    this.loadVerifiedTransactionsFromLogs();
    this.determineValidTransactions();
    if (!ignorePrivateTransactions) {
      const toDecryptTransactions = this.toDecryptTransactions;
      this.toDecryptTransactions = [];
      for (const transaction of toDecryptTransactions) {
        decryptTransactionChangesAndMeta(this, transaction);
        this.dispatchTransaction(transaction);
      }
    }
    const toParseMetaTransactions = this.toParseMetaTransactions;
    this.toParseMetaTransactions = [];
    for (const transaction of toParseMetaTransactions) {
      this.parseMetaInformation(transaction);
    }
  }
  /**
   * Returns the valid transactions matching the criteria specified in the options
   */
  getValidTransactions(options) {
    if (!this.verified) {
      return [];
    }
    this.parseNewTransactions(options?.ignorePrivateTransactions ?? false);
    const matchingTransactions = [];
    const source = getBranchSource(this);
    const from = options?.from;
    const to = options?.to;
    const knownTransactions = options?.knownTransactions?.[this.id] ?? 0;
    for (let i = knownTransactions; i < this.toProcessTransactions.length; i++) {
      const transaction = this.toProcessTransactions[i];
      if (!transaction.isValidTransactionWithChanges()) {
        continue;
      }
      const txID = transaction.currentTxID;
      const fromIdx = from?.[txID.sessionID] ?? -1;
      const toIdx = to?.[txID.sessionID] ?? Infinity;
      if (fromIdx > txID.txIndex || toIdx < txID.txIndex) {
        continue;
      }
      matchingTransactions.push(transaction);
    }
    if (options?.knownTransactions !== void 0) {
      options.knownTransactions[this.id] = this.toProcessTransactions.length;
    }
    if (source && this.branchStart && !options?.skipBranchSource) {
      const sourceTransactions = source.getValidTransactions({
        knownTransactions: options?.knownTransactions,
        to: this.branchStart,
        ignorePrivateTransactions: options?.ignorePrivateTransactions ?? false
      });
      for (const transaction of sourceTransactions) {
        matchingTransactions.push(transaction);
      }
    }
    return matchingTransactions;
  }
  addDependency(dependency) {
    const dependencyCoValue = this.node.getCoValue(dependency);
    if (this.isCircularDependency(dependencyCoValue) || this.dependencies.has(dependency)) {
      return;
    }
    this.dependencies.add(dependency);
    dependencyCoValue.addDependant(this.id);
    if (!dependencyCoValue.isCompletelyDownloaded()) {
      this.incompleteDependencies.add(dependencyCoValue.id);
      dependencyCoValue.waitFor({
        predicate: (dependencyCoValue2) => dependencyCoValue2.isCompletelyDownloaded(),
        onSuccess: () => {
          this.incompleteDependencies.delete(dependencyCoValue.id);
          if (this.incompleteDependencies.size === 0) {
            this.notifyUpdate();
          }
        }
      });
    }
    if (!dependencyCoValue.isAvailable()) {
      this.missingDependencies.add(dependencyCoValue.id);
      dependencyCoValue.waitFor({
        predicate: (dependencyCoValue2) => dependencyCoValue2.isAvailable(),
        onSuccess: () => {
          this.missingDependencies.delete(dependencyCoValue.id);
          if (this.missingDependencies.size === 0) {
            this.notifyUpdate();
          }
        }
      });
    }
  }
  addDependant(dependant) {
    this.dependant.add(dependant);
  }
  isGroupOrAccount() {
    if (!this.verified) {
      return false;
    }
    return this.verified.header.ruleset.type === "group";
  }
  isGroup() {
    if (!this.verified) {
      return false;
    }
    if (this.verified.header.ruleset.type !== "group") {
      return false;
    }
    if (this.verified.header.meta?.type === "account") {
      return false;
    }
    return true;
  }
  createBranch(name, ownerId) {
    return createBranch(this, name, ownerId);
  }
  mergeBranch() {
    return mergeBranch(this);
  }
  getBranch(name, ownerId) {
    return this.node.getCoValue(getBranchId(this, name, ownerId));
  }
  getCurrentBranchName() {
    return this.verified?.branchName;
  }
  getCurrentBranchSourceId() {
    return this.verified?.branchSourceId;
  }
  isBranched() {
    return Boolean(this.verified?.branchSourceId);
  }
  hasBranch(name, ownerId) {
    this.parseNewTransactions(false);
    const currentOwnerId = getBranchOwnerId(this);
    return this.branches.some((item) => {
      if (item.branch !== name) {
        return false;
      }
      if (item.ownerId === ownerId) {
        return true;
      }
      if (!ownerId) {
        return item.ownerId === currentOwnerId;
      }
      if (!item.ownerId) {
        return ownerId === currentOwnerId;
      }
    });
  }
  getMergeCommits() {
    return this.mergeCommits;
  }
  getValidSortedTransactions(options) {
    const allTransactions = this.getValidTransactions(options);
    allTransactions.sort(this.compareTransactions);
    return allTransactions;
  }
  compareTransactions(a, b) {
    if (a.madeAt !== b.madeAt) {
      return a.madeAt - b.madeAt;
    }
    if (a.txID.sessionID === b.txID.sessionID) {
      return a.txID.txIndex - b.txID.txIndex;
    }
    return 0;
  }
  getCurrentReadKey() {
    if (!this.verified) {
      throw new Error("CoValueCore: getCurrentReadKey called on coValue without verified state");
    }
    if (this.isGroupOrAccount()) {
      return expectGroup(this.getCurrentContent()).getCurrentReadKey();
    } else if (this.verified.header.ruleset.type === "ownedByGroup") {
      return this.node.expectCoValueLoaded(this.verified.header.ruleset.group).getCurrentReadKey();
    } else {
      throw new Error("Only groups or values owned by groups have read secrets");
    }
  }
  getReadKey(keyID) {
    const cachedSecret = this.readKeyCache.get(keyID);
    if (cachedSecret) {
      return cachedSecret;
    }
    if (!this.verified) {
      throw new Error("CoValueCore: getUncachedReadKey called on coValue without verified state");
    }
    if (this.isGroup()) {
      const content = expectGroup(
        // Private transactions are not considered valid in groups, so we don't need to pass
        // ignorePrivateTransactions: true to safely load the content
        this.getCurrentContent()
      );
      return content.getReadKey(keyID);
    } else if (this.isGroupOrAccount()) {
      const content = expectGroup(
        // Old accounts might have private transactions, because we were encrypting the root id in the past
        // So we need to load the account without private transactions, because we can't decrypt them without the read key
        this.getCurrentContent({ ignorePrivateTransactions: true })
      );
      return content.getReadKey(keyID);
    } else if (this.verified.header.ruleset.type === "ownedByGroup") {
      return expectGroup(this.node.expectCoValueLoaded(this.verified.header.ruleset.group).getCurrentContent()).getReadKey(keyID);
    } else {
      throw new Error("Only groups or values owned by groups have read secrets");
    }
  }
  safeGetGroup() {
    if (!this.verified) {
      throw new Error("CoValueCore: getGroup called on coValue without verified state");
    }
    if (this.verified.header.ruleset.type !== "ownedByGroup") {
      return void 0;
    }
    return expectGroup(this.node.expectCoValueLoaded(this.verified.header.ruleset.group).getCurrentContent());
  }
  getGroup() {
    const group = this.safeGetGroup();
    if (!group) {
      throw new Error("Only values owned by groups have groups");
    }
    return group;
  }
  getTx(txID) {
    return this.verified?.sessions.get(txID.sessionID)?.transactions[txID.txIndex];
  }
  getDependedOnCoValues() {
    return this.dependencies;
  }
  waitForSync(options) {
    return this.node.syncManager.waitForSync(this.id, options?.timeout);
  }
  load(peers, mode) {
    this.loadFromStorage((found) => {
      if (!found) {
        this.loadFromPeers(peers, mode);
      }
    });
  }
  loadFromStorage(done) {
    const node = this.node;
    if (!node.storage) {
      done?.(false);
      return;
    }
    const currentState = this.getLoadingStateForPeer("storage");
    if (currentState === "pending") {
      if (!done) {
        return;
      }
      this.subscribe((state, unsubscribe) => {
        const updatedState = state.getLoadingStateForPeer("storage");
        if (updatedState === "available" || state.isAvailable()) {
          unsubscribe();
          done(true);
        } else if (updatedState === "errored" || updatedState === "unavailable") {
          unsubscribe();
          done(false);
        }
      });
      return;
    }
    const overallState = this.loadingState;
    if (currentState !== "unknown" && overallState !== "garbageCollected" && overallState !== "onlyKnownState") {
      done?.(currentState === "available");
      return;
    }
    this.markPending("storage");
    node.storage.load(this.id, (data2) => {
      node.syncManager.handleNewContent(data2, "storage");
    }, (found) => {
      done?.(found);
      if (!found) {
        this.markNotFoundInPeer("storage");
      }
    });
  }
  /**
   * Lazily load only the knownState from storage without loading full transaction data.
   * This is useful for checking if a peer needs new content before committing to a full load.
   *
   * If found in storage, marks the CoValue as onlyKnownState and caches the knownState.
   * This enables accurate LOAD requests during peer reconciliation.
   *
   * @param done - Callback with the storage knownState, or undefined if not found in storage
   */
  getKnownStateFromStorage(done) {
    if (!this.node.storage) {
      done(void 0);
      return;
    }
    const knownState = this.knownState();
    if (knownState.header) {
      done(knownState);
      return;
    }
    this.node.storage.loadKnownState(this.id, (knownState2) => {
      if (knownState2 && !this.isAvailable()) {
        const previousState = this.loadingState;
        __classPrivateFieldSet(this, _CoValueCore_lastKnownStateSource, "onlyKnownState", "f");
        __classPrivateFieldSet(this, _CoValueCore_lastKnownState, knownState2, "f");
        this.updateCounter(previousState);
      }
      done(knownState2);
    });
  }
  loadFromPeers(peers, mode) {
    if (peers.length === 0) {
      return;
    }
    for (const peer of peers) {
      const currentState = this.getLoadingStateForPeer(peer.id);
      if (currentState === "unknown" || currentState === "unavailable") {
        this.markPending(peer.id);
        this.internalLoadFromPeer(peer, mode);
      }
    }
  }
  internalLoadFromPeer(peer, mode) {
    if (peer.closed && !peer.persistent) {
      this.markNotFoundInPeer(peer.id);
      return;
    }
    const markNotFound = () => {
      if (this.getLoadingStateForPeer(peer.id) === "pending") {
        logger.warn("Timeout waiting for peer to load coValue", {
          id: this.id,
          peerID: peer.id
        });
        this.markNotFoundInPeer(peer.id);
      }
    };
    const removeCloseListener = peer.persistent ? void 0 : peer.addCloseListener(markNotFound);
    if (!peer.closed) {
      peer.sendLoadRequest(this, mode);
    }
    this.subscribe((state, unsubscribe) => {
      const peerState = state.getLoadingStateForPeer(peer.id);
      if (state.isAvailable() || // might have become available from another peer e.g. through handleNewContent
      peerState === "available" || peerState === "errored" || peerState === "unavailable") {
        unsubscribe();
        removeCloseListener?.();
      }
    }, true);
  }
}
_CoValueCore_lastKnownStateSource = /* @__PURE__ */ new WeakMap(), _CoValueCore_lastKnownState = /* @__PURE__ */ new WeakMap(), _CoValueCore_isNotificationScheduled = /* @__PURE__ */ new WeakMap(), _CoValueCore_batchedUpdates = /* @__PURE__ */ new WeakMap(), _CoValueCore_isNotifyUpdatePaused = /* @__PURE__ */ new WeakMap(), _CoValueCore_instances = /* @__PURE__ */ new WeakSet(), _CoValueCore_isDeleteTransaction = function _CoValueCore_isDeleteTransaction2(sessionID, newTransactions, skipVerify) {
  if (!this.verified) {
    return {
      value: false
    };
  }
  let deleteTransaction = void 0;
  if (isDeleteSessionID(sessionID)) {
    const txCount = this.verified.sessions.get(sessionID)?.transactions.length ?? 0;
    if (txCount > 0 || newTransactions.length > 1) {
      return {
        value: true,
        err: {
          type: "DeleteTransactionRejected",
          id: this.id,
          sessionID,
          reason: "InvalidDeleteTransaction",
          error: new Error("Delete transaction must be the only transaction in the session")
        }
      };
    }
    const firstTransaction = newTransactions[0];
    const deleteMarker = firstTransaction && __classPrivateFieldGet$1(this, _CoValueCore_instances, "m", _CoValueCore_getDeleteMarker).call(this, firstTransaction);
    if (deleteMarker) {
      deleteTransaction = firstTransaction;
      if (deleteMarker.deleted !== this.id) {
        return {
          value: true,
          err: {
            type: "DeleteTransactionRejected",
            id: this.id,
            sessionID,
            reason: "InvalidDeleteTransaction",
            error: new Error(`Delete transaction ID mismatch: expected ${this.id}, got ${deleteMarker.deleted}`)
          }
        };
      }
    }
    if (this.isGroupOrAccount()) {
      return {
        value: true,
        err: {
          type: "DeleteTransactionRejected",
          id: this.id,
          sessionID,
          reason: "CoValueNotDeletable",
          error: new Error("Cannot delete Group or Account coValues")
        }
      };
    }
  }
  if (!skipVerify && deleteTransaction) {
    const author = accountOrAgentIDfromSessionID(sessionID);
    const permission = __classPrivateFieldGet$1(this, _CoValueCore_instances, "m", _CoValueCore_canAuthorDeleteCoValueAtTime).call(this, author, deleteTransaction.madeAt);
    if (!permission.ok) {
      return {
        value: true,
        err: {
          type: "DeleteTransactionRejected",
          id: this.id,
          sessionID,
          author,
          reason: permission.reason,
          error: new Error(permission.message)
        }
      };
    }
  }
  return {
    value: Boolean(deleteTransaction)
  };
}, _CoValueCore_markAsDeleted = function _CoValueCore_markAsDeleted2() {
  this.isDeleted = true;
  this.verified?.markAsDeleted();
}, _CoValueCore_getDeleteMarker = function _CoValueCore_getDeleteMarker2(tx) {
  if (tx.privacy !== "trusting") {
    return;
  }
  if (!tx.meta) {
    return;
  }
  const meta = safeParseJSON(tx.meta);
  return meta && typeof meta.deleted === "string" ? meta : void 0;
}, _CoValueCore_canAuthorDeleteCoValueAtTime = function _CoValueCore_canAuthorDeleteCoValueAtTime2(author, madeAt) {
  if (!this.verified) {
    return {
      ok: false,
      reason: "CannotVerifyPermissions",
      message: "Cannot verify delete permissions without verified state"
    };
  }
  if (this.isGroupOrAccount()) {
    return {
      ok: false,
      reason: "CoValueNotDeletable",
      message: "Cannot delete Group or Account coValues"
    };
  }
  const group = this.safeGetGroup();
  if (!group) {
    return {
      ok: false,
      reason: "CannotVerifyPermissions",
      message: "Cannot verify delete permissions for coValues not owned by a group"
    };
  }
  const groupAtTime = group.atTime(madeAt);
  const role = groupAtTime.roleOfInternal(author);
  if (role !== "admin") {
    return {
      ok: false,
      reason: "NotAdmin",
      message: "Delete transaction rejected: author is not an admin"
    };
  }
  return { ok: true };
};
class GarbageCollector {
  constructor(node) {
    this.node = node;
    this.interval = setInterval(() => {
      this.collect();
    }, GARBAGE_COLLECTOR_CONFIG.INTERVAL);
  }
  getCurrentTime() {
    return performance.now();
  }
  trackCoValueAccess({ verified }) {
    if (verified) {
      verified.lastAccessed = this.getCurrentTime();
    }
  }
  collect() {
    const currentTime = this.getCurrentTime();
    for (const coValue of this.node.allCoValues()) {
      const { verified } = coValue;
      if (!verified?.lastAccessed) {
        continue;
      }
      const timeSinceLastAccessed = currentTime - verified.lastAccessed;
      if (timeSinceLastAccessed > GARBAGE_COLLECTOR_CONFIG.MAX_AGE) {
        this.node.internalUnmountCoValue(coValue.id);
      }
    }
  }
  stop() {
    clearInterval(this.interval);
  }
}
class PeerKnownState {
  constructor(id2, peerId) {
    this.id = id2;
    this.peerId = peerId;
    this.knownState = emptyKnownState(id2);
  }
  cloneWithoutOptimistic() {
    const clone = new PeerKnownState(this.id, this.peerId);
    clone.set(this.knownState);
    return clone;
  }
  updateHeader(header) {
    this.knownState.header = header;
    if (this.optimisticKnownState) {
      this.optimisticKnownState.header = header;
    }
  }
  combineWith(value) {
    combineKnownStates(this.knownState, value);
    if (this.optimisticKnownState) {
      combineKnownStates(this.optimisticKnownState, value);
    }
  }
  combineOptimisticWith(value) {
    if (!this.optimisticKnownState) {
      this.optimisticKnownState = cloneKnownState(this.knownState);
    }
    combineKnownStates(this.optimisticKnownState, value);
  }
  /**
   * Aligns the CoValue known state with the defined payload
   */
  set(payload) {
    if (payload === "empty") {
      this.knownState.header = false;
      this.knownState.sessions = {};
    } else {
      this.knownState.header = payload.header;
      this.knownState.sessions = { ...payload.sessions };
    }
    this.optimisticKnownState = void 0;
  }
  value() {
    return this.knownState;
  }
  optimisticValue() {
    return this.optimisticKnownState ?? this.knownState;
  }
}
class LinkedList {
  constructor(meter) {
    this.meter = meter;
    this.head = void 0;
    this.tail = void 0;
    this.length = 0;
  }
  push(value) {
    const node = { value, prev: void 0, next: void 0 };
    if (this.head === void 0) {
      this.head = node;
      this.tail = node;
    } else if (this.tail) {
      node.prev = this.tail;
      this.tail.next = node;
      this.tail = node;
    } else {
      throw new Error("LinkedList is corrupted");
    }
    this.length++;
    this.meter?.push();
    return node;
  }
  shift() {
    if (!this.head) {
      return void 0;
    }
    const node = this.head;
    const value = node.value;
    this.head = node.next;
    node.next = void 0;
    if (this.head === void 0) {
      this.tail = void 0;
    } else {
      this.head.prev = void 0;
    }
    this.length--;
    this.meter?.pull();
    return value;
  }
  /**
   * Remove a specific node from the list in O(1) time.
   * The node must be a valid node that was returned by push().
   */
  remove(node) {
    if (node.prev) {
      node.prev.next = node.next;
    } else {
      this.head = node.next;
    }
    if (node.next) {
      node.next.prev = node.prev;
    } else {
      this.tail = node.prev;
    }
    node.prev = void 0;
    node.next = void 0;
    this.length--;
    this.meter?.pull();
  }
  isEmpty() {
    return this.head === void 0;
  }
}
class QueueMeter {
  constructor(prefix, attrs) {
    this.attrs = attrs;
    this.pullCounter = metrics.getMeter("cojson").createCounter(`${prefix}.pulled`, {
      description: "Number of messages pulled from the queue",
      valueType: ValueType.INT,
      unit: "1"
    });
    this.pushCounter = metrics.getMeter("cojson").createCounter(`${prefix}.pushed`, {
      description: "Number of messages pushed to the queue",
      valueType: ValueType.INT,
      unit: "1"
    });
    this.pullCounter.add(0, this.attrs);
    this.pushCounter.add(0, this.attrs);
  }
  pull() {
    this.pullCounter.add(1, this.attrs);
  }
  push() {
    this.pushCounter.add(1, this.attrs);
  }
}
function meteredList(type2, attrs) {
  return new LinkedList(new QueueMeter("jazz.messagequeue." + type2, attrs));
}
class OutgoingLoadQueue {
  constructor(peerId) {
    this.peerId = peerId;
    this.inFlightLoads = /* @__PURE__ */ new Map();
    this.highPriorityPending = meteredList("load-requests-queue", { priority: "high" });
    this.lowPriorityPending = meteredList("load-requests-queue", { priority: "low" });
    this.lowPriorityNodes = /* @__PURE__ */ new Map();
    this.highPriorityNodes = /* @__PURE__ */ new Map();
    this.timeoutHandle = null;
    this.processing = false;
  }
  /**
   * Check if we can send another load request.
   */
  canSend() {
    return this.inFlightLoads.size < CO_VALUE_LOADING_CONFIG.MAX_IN_FLIGHT_LOADS_PER_PEER;
  }
  /**
   * Track that a load request has been sent.
   */
  trackSent(coValue) {
    const now = performance.now();
    this.inFlightLoads.set(coValue, now);
    this.scheduleTimeoutCheck(CO_VALUE_LOADING_CONFIG.TIMEOUT);
  }
  /**
   * Schedule a timeout check if not already scheduled.
   * Uses a single timer to check all in-flight loads.
   */
  scheduleTimeoutCheck(nextTimeout) {
    if (this.timeoutHandle !== null) {
      return;
    }
    this.timeoutHandle = setTimeout(() => {
      this.timeoutHandle = null;
      this.checkTimeouts();
    }, nextTimeout);
  }
  /**
   * Check all in-flight loads for timeouts and handle them.
   */
  checkTimeouts() {
    const now = performance.now();
    let nextTimeout;
    for (const [coValue, sentAt] of this.inFlightLoads.entries()) {
      const timeout = sentAt + CO_VALUE_LOADING_CONFIG.TIMEOUT;
      if (now >= timeout) {
        if (!coValue.isAvailable()) {
          logger.warn("Load request timed out", {
            id: coValue.id,
            peerId: this.peerId
          });
          coValue.markNotFoundInPeer(this.peerId);
        } else if (coValue.isStreaming()) {
          logger.warn("Content streaming is taking more than " + CO_VALUE_LOADING_CONFIG.TIMEOUT / 1e3 + "s", {
            id: coValue.id,
            peerId: this.peerId,
            knownState: coValue.knownState().sessions,
            streamingTarget: coValue.knownStateWithStreaming().sessions
          });
        }
        this.inFlightLoads.delete(coValue);
        this.processQueue();
      } else {
        nextTimeout = Math.min(nextTimeout ?? Infinity, timeout - now);
      }
    }
    if (nextTimeout) {
      this.scheduleTimeoutCheck(nextTimeout);
    }
  }
  trackUpdate(coValue) {
    if (!this.inFlightLoads.has(coValue)) {
      return;
    }
    this.inFlightLoads.set(coValue, performance.now());
  }
  /**
   * Track that a load request has completed.
   * Triggers processing of pending requests.
   */
  trackComplete(coValue) {
    if (!this.inFlightLoads.has(coValue)) {
      return;
    }
    if (coValue.isStreaming()) {
      return;
    }
    this.inFlightLoads.delete(coValue);
    this.processQueue();
  }
  /**
   * Enqueue a load request.
   * Immediately processes the queue to send requests if capacity is available.
   * Skips CoValues that are already in-flight or pending.
   *
   * @param coValue - The CoValue to load
   * @param sendCallback - Callback to send the request when ready
   * @param mode - Optional mode: "low-priority" for background loads, "immediate" to bypass queue
   */
  enqueue(value, sendCallback, mode = "high-priority") {
    if (this.inFlightLoads.has(value)) {
      return;
    }
    const lowPriorityNode = this.lowPriorityNodes.get(value.id);
    const highPriorityNode = this.highPriorityNodes.get(value.id);
    switch (mode) {
      case "immediate":
        if (lowPriorityNode) {
          this.lowPriorityPending.remove(lowPriorityNode);
          this.lowPriorityNodes.delete(value.id);
        }
        if (highPriorityNode) {
          this.highPriorityPending.remove(highPriorityNode);
          this.highPriorityNodes.delete(value.id);
        }
        this.trackSent(value);
        sendCallback();
        break;
      case "high-priority":
        if (highPriorityNode) {
          return;
        }
        if (lowPriorityNode) {
          this.lowPriorityPending.remove(lowPriorityNode);
          this.lowPriorityNodes.delete(value.id);
        }
        this.highPriorityNodes.set(value.id, this.highPriorityPending.push({ value, sendCallback }));
        this.processQueue();
        break;
      case "low-priority":
        if (lowPriorityNode || highPriorityNode) {
          return;
        }
        this.lowPriorityNodes.set(value.id, this.lowPriorityPending.push({ value, sendCallback }));
        this.processQueue();
        break;
    }
  }
  /**
   * Process all pending load requests while capacity is available.
   * High-priority requests are processed first, then low-priority.
   */
  processQueue() {
    if (this.processing || !this.canSend()) {
      return;
    }
    this.processing = true;
    while (this.canSend()) {
      let next2 = this.highPriorityPending.shift();
      if (next2) {
        this.highPriorityNodes.delete(next2.value.id);
      } else {
        next2 = this.lowPriorityPending.shift();
        if (next2) {
          this.lowPriorityNodes.delete(next2.value.id);
        }
      }
      if (!next2) {
        break;
      }
      this.trackSent(next2.value);
      next2.sendCallback();
    }
    this.processing = false;
  }
  /**
   * Clear all state. Called on disconnect.
   * Clears the timeout and all pending/in-flight loads.
   */
  clear() {
    if (this.timeoutHandle !== null) {
      clearTimeout(this.timeoutHandle);
      this.timeoutHandle = null;
    }
    this.inFlightLoads.clear();
    while (this.highPriorityPending.shift()) {
    }
    while (this.lowPriorityPending.shift()) {
    }
    this.highPriorityNodes.clear();
    this.lowPriorityNodes.clear();
  }
  /**
   * Get the number of in-flight loads (for testing/debugging).
   */
  get inFlightCount() {
    return this.inFlightLoads.size;
  }
  /**
   * Get the number of pending loads (for testing/debugging).
   */
  get pendingCount() {
    return this.highPriorityPending.length + this.lowPriorityPending.length;
  }
  /**
   * Get the number of high-priority pending loads (for testing/debugging).
   */
  get highPriorityPendingCount() {
    return this.highPriorityPending.length;
  }
  /**
   * Get the number of low-priority pending loads (for testing/debugging).
   */
  get lowPriorityPendingCount() {
    return this.lowPriorityPending.length;
  }
}
class PeerState {
  constructor(peer, knownStates) {
    this.peer = peer;
    this.toldKnownState = /* @__PURE__ */ new Set();
    this.loadRequestSent = /* @__PURE__ */ new Set();
    this.listeners = /* @__PURE__ */ new Set();
    this.closed = false;
    this.closeListeners = /* @__PURE__ */ new Set();
    this._knownStates = knownStates ?? /* @__PURE__ */ new Map();
    this.loadQueue = new OutgoingLoadQueue(peer.id);
  }
  getKnownState(id2) {
    return this._knownStates.get(id2)?.value();
  }
  getOptimisticKnownState(id2) {
    return this._knownStates.get(id2)?.optimisticValue();
  }
  isCoValueSubscribedToPeer(id2) {
    return this._knownStates.has(id2);
  }
  /**
   * Closes the current peer state and creates a new one from a given peer,
   * keeping the same known states.
   *
   * This is used to create a new peer state when a peer reconnects.
   */
  newPeerStateFrom(peer) {
    if (!this.closed) {
      this.gracefulShutdown();
    }
    const knownStates = /* @__PURE__ */ new Map();
    for (const knownState of this._knownStates.values()) {
      knownStates.set(knownState.id, knownState.cloneWithoutOptimistic());
    }
    return new PeerState(peer, knownStates);
  }
  sendLoadRequest(coValue, mode) {
    this.toldKnownState.add(coValue.id);
    this.loadRequestSent.add(coValue.id);
    this.loadQueue.enqueue(coValue, () => {
      this.pushOutgoingMessage({
        action: "load",
        ...coValue.knownStateWithStreaming()
      });
    }, mode);
  }
  trackLoadRequestUpdate(coValue) {
    this.loadQueue.trackUpdate(coValue);
  }
  trackLoadRequestComplete(coValue) {
    this.loadQueue.trackComplete(coValue);
  }
  trackToldKnownState(id2) {
    this.toldKnownState.add(id2);
  }
  getOrCreateKnownState(id2) {
    let knownState = this._knownStates.get(id2);
    if (!knownState) {
      knownState = new PeerKnownState(id2, this.peer.id);
      this._knownStates.set(id2, knownState);
    }
    return knownState;
  }
  updateHeader(id2, header) {
    const knownState = this.getOrCreateKnownState(id2);
    knownState.updateHeader(header);
    this.triggerUpdate(id2, knownState);
  }
  combineWith(id2, value) {
    const knownState = this.getOrCreateKnownState(id2);
    knownState.combineWith(value);
    this.triggerUpdate(id2, knownState);
  }
  combineOptimisticWith(id2, value) {
    const knownState = this.getOrCreateKnownState(id2);
    knownState.combineOptimisticWith(value);
    this.triggerUpdate(id2, knownState);
  }
  setKnownState(id2, payload) {
    const knownState = this.getOrCreateKnownState(id2);
    knownState.set(payload);
    this.triggerUpdate(id2, knownState);
  }
  /**
   * Emit a change event for a given coValue.
   *
   * This is used to notify subscribers that the known state of a coValue has changed,
   * but the known state of the peer has not.
   */
  emitCoValueChange(id2) {
    if (this.peer.role === "client" && !this.isCoValueSubscribedToPeer(id2)) {
      return;
    }
    const knownState = this.getOrCreateKnownState(id2);
    this.triggerUpdate(id2, knownState);
  }
  triggerUpdate(id2, value) {
    for (const listener of this.listeners) {
      listener(id2, value);
    }
  }
  subscribeToKnownStatesUpdates(listener) {
    this.listeners.add(listener);
    return () => {
      this.listeners.delete(listener);
    };
  }
  get id() {
    return this.peer.id;
  }
  get role() {
    return this.peer.role;
  }
  get priority() {
    return this.peer.priority;
  }
  get incoming() {
    return this.peer.incoming;
  }
  get persistent() {
    return this.peer.persistent;
  }
  pushOutgoingMessage(msg) {
    this.peer.outgoing.push(msg);
  }
  addCloseListener(listener) {
    if (this.closed) {
      listener();
      return () => {
      };
    }
    this.closeListeners.add(listener);
    return () => {
      this.closeListeners.delete(listener);
    };
  }
  emitClose() {
    for (const listener of this.closeListeners) {
      listener();
    }
    this.closeListeners.clear();
  }
  gracefulShutdown() {
    if (this.closed) {
      return;
    }
    logger.debug("Gracefully closing", {
      peerId: this.id,
      peerRole: this.role
    });
    this.closed = true;
    this.loadQueue.clear();
    this.peer.outgoing.push("Disconnected");
    this.peer.outgoing.close();
    this.peer.incoming.close();
    this.emitClose();
  }
}
class SyncStateManager {
  constructor(syncManager) {
    this.syncManager = syncManager;
    this.listeners = /* @__PURE__ */ new Set();
    this.listenersByCoValues = /* @__PURE__ */ new Map();
    this.listenersByPeersAndCoValues = /* @__PURE__ */ new Map();
  }
  subscribeToUpdates(listener) {
    this.listeners.add(listener);
    return () => {
      this.listeners.delete(listener);
    };
  }
  subscribeToCoValueUpdates(coValueId, listener) {
    let listeners = this.listenersByCoValues.get(coValueId);
    if (!listeners) {
      listeners = /* @__PURE__ */ new Set();
      this.listenersByCoValues.set(coValueId, listeners);
    }
    listeners.add(listener);
    return () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        this.listenersByCoValues.delete(coValueId);
      }
    };
  }
  subscribeToPeerUpdates(peerId, coValueId, listener) {
    let peerMap = this.listenersByPeersAndCoValues.get(peerId);
    if (!peerMap) {
      peerMap = /* @__PURE__ */ new Map();
      this.listenersByPeersAndCoValues.set(peerId, peerMap);
    }
    let listeners = peerMap.get(coValueId);
    if (!listeners) {
      listeners = /* @__PURE__ */ new Set();
      peerMap.set(coValueId, listeners);
    }
    listeners.add(listener);
    return () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        peerMap.delete(coValueId);
        if (peerMap.size === 0) {
          this.listenersByPeersAndCoValues.delete(peerId);
        }
      }
    };
  }
  triggerUpdate(peer, id2, knownState) {
    const globalListeners = this.listeners;
    const coValueListeners = this.listenersByCoValues.get(id2);
    const peerMap = this.listenersByPeersAndCoValues.get(peer.id);
    const coValueAndPeerListeners = peerMap?.get(id2);
    if (!globalListeners.size && !coValueListeners?.size && !coValueAndPeerListeners?.size) {
      return;
    }
    const syncState2 = {
      uploaded: this.getIsCoValueFullyUploadedIntoPeer(knownState, id2)
    };
    for (const listener of this.listeners) {
      listener(peer, knownState, syncState2);
    }
    if (coValueListeners) {
      for (const listener of coValueListeners) {
        listener(peer, knownState, syncState2);
      }
    }
    if (coValueAndPeerListeners) {
      for (const listener of coValueAndPeerListeners) {
        listener(knownState, syncState2);
      }
    }
  }
  isSynced(peer, id2) {
    const peerKnownState = peer.getKnownState(id2);
    if (!peerKnownState)
      return false;
    return this.getIsCoValueFullyUploadedIntoPeer(peerKnownState, id2);
  }
  getIsCoValueFullyUploadedIntoPeer(peerKnownState, id2) {
    const entry = this.syncManager.local.getCoValue(id2);
    if (!entry.hasVerifiedContent()) {
      return false;
    }
    const knownState = entry.verified.knownState();
    return areCurrentSessionsInSyncWith(knownState.sessions, peerKnownState.sessions);
  }
}
const ANY_PEER_ID = "any";
let BATCH_DELAY_MS = 200;
class UnsyncedCoValuesTracker {
  constructor() {
    this.unsynced = /* @__PURE__ */ new Map();
    this.coValueListeners = /* @__PURE__ */ new Map();
    this.globalListeners = /* @__PURE__ */ new Set();
    this.pendingUpdates = [];
  }
  /**
   * Add a CoValue as unsynced to a specific peer.
   * Triggers persistence if storage is available.
   * @returns true if the CoValue was already tracked, false otherwise.
   */
  add(id2, peerId = ANY_PEER_ID) {
    if (!this.unsynced.has(id2)) {
      this.unsynced.set(id2, /* @__PURE__ */ new Set());
    }
    const peerSet = this.unsynced.get(id2);
    const alreadyTracked = peerSet.has(peerId);
    if (!alreadyTracked) {
      peerSet.add(peerId);
      this.schedulePersist(id2, peerId, false);
      this.notifyCoValueListeners(id2, false);
      this.notifyGlobalListeners(false);
    }
    return alreadyTracked;
  }
  /**
   * Remove a CoValue from being unsynced to a specific peer.
   * Triggers persistence if storage is available.
   */
  remove(id2, peerId = ANY_PEER_ID) {
    const peerSet = this.unsynced.get(id2);
    if (!peerSet || !peerSet.has(peerId)) {
      return;
    }
    peerSet.delete(peerId);
    if (peerSet.size === 0) {
      this.unsynced.delete(id2);
    }
    this.schedulePersist(id2, peerId, true);
    const isSynced = !this.unsynced.has(id2);
    this.notifyCoValueListeners(id2, isSynced);
    this.notifyGlobalListeners(this.isAllSynced());
  }
  /**
   * Remove all tracking for a CoValue (all peers).
   * Triggers persistence if storage is available.
   */
  removeAll(id2) {
    const peerSet = this.unsynced.get(id2);
    if (!peerSet) {
      return;
    }
    const peersToRemove = Array.from(peerSet);
    for (const peerId of peersToRemove) {
      this.remove(id2, peerId);
    }
  }
  forcePersist() {
    return this.flush();
  }
  schedulePersist(id2, peerId, synced) {
    const storage = this.storage;
    if (!storage) {
      return;
    }
    this.pendingUpdates.push({ id: id2, peerId, synced });
    if (!this.flushTimer) {
      this.flushTimer = setTimeout(() => {
        this.flush();
      }, BATCH_DELAY_MS);
    }
  }
  /**
   * Flush all pending persistence updates in a batch
   */
  flush() {
    if (this.flushTimer) {
      clearTimeout(this.flushTimer);
      this.flushTimer = void 0;
    }
    if (this.pendingUpdates.length === 0) {
      return;
    }
    const storage = this.storage;
    if (!storage) {
      return;
    }
    const filteredUpdates = this.simplifyPendingUpdates(this.pendingUpdates);
    this.pendingUpdates = [];
    return new Promise((resolve2) => {
      try {
        storage.trackCoValuesSyncState(filteredUpdates, () => resolve2());
      } catch (error) {
        logger.warn("Failed to persist batched unsynced CoValue tracking", {
          err: error
        });
        resolve2();
      }
    });
  }
  /**
   * Get all CoValue IDs that have at least one unsynced peer.
   */
  getAll() {
    return Array.from(this.unsynced.keys());
  }
  /**
   * Check if all CoValues are synced
   */
  isAllSynced() {
    return this.unsynced.size === 0;
  }
  /**
   * Check if a specific CoValue is tracked as unsynced.
   */
  has(id2) {
    return this.unsynced.has(id2);
  }
  subscribe(idOrListener, listener) {
    if (typeof idOrListener === "string" && listener) {
      const id2 = idOrListener;
      if (!this.coValueListeners.has(id2)) {
        this.coValueListeners.set(id2, /* @__PURE__ */ new Set());
      }
      this.coValueListeners.get(id2).add(listener);
      const isSynced = !this.unsynced.has(id2);
      listener(isSynced);
      return () => {
        const listeners = this.coValueListeners.get(id2);
        if (listeners) {
          listeners.delete(listener);
          if (listeners.size === 0) {
            this.coValueListeners.delete(id2);
          }
        }
      };
    }
    const globalListener = idOrListener;
    this.globalListeners.add(globalListener);
    globalListener(this.isAllSynced());
    return () => {
      this.globalListeners.delete(globalListener);
    };
  }
  setStorage(storage) {
    this.storage = storage;
  }
  removeStorage() {
    this.storage = void 0;
  }
  /**
   * Notify all listeners for a specific CoValue about sync status change.
   */
  notifyCoValueListeners(id2, synced) {
    const listeners = this.coValueListeners.get(id2);
    if (listeners) {
      for (const listener of listeners) {
        listener(synced);
      }
    }
  }
  /**
   * Notify all global listeners about "all synced" status change.
   */
  notifyGlobalListeners(allSynced) {
    for (const listener of this.globalListeners) {
      listener(allSynced);
    }
  }
  /**
   * Keep only the last update for each (id, peerId) combination
   */
  simplifyPendingUpdates(updates) {
    const latestUpdates = /* @__PURE__ */ new Map();
    for (const update2 of updates) {
      latestUpdates.set(`${update2.id}|${update2.peerId}`, update2);
    }
    return Array.from(latestUpdates.values());
  }
}
class IncomingMessagesQueue {
  constructor(processQueues) {
    this.processQueues = processQueues;
    this.currentQueue = 0;
    this.pullCounter = metrics.getMeter("cojson").createCounter(`jazz.messagequeue.incoming.pulled`, {
      description: "Number of messages pulled from the queue",
      valueType: ValueType.INT,
      unit: "1"
    });
    this.pushCounter = metrics.getMeter("cojson").createCounter(`jazz.messagequeue.incoming.pushed`, {
      description: "Number of messages pushed to the queue",
      valueType: ValueType.INT,
      unit: "1"
    });
    this.pullCounter.add(0, {
      peerRole: "client"
    });
    this.pushCounter.add(0, {
      peerRole: "client"
    });
    this.pullCounter.add(0, {
      peerRole: "server"
    });
    this.pushCounter.add(0, {
      peerRole: "server"
    });
    this.queues = [];
    this.peerToQueue = /* @__PURE__ */ new WeakMap();
  }
  push(msg, peer) {
    const queue = this.peerToQueue.get(peer);
    if (!queue) {
      const newQueue = new LinkedList();
      this.peerToQueue.set(peer, newQueue);
      this.queues.push([newQueue, peer]);
      newQueue.push(msg);
    } else {
      queue.push(msg);
    }
    this.pushCounter.add(1, {
      peerRole: peer.role
    });
    this.processQueues();
  }
  pull() {
    const entry = this.queues[this.currentQueue];
    if (!entry) {
      return void 0;
    }
    const [queue, peer] = entry;
    const msg = queue.shift();
    if (queue.isEmpty()) {
      this.queues.splice(this.currentQueue, 1);
      this.peerToQueue.delete(peer);
    } else {
      this.currentQueue++;
    }
    if (this.currentQueue >= this.queues.length) {
      this.currentQueue = 0;
    }
    if (msg) {
      this.pullCounter.add(1, {
        peerRole: peer.role
      });
      return { msg, peer };
    }
    return void 0;
  }
}
class LocalTransactionsSyncQueue {
  constructor(sync) {
    this.sync = sync;
    this.batch = [];
    this.syncTransaction = (coValue, knownStateBefore) => {
      const lastUpdatedValue = this.lastUpdatedValue;
      const lastUpdatedValueKnownState = this.lastUpdatedValueKnownState;
      if (lastUpdatedValue && lastUpdatedValueKnownState) {
        if (lastUpdatedValue.id === coValue.id) {
          return;
        }
        this.addContentToBatch(lastUpdatedValue, lastUpdatedValueKnownState);
      }
      this.lastUpdatedValue = coValue;
      this.lastUpdatedValueKnownState = knownStateBefore;
      for (const trackingSet of this.dirtyCoValuesTrackingSets) {
        trackingSet.add(coValue.id);
      }
      this.scheduleNextBatch();
    };
    this.nextBatchScheduled = false;
    this.dirtyCoValuesTrackingSets = /* @__PURE__ */ new Set();
    this.trackDirtyCoValues = () => {
      const trackingSet = /* @__PURE__ */ new Set();
      this.dirtyCoValuesTrackingSets.add(trackingSet);
      return {
        done: () => {
          this.dirtyCoValuesTrackingSets.delete(trackingSet);
          return trackingSet;
        }
      };
    };
  }
  addContentToBatch(coValue, knownStateBefore) {
    const content = coValue.newContentSince(knownStateBefore);
    if (!content) {
      return;
    }
    for (const piece of content) {
      this.batch.push(piece);
    }
  }
  scheduleNextBatch() {
    if (this.nextBatchScheduled)
      return;
    this.nextBatchScheduled = true;
    queueMicrotask(() => {
      if (this.lastUpdatedValue && this.lastUpdatedValueKnownState) {
        this.addContentToBatch(this.lastUpdatedValue, this.lastUpdatedValueKnownState);
      }
      const batch = this.batch;
      this.lastUpdatedValue = void 0;
      this.lastUpdatedValueKnownState = void 0;
      this.batch = [];
      this.nextBatchScheduled = false;
      for (const content of batch) {
        this.sync(content);
      }
    });
  }
}
function isPersistentServerPeer(peer) {
  return peer.role === "server" && (peer.persistent ?? false);
}
class SyncManager {
  ignoreUnknownCoValuesFromServers() {
    this._ignoreUnknownCoValuesFromServers = true;
  }
  constructor(local) {
    this.peers = {};
    this.skipVerify = false;
    this._ignoreUnknownCoValuesFromServers = false;
    this.peersCounter = metrics.getMeter("cojson").createUpDownCounter("jazz.peers", {
      description: "Amount of connected peers",
      valueType: ValueType.INT,
      unit: "peer"
    });
    this.messagesQueue = new IncomingMessagesQueue(() => this.processQueues());
    this.processing = false;
    this.syncQueue = new LocalTransactionsSyncQueue((content) => this.syncContent(content));
    this.syncLocalTransaction = this.syncQueue.syncTransaction;
    this.trackDirtyCoValues = this.syncQueue.trackDirtyCoValues;
    this.local = local;
    this.syncState = new SyncStateManager(this);
    this.unsyncedTracker = new UnsyncedCoValuesTracker();
    this.transactionsSizeHistogram = metrics.getMeter("cojson").createHistogram("jazz.transactions.size", {
      description: "The size of transactions in a covalue",
      unit: "bytes",
      valueType: ValueType.INT
    });
  }
  disableTransactionVerification() {
    this.skipVerify = true;
  }
  getPeers(id2) {
    return this.getServerPeers(id2).concat(this.getClientPeers());
  }
  getClientPeers() {
    return Object.values(this.peers).filter((peer) => peer.role === "client");
  }
  getServerPeers(id2, excludePeerId) {
    const serverPeers = Object.values(this.peers).filter((peer) => peer.role === "server" && peer.id !== excludePeerId);
    return this.serverPeerSelector ? this.serverPeerSelector(id2, serverPeers) : serverPeers;
  }
  getPersistentServerPeers(id2) {
    return this.getServerPeers(id2).filter((peer) => peer.persistent);
  }
  handleSyncMessage(msg, peer) {
    if (!isRawCoID(msg.id)) {
      const errorType = msg.id ? "invalid" : "undefined";
      logger.warn(`Received sync message with ${errorType} id`, {
        msg
      });
      return;
    }
    if (peer.role === "server" && this._ignoreUnknownCoValuesFromServers && !this.local.hasCoValue(msg.id)) {
      logger.warn(`Ignoring message ${msg.action} on unknown coValue ${msg.id} from peer ${peer.id}`);
      return;
    }
    if (this.local.getCoValue(msg.id).isErroredInPeer(peer.id)) {
      logger.warn(`Skipping message ${msg.action} on errored coValue ${msg.id} from peer ${peer.id}`);
      return;
    }
    switch (msg.action) {
      case "load":
        return this.handleLoad(msg, peer);
      case "known":
        if (msg.isCorrection) {
          return this.handleCorrection(msg, peer);
        } else {
          return this.handleKnownState(msg, peer);
        }
      case "content":
        return this.handleNewContent(msg, peer);
      case "done":
        return;
      default:
        throw new Error(`Unknown message type ${msg.action}`);
    }
  }
  sendNewContent(id2, peer, seen = /* @__PURE__ */ new Set()) {
    if (seen.has(id2)) {
      return;
    }
    seen.add(id2);
    const coValue = this.local.getCoValue(id2);
    if (!coValue.isAvailable()) {
      return;
    }
    const includeDependencies = peer.role !== "server";
    if (includeDependencies) {
      for (const dependency of coValue.getDependedOnCoValues()) {
        this.sendNewContent(dependency, peer, seen);
      }
    }
    const newContentPieces = coValue.newContentSince(peer.getOptimisticKnownState(id2));
    if (newContentPieces) {
      for (const piece of newContentPieces) {
        this.trySendToPeer(peer, piece);
      }
      peer.combineOptimisticWith(id2, coValue.knownState());
    } else if (!peer.toldKnownState.has(id2)) {
      if (coValue.isDeleted) {
        this.trySendToPeer(peer, coValue.stopSyncingKnownStateMessage(peer.getKnownState(id2)));
      } else {
        this.trySendToPeer(peer, {
          action: "known",
          ...coValue.knownStateWithStreaming()
        });
      }
    }
    peer.trackToldKnownState(id2);
  }
  reconcileServerPeers() {
    const serverPeers = Object.values(this.peers).filter((peer) => peer.role === "server");
    for (const peer of serverPeers) {
      this.startPeerReconciliation(peer);
    }
  }
  async resumeUnsyncedCoValues() {
    if (!this.local.storage) {
      return;
    }
    await new Promise((resolve2, reject) => {
      this.local.storage?.getUnsyncedCoValueIDs((unsyncedCoValueIDs) => {
        const coValuesToLoad = unsyncedCoValueIDs.filter((coValueId) => !this.local.hasCoValue(coValueId));
        if (coValuesToLoad.length === 0) {
          resolve2();
          return;
        }
        const BATCH_SIZE = 10;
        let processed = 0;
        const processBatch = async () => {
          const batch = coValuesToLoad.slice(processed, processed + BATCH_SIZE);
          await Promise.all(batch.map(async (coValueId) => new Promise((resolve3) => {
            try {
              this.local.storage?.stopTrackingSyncState(coValueId);
              this.trackSyncState(coValueId);
              const coValue = this.local.getCoValue(coValueId);
              coValue.loadFromStorage((found) => {
                if (!found) {
                  this.unsyncedTracker.removeAll(coValueId);
                }
                resolve3();
              });
            } catch (error) {
              logger.warn(`Failed to resume sync for CoValue ${coValueId}:`, {
                err: error,
                coValueId
              });
              this.unsyncedTracker.removeAll(coValueId);
              resolve3();
            }
          })));
          processed += batch.length;
          if (processed < coValuesToLoad.length) {
            processBatch().catch(reject);
          } else {
            resolve2();
          }
        };
        processBatch().catch(reject);
      });
    });
  }
  startPeerReconciliation(peer) {
    if (isPersistentServerPeer(peer)) {
      this.resumeUnsyncedCoValues().catch((error) => {
        logger.warn("Failed to resume unsynced CoValues:", error);
      });
    }
    const coValuesOrderedByDependency = [];
    const seen = /* @__PURE__ */ new Set();
    const buildOrderedCoValueList = (coValue) => {
      if (seen.has(coValue.id)) {
        return;
      }
      seen.add(coValue.id);
      if (this.getServerPeers(coValue.id).find((p) => p.id === peer.id) === void 0) {
        return;
      }
      for (const id2 of coValue.getDependedOnCoValues()) {
        const coValue2 = this.local.getCoValue(id2);
        if (coValue2.isAvailable()) {
          buildOrderedCoValueList(coValue2);
        }
      }
      coValuesOrderedByDependency.push(coValue);
    };
    for (const coValue of this.local.allCoValues()) {
      if (coValue.isAvailable()) {
        buildOrderedCoValueList(coValue);
      } else if (coValue.loadingState === "unknown") {
        continue;
      } else if (!peer.loadRequestSent.has(coValue.id)) {
        peer.sendLoadRequest(coValue, "low-priority");
      }
      if (!peer.getKnownState(coValue.id)) {
        peer.setKnownState(coValue.id, "empty");
      }
    }
    for (const coValue of coValuesOrderedByDependency) {
      peer.sendLoadRequest(coValue, "low-priority");
    }
  }
  pushMessage(incoming, peer) {
    this.messagesQueue.push(incoming, peer);
  }
  /**
   * Get the storage streaming queue if available.
   * Returns undefined if storage doesn't have a streaming queue.
   */
  getStorageStreamingQueue() {
    const storage = this.local.storage;
    if (storage && "streamingQueue" in storage) {
      return storage.streamingQueue;
    }
    return void 0;
  }
  /**
   * Unified queue processing that coordinates both incoming messages
   * and storage streaming entries.
   *
   * Processes items from both queues with priority ordering:
   * - Incoming messages are processed via round-robin across peers
   * - Storage streaming entries are processed by priority (MEDIUM before LOW)
   *
   * Implements time budget scheduling to avoid blocking the main thread.
   */
  async processQueues() {
    if (this.processing) {
      return;
    }
    this.processing = true;
    let lastTimer = performance.now();
    const streamingQueue = this.getStorageStreamingQueue();
    while (true) {
      const messageEntry = this.messagesQueue.pull();
      if (messageEntry) {
        try {
          this.handleSyncMessage(messageEntry.msg, messageEntry.peer);
        } catch (err) {
          logger.error("Error processing message", { err });
        }
      }
      const pushStreamingContent = streamingQueue?.pull();
      if (pushStreamingContent) {
        try {
          pushStreamingContent();
        } catch (err) {
          logger.error("Error processing storage streaming entry", {
            err
          });
        }
      }
      if (!messageEntry && !pushStreamingContent) {
        break;
      }
      const currentTimer = performance.now();
      if (currentTimer - lastTimer > SYNC_SCHEDULER_CONFIG.INCOMING_MESSAGES_TIME_BUDGET) {
        await waitForNextTick();
        lastTimer = performance.now();
      }
    }
    this.processing = false;
  }
  addPeer(peer, skipReconciliation = false) {
    const prevPeer = this.peers[peer.id];
    const peerState = prevPeer ? prevPeer.newPeerStateFrom(peer) : new PeerState(peer, void 0);
    this.peers[peer.id] = peerState;
    this.peersCounter.add(1, { role: peer.role });
    const unsubscribeFromKnownStatesUpdates = peerState.subscribeToKnownStatesUpdates((id2, knownState) => {
      this.syncState.triggerUpdate(peer, id2, knownState.value());
    });
    if (!skipReconciliation && peerState.role === "server") {
      this.startPeerReconciliation(peerState);
    }
    peerState.incoming.onMessage((msg) => {
      if (msg === "Disconnected") {
        peerState.gracefulShutdown();
        return;
      }
      this.pushMessage(msg, peerState);
    });
    peerState.addCloseListener(() => {
      unsubscribeFromKnownStatesUpdates();
      this.peersCounter.add(-1, { role: peer.role });
      if (!peer.persistent && this.peers[peer.id] === peerState) {
        this.removePeer(peer.id);
      }
    });
  }
  removePeer(peerId) {
    const peer = this.peers[peerId];
    if (!peer) {
      return;
    }
    if (!peer.closed) {
      peer.gracefulShutdown();
    }
    delete this.peers[peer.id];
  }
  trySendToPeer(peer, msg) {
    return peer.pushOutgoingMessage(msg);
  }
  /**
   * Handles the load message from a peer.
   *
   * Differences with the known state message:
   * - The load message triggers the CoValue loading process on the other peer
   * - The peer known state is stored as-is instead of being merged
   * - The load message always replies with a known state message
   */
  handleLoad(msg, peer) {
    peer.setKnownState(msg.id, knownStateFrom(msg));
    const coValue = this.local.getCoValue(msg.id);
    if (coValue.isAvailable()) {
      this.sendNewContent(msg.id, peer);
      return;
    }
    const peerKnownState = peer.getOptimisticKnownState(msg.id);
    if (!peerKnownState?.header) {
      this.loadFromStorageAndRespond(msg.id, peer, coValue);
      return;
    }
    coValue.getKnownStateFromStorage((storageKnownState) => {
      if (coValue.isAvailable()) {
        this.sendNewContent(msg.id, peer);
        return;
      }
      if (!storageKnownState) {
        this.loadFromPeersAndRespond(msg.id, peer, coValue);
        return;
      }
      if (peerHasAllContent(storageKnownState, peerKnownState)) {
        peer.trackToldKnownState(msg.id);
        this.trySendToPeer(peer, {
          action: "known",
          ...storageKnownState
        });
        return;
      }
      this.loadFromStorageAndRespond(msg.id, peer, coValue);
    });
  }
  /**
   * Helper to load from storage and respond appropriately.
   * Falls back to peers if not found in storage.
   */
  loadFromStorageAndRespond(id2, peer, coValue) {
    coValue.loadFromStorage((found) => {
      if (found && coValue.isAvailable()) {
        this.sendNewContent(id2, peer);
      } else {
        this.loadFromPeersAndRespond(id2, peer, coValue);
      }
    });
  }
  /**
   * Helper to load from peers and respond appropriately.
   */
  loadFromPeersAndRespond(id2, peer, coValue) {
    const peers = this.getServerPeers(id2, peer.id);
    coValue.loadFromPeers(peers);
    const handleLoadResult = () => {
      if (coValue.isAvailable()) {
        this.sendNewContent(id2, peer);
        return;
      }
      this.handleLoadNotFound(id2, peer);
    };
    if (peers.length > 0) {
      coValue.waitForAvailableOrUnavailable().then(handleLoadResult);
    } else {
      handleLoadResult();
    }
  }
  /**
   * Handle case when CoValue is not found.
   */
  handleLoadNotFound(id2, peer) {
    peer.trackToldKnownState(id2);
    this.trySendToPeer(peer, {
      action: "known",
      id: id2,
      header: false,
      sessions: {}
    });
  }
  /**
   * Request full content from a peer when we don't have the CoValue.
   */
  requestFullContent(id2, peer) {
    if (peer) {
      this.trySendToPeer(peer, {
        action: "known",
        isCorrection: true,
        id: id2,
        header: false,
        sessions: {}
      });
    } else {
      logger.error("Received new content with no header on a missing CoValue", {
        id: id2
      });
    }
  }
  handleKnownState(msg, peer) {
    const coValue = this.local.getCoValue(msg.id);
    peer.combineWith(msg.id, knownStateFrom(msg));
    const availableOnPeer = peer.getOptimisticKnownState(msg.id)?.header;
    if (!availableOnPeer) {
      coValue.markNotFoundInPeer(peer.id);
    }
    if (coValue.isAvailable()) {
      this.sendNewContent(msg.id, peer);
    }
    peer.trackLoadRequestComplete(coValue);
  }
  recordTransactionsSize(newTransactions, source) {
    for (const tx of newTransactions) {
      const size = getTransactionSize(tx);
      this.transactionsSizeHistogram.record(size, {
        source
      });
    }
  }
  handleNewContent(msg, from) {
    const coValue = this.local.getCoValue(msg.id);
    const peer = from === "storage" || from === "import" ? void 0 : from;
    const sourceRole = from === "storage" ? "storage" : from === "import" ? "import" : peer?.role;
    if (peer?.role === "client" && msg.expectContentUntil) {
      msg = {
        ...msg,
        expectContentUntil: void 0
      };
    }
    peer?.trackLoadRequestUpdate(coValue);
    coValue.addDependenciesFromContentMessage(msg);
    if (!this.skipVerify && coValue.hasMissingDependencies()) {
      coValue.addNewContentToQueue(msg, from);
      for (const dependency of coValue.missingDependencies) {
        const dependencyCoValue = this.local.getCoValue(dependency);
        if (!dependencyCoValue.hasVerifiedContent()) {
          const peers = this.getServerPeers(dependency);
          if (peer?.role === "client") {
            peers.push(peer);
          }
          dependencyCoValue.load(peers, "immediate");
        }
      }
      return;
    }
    if (!coValue.hasVerifiedContent()) {
      if (!msg.header) {
        if (from === "storage") {
          logger.warn("Received content from storage without header - CoValue may have been garbage collected mid-stream", {
            id: msg.id,
            from
          });
          return;
        }
        coValue.loadFromStorage((found) => {
          if (found) {
            this.handleNewContent(msg, from);
          } else {
            this.requestFullContent(msg.id, peer);
          }
        });
        return;
      }
      const previousState = coValue.loadingState;
      const success = coValue.provideHeader(msg.header, msg.expectContentUntil, this.skipVerify);
      if (!success) {
        logger.error("Failed to provide header", {
          id: msg.id,
          header: msg.header
        });
        return;
      }
      coValue.markFoundInPeer(peer?.id ?? "storage", previousState);
      peer?.updateHeader(msg.id, true);
      if (msg.expectContentUntil) {
        peer?.combineWith(msg.id, {
          id: msg.id,
          header: true,
          sessions: msg.expectContentUntil
        });
      }
    } else if (msg.expectContentUntil) {
      coValue.verified.setStreamingKnownState(msg.expectContentUntil);
    }
    if (!coValue.hasVerifiedContent()) {
      throw new Error("Unreachable: CoValue should always have a verified state at this point");
    }
    let invalidStateAssumed = false;
    const validNewContent = {
      action: "content",
      id: msg.id,
      priority: msg.priority,
      header: msg.header,
      new: {}
    };
    let wasAlreadyDeleted = coValue.isDeleted;
    for (const [sessionID, newContentForSession] of getSessionEntriesFromContentMessage(msg)) {
      if (wasAlreadyDeleted && !isDeleteSessionID(sessionID)) {
        continue;
      }
      const newTransactions = getNewTransactionsFromContentMessage(newContentForSession, coValue.knownState(), sessionID);
      if (newTransactions === void 0) {
        invalidStateAssumed = true;
        continue;
      }
      if (newTransactions.length === 0) {
        continue;
      }
      const error = coValue.tryAddTransactions(sessionID, newTransactions, newContentForSession.lastSignature, this.skipVerify);
      if (error) {
        if (peer) {
          logger.error("Failed to add transactions", {
            peerId: peer.id,
            peerRole: peer.role,
            id: msg.id,
            errorType: error.type,
            err: error.error,
            sessionID,
            msgKnownState: knownStateFromContent(msg).sessions,
            msgSummary: getContenDebugInfo(msg),
            knownState: coValue.knownState().sessions
          });
          coValue.markErrored(peer.id, error);
        } else {
          logger.error("Failed to add transactions from storage", {
            id: msg.id,
            err: error.error,
            sessionID,
            errorType: error.type
          });
        }
        continue;
      }
      if (sourceRole && sourceRole !== "import") {
        this.recordTransactionsSize(newTransactions, sourceRole);
      }
      if (!wasAlreadyDeleted && coValue.isDeleted) {
        wasAlreadyDeleted = true;
        validNewContent.new = {};
      }
      validNewContent.new[sessionID] = newContentForSession;
    }
    if (peer) {
      if (coValue.isDeleted) {
        peer.combineWith(msg.id, knownStateFromContent(msg));
      } else {
        peer.combineWith(msg.id, knownStateFromContent(validNewContent));
      }
    }
    if (invalidStateAssumed) {
      if (peer) {
        this.trySendToPeer(peer, {
          action: "known",
          isCorrection: true,
          ...coValue.knownState()
        });
        peer.trackToldKnownState(msg.id);
      } else {
        logger.error("Invalid state assumed when handling new content from storage", {
          id: msg.id,
          content: getContenDebugInfo(msg),
          knownState: coValue.knownState()
        });
      }
    } else if (peer) {
      if (coValue.isDeleted) {
        this.trySendToPeer(peer, coValue.stopSyncingKnownStateMessage(peer.getKnownState(msg.id)));
      } else {
        this.trySendToPeer(peer, {
          action: "known",
          ...coValue.knownState()
        });
      }
      peer.trackToldKnownState(msg.id);
    }
    const hasNewContent = validNewContent.header || Object.keys(validNewContent.new).length > 0;
    if (from !== "storage" && hasNewContent) {
      this.storeContent(validNewContent);
      if (from === "import") {
        this.trackSyncState(coValue.id);
      }
    }
    peer?.trackLoadRequestComplete(coValue);
    for (const peer2 of this.getPeers(coValue.id)) {
      if (peer2.closed || coValue.isErroredInPeer(peer2.id)) {
        peer2.emitCoValueChange(coValue.id);
        continue;
      }
      if (peer2.isCoValueSubscribedToPeer(coValue.id)) {
        this.sendNewContent(coValue.id, peer2);
      } else if (peer2.role === "server") {
        peer2.sendLoadRequest(coValue);
      }
    }
  }
  handleCorrection(msg, peer) {
    peer.setKnownState(msg.id, knownStateFrom(msg));
    return this.sendNewContent(msg.id, peer);
  }
  syncContent(content) {
    const coValue = this.local.getCoValue(content.id);
    this.storeContent(content);
    this.trackSyncState(coValue.id);
    const contentKnownState = knownStateFromContent(content);
    for (const peer of this.getPeers(coValue.id)) {
      if (peer.role === "client" && !peer.isCoValueSubscribedToPeer(coValue.id)) {
        continue;
      }
      if (peer.closed || coValue.isErroredInPeer(peer.id)) {
        peer.emitCoValueChange(content.id);
        continue;
      }
      this.trySendToPeer(peer, content);
      peer.combineOptimisticWith(coValue.id, contentKnownState);
      peer.trackToldKnownState(coValue.id);
    }
  }
  trackSyncState(coValueId) {
    const peers = this.getPersistentServerPeers(coValueId);
    const isSyncRequired = this.local.syncWhen !== "never";
    if (isSyncRequired && peers.length === 0) {
      this.unsyncedTracker.add(coValueId);
      const unsubscribe = this.syncState.subscribeToCoValueUpdates(coValueId, (peer, _knownState, syncState2) => {
        if (isPersistentServerPeer(peer) && syncState2.uploaded) {
          this.unsyncedTracker.remove(coValueId);
          unsubscribe();
        }
      });
      return;
    }
    for (const peer of peers) {
      if (this.syncState.isSynced(peer, coValueId)) {
        continue;
      }
      const alreadyTracked = this.unsyncedTracker.add(coValueId, peer.id);
      if (alreadyTracked) {
        continue;
      }
      const unsubscribe = this.syncState.subscribeToPeerUpdates(peer.id, coValueId, (_knownState, syncState2) => {
        if (syncState2.uploaded) {
          this.unsyncedTracker.remove(coValueId, peer.id);
          unsubscribe();
        }
      });
    }
  }
  storeContent(content) {
    const storage = this.local.storage;
    if (!storage)
      return;
    const value = this.local.getCoValue(content.id);
    if (value.isDeleted) {
      storage.markDeleteAsValid(value.id);
    }
    storage.store(content, (correction) => {
      if (!value.verified) {
        logger.error("Correction requested for a CoValue with no verified content", {
          id: content.id,
          content: getContenDebugInfo(content),
          correction,
          state: value.loadingState
        });
        return void 0;
      }
      return value.newContentSince(correction);
    });
  }
  /**
   * Returns true if the local CoValue changes have been synced to all persistent server peers.
   *
   * Used during garbage collection to determine if the coValue is pending sync.
   */
  isSyncedToServerPeers(id2) {
    return this.getPersistentServerPeers(id2).every((peer) => this.syncState.isSynced(peer, id2));
  }
  waitForSyncWithPeer(peerId, id2, timeout) {
    const peerState = this.peers[peerId];
    if (!peerState) {
      return;
    }
    if (peerState.isCoValueSubscribedToPeer(id2)) {
      const isAlreadySynced = this.syncState.isSynced(peerState, id2);
      if (isAlreadySynced) {
        return;
      }
    } else if (peerState.role === "client") {
      return;
    }
    return new Promise((resolve2, reject) => {
      const unsubscribe = this.syncState.subscribeToPeerUpdates(peerId, id2, (_knownState, syncState2) => {
        if (syncState2.uploaded) {
          resolve2(true);
          unsubscribe?.();
          clearTimeout(timeoutId);
        }
      });
      const timeoutId = setTimeout(() => {
        const coValue = this.local.getCoValue(id2);
        const erroredInPeer = coValue.getErroredInPeerError(peerId);
        const knownState = coValue.knownState().sessions;
        const peerKnownState = peerState.getKnownState(id2)?.sessions ?? {};
        let errorMessage = `Timeout on waiting for sync with peer ${peerId} for coValue ${id2}:
  Known state: ${JSON.stringify(knownState)}
  Peer state: ${JSON.stringify(peerKnownState)}
`;
        if (erroredInPeer) {
          errorMessage += `
Marked as errored: "${erroredInPeer}"`;
        }
        reject(new Error(errorMessage));
        unsubscribe?.();
      }, timeout);
    });
  }
  waitForStorageSync(id2) {
    return this.local.storage?.waitForSync(id2, this.local.getCoValue(id2));
  }
  waitForSync(id2, timeout = 6e4) {
    const peers = this.getPeers(id2);
    return Promise.all(peers.map((peer) => this.waitForSyncWithPeer(peer.id, id2, timeout)).concat(this.waitForStorageSync(id2)));
  }
  waitForAllCoValuesSync(timeout = 6e4) {
    const coValues = this.local.allCoValues();
    const validCoValues = Array.from(coValues).filter((coValue) => coValue.loadingState === "available" || coValue.loadingState === "loading");
    return Promise.all(validCoValues.map((coValue) => this.waitForSync(coValue.id, timeout)));
  }
  setStorage(storage) {
    this.unsyncedTracker.setStorage(storage);
    const storageStreamingQueue = this.getStorageStreamingQueue();
    if (storageStreamingQueue) {
      storageStreamingQueue.setListener(() => {
        this.processQueues();
      });
    }
  }
  removeStorage() {
    this.unsyncedTracker.removeStorage();
  }
  /**
   * Closes all the peer connections and ensures the list of unsynced coValues is persisted to storage.
   * @returns Promise of the current pending store operation, if any.
   */
  gracefulShutdown() {
    for (const peer of Object.values(this.peers)) {
      peer.gracefulShutdown();
    }
    return this.unsyncedTracker.forcePersist();
  }
}
let waitForNextTick = () => new Promise((resolve2) => queueMicrotask(resolve2));
if (typeof setImmediate === "function") {
  waitForNextTick = () => new Promise((resolve2) => setImmediate(resolve2));
}
function connectedPeers(peer1id, peer2id, { peer1role = "client", peer2role = "client", persistent = false } = {}) {
  const from1to2 = new ConnectedPeerChannel$1();
  const from2to1 = new ConnectedPeerChannel$1();
  const peer2AsPeer = {
    id: peer2id,
    incoming: from2to1,
    outgoing: from1to2,
    role: peer2role,
    persistent
  };
  const peer1AsPeer = {
    id: peer1id,
    incoming: from1to2,
    outgoing: from2to1,
    role: peer1role,
    persistent
  };
  return [peer1AsPeer, peer2AsPeer];
}
let ConnectedPeerChannel$1 = class ConnectedPeerChannel {
  constructor() {
    this.buffer = [];
    this.listeners = /* @__PURE__ */ new Set();
    this.closed = false;
    this.closeListeners = /* @__PURE__ */ new Set();
  }
  push(msg) {
    if (!this.listeners.size) {
      this.buffer.push(msg);
      return;
    }
    for (const listener of this.listeners) {
      listener(msg);
    }
  }
  close() {
    this.closed = true;
    for (const listener of this.closeListeners) {
      listener();
    }
    this.closeListeners.clear();
    this.listeners.clear();
  }
  onMessage(callback) {
    if (this.buffer.length) {
      for (const msg of this.buffer) {
        callback(msg);
      }
      this.buffer = [];
    }
    this.listeners.add(callback);
  }
  onClose(callback) {
    this.closeListeners.add(callback);
  }
};
class LocalNode {
  /** @category 3. Low-level */
  constructor(agentSecret, currentSessionID, crypto2, syncWhen) {
    this.syncWhen = syncWhen;
    this.coValues = /* @__PURE__ */ new Map();
    this.syncManager = new SyncManager(this);
    this.garbageCollector = void 0;
    this.crashed = void 0;
    this.agentSecret = agentSecret;
    this.currentSessionID = currentSessionID;
    this.crypto = crypto2;
  }
  enableGarbageCollector() {
    if (this.garbageCollector) {
      return;
    }
    this.garbageCollector = new GarbageCollector(this);
  }
  setStorage(storage) {
    this.storage = storage;
    this.syncManager.setStorage(storage);
  }
  removeStorage() {
    this.storage?.close();
    this.storage = void 0;
    this.syncManager.removeStorage();
  }
  /**
   * Enable background erasure of deleted coValues (space reclamation).
   *
   * Deleted coValues are immediately blocked from syncing via tombstones; this feature
   * only reclaims local storage space by deleting historical content while preserving
   * the tombstone (header + delete session).
   *
   * This is opt-in and affects only the currently configured storage (if any)
   *
   * @category 3. Low-level
   */
  enableDeletedCoValuesErasure() {
    this.storage?.enableDeletedCoValuesErasure();
  }
  hasCoValue(id2) {
    const coValue = this.coValues.get(id2);
    if (!coValue) {
      return false;
    }
    const state = coValue.loadingState;
    return state !== "unknown" && state !== "garbageCollected" && state !== "onlyKnownState";
  }
  getCoValue(id2) {
    let entry = this.coValues.get(id2);
    if (!entry) {
      entry = new CoValueCore(id2, this);
      this.coValues.set(id2, entry);
    }
    this.garbageCollector?.trackCoValueAccess(entry);
    return entry;
  }
  allCoValues() {
    return this.coValues.values();
  }
  /**
   * Simple delete of a CoValue from memory.
   * Used for testing and forced cleanup scenarios.
   * @internal
   */
  internalDeleteCoValue(id2) {
    this.coValues.delete(id2);
    this.storage?.onCoValueUnmounted(id2);
  }
  /**
   * Unmount a CoValue from memory, keeping a shell with cached knownState.
   * This enables accurate LOAD requests during peer reconciliation.
   *
   * @returns true if the coValue was successfully unmounted, false otherwise
   */
  internalUnmountCoValue(id2) {
    const coValue = this.coValues.get(id2);
    if (!coValue) {
      return false;
    }
    if (coValue.listeners.size > 0) {
      return false;
    }
    for (const dependant of coValue.dependant) {
      if (this.hasCoValue(dependant)) {
        return false;
      }
    }
    if (!this.syncManager.isSyncedToServerPeers(id2)) {
      return false;
    }
    const lastKnownState = coValue.knownState();
    coValue.decrementLoadingStateCounter();
    const shell = new CoValueCore(id2, this);
    shell.setGarbageCollectedState(lastKnownState);
    this.coValues.set(id2, shell);
    this.storage?.onCoValueUnmounted(id2);
    return true;
  }
  getCurrentAccountOrAgentID() {
    return accountOrAgentIDfromSessionID(this.currentSessionID);
  }
  getCurrentAgent() {
    if (!this._cachedCurrentAgent) {
      const accountOrAgent = this.getCurrentAccountOrAgentID();
      if (isAgentID(accountOrAgent)) {
        this._cachedCurrentAgent = new ControlledAgent(this.agentSecret, this.crypto);
      } else {
        this._cachedCurrentAgent = new ControlledAccount(expectAccount(this.expectCoValueLoaded(accountOrAgent).getCurrentContent()), this.agentSecret);
      }
    }
    return this._cachedCurrentAgent;
  }
  expectCurrentAccountID(reason) {
    const accountOrAgent = this.getCurrentAccountOrAgentID();
    if (isAgentID(accountOrAgent)) {
      throw new Error("Current account is an agent, but expected an account: " + reason);
    }
    return accountOrAgent;
  }
  expectCurrentAccount(reason) {
    const accountID = this.expectCurrentAccountID(reason);
    return expectAccount(this.expectCoValueLoaded(accountID).getCurrentContent());
  }
  static internalCreateAccount(opts) {
    const { crypto: crypto2, initialAgentSecret = crypto2.newRandomAgentSecret(), peers = [], syncWhen } = opts;
    const accountHeader = accountHeaderForInitialAgentSecret$1(initialAgentSecret, crypto2);
    const accountID = idforHeader$1(accountHeader, crypto2);
    const node = new LocalNode(initialAgentSecret, crypto2.newRandomSessionID(accountID), crypto2, syncWhen);
    if (opts.storage) {
      node.setStorage(opts.storage);
    }
    for (const peer of peers) {
      node.syncManager.addPeer(peer);
    }
    const accountAgentID = crypto2.getAgentID(initialAgentSecret);
    const rawAccount = expectGroup(node.createCoValue(accountHeader).getCurrentContent());
    rawAccount.set(accountAgentID, "admin", "trusting");
    const readKey = crypto2.newRandomKeySecret();
    const sealed = crypto2.seal({
      message: readKey.secret,
      from: crypto2.getAgentSealerSecret(initialAgentSecret),
      to: crypto2.getAgentSealerID(accountAgentID),
      nOnceMaterial: {
        in: rawAccount.id,
        tx: rawAccount.core.nextTransactionID()
      }
    });
    rawAccount.set(`${readKey.id}_for_${accountAgentID}`, sealed, "trusting");
    rawAccount.set("readKey", readKey.id, "trusting");
    return node.expectCurrentAccount("after creation");
  }
  /** @category 2. Node Creation */
  static async withNewlyCreatedAccount({ creationProps, peers, syncWhen, migration, crypto: crypto2, initialAgentSecret = crypto2.newRandomAgentSecret(), storage }) {
    const account = LocalNode.internalCreateAccount({
      crypto: crypto2,
      initialAgentSecret,
      peers,
      syncWhen,
      storage
    });
    const node = account.core.node;
    if (migration) {
      await migration(account, node, creationProps);
    } else {
      const profileGroup = node.createGroup();
      profileGroup.addMember("everyone", "reader");
      const profile = profileGroup.createMap({
        name: creationProps.name
      });
      account.set("profile", profile.id, "trusting");
    }
    const profileId = account.get("profile");
    if (!profileId) {
      throw new Error("Must set account profile in initial migration");
    }
    if (node.storage) {
      await Promise.all([
        node.syncManager.waitForStorageSync(account.id),
        node.syncManager.waitForStorageSync(profileId)
      ]);
    }
    return {
      node,
      accountID: account.id,
      accountSecret: initialAgentSecret,
      sessionID: node.currentSessionID
    };
  }
  /** @category 2. Node Creation */
  static async withLoadedAccount({ accountID, accountSecret, sessionID, peers, syncWhen, crypto: crypto2, migration, storage }) {
    try {
      const expectedAgentID = crypto2.getAgentID(accountSecret);
      const node = new LocalNode(accountSecret, sessionID || crypto2.newRandomSessionID(accountID), crypto2, syncWhen);
      if (storage) {
        node.setStorage(storage);
      }
      for (const peer of peers) {
        node.syncManager.addPeer(peer);
      }
      const account = await node.load(accountID);
      if (account === "unavailable") {
        throw new Error("Account unavailable from all peers");
      }
      if (account.currentAgentID() !== expectedAgentID) {
        throw new Error("Account secret does not match expected agent ID in account");
      }
      const profileID = account.get("profile");
      if (!profileID) {
        throw new Error("Account has no profile");
      }
      const rootID = account.get("root");
      if (rootID) {
        const rawEntry = account.getRaw("root");
        if (!rawEntry?.trusting) {
          account.set("root", rootID, "trusting");
        }
      }
      await node.load(profileID);
      if (migration) {
        await migration(account, node);
      }
      return node;
    } catch (e) {
      logger.error("Error withLoadedAccount", { err: e });
      throw e;
    }
  }
  /** @internal */
  createCoValue(header) {
    if (this.crashed) {
      throw new Error("Trying to create CoValue after node has crashed", {
        cause: this.crashed
      });
    }
    const id2 = idforHeader$1(header, this.crypto);
    const coValue = this.getCoValue(id2);
    coValue.provideHeader(header);
    if (!coValue.hasVerifiedContent()) {
      throw new Error("CoValue not available after providing header");
    }
    this.garbageCollector?.trackCoValueAccess(coValue);
    this.syncManager.syncLocalTransaction(coValue.verified, emptyKnownState(id2));
    return coValue;
  }
  /** @internal */
  async loadCoValueCore(id2, skipLoadingFromPeer, skipRetry) {
    if (!isRawCoID(id2)) {
      throw new TypeError(`Trying to load CoValue with invalid id ${Array.isArray(id2) ? JSON.stringify(id2) : id2}`);
    }
    if (this.crashed) {
      throw new Error("Trying to load CoValue after node has crashed", {
        cause: this.crashed
      });
    }
    let retries = 0;
    while (true) {
      const coValue = this.getCoValue(id2);
      if (coValue.isAvailable()) {
        return coValue;
      }
      if (coValue.loadingState === "unknown" || coValue.loadingState === "unavailable" || coValue.loadingState === "garbageCollected" || coValue.loadingState === "onlyKnownState") {
        const peers = this.syncManager.getServerPeers(id2, skipLoadingFromPeer);
        if (!this.storage && peers.length === 0) {
          coValue.markNotFoundInPeer("storage");
          return coValue;
        }
        coValue.load(peers);
      }
      const result = await coValue.waitForAvailableOrUnavailable();
      if (result.isAvailable() || skipRetry || retries >= CO_VALUE_LOADING_CONFIG.MAX_RETRIES) {
        return result;
      }
      await Promise.race([
        new Promise((resolve2) => setTimeout(resolve2, CO_VALUE_LOADING_CONFIG.RETRY_DELAY)),
        coValue.waitForAvailable()
        // Stop waiting if the coValue becomes available
      ]);
      retries++;
    }
  }
  /**
   * Loads a CoValue's content, syncing from peers as necessary and resolving the returned
   * promise once a first version has been loaded. See `coValue.subscribe()` and `node.useTelepathicData()`
   * for listening to subsequent updates to the CoValue.
   *
   * @category 3. Low-level
   */
  async load(id2, skipRetry) {
    const core2 = await this.loadCoValueCore(id2, void 0, skipRetry);
    if (!core2.isAvailable()) {
      return "unavailable";
    }
    return core2.getCurrentContent();
  }
  /**
   * Loads a branch from a group coValue, creating a new one if it doesn't exist.
   *
   * Returns "unavailable" in case of errors or missing source.
   */
  async checkoutBranch(id2, branchName, branchOwnerID) {
    const source = await this.loadCoValueCore(id2);
    if (!source.isAvailable()) {
      return "unavailable";
    }
    if (!canBeBranched(source)) {
      return source.getCurrentContent();
    }
    const branch = source.getBranch(branchName, branchOwnerID);
    if (branch.isAvailable()) {
      return branch.getCurrentContent();
    }
    if (!source.hasBranch(branchName, branchOwnerID)) {
      return source.createBranch(branchName, branchOwnerID).getCurrentContent();
    }
    await this.loadCoValueCore(branch.id);
    if (!branch.isAvailable()) {
      return source.createBranch(branchName, branchOwnerID).getCurrentContent();
    }
    return branch.getCurrentContent();
  }
  getLoaded(id2) {
    const coValue = this.getCoValue(id2);
    if (coValue.isAvailable()) {
      return coValue.getCurrentContent();
    }
    return void 0;
  }
  /** @category 3. Low-level */
  subscribe(id2, callback, skipRetry) {
    let stopped = false;
    let unsubscribe;
    this.load(id2, skipRetry).then((coValue) => {
      if (stopped) {
        return;
      }
      if (coValue === "unavailable") {
        callback("unavailable");
        return;
      }
      unsubscribe = coValue.subscribe(callback);
    }).catch((e) => {
      logger.error("Subscription error", {
        id: id2,
        err: e
      });
    });
    return () => {
      stopped = true;
      unsubscribe?.();
    };
  }
  async acceptInvite(groupOrOwnedValueID, inviteSecret) {
    const value = await this.load(groupOrOwnedValueID);
    if (value === "unavailable") {
      throw new Error("Trying to accept invite: Group/owned value unavailable from all peers");
    }
    const ruleset = value.core.verified.header.ruleset;
    let group;
    if (ruleset.type === "unsafeAllowAll") {
      throw new Error("Can only accept invites to values owned by groups");
    }
    if (ruleset.type === "ownedByGroup") {
      const owner = await this.load(ruleset.group);
      if (owner === "unavailable") {
        throw new Error("Trying to accept invite: CoValue owner unavailable from all peers");
      }
      group = expectGroup(owner);
    } else {
      group = expectGroup(value);
    }
    if (group.core.verified.header.meta?.type === "account") {
      throw new Error("Can't accept invites to values owned by accounts");
    }
    const inviteAgentSecret = this.crypto.agentSecretFromSecretSeed(secretSeedFromInviteSecret(inviteSecret));
    const inviteAgentID = this.crypto.getAgentID(inviteAgentSecret);
    const inviteRole = await new Promise((resolve2, reject) => {
      group.subscribe((groupUpdate) => {
        const role = groupUpdate.get(inviteAgentID);
        if (role) {
          resolve2(role);
        }
      });
      setTimeout(() => reject(new Error("Couldn't find invite before timeout")), 2e3);
    });
    if (!inviteRole) {
      throw new Error("No invite found");
    }
    const account = this.getCurrentAgent();
    const existingRole = group.get(account.id);
    if (existingRole === "admin" || existingRole === "writer" && inviteRole === "writerInvite" || existingRole === "writer" && inviteRole === "reader" || existingRole === "reader" && inviteRole === "readerInvite" || existingRole && inviteRole === "writeOnlyInvite") {
      logger.debug("Not accepting invite that would replace or downgrade role");
      return;
    }
    const groupCoreAsDifferentAgent = await this.loadCoValueAsDifferentAgent(group.id, inviteAgentSecret);
    const groupAsInvite = expectGroup(groupCoreAsDifferentAgent.getCurrentContent());
    groupAsInvite.addMemberInternal(account, inviteRole === "adminInvite" ? "admin" : inviteRole === "managerInvite" ? "manager" : inviteRole === "writerInvite" ? "writer" : inviteRole === "writeOnlyInvite" ? "writeOnly" : "reader");
    const contentPieces = groupAsInvite.core.newContentSince(group.core.knownState()) ?? [];
    for (const contentPiece of contentPieces) {
      this.syncManager.handleNewContent(contentPiece, "import");
    }
  }
  /** @internal */
  expectCoValueLoaded(id2, expectation) {
    const coValue = this.getCoValue(id2);
    if (!coValue.isAvailable()) {
      throw new Error(`${expectation ? expectation + ": " : ""}CoValue ${id2} not yet loaded.`);
    }
    return coValue;
  }
  /** @internal */
  expectProfileLoaded(id2, expectation) {
    const account = this.expectCoValueLoaded(id2, expectation);
    const profileID = expectGroup(account.getCurrentContent()).get("profile");
    if (!profileID) {
      throw new Error(`${expectation ? expectation + ": " : ""}Account ${id2} has no profile`);
    }
    return this.expectCoValueLoaded(profileID, expectation).getCurrentContent();
  }
  /** @internal */
  resolveAccountAgent(id2, expectation) {
    if (isAgentID(id2)) {
      return { value: id2, error: void 0 };
    }
    let coValue;
    try {
      coValue = this.expectCoValueLoaded(id2, expectation);
    } catch (e) {
      return { value: void 0, error: e };
    }
    if (coValue.verified.header.type !== "comap" || coValue.verified.header.ruleset.type !== "group" || !coValue.verified.header.meta || !("type" in coValue.verified.header.meta) || coValue.verified.header.meta.type !== "account") {
      return {
        value: void 0,
        error: new Error(`Unexpectedly not account: ${expectation}`)
      };
    }
    const agentId = coValue.verified.header.ruleset.initialAdmin;
    if (!isAgentID(agentId)) {
      return {
        value: void 0,
        error: new Error(`Unexpectedly not account: ${expectation}`)
      };
    }
    return { value: agentId, error: void 0 };
  }
  createGroup(uniqueness = this.crypto.createdNowUnique()) {
    const account = this.getCurrentAgent();
    const groupCoValue = this.createCoValue({
      type: "comap",
      ruleset: { type: "group", initialAdmin: account.id },
      meta: null,
      ...uniqueness.createdAt !== void 0 ? { createdAt: uniqueness.createdAt } : {},
      uniqueness: uniqueness.uniqueness
    });
    const group = expectGroup(groupCoValue.getCurrentContent());
    group.set(account.id, "admin", "trusting");
    const readKey = this.crypto.newRandomKeySecret();
    group.set(`${readKey.id}_for_${account.id}`, this.crypto.seal({
      message: readKey.secret,
      from: account.currentSealerSecret(),
      to: account.currentSealerID(),
      nOnceMaterial: {
        in: groupCoValue.id,
        tx: groupCoValue.nextTransactionID()
      }
    }), "trusting");
    group.set("readKey", readKey.id, "trusting");
    return group;
  }
  async loadCoValueAsDifferentAgent(id2, secret, accountId) {
    const agent = new ControlledAgent(secret, this.crypto);
    const newNode = new LocalNode(secret, this.crypto.newRandomSessionID(accountId || agent.id), this.crypto);
    await newNode.loadVerifiedStateFrom(this, id2);
    return newNode.expectCoValueLoaded(id2);
  }
  /** @internal */
  async loadVerifiedStateFrom(otherNode, id2) {
    const connection = connectedPeers("source-" + id2, "target-" + id2, {
      peer1role: "server",
      peer2role: "client"
    });
    this.syncManager.addPeer(connection[0], true);
    otherNode.syncManager.addPeer(connection[1], true);
    const coValue = this.getCoValue(id2);
    const peerState = this.syncManager.peers[connection[0].id];
    if (!peerState) {
      throw new Error("Peer state not found");
    }
    coValue.loadFromPeers([peerState]);
    await coValue.waitForAvailable();
    peerState.gracefulShutdown();
  }
  /**
   * Closes all the peer connections, drains all the queues and closes the storage.
   *
   * @returns Promise of the current pending store operation, if any.
   */
  async gracefulShutdown() {
    this.garbageCollector?.stop();
    await this.syncManager.gracefulShutdown();
    return this.storage?.close();
  }
}
function collectNewTxs({ newTxsInSession, contentMessage, sessionRow, firstNewTxIdx, signature }) {
  let sessionEntry = contentMessage.new[sessionRow.sessionID];
  if (!sessionEntry) {
    sessionEntry = {
      after: firstNewTxIdx,
      lastSignature: signature,
      newTransactions: []
    };
    contentMessage.new[sessionRow.sessionID] = sessionEntry;
  } else {
    sessionEntry.lastSignature = signature;
  }
  for (const tx of newTxsInSession) {
    sessionEntry.newTransactions.push(tx.tx);
  }
}
function getDependedOnCoValues(header, contentMessage) {
  const id2 = contentMessage.id;
  const sessionIDs = Object.keys(contentMessage.new);
  const transactions = Object.values(contentMessage.new).map((entry) => entry.newTransactions);
  return getDependedOnCoValuesFromRawData(id2, header, sessionIDs, transactions);
}
function getNewTransactionsSize(newTxs) {
  return newTxs.reduce((sum, tx) => sum + getTransactionSize(tx), 0);
}
const PRIORITY_TO_QUEUE_INDEX = {
  [CO_VALUE_PRIORITY$1.HIGH]: 0,
  [CO_VALUE_PRIORITY$1.MEDIUM]: 1,
  [CO_VALUE_PRIORITY$1.LOW]: 2
};
class PriorityBasedMessageQueue {
  constructor(defaultPriority, type2, attrs) {
    this.defaultPriority = defaultPriority;
    this.queues = [
      meteredList(type2, { priority: CO_VALUE_PRIORITY$1.HIGH, ...attrs }),
      meteredList(type2, { priority: CO_VALUE_PRIORITY$1.MEDIUM, ...attrs }),
      meteredList(type2, { priority: CO_VALUE_PRIORITY$1.LOW, ...attrs })
    ];
  }
  getQueue(priority) {
    return this.queues[PRIORITY_TO_QUEUE_INDEX[priority]];
  }
  push(msg) {
    const priority = "priority" in msg ? msg.priority : this.defaultPriority;
    this.getQueue(priority).push(msg);
  }
  pull() {
    const priority = this.queues.findIndex((queue) => queue.length > 0);
    return this.queues[priority]?.shift();
  }
}
var DeletedCoValueDeletionStatus;
(function(DeletedCoValueDeletionStatus2) {
  DeletedCoValueDeletionStatus2[DeletedCoValueDeletionStatus2["Pending"] = 0] = "Pending";
  DeletedCoValueDeletionStatus2[DeletedCoValueDeletionStatus2["Done"] = 1] = "Done";
})(DeletedCoValueDeletionStatus || (DeletedCoValueDeletionStatus = {}));
class StorageKnownState {
  constructor() {
    this.knownStates = /* @__PURE__ */ new Map();
    this.waitForSyncRequests = /* @__PURE__ */ new Map();
  }
  getKnownState(id2) {
    const knownState = this.knownStates.get(id2);
    if (!knownState) {
      const empty = emptyKnownState(id2);
      this.knownStates.set(id2, empty);
      return empty;
    }
    return knownState;
  }
  /**
   * Get a cached knownState if it exists and has a header.
   * Unlike getKnownState, this doesn't create an empty state if one doesn't exist.
   */
  getCachedKnownState(id2) {
    const knownState = this.knownStates.get(id2);
    if (knownState?.header) {
      return knownState;
    }
    return void 0;
  }
  setKnownState(id2, knownState) {
    this.knownStates.set(id2, knownState);
  }
  handleUpdate(id2, knownState) {
    const requests = this.waitForSyncRequests.get(id2);
    if (!requests) {
      return;
    }
    for (const request of requests) {
      if (isInSync(request.knownState, knownState)) {
        request.resolve();
        requests.delete(request);
      }
    }
  }
  waitForSync(id2, coValue) {
    const initialKnownState = coValue.knownState();
    if (isInSync(initialKnownState, this.getKnownState(id2))) {
      return Promise.resolve();
    }
    const requests = this.waitForSyncRequests.get(id2) || /* @__PURE__ */ new Set();
    this.waitForSyncRequests.set(id2, requests);
    return new Promise((resolve2) => {
      const unsubscribe = coValue.subscribe((coValue2) => {
        req.knownState = coValue2.knownState();
        this.handleUpdate(id2, this.getKnownState(id2));
      }, false);
      const handleResolve = () => {
        resolve2();
        unsubscribe();
      };
      const req = { knownState: initialKnownState, resolve: handleResolve };
      requests.add(req);
    });
  }
}
function isInSync(knownState, knownStateFromStorage) {
  if (!knownStateFromStorage.header && knownState.header) {
    return false;
  }
  return areCurrentSessionsInSyncWith(knownState.sessions, knownStateFromStorage.sessions);
}
const DEFAULT_DELETE_SCHEDULE_OPTS = {
  throttleMs: 6e4,
  startupDelayMs: 1e3,
  followUpDelayMs: 1e3
};
class DeletedCoValuesEraserScheduler {
  isDisposed() {
    return this.state === "disposed";
  }
  constructor({ run, opts }) {
    this.state = "idle";
    this.runCallback = run;
    this.opts = opts || DEFAULT_DELETE_SCHEDULE_OPTS;
  }
  scheduleStartupDrain() {
    if (this.isDisposed())
      return;
    if (this.state !== "idle")
      return;
    this.scheduleTimer("startup_scheduled", this.opts.startupDelayMs);
  }
  onEnqueueDeletedCoValue() {
    if (this.isDisposed())
      return;
    if (this.state !== "idle")
      return;
    this.scheduleTimer("throttle_scheduled", this.opts.throttleMs);
  }
  dispose() {
    if (this.isDisposed())
      return;
    this.state = "disposed";
    if (this.scheduledTimeout)
      clearTimeout(this.scheduledTimeout);
    this.scheduledTimeout = void 0;
  }
  scheduleTimer(state, delayMs) {
    if (this.isDisposed())
      return;
    if (this.scheduledTimeout)
      return;
    this.state = state;
    this.scheduledTimeout = setTimeout(() => {
      this.scheduledTimeout = void 0;
      void this.run();
    }, delayMs);
  }
  async run() {
    if (this.isDisposed())
      return;
    this.state = "running";
    let result;
    try {
      result = await this.runCallback();
    } catch (error) {
      logger.error("Error running deleted co values eraser scheduler", {
        err: error
      });
      if (!this.isDisposed()) {
        this.state = "idle";
      }
      return;
    }
    if (this.isDisposed())
      return;
    if (result.hasMore) {
      this.scheduleTimer("followup_scheduled", this.opts.followUpDelayMs);
      return;
    }
    this.state = "idle";
  }
}
class StoreQueueManager {
  constructor() {
    this.backlog = new LinkedList();
    this.processing = false;
  }
  async schedule(queue, callback) {
    this.backlog.push({ queue, callback });
    if (this.processing) {
      return;
    }
    this.processing = true;
    while (this.backlog.head) {
      const entry = this.backlog.head;
      await entry.value.callback();
      this.backlog.shift();
    }
    this.processing = false;
  }
}
class StoreQueue {
  constructor() {
    this.queue = new LinkedList();
    this.closed = false;
    this.processing = false;
  }
  push(data2, correctionCallback) {
    if (this.closed) {
      return;
    }
    this.queue.push({ data: data2, correctionCallback });
  }
  pull() {
    return this.queue.shift();
  }
  processQueue(callback) {
    if (this.processing) {
      return;
    }
    this.processing = true;
    return StoreQueue.manager.schedule(this, async () => {
      let entry;
      while (entry = this.pull()) {
        const { data: data2, correctionCallback } = entry;
        try {
          this.lastCallback = callback(data2, correctionCallback);
          await this.lastCallback;
        } catch (err) {
          logger.error("Error processing message in store queue", { err });
        }
      }
      this.lastCallback = void 0;
      this.processing = false;
    });
  }
  close() {
    this.closed = true;
    while (this.pull()) {
    }
    return this.lastCallback;
  }
}
StoreQueue.manager = new StoreQueueManager();
class StorageApiAsync {
  constructor(dbClient) {
    this.inMemoryCoValues = /* @__PURE__ */ new Set();
    this.pendingKnownStateLoads = /* @__PURE__ */ new Map();
    this.knownStates = new StorageKnownState();
    this.storeQueue = new StoreQueue();
    this.deletedValues = /* @__PURE__ */ new Set();
    this.dbClient = dbClient;
  }
  getKnownState(id2) {
    return this.knownStates.getKnownState(id2);
  }
  loadKnownState(id2, callback) {
    const cached = this.knownStates.getCachedKnownState(id2);
    if (cached) {
      callback(cached);
      return;
    }
    const pending = this.pendingKnownStateLoads.get(id2);
    if (pending) {
      pending.then(callback, () => callback(void 0));
      return;
    }
    const loadPromise = this.dbClient.getCoValueKnownState(id2).then((knownState) => {
      if (knownState) {
        this.knownStates.setKnownState(id2, knownState);
      }
      return knownState;
    }).catch((err) => {
      logger.warn("Failed to load knownState from storage", { id: id2, err });
      return void 0;
    }).finally(() => {
      this.pendingKnownStateLoads.delete(id2);
    });
    this.pendingKnownStateLoads.set(id2, loadPromise);
    loadPromise.then(callback);
  }
  async load(id2, callback, done) {
    await this.loadCoValue(id2, callback, done);
  }
  async loadCoValue(id2, callback, done) {
    this.interruptEraser("load");
    const coValueRow = await this.dbClient.getCoValue(id2);
    if (!coValueRow) {
      done?.(false);
      return;
    }
    const allCoValueSessions = await this.dbClient.getCoValueSessions(coValueRow.rowID);
    const signaturesBySession = /* @__PURE__ */ new Map();
    let contentStreaming = false;
    await Promise.all(allCoValueSessions.map(async (sessionRow) => {
      const signatures = await this.dbClient.getSignatures(sessionRow.rowID, 0);
      if (signatures.length > 0) {
        contentStreaming = true;
        signaturesBySession.set(sessionRow.sessionID, signatures);
      }
    }));
    const knownState = this.knownStates.getKnownState(coValueRow.id);
    knownState.header = true;
    for (const sessionRow of allCoValueSessions) {
      setSessionCounter(knownState.sessions, sessionRow.sessionID, sessionRow.lastIdx);
    }
    this.inMemoryCoValues.add(coValueRow.id);
    let contentMessage = createContentMessage(coValueRow.id, coValueRow.header);
    if (contentStreaming) {
      contentMessage.expectContentUntil = knownState.sessions;
    }
    for (const sessionRow of allCoValueSessions) {
      const signatures = signaturesBySession.get(sessionRow.sessionID) || [];
      let idx = 0;
      const lastSignature = signatures[signatures.length - 1];
      if (lastSignature?.signature !== sessionRow.lastSignature) {
        signatures.push({
          idx: sessionRow.lastIdx,
          signature: sessionRow.lastSignature
        });
      }
      for (const signature of signatures) {
        const newTxsInSession = await this.dbClient.getNewTransactionInSession(sessionRow.rowID, idx, signature.idx);
        collectNewTxs({
          newTxsInSession,
          contentMessage,
          sessionRow,
          firstNewTxIdx: idx,
          signature: signature.signature
        });
        idx = signature.idx + 1;
        if (signatures.length > 1) {
          await this.pushContentWithDependencies(coValueRow, contentMessage, callback);
          contentMessage = createContentMessage(coValueRow.id, coValueRow.header);
        }
      }
    }
    const hasNewContent = Object.keys(contentMessage.new).length > 0;
    if (hasNewContent || !contentStreaming) {
      await this.pushContentWithDependencies(coValueRow, contentMessage, callback);
    }
    this.knownStates.handleUpdate(coValueRow.id, knownState);
    done?.(true);
  }
  async pushContentWithDependencies(coValueRow, contentMessage, pushCallback) {
    const dependedOnCoValuesList = getDependedOnCoValues(coValueRow.header, contentMessage);
    const promises = [];
    for (const dependedOnCoValue of dependedOnCoValuesList) {
      if (this.inMemoryCoValues.has(dependedOnCoValue)) {
        continue;
      }
      promises.push(new Promise((resolve2) => {
        this.loadCoValue(dependedOnCoValue, pushCallback, resolve2);
      }));
    }
    await Promise.all(promises);
    pushCallback(contentMessage);
  }
  async store(msg, correctionCallback) {
    this.storeQueue.push(msg, correctionCallback);
    this.storeQueue.processQueue(async (data2, correctionCallback2) => {
      this.interruptEraser("store");
      return this.storeSingle(data2, correctionCallback2);
    });
  }
  interruptEraser(reason) {
    if (this.eraserController) {
      this.eraserController.abort(reason);
      this.eraserController = void 0;
    }
  }
  async eraseAllDeletedCoValues() {
    const ids = await this.dbClient.getAllCoValuesWaitingForDelete();
    this.eraserController = new AbortController();
    const signal = this.eraserController.signal;
    for (const id2 of ids) {
      if (signal.aborted) {
        return;
      }
      await this.dbClient.eraseCoValueButKeepTombstone(id2);
    }
  }
  /**
   * This function is called when the storage lacks the information required to store the incoming content.
   *
   * It triggers a `correctionCallback` to ask the syncManager to provide the missing information.
   *
   * The correction is applied immediately, to ensure that, when applicable, the dependent content in the queue won't require additional corrections.
   */
  async handleCorrection(knownState, correctionCallback) {
    const correction = correctionCallback(knownState);
    if (!correction) {
      logger.error("Correction callback returned undefined", {
        knownState,
        correction: correction ?? null
      });
      return false;
    }
    for (const msg of correction) {
      const success = await this.storeSingle(msg, (knownState2) => {
        logger.error("Double correction requested", {
          msg,
          knownState: knownState2
        });
        return void 0;
      });
      if (!success) {
        return false;
      }
    }
    return true;
  }
  async storeSingle(msg, correctionCallback) {
    this.interruptEraser("store");
    if (this.storeQueue.closed) {
      return false;
    }
    const id2 = msg.id;
    const storedCoValueRowID = await this.dbClient.upsertCoValue(id2, msg.header);
    if (!storedCoValueRowID) {
      const knownState2 = emptyKnownState(id2);
      this.knownStates.setKnownState(id2, knownState2);
      return this.handleCorrection(knownState2, correctionCallback);
    }
    const knownState = this.knownStates.getKnownState(id2);
    knownState.header = true;
    let invalidAssumptions = false;
    for (const sessionID of Object.keys(msg.new)) {
      await this.dbClient.transaction(async (tx) => {
        const sessionRow = await tx.getSingleCoValueSession(storedCoValueRowID, sessionID);
        if (this.deletedValues.has(id2) && isDeleteSessionID(sessionID)) {
          await tx.markCoValueAsDeleted(id2);
        }
        if (sessionRow) {
          setSessionCounter(knownState.sessions, sessionRow.sessionID, sessionRow.lastIdx);
        }
        const lastIdx = sessionRow?.lastIdx || 0;
        const after = msg.new[sessionID]?.after || 0;
        if (lastIdx < after) {
          invalidAssumptions = true;
        } else {
          const newLastIdx = await this.putNewTxs(tx, msg, sessionID, sessionRow, storedCoValueRowID);
          setSessionCounter(knownState.sessions, sessionID, newLastIdx);
        }
      });
    }
    this.inMemoryCoValues.add(id2);
    this.knownStates.handleUpdate(id2, knownState);
    if (invalidAssumptions) {
      return this.handleCorrection(knownState, correctionCallback);
    }
    return true;
  }
  async putNewTxs(tx, msg, sessionID, sessionRow, storedCoValueRowID) {
    const newTransactions = msg.new[sessionID]?.newTransactions || [];
    const lastIdx = sessionRow?.lastIdx || 0;
    const actuallyNewOffset = lastIdx - (msg.new[sessionID]?.after || 0);
    const actuallyNewTransactions = newTransactions.slice(actuallyNewOffset);
    if (actuallyNewTransactions.length === 0) {
      return lastIdx;
    }
    let bytesSinceLastSignature = sessionRow?.bytesSinceLastSignature || 0;
    const newTransactionsSize = getNewTransactionsSize(actuallyNewTransactions);
    const newLastIdx = lastIdx + actuallyNewTransactions.length;
    let shouldWriteSignature = false;
    if (exceedsRecommendedSize(bytesSinceLastSignature, newTransactionsSize)) {
      shouldWriteSignature = true;
      bytesSinceLastSignature = 0;
    } else {
      bytesSinceLastSignature += newTransactionsSize;
    }
    const nextIdx = lastIdx;
    if (!msg.new[sessionID])
      throw new Error("Session ID not found");
    const sessionUpdate = {
      coValue: storedCoValueRowID,
      sessionID,
      lastIdx: newLastIdx,
      lastSignature: msg.new[sessionID].lastSignature,
      bytesSinceLastSignature
    };
    const sessionRowID = await tx.addSessionUpdate({
      sessionUpdate,
      sessionRow
    });
    if (shouldWriteSignature) {
      await tx.addSignatureAfter({
        sessionRowID,
        idx: newLastIdx - 1,
        signature: msg.new[sessionID].lastSignature
      });
    }
    await Promise.all(actuallyNewTransactions.map((newTransaction, i) => tx.addTransaction(sessionRowID, nextIdx + i, newTransaction)));
    return newLastIdx;
  }
  markDeleteAsValid(id2) {
    this.deletedValues.add(id2);
    if (this.deletedCoValuesEraserScheduler) {
      this.deletedCoValuesEraserScheduler.onEnqueueDeletedCoValue();
    }
  }
  enableDeletedCoValuesErasure() {
    if (this.deletedCoValuesEraserScheduler)
      return;
    this.deletedCoValuesEraserScheduler = new DeletedCoValuesEraserScheduler({
      run: async () => {
        await this.eraseAllDeletedCoValues();
        const remaining = await this.dbClient.getAllCoValuesWaitingForDelete();
        return { hasMore: remaining.length > 0 };
      }
    });
    this.deletedCoValuesEraserScheduler.scheduleStartupDrain();
  }
  waitForSync(id2, coValue) {
    return this.knownStates.waitForSync(id2, coValue);
  }
  trackCoValuesSyncState(updates, done) {
    this.dbClient.trackCoValuesSyncState(updates).then(() => done?.());
  }
  getUnsyncedCoValueIDs(callback) {
    this.dbClient.getUnsyncedCoValueIDs().then(callback);
  }
  stopTrackingSyncState(id2) {
    this.dbClient.stopTrackingSyncState(id2);
  }
  onCoValueUnmounted(id2) {
    this.inMemoryCoValues.delete(id2);
  }
  close() {
    this.deletedCoValuesEraserScheduler?.dispose();
    this.inMemoryCoValues.clear();
    return this.storeQueue.close();
  }
}
const cojsonInternals = {
  accountHeaderForInitialAgentSecret: accountHeaderForInitialAgentSecret$1,
  idforHeader: idforHeader$1,
  CO_VALUE_PRIORITY: CO_VALUE_PRIORITY$1,
  ConnectedPeerChannel: ConnectedPeerChannel$1,
  getContentMessageSize: getContentMessageSize$2,
  WEBSOCKET_CONFIG: WEBSOCKET_CONFIG$1
};
const index$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CoValueCore,
  ControlledAccount,
  ControlledAgent,
  CryptoProvider,
  get DeletedCoValueDeletionStatus() {
    return DeletedCoValueDeletionStatus;
  },
  EVERYONE,
  LocalNode,
  LogLevel,
  PriorityBasedMessageQueue,
  RawAccount,
  RawBinaryCoStream,
  RawCoList,
  RawCoMap,
  RawCoPlainText,
  RawCoStream,
  RawGroup,
  StorageApiAsync,
  base64URLtoBytes,
  bytesToBase64url,
  cojsonInternals,
  emptyKnownState,
  isAccountRole,
  isRawCoID,
  logger,
  stringifyOpID
}, Symbol.toStringTag, { value: "Module" }));
let wasm;
let WASM_VECTOR_LEN = 0;
let cachedUint8ArrayMemory0 = null;
function getUint8ArrayMemory0() {
  if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {
    cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);
  }
  return cachedUint8ArrayMemory0;
}
const cachedTextEncoder = typeof TextEncoder !== "undefined" ? new TextEncoder("utf-8") : { encode: () => {
  throw Error("TextEncoder not available");
} };
const encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
  return cachedTextEncoder.encodeInto(arg, view);
} : function(arg, view) {
  const buf = cachedTextEncoder.encode(arg);
  view.set(buf);
  return {
    read: arg.length,
    written: buf.length
  };
};
function passStringToWasm0(arg, malloc, realloc) {
  if (realloc === void 0) {
    const buf = cachedTextEncoder.encode(arg);
    const ptr2 = malloc(buf.length, 1) >>> 0;
    getUint8ArrayMemory0().subarray(ptr2, ptr2 + buf.length).set(buf);
    WASM_VECTOR_LEN = buf.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len, 1) >>> 0;
  const mem = getUint8ArrayMemory0();
  let offset = 0;
  for (; offset < len; offset++) {
    const code2 = arg.charCodeAt(offset);
    if (code2 > 127) break;
    mem[ptr + offset] = code2;
  }
  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
    const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);
    const ret = encodeString(arg, view);
    offset += ret.written;
    ptr = realloc(ptr, len, offset, 1) >>> 0;
  }
  WASM_VECTOR_LEN = offset;
  return ptr;
}
let cachedDataViewMemory0 = null;
function getDataViewMemory0() {
  if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || cachedDataViewMemory0.buffer.detached === void 0 && cachedDataViewMemory0.buffer !== wasm.memory.buffer) {
    cachedDataViewMemory0 = new DataView(wasm.memory.buffer);
  }
  return cachedDataViewMemory0;
}
function addToExternrefTable0(obj) {
  const idx = wasm.__externref_table_alloc();
  wasm.__wbindgen_export_4.set(idx, obj);
  return idx;
}
function handleError(f, args) {
  try {
    return f.apply(this, args);
  } catch (e) {
    const idx = addToExternrefTable0(e);
    wasm.__wbindgen_exn_store(idx);
  }
}
const cachedTextDecoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : { decode: () => {
  throw Error("TextDecoder not available");
} };
if (typeof TextDecoder !== "undefined") {
  cachedTextDecoder.decode();
}
function getStringFromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));
}
function isLikeNone(x) {
  return x === void 0 || x === null;
}
function debugString(val) {
  const type2 = typeof val;
  if (type2 == "number" || type2 == "boolean" || val == null) {
    return `${val}`;
  }
  if (type2 == "string") {
    return `"${val}"`;
  }
  if (type2 == "symbol") {
    const description2 = val.description;
    if (description2 == null) {
      return "Symbol";
    } else {
      return `Symbol(${description2})`;
    }
  }
  if (type2 == "function") {
    const name = val.name;
    if (typeof name == "string" && name.length > 0) {
      return `Function(${name})`;
    } else {
      return "Function";
    }
  }
  if (Array.isArray(val)) {
    const length = val.length;
    let debug = "[";
    if (length > 0) {
      debug += debugString(val[0]);
    }
    for (let i = 1; i < length; i++) {
      debug += ", " + debugString(val[i]);
    }
    debug += "]";
    return debug;
  }
  const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
  let className;
  if (builtInMatches && builtInMatches.length > 1) {
    className = builtInMatches[1];
  } else {
    return toString.call(val);
  }
  if (className == "Object") {
    try {
      return "Object(" + JSON.stringify(val) + ")";
    } catch (_) {
      return "Object";
    }
  }
  if (val instanceof Error) {
    return `${val.name}: ${val.message}
${val.stack}`;
  }
  return className;
}
function takeFromExternrefTable0(idx) {
  const value = wasm.__wbindgen_export_4.get(idx);
  wasm.__externref_table_dealloc(idx);
  return value;
}
function passArray8ToWasm0(arg, malloc) {
  const ptr = malloc(arg.length * 1, 1) >>> 0;
  getUint8ArrayMemory0().set(arg, ptr / 1);
  WASM_VECTOR_LEN = arg.length;
  return ptr;
}
function getArrayU8FromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);
}
function newEd25519SigningKey() {
  const ret = wasm.newEd25519SigningKey();
  var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
  wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
  return v1;
}
function getSignerId(secret) {
  let deferred3_0;
  let deferred3_1;
  try {
    const ptr0 = passArray8ToWasm0(secret, wasm.__wbindgen_malloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.getSignerId(ptr0, len0);
    var ptr2 = ret[0];
    var len2 = ret[1];
    if (ret[3]) {
      ptr2 = 0;
      len2 = 0;
      throw takeFromExternrefTable0(ret[2]);
    }
    deferred3_0 = ptr2;
    deferred3_1 = len2;
    return getStringFromWasm0(ptr2, len2);
  } finally {
    wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);
  }
}
function sign(message, secret) {
  let deferred4_0;
  let deferred4_1;
  try {
    const ptr0 = passArray8ToWasm0(message, wasm.__wbindgen_malloc);
    const len0 = WASM_VECTOR_LEN;
    const ptr1 = passArray8ToWasm0(secret, wasm.__wbindgen_malloc);
    const len1 = WASM_VECTOR_LEN;
    const ret = wasm.sign(ptr0, len0, ptr1, len1);
    var ptr3 = ret[0];
    var len3 = ret[1];
    if (ret[3]) {
      ptr3 = 0;
      len3 = 0;
      throw takeFromExternrefTable0(ret[2]);
    }
    deferred4_0 = ptr3;
    deferred4_1 = len3;
    return getStringFromWasm0(ptr3, len3);
  } finally {
    wasm.__wbindgen_free(deferred4_0, deferred4_1, 1);
  }
}
function verify(signature, message, id2) {
  const ptr0 = passArray8ToWasm0(signature, wasm.__wbindgen_malloc);
  const len0 = WASM_VECTOR_LEN;
  const ptr1 = passArray8ToWasm0(message, wasm.__wbindgen_malloc);
  const len1 = WASM_VECTOR_LEN;
  const ptr2 = passArray8ToWasm0(id2, wasm.__wbindgen_malloc);
  const len2 = WASM_VECTOR_LEN;
  const ret = wasm.verify(ptr0, len0, ptr1, len1, ptr2, len2);
  if (ret[2]) {
    throw takeFromExternrefTable0(ret[1]);
  }
  return ret[0] !== 0;
}
function blake3HashOnce(data2) {
  const ptr0 = passArray8ToWasm0(data2, wasm.__wbindgen_malloc);
  const len0 = WASM_VECTOR_LEN;
  const ret = wasm.blake3HashOnce(ptr0, len0);
  var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
  wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
  return v2;
}
function blake3HashOnceWithContext(data2, context) {
  const ptr0 = passArray8ToWasm0(data2, wasm.__wbindgen_malloc);
  const len0 = WASM_VECTOR_LEN;
  const ptr1 = passArray8ToWasm0(context, wasm.__wbindgen_malloc);
  const len1 = WASM_VECTOR_LEN;
  const ret = wasm.blake3HashOnceWithContext(ptr0, len0, ptr1, len1);
  var v3 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
  wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
  return v3;
}
function unseal(sealed_message, recipient_secret, sender_id, nonce_material) {
  const ptr0 = passArray8ToWasm0(sealed_message, wasm.__wbindgen_malloc);
  const len0 = WASM_VECTOR_LEN;
  const ptr1 = passStringToWasm0(recipient_secret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len1 = WASM_VECTOR_LEN;
  const ptr2 = passStringToWasm0(sender_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len2 = WASM_VECTOR_LEN;
  const ptr3 = passArray8ToWasm0(nonce_material, wasm.__wbindgen_malloc);
  const len3 = WASM_VECTOR_LEN;
  const ret = wasm.unseal(ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3);
  if (ret[3]) {
    throw takeFromExternrefTable0(ret[2]);
  }
  var v5 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
  wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
  return v5;
}
function seal(message, sender_secret, recipient_id, nonce_material) {
  const ptr0 = passArray8ToWasm0(message, wasm.__wbindgen_malloc);
  const len0 = WASM_VECTOR_LEN;
  const ptr1 = passStringToWasm0(sender_secret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len1 = WASM_VECTOR_LEN;
  const ptr2 = passStringToWasm0(recipient_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len2 = WASM_VECTOR_LEN;
  const ptr3 = passArray8ToWasm0(nonce_material, wasm.__wbindgen_malloc);
  const len3 = WASM_VECTOR_LEN;
  const ret = wasm.seal(ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3);
  if (ret[3]) {
    throw takeFromExternrefTable0(ret[2]);
  }
  var v5 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
  wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
  return v5;
}
function encrypt(value, key_secret, nonce_material) {
  const ptr0 = passArray8ToWasm0(value, wasm.__wbindgen_malloc);
  const len0 = WASM_VECTOR_LEN;
  const ptr1 = passStringToWasm0(key_secret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len1 = WASM_VECTOR_LEN;
  const ptr2 = passArray8ToWasm0(nonce_material, wasm.__wbindgen_malloc);
  const len2 = WASM_VECTOR_LEN;
  const ret = wasm.encrypt(ptr0, len0, ptr1, len1, ptr2, len2);
  if (ret[3]) {
    throw takeFromExternrefTable0(ret[2]);
  }
  var v4 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
  wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
  return v4;
}
function decrypt(ciphertext, key_secret, nonce_material) {
  const ptr0 = passArray8ToWasm0(ciphertext, wasm.__wbindgen_malloc);
  const len0 = WASM_VECTOR_LEN;
  const ptr1 = passStringToWasm0(key_secret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len1 = WASM_VECTOR_LEN;
  const ptr2 = passArray8ToWasm0(nonce_material, wasm.__wbindgen_malloc);
  const len2 = WASM_VECTOR_LEN;
  const ret = wasm.decrypt(ptr0, len0, ptr1, len1, ptr2, len2);
  if (ret[3]) {
    throw takeFromExternrefTable0(ret[2]);
  }
  var v4 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
  wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
  return v4;
}
function getSealerId(secret) {
  let deferred3_0;
  let deferred3_1;
  try {
    const ptr0 = passArray8ToWasm0(secret, wasm.__wbindgen_malloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.getSealerId(ptr0, len0);
    var ptr2 = ret[0];
    var len2 = ret[1];
    if (ret[3]) {
      ptr2 = 0;
      len2 = 0;
      throw takeFromExternrefTable0(ret[2]);
    }
    deferred3_0 = ptr2;
    deferred3_1 = len2;
    return getStringFromWasm0(ptr2, len2);
  } finally {
    wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);
  }
}
function newX25519PrivateKey() {
  const ret = wasm.newX25519PrivateKey();
  var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
  wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
  return v1;
}
typeof FinalizationRegistry === "undefined" ? {} : new FinalizationRegistry((ptr) => wasm.__wbg_blake3hasher_free(ptr >>> 0, 1));
const SessionLogFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm.__wbg_sessionlog_free(ptr >>> 0, 1));
class SessionLog {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(SessionLog.prototype);
    obj.__wbg_ptr = ptr;
    SessionLogFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    SessionLogFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_sessionlog_free(ptr, 0);
  }
  /**
   * Commit pending transactions to the main state.
   * If skip_validate is false, validates the signature first.
   * If skip_validate is true, commits without validation.
   * @param {string} new_signature_str
   * @param {boolean} skip_validate
   */
  commitTransactions(new_signature_str, skip_validate) {
    const ptr0 = passStringToWasm0(new_signature_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.sessionlog_commitTransactions(this.__wbg_ptr, ptr0, len0, skip_validate);
    if (ret[1]) {
      throw takeFromExternrefTable0(ret[0]);
    }
  }
  /**
   * @param {string} changes_json
   * @param {string} signer_secret
   * @param {string} encryption_key
   * @param {string} key_id
   * @param {number} made_at
   * @param {string | null} [meta]
   * @returns {string}
   */
  addNewPrivateTransaction(changes_json, signer_secret, encryption_key, key_id, made_at, meta) {
    let deferred7_0;
    let deferred7_1;
    try {
      const ptr0 = passStringToWasm0(changes_json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN;
      const ptr1 = passStringToWasm0(signer_secret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      const len1 = WASM_VECTOR_LEN;
      const ptr2 = passStringToWasm0(encryption_key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      const len2 = WASM_VECTOR_LEN;
      const ptr3 = passStringToWasm0(key_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      const len3 = WASM_VECTOR_LEN;
      var ptr4 = isLikeNone(meta) ? 0 : passStringToWasm0(meta, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      var len4 = WASM_VECTOR_LEN;
      const ret = wasm.sessionlog_addNewPrivateTransaction(this.__wbg_ptr, ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3, made_at, ptr4, len4);
      var ptr6 = ret[0];
      var len6 = ret[1];
      if (ret[3]) {
        ptr6 = 0;
        len6 = 0;
        throw takeFromExternrefTable0(ret[2]);
      }
      deferred7_0 = ptr6;
      deferred7_1 = len6;
      return getStringFromWasm0(ptr6, len6);
    } finally {
      wasm.__wbindgen_free(deferred7_0, deferred7_1, 1);
    }
  }
  /**
   * @param {string} changes_json
   * @param {string} signer_secret
   * @param {number} made_at
   * @param {string | null} [meta]
   * @returns {string}
   */
  addNewTrustingTransaction(changes_json, signer_secret, made_at, meta) {
    let deferred5_0;
    let deferred5_1;
    try {
      const ptr0 = passStringToWasm0(changes_json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN;
      const ptr1 = passStringToWasm0(signer_secret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      const len1 = WASM_VECTOR_LEN;
      var ptr2 = isLikeNone(meta) ? 0 : passStringToWasm0(meta, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      var len2 = WASM_VECTOR_LEN;
      const ret = wasm.sessionlog_addNewTrustingTransaction(this.__wbg_ptr, ptr0, len0, ptr1, len1, made_at, ptr2, len2);
      var ptr4 = ret[0];
      var len4 = ret[1];
      if (ret[3]) {
        ptr4 = 0;
        len4 = 0;
        throw takeFromExternrefTable0(ret[2]);
      }
      deferred5_0 = ptr4;
      deferred5_1 = len4;
      return getStringFromWasm0(ptr4, len4);
    } finally {
      wasm.__wbindgen_free(deferred5_0, deferred5_1, 1);
    }
  }
  /**
   * Add an existing private transaction to the staging area.
   * The transaction is NOT committed until commitTransactions() succeeds.
   * Note: made_at uses f64 because JavaScript's number type is f64.
   * @param {string} encrypted_changes
   * @param {string} key_used
   * @param {number} made_at
   * @param {string | null} [meta]
   */
  addExistingPrivateTransaction(encrypted_changes, key_used, made_at, meta) {
    const ptr0 = passStringToWasm0(encrypted_changes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ptr1 = passStringToWasm0(key_used, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len1 = WASM_VECTOR_LEN;
    var ptr2 = isLikeNone(meta) ? 0 : passStringToWasm0(meta, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len2 = WASM_VECTOR_LEN;
    const ret = wasm.sessionlog_addExistingPrivateTransaction(this.__wbg_ptr, ptr0, len0, ptr1, len1, made_at, ptr2, len2);
    if (ret[1]) {
      throw takeFromExternrefTable0(ret[0]);
    }
  }
  /**
   * Add an existing trusting transaction to the staging area.
   * The transaction is NOT committed until commitTransactions() succeeds.
   * Note: made_at uses f64 because JavaScript's number type is f64.
   * @param {string} changes
   * @param {number} made_at
   * @param {string | null} [meta]
   */
  addExistingTrustingTransaction(changes, made_at, meta) {
    const ptr0 = passStringToWasm0(changes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    var ptr1 = isLikeNone(meta) ? 0 : passStringToWasm0(meta, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len1 = WASM_VECTOR_LEN;
    const ret = wasm.sessionlog_addExistingTrustingTransaction(this.__wbg_ptr, ptr0, len0, made_at, ptr1, len1);
    if (ret[1]) {
      throw takeFromExternrefTable0(ret[0]);
    }
  }
  /**
   * @param {number} tx_index
   * @param {string} encryption_key
   * @returns {string | undefined}
   */
  decryptNextTransactionMetaJson(tx_index, encryption_key) {
    const ptr0 = passStringToWasm0(encryption_key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.sessionlog_decryptNextTransactionMetaJson(this.__wbg_ptr, tx_index, ptr0, len0);
    if (ret[3]) {
      throw takeFromExternrefTable0(ret[2]);
    }
    let v2;
    if (ret[0] !== 0) {
      v2 = getStringFromWasm0(ret[0], ret[1]).slice();
      wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
    }
    return v2;
  }
  /**
   * @param {number} tx_index
   * @param {string} encryption_key
   * @returns {string}
   */
  decryptNextTransactionChangesJson(tx_index, encryption_key) {
    let deferred3_0;
    let deferred3_1;
    try {
      const ptr0 = passStringToWasm0(encryption_key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN;
      const ret = wasm.sessionlog_decryptNextTransactionChangesJson(this.__wbg_ptr, tx_index, ptr0, len0);
      var ptr2 = ret[0];
      var len2 = ret[1];
      if (ret[3]) {
        ptr2 = 0;
        len2 = 0;
        throw takeFromExternrefTable0(ret[2]);
      }
      deferred3_0 = ptr2;
      deferred3_1 = len2;
      return getStringFromWasm0(ptr2, len2);
    } finally {
      wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);
    }
  }
  /**
   * @param {string} co_id
   * @param {string} session_id
   * @param {string | null} [signer_id]
   */
  constructor(co_id, session_id, signer_id) {
    const ptr0 = passStringToWasm0(co_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ptr1 = passStringToWasm0(session_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len1 = WASM_VECTOR_LEN;
    var ptr2 = isLikeNone(signer_id) ? 0 : passStringToWasm0(signer_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len2 = WASM_VECTOR_LEN;
    const ret = wasm.sessionlog_new(ptr0, len0, ptr1, len1, ptr2, len2);
    this.__wbg_ptr = ret >>> 0;
    SessionLogFinalization.register(this, this.__wbg_ptr, this);
    return this;
  }
  /**
   * @returns {SessionLog}
   */
  clone() {
    const ret = wasm.sessionlog_clone(this.__wbg_ptr);
    return SessionLog.__wrap(ret);
  }
}
async function __wbg_load(module2, imports) {
  if (typeof Response === "function" && module2 instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming === "function") {
      try {
        return await WebAssembly.instantiateStreaming(module2, imports);
      } catch (e) {
        if (module2.headers.get("Content-Type") != "application/wasm") {
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);
        } else {
          throw e;
        }
      }
    }
    const bytes = await module2.arrayBuffer();
    return await WebAssembly.instantiate(bytes, imports);
  } else {
    const instance = await WebAssembly.instantiate(module2, imports);
    if (instance instanceof WebAssembly.Instance) {
      return { instance, module: module2 };
    } else {
      return instance;
    }
  }
}
function __wbg_get_imports() {
  const imports = {};
  imports.wbg = {};
  imports.wbg.__wbg_String_8f0eb39a4a4c2f66 = function(arg0, arg1) {
    const ret = String(arg1);
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len1 = WASM_VECTOR_LEN;
    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
  };
  imports.wbg.__wbg_buffer_609cc3eee51ed158 = function(arg0) {
    const ret = arg0.buffer;
    return ret;
  };
  imports.wbg.__wbg_call_672a4d21634d4a24 = function() {
    return handleError(function(arg0, arg1) {
      const ret = arg0.call(arg1);
      return ret;
    }, arguments);
  };
  imports.wbg.__wbg_call_7cccdd69e0791ae2 = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = arg0.call(arg1, arg2);
      return ret;
    }, arguments);
  };
  imports.wbg.__wbg_crypto_574e78ad8b13b65f = function(arg0) {
    const ret = arg0.crypto;
    return ret;
  };
  imports.wbg.__wbg_getRandomValues_b8f5dbd5f3995a9e = function() {
    return handleError(function(arg0, arg1) {
      arg0.getRandomValues(arg1);
    }, arguments);
  };
  imports.wbg.__wbg_msCrypto_a61aeb35a24c1329 = function(arg0) {
    const ret = arg0.msCrypto;
    return ret;
  };
  imports.wbg.__wbg_new_a12002a7f91c75be = function(arg0) {
    const ret = new Uint8Array(arg0);
    return ret;
  };
  imports.wbg.__wbg_newnoargs_105ed471475aaf50 = function(arg0, arg1) {
    const ret = new Function(getStringFromWasm0(arg0, arg1));
    return ret;
  };
  imports.wbg.__wbg_newwithbyteoffsetandlength_d97e637ebe145a9a = function(arg0, arg1, arg2) {
    const ret = new Uint8Array(arg0, arg1 >>> 0, arg2 >>> 0);
    return ret;
  };
  imports.wbg.__wbg_newwithlength_a381634e90c276d4 = function(arg0) {
    const ret = new Uint8Array(arg0 >>> 0);
    return ret;
  };
  imports.wbg.__wbg_node_905d3e251edff8a2 = function(arg0) {
    const ret = arg0.node;
    return ret;
  };
  imports.wbg.__wbg_process_dc0fbacc7c1c06f7 = function(arg0) {
    const ret = arg0.process;
    return ret;
  };
  imports.wbg.__wbg_randomFillSync_ac0988aba3254290 = function() {
    return handleError(function(arg0, arg1) {
      arg0.randomFillSync(arg1);
    }, arguments);
  };
  imports.wbg.__wbg_require_60cc747a6bc5215a = function() {
    return handleError(function() {
      const ret = module.require;
      return ret;
    }, arguments);
  };
  imports.wbg.__wbg_set_65595bdd868b3009 = function(arg0, arg1, arg2) {
    arg0.set(arg1, arg2 >>> 0);
  };
  imports.wbg.__wbg_static_accessor_GLOBAL_88a902d13a557d07 = function() {
    const ret = typeof globalThis === "undefined" ? null : globalThis;
    return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
  };
  imports.wbg.__wbg_static_accessor_GLOBAL_THIS_56578be7e9f832b0 = function() {
    const ret = typeof globalThis === "undefined" ? null : globalThis;
    return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
  };
  imports.wbg.__wbg_static_accessor_SELF_37c5d418e4bf5819 = function() {
    const ret = typeof self === "undefined" ? null : self;
    return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
  };
  imports.wbg.__wbg_static_accessor_WINDOW_5de37043a91a9c40 = function() {
    const ret = typeof window === "undefined" ? null : window;
    return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
  };
  imports.wbg.__wbg_subarray_aa9065fa9dc5df96 = function(arg0, arg1, arg2) {
    const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);
    return ret;
  };
  imports.wbg.__wbg_versions_c01dfd4722a88165 = function(arg0) {
    const ret = arg0.versions;
    return ret;
  };
  imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {
    const ret = debugString(arg1);
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len1 = WASM_VECTOR_LEN;
    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
  };
  imports.wbg.__wbindgen_error_new = function(arg0, arg1) {
    const ret = new Error(getStringFromWasm0(arg0, arg1));
    return ret;
  };
  imports.wbg.__wbindgen_init_externref_table = function() {
    const table = wasm.__wbindgen_export_4;
    const offset = table.grow(4);
    table.set(0, void 0);
    table.set(offset + 0, void 0);
    table.set(offset + 1, null);
    table.set(offset + 2, true);
    table.set(offset + 3, false);
  };
  imports.wbg.__wbindgen_is_function = function(arg0) {
    const ret = typeof arg0 === "function";
    return ret;
  };
  imports.wbg.__wbindgen_is_object = function(arg0) {
    const val = arg0;
    const ret = typeof val === "object" && val !== null;
    return ret;
  };
  imports.wbg.__wbindgen_is_string = function(arg0) {
    const ret = typeof arg0 === "string";
    return ret;
  };
  imports.wbg.__wbindgen_is_undefined = function(arg0) {
    const ret = arg0 === void 0;
    return ret;
  };
  imports.wbg.__wbindgen_memory = function() {
    const ret = wasm.memory;
    return ret;
  };
  imports.wbg.__wbindgen_string_new = function(arg0, arg1) {
    const ret = getStringFromWasm0(arg0, arg1);
    return ret;
  };
  imports.wbg.__wbindgen_throw = function(arg0, arg1) {
    throw new Error(getStringFromWasm0(arg0, arg1));
  };
  return imports;
}
function __wbg_finalize_init(instance, module2) {
  wasm = instance.exports;
  __wbg_init.__wbindgen_wasm_module = module2;
  cachedDataViewMemory0 = null;
  cachedUint8ArrayMemory0 = null;
  wasm.__wbindgen_start();
  return wasm;
}
function initSync(module2) {
  if (wasm !== void 0) return wasm;
  if (typeof module2 !== "undefined") {
    if (Object.getPrototypeOf(module2) === Object.prototype) {
      ({ module: module2 } = module2);
    } else {
      console.warn("using deprecated parameters for `initSync()`; pass a single object instead");
    }
  }
  const imports = __wbg_get_imports();
  if (!(module2 instanceof WebAssembly.Module)) {
    module2 = new WebAssembly.Module(module2);
  }
  const instance = new WebAssembly.Instance(module2, imports);
  return __wbg_finalize_init(instance, module2);
}
async function __wbg_init(module_or_path) {
  if (wasm !== void 0) return wasm;
  if (typeof module_or_path !== "undefined") {
    if (Object.getPrototypeOf(module_or_path) === Object.prototype) {
      ({ module_or_path } = module_or_path);
    } else {
      console.warn("using deprecated parameters for the initialization function; pass a single object instead");
    }
  }
  if (typeof module_or_path === "undefined") {
    throw new Error();
  }
  const imports = __wbg_get_imports();
  if (typeof module_or_path === "string" || typeof Request === "function" && module_or_path instanceof Request || typeof URL === "function" && module_or_path instanceof URL) {
    module_or_path = fetch(module_or_path);
  }
  const { instance, module: module2 } = await __wbg_load(await module_or_path, imports);
  return __wbg_finalize_init(instance, module2);
}
const data = "data:application/wasm;base64,AGFzbQEAAAAB4wM9YAJ/fwF/YAN/f38Bf2ACf38AYAN/f38AYAF/AGAABH9/f39gAX8Bf2AFf39/f38AYAACf39gAAF/YAR/f39/AGACf38Ef39/f2ABbwFvYAAAYAV/f39+fwBgB39/f39/f38AYAV/f39/fwF/YAR/f39/AX9gBH9/f38Ef39/f2ABbwF/YAZ/f39/f38Bf2AAA39/f2ACf38Bb2AGf39/f39/AGACf28AYAABb2ACb28AYANvf38Bb2ACf34AYAh/f39/f39/fwR/f39/YAZ/f39/f38Ef39/f2AGf39/f39/A39/f2AEf39/fwJ/f2ACf38Cf39gA29vfwBgAX8Bb2ACb28Bb2ADb29vAW9gBn9/f39+fwBgCH9/f39/f35/AGACfH8Bf2AHf39/fn9/fwF/YAR/f39+AGAJf39/f39/fn5+AGACfn8AYAd/f39/f39/AX9gC39/f39/f39/f39/AX9gA39+fgBgAAF+YAR/fn5/AGAMf39/f39/f39/fH9/BH9/f39gCH9/f39/fH9/BH9/f39gCH9/f39/fH9/An9/YAZ/f398f38Cf39gAX8Cf39gBX9/fH9/AGAEf3x/fwBgBX9/fn9/AGAEf35/fwBgBX9/fX9/AGAEf31/fwACogkgA3diZxVfX3diaW5kZ2VuX3N0cmluZ19uZXcAFgN3YmcUX193YmluZGdlbl9lcnJvcl9uZXcAFgN3YmcUX193YmluZGdlbl9pc19vYmplY3QAEwN3YmcdX193YmdfU3RyaW5nXzhmMGViMzlhNGE0YzJmNjYAGAN3YmcdX193YmdfY3J5cHRvXzU3NGU3OGFkOGIxM2I2NWYADAN3YmceX193YmdfcHJvY2Vzc19kYzBmYmFjYzdjMWMwNmY3AAwDd2JnH19fd2JnX3ZlcnNpb25zX2MwMWRmZDQ3MjJhODgxNjUADAN3YmcbX193Ymdfbm9kZV85MDVkM2UyNTFlZGZmOGEyAAwDd2JnFF9fd2JpbmRnZW5faXNfc3RyaW5nABMDd2JnHl9fd2JnX3JlcXVpcmVfNjBjYzc0N2E2YmM1MjE1YQAZA3diZxZfX3diaW5kZ2VuX2lzX2Z1bmN0aW9uABMDd2JnH19fd2JnX21zQ3J5cHRvX2E2MWFlYjM1YTI0YzEzMjkADAN3YmclX193YmdfcmFuZG9tRmlsbFN5bmNfYWMwOTg4YWJhMzI1NDI5MAAaA3diZyZfX3diZ19nZXRSYW5kb21WYWx1ZXNfYjhmNWRiZDVmMzk5NWE5ZQAaA3diZyBfX3diZ19uZXdub2FyZ3NfMTA1ZWQ0NzE0NzVhYWY1MAAWA3diZxpfX3diZ19uZXdfYTEyMDAyYTdmOTFjNzViZQAMA3diZx1fX3diZ19idWZmZXJfNjA5Y2MzZWVlNTFlZDE1OAAMA3diZzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9kOTdlNjM3ZWJlMTQ1YTlhABsDd2JnGl9fd2JnX3NldF82NTU5NWJkZDg2OGIzMDA5ACIDd2JnJF9fd2JnX25ld3dpdGhsZW5ndGhfYTM4MTYzNGU5MGMyNzZkNAAjA3diZx9fX3diZ19zdWJhcnJheV9hYTkwNjVmYTlkYzVkZjk2ABsDd2JnMl9fd2JnX3N0YXRpY19hY2Nlc3Nvcl9HTE9CQUxfVEhJU181NjU3OGJlN2U5ZjgzMmIwAAkDd2JnF19fd2JpbmRnZW5faXNfdW5kZWZpbmVkABMDd2JnG19fd2JnX2NhbGxfNjcyYTRkMjE2MzRkNGEyNAAkA3diZytfX3diZ19zdGF0aWNfYWNjZXNzb3JfU0VMRl8zN2M1ZDQxOGU0YmY1ODE5AAkDd2JnLV9fd2JnX3N0YXRpY19hY2Nlc3Nvcl9HTE9CQUxfODhhOTAyZDEzYTU1N2QwNwAJA3diZy1fX3diZ19zdGF0aWNfYWNjZXNzb3JfV0lORE9XXzVkZTM3MDQzYTkxYTljNDAACQN3YmcbX193YmdfY2FsbF83Y2NjZGQ2OWUwNzkxYWUyACUDd2JnEV9fd2JpbmRnZW5fbWVtb3J5ABkDd2JnEF9fd2JpbmRnZW5fdGhyb3cAAgN3YmcXX193YmluZGdlbl9kZWJ1Z19zdHJpbmcAGAN3YmcfX193YmluZGdlbl9pbml0X2V4dGVybnJlZl90YWJsZQANA4kDhwMDJg4GJwAKAigDAgMCAAYDAgMHAgICAykDAgIDAgMDDwMAARwEAgYDKgMDFAMEDgMCDwMBAQICAwIAAxwCAAoBAQIDAAAPAQoDFAMKAwMDAgoDDw8CAgMHDgIDBAIrAQIsBwAELQQCCQMDAxcAAgMJAgQDAAACAgAEAAMABwIBEBEOAAAGAAIEBAQEAAYAAAkQAAYAAgAADQ0UAAABEQACBAMEBAcCFwcuBwQGAwcXAgADAwQABAABAAMABAIEAAoBAC8EAwIHAAAOAgMAAAICAgQDBAAAMDEDBAACAAAABAIBAQECBgEAAAADAwMyAAAAAAEAAgQCAgoDBAQAMx0dAAACEB4eBgoAAAQ0EhISHxIfEjULCwsLCwsLCwAJAgIgIAEhIRE2FAgIBxA3OTsECgAAAQAEAAICAgICAAQEBAQEAAAGAAAGAwEABwARAAACAAIEAAACAAAGAwQEAAAAAAAAAAAAAAAAAAAAAAAAAg0NAgAAAAACAAACAQAAAAAAAgQNBgkDBAsCcAG1AbUBbwCAAQUDAQASBgkBfwFBgIDAAAsH+AgxBm1lbW9yeQIAFV9fd2JnX3Nlc3Npb25sb2dfZnJlZQBYKHNlc3Npb25sb2dfYWRkRXhpc3RpbmdQcml2YXRlVHJhbnNhY3Rpb24AqwIpc2Vzc2lvbmxvZ19hZGRFeGlzdGluZ1RydXN0aW5nVHJhbnNhY3Rpb24AswIjc2Vzc2lvbmxvZ19hZGROZXdQcml2YXRlVHJhbnNhY3Rpb24AjQIkc2Vzc2lvbmxvZ19hZGROZXdUcnVzdGluZ1RyYW5zYWN0aW9uAJ0CEHNlc3Npb25sb2dfY2xvbmUArAEdc2Vzc2lvbmxvZ19jb21taXRUcmFuc2FjdGlvbnMAwAIsc2Vzc2lvbmxvZ19kZWNyeXB0TmV4dFRyYW5zYWN0aW9uQ2hhbmdlc0pzb24ArQIpc2Vzc2lvbmxvZ19kZWNyeXB0TmV4dFRyYW5zYWN0aW9uTWV0YUpzb24ArAIOc2Vzc2lvbmxvZ19uZXcAuQELZWQyNTUxOVNpZ24ArgIZZWQyNTUxOVNpZ25hdHVyZUZyb21CeXRlcwC2AhplZDI1NTE5U2lnbmluZ0tleUZyb21CeXRlcwC1AhllZDI1NTE5U2lnbmluZ0tleVRvUHVibGljALQCDWVkMjU1MTlWZXJpZnkArwITZWQyNTUxOVZlcmlmeWluZ0tleQC3AhxlZDI1NTE5VmVyaWZ5aW5nS2V5RnJvbUJ5dGVzALgCFG5ld0VkMjU1MTlTaWduaW5nS2V5AMgCFWVkMjU1MTlTaWduaW5nS2V5U2lnbgCuAgtnZXRTaWduZXJJZAC5AgRzaWduALACBnZlcmlmeQCxAhdfX3diZ19ibGFrZTNoYXNoZXJfZnJlZQDPAQ5ibGFrZTNIYXNoT25jZQDEAhlibGFrZTNIYXNoT25jZVdpdGhDb250ZXh0AMECEmJsYWtlM2hhc2hlcl9jbG9uZQBGFWJsYWtlM2hhc2hlcl9maW5hbGl6ZQDGAhBibGFrZTNoYXNoZXJfbmV3AIcBE2JsYWtlM2hhc2hlcl91cGRhdGUAzAEPZGVjcnlwdFhzYWxzYTIwAKQCD2VuY3J5cHRYc2Fsc2EyMACkAg1nZW5lcmF0ZU5vbmNlAMMCB2RlY3J5cHQApQIHZW5jcnlwdAClAgRzZWFsAJ8CBnVuc2VhbACeAgtnZXRTZWFsZXJJZAC7AhNuZXdYMjU1MTlQcml2YXRlS2V5AMkCE3gyNTUxOURpZmZpZUhlbGxtYW4AsgIPeDI1NTE5UHVibGljS2V5ALoCEV9fd2JpbmRnZW5fbWFsbG9jALwCEl9fd2JpbmRnZW5fcmVhbGxvYwDFAhRfX3diaW5kZ2VuX2V4bl9zdG9yZQDzAhdfX2V4dGVybnJlZl90YWJsZV9hbGxvYwCPARNfX3diaW5kZ2VuX2V4cG9ydF80AQEZX19leHRlcm5yZWZfdGFibGVfZGVhbGxvYwD/AQ9fX3diaW5kZ2VuX2ZyZWUA6AIQX193YmluZGdlbl9zdGFydAAfCe0CAQBBAQu0Af4C1QKBAqIB/wL9Ao4CqAL9AaACjwLVAoECogGAA6gC7gKFA90BsQGbAtQB+QGMAaEC0AGIAo0D0gKoAqEC1gGfA4QDggODA/UC7AHdAYYDjgPlAuYChwPVAoECogGKA4gDiQObAu4C1QKBAqIBiwPtAYkC1QKQAtUCgQKiAYwDqAKgAu4C7wLsApsBjgPYAdUC1QKRAqADqAL+AZkB7wL6AfoB0wG7AdoBoQPXAvACoQOmA/ECoQLvAvwB6gK2AboBoQPYAvICpgOUAagC8QKpAssCzgHKAs4CzQLKAswCygLQAssCxwLTAt0C3gLfAuACrwHhAu4C1gL0ApcB7AKrAe8C1QKBAqIBlAOTA9UCgQKiAdECkwG+Aa0B8QKTArwB1AKVA/AB7gLvAtUCggKjAZYD9QKXAvYClwPPAt4BpgHFAaED2gLZApkD1QKG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IgkgA3NBGHciAyAmczYAPCAAICUgAiANIBRzQRh3IiYgDmoiCCASc0EZdyINIB4gJGpqIiRqIBUgJHNBEHciAiARaiIVIA1zQRR3IiRqIh4gAnNBGHciAnM2ADggACAnIAEgCyAfaiIfIBhzQRl3IhggIiAjamoiImogBSAic0EQdyIBIAhqIiMgGHNBFHciGGoiESABc0EYdyIBczYANCAAICggISAXIBxzQRl3IgUgDyAgamoiIGogBSAgICZzQRB3IgUgH2oiIHNBFHciF2oiHyAFc0EYdyIFczYAMCAAICsgBSAgaiIgczYALCAAICwgAyAHaiIiczYAKCAAICkgAiAVaiIVczYAJCAAICogASAjaiIcczYAICAAIB4gIHM2AAwgACARICJzNgAIIAAgFSAfczYABCAAIAkgHHM2AAAgACAYIBxzQRl3IANzNgAcIAAgFyAgc0EZdyACczYAGCAAIAogInNBGXcgAXM2ABQgACAVICRzQRl3IAVzNgAQC4kbASB/IAAgACgCGCIdIAEoABAiJCAAKAIIamoiGyABKAAUIhVqIB0gGyACQf8BcXNBEHciAkHy5rvjA2oiHXNBFHciG2oiIiACc0EYdyIJIB1qIhwgG3NBGXciDyAAKAIUIhsgASgACCICIAAoAgRqaiIZIAEoAAwiHWogGSADQiCIp3NBEHciHkH7ouGkBGsiICAbc0EUdyIGaiIKIAEoACgiG2pqIiMgASgALCIZaiAPICMgACgCECIhIAEoAAAiDyAAKAIAamoiCCABKAAEIh9qICEgCCADp3NBEHciIUHnzKfQBmoiCHNBFHciB2oiDiAhc0EYdyINc0EQdyILIAAoAhwiBSABKAAYIiMgACgCDGpqIgwgASgAHCIhaiAFIAwgBEH/AXFzQRB3IgRBxpXA1QVrIgVzQRR3IgxqIhEgBHNBGHciECAFaiIFaiISc0EUdyIUaiITIB1qIAYgICAKIB5zQRh3IiBqIgZzQRl3IgogDiABKAAgIgRqaiIOIAEoACQiHmogCiAcIA4gEHNBEHciHGoiCnNBFHciDmoiECAcc0EYdyIWIApqIgogDnNBGXciHGoiDiAbaiAcIA4gBSAMc0EZdyIFICIgASgAMCIcamoiDCABKAA0IiJqIAwgIHNBEHciICAIIA1qIghqIg0gBXNBFHciBWoi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jOjEACABNgIAC0GQ6MQAQf8fNgIAQdzlxAAgBzYCAEHU5cQAIAQ2AgBB0OXEACABNgIAQezlxABB4OXEADYCAEH05cQAQejlxAA2AgBB6OXEAEHg5cQANgIAQfzlxABB8OXEADYCAEHw5cQAQejlxAA2AgBBhObEAEH45cQANgIAQfjlxABB8OXEADYCAEGM5sQAQYDmxAA2AgBBgObEAEH45cQANgIAQZTmxABBiObEADYCAEGI5sQAQYDmxAA2AgBBnObEAEGQ5sQANgIAQZDmxABBiObEADYCAEGk5sQAQZjmxAA2AgBBmObEAEGQ5sQANgIAQazmxABBoObEADYCAEGg5sQAQZjmxAA2AgBBqObEAEGg5sQANgIAQbTmxABBqObEADYCAEGw5sQAQajmxAA2AgBBvObEAEGw5sQANgIAQbjmxABBsObEADYCAEHE5sQAQbjmxAA2AgBBwObEAEG45sQANgIAQczmxABBwObEADYCAEHI5sQAQcDmxAA2AgBB1ObEAEHI5sQANgIAQdDmxABByObEADYCAEHc5sQAQdDmxAA2AgBB2ObEAEHQ5sQANgIAQeTmxABB2ObEADYCAEHg5sQAQdjmxAA2AgBB7ObEAEHg5sQANgIAQfTmxABB6ObEADYCAEHo5sQAQeDmxAA2AgBB/ObEAEHw5sQANgIAQfDmxABB6ObEADYCAEGE58QAQfjmxAA2AgBB+ObEAEHw5sQANgIAQYznxABBgOfEADYCAEGA58QAQfjmxAA2AgBBlOfEAEGI58QANgIAQYjnxABBgOfEADYCAEGc58QAQZDnxAA2AgBBkOfEAEGI58QANgIAQaTnxABBmOfEADYCAEGY58QAQZDnxAA2AgBBrOfEAEGg58QANgIAQaDnxABBmOfEADYCAEG058QAQajnxAA2AgBBqOfEAEGg58QANgIAQbznxABBsOfEADYCAEGw58QAQajnxAA2AgBBxOfEAEG458QANgIAQbjnxABBsOfEADYCAEHM58QAQcDnxAA2AgBBwOfEAEG458QANgIAQdTnxABByOfEADYCAEHI58QAQcDnxAA2AgBB3OfEAEHQ58QANgIAQdDnxABByOfEADYCAEHk58QAQdjnxAA2AgBB2OfEAEHQ58QANgIAQfznxAAgAUEPakF4cSIAQQhrIgI2AgBB4OfEAEHY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akEJdyAMcyIMIAVqQQ13IA9zIg8gDGpBEncgCHMhCCAQIBQgFWpBEncgB3MiB2pBB3cgCXMiCSAHakEJdyANcyINIAlqQQ13IBBzIhAgDWpBEncgB3MhByATQQFrIhMNAAsgACkCICEpIAAoAgAhEyAAKAIEIRIgACgCCCERIAAoAgwhFCAAKAIQIRUgACgCFCEcIAAoAhghGiAAKAIcIR0gACgCICEeIAAoAiQhHyAAKAIoISAgACgCLCEhIAAoAjAhIiAAKAI0ISMgACgCOCEkIAAgACgCPCABajYCfCAAIBYgJGo2AnggACAOICNqNgJ0IAAgBiAiajYCcCAAIAIgIWo2AmwgACAEICBqNgJoIAAgFyAfajYCZCAAIAsgHmo2AmAgACAMIB1qNgJcIAAgBSAaajYCWCAAIAggHGo2AlQgACAPIBVqNgJQIAAgECAUajYCTCAAIA0gEWo2AkggACAJIBJqNgJEIAAgByATajYCQCAAIClCAXwiKT4CICAAIClCIIg+AiQgCkEBcSECQQAhASAbQQFGDQEgCkE+cSEKA0AgASAZaiIGIAAgAWoiBEFAay0AACABIBhqIgUtAABzOgAAIAZBAWogBEHBAGotAAAgBUEBai0AAHM6AAAgCiABQQJqIgFHDQALDAELAkAgCkUNACABKAIEIQAgASgCACECQQAhASAKQQFHBEAgCkF+cSEGA0AgACABaiIFIAEgCGoiB0FAay0AACABIAJqIg4tAABzOgAAIAVBAWogB0HBAGotAAAgDkEBai0AAHM6AAAgBiABQQJqIgFHDQALCyAKQQFxRQ0AIAAgAWogASAJai0AACABIAJqLQAAczoAAAsgBCAKaiEbDAELIAJFDQAgASAZaiAAQUBrIAFqLQAAIAEgGGotAABzOgAACyAlIBs6AABBAAsgA0HAAWokAAuQMQITfyR+IwBB4AVrIgQkACAEQeAAaiIFQQBB4AD8CwAgBEHYAGoiByABQdgBaikCADcDACAEQdAAaiIGIAFB0AFqKQIANwMAIARBkANqIghBsN/AACkDADcDACAEQZgDaiIJQbjfwAApAwA3AwAgBEGgA2pBwN/AACkDADcDACAEQagDakHI38AAKQMANwMAIARBsANqQdDfwAApAwA3AwAgBEG4A2pB2N/AACkDADcDACAEIAFByAFqKQIANwNIIAQgASkCwAE3A0AgBEGg38AAKQMANwOAAyAEQajfwAApAwA3A4gDIARCADcDyAMgBEIANwPAAyAEQdADaiINIARBQGsiCkGAAfwKAAAgBEGoBWoiDkIANwMAIARBsAVqIg9CADcDACAEQbgFaiILQgA3AwAgBEHABWoiDEIANwMAIARByAVqIhBCADcDACAEQdAFaiIRQgA3AwAgBEHYBWoiEkIANwMAIARBIDoA0AQgBEIANwOgBSAEQYADaiITIA0gBEGgBWoQOCAJIAspAwA3AwAgCCAPKQMANwMAIARBiANqIA4pAwA3AwAgBCAEKQOgBSIXNwOAAyAEIBenQfgBcToAgAMgBCAELQCfA0E/cUHAAHI6AJ8DIAQgExD7ASAEQThqIgggEikDADcAACAEQTBqIgkgESkDADcAACAEQShqIg0gECkDADcAACAEIAwpAwA3ACAgBEH4AGpB6N3AACkDADcDACAEQfAAakHg3cAAKQMANwMAIARB6ABqQdjdwAApAwA3AwAgBUHQ3cAAKQMANwMAIAdByN3AACkDADcDACAGQcDdwAApAwA3AwAgBEIANwOIASAEQgA3A4ABIARBuN3AACkDADcDSCAEQbDdwAApAwA3A0AgBEGwAWoiBUEAQeAA/AsAIARBqAFqIAgpAAA3AwAgBEGgAWogCSkAADcDACAEQZgBaiANKQAANwMAIARBIDoAkAIgBCAEKQAgNwOQASAEQZABaiEHAkAgA0HgAE8EQCAFIAJB4AD8CgAAIARCADcDiAEgBEIBNwOAASAKIAdBARAgIAJB4ABqIQggA0HgAGsiBkH/AHEhBSAGQYABTwRAIAQgBCkDgAEiFyAGQQd2IgmtfCIYNwOAASAEIAQpA4gBIBcgGFatfDcDiAEgCiAIIAkQIAsgBUUNASAHIAggBkGAf3FqIAX8CgAADAELIAMEQCAEQbABaiACIAP8CgAACyADQSBqIQULIAQgBToAkAIgBEGAA2oiBSAEQUBrQeAB/AoAACAEQdgFaiIGQgA3AwAgBEHQBWoiCkIANwMAIARByAVqIghCADcDACAEQcAFaiIJQgA3AwAgBEG4BWoiDUIANwMAIARBsAVqIg5CADcDACAEQagFaiIPQgA3AwAgBEIANwOgBSAFIARB0ANqIARBoAVqEDggBEGYBWogBikDADcD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//8BcTYCbCABIAEoAkwgASgCKCACQR12amoiAkH/////AXE2AnAgASABKAJQIAEoAiwgAkEddmpqIgJB/////wFxNgJ0IAEgASgCVCABKAIwIAJBHXZqaiICQf////8BcTYCeCABIAEoAlggASgCNCACQR12amoiAkH/////AXE2AnwgASABKAJcIAEoAjggAkEddmpqIgJB/////wFxNgKAASABIAEoAmAgASgCPCACQR12amoiAkH/////AXE2AoQBIAEgASgCZCABKAJAIAJBHXZqaiICQf////8BcTYCiAEgASABKAJoIAEoAkQgAkEddmpqQf////8BcTYCjAEgASABQewAakHg4cAAEGggBEGgA2oiAiABEH8gAUGQAWokACAPIARByAJqKQAAIhc3AwAgDiAEQdACaikAACIYNwMAIA0gBEHYAmopAAAiGzcDACAAIAQpAMACIhw3AAEgAEEJaiAXNwAAIABBEWogGDcAACAAQRlqIBs3AAAgAEEhaiACKQMANwAAIABBKWogBEGoA2opAwA3AAAgAEExaiAEQbADaikDADcAACAAQTlqIARBuANqKQMANwAAIAQgHDcDgAMgAEEAOgAAIAQQwgEgBEEAOgAgIARBADoAISAEQQA6ACIgBEEAOgAjIARBADoAJCAEQQA6ACUgBEEAOgAmIARBADoAJyAEQQA6ACggBEEAOgApIARBADoAKiAEQQA6ACsgBEEAOgAsIARBADoALSAEQQA6AC4gBEEAOgAvIARBADoAMCAEQQA6ADEgBEEAOgAyIARBADoAMyAEQQA6ADQgBEEAOgA1IARBADoANiAEQQA6ADcgBEEAOgA4IARBADoAOSAEQQA6ADogBEEAOgA7IARBADoAPCAEQQA6AD0gBEEAOgA+IARBADoAPyAEQeAFaiQAC/QZAhl/BH4jAEGwB2siAiQAIwBBIGsiBCQAIAIgAS0AACIDQQR2OgABIAIgA0EPcSIGOgAAIAIgAS0AASIDQQR2OgADIAIgA0EPcToAAiACIAEtAAIiA0EEdjoABSACIANBD3E6AAQgAiABLQADIgNBBHY6AAcgAiADQQ9xOgAGIAIgAS0ABCIDQQR2OgAJIAIgA0EPcToACCACIAEtAAUiA0EEdjoACyACIANBD3E6AAogAiABLQAGIgNBBHY6AA0gAiADQQ9xOgAMIAIgAS0AByIDQQR2OgAPIAIgA0EPcToADiACIAEtAAgiA0EEdjoAESACIANBD3E6ABAgAiABLQAJIgNBBHY6ABMgAiADQQ9xOgASIAIgAS0ACiIDQQR2OgAVIAIgA0EPcToAFCACIAEtAAsiA0EEdjoAFyACIANBD3E6ABYgAiABLQAMIgNBBHY6ABkgAiADQQ9xOgAYIAIgAS0ADSIDQQR2OgAbIAIgA0EPcToAGiACIAEtAA4iA0EEdjoAHSACIANBD3E6ABwgAiABLQAPIgNBBHY6AB8gAiADQQ9xOgAeIAIgAS0AECIDQQR2OgAhIAIgA0EPcToAICACIAEtABEiA0EPcToAIiACIANBBHY6ACMgAiABLQASIgNBBHY6ACUgAiADQQ9xOgAkIAIgAS0AEyIDQQR2OgAnIAIgA0EPcToAJiACIAEtABQiA0EEdjoAKSACIANBD3E6ACggAiABLQAVIgNBBHY6ACsgAiADQQ9xOgAqIAIgAS0AFiIDQQR2OgAtIAIgA0EPcToALCACIAEtABciA0EEdjoALyACIANBD3E6AC4gAiABLQAYIgNBBHY6ADEgAiADQQ9xOgAwIAIgAS0AGSIDQQR2OgAzIAIgA0EPcToAMiACIAEtABoiA0EEdjoANSACIANBD3E6ADQgAiABLQAbIgNBBHY6ADcgAiADQQ9xOgA2IAIgAS0AHCIDQQR2OgA5IAIgA0EPcToAOCACIAEtAB0iA0EEdjoAOyACIANBD3E6ADogAiABLQAeIgNBBHY6AD0gAiADQQ9xOgA8IAIgAS0AHyIBQQR2OgA/IAIgAUEPcToAPgNAIAIgBWoiCCAGIAZBCGoiAUHwAXFrOgAAIAhBAWoiAyADLQAAIAHAQQR1aiIBOgAAIAVBPkcEQCADIAEgAUEIaiIDQfABcWs6AAAgCEECaiIBIAEtAAAgA8BBBHVqIgY6AAAgBUECaiEFDAELCyAEQSBqJAAgAkHgAGpCADcDACACQdgAakIANwMAIAJB0ABqQgA3AwAgAkHIAGpCADcDAEEAIQEgAkHwAGpBoOPAACkCACIcNwMAIAJB+ABqQajjwAApAgAiHTcDACACQYABakGw48AAKQIAIh43AwAgAkGIAWpBuOPAACkCACIbNwMAIAJBmAFqIBw3AwAgAkGgAWogHTcDACACQagBaiAeNwMAIAJBsAFqIBs3AwAgAkIANwNAIAJBmOPAACkCACIbNwNoIAIgGzcDkAEgAkHYAWpCADcDACACQdABakIANwMAIAJByAFqQgA3AwAgAkHAAWpCADcDACACQgA3A7gBIAJB+ANqIQwgAkHQA2ohDSACQagDaiEOIAJB6AVqIQsgAkHABWohBSACQZAGaiEGIAJBkAFqIQ8gAkHoAGohEANAAkACQCABQcAARwRAIAFBAXENAQwCCyACQegEaiAQQSBqKQIANwMAIAJB4ARqIBBBGGopAgA3AwAgAkHYBGogEEEQaikCADcDACACQdAEaiAQQQhqKQIANwMAIAJB+ARqIA9BCGopAgA3AwAgAkGABWogD0EQaikCADcDACACQYgFaiAPQRhqKQIANwMAIAJBkAVqIA9BIGopAgA3AwAgAiAQKQIANwPIBCACIA8pAgA3A/AEIAJBwARqIAJB4ABqKQMANwMAIAJBuARqIAJB2ABqKQMANwMAIAJBsARqIAJB0ABqKQMANwMAIAJBqARqIAJByABqKQMANwMAIAIgAikDQDcDoAQgAkGYBWoiAyACQaAEahAsQQAiAUUEQCACQYADaiADQaAB/AoAAAsgAkGYBWoiByACQYADaiITIAJB+ANqIgkQNiACQYgHaiIVIAJBqANqIhEgAkHQA2oiChA2IAJB4AFqIhQgCiAJEDYgAkHgBWoiGiACQagHaiIWKQIANwIAIAJB2AVqIgwgAkGgB2oiFykCADcCACACQdAFaiINIAJBmAdqIhgpAgA3AgAgAkHIBWoiDiACQZAHaiIZKQIANwIAIAJB8AVqIg8gAkHoAWoiECkCADcCACACQfgFaiILIAJB8AFqIgUpAgA3AgAgAkGABmoiBiACQfgBaiIIKQIANwIAIAJBiAZqIgQgAkGAAmoiAykCADcCACACIAIpAogHNwLABSACIAIpAuABNwLoBSACQaAEaiISIAdB+AD8CgAAIAcgEhAsIBMgB0GgAfwKAAAgByATIAkQNiAVIBEgChA2IBQgCiAJEDYgGiAWKQIANwIAIAwgFykCADcCACANIBgpAgA3AgAgDiAZKQIANwIAIA8gECkCADcCACALIAUpAgA3AgAgBiAIKQIANwIAIAQgAykCADcCACACIAIpAogHNwLABSACIAIpAuABNwLoBSASIAdB+AD8CgAAIAcgEhAsIBMgB0GgAfwKAAAgByATIAkQNiAVIBEgChA2IBQgCiAJEDYgGiAWKQIANwIAIAwgFykCADcCACANIBgpAgA3AgAgDiAZKQIANwIAIA8gECkCADcCACALIAUpAgA3AgAgBiAIKQIANwIAIAQgAykCADcCACACIAIpAogHNwLABSACIAIpAuABNwLoBSASIAdB+AD8CgAAIAcgEhAsIBQgByACQZAGaiILEDYgAkG4BmogAkHABWoiBSACQegFaiIGEDYgAkHgBmogBiALEDYgFSAHIAUQNiACQagCaiACQdgGaikCADcCACACQaACaiACQdAGaikCADcCACACQZgCaiACQcgGaikCADcCACACQZACaiACQcAGaikCADcCACACQbgCaiACQegGaikCADcCACACQcACaiACQfAGaikCADcCACACQcgCaiACQfgGaikCADcCACACQdACaiACQYAHaikCADcCACACIAIpArgGNwKIAiACIAIpAuAGNwKwAiACQfgCaiAWKQIANwIAIAJB8AJqIBcpAgA3AgAgAkHoAmogGCkCADcCACACQeACaiAZKQIANwIAIAIgAikCiAc3AtgCIAJBQGsgFEGgAfwKAAADQAJAAkAgAUHAAEcEQCABQQFxRQ0BDAILIAAgAkFAa0GgAfwKAAAgAkGwB2okAA8LIAFBAXYhBCABQcAASQRAIAJB4AFqIgMgBEHAB2xBuKHBAGogASACai0AABBiIAJBmAVqIgggAkFAayIEIAMQQCACQYADaiIDIAggCxA2IAJB4AZqIAUgBhA2IAJBiAdqIAYgCxA2IAJBoARqIAggBRA2IBFBIGogAkGAB2opAgA3AgAgEUEYaiACQfgGaikCADcCACARQRBqIAJB8AZqKQIANwIAIBFBCGogAkHoBmopAgA3AgAgESACKQLgBjcCACAKIAIpAogHNwIAIApBCGogAkGQB2opAgA3AgAgCkEQaiACQZgHaikCADcCACAKQRhqIAJBoAdqKQIANwIAIApBIGogAkGoB2opAgA3AgAgCUEgaiACQcAEaikCADcCACAJQRhqIAJBuARqKQIANwIAIAlBEGogAkGwBGopAgA3AgAgCUEIaiACQagEaikCADcCACAJIAIpAqAENwIAIAQgA0GgAfwKAAAgAUEBaiEBDAILIARBIEHA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ASASQgA3AwAgE0IANwMAIBRCADcDACAVQgA3AwAgF0IANwMAIBhCADcDACAZQgA3AwAgDiAAQQhqKQMANwMAIBAgAEEQaikDADcDACARIABBGGopAwA3AwAgA0IANwOAASADIAApAwA3A8ABIAApA4ABIRsgBSAaQeAA/AoAACAAQQA7AYgBIAAgG0IBfDcDgAEgASAKaiEBCyACQYEITwRAIABBnAFqIQ8gACkDgAEhGyADQdAAaiEMIANBwAFqIQkgA0GgAWohCgNAIBtCCoYhHEF/IAJBAXZndkEBaiEEA0AgBCIFQQF2IQQgHCAFQQFrrYNCAFINAAsgBUEKdq0hHAJAAkAgBUGBCE8EQCACIAVPDQFBACAFIAJB7NrAABCYAgALIANBiAFqQgA3AwAgA0GQAWpCADcDACADQZgBakIANwMAIApCADcDACADQagBakIANwMAIANBsAFqQgA3AwAgA0G4AWpCADcDACAJIAApAwA3AwAgCUEIaiIHIABBCGopAwA3AwAgCUEQaiIGIABBEGopAwA3AwAgCUEYaiIIIABBGGopAwA3AwAgA0IANwOAASADQQA7AegBIAMgGzcD4AEgAyAALQCKAToA6gEgA0GAAWogASAFEH4hBCAMIAkpAwA3AwAgDEEIaiAHKQMANwMAIAxBEGogBikDADcDACAMQRhqIAgpAwA3AwAgA0EYaiAEQQhqKQMANwMAIANBIGogBEEQaikDADcDACADQShqIARBGGopAwA3AwAgA0EwaiAEQSBqKQMANwMAIANBOGogBEEoaikDADcDACADQUBrIARBMGopAwA3AwAgA0HIAGogBEE4aikDADcDACADIAQpAwA3AxAgAy0A6gEhBCADLQDpASELIAMgAy0A6AEiDToAeCADIAMpA+ABIhs3A3AgAyAEIAtFckECciIEOgB5IANBiAJqIgsgCCkCADcDACADQYACaiIIIAYpAgA3AwAgA0H4AWoiDiAHKQIANwMAIAMgCSkCADcD8AEgA0HwAWogA0EQaiANIBsgBBAiIAsoAgAhByAIKAIAIQYgDigCACEIIAMoAowCIQsgAygChAIhDSADKAL8ASEOIAMoAvQBIRAgAygC8AEhESAAIAApA4ABEEMgACgCmAEiBEE3Tw0HIAAgBEEBajYCmAEgDyAEQQV0aiIEIAs2AhwgBCAHNgIYIAQgDTYCFCAEIAY2AhAgBCAONgIMIAQgCDYCCCAEIBA2AgQgBCARNgIADAELIANBgAFqIQcgAC0AigEhCyMAQeAAayIEJAAgBEE4aiINQgA3AwAgBEEwaiIOQgA3AwAgBEEoaiIQQgA3AwAgBEEgaiIRQgA3AwAgBEEYaiISQgA3AwAgBEEQaiITQgA3AwAgBEEIaiIUQgA3AwAgBEIANwMAIAEgBSAAIBsgCyAEQcAAEDchCCAEQdgAakIANwMAIARB0ABqQgA3AwAgBEHIAGpCADcDACAEQgA3A0ACQAJAAkACQCAIQQNPBEADQCAIQQV0IgZBwQBPDQIgBCAGIAAgCyAEQUBrIhVBIBBpIghBBXQiBkHBAE8NAyAGQSFPDQQgBgRAIAQgFSAG/AoAAAsgCEECSw0ACwsgByAEKQMANwAAIAdBOGogDSkDADcAACAHQTBqIA4pAwA3AAAgB0EoaiAQKQMANwAAIAdBIGogESkDADcAACAHQRhqIBIpAwA3AAAgB0EQaiATKQMANwAAIAdBCGogFCkDADcAACAEQeAAaiQADAMLQQAgBkHAAEHo2MAAEJgCAAtBACAGQcAAQdjYwAAQmAIAC0EAIAZBIEHI2MAAEJgCAAsgACAAKQOAARBDIAAoApgBIgRBN08NByAAIARBAWo2ApgBIA8gBEEFdGoiBCADKQCAATcAACAEQRhqIANBmAFqKQAANwAAIARBEGogA0GQAWopAAA3AAAgBEEIaiADQYgBaikAADcAACAAIAApA4ABIBxCAYh8EEMgACgCmAEiBEE3Tw0IIAAgBEEBajYCmAEgDyAEQQV0aiIEIAopAAA3AAAgBEEYaiAKQRhqKQAANwAAIARBEGogCkEQaikAADcAACAEQQhqIApBCGopAAA3AAALIAAgACkDgAEgHHwiGzcDgAEgAiAFSQ0IIAEgBWohASACIAVrIgJBgAhLDQALCyACRQ0AIBYgASACEH4aIAAgACkDgAEQQwsgA0GQAmokAA8LIAMgG0IKhjcD8AEgAyACNgIMIANBBDYCFCADQbzawAA2AhAgA0IDNwIcIAMgA0EMaq1CgICAgOAIhDcDkAEgAyADrUKAgICA8AmENwOIASADIANB8AFqrUKAgICA8AmENwOAASADIANBgAFqNgIYIANBEGpB3NrAABC/AgALIAMgDDYCnAEgAyAHNgKYASADIAg2ApQBIAMgCTYCkAEgAyAPNgKMASADIAY2AogBIAMgCzYChAEgAyANNgKAAUGs28AAQSsgA0GAAWpBnNzAAEGM28AAEOYBAAsgAyALNgKMAiADIAc2AogCIAMgDTYChAIgAyAGNgKAAiADIA42AvwBIAMgCDYC+AEgAyAQNgL0ASADIBE2AvABQazbwABBKyADQfABakGc3MAAQYzbwAAQ5gEACyADQShqIANBmAFqKQAANwMAIANBIGogA0GQAWopAAA3AwAgA0EYaiADQYgBaikAADcDACADIAMpAIABNwMQDAILIANBKGogCkEYaikAADcDACADQSBqIApBEGopAAA3AwAgA0EYaiAKQQhqKQAANwMAIAMgCikAADcDEAwBCyAFIAIgAkH82sAAEJgCAAtBrNvAAEErIANBEGpBnNzAAEGM28AAEOYBAAvVKQIRfwF+IwBBwAFrIgMkAAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJ/AkACQAJ/AkACQAJ/AkACQAJAAkAgASgCFCIIIAEoAhAiAkkEQEEAIAJrIQUgCEEFaiEEIAFBDGohCSABKAIMIQgDQAJAAkAgBCAIaiIGQQVrLQAAIgdBCWsOJQEBFhYBFhYWFhYWFhYWFhYWFhYWFhYWARYRFhYWFhYWFhYWFhAACyAHQdsAaw4hERUVFRUVFRUVFRUFFRUVFRUVFQMVFRUVFQQVFRUVFRUSFQsgASAEQQRrNgIUIAUgBEEBaiIEakEFRw0ACwsgA0EFNgKYASADQQhqIAFBDGoQgAIgA0GYAWogAygCCCADKAIMEJICIQEgAEGVgICAeDYCACAAIAE2AgQMHgsgASAEQQRrIgg2AhQgAiAITQ0CIAEgBEEDayIHNgIUAkAgBkEEay0AAEH1AEcNACAHIAggAiACIAhJGyICRg0DIAEgBEECayIINgIUIAZBA2stAABB7ABHDQAgAiAIRg0DIAEgBEEBazYCFCAGQQJrLQAAQewARg0FCyADQQk2ApgBIANBGGogCRCWAiADQZgBaiADKAIYIAMoAhwQkgIMAwsgASAEQQRrIgg2AhQgAiAITQ0EIAEgBEEDayIHNgIUAkAgBkEEay0AAEHyAEcNACAHIAggAiACIAhJGyICRg0FIAEgBEECayIINgIUIAZBA2stAABB9QBHDQAgAiAIRg0FIAEgBEEBazYCFCAGQQJrLQAAQeUARg0HCyADQQk2ApgBIANBKGogCRCWAiADQZgBaiADKAIoIAMoAiwQkgIMBQsgASAEQQRrIgg2AhQgAiAITQ0GIAEgBEEDayIHNgIUAkAgBkEEay0AAEHhAEcNACAHIAggAiACIAhJGyICRg0HIAEgBEECayIINgIUIAZBA2stAABB7ABHDQAgAiAIRg0HIAEgBEEBayIINgIUIAZBAmstAABB8wBHDQAgAiAIRg0HIAEgBDYCFCAGQQFrLQAAQeUARg0JCyADQQk2ApgBIANBOGogCRCWAiADQZgBaiADKAI4IAMoAjwQkgIMBwsgA0EFNgKYASADQRBqIAkQlgIgA0GYAWogAygCECADKAIUEJICCyEBIABBlYCAgHg2AgAgACABNgIEDBkLIABCkoCAgAg3AwAMGAsgA0EFNgKYASADQSBqIAkQlgIgA0GYAWogAygCICADKAIkEJICCyEBIABBlYCAgHg2AgAgACABNgIEDBYLIABCgICAgBg3AwAMFQsgA0EFNgKYASADQTBqIAkQlgIgA0GYAWogAygCMCADKAI0EJICCyEBIABBlYCAgHg2AgAgACABNgIEDBMLIABCgICAgAg3AwAMEgsgASAEQQRrNgIUIANBmAFqIAFBABBxIAMpA5gBIhNCA1ENECAAIAMpA6ABNwMIIABBADYCBCAAIBOnQQJ0KAKU0kA2AgAMEQsgAUEANgIIIAEgBEEEazYCFCADQZgBaiAJIAEQbCADKAKcASEEIAMoApgBIgJBAkYNDiADKAKgASEBIAJBAXEEQEEAIQIgAUEATgRAIAFFBEBBASEIDBALQQEhAiABQQEQgQMiCA0PCyACIAEQ2wIACyAAIAE2AgggACAENgIEIABBjYCAgHg2AgAMEAsgASABLQAkQQFrIgI6ACQgAkH/AXFFDQsgASAEQQRrNgIUIANBiAFqIQsjAEEwayIGJAAgBkEBOgAQIAYgATYCDCAGQQA2AhwgBkKAgICAgAE3AhQgBkEgakEEciIOQQhqIRECQANAAkAgBkEgaiEFIwBBMGsiAiQAAkACQAJ/AkAgBkEMaiIKKAIAIgcoAhQiBCAHKAIQIg1JBEAgB0EMaiEMIAcoAgwhEANAIAQgEGotAAAiD0EJayISQRdLQQEgEnRBk4CABHFFcg0CIAcgBEEBaiIENgIUIAQgDUcNAAsLIAJBAjYCICACQRhqIAdBDGoQgAIgAkEgaiACKAIYIAIoAhwQkgIMAQsgD0HdAEYEQCAFQZWAgIB4NgIADAMLAkACQCAKLQAERQRAIA9BLEcNASAHIARBAWoiBDYCFCAEIA1JBEADQCAEIBBqLQAAIgpBCWsiD0EXS0EBIA90QZOAgARxRXINBCAHIARBAWoiBDYCFCAEIA1HDQALCyACQQU2AiAgAiAMEIACIAJBIGogAigCACACKAIEEJICDAMLIApBADoABAwDCyACQQc2AiAgAkEQaiAMEIACIAJBIGogAigCECACKAIUEJICDAELIApB3QBHDQEgAkEVNgIgIAJBCGogDBCAAiACQSBqIAIoAgggAigCDBCSAgshBCAFQZaAgIB4NgIAIAUgBDYCBAwBCyACQSBqIAcQKiACKAIgQZWAgIB4RgRAIAUgAigCJDYCBCAFQZaAgIB4NgIADAELIAUgAikDIDcDACAFQQhqIAJBKGopAwA3AwALIAJBMGokAAJAAkAgBigCICIFQev///8Hag4CAgABCyALIAYoAiQ2AgQgC0GVgICAeDYCACAGKAIcIgUEQCAGKAIYIQQDQCAEEKkBIARBEGohBCAFQQFrIgUNAAsLIAYoAhQiAkUNAyAGKAIYIAJBBHRBCBD6AgwDCyAGKAIcIgcgBigCFEYEQCMAQRBrIgIkACACQQRqIAZBFGoiBCgCACINIAQoAgRBBCANQQF0Ig0gDUEETRsiDUEIQRAQxgEgAigCBEEBRgRADBULIAIoAgghDCAEIA02AgAgBCAMNgIEIAJBEGokAAsgBigCGCAHQQR0aiICIA4pAgA3AgQgAiAFNgIAIAJBDGogESgCADYCACAGIAdBAWo2AhwMAQsLIAsgBikCFDcCBCALQZSAgIB4NgIAIAtBDGogBkEcaigCADYCAAsgBkEwaiQAIAEgAS0AJEEBajoAJAJAAkACQAJAIAEoAhQiBCABKAIQIgVJBEAgCSgCACECA0ACQCACIARqLQAAIghBCWsOJAAABAQABAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBQMLIAEgBEEBaiIENgIUIAQgBUcNAAsLIANBAjYCtAEgA0HQAGogCRCAAiADQbQBaiADKAJQIAMoAlQQkgIMDAsgCEHdAEYNAgsgA0EWNgK0ASADQcgAaiAJEIACIANBtAFqIAMoAkggAygCTBCSAgwKCyABIARBAWoiBDYCFCAEIAVPDQgDQCACIARqLQAAIgZBCWsiCEEXS0EBIAh0QZOAgARxRXINCCABIARBAWoiBDYCFCAEIAVHDQALDAgLIAEgBEEBajYCFCADQaABaiADQZABaikDADcDACADIAMpA4gBIhM3A5gBQZWAgIB4IQQgE6dBlYCAgHhHDQEMBQsgASABLQAkQQFrIgI6ACQgAkH/AXFFDQMgASAEQQRrNgIUIANBiAFqIQ0jAEHgAGsiByQAIAdBAToAECAHIAE2AgwgB0EANgIcIAdCgICAgIABNwIUIAdBQGtBBHIhECAHQTBqQQRyIQ8CQANAAkAgB0EwaiELIwBBQGoiBSQAAkACfwJAIAdBDGoiDigCACICKAIUIgQgAigCECIMSQRAIAJBDGohBiACKAIMIREDQCAEIBFqLQAAIgpBCWsiEkEXS0EBIBJ0QZOAgARxRXINAiACIARBAWoiBDYCFCAEIAxHDQALCyAFQQM2AjQgBUEoaiACQQxqEIACIAVBNGogBSgCKCAFKAIsEJICDAELIApB/QBGBEAgC0GVgICAeDYCAAwCCwJAAkACQCAOLQAERQRAIApBLEcNASACIARBAWoiBDYCFCAEIAxJBEADQCAEIBFqLQAAIg5BCWsiCkEZSw0FQQEgCnRBk4CABHFFBEAgCkEZRw0GDAULIAIgBEEBaiIENgIUIAQgDEcNAAsLIAVBBTYCNCAFQRBqIAYQgAIgBUE0aiAFKAIQIAUoAhQQkgIMBAsgDkEAOgAEIApBIkYNASAFQRE2AjQgBSAGEIACIAVBNGogBSgCACAFKAIEEJICDAMLIAVBCDYCNCAFQSBqIAYQgAIgBUE0aiAFKAIgIAUoAiQQkgIMAgsgAkEANgIIIAIgBEEBajYCFCAFQTRqIAYgAhBsIAUoAjghBAJAAn8CQCAFKAI0IgZBAkcEQCAFKAI8IQIgBkEBcUUNAUEAIQwgAkEASA0DAkAgAkUEQEEBIQYMAQtBASEMIAJBARCBAyIGRQ0ECyACBEAgBiAEIAL8CgAACyACIQRBjICAgHgMAgsgC0GWgICAeDYCACALIAQ2AgQMBQsgAiEGQY2AgIB4CyEMIAsgAjYCDCALIAY2AgggCyAENgIEIAsgDDYCAAwDCyAMIAIQ2wIACyAOQf0ARwRAIAVBETYCNCAFQQhqIAYQgAIgBUE0aiAFKAIIIAUoAgwQkgIMAQsgBUEVNgI0IAVBGGogBhCAAiAFQTRqIAUoAhggBSgCHBCSAgshAiALQZaAgIB4NgIAIAsgAjYCBAsgBUFAayQAAkACQAJAAkAgBygCMCILQev///8Hag4CBAABCyAHKAI0IQQMAQsgECAPKQIANwIAIBBBCGogD0EIaigCADYCACAHIAs2AkAgB0HQAGohBSMAQSBrIgIkAAJAAkACfwJAIAdBDGooAgAiBCgCFCIGIAQoAhAiDEkEQCAEQQxqIQogBCgCDCEOA0ACQCAGIA5qLQAAQQlrDjIAAAMDAAMDAwMDAwMDAwMDAwMDAwMDAwADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBQMLIAQgBkEBaiIGNgIUIAYgDEcNAAsLIAJBAzYCFCACQQhqIARBDGoQgAIgAkEUaiACKAIIIAIoAgwQkgIMAQsgAkEGNgIUIAIgChCAAiACQRRqIAIoAgAgAigCBBCSAgshBCAFQZWAgIB4NgIAIAUgBDYCBAwBCyAEIAZBAWo2AhQgBSAEECoLIAJBIGokACAHKAJQQZWAgIB4Rw0BIAcoAlQhBCAHQUBrEKgBCyANQZWAgIB4NgIAIA0gBDYCBCAHKAIcIgUEQCAHKAIYIQQDQCAEEKkBIARBEGoQqQEgBEEgaiEEIAVBAWsiBQ0ACwsgBygCFCICRQ0DIAcoAhggAkEFdEEIEPoCDAMLIAdBKGoiBSAHQdgAaikDADcDACAHIAcpA1A3AyAgBygCRCEMIAcpA0ghEyAHKAIcIgYgBygCFEYEQCMAQRBrIgIkACACQQRqIAdBFGoiBCgCACIKIAQoAgRBBCAKQQF0IgogCkEETRsiCkEIQSAQxgEgAigCBEEBRgRADBQLIAIoAgghDiAEIAo2AgAgBCAONgIEIAJBEGokAAsgBygCGCAGQQV0aiICIBM3AgggAiAMNgIEIAIgCzYCACACIAcpAyA3AhAgAkEYaiAFKQMANwIAIAcgBkEBajYCHAwBCwsgDSAHKQIUNwIAIA1BCGogB0EcaigCADYCAAsgB0HgAGokACABIAEtACRBAWo6ACQCQAJ/AkACQAJAIAEoAhQiBCABKAIQIgVJBEAgCSgCACECA0ACQCACIARqLQAAIghBCWsOJAAABAQABAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBQMLIAEgBEEBaiIENgIUIAQgBUcNAAsLIANBAzYCtAEgA0H4AGogCRCAAiADQbQBaiADKAJ4IAMoAnwQkgIMAwsgCEH9AEYNAwsgA0EWNgK0ASADQfAAaiAJEIACIANBtAFqIAMoAnAgAygCdBCSAgwBCyADQRU2ArQBIANBgAFqIAkQgAIgA0G0AWogAygCgAEgAygChAEQkgILIQIgA0GgAWogA0GQAWopAwA3AwAgAyADKQOIASITNwOYASADIAI2AqgBQZWAgIB4IQQgE6dBlYCAgHhGDQIgA0GYAWoQqgEMCQsgASAEQQFqNgIUIANBoAFqIANBkAFqKQMANwMAIAMgAykDiAEiEzcDmAFBlYCAgHghBCATp0GVgICAeEYNBAsgAygClAEhCCADKAKQASEFIAMoAowBIQIgAygCiAEhBAwHCyADKAKcASEIIAIQ4wEgCCECDAYLIAdBMGtB/wFxQQpPBEAgA0EKNgKYASADIAkQgAIgA0GYAWogAygCACADKAIEEJICIQIMBwsgA0GYAWogAUEBEHEgAykDmAEiE0IDUQRAIAAgAygCoAE2AgQgAEGVgICAeDYCAAwMCyAAIAMpA6ABNwMIIABBADYCBCAAIBOnQQJ0KAKU0kA2AgAMCwsgA0EYNgKYASADQegAaiAJEIACIANBmAFqIAMoAmggAygCbBCSAiEBIABBlYCAgHg2AgAgACABNgIEDAoLIAMoApwBIQIMAwsgBkHdAEcNACADQRU2ArQBIANB4ABqIAkQgAIgA0G0AWogAygCYCADKAJkEJICDAELIANBFjYCtAEgA0HYAGogCRCAAiADQbQBaiADKAJYIAMoAlwQkgILIQIgA0GgAWogA0GQAWopAwA3AwAgAyADKQOIASITNwOYASADIAI2AqgBQZWAgIB4IQQgE6dBlYCAgHhHBEAgA0GYAWoQqgEMAQsgAygCnAEhCCACEOMBIAghAgsgBEGVgICAeEYNACAAIAg2AgwgACAFNgIIIAAgAjYCBCAAIAQ2AgAMBQsjAEEgayIIJAACQCACKAIMBEAgAiEBDAELIAhBGGogAkEIaigCADYCACAIIAIpAgA3AxAgCEEIaiABQQxqEJYCIAhBEGogCCgCCCAIKAIMEJICIQEgAkEUQQQQ+gILIAhBIGokACAAQZWAgIB4NgIAIAAgATYCBAwECyADQRg2ApgBIANBQGsgCRCAAiADQZgBaiADKAJAIAMoAkQQkgIhASAAQZWAgIB4NgIAIAAgATYCBAwDCyABBEAgCCAEIAH8CgAACyAAIAE2AgwgACAINgIIIAAgATYCBCAAQYyAgIB4NgIADAILIABBlYCAgHg2AgAgACAENgIEDAELIAAgAygCoAE2AgQgAEGVgICAeDYCAAsgA0HAAWokAA8LIAIoAgggAigCDBDbAgALzhoCDn8DfiMAQcAQayIDJAAgA0EANgIgIANBADYCGAJAAkACQAJAAkACQEECQQEQgQMiBARAIARB6dwBOwAAIANBAjYCuA8gAyAENgK0DyADQQI2ArAPIANBMGoiBEEEciABEO8BIANBAzoAMCADQcgPaiADQRhqIANBsA9qIAQQcAJAAkACQAJAIAMtAMgPDgcDAwMBAgADAAsgA0HID2pBBHIQRAwCCyADKALMDyIERQ0BIAMoAtAPIARBARD6AgwBCyADKALQDyEHIAMoAtQPIgUEQCAHQQRqIQQDQAJAAkACQAJAIARBBGstAAAOBQMDAwECAAsgBBBEDAILIAQoAgAiBkUNASAEQQRqKAIAIAZBARD6AgwBCyAEENsBCyAEQRhqIQQgBUEBayIFDQALCyADKALMDyIERQ0AIAcgBEEYbEEIEPoCCyADQQA2AiwgA0EANgIkQQlBARCBAyIERQ0BIARBCGpB1LfAAC0AADoAACAEQcy3wAApAAA3AAAgA0EJNgK4DyADIAQ2ArQPIANBCTYCsA8gA0EwaiIEQQRyIAFBDGoQ7wEgA0EDOgAwIANByA9qIANBJGogA0GwD2ogBBBwAkACQAJAAkAgAy0AyA8OBwMDAwECAAMACyADQcgPakEEchBEDAILIAMoAswPIgFFDQEgAygC0A8gAUEBEPoCDAELIAMoAtAPIQYgAygC1A8iBQRAIAZBBGohBANAAkACQAJAAkAgBEEEay0AAA4FAwMDAQIACyAEEEQMAgsgBCgCACIBRQ0BIARBBGooAgAgAUEBEPoCDAELIAQQ2wELIARBGGohBCAFQQFrIgUNAAsLIAMoAswPIgFFDQAgBiABQRhsQQgQ+gILQQdBARCBAyIBRQ0CIAFBA2pB2LfAACgAADYAACABQdW3wAAoAAA2AAAgA0EHNgK4DyADIAE2ArQPIANBBzYCsA8gAyACrTcDQCADQgA3AzggA0ECOgAwIANByA9qIANBJGogA0GwD2ogA0EwahBwAkACQAJAAkAgAy0AyA8OBwMDAwECAAMACyADQcgPakEEchBEDAILIAMoAswPIgFFDQEgAygC0A8gAUEBEPoCDAELIAMoAtAPIQIgAygC1A8iBQRAIAJBBGohBANAAkACQAJAAkAgBEEEay0AAA4FAwMDAQIACyAEEEQMAgsgBCgCACIBRQ0BIARBBGooAgAgAUEBEPoCDAELIAQQ2wELIARBGGohBCAFQQFrIgUNAAsLIAMoAswPIgFFDQAgAiABQRhsQQgQ+gILQQJBARCBAyIBRQ0DIAFB9PABOwAAIANBAjYCuA8gAyABNgK0DyADQQI2ArAPIANBPGogA0EsaigCADYCACADIAMpAiQ3AjQgA0EFOgAwIANByA9qIANBGGogA0GwD2ogA0EwahBwAkACQAJAAkAgAy0AyA8OBwMDAwECAAMACyADQcgPakEEchBEDAILIAMoAswPIgFFDQEgAygC0A8gAUEBEPoCDAELIAMoAtAPIQIgAygC1A8iBQRAIAJBBGohBANAAkACQAJAAkAgBEEEay0AAA4FAwMDAQIACyAEEEQMAgsgBCgCACIBRQ0BIARBBGooAgAgAUEBEPoCDAELIAQQ2wELIARBGGohBCAFQQFrIgUNAAsLIAMoAswPIgFFDQAgAiABQRhsQQgQ+gILIANBDGogA0EgaigCADYCACADIAMpAhg3AgQgA0EFOgAAQYABQQEQgQMiAUUNBCADIAE2AjQgA0GAATYCMCADIANBMGo2ArAPIAFB+wA6AAAgA0EBNgI4AkACQAJAIAMoAgwiDkUEQCABQf0AOgABIANBAjYCOAwBCyADQYACNgLIDyADIANBsA9qIgE2AswPIAMoAgQiBQR/QQAhBCADKAIIIQcDQAJAIAQEQCAHIQkMAQtBACEJAkAgB0UNACAHIgRBB3EiAQRAA0AgBEEBayEEIAUoApgDIQUgAUEBayIBDQALCyAHQQhJDQADQCAFKAKYAygCmAMoApgDKAKYAygCmAMoApgDKAKYAygCmAMhBSAEQQhrIgQNAAsLIAUhBEEAIQULAkAgBC8BkgMgCUsEQCAEIQEMAQsDQCAEKAKIAiIBRQ0NIAVBAWohBSAELwGQAyEJIAkgASIELwGSA08NAAsLIAlBAWohBwJAIAVFBEAgASEEDAELIAEgB0ECdGpBmANqIQICQCAFQQdxIgdFBEAgBSEGDAELIAUhBgNAIAZBAWshBiACKAIAIgRBmANqIQIgB0EBayIHDQALC0EAIQcgBUEISQ0AA0AgAigCACgCmAMoApgDKAKYAygCmAMoApgDKAKYAygCmAMiBEGYA2ohAiAGQQhrIgYNAAsLAn8gASAJQQxsakGMAmohBiABIAlBGGxqIQUjAEEQayILJAAgA0HID2oiCS0AAEEBRwRAIAYoAgghAiAGKAIEIQEgCSgCBCENIAktAAFBAUcEQCANKAIAIgwoAgAgDCgCCCIGRgRAIAwgBkEBQQFBARDJASAMKAIIIQYLIAwgBkEBajYCCCAMKAIEIAZqQSw6AAALIAlBAjoAASALIA0gASACEGcCfyALLQAAQQRHBEAgCyALKQMANwMIIAtBCGoQpgIMAQsgDSgCACICKAIAIAIoAggiAUYEQCACIAFBAUEBQQEQyQEgAigCCCEBCyACIAFBAWo2AgggAigCBCABakE6OgAAIAUgDRAtCyALQRBqJAAMAQtB3dTAAEEoQYjVwAAQmQIACyIFDQNBACEFIA5BAWsiDg0ACyADKALIDyIBQQFxDQkgAUGA/gNxRQ0BIAMoAswPBSABCygCACIBKAIAIAEoAggiBUYEQCABIAVBAUEBQQEQyQEgASgCCCEFCyABIAVBAWo2AgggASgCBCAFakH9ADoAAAsgAygCNCEFIAMoAjAiD0GAgICAeEYNASADKAI4IQQgA0GAEGpCADcDACADQfgPakIANwMAIANB8A9qQgA3AwAgA0HoD2pCADcDACADQeAPakIANwMAIANB2A9qQgA3AwAgA0HQD2pCADcDACADQZAQakHotsAAKQIAIhM3AwAgA0GYEGpB8LbAACkCACISNwMAIANBoBBqQfi2wAApAgAiETcDACADQThqIBM3AwAgA0FAayASNwMAIANByABqIBE3AwAgA0IANwPIDyADQeC2wAApAgAiETcDiBAgAyARNwMwIANB0ABqIANByA9qIgJB4AD8CgAAIANBtwFqQQA2AAAgA0EANgLIASADQgA3A8ABIANCADcDsAEgA0EwaiIBIAUgBBApIANBwA9qIgtCADcDACADQbgPaiIMQgA3AwAgA0IANwOwDyMAQSBrIgQkAAJAIAEpA5ABUARAIAIgARAwIAJBADoAcCAEQSBqJAAMAQsgBEIANwIUIARCgYCAgMAANwIMIARBzNnAADYCCCABQZABakGI18AAIARBCGpB1NnAABCnAgALIANBsA9qIQFBGCEKIwBBQGoiCCQAAkACQCACIgQtAHAiAgR/IAggBEFAayAEIAQtAGggBCkDYCIRIAQtAGlBCHIQISACQcAASw0BQRhBwAAgAmsiBiAGQRhPGyIGBEAgASACIAhqIAb8CgAACyAEIAIgBmoiAjoAcCABIAZqIQFBGCAGayEKIAJB/wFxQcAARgR/IARBADoAcCAEIBFCAXw3A2BBAAUgAgsFQQALIQ0gCkE/SwRAIARBQGshDkEAIApBQHEiCWshECAELQBpQQhyIQcgBC0AaCEGIAQpA2AiESESIAEhAgNAIAggDiAEIAYgEiAHECEgAkE4aiAIQThqKQAANwAAIAJBMGogCEEwaikAADcAACACQShqIAhBKGopAAA3AAAgAkEgaiAIQSBqKQAANwAAIAJBGGogCEEYaikAADcAACACQRBqIAhBEGopAAA3AAAgAkEIaiAIQQhqKQAANwAAIAIgCCkAADcAACASQgF8IRIgAkFAayECIBBBQGsiEA0ACyAEIBEgCkEGdq18NwNgIApBP3EhCiABIAlqIQELAkAgCkUNACAIIARBQGsgBCAELQBoIAQpA2AgBC0AaUEIchAhIA1B/wFxIgJBwABNBEBBwAAgAmsiBiAKIAYgCkkbIgYEQCABIAIgCGogBvwKAAALIAQgBC0AcCAGaiIBOgBwIAFB/wFxQcAARw0BIARBADoAcCAEIAQpA2BCAXw3A2AMAQsMAQsgCEFAayQADAELIAJBwABBwABBpNfAABCYAgALIABBEGogCykDADcAACAAQQhqIAwpAwA3AAAgACADKQOwDzcAACAPBEAgBSAPQQEQ+gILIANBBHIQRCADQcAQaiQADwsgAygCMCIARQ0AIAMoAjQgAEEBEPoCCyADIAU2AjBBkLfAAEErIANBMGpBgLfAAEG8t8AAEOYBAAtBAUECENsCAAtBAUEJENsCAAtBAUEHENsCAAtBAUECENsCAAtBAUGAARDbAgALQfC4wABBKEGYucAAEJkCAAtB/LfAABD8AgALow8CKH8IfiMAQfACayICJAAgAkGgAmoiAyABEFAgAiACKQPoAiACKQPgAiACKQPYAiACKQPQAiACKQPIAiACKQPAAiIqQhqIfCIsQhmIfCIrQhqIfCIvQhmIfCIwQhqIfCItQhmIQhN+IAIpA6ACIi5C////H4N8IjGnQf///x9xIgQ2AgggAiACKQOoAiAuQhqIfCIuQv///w+DIDFCGoh8pyIINgIMIAIgLEL///8PgyAqQv///x+DIAIpA7gCIAIpA7ACIC5CGYh8IipCGoh8IixCGYh8Ii5CGoh8pyIJNgIcIAIgLqdB////H3EiBTYCGCACICynQf///w9xIgo2AhQgAiAvp0H///8PcSILNgIkIAIgLadB////D3EiDDYCLCACICqnQf///x9xIg02AhAgAiArp0H///8fcSIGNgIgIAIgMKdB////H3EiBzYCKCADIAFBKGoQUCACIAIpA+gCIAIpA+ACIAIpA9gCIAIpA9ACIAIpA8gCIAIpA8ACIipCGoh8IixCGYh8IitCGoh8Ii9CGYh8IjBCGoh8Ii1CGYhCE34gAikDoAIiLkL///8fg3wiMadB////H3EiDjYCMCACIAIpA6gCIC5CGoh8Ii5C////D4MgMUIaiHynIg82AjQgAiAsQv///w+DICpC////H4MgAikDuAIgAikDsAIgLkIZiHwiKkIaiHwiLEIZiHwiLkIaiHynIhA2AkQgAiAup0H///8fcSIRNgJAIAIgLKdB////D3EiEjYCPCACIC+nQf///w9xIhM2AkwgAiAtp0H///8PcSIUNgJUIAIgKqdB////H3EiFTYCOCACICunQf///x9xIhY2AkggAiAwp0H///8fcSIXNgJQIAMgAUHQAGoQUCACIAIpA9ACQgGGIAIpA8gCQgGGIAIpA8ACQgGGIipCGoh8IixCGYh8IiunQf///x9xNgJwIAIgAikDsAJCAYYgAikDqAJCAYYgAikDoAJCAYYiL0IaiHwiMEIZiHwiLadB////H3E2AmAgAiACKQPYAkIBhiArQhqIfCIrp0H///8PcTYCdCACIAIpA7gCQgGGIC1CGoh8Ii2nQf///w9xNgJkIAIgAikD4AJCAYYgK0IZiHwiK6dB////H3E2AnggAiAsQv///w+DICpC/v//H4MgLUIZiHwiKkIaiHw+AmwgAiAqp0H///8fcTYCaCACIAIpA+gCQgGGICtCGoh8IiqnQf///w9xNgJ8IAIgMEL///8PgyAqQhmIQhN+IC9C/v//H4N8IipCGoh8PgJcIAIgKqdB////H3E2AlggASgCKCEYIAEoAgAhGSABKAIsIRogASgCBCEbIAEoAjAhHCABKAIIIR0gASgCNCEeIAEoAgwhHyABKAI4ISAgASgCECEhIAEoAjwhIiABKAIUISMgASgCQCEkIAEoAhghJSABKAJEISYgASgCHCEnIAEoAkghKCABKAIgISkgAiABKAJMIAEoAiRqNgKkASACICggKWo2AqABIAIgJiAnajYCnAEgAiAkICVqNgKYASACICIgI2o2ApQBIAIgICAhajYCkAEgAiAeIB9qNgKMASACIBwgHWo2AogBIAIgGiAbajYChAEgAiAYIBlqNgKAASADIAJBgAFqEFAgAiACKQPQAiACKQPIAiACKQPAAiIqQhqIfCIsQhmIfCIrp0H///8fcTYCwAEgAiACKQOwAiACKQOoAiACKQOgAiIvQhqIfCIwQhmIfCItp0H///8fcTYCsAEgAiACKQPYAiArQhqIfCIrp0H///8PcTYCxAEgAiACKQO4AiAtQhqIfCItp0H///8PcTYCtAEgAiACKQPgAiArQhmIfCIrp0H///8fcTYCyAEgAiAsQv///w+DICpC////H4MgLUIZiHwiKkIaiHw+ArwBIAIgKqdB////H3E2ArgBIAIgAikD6AIgK0IaiHwiKqdB////D3E2AswBIAIgMEL///8PgyAqQhmIQhN+IC9C////H4N8IipCGoh8PgKsASACICqnQf///x9xNgKoASACQfABaiIBIAcgF2o2AgAgAkHoAWoiByAGIBZqNgIAIAJB4AFqIgYgBSARajYCACACQdgBaiIFIA0gFWo2AgAgAiAMIBRqNgL0ASACIAsgE2o2AuwBIAIgCSAQajYC5AEgAiAKIBJqNgLcASACIAggD2o2AtQBIAIgBCAOajYC0AEgAkH4AWoiBCACQTBqIAJBCGoQeiAAIAJBqAFqIAJB0AFqEHogAyACQdgAaiAEEHogAEHIAGogASkCADcCACAAQUBrIAcpAgA3AgAgAEE4aiAGKQIANwIAIABBMGogBSkCADcCACAAIAIpAtABNwIoIAAgAikC+AE3AlAgAEHYAGogAkGAAmopAgA3AgAgAEHgAGogAkGIAmopAgA3AgAgAEHoAGogAkGQAmopAgA3AgAgAEHwAGogAkGYAmopAgA3AgAgAEGYAWogAkHAAmopAgA3AgAgAEGQAWogAkG4AmopAgA3AgAgAEGIAWogAkGwAmopAgA3AgAgAEGAAWogAkGoAmopAgA3AgAgACACKQKgAjcCeCACQfACaiQAC50OAQp/IwBBEGsiCCQAAkACQAJAAkACQAJAAkACQCAALQAAQQFrDgUBAgMEBQALIAEoAgAiACgCACAAKAIIIgJrQQNNBEAgACACQQRBAUEBEMkBIAAoAgghAgsgACACQQRqNgIIIAAoAgQgAmpB7uqx4wY2AAAMBQsgASgCACEBIAAtAAFFBEAgASgCACABKAIIIgBrQQRNBEAgASAAQQVBAUEBEMkBIAEoAgghAAsgASAAQQVqNgIIIAEoAgQgAGoiAEGw0sAAKAAANgAAIABBBGpBtNLAAC0AADoAAAwGCyABKAIAIAEoAggiAGtBA00EQCABIABBBEEBQQEQyQEgASgCCCEACyABIABBBGo2AgggASgCBCAAakH05NWrBjYAAAwECyAAQQhqIAEQPAwDCyAIIAEgACgCCCAAKAIMEGcgCC0AAEEERg0DIAggCCkDADcDCCAIQQhqEKYCIQIMAwsgACgCDCEEIAAoAgghByABKAIAIgAoAgAgACgCCCICRgRAIAAgAkEBQQFBARDJASAAKAIIIQILIAAgAkEBajYCCCAAKAIEIAJqQdsAOgAAAkAgBEUNACAHIAEQLSICDQMgBEEBRg0AIARBGGxBGGshBiAHQRhqIQMDQCAAKAIIIgIgACgCAEYEQCAAIAJBAUEBQQEQyQEgACgCCCECCyAAIAJBAWo2AgggACgCBCACakEsOgAAIAMgARAtIgINBCADQRhqIQMgBkEYayIGDQALCyAAKAIIIgIgACgCAEYEQCAAIAJBAUEBQQEQyQEgACgCCCECCyAAIAJBAWo2AgggACgCBCACakHdADoAAAwBCyAAKAIMIQogASgCACIFKAIAIAUo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CyAGIBN6p0EDdiACaiAKcSICaiwAAEEATgRAIAYpAwBCgIGChIiQoMCAf4N6p0EDdiECCyACIAdrIAUgB2tzIApxQQhPBEAgAiAGaiIHLQAAIAcgEEEZdiIHOgAAIAkgAkEIayAKcWogBzoAACAGIAJBA3RrQQhrIQJB/wFGDQIgAigAACEHIAIgBCgAADYAACAEIAc2AAAgBCgABCEHIAQgAigABDYABCACIAc2AAQMAQsLIA8gEEEZdiICOgAAIAkgBUEIayAKcWogAjoAAAwBCyAPQf8BOgAAIAkgBUEIayAKcWpB/wE6AAAgAiAEKQAANwAACyAIIAggDEkiAmohBCACDQALCyABIA4gDWs2AghBgYCAgHghCQwBCwwBCyAAIA42AgQgACAJNgIAIANBQGskAA8LIANBADYCECADQQE2AgQgA0G4wMAANgIAIANCBDcCCCADQcDAwAAQvwIAC8cMAhJ/BH4jAEHQAWsiAiQAAkAgASgCmAEiBEUEQCAAIAEpA2A3A0AgACABKQMgNwMAIABByABqIAFB6ABqKQMANwMAIABB0ABqIAFB8ABqKQMANwMAIABB2ABqIAFB+ABqKQMANwMAIABBCGogAUEoaikDADcDACAAQRBqIAFBMGopAwA3AwAgAEEYaiABQThqKQMANwMAIABBIGogAUFAaykDADcDACAAQShqIAFByABqKQMANwMAIABBMGogAUHQAGopAwA3AwAgAEE4aiABQdgAaikDADcDACABLQCKASEEIAEtAIkBIQMgACABLQCIAToAaCAAIAEpA4ABNwNgIAAgBCADRXJBAnI6AGkMAQsCQAJAAkACQCABLQCIASIHIAEtAIkBIgZyBEAgAkG4AWogAUHoAGopAwA3AwAgAkHAAWogAUHwAGopAwA3AwAgAkHIAWogAUH4AGopAwA3AwAgAkH4AGogAUEoaikDADcDACACQYABaiABQTBqKQMANwMAIAJBiAFqIAFBOGopAwA3AwAgAkGQAWogAUFAaykDADcDACACQZgBaiABQcgAaikDADcDACACQaABaiABQdAAaikDADcDACACQagBaiABQdgAaikDADcDACACIAEpA2A3A7ABIAIgASkDIDcDcCABLQCKASEDIAEpA4ABIRQgAiACQfAAakHgAPwKAAAgAiADIAZFckECciIFOgBpIAIgBzoAaCACIBQ3A2AgA0EEciEGIAQhAwwBCyAEQQJrIQMgBEEBRg0DIAEtAIoBIQggAkEYaiIHIAFBnAFqIgUgA0EFdGoiBkEYaikAADcDACACQRBqIgkgBkEQaikAADcDACACQQhqIgogBkEIaikAADcDACACQSBqIgsgBSAEQQV0akEgayIFKQAANwMAIAJBKGoiDCAFQQhqKQAANwMAIAJBMGoiDSAFQRBqKQAANwMAIAJBOGoiDiAFQRhqKQAANwMAIAIgBikAADcDACACQcgBaiABQRhqKQMANwMAIAJBwAFqIAFBEGopAwA3AwAgAkG4AWogAUEIaikDADcDACACIAEpAwA3A7ABIAJBqAFqIA4pAwA3AwAgAkGgAWogDSkDADcDACACQZgBaiAMKQMANwMAIAJBkAFqIAspAwA3AwAgAkGIAWogBykDADcDACACQYABaiAJKQMANwMAIAJB+ABqIAopAwA3AwAgAiACKQMANwNwIAIgAkHwAGpB4AD8CgAAIAIgCEEEciIGOgBpQcAAIQcgAkHAADoAaCACQgA3A2AgBiEFIANFDQELIANBAWsiCCAETw0BIAJBiAFqIgkgAkFAayIEQRhqIgopAgA3AwAgAkGAAWoiCyAEQRBqIgwpAgA3AwAgAkH4AGoiDSAEQQhqIg4pAgA3AwAgAiAEKQIANwNwIAJB8ABqIAIgByAUIAUQIiANKQMAIRQgCykDACEVIAkpAwAhFiACKQNwIRcgAkEIaiIHIAFBnAFqIAhBBXRqIgVBCGopAgA3AwAgAkEQaiIPIAVBEGopAgA3AwAgAkEYaiIQIAVBGGopAgA3AwAgBCABKQMANwMAIA4gAUEIaiIRKQMANwMAIAwgAUEQaiISKQMANwMAIAogAUEYaiITKQMANwMAIAIgFjcDOCACIBU3AzAgAiAUNwMoIAIgFzcDICACIAUpAgA3AwAgAiAGOgBpIAJBwAA6AGggAkIANwNgIAhFDQAgA0EFdCABakHcAGohAwNAIAkgCikCADcDACALIAwpAgA3AwAgDSAOKQIANwMAIAIgBCkCADcDcCACQfAAaiACQcAAQgAgBhAiIA0pAwAhFCALKQMAIRUgCSkDACEWIAIpA3AhFyAHIANBCGopAgA3AwAgDyADQRBqKQIANwMAIBAgA0EYaikCADcDACAEIAEpAwA3AwAgDiARKQMANwMAIAwgEikDADcDACAKIBMpAwA3AwAgAiAWNwM4IAIgFTcDMCACIBQ3AyggAiAXNwMgIAIgAykCADcDACACIAY6AGkgAkHAADoAaCACQgA3A2AgA0EgayEDIAhBAWsiCA0ACwsgACACQfAA/AoAAAwCCyAIIARBiNnAABDyAQALIANBAUH42MAAEPIBAAsgAkHQAWokAAvTCwIkfgl/IwBBMGsiJyQAICcgAigCACIorSIFIAEoAgAiKa0iBH4iC0Kb/NGSAX5C/////wGDIglC0rHMBH4gASgCBCIqrSIGIAV+IAIoAgQiLq0iByAEfnwiIXwgCULtp9fnAX4gC3xCHYh8IhhCm/zRkgF+Qv////8BgyIKQhSGIAIoAgwiK60iDSAGfiABKAIIIiytIg4gAigCCCItrSIIfnwgASgCDCIvrSIPIAd+fCACNQIQIgMgBH58IAE1AhAiDCAFfnwiIn0gKSABKAIUIilqrSIQIAN+fCAoIAIoAhQiKGqtIhEgDH58ICwgASgCHCIsaq0iEiAtIAIoAhwiLWqtIhN+fCArIAIoAiAiK2qtIhQgKiABKAIYIipqrSIVfnwgASgCICIBIC9qrSIWIAIoAhgiAiAuaq0iF358ICutIhkgKq0iGn4gLK0iGyAtrSIcfnwgAa0iHSACrSIefnwiI30gCCAPfiANIA5+fCADIAZ+fCAHIAx+fCAorSIfICmtIiB+fSIkIApCzQJ+IAt9fCAQIBF+fCAEIAh+IAYgB358IAUgDn58IiUgCUKW65zvAX58IApC0rHMBH58IApC7afX5wF+IBh8Qh2IfCIYQpv80ZIBfkL/////AYMiC0LF+s7vAX58IAcgDn4gBiAIfnwgBCANfnwgBSAPfnwiJiAJQsX6zu8BfnwgCkKW65zvAX58IAtC0rHMBH58IAtC7afX5wF+IBh8Qh2IfCIEQpv80ZIBfkL/////AYMiBUKW65zvAX58IApCxfrO7wF+IAlCzQJ+fCAifCALQpbrnO8BfnwgBULSscwEfnwgBULtp9fnAX4gBHxCHYh8IgRCm/zRkgF+Qv////8BgyIKQtKxzAR+fCAKQu2n1+cBfiAEfEIdiHwiBkKb/NGSAX5C/////wGDIgRCzQJ+fCADIA5+IA0gD358IAggDH58IBogH34gHiAgfnx9Ig4gECAXfiAhfSARIBV+fHwgC0LNAn58IAVCxfrO7wF+fCAKQpbrnO8BfnwgBELSscwEfnwgBELtp9fnAX4gBnxCHYh8IgdCm/zRkgF+Qv////8BgyIGQsX6zu8BfnwgDCANfiADIA9+fCAcICB+IBogHn58IBsgH358fSINIBUgF34gJX0gECATfnwgESASfnx8IAVCzQJ+fCAKQsX6zu8BfnwgBEKW65zvAX58IAZC0rHMBH58IAZC7afX5wF+IAd8Qh2IfCIIQpv80ZIBfkL/////AYMiB0KW65zvAX58IAlCFIYgJn0gAyAMfnwgEyAVfnwgEiAXfnwgECAUfnwgESAWfnwgGyAefiAaIBx+fCAZICB+fCAdIB9+fCIPfSAKQs0CfnwgBELF+s7vAX58IAZCluuc7wF+fCAHQtKxzAR+fCAHQu2n1+cBfiAIfEIdiHwiCEKb/NGSAX5C/////wGDIglC0rHMBH58IAlC7afX5wF+IAh8Qh2IfCIIp0H/////AXE2AgwgJyAMIBd+ICR9IAMgFX58IAtCFIZ8IBIgFH58IBMgFn58IBwgHX4gGSAbfnwiC30gBkLNAn58IAdCxfrO7wF+fCAJQpbrnO8BfnwgCEIdiHwiCKdB/////wFxNgIQICcgDCATfiADIBJ+fCAOIBkgHX4iEHx9IBQgFn58IAVCFIZ8IAdCzQJ+fCAJQsX6zu8BfnwgCEIdiHwiBadB/////wFxNgIUICcgAyAWfiAMIBR+fCANfSAKQhSGfCAJQs0CfnwgBUIdiHwiA6dB/////wFxNgIYICcgBEIUhiAPfCADQh2IfCIDp0H/////AXE2AhwgJyAGQhSGICN8IANCHYh8IgOnQf////8BcTYCICAnIAdCFIYgC3wgA0IdiHwiA6dB/////wFxNgIkICcgCUIUhiAQfCADQh2IfCIDQh2IPgIsICcgA6dB/////wFxNgIoIAAgJ0EMakHg4cAAEGggJ0EwaiQAC/sKAgp/AX4gBEUEQCAAQQA2AjwgACADNgI4IAAgAjYCNCAAIAE2AjAgAEEAOgAOIABBgQI7AQwgACACNgIIIABCADcDAA8LQQEhDEEBIQsCQAJAAkACQAJAAkACQAJAIARBAUcEQEEBIQhBASEHA0AgBiAKaiIFIARPDQICQCADIAhqLQAAIgkgAyAFai0AACIFSQRAIAYgB2pBAWoiByAKayEMQQAhBgwBCyAFIAlHBEBBASEMQQAhBiAHIQogB0EBaiEHDAELQQAgBkEBaiIFIAUgDEYiCRshBiAFQQAgCRsgB2ohBwsgBiAHaiIIIARJDQALQQEhCEEBIQdBACEGQQAhCQNAIAYgCWoiBSAETw0DAkAgAyAIai0AACINIAMgBWotAAAiBUsEQCAGIAdqQQFqIgcgCWshC0EAIQYMAQsgBSANRwRAQQEhC0EAIQYgByEJIAdBAWohBwwBC0EAIAZBAWoiBSAFIAtGIg0bIQYgBUEAIA0bIAdqIQcLIAYgB2oiCCAESQ0ACwsgBCAKIAkgCSAKSSIHGyINSQ0CIAwgCyAHGyIHIA1qIgUgB0kgBCAFSXINAwJ/IAMgAyAHaiANEIMCBEAgBEEDcSEIAkAgBEEBa0EDSQRAQQAhBwwBCyAEQXxxIQxBACEHA0BCASADIAdqIgVBA2oxAACGQgEgBTEAAIYgD4RCASAFQQFqMQAAhoRCASAFQQJqMQAAhoSEIQ8gDCAHQQRqIgdHDQALCyAIBEAgAyAHaiEGA0BCASAGMQAAhiAPhCEPIAZBAWohBiAIQQFrIggNAAsLIAQgDWsiByANIAcgDUsbQQFqIQdBfyEJIA0hDEF/DAELQQEhCkEAIQZBASEFQQAhDANAIAQgBSIJIAZqIghLBEAgBCAGayAFQX9zaiIFIARPDQcgBCAGQX9zaiAMayILIARPDQgCQCADIAVqLQAAIgUgAyALai0AACILSQRAIAhBAWoiBSAMayEKQQAhBgwBCyAFIAtHBEAgCUEBaiEFQQAhBkEBIQogCSEMDAELQQAgBkEBaiIFIAUgCkYiCxshBiAFQQAgCxsgCWohBQsgByAKRw0BCwtBASEKQQAhBkEBIQVBACELA0AgBCAFIgkgBmoiDksEQCAEIAZrIAVBf3NqIgUgBE8NCSAEIAZBf3NqIAtrIgggBE8NCgJAIAMgBWotAAAiBSADIAhqLQAAIghLBEAgDkEBaiIFIAtrIQpBACEGDAELIAUgCEcEQCAJQQFqIQVBACEGQQEhCiAJIQsMAQtBACAGQQFqIgUgBSAKRiIIGyEGIAVBACAIGyAJaiEFCyAHIApHDQELCyAEIAsgDCALIAxLG2shDAJAIAdFBEBBACEHQQAhCQwBCyAHQQNxIQVBACEJAkAgB0EESQRAQQAhCAwBCyAHQXxxIQpBACEIA0BCASADIAhqIgZBA2oxAACGQgEgBjEAAIYgD4RCASAGQQFqMQAAhoRCASAGQQJqMQAAhoSEIQ8gCiAIQQRqIghHDQALCyAFRQ0AIAMgCGohBgNAQgEgBjEAAIYgD4QhDyAGQQFqIQYgBUEBayIFDQALCyAECyEGIAAgBDYCPCAAIAM2AjggACACNgI0IAAgATYCMCAAIAY2AiggACAJNgIkIAAgAjYCICAAQQA2AhwgACAHNgIYIAAgDDYCFCAAIA02AhAgACAPNwMIIABBATYCAA8LIAUgBEHg0MQAEPIBAAsgBSAEQeDQxAAQ8gEAC0EAIA0gBEGg0cQAEJgCAAsgByAFIARBkNHEABCYAgALIAUgBEHw0MQAEPIBAAsgCyAEQYDRxAAQ8gEACyAFIARB8NDEABDyAQALIAggBEGA0cQAEPIBAAuHDAIGfwZ+IwBBoAZrIgIkACACQdAFaiIFIAEQUCACIAIpA4AGIAIpA/gFIAIpA/AFIghCGoh8IgtCGYh8IgmnQf///x9xNgIYIAIgAikD4AUgAikD2AUgAikD0AUiDEIaiHwiDUIZiHwiCqdB////H3E2AgggAiACKQOIBiAJQhqIfCIJp0H///8PcTYCHCACIAIpA+gFIApCGoh8IgqnQf///w9xNgIMIAIgAikDkAYgCUIZiHwiCadB////H3E2AiAgAiALQv///w+DIAhC////H4MgCkIZiHwiCEIaiHw+AhQgAiAIp0H///8fcTYCECACIAIpA5gGIAlCGoh8IginQf///w9xNgIkIAIgDUL///8PgyAIQhmIQhN+IAxC////H4N8IghCGoh8PgIEIAIgCKdB////H3E2AgAgBSACEFAgAiACKQOABiACKQP4BSACKQPwBSIIQhqIfCILQhmIfCIJp0H///8fcTYCwAUgAiACKQPgBSACKQPYBSACKQPQBSIMQhqIfCINQhmIfCIKp0H///8fcTYCsAUgAiACKQOIBiAJQhqIfCIJp0H///8PcTYCxAUgAiACKQPoBSAKQhqIfCIKp0H///8PcTYCtAUgAiACKQOQBiAJQhmIfCIJp0H///8fcTYCyAUgAiALQv///w+DIAhC////H4MgCkIZiHwiCEIaiHw+ArwFIAIgCKdB////H3E2ArgFIAIgAikDmAYgCUIaiHwiCKdB////D3E2AswFIAIgDUL///8PgyAIQhmIQhN+IAxC////H4N8IghCGoh8PgKsBSACIAinQf///x9xNgKoBSAFIAJBqAVqIgYQUCACIAIpA4AGIAIpA/gFIAIpA/AFIghCGoh8IgtCGYh8IgmnQf///x9xNgJAIAIgAikD4AUgAikD2AUgAikD0AUiDEIaiHwiDUIZiHwiCqdB////H3E2AjAgAiACKQOIBiAJQhqIfCIJp0H///8PcTYCRCACIAIpA+gFIApCGoh8IgqnQf///w9xNgI0IAIgAikDkAYgCUIZiHwiCadB////H3E2AkggAiALQv///w+DIAhC////H4MgCkIZiHwiCEIaiHw+AjwgAiAIp0H///8fcTYCOCACIAIpA5gGIAlCGoh8IginQf///w9xNgJMIAIgDUL///8PgyAIQhmIQhN+IAxC////H4N8IghCGoh8PgIsIAIgCKdB////H3E2AiggAkHQAGoiBCABIAJBKGoQNiACQfgAaiIBIAIgBBA2IAUgARBQIAIgAikDgAYgAikD+AUgAikD8AUiCEIaiHwiC0IZiHwiCadB////H3E2ArgBIAIgAikD4AUgAikD2AUgAikD0AUiDEIaiHwiDUIZiHwiCqdB////H3E2AqgBIAIgAikDiAYgCUIaiHwiCadB////D3E2ArwBIAIgAikD6AUgCkIaiHwiCqdB////D3E2AqwBIAIgAikDkAYgCUIZiHwiCadB////H3E2AsABIAIgC0L///8PgyAIQv///x+DIApCGYh8IghCGoh8PgK0ASACIAinQf///x9xNgKwASACIAIpA5gGIAlCGoh8IginQf///w9xNgLEASACIA1C////D4MgCEIZiEITfiAMQv///x+DfCIIQhqIfD4CpAEgAiAIp0H///8fcTYCoAEgAkHIAWoiAyAEIAJBoAFqEDYgAkHwAWoiBCADQQUQTCACQZgCaiIBIAQgAxA2IAJBwAJqIgMgAUEKEEwgAkHoAmoiBCADIAEQNiACQZADaiIDIARBFBBMIAJBuANqIgcgAyAEEDYgAkHgA2oiAyAHQQoQTCACQYgEaiIEIAMgARA2IAJBsARqIgMgBEEyEEwgAkHYBGoiASADIAQQNiACQYAFaiIDIAFB5AAQTCAGIAMg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fnwgECAafnwgGyAgfnwgAyAOfnwgCSAYfnwgBiALfnwgBSAHfnwgCCAMfnwgCiAdfnwgJUIaiHwiBKdB////D3E2AgwgACASIBR+IBEgE358IA4gFX58IAsgFn58IAMgAa0iDH58IAUgF358IAYgHn58IAcgD358IAggDX58IAkgCn58IB9CGYh8IgWnQf///x9xNgIgIAAgI0L///8PgyAiQv///x+DIARCGYh8IgRCGoh8PgIUIAAgBKdB////H3E2AhAgACAYIB5+IAwgGX58IA8gHH58IA0gGn58IAMgLa1+fCAJIBt+fCAGIBF+fCAHIBR+fCAIIA5+fCAKIAt+fCAFQhqIfCIDp0H///8PcTYCJCAAICRC////D4MgA0IZiEITfiAhQv///x+DfCIDQhqIfD4CBCAAIAOnQf///x9xNgIAC90MAg1/AX4jAEGgAmsiByQAAkACQAJAAkACQCABQYAITQRAIAdBADYCiAEgASABQQAgAUGACEcbIgxrIg5BgAhPBEAgB0EBNgKIASAHIAA2AowBQQEhCgsgB0GMAWohCyADIRQgBSEBIwBBIGsiCCQAIAZBBXYiCSAKIAkgCkkbIg0EQCAEQQJyIQ8gBEEBciEQA0AgCygCACEJIAhBGGoiESACQRhqKQIANwMAIAhBEGoiEiACQRBqKQIANwMAIAhBCGoiEyACQQhqKQIANwMAIAggAikCADcDACAIIAlBwAAgFCAQECIgCCAJQUBrQcAAIBQgBBAiIAggCUGAAWpBwAAgFCAEECIgCCAJQcABakHAACAUIAQQIiAIIAlBgAJqQcAAIBQgBBAiIAggCUHAAmpBwAAgFCAEECIgCCAJQYADakHAACAUIAQQIiAIIAlBwANqQcAAIBQgBBAiIAggCUGABGpBwAAgFCAEECIgCCAJQcAEakHAACAUIAQQIiAIIAlBgAVqQcAAIBQgBBAiIAggCUHABWpBwAAgFCAEECIgCCAJQYAGakHAACAUIAQQIiAIIAlBwAZqQcAAIBQgBBAiIAggCUGAB2pBwAAgFCAEECIgCCAJQcAHakHAACAUIA8QIiABQRhqIBEpAwA3AAAgAUEQaiASKQMANwAAIAFBCGogEykDADcAACABIAgpAwA3AAAgC0EEaiELIAFBIGohASAUQgF8IRQgDUEBayINDQALCyAIQSBq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BjcDCCAAIAZCP4g3AwAMEgsgACABMgEEIgY3AwggACAGQj+INwMADBELIAAgATQCBCIGNwMIIAAgBkI/iDcDAAwQCyAAIAEpAwgiBjcDCCAAIAZCP4g3AwAMDwsgASoCBLsiB71C////////////AINCgICAgICAgPj/AFoEQCAAQbXSwABBERDhATYCCCAAQgM3AwAMDwsgACAHOQMIIABCAjcDAAwOCyABKwMIIge9Qv///////////wCDQoCAgICAgID4/wBaBEAgAEG10sAAQREQ4QE2AgggAEIDNwMADA4LIAAgBzkDCCAAQgI3AwAMDQsgASgCBCEBIAJBADYCBCABQYABSQ0KIAFBP3FBgH9yIQMgAUEGdiEEIAFBgBBJBEAgAiADOgAFIAIgBEHAAXI6AARBAgwMCyABQQx2IQUgBEE/cUGAf3IhBCABQf//A00EQCACIAM6AAYgAiAEOgAFIAIgBUHgAXI6AARBAwwMCyACIAM6AAcgAiAEOgAGIAIgBUE/cUGAf3I6AAUgAiABQRJ2QXByOgAEQQQMCwsgASkDCCEGIAJBBToACCACIAY3AgwgAkEIaiACQR9qQaDSwAAQ1wEhASAAQgM3AwAgACABNgIIDAsLIAEpAgQhBiACQQU6AAggAiAGNwIMIAJBCGogAkEfakGg0sAAENcBIQEgAEIDNwMAIAAgATYCCAwKCyABKQMIIQYgAkEGOgAIIAIgBjcCDCACQQhqIAJBH2pBoNLAABDXASEBIABCAzcDACAAIAE2AggMCQsgASkCBCEGIAJBBjoACCACIAY3AgwgAkEIaiACQR9qQaDSwAAQ1wEhASAAQgM3AwAgACABNgIIDAgLIAJBCDoACCACQQhqIAJBH2pBoNLAABDXASEBIABCAzcDACAAIAE2AggMBwsgAkEIOgAIIAJBCGogAkEfakGg0sAAENcBIQEgAEIDNwMAIAAgATYCCAwGCyACQQc6AAggAkEIaiACQR9qQaDSwAAQ1wEhASAAQgM3AwAgACABNgIIDAULIAJBCToACCACQQhqIAJBH2pBoNLAABDXASEBIABCAzcDACAAIAE2AggMBAsgAkEKOgAIIAJBCGogAkEfakGg0sAAENcBIQEgAEIDNwMAIAAgATYCCAwDCyACQQs6AAggAkEIaiACQR9qQaDSwAAQ1wEhASAAQgM3AwAgACABNgIIDAILIAIgAToABEEBCzYCECACQQU6AAggAiACQQRqNgIMIAJBCGogAkEfakGg0sAAENcBIQEgAEIDNwMAIAAgATYCCAsgAkEgaiQAC5oHAQ1/IwBBoAFrIgMkACADQQA2AgwgA0KAgICAEDcCBCADQRBqIAEgAkGtq8AAQQEQMiADQYgBaiADQcgAaikDADcDACADQYABaiADQUBrKQMANwMAIANB+ABqIANBOGopAwA3AwAgA0HwAGogA0EwaikDADcDACADQegAaiADQShqKQMANwMAIANB4ABqIANBIGopAwA3AwAgA0HYAGoiDyADQRhqKQMANwMAIAMgAykDEDcDUEEBIQsCQANAAkACQAJAAkACQCADKAJQQQFGBEAgAygCjAEhBSADKAKIASEEIAMoAoQBIQcgAygCgAEhCCADKAJ0QX9GDQEgA0GUAWogDyAIIAcgBCAFQQAQcgwFCyADLQBeRQRAIAMtAFwhDCADKAKEASEEIAMoAoABIQgCQCADKAJUIgVFDQAgBCAFTQRAIAQgBUYNAQwJCyAFIAhqLAAAQUBIDQgLIAQgBUcEQAJ/IAUgCGoiDSwAACIHQQBIBEAgDS0AAUE/cSEKIAdBH3EhDiAOQQZ0IApyIAdBYEkNARogDS0AAkE/cSAKQQZ0ciEKIAogDkEMdHIgB0FwSQ0BGiAOQRJ0QYCA8ABxIA0tAANBP3EgCkEGdHJyDAELIAdB/wFxCyEHIAxBAXENAwJAAn9BASAHQYABSQ0AGkECIAdBgBBJDQAaQQNBBCAHQYCABEkbCyAFaiIFRQ0AIAQgBU0EQCAEIAVHDQoMAQsgBSAIaiwAAEFASA0JCyAEIAVGDQQgBSAIaiwAABoMAwsgAyAMQX9zQQFxOgBcIAUhBCAMQQFxDQQgA0EBOgBeCyADQQA2ApQBDAQLIANBlAFqIA8gCCAHIAQgBUEBEHIMAwsgBSEECyADQQA6AFwgAyAENgJUCyADIAQ2ApwBIAMgBDYCmAEgA0EBNgKUAQsgAygClAFBAUYEQCADKAKcASADKAKYASAJayIEIAMoAgQgBmtLBEAgA0EEaiAGIARBAUEBEMkBIAMoAgghCyADKAIMIQYLIAQEQCAGIAtqIAEgCWogBPwKAAALIAMgBCAGaiIGNgIMIQkMAQsLIAIgCWsiAiADKAIEIAZrSwRAIANBBGogBiACQQFBARDJASADKAIIIQsgAygCDCEGCyACBEAgBiALaiABIAlqIAL8CgAACyAAQQhqIAIgBmo2AgAgACADKQIENwIAIANBoAFqJAAPCyAIIAQgBSAEQfSxwAAQ6wIAC9QHAwR/A34BfCMAQTBrIgMkACABKAIAIQICQAJAAkACQAJAAkAgACgCAEEBaw4CAQIAC0EUIQEgACkDCCIHQpDOAFQEQCAHIQYMBAsDQCADQQhqIAFqIgBBBGsgByAHQpDOAIAiBkKQzgB+faciBEH//wNxQeQAbiIFQQF0LwDG0kA7AAAgAEECayAEIAVB5ABsa0H//wNxQQF0LwDG0kA7AAAgAUEEayEBIAdC/8HXL1YgBiEHDQALDAMLQRQhASAAKQMIIgggCEI/hyIGhSAGfSIHQpDOAFQEQCAHIQYMAgsDQCADQQhqIAFqIgBBBGsgByAHQpDOAIAiBkKQzgB+faciBEH//wNxQeQAbiIFQQF0LwDG0kA7AAAgAEECayAEIAVB5ABsa0H//wNxQQF0LwDG0kA7AAAgAUEEayEBIAdC/8HXL1YgBiEHDQALDAELIAArAwgiCb1C////////////AINCgICAgICAgPj/AFoEQCACKAIAIAIoAggiAWtBA00EQCACIAFBBEEBQQEQyQEgAigCCCEBCyACIAFBBGo2AgggAigCBCABakHu6rHjBjYAAAwDCyAJIANBCGoQKCIBIAIoAgAgAigCCCIAa0sEQCACIAAgAUEBQQEQyQEgAigCCCEACyABBEAgAigCBCAAaiADQQhqIAH8CgAACyACIAAgAWo2AggMAgsgBkLjAFYEQCABQQJrIgEgA0EIamogBqciACAAQf//A3FB5ABuIgBB5ABsa0H//wNxQQF0LwDG0kA7AAAgAK0hBgsCQCAGQgpaBEAgAUECayIAIANBCGpqIAanQQF0LwDG0kA7AAAMAQsgAUEBayIAIANBCGpqIAanQTByOgAACyAIQgBTBEAgAEEBayIAIANBCGpqQS06AAALQRQgAGsiBCACKAIAIAIoAggiAWtLBEAgAiABIARBAUEBEMkBIAIoAgghAQsgBARAIAIoAgQgAWogA0EIaiAAaiAE/AoAAAsgAiABIARqNgIIDAELIAZC4wBWBEAgAUECayIBIANBCGpqIAan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KALoAUEBdCIMNgKQAiADIAMoAuwBQQF0Ig02ApQCIAAgBSAGEHogAygCxAEhBSADKAJ4IQYgAygCUCEOIAMoAnwhDyADKAJUIRAgAygCgAEhESADKAJYIRIgAygChAEhEyADKAJcIRQgAygCiAEhFSADKAJgIRcgAygCjAEhGCADKAJkIRkgAygCkAEhGiADKAJoIRsgAygClAEhHCADKAJsIR0gAygCmAEhHiADKAJwIR8gAygCnAEhICADKAJ0ISEgAygCoAEhIiADKAKkASEjIAMoAqgBISQgAygCrAEhJSADKAKwASEmIAMoArQBIScgAygCuAEhKCADKAK8ASEpIAMoAsABISogA0GYAmogA0HwAWogFhB6IAAgBSANajYCdCAAIAwgKmo2AnAgACALIClqNgJsIAAgCiAoajYCaCAAIAkgJ2o2AmQgACAIICZqNgJgIAAgByAlajYCXCAAIAQgJGo2AlggACACICNqNgJUIAAgASAiajYCUCAAICAgIWo2AkwgACAeIB9qNgJIIAAgHCAdajYCRCAAIBogG2o2AkAgACAYIBlqNgI8IAAgFSAXajYCOCAAIBMgFGo2AjQgACARIBJqNgIwIAAgDyAQajYCLCAAIAYgDmo2AiggAEGYAWogA0G4AmopAgA3AgAgAEGQAWogA0GwAmopAgA3AgAgAEGIAWogA0GoAmopAgA3AgAgAEGAAWogA0GgAmopAgA3AgAgACADKQKYAjcCeCADQcACaiQAC9kIAgd/AX4jAEHAA2siByQAAkACQCACQSBGBEAgAUECai0AACELIAEoAAMhCSABKAAHIQIgASgACyEMIAEpAA8hDiABLwAAIQ0gB0HrAWogAUEfai0AADoAACAHIAs6AM4BIAcgDTsBzAEgByAONwDbASAHIAw2ANcBIAcgAjYA0wEgByAJNgDPASAHIAEpABc3AOMBIAdBmAJqIgggB0HMAWoiChBWIAcoApgCRQRAIAdBADYCmAIgByAIEJQCIAcoAgAhAiAHIAcoAgQiAzYCkAIgByACNgKMAiAHQQA2AtQBIAdCgICAgBA3AswBIAdB4LzAADYCnAIgB0KggICADjcCoAIgByAKNgKYAiAHQYwCaiEEIwBBMGsiASQAAn9BASAIQdKewwBBDxDpAg0AGkEAIAQoAgBFDQAaIAEgBDYCDCABQQE2AhQgAUHknsMANgIQIAFCATcCHCABIAFBDGqtQoCAgIDQD4Q3AyggASABQShqNgIYIAgoAgAgCCgCBCABQRBqEGALIAFBMGokAA0CIAcvAdABIAdB0gFqLQAAQRB0ciEBIActANcBIQQgBygA0wEhBSAHKALMASEGAkAgAkUNACADKAIAIggEQCACIAgRBAALIAMoAgQiCEUNACACIAggAygCCBD6AgsgACABOwEIIAAgBDoADyAAIAU2AAsgACAGNgIEIABBBDYCACAAQQpqIAFBEHY6AAAMAwsgB0E4aiAHQagCaigCADYCACAHIAcpAqACNwIwIAcoApwCIQggB0E8aiAHQawCakGQAfwKAAAgB0EraiABQRdqIgFBCGotAAA6AAAgB0EWaiACQRh2OgAAIAcgDjwAGyAHIA5CKIinIgo7ASAgB0EiaiAKQRB2OgAAIAcgASkAADcAIyAHIAJBCHY7ARQgByAINgIsIAcgDDYAFyAHIAJBGHQgCUEIdnI2AhAgByANIAtBEHRyIAlBGHRyNgIMIAcgDkIIiD4CHCAGQcAARgRAIAdBzgFqIAVBAmotAAA6AAAgB0HrAWogBUEfaikAADcAACAHQfMBaiAFQSdqKQAANwAAIAdB+wFqIAVBL2opAAA3AAAgB0GDAmogBUE3aikAADcAACAHQYsCaiAFQT9qLQAAOgAAIAcgBS8AADsBzAEgByAFKQAXNwDjASAFKAADIQEgB0HbAWogBUEPaikAADcAACAHIAE2AM8BIAcgBSkABzcA0wEgB0GYAmoiASAHQcwBahDqASAHQYwCaiAHQQxqIAMgBCABEIEBIABBCjYCACAAIAcoAowCIgBBAXM6AAQgAEUNAyAHKAKQAiIARQ0DIAcoApQCIgEoAgAiAgRAIAAgAhEEAAsgASgCBCICRQ0DIAAgAiABKAIIEPoCDAMLIABBAzYCAAwCCyAAIAI2AgggAEKAgICAgAQ3AgAMAQtBiL3AAEE3IAdBvwNqQfi8wABBwL3AABDmAQALIAdBwANqJAAL/wcBKH8jAEGgAmsiAyQAIAEoAgAhBCABKAIoIQcgASgCBCEIIAEoAiwhCSABKAIIIQogASgCMCELIAEoAgwhDCABKAI0IQ0gASgCECEFIAEoAjghBiABKAIUIQ4gASgCPCEPIAEoAhghECABKAJAIREgASgCHCESIAEoAkQhEyABKAIgIRQgASgCSCEVIAMgASgCJCABKAJMajYCLCADIBQgFWo2AiggAyASIBNqNgIkIAMgECARajYCICADIA4gD2o2AhwgAyAFIAZqNgIYIAMgDCANajYCFCADIAogC2o2AhAgAyAIIAlqNgIMIAMgBCAHajYCCCADQTBqIgQgAUEoaiABEHogA0HYAGoiBSADQQhqIAIQNiADQYABaiIGIAQgAkEoahA2IANBqAFqIhYgAUH4AGogAkHQAGoQNiADIAEoAlBBAXQiAjYC0AEgAyABKAJUQQF0IgQ2AtQBIAMgASgCWEEBdCIHNgLYASADIAEoAlxBAXQiCDYC3AEgAyABKAJgQQF0Igk2AuABIAMgASgCZEEBdCIKNgLkASADIAEoAmhBAXQiCzYC6AEgAyABKAJsQQF0Igw2AuwBIAMgASgCcEEBdCINNgLwASADIAEoAnRBAXQiATYC9AEgACAFIAYQeiADKALMASEFIAMoAoABIQYgAygCWCEOIAMoAoQBIQ8gAygCXCEQIAMoAogBIREgAygCYCESIAMoAowBIRMgAygCZCEUIAMoApABIRUgAygCaCEXIAMoApQBIRggAygCbCEZIAMoApgBIRogAygCcCEbIAMoApwBIRwgAygCdCEdIAMoAqABIR4gAygCeCEfIAMoAqQBISAgAygCfCEhIAMoAqgBISIgAygCrAEhIyADKAKwASEkIAMoArQBISUgAygCuAEhJiADKAK8ASEnIAMoAsABISggAygCxAEhKSADKALIASEqIANB+AFqIANB0AFqIBYQeiAAIAEgBWo2AnQgACANICpqNgJwIAAgDCApajYCbCAAIAsgKGo2AmggACAKICdqNgJkIAAgCSAmajYCYCAAIAggJWo2AlwgACAHICRqNgJYIAAgBCAjajYCVCAAIAIgImo2AlAgACAgICFqNgJMIAAgHiAfajYCSCAAIBwgHWo2AkQgACAaIBtqNgJAIAAgGCAZajYCPCAAIBUgF2o2AjggACATIBRqNgI0IAAgESASajYCMCAAIA8gEGo2AiwgACAGIA5qNgIoIABBmAFqIANBmAJqKQIANwIAIABBkAFqIANBkAJqKQIANwIAIABBiAFqIANBiAJqKQIANwIAIABBgAFqIANBgAJqKQIANwIAIAAgAykC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B0ECa0E3SSEWA0AgACAINgKYASAQIAAgDmoiA0GEAWopAAA3AwAgESADQYwBaikAADcDACASIANBlAFqKQAANwMAIAIgA0H8AGopAAA3AwAgCEUNAiAAIAhBAWsiBzYCmAEgAkGoAWoiBCADQfQAaiIXKQAANwMAIAJBoAFqIgUgA0HsAGoiGCkAADcDACACQZgBaiIGIANB5ABqIhkpAAA3AwAgAiADQdwAaiIaKQAANwOQASAJQRhqIBIpAwA3AAAgCUEQaiARKQMANwAAIAlBCGogECkDADcAACAJIAIpAwA3AAAgCiAAKQMANwMAIApBCGogAEEIaiILKQMANwMAIApBEGogAEEQaiIMKQMANwMAIApBGGogAEEYaiINKQMANwMAIAJBKGogBikDADcDACACQTBqIAUpAwA3AwAgAkE4aiAEKQMANwMAIAJBQGsgCSkDADcDACACQcgAaiACQbgBaikDADcDACACQdAAaiACQcABaikDADcDACACQdgAaiACQcgBaikDADcDACACIAIpA5ABNwMgIAJBwAA6AIgBIAIgDzoAiQEgAkIANwOAASAEIA0pAgA3AwAgBSAMKQIANwMAIAYgCykCADcDACACIAApAgA3A5ABIAJBkAFqIAJBIGpBwABCACAPECIgBCgCACEEIAUoAgAhBSAGKAIAIQYgAigCrAEhCyACKAKkASEMIAIoApwBIQ0gAigClAEhEyACKAKQASEUIBZFDQMgGiAUNgIAIANB+ABqIAs2AgAgFyAENgIAIANB8ABqIAw2AgAgGCAFNgIAIANB6ABqIA02AgAgGSAGNgIAIANB4ABqIBM2AgAgACAINgKYASAOQSBrIQ4gByIIIBVPDQALCyACQdABaiQADwtB5NnAABD8AgALIAIgCzYCrAEgAiAENgKoASACIAw2AqQBIAIgBTYCoAEgAiANNgKcASACIAY2ApgBIAIgEzYClAEgAiAUNgKQAUGs28AAQSsgAkGQAWpBnNzAAEH02cAAEOYBAAvuBgEHfyAAKAIAIgEEQCAAKAIEIQICQCAAKAIIIgcEfwNAAkAgBARAIAEhACAEIQEMAQtBACEAAkAgAkUNACACIQUgAkEHcSIDBEADQCAFQQFrIQUgASgCmAMhASADQQFrIgMNAAsLIAJBCEkNAANAIAEoApgDKAKYAygCmAMoApgDKAKYAygCmAMoApgDKAKYAyEBIAVBCGsiBQ0ACwtBACECCwJAIAEvAZIDIAJLBEAgAiEGIAEhBQwBCwNAIAEoAogCIgUEQCABLwGQAyEGIAFByANBmAMgABtBCBD6AiAAQQFqIQAgBSIBLwGSAyAGTQ0BDAILCyABQcgDQZgDIAAbQQgQ+gJB0LbAABD8AgALIAZBAWohAgJAIABFBEAgBSEEDAELIAUgAkECdGpBmANqIQECQCAAQQdxIgJFBEAgACEDDAELIAAhAwNAIANBAWshAyABKAIAIgRBmANqIQEgAkEBayICDQALC0EAIQIgAEEISQ0AA0AgASgCACgCmAMoApgDKAKYAygCmAMoApgDKAKYAygCmAMiBEGYA2ohASADQQhrIgMNAAsLIAUgBkEMbGoiASgCjAIiAARAIAFBjAJqKAIEIABBARD6AgsCQAJAAkACQCAFIAZBGGxqIgMtAAAOBQMDAwECAAsgA0EEahBEDAILIAMoAgQiAEUNASADKAIIIABBARD6AgwBCyADKAIMIgAEQCADKAIIQQRqIQEDQAJAAkACQAJAIAFBBGstAAAOBQMDAwECAAsgARBEDAILIAEoAgAiBUUNASABQQRqKAIAIAVBARD6AgwBCyABENsBCyABQRhqIQEgAEEBayIADQALCyADKAIEIgBFDQAgAygCCCAAQRhsQQgQ+gILQQAhASAHQQFrIgcNAAsgBA0BQQAFIAELIQQgAkUNAAJAIAJBB3EiAEUEQCACIQEMAQsgAiEBA0AgAUEBayEBIAQoApgDIQQgAEEBayIADQALCyACQQhJDQADQCAEKAKYAygCmAMoApgDKAKYAygCmAMoApgDKAKYAygCmAMhBCABQQhrIgENAAsLIAQoAogCIgAEf0EAIQEDQCAEQcgDQZgDIAEbQQgQ+gIgAUEBayEBIAAhBCAAKAKIAiIADQALQcgDQZgDIAEbBUGYAwshASAEIAFBCBD6AgsLhAYCCH4JfyAAIAE1AiQgATUCICABNQIcIAE1AhggATUCFCABNQIQIgNCGoh8IgRCGYh8IgVCGoh8IgZCGYh8IgdCGoh8IghCGYhCE34gATUCACICQv///x+DfCIJp0H///8fcSIKQRNqQRp2IAE1AgQgAkIaiHwiAkL///8PgyAJQhqIfKciC2pBGXYgATUCCCACQhmIfCICp0H///8fcSIMakEadiABNQIMIAJCGoh8IgKnQf///w9xIg1qQRl2IANC////H4MgAkIZiHwiAqdB////H3EiDmpBGnYgBEL///8PgyACQhqIfKciD2pBGXYgBadB////H3EiEGpBGnYgBqdB////D3EiEWpBGXYgB6dB////H3EiEmpBGnYgCKdB////D3EiAWpBGXZBE2wgCmoiCjoAACAAIApBEHY6AAIgACAKQQh2OgABIAAgCkEadiALaiILQQ52OgAFIAAgC0EGdjoABCAAIApBGHZBA3EgC0ECdHI6AAMgACALQRl2IAxqIgxBDXY6AAggACAMQQV2OgAHIAAgDEEDdCALQYCAgA5xQRZ2cjoABiAAIAxBGnYgDWoiDUELdjoACyAAIA1BA3Y6AAogACAMQRV2QR9xIA1BBXRyOgAJIAAgDUEZdiAOaiIOQRJ2OgAPIAAgDkEKdjoADiAAIA5BAnY6AA0gACAOQRp2IA9qIg86ABAgACANQRN2QT9xIA5BBnRyOgAMIAAgD0EQdjoAEiAAIA9BCHY6ABEgACAPQRl2IBBqIhBBD3Y6ABUgACAQQQd2OgAUIAAgD0EYdkEBcSAQQQF0cjoAEyAAIBBBGnYgEWoiEUENdjoAGCAAIBFBBXY6ABcgACAQQRd2QQdxIBFBA3RyOgAWIAAgEUEZdiASaiISQQx2OgAbIAAgEkEEdjoAGiAAIBFBFXZBD3EgEkEEdHI6ABkgACASQRp2IAFqIgFBCnY6AB4gACABQQJ2OgAdIAAgAUGAgPAPcUESdjoAHyAAIBJBFHZBP3EgAUEGdHI6ABwLkgYCC38CfiMAQYAQayIBJAACQAJAAkAgAARAIABBCGsiBiAGKAIAIgJBAWoiBTYCACAFRQ0BIAAoAgAiA0F/Rg0CIAAgA0EBajYCACABIAY2AgwgASAANgIIIAEgAEEIaiIFNgIEIAFB6AFqIABBgAFqKQMANwMAIAFB4AFqIABB+ABqKQMANwMAIAFB2AFqIABB8ABqKQMANwMAIAFBmAFqIABBMGopAwA3AwAgAUGgAWogAEE4aikDADcDACABQagBaiAAQUBrKQMANwMAIAFBsAFqIABByABqKQMANwMAIAFBuAFqIABB0ABqKQMANwMAIAFBwAFqIABB2ABqKQMANwMAIAFByAFqIABB4ABqKQMANwMAIAEgACkDaDcD0AEgASAAKQMoNwOQASAAKQOIASEMIAApA5gBIQ0gAC0AkgEhCCAALQCRASEJIAAtAJABIQogACgCoAEiBAR/IARBBXQhByABQZgCakEEciELQQAhAgNAIAJB4A1GBEBB/KPAABD7AgsgAiALaiIDIAAgAmpBpAFqIgQpAAA3AAAgA0EYaiAEQRhqKQAANwAAIANBEGogBEEQaikAADcAACADQQhqIARBCGopAAA3AAAgByACQSBqIgJHDQALIAYoAgBBAWshAiAAKAIAQQFrIQMgB0Ega0EFdkEBagVBAAshBCABQRhqIAVBCGopAwA3AwAgAUEgaiAFQRBqKQMANwMAIAFBKGogBUEYaikDADcDACABIAQ2ApgCIAEgBSkDADcDECABQTBqIAFBkAFqQeAA/AoAACAAIAM2AgAgBiACNgIAIAJFBEAgAUEMahCaAgsgAUGUAWogAUEQakGAAfwKAABBkA9BCBCBAyIARQ0DIABBADYCCCAAQoGAgIAQNwMAIABBDGogAUGQAWpBhAH8CgAAIAAgDTcDoAEgACAIOgCaASAAIAk6AJkBIAAgCjoAmAEgACAMNwOQASAAQagBaiABQZgCakHkDfwKAAAgAUGAEGokACAAQQhqDwsQkAMLAAsQkQMAC0EIQZAPEJoDAAvPBQIMfwN+IwBBoAFrIgkkACAJQQBBoAH8CwACQAJAIAIgACgCoAEiBU0EQCAFQSlPDQIgASACQQJ0aiEMAkACQCAFBEAgBUEBaiENIAVBAnQhCgNAIAkgBkECdGohAwNAIAYhAiADIQQgASAMRg0GIANBBGohAyACQQFqIQYgASgCACEHIAFBBGoiCyEBIAdFDQALIAetIRFCACEPIAohByACIQEgACEDA0AgAUEoTw0EIAQgDyAENQIAfCADNQIAIBF+fCIQPgIAIBBCIIghDyAEQQRqIQQgAUEBaiEBIANBBGohAyAHQQRrIgcNAAsgCCAQQoCAgIAQWgR/IAIgBWoiAUEoTw0DIAkgAUECdGogDz4CACANBSAFCyACaiIBIAEgCEkbIQggCyEBDAALAAsDQCABIAxGDQQgBEEBaiEEIAEoAgAgAUEEaiEBRQ0AIAggBEEBayICIAIgCEkbIQgMAAsACyABQShBzLfEABDyAQALIAFBKEHMt8QAEPIBAAsgBUEpTw0BIAJBAWohDSACQQJ0IQwgACAFQQJ0aiEOIAAhAwJAA0AgCSAHQQJ0aiEGA0AgByELIAYhBCADIA5GDQMgBEEEaiEGIAdBAWohByADKAIAIQogA0EEaiIFIQMgCkUNAAsgCq0hEUIAIQ8gDCEKIAshAyABIQYDQCADQShPDQIgBCAPIAQ1AgB8IAY1AgAgEX58IhA+AgAgEEIgiCEPIARBBGohBCADQQFqIQMgBkEEaiEGIApBBGsiCg0ACwJAIAggEEKAgICAEFoEfyACIAtqIgNBKE8NASAJIANBAnRqIA8+AgAgDQUgAgsgC2oiAyADIAhJGyEIIAUhAwwBCwsgA0EoQcy3xAAQ8gEACyADQShBzLfEABDyAQALIAAgCUGgAfwKAAAgACAINgKgASAJQaABaiQADwtBACAFQShBzLfEABCYAgALxgYDCn8CfAJ+IwBBQGoiBCQAAkACQAJAAkACQAJAAkACQCABKAIUIgYgASgCECIHSQRAIAFBDGoiCCgCACIJIAZqLQAAIgVBLkYNASAFQcUARiAFQeUARnINAgsgAkUNAkIBIRAMBgsgASAGQQFqIgU2AhQCQCAFIAdJBEAgBSAJaiEJIAZBAmohCiAFIAdrIQUgBkF/cyAHaiEHQQAhBgNAIAYgCWotAAAiC0EwayIMQf8BcSINQQpPBEAgBkUEQCAEQQ02AjQgBEEYaiAIEIACIAQgBEE0aiAEKAIYIAQoAhwQkgI2AiQgBEEBNgIgDAgLQQAgBmshBSALQSByQeUARw0GIARBIGogASACIAMgBRBODAcLIA1BBUsgA0KZs+bMmbPmzBlSciADQpiz5syZs+bMGVZxDQIgASAGIApqNgIUIANCCn4gDK1C/wGDfCEDIAcgBkEBaiIGRw0ACyAFDQQLIARBBTYCNCAEIAgQgAIgBCAEQTRqIAQoAgAgBCgCBBCSAjYCJCAEQQE2AiAMBAsgBEEgaiABIAIgA0EAIAZrEOkBDAMLIARBIGogASACIANBABBOIAQoAiBFDQMgACAEKAIkNgIIIABCAzcDAAwFC0IAIAN9IhFCAFMEQEICIRAgESEDDAQLIAO6vUKAgICAgICAgIB/hCEDDAMLIAO6IQ4CQAJAAkAgBSAFQR91IgFzIAFrIgZBtQJPBEADQCAORAAAAAAAAAAAYQ0EIAVBAE4NAiAORKDI64XzzOF/oyEOIAVBtAJqIgUgBUEfdSIBcyABayIGQbUCTw0ACwsgBkEDdCsDoKFDIQ8gBUEATg0BIA4gD6MhDgwCCyAEQQ42AjQgBEEQaiAIEJYCIAQgBEE0aiAEKAIQIAQoAhQQkgI2AiQgBEEBNgIgDAILIA4gD6IiDplEAAAAAAAA8H9iDQAgBEEONgI0IARBCGogCBCWAiAEIARBNGogBCgCCCAEKAIMEJICNgIkIARBATYCIAwBCyAEIA4gDpogAhs5AyggBEEANgIgCyAEKAIgRQ0AIAAgBCgCJDYCCCAAQgM3AwAMAgsgBCkDKCEDCyAAIAM3AwggACAQNwMACyAEQUBrJAAL6wUBCX8jAEHQAGsiAyQAIANBEGogASACQaTLwABBAhAyAkACQAJAIAMoAhBBAUYEQCADQRhqIQQgAygCTCEFIAMoAkghBiADKAJEIQggAygCQCEHIAMoAjRBf0YNASADQQRqIAQgByAIIAYgBUEAEHMMAgsCQCADLQAeDQAgAy0AHCELIAMoAkQhBSADKAJAIQgCQCADKAIUIgRFDQAgBCAFTwRAIAQgBUYNAQwFCyAEIAhqLAAAQUBIDQQLAkAgBCAFRwRAAn8gBCAIaiIHLAAAIgZBAEgEQCAHLQABQT9xIQkgBkEfcSEKIApBBnQgCXIgBkFgSQ0BGiAHLQACQT9xIAlBBnRyIQkgCSAKQQx0ciAGQXBJDQEaIApBEnRBgIDwAHEgBy0AA0E/cSAJQQZ0cnIMAQsgBkH/AXELIQZBASEHIAtBAXEEQCAEIQUMAgsCQCAGQYABSQ0AQQIhByAGQYAQSQ0AQQNBBCAGQYCABEkbIQcLAkAgBCAHaiIERQ0AIAQgBU8EQCAEIAVHDQcMAQsgBCAIaiwAAEFASA0GCyAEIAVGDQEgBCAIaiwAAEEATgRAIAQhBQwCCyAEIQUMAQsgBCEFIAtBAXFFDQELIAMgBTYCCEEBIQYLIAMgBjYCBAwBCyADQQRqIAQgByAIIAYgBUEBEHMLAkACQAJAAkAgAygCBEEBRgRAIAMoAghBAmoiBEUNAyACIARLDQEgAiAERw0CDAMLIABBhoCAgHg2AgAMAwsgASAEaiwAAEG/f0oNAQsgASACIAQgAkGoy8AAEOsCAAsgA0HkyMAANgIYIAMgAiAEazYCFCADIAEgBGo2AhAgA0EEaiADQRBqEJ0BIAMoAgRBgICAgHhGBEAgACADKQIINwIEIABBiICAgHg2AgAMAQsgACADKQIENwIEIABBDGogA0EMaigCADYCACAAQYqAgIB4NgIACyADQdAAaiQADwsgCCAFIAQgBUHgzsAAEOsCAAvdBQEBfyAAQQAgAkH/AXFrIgIgACgCACIDIAEoAgBzcSADczYCACAAIAAoAgQiAyABKAIEcyACcSADczYCBCAAIAAoAggiAyABKAIIcyACcSADczYCCCAAIAAoAgwiAyABKAIMcyACcSADczYCDCAAIAAoAhAiAyABKAIQcyACcSADczYCECAAIAAoAhQiAyABKAIUcyACcSADczYCFCAAIAAoAhgiAyABKAIYcyACcSADczYCGCAAIAAoAhwiAyABKAIccyACcSADczYCHCAAIAAoAiAiAyABKAIgcyACcSADczYCICAAIAAoAiQiAyABKAIkcyACcSADczYCJCAAIAAoAigiAyABKAIocyACcSADczYCKCAAIAAoAiwiAyABKAIscyACcSADczYCLCAAIAAoAjAiAyABKAIwcyACcSADczYCMCAAIAAoAjQiAyABKAI0cyACcSADczYCNCAAIAAoAjgiAyABKAI4cyACcSADczYCOCAAIAAoAjwiAyABKAI8cyACcSADczYCPCAAIAAoAkAiAyABKAJAcyACcSADczYCQCAAIAAoAkQiAyABKAJEcyACcSADczYCRCAAIAAoAkgiAyABKAJIcyACcSADczYCSCAAIAAoAkwiAyABKAJMcyACcSADczYCTCAAIAAoAlAiAyABKAJQcyACcSADczYCUCAAIAAoAlQiAyABKAJUcyACcSADczYCVCAAIAAoAlgiAyABKAJYcyACcSADczYCWCAAIAAoAlwiAyABKAJccyACcSADczYCXCAAIAAoAmAiAyABKAJgcyACcSADczYCYCAAIAAoAmQiAyABKAJkcyACcSADczYCZCAAIAAoAmgiAyABKAJocyACcSADczYCaCAAIAAoAmwiAyABKAJscyACcSADczYCbCAAIAAoAnAiAyABKAJwcyACcSADczYCcCAAIAAoAnQiACABKAJ0cyACcSAAczYCdAvaBQIHfwF+An8gAUUEQCAAKAIIIQdBLSELIAVBAWoMAQtBK0GAgMQAIAAoAggiB0GAgIABcSIBGyELIAFBFXYgBWoLIQkCQCAHQYCAgARxRQRAQQAhAgwBCwJAIANBEE8EQCACIAMQQSEBDAELIANFBEBBACEBDAELIANBA3EhCgJAIANBBEkEQEEAIQEMAQsgA0EMcSEMQQAhAQNAIAEgAiAIaiIGLAAAQb9/SmogBkEBaiwAAEG/f0pqIAZBAmosAABBv39KaiAGQQNqLAAAQb9/SmohASAMIAhBBGoiCEcNAAsLIApFDQAgAiAIaiEGA0AgASAGLAAAQb9/SmohASAGQQFqIQYgCkEBayIKDQALCyABIAlqIQkLAkAgAC8BDCIIIAlLBEACQAJAIAdBgICACHFFBEAgCCAJayEIQQAhAUEAIQkCQAJAAkAgB0EddkEDcUEBaw4DAAEAAgsgCCEJDAELIAhB/v8DcUEBdiEJCyAHQf///wBxIQogACgCBCEHIAAoAgAhAANAIAFB//8DcSAJQf//A3FPDQJBASEGIAFBAWohASAAIAogBygCEBEAAEUNAAsMBAsgACAAKQIIIg2nQYCAgP95cUGwgICAAnI2AghBASEGIAAoAgAiByAAKAIEIgogCyACIAMQowINA0EAIQEgCCAJa0H//wNxIQIDQCABQf//A3EgAk8NAiABQQFqIQEgB0EwIAooAhARAABFDQALDAMLQQEhBiAAIAcgCyACIAMQowINAiAAIAQgBSAHKAIMEQEADQJBACEBIAggCWtB//8DcSECA0AgAUH//wNxIgMgAkkhBiACIANNDQMgAUEBaiEBIAAgCiAHKAIQEQAARQ0ACwwCCyAHIAQgBSAKKAIMEQEADQEgACANNwIIQQAPC0EBIQYgACgCACIBIAAoAgQiACALIAIgAxCjAg0AIAEgBCAFIAAoAgwRAQAhBgsgBgvABQIBfwZ+IwBBgAFrIgMkACADQTBqIAEQUCADIAMpA2AgAykDWCADKQNQIgRCGoh8IgdCGYh8IgWnQf///x9xNgIgIAMgAykDQCADKQM4IAMpAzAiCEIaiHwiCUIZiHwiBqdB////H3E2AhAgAyADKQNoIAVCGoh8IgWnQf///w9xNgIkIAMgAykDSCAGQhqIfCIGp0H///8PcTYCFCADIAMpA3AgBUIZiHwiBadB////H3E2AiggAyAHQv///w+DIARC////H4MgBkIZiHwiBEIaiHw+AhwgAyAEp0H///8fcTYCGCADIAMpA3ggBUIaiHwiBKdB////D3E2AiwgAyAJQv///w+DIARCGYhCE34gCEL///8fg3wiBEIaiHw+AgwgAyAEp0H///8fcTYCCCACQQJPBEAgAkEBayECA0AgA0EwaiADQQhqEFAgAyADKQNgIAMpA1ggAykDUCIEQhqIfCIHQhmIfCIFp0H///8fcTYCICADIAMpA0AgAykDOCADKQMwIghCGoh8IglCGYh8IganQf///x9xNgIQIAMgAykDaCAFQhqIfCIFp0H///8PcTYCJCADIAMpA0ggBkIaiHwiBqdB////D3E2AhQgAyADKQNwIAVCGYh8IgWnQf///x9xNgIoIAMgB0L///8PgyAEQv///x+DIAZCGYh8IgRCGoh8PgIcIAMgBKdB////H3E2AhggAyADKQN4IAVCGoh8IgSnQf///w9xNgIsIAMgCUL///8PgyAEQhmIQhN+IAhC////H4N8IgRCGoh8PgIMIAMgBKdB////H3E2AgggAkEBayICDQALCyAAIAMpAgg3AgAgAEEgaiADQShqKQIANwIAIABBGGogA0EgaikCADcCACAAQRBqIANBGGopAgA3AgAgAEEIaiADQRBqKQIANwIAIANBgAFqJAALlwYBBX8gAEEIayIBIABBBGsoAgAiA0F4cSIAaiECAkACQCADQQFxDQAgA0ECcUUNASABKAIAIgMgAGohACABIANrIgFB+OfEACgCAEYEQCACKAIEQQNxQQNHDQFB8OfEACAANgIAIAIgAigCBEF+cTYCBCABIABBAXI2AgQgAiAANgIADwsgASADEIYBCwJAAkACQAJAAkAgAigCBCIDQQJxRQRAIAJB/OfEACgCAEYNAiACQfjnxAAoAgBGDQMgAiADQXhxIgIQhgEgASAAIAJqIgBBAXI2AgQgACABaiAANgIAIAFB+OfEACgCAEcNAUHw58QAIAA2AgAPCyACIANBfnE2AgQgASAAQQFyNgIEIAAgAWogADYCAAsgAEGAAkkNAiABIAAQlQFBACEBQZDoxABBkOjEACgCAEEBayIANgIAIAANBEHY5cQAKAIAIgAEQANAIAFBAWohASAAKAIIIgANAAsLQZDoxABB/x8gASABQf8fTRs2AgAPC0H858QAIAE2AgBB9OfEAEH058QAKAIAIABqIgA2AgAgASAAQQFyNgIEQfjnxAAoAgAgAUYEQEHw58QAQQA2AgBB+OfEAEEANgIACyAAQYjoxAAoAgAiA00NA0H858QAKAIAIgJFDQNBACEAQfTnxAAoAgAiBEEpSQ0CQdDlxAAhAQNAIAIgASgCACIFTwRAIAIgBSABKAIEakkNBAsgASgCCCEBDAALAAtB+OfEACABNgIAQfDnxABB8OfEACgCACAAaiIANgIAIAEgAEEBcjYCBCAAIAFqIAA2AgAPCwJAQejnxAAoAgAiAkEBIABBA3Z0IgNxRQRAQejnxAAgAiADcjYCACAAQfgBcUHg5cQAaiIAIQIMAQsgAEH4AXEiAEHg5cQAaiECIABB6OXEAGooAgAhAAsgAiABNgIIIAAgATYCDCABIAI2AgwgASAANgIIDwtB2OXEACgCACIBBEADQCAAQQFqIQAgASgCCCIBDQALC0GQ6MQAQf8fIAAgAEH/H00bNgIAIAMgBE8NAEGI6MQAQX82AgALC8IFAgh/AnwjAEEwayIFJABBASEJIAEgASgCFCIHQQFqIgY2AhQgAUEMaiEIAkAgBiABKAIQIgpPDQACQAJAIAgoAgAgBmotAABBK2sOAwECAAILQQAhCQsgASAHQQJqIgY2AhQLAkACQCAGIApJBEAgASAGQQFqIgc2AhQgASgCDCIMIAZqLQAAQTBrQf8BcSIGQQpPBEAgBUENNgIkIAVBEGogCBCWAiAFQSRqIAUoAhAgBSgCFBCSAiEBIABBATYCACAAIAE2AgQMAwsgByAKTw0BA0AgByAMai0AAEEwa0H/AXEiC0EKTw0CIAEgB0EBaiIHNgIUIAZBzJmz5gBHIAtBB0tyIAZBy5mz5gBKcUUEQCAGQQpsIAtqIQYgByAKRw0BDAMLCyAAIAEgAiADUCAJEMcBDAILIAVBBTYCJCAFQRhqIAgQlgIgBUEkaiAFKAIYIAUoAhwQkgIhASAAQQE2AgAgACABNgIEDAELIAO6IQ0gAAJ/AkACQAJAAkACfyAJRQRAIAQgBmsiAUEfdUGAgICAeHMgASABIARIIAZBAEpzGwwBCyAEIAZqIgFBH3VBgICAgHhzIAEgBkEASCABIARIcxsLIgdBH3UiASAHcyABayIGQbUCTwRAA0AgDUQAAAAAAAAAAGENBSAHQQBODQIgDUSgyOuF88zhf6MhDSAHQbQCaiIHIAdBH3UiAXMgAWsiBkG1Ak8NAAsLIAZBA3QrA6ChQyEOIAdBAE4NASANIA6jIQ0MAwsgBUEONgIkIAVBCGogCBCWAiAAIAVBJGogBSgCCCAFKAIMEJICNgIEDAELIA0gDqIiDZlEAAAAAAAA8H9iDQEgBUEONgIkIAUgCBCWAiAAIAVBJGogBSgCACAFKAIEEJICNgIEC0EBDAELIAAgDSANmiACGzkDCEEACzYCAAsgBUEwaiQAC8wFAgZ/An4CQCACRQ0AIAJBB2siA0EAIAIgA08bIQcgAUEDakF8cSABayEIQQAhAwNAAkACQAJAIAEgA2otAAAiBcAiBkEATgRAIAggA2tBA3ENASADIAdPDQIDQCABIANqIgRBBGooAgAgBCgCAHJBgIGChHhxDQMgA0EIaiIDIAdJDQALDAILQoCAgICAICEKQoCAgIAQIQkCQAJAAn4CQAJAAkACQAJAAkACQAJAAkAgBS0AgM1EQQJrDgMAAQIKCyADQQFqIgQgAkkNAkIAIQpCACEJDAkLQgAhCiADQQFqIgQgAkkNAkIAIQkMCAtCACEKIANBAWoiBCACSQ0CQgAhCQwHCyABIARqLAAAQb9/Sg0GDAcLIAEgBGosAAAhBAJAAkAgBUHgAWsiBQRAIAVBDUYEQAwCBQwDCwALIARBYHFBoH9GDQQMAwsgBEGff0oNAgwDCyAGQR9qQf8BcUEMTwRAIAZBfnFBbkcNAiAEQUBIDQMMAgsgBEFASA0CDAELIAEgBGosAAAhBAJAAkACQAJAIAVB8AFrDgUBAAAAAgALIAZBD2pB/wFxQQJLIARBQE5yDQMMAgsgBEHwAGpB/wFxQTBPDQIMAQsgBEGPf0oNAQsgAiADQQJqIgRNBEBCACEJDAULIAEgBGosAABBv39KDQJCACEJIANBA2oiBCACTw0EIAEgBGosAABBQEgNBUKAgICAgOAADAMLQoCAgICAIAwCC0IAIQkgA0ECaiIEIAJPDQIgASAEaiwAAEG/f0wNAwtCgICAgIDAAAshCkKAgICAECEJCyAAIAogA62EIAmENwIEIABBATYCAA8LIARBAWohAwwCCyADQQFqIQMMAQsgAiADTQ0AA0AgASADaiwAAEEASA0BIAIgA0EBaiIDRw0ACwwCCyACIANLDQALCyAAIAI2AgggACABNgIEIABBADYCAAutBAIUfgl/IAAgASgCDCIYrSIPIAEoAgAiGUEBdK0iAn4gASgCBCIaQQF0rSIDIAEoAggiG60iB358IAEoAiAiHEETbK0iCCABKAIUIhZBAXStIgp+fCABKAIkIh1BE2ytIgQgASgCECIerSIFfiABKAIcIhdBE2ytIgwgASgCGCIBrSIJfnxCAYZ8NwMYIAAgAUETbK0iECAKfiACIBqtIhR+fCAIIBhBAXStIgZ+fCAEIAd+IAUgDH58QgGGfDcDCCAAIAYgCX4gHkEBdK0iESAWrSINfnwgF60iEiAbQQF0rSILfnwgHK0iDiADfnwgHa0iFSACfnw3A0ggACALIA1+IAUgBn58IAMgCX58IAIgEn58IAQgDn5CAYZ8NwM4IAAgAyAFfiALIA9+fCACIA1+fCAIIBdBAXStIhN+fCAEIAl+QgGGfDcDKCAAIAMgBn4gByAHfnwgAiAFfnwgCCABQQF0rX58IAQgCn4gDCASfnxCAYZ8NwMgIAAgAiAHfiADIBR+fCAJIBB+fCAIIBF+fCAEIAZ+IAogDH58QgGGfDcDECAAIBAgEX4gGa0iByAHfnwgCCALfnwgBiAMfiAWQRNsrSANfnwgAyAEfnxCAYZ8NwMAIAAgCSALfiAFIAV+fCAGIAp+fCADIBN+fCACIA5+fCAEIBV+QgGGfDcDQCAAIAYgD34gBSALfnwgAyAKfnwgAiAJfnwgCCAOfnwgBCATfkIBhnw3AzAL7wUCAn8CfiMAQeABayIHJAACQAJAAkACQCACQSBHBH9BAAUgBEEYRg0BQQELIQEgACACNgIIIABBIDYCBCAAIAE2AgAMAQsgASkAAyEJIAEoAAshAiABKQAPIQogB0EiaiADQQJqLQAAOgAAIAcgAy8AADsBICADLQAXIQQgAygAAyEIIAdBAmogAUECai0AADoAACAHQR9qIAFBH2otAAA6AAAgByAKNwAPIAcgAjYACyAHIAk3AAMgByABLwAAOwEAIAcgASkAFzcAFyAHIAg2ACMgB0EvaiADQQ9qKQAANwAAIAcgAykABzcAJyAHIAQ6ADcgB0G8AWogByAHQSBqEFcgB0GAAWpCADcCACAHQYgBakIANwIAIAdBkAFqQgA3AgAgB0GYAWpCADcCACAHQaABakIANwIAIAdBqAFqQgA3AgAgB0GwAWpCADcCACAHQgA3AnggB0HuyIGZAzYCTCAHQbLaiMsHNgJgQQAhASAHQQA6ALgBIAdB9MqB2QY2AnQgB0IANwJYIAcgBykBMCIJPgJQIAcgBykC1AE3AmwgByAHKQLMATcCZCAHIAcpAsQBNwJEIAcgBykCvAE3AjwgByAJQiCIPgJUIAdB5fDBiwY2AjggBkEASA0BAkAgBkUEQEEBIQIMAQtBASEBIAZBARCBAyICRQ0CCyAGBEAgAiAFIAb8CgAACyAHIAY2AsQBIAcgAjYCwAEgByACNgK8ASAHQThqIgEgB0G8AWoQJQ0CIAAgBjYCCCAAIAI2AgQgAEEKNgIAIAEQgwEgB0EANgI4IAdBADYCPCAHQQA2AkAgB0EANgJEIAdBADYCSCAHQQA2AkwgB0EANgJQIAdBADYCVCAHQQA2AlggB0EANgJcIAdBADYCYCAHQQA2AmQgB0EANgJoIAdBADYCbCAHQQA2AnAgB0EANgJ0CyAHQeABaiQADwsgASAGENsCAAtBuLnAAEErIAdB3wFqQai5wABB5LnAABDmAQALug4BCH8jAEEgayIGJAAgAAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABDigCAQEBAQEBAQEDBQEBBAEBAQEBAQEBAQEBAQEBAQEBAQEBCAEBAQEHAAsgAUHcAEYNBQsgAkEBcUUgAUH/BU1yDQdBEEEAIAFBq50ETxsiAiACQQhyIgMgAUELdCICIANBAnQoAvTTREELdEkbIgMgA0EEciIDIANBAnQoAvTTREELdCACSxsiAyADQQJyIgMgA0ECdCgC9NNEQQt0IAJLGyIDIANBAWoiAyADQQJ0KAL000RBC3QgAksbIgMgA0EBaiIDIANBAnQoAvTTREELdCACSxsiA0ECdCgC9NNEQQt0IgcgAkYgAiAHS2ogA2oiB0ECdCICQfTTxABqIQUgAigC9NNEQRV2IQJB/wUhAwJAIAdBH00EQCAFKAIEQRV2IQMgB0UNAQsgBUEEaygCAEH///8AcSEECwJAIAMgAkF/c2pFDQAgASAEayEEIANBAWshB0EAIQMDQCADIAJB8K3EAGotAABqIgMgBEsNASAHIAJBAWoiAkcNAAsLIAJBAXFFDQcgBkEOakEAOgAAIAZBADsBDCAGIAFBFHYtAPG1RDoADyAGIAFBBHZBD3EtAPG1RDoAEyAGIAFBCHZBD3EtAPG1RDoAEiAGIAFBDHZBD3EtAPG1RDoAESAGIAFBEHZBD3EtAPG1RDoAECABQQFyZ0ECdiICIAZBDGoiA2oiBEH7ADoAACAEQQFrQfUAOgAAIAMgAkECayICakHcADoAACAGQRRqIgMgAUEPcS0A8bVEOgAAIAAgBikBDDcAACAGQf0AOgAVDAgLIABCADcBAiAAQdzgADsBAAwKCyAAQgA3AQIgAEHc6AE7AQAMCQsgAEIANwECIABB3OQBOwEADAgLIABCADcBAiAAQdzcATsBAAwHCyAAQgA3AQIgAEHcuAE7AQAMBgsgAkGAAnFFDQEgAEIANwECIABB3M4AOwEADAULIAJB////B3FBgIAETw0DC0EAIQQCQAJAAkAgASIFQSBJDQAgAUH/AEkEQEEBIQMMAwsCQCAFQYCABE8EQCAFQYCACEkNASAFQf7//wBxIgJBrp0LRyAFQeD//wBxQeDNCkcgAkGe8ApHcXEgBUHw1wtrQXFJcSAFQYDwC2tB3mxJcSAFQYCADGtBnnRJcSAFQdCmDGtBe0lxIAVBgII4a0H65lRJcSAFQfCDOElxIQMMBAtBoNvEACECQaLbxAAhAyAFQQh2Qf8BcSEJA0ACQCADIQcgBCACLQABIgNqIQgCQCAJIAItAAAiAkcEQCACIAlLDQIMAQsgBCAISyAIQZwCS3JFBEAgBEHs28QAaiECA0AgA0UNAiADQQFrIQMgAi0AACACQQFqIQIgBUH/AXFHDQALDAULIAQgCEGcAkG84MQAEJgCAAsgB0ECQQAgB0Hs28QARxtqIQMgCCEEIAciAkHs28QARw0BCwtBASEDQQAhAgNAIAJBAWohBwJAIAIsAIjeRCIEQQBOBEAgByECDAELIAdBpAJHBEAgAkGJ3sQAai0AACAEQf8AcUEIdHIhBCACQQJqIQIMAQtBrODEABD8AgALIAUgBGsiBUEASA0EIANBAXMhAyACQaQCRw0ACwwDC0H41MQAIQJB+tTEACEDIAVBCHZB/wFxIQkDQCADIQcgBCACLQABIgNqIQgCQCAJIAItAAAiAkcEQCACIAlNDQEMBAsgBCAISyAIQdQBS3JFBEAgBEHU1cQAaiECA0AgA0UNAiADQQFrIQMgAi0AACACQQFqIQIgBUH/AXFHDQALDAMLIAQgCEHUAUG84MQAEJgCAAsgB0EAQQIgB0HU1cQARiIKG2ohAyAIIQQgByECIApFDQALDAELQQAhAwwBCyAFQf//A3EhBEEBIQNBACECA0AgAkEBaiEHAkAgAiwAqNdEIgVBAE4EQCAHIQIMAQsgB0H4A0cEQCACQanXxABqLQAAIAVB/wBxQQh0ciEFIAJBAmohAgwBC0Gs4MQAEPwCAAsgBCAFayIEQQBIDQEgA0EBcyEDIAJB+ANHDQALCyADQQFxDQEgBkEYakEAOgAAIAZBADsBFiAGIAFBFHYtAPG1RDoAGSAGIAFBBHZBD3EtAPG1RDoAHSAGIAFBCHZBD3EtAPG1RDoAHCAGIAFBDHZBD3EtAPG1RDoAGyAGIAFBEHZBD3EtAPG1RDoAGiABQQFyZ0ECdiICIAZBFmoiA2oiBEH7ADoAACAEQQFrQfUAOgAAIAMgAkECayICakHcADoAACAGQR5qIgMgAUEPcS0A8bVEOgAAIAAgBikBFjcAACAGQf0AOgAfCyAAQQhqIAMvAQA7AABBCgwDCyAAIAE2AgBBgAEhAkGBAQwCCyAAQgA3AQIgAEHcxAA7AQALQQAhAkECCzoADSAAIAI6AAwgBkEgaiQAC98EAQZ/AkACQCAAKAIIIgdBgICAwAFxRQ0AAkACQAJAAkAgB0GAgICAAXEEQCAALwEOIgMNAUEAIQIMAgsgAkEQTwRAIAEgAhBBIQMMBAsgAkUEQEEAIQIMBAsgAkEDcSEGAkAgAkEESQRADAELIAJBDHEhCANAIAMgASAFaiIELAAAQb9/SmogBEEBaiwAAEG/f0pqIARBAmosAABBv39KaiAEQQNqLAAAQb9/SmohAyAIIAVBBGoiBUcNAAsLIAZFDQMgASAFaiEEA0AgAyAELAAAQb9/SmohAyAEQQFqIQQgBkEBayIGDQALDAMLIAEgAmohCEEAIQIgASEEIAMhBQNAIAQiBiAIRg0CAn8gBkEBaiAGLAAAIgRBAE4NABogBkECaiAEQWBJDQAaIAZBA2ogBEFwSQ0AGiAGQQRqCyIEIAZrIAJqIQIgBUEBayIFDQALC0EAIQULIAMgBWshAwsgAyAALwEMIgRPDQAgBCADayEGQQAhA0EAIQUCQAJAAkAgB0EddkEDcUEBaw4CAAECCyAGIQUMAQsgBkH+/wNxQQF2IQULIAdB////AHEhCCAAKAIEIQcgACgCACEAA0AgA0H//wNxIAVB//8DcUkEQEEBIQQgA0EBaiEDIAAgCCAHKAIQEQAARQ0BDAMLC0EBIQQgACABIAIgBygCDBEBAA0BQQAhAyAGIAVrQf//A3EhAQNAIANB//8DcSICIAFJIQQgASACTQ0CIANBAWohAyAAIAggBygCEBEAAEUNAAsMAQsgACgCACABIAIgACgCBCgCDBEBACEECyAEC+wEAQh/IwBBEGsiBSQAAkACQCACKAIEIgNFDQAgACACKAIAIAMgASgCDBEBAEUNAEEBIQIMAQsgAigCDCIDRQRAQQAhAgwBCyACKAIIIgYgA0EMbGohCCAGQQxqIQMgBUEMaiEJA0AgBiECIAMhBgJAAkACQAJAIAIvAQBBAWsOAgIBAAsCQCACKAIEIgJBwQBPBEAgAUEMaigCACEDA0AgAEHBtsQAQcAAIAMRAQAEQEEBIQIMCAsgAkFAaiICQcAASw0ACwwBCyACRQ0DCyAAQcG2xAAgAiABQQxqKAIAEQEARQ0CQQEhAgwECyAAIAIoAgQgAigCCCABQQxqKAIAEQEARQ0BQQEhAgwDCyACLwECIQMgCUEAOgAAIAVBADYCCAJAAkACfwJAAkACQAJAIAIvAQBBAWsOAgECAAsgAigCBAwDCyACLwECIgINAUEBIQQMAwsgAigCCAwBCyACQfb/F2ogAkGc/x9qcSACQZj4N2ogAkHwsR9qcXNBEXZBAWoLIgRBBk8EQEEAIARBBUGEt8QAEJgCAAsgBA0AQQAhBAwBCyAFQQhqIARqIQIgBEEBcQRAIAJBAWsiAiADIANBCm4iA0EKbGtBMHI6AAALIARBAUYNACACQQJrIQIDQCACIANB//8DcSIHQQpuIgpBCnBBMHI6AAAgAkEBaiADIApBCmxrQTByOgAAIAdB5ABuIQMgAiAFQQhqRyACQQJrIQINAAsLIAAgBUEIaiAEIAFBDGooAgARAQBFDQBBASECDAILQQAhAiAGQQBBDCAGIAhGIgQbaiEDIARFDQALCyAFQRBqJAAgAgvsBAEJfyMAQdAAayICJAAgASgCACIHLwGSAyEIAkACQAJAQcgDQQgQgQMiBgRAIAZBADYCiAIgBiAHLwGSAyABKAIIIgVBf3NqIgQ7AZIDIAJBMGogB0GMAmoiCiAFQQxsaiIJQQhqKAIANgIAIAJBQGsgByAFQRhsaiIDQQhqKQMANwMAIAJByABqIANBEGopAwA3AwAgAiAJKQIANwMoIAIgAykDADcDOCAEQQxPDQEgBUEBaiEDIARBDGwiCQRAIAZBjAJqIAogA0EMbGogCfwKAAALIARBGGwiBARAIAYgByADQRhsaiAE/AoAAAsgByAFOwGSAyACQQhqIAJBMGooAgA2AgAgAkEYaiACQUBrKQMANwMAIAJBIGogAkHIAGopAwA3AwAgAiACKQMoNwMAIAIgAikDODcDECAGLwGSAyIEQQFqIQMgBEEMTw0CIAggBWsgA0cNAyAGQZgDaiEIIANBAnQiAwRAIAggByAFQQJ0akGcA2ogA/wKAAALIAEoAgQhBUEAIQEDQAJAIAggAUECdGooAgAiAyABOwGQAyADIAY2AogCIAEgBE8NACABIAEgBElqIgEgBE0NAQsLIAAgBTYCLCAAIAc2AiggACACKQMANwMAIAAgBTYCNCAAIAY2AjAgAEEIaiACQQhqKQMANwMAIABBEGogAkEQaikDADcDACAAQRhqIAJBGGopAwA3AwAgAEEgaiACQSBqKQMANwMAIAJB0ABqJAAPC0EIQcgDEJoDAAtBACAEQQtB6LXAABCYAgALQQAgA0EMQfi1wAAQmAIAC0GwtcAAQShB2LXAABCZAgALuCACFX8IfiMAQaADayIEJAAgBEGoAWoiAiABEG8gBEHwAWpBkOXAACkCADcDACAEQegBakGI5cAAKQIANwMAIARB4AFqQYDlwAApAgA3AwAgBEHYAWpB+OTAACkCADcDACAEQfDkwAApAgA3A9ABIwBB0ABrIgMkACADIAIQUCAEQfwBaiICIAMpAzAgAykDKCADKQMgIhdCGoh8IhtCGYh8IhinQf///x9xNgIYIAIgAykDECADKQMIIAMpAwAiHEIaiHwiGkIZiHwiGadB////H3E2AgggAiADKQM4IBhCGoh8IhinQf///w9xNgIcIAIgAykDGCAZQhqIfCIZp0H///8PcTYCDCACIAMpA0AgGEIZiHwiGKdB////H3E2AiAgAiAbQv///w+DIBdC////H4MgGUIZiHwiF0IaiHw+AhQgAiAXp0H///8fcTYCECACIAMpA0ggGEIaiHwiF6dB////D3E2AiQgAiAaQv///w+DIBdCGYhCE34gHEL///8fg3wiF0IaiHw+AgQgAiAXp0H///8fcTYCACADQdAAaiQAIARBpAJqIgMgAiAEQdABahB6IARB2ABqIAJByOTAABA2IAQgBCgCfDYC8AIgBCAEKQJ0NwLoAiAEIAQpAmw3AuACIAQgBCkCZDcC2AIgBCAEKQJcNwLQAiAEIAQoAlhBAWo2AswCIARB9AJqIQkjAEHwAmsiAiQAIAJBoAJqIgUgBEHMAmoiCBBQIAIgAikD0AIgAikDyAIgAikDwAIiF0IaiHwiG0IZiHwiGKdB////H3E2ApACIAIgAikDsAIgAikDqAIgAikDoAIiHEIaiHwiGkIZiHwiGadB////H3E2AoACIAIgAikD2AIgGEIaiHwiGKdB////D3E2ApQCIAIgAikDuAIgGUIaiHwiGadB////D3E2AoQCIAIgAikD4AIgGEIZiHwiGKdB////H3E2ApgCIAIgG0L///8PgyAXQv///x+DIBlCGYh8IhdCGoh8PgKMAiACIBenQf///x9xNgKIAiACIAIpA+gCIBhCGoh8IhenQf///w9xNgKcAiACIBpC////D4MgF0IZiEITfiAcQv///x+DfCIXQhqIfD4C/AEgAiAXp0H///8fcTYC+AEgAkEIaiIHIAJB+AFqIgYgCBA2IAUgBxBQIAIgAikD0AIgAikDyAIgAikDwAIiF0IaiHwiG0IZiHwiGKdB////H3E2ApACIAIgAikDsAIgAikDqAIgAikDoAIiHEIaiHwiGkIZiHwiGadB////H3E2AoACIAIgAikD2AIgGEIaiHwiGKdB////D3E2ApQCIAIgAikDuAIgGUIaiHwiGadB////D3E2AoQCIAIgAikD4AIgGEIZiHwiGKdB////H3E2ApgCIAIgG0L///8PgyAXQv///x+DIBlCGYh8IhdCGoh8PgKMAiACIBenQf///x9xNgKIAiACIAIpA+gCIBhCGoh8IhenQf///w9xNgKcAiACIBpC////D4MgF0IZiEITfiAcQv///x+DfCIXQhqIfD4C/AEgAiAXp0H///8fcTYC+AEgAkEwaiIKIAYgCBA2IAJBgAFqIgsgAyAHEDYgAkHQAWoiByADIAoQNiAFIAcQMyACQZgCaiACQcACaikCADcDACACQZACaiACQbgCaikCADcDACACQYgCaiACQbACaikCADcDACACQYACaiACQagCaikCADcDACACIAIpAqACNwP4ASAFIAZBAhBMIAJBqAFqIgogByAFEDYgAkHYAGoiDCALIAoQNiAFIAwQUCACIAIpA9ACIAIpA8gCIAIpA8ACIhdCGoh8IhtCGYh8IhinQf///x9xNgKQAiACIAIpA7ACIAIpA6gCIAIpA6ACIhxCGoh8IhpCGYh8IhmnQf///x9xNgKAAiACIAIpA9gCIBhCGoh8IhinQf///w9xNgKUAiACIAIpA7gCIBlCGoh8IhmnQf///w9xNgKEAiACIAIpA+ACIBhCGYh8IhinQf///x9xNgKYAiACIBtC////D4MgF0L///8fgyAZQhmIfCIXQhqIfD4CjAIgAiAXp0H///8fcTYCiAIgAiACKQPoAiAYQhqIfCIXp0H///8PcTYCnAIgAiAaQv///w+DIBdCGYhCE34gHEL///8fg3wiF0IaiHw+AvwBIAIgF6dB////H3E2AvgBIAcgCCAGEDYgBiAHEEUgBSADEEVBACEFQQEhBgNAIAJB+AFqIgcgBWotAAAgAkGgAmoiCCAFai0AAEYQ5wIgBnEhBiAFQQFqIgVBIEcNAAsgBhDnAiEVIAJB8P///wMgAygCGGutQfD///8BIAMoAhRrrUHw////AyADKAIQa60iF0IaiHwiG0IZiHwiGKdB////H3EiCjYCuAIgAkHw////AyADKAIIa61B8P///wEgAygCBGutQdD9//8DIAMoAgBrrSIcQhqIfCIaQhmIfCIZp0H///8fcSILNgKoAiACQfD///8BIAMoAhxrrSAYQhqIfCIYp0H///8PcSIMNgK8AiACQfD///8BIAMoAgxrrSAZQhqIfCIZp0H///8PcSINNgKsAiACQfD///8DIAMoAiBrrSAYQhmIfCIYp0H///8fcSIONgLAAiACIBdC////H4MgGUIZiHwiF6dB////H3EiDzYCsAIgAiAbQv///w+DIBdCGoh8pyIQNgK0AiACQfD///8BIAMoAiRrrSAYQhqIfCIXp0H///8PcSITNgLEAiACIBdCGYhCE34gHEL///8fg3wiF6dB////H3EiETYCoAIgAiAaQv///w+DIBdCGoh8pyISNgKkAiACQagBaiACQdABahBFIAcgCBBFQQAhBUEBIQYDQCACQagBaiIHIAVqLQAAIAJB+AFqIgMgBWotAABGEOcCIAZxIQYgBUEBaiIFQSBHDQALIAYQ5wIhFCACIBM2AsQCIAIgDjYCwAIgAiAMNgK8AiACIAo2ArgCIAIgEDYCtAIgAiAPNgKwAiACIA02AqwCIAIgCzYCqAIgAiASNgKkAiACIBE2AqACIAMgAkGgAmpB+OPAABA2IAJBgAFqIAJB0AFqEEUgByADEEVBACEFQQEhBgNAIAJBgAFqIAVqLQAAIAJBqAFqIAVqLQAARhDnAiAGcSEGIAVBAWoiBUEgRw0ACyAGEOcCIQMgAkGgAmpB+OPAACACQdgAaiIWEDYgAkHgAGoiBUEAIAMgFHIQ5wJB/wFxayIDIAUoAgAiBiACKAKoAnNxIAZzIgY2AgAgAkHoAGoiByAHKAIAIgggAigCsAJzIANxIAhzIgg2AgAgAkHwAGoiCiAKKAIAIgsgAigCuAJzIANxIAtzIgs2AgAgAiACKAJkIgwgAigCrAJzIANxIAxzIgw2AmQgAiACKAJcIg0gAigCpAJzIANxIA1zIg02AlwgAiACKAJYIg4gAigCoAJzIANxIA5zIg42AlggAiACKAJsIg8gAigCtAJzIANxIA9zIg82AmwgAiACKAJ0IhAgAigCvAJzIANxIBBzIhA2AnQgAkH4AGoiEyATKAIAIhEgAigCwAJzIANxIBFzIhE2AgAgAiADIAIoAnwiEiACKALEAnNxIBJzIhI2AnwgAkH4AWogFhBFIBNBACACLQD4AUEBcRDnAkH/AXFrIgNB8P///wMgEWutQfD///8BIBBrrUHw////AyALa61B8P///wEgD2utQfD///8DIAhrrSIXQhqIfCIbQhmIfCIYQhqIfCIcQhmIfCIap0H///8fcSARc3EgEXM2AgAgCiAYp0H///8fcSALcyADcSALczYCACAHIBdC////H4NB8P///wEgDGutQfD///8DIAZrrUHw////ASANa61B0P3//wMgDmutIhdCGoh8IhhCGYh8IhlCGoh8Ih1CGYh8Ih6nQf///x9xIAhzIANxIAhzNgIAIAUgGadB////H3EgBnMgA3EgBnM2AgAgAkHw////ASASa60gGkIaiHwiGqdB////D3EgEnMgA3EgEnM2AnwgAiAcp0H///8PcSAQcyADcSAQczYCdCACIA8gG0L///8PgyAeQhqIfKdzIANxIA9zNgJsIAIgHadB////D3EgDHMgA3EgDHM2AmQgAiAaQhmIQhN+IBdC////H4N8IhenQf///x9xIA5zIANxIA5zNgJYIAIgDSAYQv///w+DIBdCGoh8p3MgA3EgDXM2AlwgCSAUIBVyEOcCOgAAIAkgAikCWDcCBCAJQQxqIAUpAgA3AgAgCUEUaiAHKQIANwIAIAlBHGogCikCADcCACAJQSRqIBMpAgA3AgAgAkHwAmokACAEQeAAaiIDIARBgANqKQIANwMAIARB6ABqIgIgBEGIA2opAgA3AwAgBEHwAGoiBSAEQZADaikCADcDACAEQfgAaiIGIARBmANqKQIANwMAIARBiAFqIgkgBEGwAWopAgA3AwAgBEGQAWoiByAEQbgBaikCADcDACAEQZgBaiIIIARBwAFqKQIANwMAIARBoAFqIgogBEHIAWopAgA3AwAgBCAEKQL4AjcDWCAEIAQpAqgBNwOAASAELQD0AiELIARBKGogBikDADcDACAEQSBqIAUpAwA3AwAgBEEYaiACKQMANwMAIARBEGogAykDADcDACAEIAQpA1g3AwggBEHQAGogCikDADcDACAEQcgAaiAIKQMANwMAIARBQGsgBykDADcDACAEQThqIAkpAwA3AwAgBCAEKQOAATcDMCAAIAsEfyMAQTBrIgMkACABLQAfQQd2EOcCIQIgA0EIaiAEQQhqIgEQkAEgAUEAIAJB/wFxayICIAEoAgAiBSADKAIIc3EgBXM2AgAgASABKAIEIgUgAygCDHMgAnEgBXM2AgQgAUEIaiIFIAUoAgAiBiADKAIQcyACcSAGczYCACABIAEoAgwiBiADKAIUcyACcSAGczYCDCABQRBqIgYgBigCACIJIAMoAhhzIAJxIAlzNgIAIAEgASgCFCIJIAMoAhxzIAJxIAlzNgIUIAFBGGoiCSAJKAIAIgcgAygCIHMgAnEgB3M2AgAgASABKAIcIgcgAygCJHMgAnEgB3M2AhwgAUEgaiIHIAcoAgAiCCADKAIocyACcSAIczYCACABIAIgASgCJCIIIAMoAixzcSAIczYCJCAAQQRqIgBBIGogBykCADcCACAAQRhqIAkpAgA3AgAgAEEQaiAGKQIANwIAIABBCGogBSkCADcCACAAIAEpAgA3AgAgAEH4AGogASAEQTBqIgEQNiAAQcgAaiABQSBqKQIANwIAIABBQGsgAUEYaikCADcCACAAQThqIAFBEGopAgA3AgAgAEEwaiABQQhqKQIANwIAIAAgASkCADcCKCAAQfDkwAApAgA3AlAgAEHYAGpB+OTAACkCADcCACAAQeAAakGA5cAAKQIANwIAIABB6ABqQYjlwAApAgA3AgAgAEHwAGpBkOXAACkCADcCACADQTBqJABBAQVBAAs2AgAgBEGgA2okAAuoBAETfyABKAAcIREgASgAGCEOIAEoABQhDSABKAAQIQMgAigADCEPIAIoAAghCCACKAAEIQcgAigAACECIAEoAAwhCSABKAAIIQogASgABCELIAEoAAAhDEGy2ojLByEBQe7IgZkDIQRB5fDBiwYhBUH0yoHZBiEGQQohEgNAIAQgDGpBB3cgD3MiECAEakEJdyAOcyITIAUgDWpBB3cgCXMiCSAFakEJdyAIcyIUIAlqQQ13IA1zIhUgAyAGakEHdyAKcyIKIAZqQQl3IAdzIgcgCmpBDXcgA3MiCCAHakESdyAGcyIGIAEgAmpBB3cgEXMiA2pBB3dzIg0gBmpBCXdzIg4gDWpBDXcgA3MiESAOakESdyAGcyEGIAMgASADakEJdyALcyILakENdyACcyICIAtqQRJ3IAFzIgEgEGpBB3cgCHMiAyABakEJdyAUcyIIIANqQQ13IBBzIg8gCGpBEncgAXMhASATIBAgE2pBDXcgDHMiDGpBEncgBHMiBCAJakEHdyACcyICIARqQQl3IAdzIgcgAmpBDXcgCXMiCSAHakESdyAEcyEEIAogFCAVakESdyAFcyIFakEHdyAMcyIMIAVqQQl3IAtzIgsgDGpBDXcgCnMiCiALakESdyAFcyEFIBJBAWsiEg0ACyAAIA82ABwgACAINgAYIAAgBzYAFCAAIAI2ABAgACAGNgAMIAAgATYACCAAIAQ2AAQgACAFNgAAC+QEAQN/IwBB0CNrIgIkAAJAAkACQCABRQRAIABFDQEgAEEIayIBKAIAQQFHDQIgAkHoEWogAEHoEfwKAAAgAUEANgIAAkAgAUF/Rg0AIABBBGsiACAAKAIAQQFrIgA2AgAgAA0AIAFB8BFBCBD6AgsgAkEIaiACQfARakHgEfwKAAAgAigCoAEEQCACQQA2AqABCyACKAKQECEDIAIoApQQIgEEQCADIQADQCAAKAIAIgQEQCAAQQRqKAIAIARBARD6AgsgAEEMaiEAIAFBAWsiAQ0ACwsgAigCjBAiAARAIAMgAEEMbEEEEPoCCyACKAKAECIAQYCAgIB4RiAARXJFBEAgAigChBAgAEEBEPoCCyACKALoDyIABEAgAigC7A8gAEEBEPoCCyACKAL0DyIABEAgAigC+A8gAEEBEPoCCyACQZAPahCRAQJAIAIoApQPIgBFDQAgACAAQQN0QQ9qQXhxIgFqQQlqIgBFDQAgAigCkA8gAWsgAEEIEPoCCyACQcAPahCFAQJAIAIoAsQPIgBFDQAgACAAQQN0QQ9qQXhxIgFqQQlqIgBFDQAgAigCwA8gAWsgAEEIEPoCCyACKAKgECIBBEAgAigCnBAhAANAIAAoAgAiAwRAIABBBGooAgAgA0EBEPoCCyAAQQxqIQAgAUEBayIBDQALCyACKAKYECIARQ0DIAIoApwQIABBDGxBBBD6AgwDCyAARQ0AIAIgAEEIayIANgLoESAAIAAoAgBBAWsiADYCACAADQIgAkHoEWoQewwCCxCQAwALQfSfwABBPxCSAwALIAJB0CNqJAALlAUCAX8BfiMAQUBqIgIkAAJ/AkACQAJAAkACQAJAAkACQAJAAkAgACgCAEEBaw4JAQIDBAUGBwgJAAsgAiAAQQRqNgIMIAIgAEEIajYCJCACQQM2AiwgAkGsusAANgIoIAJCAjcCNCACQoCAgICQBSIDIAJBJGqthDcDGCACIAMgAkEMaq2ENwMQIAIgAkEQajYCMCABKAIAIAEoAgQgAkEoahBgDAkLIAEoAgBBxLrAAEEUIAEoAgQoAgwRAQAMCAsgASgCAEHYusAAQT4gASgCBCgCDBEBAAwHCyABKAIAQZa7wABBGCABKAIEKAIMEQEADAYLIAIgAEEEajYCJCACQQE2AiwgAkHIu8AANgIoIAJCATcCNCACIAJBJGqtQoCAgICgBYQ3AxAgAiACQRBqNgIwIAEoAgAgASgCBCACQShqEGAMBQsgAiAAQQRqNgIkIAJBATYCLCACQeS7wAA2AiggAkIBNwI0IAIgAkEkaq1CgICAgKAFhDcDECACIAJBEGo2AjAgASgCACABKAIEIAJBKGoQYAwECyABKAIAQey7wABBCSABKAIEKAIMEQEADAMLIAEoAgBB9bvAAEEXIAEoAgQoAgwRAQAMAgsgAiAAQQRqNgIMIAIgAEEMajYCJCACQQM2AiwgAkGwvMAANgIoIAJCAjcCNCACQoCAgICwBSIDIAJBDGqthDcDGCACIAMgAkEkaq2ENwMQIAIgAkEQajYCMCABKAIAIAEoAgQgAkEoahBgDAELIAIgAEEEajYCJCACQQE2AiwgAkHYvMAANgIoIAJCATcCNCACIAJBJGqtQoCAgICgBYQ3AxAgAiACQRBqNgIwIAEoAgAgASgCBCACQShqEGALIAJBQGskAAvpHAIFfhp/IwBB8ABrIgwkACABKAIARQRAIAFBfzYCACAAAn8jAEFAaiIQJAACQCABQQhqIg0oAgxFDQAgAigCCCEYIAIoAgQhFCANKQMQIQMgEEIANwMIIBBCADcDACAQIAM3AxAgEEEAOgA4IBBBoOTEACkDADcDMCAQQZjkxAApAwA3AyggEEGQ5MQAKQMANwMgIBBBiOTEACkDADcDGCAUIBggEBBtIA0oAgAiFUEIayESIA0oAgQiEwJ+IBAtADhFBEAgECkDEAwBCyAQKQMYIBApAwiFIgRCIIgiByAQKQMQIBApAwCFIgNCIIgiBX4gBEL/////D4MiBCADQv////8PgyIDfoUgBCAFfiADIAd+hUIgiIULIgOncSEPIANCGYhC/wCDQoGChIiQoMCAAX4hBANAAkAgDyAVaikAACIFIASFIgNCf4UgA0KBgoSIkKDAgAF9g0KAgYKEiJCgwIB/gyIDUEUEQANAIBIgA3qnQQN2IA9qIBNxIhZBA3RrKAIAIglBCGooAgAgGEYEQCAUIAlBBGooAgAgGBCDAkUNAwsgA0IBfSADgyIDUEUNAAsLIAUgBUIBhoNCgIGChIiQoMCAf4NQBEAgDyAOQQhqIg5qIBNxIQ8MAgVBACEPDAMLAAsLIBVBACAWa0EDdGpBBGsoAgAiDygCLCAPKAIwIg42AjAgDiAPKAIsNgIsIA8gDSgCHCIOKAIwNgIwIA8gDjYCLCAOIA82AjAgDygCMCAPNgIsCyAQQUBrJAAgDwRAIAAgDykAADcAASAAQRlqIA9BGGopAAA3AAAgAEERaiAPQRBqKQAANwAAIABBCWogD0EIaikAADcAAEEADAELIAxBGGogAigCBCACKAIIEEkgDCgCJCEOIAwoAiAhCSAMKAIcIRICQCAMKAIYIhZBioCAgHhHBEAgDCgCKCECDAELIA5BIEYEQCAMQe4AaiIdIAlBAmotAAA6AAAgDEEgaiIOIAlBH2otAAA6AAAgDCAJLwAAOwFsIAwgCSkAFzcDGCAJKAATIR4gCSgADyEfIAkoAAshICAJKAAHISEgCSgAAyEPIBIEQCAJIBJBARD6AgsgDEEQaiIQIA4tAAA6AAAgDCAMKQMYNwMIIAxBPGoiDiACEO8BIAxBygBqIB0tAAA6AAAgDEHnAGogEC0AADoAACAMIAwvAWw7AUggDCAeNgBbIAwgHzYAVyAMICA2AFMgDCAhNgBPIAwgDzYASyAMIAwpAwg3AF8gDEEYaiEbIAxByABqIQpBACEVQQAhGCMAQdAAayIIJAACQAJAAkAgDSgCDCIXRQ0AIA4oAgghGSAOKAIEIRQgDSkDECEDIAhCADcDGCAIQgA3AxAgCCADNwMgIAhBADoASCAIQaDkxAApAwA3A0AgCEGY5MQAKQMANwM4IAhBkOTEACkDADcDMCAIQYjkxAApAwA3AyggFCAZIAhBEGoQbSANKAIAIhNBCGshFiANKAIEIhICfiAILQBIRQRAIAgpAyAMAQsgCCkDKCAIKQMYhSIEQiCIIgcgCCkDICAIKQMQhSIDQiCIIgV+IARC/////w+DIgQgA0L/////D4MiA36FIAQgBX4gAyAHfoVCIIiFCyIDp3EhESADQhmIQv8Ag0KBgoSIkKDAgAF+IQQDQCARIBNqKQAAIgUgBIUiA0J/hSADQoGChIiQoMCAAX2DQoCBgoSIkKDAgH+DIgZQRQRAA0AgFiAGeqdBA3YgEWogEnEiCUEDdGsoAgAiAkEIaigCACAZRgRAIBQgAkEEaigCACAZEIMCRQ0FCyAGQgF9IAaDIgZQRQ0ACwsgBSAFQgGGg0KAgYKEiJCgwIB/g1BFDQEgESAVQQhqIhVqIBJxIREMAAsACwJAAkAgDSgCGCAXRwRAIAhBOGoiFyAOQQhqKAIANgIAIAhBGGoiFiAKQQhqKQAANwMAIAhBIGoiCSAKQRBqKQAANwMAIAhBKGoiAiAKQRhqKQAANwMAIAggDikCADcDMCAIIAopAAA3AxBBNEEEEIEDIgsNAUEEQTQQmgMACyANKAIgKAIsIhNBKGooAgAhCSATQSRqKAIAIA0pAxAhBiAIQgA3AxggCEIANwMQIAggBjcDICAIQQA6AEggCEGg5MQAKQMANwNAIAhBmOTEACkDADcDOCAIQZDkxAApAwA3AzAgCEGI5MQAKQMANwMoIAkgCEEQahBtIA0oAgAiGEEIayESIA0oAgQiFAJ+IAgtAEhFBEAgCCkDIAwBCyAIKQMoIAgpAxiFIgRCIIgiByAIKQMgIAgpAxCFIgNCIIgiBX4gBEL/////D4MiBCADQv////8PgyIDfoUgBCAFfiADIAd+hUIgiIULIgOncSERIANCGYhC/wCDQoGChIiQoMCAAX4hBCATQShqIRYgE0EkaiEJAkADQAJAIBEgGGopAAAiBSAEhSIDQn+FIANCgYKEiJCgwIABfYNCgIGChIiQoMCAf4MiA1BFBEAgFigCACETA0AgEiADeqdBA3YgEWogFHEiFUEDdGsoAgAiAkEIaigCACATRgRAIAkoAgAgAkEEaigCACATEIMCRQ0DCyADQgF9IAODIgNQRQ0ACwsgBSAFQgGGg0KAgYKEiJCgwIB/g1BFDQIgESAcQQhqIhxqIBRxIREMAQsLQYABIREgFSAYaiIJKQAAIgMgA0IBhoNCgIGChIiQoMCAf4N6p0EDdiAYIBVBCGsgFHFqIgIpAAAiAyADQgGGg0KAgYKEiJCgwIB/g3mnQQN2akEHTQRAIA0gDSgCCEEBajYCCEH/ASERCyAJIBE6AAAgAkEIaiAROgAAIBhBACAVa0EDdGpBBGsoAgAiCyAKKQAANwAAIAtBGGogCkEYaikAADcAACALQRBqIApBEGopAAA3AAAgC0EIaiAKQQhqKQAANwAAIAsoAiAhESALKAIkIRggCyAOKQIANwIgIAtBKGogDkEIaigCADYCACALKAIsIAsoAjAiAjYCMCANIBdBAWs2AgwgAiALKAIsNgIsDAILQYSywAAQ/AIACyALIAgpAxA3AgAgC0IANwIsIAtBKGogFygCADYCACALQSBqIAhBMGopAwA3AgAgC0EYaiACKQMANwIAIAtBEGogCSkDADcCACALQQhqIBYpAwA3AgAgDSkDECEGQYCAgIB4IRELIAsgDSgCHCICKAIwNgIwIAsgAjYCLCACIAs2AjAgCygCMCALNgIsIAtBKGooAgAhDiALQSRqKAIAIAhCADcDGCAIQgA3AxAgCCAGNwMgIAhBADoASCAIQaDkxAApAwA3A0AgCEGY5MQAKQMANwM4IAhBkOTEACkDADcDMCAIQYjkxAApAwA3AyggDiAIQRBqEG0CfiAILQBIRQRAIAgpAyAMAQsgCCkDKCAIKQMYhSIEQiCIIgcgCCkDICAIKQMQhSIDQiCIIgV+IARC/////w+DIgQgA0L/////D4MiA36FIAQgBX4gAyAHfoVCIIiFCyEDIA0oAghFBEAgCEEIaiANIA1BEGoQLwsgC0EgaiETIA0oAgAiGkEIayESIA0oAgQiGSADp3EhCiADQhmIIgVC/wCDQoGChIiQoMCAAX4hBCALQShqIRYgC0EkaiEJQQAhFEEAIRwDQAJ/AkAgGgJ/IAogGmopAAAiByAEhSIDQn+FIANCgYKEiJCgwIABfYNCgIGChIiQoMCAf4MiBlBFBEAgFigCACEVA0ACQCAVIBIgBnqnQQN2IApqIBlxIg5BA3RrKAIAIgJBCGooAgBHDQAgCSgCACACQQRqKAIAIBUQgwINAEEAIA5rDAMLIAZCAX0gBoMiBlBFDQALCyAHQoCBgoSIkKDAgH+DIQMgFEUEQCADUA0CIAN6p0EDdiAKaiAZcSEXC0EBIAMgB0IBhoNQDQIaIBcgGmosAAAiCkEATgRAIBogGikDAEKAgYKEiJCgwIB/g3qnQQN2IhdqLQAAIQoLIBcgGmogBadB/wBxIgI6AAAgGiAXQQhrIBlxakEIaiACOgAAIA0gDSgCCCAKQQFxazYCCCANIA0oAgxBAWo2AgwgGiAXQQN0a0EIayATNgIAQQAgF2sLQQN0akEEayALNgIAQQAhCyARQYCAgIB4ckGAgICAeEYNBCAYIBFBARD6AgwEC0EACyEUIBxBCGoiHCAKaiAZcSEKDAALAAsgCikAACEDIAogE0EAIAlrQQN0akEEaygCACIJKQAANwAAIAkgAzcAACAJKQAIIQMgCSAKKAAINgAIIAooAAwhAiAKIAM3AAggCSACNgAMIAooABAhAiAKIAkoABA2ABAgCSACNgAQIAooABQhAiAKIAkoABQ2ABQgCSACNgAUIAooABghAiAKIAkoABg2ABggCSACNgAYIAooABwhAiAKIAkoABw2ABwgCSACNgAcIAkoAiwgCSgCMCICNgIwIAIgCSgCLDYCLCAJIA0oAhwiAigCMDYCMCAJIAI2AiwgAiAJNgIwIAkoAjAgCTYCLCAOKAIAIgJBgICAgHhGBEAMAQsgGyAKKQAANwABIBtBGWogCkEYaikAADcAACAbQRFqIApBEGopAAA3AAAgG0EJaiAKQQhqKQAANwAAQQEhCyACRQ0AIBQgAkEBEPoCCyAbIAs6AAAgCEHQAGokACAAQQNqIB0tAAA6AAAgACAMLwFsOwABIAAgHjYCFCAAIB82AhAgACAgNgIMIAAgITYCCCAAIA82AgQgACAMKQMINwAYIABBIGogEC0AADoAAEEADAILIBIEQCAJIBJBARD6AgtBICESQYeAgIB4IRYgDiEJCyAAIAI2AhQgACAONgIQIAAgCTYCDCAAIBI2AgggACAWNgIEQQELOgAAIAEgASgCAEEBajYCACAMQfAAaiQADwtB2L3AABCiAwAL7gUBAX4gACABQiCIIgJCppfEiQ1+IAFC/////w+DIgFCrOv+xgl+hSACQqzr/sYJfiABQqaXxIkNfoVCIImFIgFCIIgiAkKml8SJDX4gAUL/////D4MiAUKs6/7GCX6FIAJCrOv+xgl+IAFCppfEiQ1+hUIgiYUiAUIgiCICQqaXxIkNfiABQv////8PgyIBQqzr/sYJfoUgAkKs6/7GCX4gAUKml8SJDX6FQiCJhSIBQoGAgICIgICAgH+ENwMAIAAgAUIgiCICQqaXxIkNfiABQv////8PgyIBQqzr/sYJfoUgAkKs6/7GCX4gAUKml8SJDX6FQiCJhSIBQiCIIgJCppfEiQ1+IAFC/////w+DIgFCrOv+xgl+hSACQqzr/sYJfiABQqaXxIkNfoVCIImFIgFCIIgiAkKml8SJDX4gAUL/////D4MiAUKs6/7GCX6FIAJCrOv+xgl+IAFCppfEiQ1+hUIgiYUiAUKBgICAiICAgIB/hDcDCCAAIAFCIIgiAkKml8SJDX4gAUL/////D4MiAUKs6/7GCX6FIAJCrOv+xgl+IAFCppfEiQ1+hUIgiYUiAUIgiCICQqaXxIkNfiABQv////8PgyIBQqzr/sYJfoUgAkKs6/7GCX4gAUKml8SJDX6FQiCJhSIBQiCIIgJCppfEiQ1+IAFC/////w+DIgFCrOv+xgl+hSACQqzr/sYJfiABQqaXxIkNfoVCIImFIgFCgYCAgIiAgICAf4Q3AxAgACABQiCIIgJCppfEiQ1+IAFC/////w+DIgFCrOv+xgl+hSACQqzr/sYJfiABQqaXxIkNfoVCIImFIgFCIIgiAkKml8SJDX4gAUL/////D4MiAUKs6/7GCX6FIAJCrOv+xgl+IAFCppfEiQ1+hUIgiYUiAUIgiCICQqaXxIkNfiABQv////8PgyIBQqzr/sYJfoUgAkKs6/7GCX4gAUKml8SJDX6FQiCJhUKBgICAiICAgIB/hDcDGAuCMgIhfwd+IwBBgAFrIggkACAIQSRqIAFBEGopAgA3AgAgCEEcaiABQQhqKQIANwIAIAhBgAE6ACwgCEEANgIQIAhCgICAgBA3AgggCCABKQIANwIUIwBBkAFrIgUkACAFQdAAaiAIQQhqECogBSgCVCEBAkAgBSgCUCIGQZWAgIB4RgRAIABCBDcDACAAIAE2AggMAQsgBSAFKQNYNwMIIAUgATYCBCAFIAY2AgAgBUHQAGohAkEAIQYjAEHQAGsiBCQAQYCAgIB4IRECQAJAAkACQEEVIAUoAgAiAUGAgICAeHMgAUEAThtBFGsOAgECAAsgBSAEQcwAakHossAAEMICIQEgAkIDNwMAIAIgATYCCAwCCwJAAkACfwJAAkACQAJ/AkACQAJAAkACQAJ/AkACfyAFKAIMIgYEQCAEQQhqIgEgBSgCCCILEJYBIAQoAgwiDSAEKAIIIgdBgICAgHhGDQEaIAZBAUYNAiAEKAIQIREgASALQRBqEJYBIAQoAgwiDyAEKAIIIgNBgICAgHhGDQMaIAZBAkYNCCAEKAIQIQ4gASALQSBqEDogBCgCECIUIAQpAwgiI0IDUQ0JGiAGQQNGDQogBCgCFCETQYCAgIB4IQxBFSALKAIwIgFBgICAgHhzIAFBAE4bQRBrDgMHBQcEC0EAQeyzwABB9LPAABDgAQshASACQgM3AwAgAiABNgIIDA8LQQFB7LPAAEH0s8AAEOABCyEBIAJCAzcDACACIAE2AggMCwsgBEEIaiALQTBqEJYBIAQoAgwhCiAEKAIIIgxBgICAgHhHDQEMBgsgBEEIaiALKAI0EJYBIAQoAgwhCiAEKAIIIgxBgICAgHhGDQULIAQoAhAhCQsgBkEERg0EIARBCGoiASALQUBrEJYBIAQoAgwiCyAEKAIIIhZBgICAgHhGDQUaIAQoAhAhFyACIBM2AgwgAkEIaiITIBQ2AgAgAiANNgIUIAJBEGoiDSAHNgIAIAIgAzYCHCACQRhqIgcgETYCACACIA42AiQgAkEgaiIDIA82AgAgAiALNgIsIAJBKGoiCyAWNgIAIAIgDDYCNCACQTBqIgwgFzYCACACIAk2AjwgAkE4aiIJIAo2AgAgAiAjNwMAIARBEGogEykDADcDACAEQRhqIA0pAwA3AwAgBEEgaiAHKQMANwMAIARBKGogAykDADcDACAEQTBqIAspAwA3AwAgBEE4aiAMKQMANwMAIARBQGsgCSkDADcDACAEICM3AwggBkEFRg0JIARBBTYCTCAGQfv///8AakH/////AHFBBWogBEHMAGpBwLTAABDgASEGIAJCAzcDACACIAY2AgggASgCECIGBEAgASgCFCAGQQEQ+gILIAEoAhwiBgRAIAEoAiAgBkEBEPoCCyABKAI0IgZBgICAgHhGIAZFckUEQCABKAI4IAZBARD6AgsgASgCKCIGBEAgASgCLCAGQQEQ+gILDAkLQQJB7LPAAEH0s8AAEOABCyEBIAJCAzcDACACIAE2AggMBAtBA0Hss8AAQfSzwAAQ4AEhCgsgAkIDNwMAIAIgCjYCCAwCC0EEQeyzwABB9LPAABDgAQshASACQgM3AwAgAiABNgIIIAxBgICAgHhyQYCAgIB4Rg0AIAogDEEBEPoCCyADRQ0AIA8gA0EBEPoCCyAHRQ0BIA0gB0EBEPoCDAELAkACQAJAAn8CfwJAIAUoAggiAUUEQEGBgICAeCENQYCAgIB4IQoMAQsgAUEFdCEgIAUoAgQhIUGBgICAeCENQYCAgIB4IQpBgICAgHghDEIDISMDQCABIQYCQAJAAkACQAJAAkACQAJAQRUgDyAhaiIDKAIAIg5BgICAgHhzIA5BAE4bQQFrDg8BAAACAAAAAAAAAAMEBQYACyADIARBzABqQYizwAAQwgIhDiAEQQE6AAggBCAONgIMDAYLIARBADoACCAEQQUgA0EEai0AACIOIA5BBU8bOgAJDAULIARBADoACCAEQgUgA0EIaikDACIkICRCBVobPAAJDAQLIARBCGogA0EIaigCACADQQxqKAIAEOQBDAMLIARBCGogA0EEaigCACADQQhqKAIAEOQBDAILIARBCGogA0EIaigCACADQQxqKAIAEHYMAQsgBEEIaiADQQRqKAIAIANBCGooAgAQdgsCQAJA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/////wFxIAZB/////wFxIAVB/////wFxIAJB/////wFxIAxB7afX5wFxIARB/////wFxaiICQR12aiANQdKxzARxaiIDQR12aiAOQZbrnO8BcWoiBEEddmogD0HF+s7vAXFqIgVBHXZqIBBBzQJxaiIGQR12aiIHQR12aiIIQR12aiIJQf////8BcTYCHCAAIAhB/////wFxNgIYIAAgB0H/////AXE2AhQgACAGQf////8BcTYCECAAIAVB/////wFxNgIMIAAgBEH/////AXE2AgggACADQf////8BcTYCBCAAIAJB/////wFxNgIAIAAgCUEddiALaiABQYCAwABxakH/////AXE2AiAL0QQBCn8jAEEwayIGJAACQCABQcABcSIKRQ0AIAZBCGogADYCACAKQcAARgRAQQEhBwwBCyAGIABBQGs2AgwgCkGAAUYEQEECIQcMAQsgBiAAQYABajYCEEGs28AAQSsgBkEQakGM3MAAQbjYwAAQ5gEACyAFQQV2IgkgByAHIAlLGyIIBEAgBkEIaiEJIANBBHIhCyAIQQV0IQxBACEDA0AgCSgCACEIIAZBKGoiDSACQRhqKQIANwMAIAZBIGoiDiACQRBqKQIANwMAIAZBGGoiDyACQQhqKQIANwMAIAYgAikCADcDECAGQRBqIAhBwABCACALECIgAyAEaiIIQRhqIA0pAwA3AAAgCEEQaiAOKQMANwAAIAhBCGogDykDADcAACAIIAYpAxA3AAAgCUEEaiEJIAwgA0EgaiIDRw0ACwsCQAJAAkAgAUE/cSICBEAgBSAHQQV0IgFJDQEgBSABayIDQR9NDQIgAkEgRw0DIAEgBGoiASAAIApqIgApAAA3AAAgAUEYaiAAQRhqKQAANwAAIAFBEGogAEEQaikAADcAACABQQhqIABBCGopAAA3AAAgB0EBaiEHCyAGQTBqJAAgBw8LIAEgBSAFQajYwAAQmAIAC0EAQSAgA0GI2MAAEJgCAAsjAEEwayIAJAAgAEEgNgIEIAAgAjYCACAAQQM2AgwgAEGE0sQANgIIIABCAjcCFCAAIABBBGqtQoCAgIDgCIQ3AyggACAArUKAgICA4AiENwMgIAAgAEEgajYCECAAQQhqQZjYwAAQvwIAC4cEAQV/IAAoAggiBCAAKAIARgRAIAAgBEEBQQFBARDJASAA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IAAoAjRBAEGAgIAIIAIbaiABKAAMQQh2aq0iCCAAKAIcIgJBBWytIgl+fCAAKAIwIAEoAAlBBnZqrSIKIAAoAiAiAUEFbK0iBH58IAMgB34gBSALfnwgBCAGfnwgCCARQQVsrSIMfnwgCSAKfnwgAyAEfiAFIAd+fCAGIAl+fCAIIBBBBWytfnwgCiAMfnwiCUIaiEL/////D4N8IgxCGohC/////w+DfCIOp0H///8fcTYCLCAAIAMgDX4gBSACrSIPfnwgBiALfnwgBCAIfnwgByAKfnwgDkIaiEL/////D4N8IgSnQf///x9xNgIwIAAgAyAPfiAFIAGtfnwgBiANfnwgByAIfnwgCiALfnwgBEIaiEL/////D4N8IgOnQf///x9xNgI0IAAgA0IaiKdBBWwgCadB////H3FqIgFB////H3E2AiQgACAMp0H///8fcSABQRp2ajYCKAvlAwIYfgF/IAExAAghCCABMQAHIQkgATEACSECIAExAAshCiABMQAKIQsgATEAFSEMIAExABQhDSABMQAWIQMgATEAGCEOIAExABchDyABMQAZIQQgATEAGyEQIAExABohESABMQAGIQUgATEABSESIAExAAQhEyABMQAPIRQgATEADiEVIAExAA0hFiABMQAMIQYgATEAHyEXIAExAB4hGCABMQAdIRkgATEAHCEHIAEoAAAhGiAAIAEoABAiAUH///8PcTYCFCAAIBpB////H3E2AgAgACAXQhKGQoCA8A+DIBlCAoYgB0IGiIQgGEIKhoSEPgIkIAAgFkIChiAGQgaIhCAVQgqGhCAUQhKGhD4CECAAIAVCFoZCgICADoMgGkEadq0gE0IGhoQgEkIOhoSEPgIEIAAgEEIMhiARQgSGhCAEQgSIhCAHQhSGhKdB////H3E2AiAgACAOQg2GIA9CBYaEIANCA4iEIARCFYaEp0H///8PcTYCHCAAIAFBGXatIAxCD4YgDUIHhoSEIANCF4aEp0H///8fcTYCGCAAIApCC4YgC0IDhoQgAkIFiIQgBkIThoSnQf///w9xNgIMIAAgCEINhiAJQgWGhCAFQgOIhCACQhWGhKdB////H3E2AggLqyQCE38CfiMAQTBrIhAkAAJAAkACQAJ/IAEoAgAiDQRAIAIoAgghCyACKAIEIQkgASgCBCEFAkADQCANQYwC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eHMgBiAFQQBKIAQgBkpzGwwBCyAEIAVqIgZBH3VBgICAgHhzIAYgBUEASCAEIAZKcxsLEKEBCyAHQSBqJAALsgMBB38jAEEwayIEJAACQAJAAkACQCABKAIEIgIEQCABKAIAIQYgAkEDcSEFAkAgAkEESQRAQQAhAgwBCyAGQRxqIQMgAkF8cSEIQQAhAgNAIAMoAgAgA0EIaygCACADQRBrKAIAIANBGGsoAgAgAmpqamohAiADQSBqIQMgCCAHQQRqIgdHDQALCyAFBEAgB0EDdCAGakEEaiEDA0AgAygCACACaiECIANBCGohAyAFQQFrIgUNAAsLIAEoAgxFDQIgAkEPSw0BIAYoAgQNAQwDC0EAIQIgASgCDEUNAgsgAkEAIAJBAEobQQF0IQILQQAhAyACQQBOBEAgAkUNAUEBIQMgAkEBEIEDIgUNAgsgAyACENsCAAtBASEFQQAhAgsgBEEANgIMIAQgBTYCCCAEIAI2AgQgBEEgaiABQRBqKQIANwMAIARBGGogAUEIaikCADcDACAEIAEpAgA3AxAgBEEEakHYrcQAIARBEGoQYEUEQCAAIAQpAgQ3AgAgAEEIaiAEQQxqKAIANgIAIARBMGokAA8LQcSsxABB1gAgBEEvakG0rMQAQZytxAAQ5gEAC+EDAgZ+Dn8gAigCJCEJIAEoAiQhCiACKAIgIQsgASgCICEMIAIoAgwhDSABKAIMIQ4gAigCHCEPIAEoAhwhECACKAIIIREgASgCCCESIAIoAgQhEyABKAIEIRQgAigCACEVIAEoAgAhFiAAIAEoAhggAigCGGtB8P///wNqrSABKAIUIAIoAhRrQfD///8Baq0gASgCECACKAIQa0Hw////A2qtIgNCGoh8IgZCGYh8IgSnQf///x9xNgIYIAAgEiARa0Hw////A2qtIBQgE2tB8P///wFqrSAWIBVrQdD9//8Daq0iB0IaiHwiCEIZiHwiBadB////H3E2AgggACAQIA9rQfD///8Baq0gBEIaiHwiBKdB////D3E2AhwgACAOIA1rQfD///8Baq0gBUIaiHwiBadB////D3E2AgwgACAMIAtrQfD///8Daq0gBEIZiHwiBKdB////H3E2AiAgACAGQv///w+DIANC////H4MgBUIZiHwiA0IaiHw+AhQgACADp0H///8fcTYCECAAIAogCWtB8P///wFqrSAEQhqIfCIDp0H///8PcTYCJCAAIAhC////D4MgA0IZiEITfiAHQv///x+DfCIDQhqIfD4CBCAAIAOnQf///x9xNgIAC8kDAQN/IAAoAgAiASgCqAEEQCABQQA2AqgBCyABKAKcECICBEAgASgCmBAhAANAIAAoAgAiAwRAIABBBGooAgAgA0EBEPoCCyAAQQxqIQAgAkEBayICDQALCyABKAKUECIABEAgASgCmBAgAEEMbEEEEPoCCyABKAKIECIAQYCAgIB4RiAARXJFBEAgASgCjBAgAEEBEPoCCyABKALwDyIABEAgASgC9A8gAEEBEPoCCyABKAL8DyIABEAgASgCgBAgAEEBEPoCCyABQZgPaiICEJEBAkAgASgCnA8iAEUNACAAIABBA3RBD2pBeHEiA2pBCWoiAEUNACACKAIAIANrIABBCBD6AgsgAUHID2oiAhCFAQJAIAEoAswPIgBFDQAgACAAQQN0QQ9qQXhxIgNqQQlqIgBFDQAgAigCACADayAAQQgQ+gILIAEoAqgQIgIEQCABKAKkECEAA0AgACgCACIDBEAgAEEEaigCACADQQEQ+gILIABBDGohACACQQFrIgINAAsLIAEoAqAQIgAEQCABKAKkECAAQQxsQQQQ+gILAkAgAUF/Rg0AIAEgASgCBEEBayIANgIEIAANACABQfARQQgQ+gILC+cCAQV/IwBB8AFrIgIkACACQaABaiIDIAFB0ABqEDMgAkHwAGogAkHAAWopAgA3AwAgAkHoAGogAkG4AWopAgA3AwAgAkHgAGogAkGwAWopAgA3AwAgAkHYAGogAkGoAWopAgA3AwAgAiACKQKgATcDUCACQZgBaiACQegBaikCADcDACACQZABaiACQeABaikCADcDACACQYgBaiACQdgBaikCADcDACACQYABaiACQdABaikCADcDACACIAIpAsgBNwN4IAMgAkHQAGoiBkEFEEwgAkEIaiIEIAMgAkH4AGoiBRA2IAUgASAEEDYgAyABQShqIAQQNiACQTBqIAMQRSAGIAUQRSACLQBQQQFxEOcCIQEgACACKQAwNwAAIABBCGogAkE4aikAADcAACAAQRBqIAJBQGspAAA3AAAgAiACLQBPIAFBB3RzOgBPIABBGGogAkHIAGopAAA3AAAgAkHwAWokAAuWAwEEfwJAAkACQAJAAkACQCAHIAhWBEAgByAIfSAIWA0DIAYgByAGfVQgByAGQgGGfSAIQgGGWnENAiAGIAhYDQYgByAGIAh9IgZ9IAZWDQYgAiADTw0BQQAgAyACQcDExAAQmAIACyAAQQA2AgAPCyABIANqIQwgASEKAkACQAJAA0AgAyAJRg0BIAlBAWohCSAKQQFrIgogA2oiCy0AAEE5Rg0ACyALIAstAABBAWo6AAAgAyAJa0EBaiIFIANNDQEgBSADIANB/LnEABCYAgALAkAgA0UEQEExIQkMAQsgAUExOgAAQTAhCSADQQFrIgpFDQAgAUEBakEwIAr8CwALIARBAWrBIgQgBcFMIAIgA01yDQEgDCAJOgAAIANBAWohAwwBCyAJQQFrIgVFDQAgC0EBakEwIAX8CwALIAIgA0kNAgwDCyACIANPDQJBACADIAJB0MTEABCYAgALIABBADYCAA8LQQAgAyACQbDExAAQmAIACyAAIAQ7AQggACADNgIEIAAgATYCAA8LIABBADYCAAuZAwECfwJAAkACQCAALQBoIgMEQCADQcEATw0DIAJBwAAgA2siBCACIARJGyIEBEAgACADaiABIAT8CgAACyAAIAAtAGggBGoiAzoAaCABIARqIQEgAiAEayICRQRAQQAhAgwCCyAAQUBrIABBwAAgACkDYCAALQBqIAAtAGlFchAiIABCADcDACAAQQA6AGggAEEIakIANwMAIABBEGpCADcDACAAQRhqQgA3AwAgAEEgakIANwMAIABBKGpCADcDACAAQTBqQgA3AwAgAEE4akIANwMAIAAgAC0AaUEBajoAaQtBACEDIAJBwQBJDQEgAEFAayEEIAAtAGkhAwNAIAQgAUHAACAAKQNgIAAtAGogA0H/AXFFchAiIAAgAC0AaUEBaiIDOgBpIAFBQGshASACQUBqIgJBwABLDQALIAAtAGghAwsgA0H/AXEiA0HBAE8NAQsgAkHAACADayIEIAIgBEkbIgIEQCAAIANqIAEgAvwKAAALIAAgAC0AaCACajoAaCAADwsgA0HAAEHAAEGU18AAEJgCAAuVAwEHfyAAIAEoAiAiAjoAHSAAIAEoAgAiBToAACAAIAJBEHY6AB8gACACQQh2OgAeIAAgASgCHCIGQRV2OgAcIAAgBkENdjoAGyAAIAZB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KAI8ISIgBigCHCEYIAYoAkQhGSABIAYoAiQgBigCTGo2AowOIAEgFSAXajYCiA4gASAYIBlqNgKEDiABIA0gEmo2AoAOIAEgISAiajYC/A0gASAKIAxqNgL4DSABIB8gIGo2AvQNIAEgAyAHajYC8A0gASAeICVqNgLsDSABIBYgHWo2AugNIAFBkA5qIgcgBkEoaiAGEHogAUHYDmogBkHwAGoiFSkCADcCACABQdAOaiAGQegAaiIXKQIANwIAIAFByA5qIAZB4ABqIhIpAgA3AgAgAUHADmogBkHYAGoiFikCADcCACABIAYpAlA3ArgOIAFBCGoiSiIDIAZB+ABqQdDjwAAQNiABQYAPaiABQShqKQIANwIAIAFB+A5qIAFBIGopAgA3AgAgAUHwDmogAUEYaikCADcCACABQegOaiABQRBqKQIANwIAIAEgASkCCDcC4A4gAyABQegNaiIDQaAB/AoAACABQagBaiInIANBoAH8CgAAIAFByAJqIjggA0GgAfwKAAAgAUHoA2oiQSADQaAB/AoAACABQYgFaiJFIANBoAH8CgAAIAFBqAZqIkcgA0GgAfwKAAAgAUHIB2oiSyADQaAB/AoAACABQegIaiJNIANBoAH8CgAAIAFBkA1qIgogECkCADcDACABQYgNaiIMIBQpAgA3AwAgAUGADWoiDSARKQIANwMAIAFB+AxqIhEgEykCADcDACABQaANaiITIBYpAgA3AwAgAUGoDWoiFCASKQIANwMAIAFBsA1qIhIgFykCADcDACABQbgNaiIXIBUpAgA3AwAgASAGKQIoNwPwDCABIAYpAlA3A5gNIAFB6AxqIA8pAgA3AwAgAUHgDGogDikCADcDACABQdgMaiAaKQIANwMAIAFB0AxqIAkpAgA3AwAgASAGKQIANwPIDCADIAFByAxqIhoQLCABQYgKaiIdIAMgAUHgDmoiBhA2IAFBsA9qIh4gByABQbgOaiIJEDYgAUHYD2oiDiAJIAYQNiABQagLaiIlIAMgBxA2IAFB0ApqIAFB0A9qIh8pAgA3AgAgAUHICmogAUHID2oiICkCADcCACABQcAKaiABQcAPaiIhKQIANwIAIAFBuApqIAFBuA9qIiIpAgA3AgAgAUHgCmogAUHgD2oiDykCADcCACABQegKaiABQegPaiIQKQIANwIAIAFB8ApqIAFB8A9qIhUpAgA3AgAgAUH4CmogAUH4D2oiFikCADcCACABIAEpArAPNwKwCiABIAEpAtgPNwLYCiABQaALaiABQcgLaikCADcCACABQZgLaiABQcALaikCADcCACABQZALaiABQbgLaikCADcCACABQYgLaiABQbALaikCADcCACABIAEpAqgLNwKACyADIB0gShA+IBogAyAGEDYgAUGID2oiGCAHIAkQNiAeIAkgBhA2IA4gAyAHEDYgCiABQagPaiIZKQIANwIAIAwgAUGgD2oiGykCADcCACANIAFBmA9qIhwpAgA3AgAgESABQZAPaiIjKQIANwIAIBMgIikCADcCACAUICEpAgA3AgAgEiAgKQIANwIAIBcgHykCADcCACABIAEpAogPNwLwDCABIAEpArAPNwKYDSABQeANaiIkIBYpAgA3AgAgAUHYDWoiJiAVKQIANwIAIAFB0A1qIjkgECkCADcCACABQcgNaiI6IA8pAgA3AgAgASABKQLYDzcCwA0gESgCACEoIA0oAgAhKSAMKAIAISogCigCACErIAEoAsgMISwgASgC8AwhLSABKALMDCEuIAEoAvQMIS8gASgC0AwhMCABKALUDCFCIAEoAvwMIUMgASgC2AwhMSABKALcDCEyIAEoAoQNITMgASgC4AwhNCABKALkDCE1IAEoAowNITYgASgC6AwhNyABIAEoAuwMIAEoApQNajYCzAsgASArIDdqNgLICyABIDUgNmo2AsQLIAEgKiA0ajYCwAsgASAyIDNqNgK8CyABICkgMWo2ArgLIAEgQiBDajYCtAsgASAoIDBqNgKwCyABIC4gL2o2AqwLIAEgLCAtajYCqAsgAUHQC2oiKCABQfAMaiIpIBoQeiABQZgMaiIqIBcpAgA3AgAgAUGQDGoiKyASKQIANwIAIAFBiAxqIiwgFCkCADcCACABQYAMaiItIBMpAgA3AgAgASABKQKYDTcC+AsgDiABQcANaiIuQdDjwAAQNiABQcAMaiIvIBYpAgA3AgAgAUG4DGoiMCAVKQIANwIAIAFBsAxqIkIgECkCADcCACABQagMaiJDIA8pAgA3AgAgASABKQLYDzcCoAwgJyAlQaAB/AoAACADIB0gJxA+IBogAyAGEDYgGCAHIAkQNiAeIAkgBhA2IA4gAyAHEDYgCiAZKQIANwIAIAwgGykCADcCACANIBwpAgA3AgAgESAjKQIANwIAIBMgIikCADcCACAUICEpAgA3AgAgEiAgKQIANwIAIBcgHykCADcCACABIAEpAogPNwLwDCABIAEpArAPNwKYDSAkIBYpAgA3AgAgJiAVKQIANwIAIDkgECkCADcCACA6IA8pAgA3AgAgASABKQLYDzcCwA0gESgCACEnIA0oAgAhMSAMKAIAITIgCigCACEzIAEoAsgMITQgASgC8AwhNSABKALMDCE2IAEoAvQMITcgASgC0AwhOyABKALUDCE8IAEoAvwMIT0gASgC2AwhPiABKALcDCE/IAEoAoQNIUAgASgC4AwhRCABKALkDCFGIAEoAowNIUggASgC6AwhTiABIAEoAuwMIAEoApQNajYCzAsgASAzIE5qNgLICyABIEYgSGo2AsQLIAEgMiBEajYCwAsgASA/IEBqNgK8CyABIDEgPmo2ArgLIAEgPCA9ajYCtAsgASAnIDtqNgKwCyABIDYgN2o2AqwLIAEgNCA1ajYCqAsgKCApIBoQeiAqIBcpAgA3AgAgKyASKQIANwIAICwgFCkCADcCACAtIBMpAgA3AgAgASABKQKYDTcC+AsgDiAuQdDjwAAQNiAvIBYpAgA3AgAgMCAVKQIANwIAIEIgECkCADcCACBDIA8pAgA3AgAgASABKQLYDzcCoAwgOCAlQaAB/AoAACADIB0gOBA+IBogAyAGEDYgGCAHIAkQNiAeIAkgBhA2IA4gAyAHEDYgCiAZKQIANwIAIAwgGykCADcCACANIBwpAgA3AgAgESAjKQIANwIAIBMgIikCADcCACAUICEpAgA3AgAgEiAgKQIANwIAIBcgHykCADcCACABIAEpAogPNwLwDCABIAEpArAPNwKYDSAkIBYpAgA3AgAgJiAVKQIANwIAIDkgECkCADcCACA6IA8pAgA3AgAgASABKQLYDzcCwA0gESgCACEnIA0oAgAhOCAMKAIAITEgCigCACEyIAEoAsgMITMgASgC8AwhNCABKALMDCE1IAEoAvQMITYgASgC0AwhNyABKALUDCE7IAEoAvwMITwgASgC2AwhPSABKALcDCE+IAEoAoQNIT8gASgC4AwhQCABKALkDCFEIAEoAowNIUYgASgC6AwhSCABIAEoAuwMIAEoApQNajYCzAsgASAyIEhqNgLICyABIEQgRmo2AsQLIAEgMSBAajYCwAsgASA+ID9qNgK8CyABIDggPWo2ArgLIAEgOyA8ajYCtAsgASAnIDdqNgKwCyABIDUgNmo2AqwLIAEgMyA0ajYCqAsgKCApIBoQeiAqIBcpAgA3AgAgKyASKQIANwIAICwgFCkCADcCACAtIBMpAgA3AgAgASABKQKYDTcC+AsgDiAuQdDjwAAQNiAvIBYpAgA3AgAgMCAVKQIANwIAIEIgECkCADcCACBDIA8pAgA3AgAgASABKQLYDzcCoAwgQSAlQaAB/AoAACADIB0gQRA+IBogAyAGEDYgGCAHIAkQNiAeIAkgBhA2IA4gAyAHEDYgCiAZKQIANwIAIAwgGykCADcCACANIBwpAgA3AgAgESAjKQIANwIAIBMgIikCADcCACAUICEpAgA3AgAgEiAgKQIANwIAIBcgHykCADcCACABIAEpAogPNwLwDCABIAEpArAPNwKYDSAkIBYpAgA3AgAgJiAVKQIANwIAIDkgECkCADcCACA6IA8pAgA3AgAgASABKQLYDzcCwA0gESgCACEnIA0oAgAhOCAMKAIAIUEgCigCACExIAEoAsgMITIgASgC8AwhMyABKALMDCE0IAEoAvQMITUgASgC0AwhNiABKALUDCE3IAEoAvwMITsgASgC2AwhPCABKALcDCE9IAEoAoQNIT4gASgC4AwhPyABKALkDCFAIAEoAowNIUQgASgC6AwhRiABIAEoAuwMIAEoApQNajYCzAsgASAxIEZqNgLICyABIEAgRGo2AsQLIAEgPyBBajYCwAsgASA9ID5qNgK8CyABIDggPGo2ArgLIAEgNyA7ajYCtAsgASAnIDZqNgKwCyABIDQgNWo2AqwLIAEgMiAzajYCqAsgKCApIBoQeiAqIBcpAgA3AgAgKyASKQIANwIAICwgFCkCADcCACAtIBMpAgA3AgAgASABKQKYDTcC+AsgDiAuQdDjwAAQNiAvIBYpAgA3AgAgMCAVKQIANwIAIEIgECkCADcCACBDIA8pAgA3AgAgASABKQLYDzcCoAwgRSAlQaAB/AoAACADIB0gRRA+IBogAyAGEDYgGCAHIAkQNiAeIAkgBhA2IA4gAyAHEDYgCiAZKQIANwIAIAwgGykCADcCACANIBwpAgA3AgAgESAjKQIANwIAIBMgIikCADcCACAUICEpAgA3AgAgEiAgKQIANwIAIBcgHykCADcCACABIAEpAogPNwLwDCABIAEpArAPNwKYDSAkIBYpAgA3AgAgJiAVKQIANwIAIDkgECkCADcCACA6IA8pAgA3AgAgASABKQLYDzcCwA0gESgCACEnIA0oAgAhOCAMKAIAIUEgCigCACFFIAEoAsgMITEgASgC8AwhMiABKALMDCEzIAEoAvQMITQgASgC0AwhNSABKALUDCE2IAEoAvwMITcgASgC2AwhOyABKALcDCE8IAEoAoQNIT0gASgC4AwhPiABKALkDCE/IAEoAowNIUAgASgC6AwhRCABIAEoAuwMIAEoApQNajYCzAsgASBEIEVqNgLICyABID8gQGo2AsQLIAEgPiBBajYCwAsgASA8ID1qNgK8CyABIDggO2o2ArgLIAEgNiA3ajYCtAsgASAnIDVqNgKwCyABIDMgNGo2AqwLIAEgMSAyajYCqAsgKCApIBoQeiAqIBcpAgA3AgAgKyASKQIANwIAICwgFCkCADcCACAtIBMpAgA3AgAgASABKQKYDTcC+AsgDiAuQdDjwAAQNiAvIBYpAgA3AgAgMCAVKQIANwIAIEIgECkCADcCACBDIA8pAgA3AgAgASABKQLYDzcCoAwgRyAlQaAB/AoAACADIB0gRxA+IBogAyAGEDYgGCAHIAkQNiAeIAkgBhA2IA4gAyAHEDYgCiAZKQIANwIAIAwgGykCADcCACANIBwpAgA3AgAgESAjKQIANwIAIBMgIikCADcCACAUICEpAgA3AgAgEiAgKQIANwIAIBcgHykCADcCACABIAEpAogPNwLwDCABIAEpArAPNwKYDSAkIBYpAgA3AgAgJiAVKQIANwIAIDkgECkCADcCACA6IA8pAgA3AgAgASABKQLYDzcCwA0gESgCACEnIA0oAgAhOCAMKAIAIUEgCigCACFFIAEoAsgMIUcgASgC8AwhMSABKALMDCEyIAEoAvQMITMgASgC0AwhNCABKALUDCE1IAEoAvwMITYgASgC2AwhNyABKALcDCE7IAEoAoQNITwgASgC4AwhPSABKALkDCE+IAEoAowNIT8gASgC6AwhQCABIAEoAuwMIAEoApQNajYCzAsgASBAIEVqNgLICyABID4gP2o2AsQLIAEgPSBBajYCwAsgASA7IDxqNgK8CyABIDcgOGo2ArgLIAEgNSA2ajYCtAsgASAnIDRqNgKwCyABIDIgM2o2AqwLIAEgMSBHajYCqAsgKCApIBoQeiAqIBcpAgA3AgAgKyASKQIANwIAICwgFCkCADcCACAtIBMpAgA3AgAgASABKQKYDTcC+AsgDiAuQdDjwAAQNiAvIBYpAgA3AgAgMCAVKQIANwIAIEIgECkCADcCACBDIA8pAgA3AgAgASABKQLYDzcCoAwgSyAlQaAB/AoAACADIB0gSxA+IBogAyAGEDYgGCAHIAkQNiAeIAkgBhA2IA4gAyAHEDYgCiAZKQIANwIAIAwgGykCADcCACANIBwpAgA3AgAgESAjKQIANwIAIBMgIikCADcCACAUICEpAgA3AgAgEiAgKQIANwIAIBcgHykCADcCACABIAEpAogPNwLwDCABIAEpArAPNwKYDSAkIBYpAgA3AgAgJiAVKQIANwIAIDkgECkCADcCACA6IA8pAgA3AgAgASABKQLYDzcCwA0gESgCACEDIA0oAgAhBiAMKAIAIQcgCigCACEJIAEoAsgMIQogASgC8AwhDCABKALMDCENIAEoAvQMIREgASgC0AwhHSABKALUDCEeIAEoAvwMIR8gASgC2AwhICABKALcDCEhIAEoAoQNISIgASgC4AwhGCABKALkDCEZIAEoAowNIRsgASgC6AwhHCABIAEoAuwMIAEoApQNajYCzAsgASAJIBxqNgLICyABIBkgG2o2AsQLIAEgByAYajYCwAsgASAhICJqNgK8CyABIAYgIGo2ArgLIAEgHiAfajYCtAsgASADIB1qNgKwCyABIA0gEWo2AqwLIAEgCiAMajYCqAsgKCApIBoQeiAqIBcpAgA3AgAgKyASKQIANwIAICwgFCkCADcCACAtIBMpAgA3AgAgASABKQKYDTcC+AsgDiAuQdDjwAAQNiAvIBYpAgA3AgAgMCAVKQIANwIAIEIgECkCADcCACBDIA8pAgA3AgAgASABKQLYDzcCoAwgTSAlQaAB/AoAACAEQYAEaiBKQYAK/AoAACABQYAQaiQAIARBoA5qQgA3AwAgBEGYDmpCADcDACAEQZAOakIANwMAIARBiA5qQgA3AwAgBEGwDmpB+OTAACkCACJPNwMAIARBuA5qQYDlwAApAgAiUDcDACAEQcAOakGI5cAAKQIA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KAKwASEZIAMoArQBIRsgAygCuAEhHCADKAK8ASEjIAMoAsABISQgAygCxAEhJiABQfAAaiADQbgCaikCADcCACABQegAaiADQbACaikCADcCACABQeAAaiADQagCaikCADcCACABQdgAaiADQaACaikCADcCACABIAMpApgCNwJQIAEgIiAmajYCnAEgASAhICRqNgKYASABICAgI2o2ApQBIAEgHCAfajYCkAEgASAbICVqNgKMASABIBkgHmo2AogBIAEgGCAdajYChAEgASAQIBZqNgKAASABIA8gFWo2AnwgASAGIA5qNgJ4IANBwAJqJAAgBEH4DmogAUGgAfwKAAALAkACQAJAAkAgBEGAAmogAmosAAAiAUEASiABQQBIa0H/AXEOAgMBAAsgBEHYEmogBEH4DmoiAyAUEDYgBEH4E2ogEiATEDYgBEGYEGogEyAUEDYgBEG4EWogAyASEDYgCUEgaiAEQZgUaikCADcCACAJQRhqIARBkBRqKQIANwIAIAlBEGogBEGIFGopAgA3AgAgCUEIaiAEQYAUaikCADcCACAJIAQpAvgTNwIAIAcgBCkCmBA3AgAgB0EIaiAEQaAQaikCADcCACAHQRBqIARBqBBqKQIANwIAIAdBGGogBEGwEGopAgA3AgAgB0EgaiAEQbgQaikCADcCACAKQSBqIARB2BFqKQIANwIAIApBGGogBEHQEWopAgA3AgAgCkEQaiAEQcgRaikCADcCACAKQQhqIARBwBFqKQIANwIAIAogBCkCuBE3AgBBACABa8AiA0EBdiEBIANBAE4NASABQcAAQaihwQAQ8gEACyAEQdgSaiAEQfgOaiIDIBQQNiAEQfgTaiASIBMQNiAEQZgQaiATIBQQNiAEQbgRaiADIBIQNiAJQSBqIARBmBRqKQIANwIAIAlBGGogBEGQFGopAgA3AgAgCUEQaiAEQYgUaikCADcCACAJQQhqIARBgBRqKQIANwIAIAkgBCkC+BM3AgAgByAEKQKYEDcCACAHQQhqIARBoBBqKQIANwIAIAdBEGogBEGoEGopAgA3AgAgB0EYaiAEQbAQaikCADcCACAHQSBqIARBuBBqKQIANwIAIApBIGogBEHYEWopAgA3AgAgCkEYaiAEQdARaikCADcCACAKQRBqIARByBFqKQIANwIAIApBCGogBEHAEWopAgA3AgAgCiAEKQK4ETcCACABQQF2IQMgAUEASARAIANBwABBqKHBABDyAQALIARBmBBqIgEgA0H4AGxBmOXAAGpB+AD8CgAAIARBuBFqIgMgBEHYEmogARBAIARB+A5qIANBoAH8CgAADAELIARBmBBqIgYgAUH4AGxBmOXAAGpB+AD8CgAAIwBBoAJrIgEkACAEQdgSaiIDKAIAIQ4gAygCKCEPIAMoAgQhECADKAIsIRUgAygCCCEWIAMoAjAhHSADKAIMIR4gAygCNCElIAMoAhAhHyADKAI4ISAgAygCFCEhIAMoAjwhIiADKAIYIRggAygCQCEZIAMoAhwhGyADKAJEIRwgAygCICEjIAMoAkghJCABIAMoAiQgAygCTGo2AiwgASAjICRqNgIoIAEgGyAcajYCJCABIBggGWo2AiAgASAhICJqNgIcIAEgHyAgajYCGCABIB4gJWo2AhQgASAWIB1qNgIQIAEgECAVajYCDCABIA4gD2o2AgggAUEwaiIOIANBKGogAxB6IAFB2ABqIg8gAUEIaiAGQShqEDYgAUGAAWoiECAOIAYQNiABQagBaiIOIANB+ABqIAZB0ABqEDYgASADKAJQQQF0IgY2AtABIAEgAygCVEEBdCIVNgLUASABIAMoAlhBAXQiFjYC2AEgASADKAJcQQF0Ih02AtwBIAEgAygCYEEBdCIeNgLgASABIAMoAmRBAXQiJTYC5AEgASADKAJoQQF0Ih82AugBIAEgAygCbEEBdCIgNgLsASABIAMoAnBBAXQiITYC8AEgASADKAJ0QQF0IiI2AvQBIARBuBFqIgMgDyAQEHogASgCfCEPIAEoAqQBIRAgASgCgAEhGCABKAJYIRkgASgChAEhGyABKAJcIRwgASgCiAEhIyABKAJgISQgASgCjAEhJiABKAJkITkgASgCkAEhOiABKAJoISggASgClAEhKSABKAJsISogASgCmAEhKyABKAJwISwgASgCnAEhLSABKAJ0IS4gASgCoAEhLyABKAJ4ITAgAUH4AWogAUHQAWogDhB6IAMgDyAQajYCTCADIC8gMGo2AkggAyAtIC5qNgJEIAMgKyAsajYCQCADICkgKmo2AjwgAyAoIDpqNgI4IAMgJiA5ajYCNCADICMgJGo2AjAgAyAbIBxqNgIsIAMgGCAZajYCKCABKAKoASEOIAEoAqwBIQ8gASgCsAEhECABKAK0ASEYIAEoArgBIRkgASgCvAEhGyABKALAASEcIAEoAsQBISMgASgCyAEhJCABKALMASEmIANB8ABqIAFBmAJqKQIANwIAIANB6ABqIAFBkAJqKQIANwIAIANB4ABqIAFBiAJqKQIANwIAIANB2ABqIAFBgAJqKQIANwIAIAMgASkC+AE3AlAgAyAiICZqNgKcASADICEgJGo2ApgBIAMgICAjajYClAEgAyAcIB9qNgKQASADIBsgJWo2AowBIAMgGSAeajYCiAEgAyAYIB1qNgKEASADIBAgFmo2AoABIAMgDyAVajYCfCADIAYgDmo2AnggAUGgAmokACAEQfgOaiADQaAB/AoAAAsgBEHYEmoiASAEQfgOaiAUEDYgBEGYEGogEiATEDYgBEG4EWogEyAUEDYgCUEgaiAEQbgQaikCADcCACAJQRhqIARBsBBqKQIANwIAIAlBEGogBEGoEGopAgA3AgAgCUEIaiAEQaAQaikCADcCACAJIAQpApgQNwIAIAcgBCkCuBE3AgAgB0EIaiAEQcARaikCADcCACAHQRBqIARByBFqKQIANwIAIAdBGGogBEHQEWopAgA3AgAgB0EgaiAEQdgRaikCADcCACAEQYAOaiABQfgA/AoAACACBEAgAkEBayECDAELCyAIIARBgA5qIgEgFxA2IARBuBFqIBogFxA2IARB2BJqIgIgFxBQIAQpA6ATIVIgBCkDmBMhUSAEKQPwEiFTIAQpA5ATIVQgBCkD6BIhVSAEKQPgEiFWIAQpA9gSIU8gBCkDiBMhVyAEKQOAEyFYIAQpA/gSIVAgAiABIBoQNiAIQcgAaiAEQdgRaikCADcCACAIQUBrIARB0BFqKQIANwIAIAhBOGogBEHIEWopAgA3AgAgCEEwaiAEQcARaikCADcCACAIIAQpArgRNwIoIAggVyBYIFBCGoh8IlhCGYh8IlenQf///x9xNgJoIAggVSBWIE9CGoh8IlZCGYh8IlWnQf///x9xNgJYIAggVCBXQhqIfCJUp0H///8PcTYCbCAIIFMgVUIaiHwiU6dB////D3E2AlwgCCBRIFRCGYh8IlGnQf///x9xNgJwIAggWEL///8PgyBQQv///x+DIFNCGYh8IlBCGoh8PgJkIAggUKdB////H3E2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IQUDQCABIARqLQAAQS5GBEAgBCEDDAMLIAIgBEEBaiIERw0ACwtBACEFCyAHIAM2AgQgByAFNgIAIAYoAghBAUYhAwwBCyABLQAAQS5GIgMgAkEBRnINACABLQABQS5GIgMgAkECRnINACABLQACQS5GIgMgAkEDRnINACABLQADQS5GIgMgAkEERnINACABLQAEQS5GIgMgAkEFRnINACABLQAFQS5GIgMgAkEGRnINACABLQAGQS5GIQMLIAAgAyAALQAEcjoABCAAKAIAIAEgAhDpAiAGQRBqJAAL3wEBA38gAC0AAEEBRwRAIAAoAgQhBiAALQABQQFHBEAgBigCACIEKAIAIAQoAggiBUYEQCAEIAVBAUEBQQEQyQEgBCgCCCEFCyAEIAVBAWo2AgggBCgCBCAFakEsOgAACyAAQQI6AAEgBigCACABIAIQaiADKAIIIQEgAygCBCECIAYoAgAiACgCACAAKAIIIgNGBEAgACADQQFBAUEBEMkBIAAoAgghAwsgACADQQFqNgIIIAAoAgQgA2pBOjoAACAGKAIAIAIgARBqQQAPC0GkpMAAQShBzKTAABCZAgAL8gEBAn8jAEEwayICJAACQCAAKQMAQv///////////wCDQoCAgICAgID4/wBaBEAgAkEBNgIUIAJBsKDEADYCECACQgE3AhwgAiAArUKAgICAgBKENwMoIAIgAkEoajYCGCABKAIAIAEoAgQgAkEQahBgIQMMAQsgAkEAOgAMIAIgATYCCEEBIQMgAkEBNgIUIAJBsKDEADYCECACQgE3AhwgAiAArUKAgICAgBKENwMoIAIgAkEoajYCGCACQQhqQbygxAAgAkEQahBgDQAgAi0ADEUEQCABQbigxABBAhDpAg0BC0EAIQMLIAJBMGokACADC+EBAQN/IwBBkAFrIgIkACABKQOQAVAEQCACIAEQMCACQYgBaiIBIAJB2ABqKQMANwMAIAJBgAFqIgMgAkHQAGopAwA3AwAgAkH4AGoiBCACQcgAaikDADcDACACIAIpA0A3A3AgAkHwAGogAiACLQBoQgAgAi0AaUEIchAiIAAgASkDADcAGCAAIAMpAwA3ABAgACAEKQMANwAIIAAgAikDcDcAACACQZABaiQADwsgAkIANwIMIAJCgYCAgMAANwIEIAJBzNnAADYCACABQZABakGI18AAIAJBnNvAABCnAgAL5wEAIAAQwgEgAEEAOgAgIABBADoAISAAQQA6ACIgAEEAOgAjIABBADoAJCAAQQA6ACUgAEEAOgAmIABBADoAJyAAQQA6ACggAEEAOgApIABBADoAKiAAQQA6ACsgAEEAOgAsIABBADoALSAAQQA6AC4gAEEAOgAvIABBADoAMCAAQQA6ADEgAEEAOgAyIABBADoAMyAAQQA6ADQgAEEAOgA1IABBADoANiAAQQA6ADcgAEEAOgA4IABBADoAOSAAQQA6ADogAEEAOgA7IABBADoAPCAAQQA6AD0gAEEAOgA+IABBADoAPwvOAgEDfyMAQTBrIgMkACADQQxqIAEgAhBPAkACQCADKAIMQQFGBEAgAyACNgIgIAMgATYCHCADQQY6ABgjAEFAaiIBJAAgAUHguMAANgIEIAEgA0EvajYCACABQShqIANBGGoiAkEIaikDADcDACABIAIpAwA3AyAgAUECNgIMIAFBmLjDADYCCCABQgI3AhQgASABrUKAgICAgBCENwM4IAEgAUEgaq1CgICAgJAQhDcDMCABIAFBMGo2AhAgAUEIahCyASECIAFBQGskACAAQYCAgIB4NgIAIAAgAjYCBAwBC0EAIQEgAygCFCICQQBIDQEgAygCECEFAkAgAkUEQEEBIQQMAQtBASEBIAJBARCBAyIERQ0CCyACBEAgBCAFIAL8CgAACyAAIAI2AgggACAENgIEIAAgAjYCAAsgA0EwaiQADwsgASACENsCAAviAQAgAEEAOgAAIABBADoAASAAQQA6AAIgAEEAOgADIABBADoABCAAQQA6AAUgAEEAOgAGIABBADoAByAAQQA6AAggAEEAOgAJIABBADoACiAAQQA6AAsgAEEAOgAMIABBADoADSAAQQA6AA4gAEEAOgAPIABBADoAECAAQQA6ABEgAEEAOgASIABBADoAEyAAQQA6ABQgAEEAOgAVIABBADoAFiAAQQA6ABcgAEEAOgAYIABBADoAGSAAQQA6ABogAEEAOgAbIABBADoAHCAAQQA6AB0gAEEAOgAeIABBADoAHwuCAgAgAEEAOgDAASAAQQA6AMEBIABBADoAwgEgAEEAOgDDASAAQQA6AMQBIABBADoAxQEgAEEAOgDGASAAQQA6AMcBIABBADoAyAEgAEEAOgDJASAA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aikAADcDACAUQTBqIAFBEGopAAA3AwAgFEEoaiABQQhqKQAANwMAIBQgASkAADcDICMAQSBrIi0kACAUQSBqIgEgAS0AH0E/cUHAAHI6AB8gASABLQAAQfgBcToAACAtQQhqIAFBCGopAAA3AwAgLUEQaiABQRBqKQAANwMAIC1BGGogAUEYaikAADcDACAtIAEpAAA3AwAgACECQQAhASMAQaADayIDJAAgA0EIaiAUEG8gA0HQAGpB2JHDACkCACI3NwMAIANByABqQdCRwwApAgAiOTcDACADQUBrQciRwwApAgAiODcDACADQThqQcCRwwApAgAiOjcDACADQeAAakIANwMAIANB6ABqQgA3AwAgA0HwAGpCADcDACADQfgAakIANwMAIANBuJHDACkCACI7NwMwIANCADcDWCADQaABaiADQShqKQIANwMAIANBmAFqIANBIGopAgA3AwAgA0GQAWogA0EYaikCADcDACADQYgBaiADQRBqKQIANwMAIANBsAFqIDo3AwAgA0G4AWogODcDACADQcABaiA5NwMAIANByAFqIDc3AwAgAyADKQIINwOAASADIDs3A6gBIANBADoA1wEgA0EBNgLcAiADQoCAgICAIDcC1AIgAyAtNgLQAiADQdgAaiEvQQEhBgJAAkADQAJAAkAgBkUEQCADKALYAiIAIAMoAtQCTQ0CIAMgAEEBayIENgLYAiAEQQN2IQUgAEGBAk8NBCADKALQAiAFai0AACAEQQdxdkEBcSEADAELIANBADYC3AICf0EAIQAgA0HQAmoiBCgCBCIHIAQoAggiBSAFIAdLGyAFayEVAkACQAJAA0BBAiEIIAAgFUYNASAEIAAgBWoiE0EBazYCCCATQYECTw0CIAYgAEEBayIAag0ACyAHIAAgBWoiAE8NACAEIABBAWsiBTYCCCAFQQN2IQYgAEGBAk8NAiAEKAIAIAZqLQAAIAVBB3F2QQFxIQgLIAgMAgsgE0EBa0EDdkEgQYiSwwAQ8gEACyAGQSBBiJLDABDyAQALQf8BcSIAQQJGDQELIAAgAXMQ5wIhASADKAKAASEEIAMoAjAhBSADKAKEASEGIAMoAjQhByADKAKIASEIIAMoAjghEyADKAKMASEVIAMoAjwhICADKAKQASEhIAMoAkAhIiADKAKUASEWIAMoAkQhIyAD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KQOIBSA9QhqIfCI9Qv///w+DID5CGoh8pyILNgLMASABIDdC////H4MgASkDmAUgASkDkAUgPUIZiHwiN0IaiHwiPUIZiHwiPqdB////H3EiDDYC2AEgASA5Qv///w+DID5CGoh8pyINNgLcASABIDenQf///x9xIg42AtABIAEgPadB////D3EiDzYC1AEgASA4p0H///8fcSIQNgLgASABIDqnQf///w9xIhE2AuQBIAEgO6dB////H3EiEjYC6AEgASA8p0H///8PcSIaNgLsASABQfABaiIIIAFBoAFqIhsgAUHIAWoiHBB6IAFBmAJqIh0gASAJEDYgAUHAAmoiCSAHIAFB0ABqEDYgASgCmAIhByABKALAAiEeIAEoApwCIR8gASgCxAIhJiABKAKgAiEnIAEoAsgCISggASgCpAIhKSABKALMAiEqIAEoAqgCISsgASgC0AIhLCABKAKsAiEuIAEoAtQCITAgASgCsAIhMSABKALYAiEyIAEoArQCITMgASgC3AIhNCABKAK4AiE1IAEoAuACITYgASABKALkAiABKAK8Amo2AowDIAEgNSA2ajYCiAMgASAzIDRqNgKEAyABIDEgMmo2AoADIAEgLiAwajYC/AIgASArICxqNgL4AiABICkgKmo2AvQCIAEgJyAoajYC8AIgASAfICZqNgLsAiABIAcgHmo2AugCIAFBkANqIgcgHSAJEHogBiABQegCahBQIAEpA5gFITggASkDkAUhOiABKQOIBSE7IAEpA4AFITcgASkDyAUhPCABKQPABSE9IAEpA7gFIT4gASkDsAUhQSABKQOoBSFCIAEpA6AFITkgBiAHEFAgASABKQOwBSABKQOoBSABKQOgBSI/QhqIfCJEQhmIfCJAp0H///8fcTYC0AMgASABKQOQBSABKQOIBSABKQOABSJFQhqIfCJGQhmIfCJDp0H///8fcTYCwAMgASABKQO4BSBAQhqIfCJAp0H///8PcTYC1AMgASABKQOYBSBDQhqIfCJDp0H///8PcTYCxAMgASABKQPABSBAQhmIfCJAp0H///8fcTYC2AMgASBEQv///w+DID9C////H4MgQ0IZiHwiP0IaiHw+AswDIAEgP6dB////H3E2AsgDIAEgASkDyAUgQEIaiHwiP6dB////D3E2AtwDIAEgRkL///8PgyA/QhmIQhN+IEVC////H4N8Ij9CGoh8PgK8AyABID+nQf///x9xNgK4AyABQeADakHgkcMAIAgQNiABQYgEaiAbIBwQNiABIAEoAoQEIBpqNgKkBSABIAEoAoAEIBJqNgKgBSABIAEoAvwDIBFqNgKcBSABIAEoAvgDIBBqNgKYBSABIAEoAvQDIA1qNgKUBSABIAEoAvADIAxqNgKQBSABIAEoAuwDIA9qNgKMBSABIAEoAugDIA5qNgKIBSABIAEoAuQDIAtqNgKEBSABIAEoAuADIApqNgKABSABQbAEaiAIIAYQNiABQdgEaiADQQhqIAFBuANqEDYgJSABQagEaikCADcCACAjIAFBoARqKQIANwIAICEgAUGYBGopAgA3AgAgFSABQZAEaikCADcCACAFIAEpAogENwIAIAUgASkCsAQ3AiggEyABQbgEaikCADcCACAgIAFBwARqKQIANwIAICIgAUHIBGopAgA3AgAgJCABQdAEaikCADcCACAEIDwgPSA+IEEgQiA5QhqIfCJCQhmIfCJBQhqIfCI+QhmIfCI9QhqIfCI8p0H///8PcTYCJCAEID2nQf///x9xNgIgIAQgPqdB////D3E2AhwgBCBBp0H///8fcTYCGCAEIEJC////D4MgOUL///8fgyA4IDogOyA3QhqIfCI5QhmIfCI6QhqIfCI4QhmIfCI7QhqIfD4CFCAEIDunQf///x9xNgIQIAQgOKdB////D3E2AgwgBCA6p0H///8fcTYCCCAEIDlC////D4MgPEIZiEITfiA3Qv///x+DfCI3QhqIfD4CBCAEIDenQf///x9xNgIAIAQgASkC2AQ3AiggFiABQeAEaikCADcCACAXIAFB6ARqKQIANwIAIBggAUHwBGopAgA3AgAgGSABQfgEaikCADcCACABQdAFaiQAIAMgADoA1wEgAygC3AIhBiAAIQEMAQsLIAEQ5wIhACADKAKAASEBIAMoAjAhBCADKAKEASEFIAMoAjQhBiADKAKIASEHIAMoAjghCCADKAKMASETIAMoAjwhFSADKAKQASEgIAMoAkAhISADKAKUASEiIAMoAkQhFiADKAKYASEjIAMoAkghFyADKAKcASEkIAMoAkwhGCADKAKgASElIAMoAlAhCSADKAKkASEZIAMoAlQhCiADKAKoASELIAMoAlghDCADKAKsASENIAMoAlwhDiADKAKwASEPIAMoAmAhECADKAK0ASERIAMoAmQhEiADKAK4ASEaIAMoAmghGyADKAK8ASEcIAMoAmwhHSADKALAASEeIAMoAnAhHyADKALEASEmIAMoAnQhJyADKALIASEoIAMoAnghKSADQQAgAEH/AXFrIgAgAygCzAEiKiADKAJ8IitzcSIsICtzNgJ8IAMgKSAoIClzIABxIitzNgJ4IAMgJyAmICdzIABxIilzNgJ0IAMgHyAeIB9zIABxIidzNgJwIAMgHSAcIB1zIABxIh9zNgJsIAMgGyAaIBtzIABxIh1zNgJoIAMgEiARIBJzIABxIhtzNgJkIAMgECAPIBBzIABxIhJzNgJgIAMgDiANIA5zIABxIhBzNgJcIAMgDCALIAxzIABxIg5zNgJYIAMgCiAKIBlzIABxIgxzNgJUIAMgCSAJICVzIABxIgpzNgJQIAMgGCAYICRzIABxIglzNgJMIAMgFyAXICNzIABxIhhzNgJIIAMgFiAWICJzIABxIhdzNgJEIAMgISAgICFzIABxIhZzNgJAIAMgFSATIBVzIABxIiFzNgI8IAMgCCAHIAhzIABxIhVzNgI4IAMgBiAFIAZzIABxIghzNgI0IAMgBCABIARzIABxIgBzNgIwIAMgKiAsczYCzAEgAyAoICtzNgLIASADICYgKXM2AsQBIAMgHiAnczYCwAEgAyAcIB9zNgK8ASADIBogHXM2ArgBIAMgESAbczYCtAEgAyAPIBJzNgKwASADIA0gEHM2AqwBIAMgCyAOczYCqAEgAyAMIBlzNgKkASADIAogJXM2AqABIAMgCSAkczYCnAEgAyAYICNzNgKYASADIBcgInM2ApQBIAMgFiAgczYCkAEgAyATICFzNgKMASADIAcgFXM2AogBIAMgBSAIczYChAEgAyAAIAFzNgKAASADQQA6ANcBIANB0AJqIgAgLxAzIANBoAJqIANB8AJqKQIANwMAIANBmAJqIANB6AJqKQIANwMAIANBkAJqIANB4AJqKQIANwMAIANBiAJqIANB2AJqKQIANwMAIAMgAykC0AI3A4ACIANByAJqIANBmANqKQIANwMAIANBwAJqIANBkANqKQIANwMAIANBuAJqIANBiANqKQIANwMAIANBsAJqIANBgANqKQIANwMAIAMgAykC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AEEIaikDADcDACADIAApAwA3AyAgA0ECNgIMIANB+LfDADYCCCADQgI3AhQgAyADrUKAgICAgBCENwM4IAMgA0Egaq1CgICAgJAQhDcDMCADIANBMGo2AhAgA0EIahCyASADQUBrJAALjQEBBH8jAEEQayICJAACf0EBIAEoAgAiA0EnIAEoAgQiBSgCECIBEQAADQAaIAIgACgCAEGBAhBSAkAgAi0ADSIAQYEBTwRAIAMgAigCACABEQAARQ0BQQEMAgsgAyACIAItAAwiBGogACAEayAFKAIMEQEARQ0AQQEMAQsgA0EnIAERAAALIAJBEGokAAuGAQEBfyMAQRBrIgMkACACIAEgAmoiAUsEQEEAQQAQ2wIACyADQQRqIAAoAgAiAiAAKAIEQQggASACQQF0IgIgASACSxsiASABQQhNGyIBEN8BIAMoAgRBAUYEQCADKAIIIAMoAgwQ2wIACyADKAIIIQIgACABNgIAIAAgAjYCBCADQRBqJAALpQEBAX8jAEEQayICJAACfwJAAkACQAJAAkAgACgCAEEBaw4EAQIDBAALIAFBqN7AAEESEOkCDAQLIAFBut7AAEEMEOkCDAMLIAIgAEEEajYCDCABQejewABBC0Hz3sAAQQQgAEEIakHI3sAAQffewABBBiACQQxqQdjewAAQyAEMAgsgAUH93sAAQQYQ6QIMAQsgAUGD38AAQREQ6QILIAJBEGokAAuHAQEEfyAAKAIEIQIgACgCCCIDBEAgAkEEaiEBA0ACQAJAAkACQCABQQRrLQAADgUDAwMBAgALIAEQRAwCCyABKAIAIgRFDQEgAUEEaigCACAEQQEQ+gIMAQsgARDbAQsgAUEYaiEBIANBAWsiAw0ACwsgACgCACIABEAgAiAAQRhsQQgQ+gILC3kAIAAgASkAADcAACAAQSBqIAEpACA3AAAgAEEIaiABQQhqKQAANwAAIABBEGogAUEQaikAADcAACAAQRhqIAFBGGopAAA3AAAgAEEoaiABQShqKQAANwAAIABBMGogAUEwaikAADcAACAAQThqIAFBOGopAAA3AAALiwEBBH8CQAJAAkAgACgCACIAKAIADgIAAQILIAAoAggiAUUNASAAKAIEIAFBARD6AgwBCyAALQAEQQNHDQAgACgCCCIBKAIAIQMgAUEEaigCACIEKAIAIgIE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AQsgAkECNgIEIAJBqJ7EADYCACACQgE3AgwgAiAArUKAgICA4AiENwMYIAIgAkEYajYCCCABKAIAIAEoAgQgAhBgCyACQSBqJAALvQMBB38jAEEQayIDJAAgACgCCCEFIAAoAgQhACABKAIAQb+2xABBASABKAIEKAIMEQEAIQQgA0EEaiICQQA6AAUgAiAEOgAEIAIgATYCACAFBEADQCADIAA2AgwgA0EMaiEHIwBBIGsiASQAQQEhBgJAIANBBGoiBC0ABA0AIAQtAAUhCAJAIAQoAgAiAi0ACkGAAXFFBEAgCEEBcUUNASACKAIAQZG2xABBAiACKAIEKAIMEQEARQ0BDAILIAhBAXFFBEAgAigCAEGTtsQAQQEgAigCBCgCDBEBAA0CCyABQQE6AA8gAUGctsQANgIUIAEgAikCADcCACABIAIpAgg3AhggASABQQ9qNgIIIAEgATYCECAHIAFBEGpBiNLAACgCABEAAA0BIAEoAhBBlLbEAEECIAEoAhQoAgwRAQAhBgwBCyAHIAJBiNLAACgCABEAACEGCyAEQQE6AAUgBCAGOgAEIAFBIGokACAAQQFqIQAgBUEBayIFDQALC0EBIQAgA0EEaiIBLQAERQRAIAEoAgAiACgCAEHAtsQAQQEgACgCBCgCDBEBACEACyABIAA6AAQgA0EQaiQAIAALugUBE38jAEHAAWsiAyQAIANBuAFqIAFBGGopAAA3AwAgA0GwAWogAUEQaikAADcDACADQagBaiABQQhqKQAANwMAIAMgASkAADcDoAEjAEEgayIBJAAgA0GgAWoiBCAELQAfQT9xQcAAcjoAHyAEIAQtAABB+AFxOgAAIAFBCGogBEEIaikAADcDACABQRBqIARBEGopAAA3AwAgAUEYaiAEQRhqKQAANwMAIAEgBCkAADcDACADIAEQJyABQSBqJAAjAEGgAmsiAiQAIAMoAighBSADKAJQIQYgAygCLCEHIAMoAlQhCCADKAIwIQkgAygCWCEKIAMoAjQhCyADKAJcIQwgAygCOCENIAMoAmAhDiADKAI8IQ8gAygCZCEQIAMoAkAhESADKAJoIRIgAygCRCETIAMoAmwhFCADKAJIIQQgAygCcCEBIAIgAygCTCADKAJ0ajYCLCACIAEgBGo2AiggAiATIBRqNgIkIAIgESASajYCICAC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AgggAygCDBCSAiEBIABBATsBACAAIAE2AgQgA0EQaiQAC0kBAX8jAEEQayIDJAAgA0EIaiABKAIAIAEoAgQgASgCCBBeIAIgAygCCCADKAIMEJICIQEgAEECNgIAIAAgATYCBCADQRBqJAALvw8CBn8CfiMAQRBrIg0kACMAQeAAayIMJAACQAJAAkACQCAABEAgAEEIayIPIA8oAgBBAWoiDjYCACAORQ0BIAAoAgANAiAAQX82AgAgDCAPNgJQIAwgADYCTCAMIAQ2AgwgDCADNgIIIAwgBDYCBCAMIAY2AhggDCAFNgIUIAwgBjYCECAMIAg2AiQgDCAHNgIgIAwgCDYCHCAMIABBCGoiBDYCSAJAIApFBEBBgICAgHghCwwBCyAMIAs2AjAgDCAKNgIsCyAMIAs2AiggDEE0aiEFIwBB0AFrIgMkACADQQhqIAxBHGoiBkEIaigCADYCACADQRRqIAxBEGoiB0EIaigCADYCACADIAYpAgA3AwAgAyAHKQIANwIMIANByAFqIAxBBGoiBkEIaigCADYCACADIAYpAgA3A8ABIANB8ABqIAQgASACIAMgA0HAAWogCfwHIAxBKGoQJAJAIAMpA4ABIhJCBFEEQCADQcgAaiADQZABaikDACISNwMAIANB0ABqIANBmAFqKAIAIgQ2AgAgAyADKQOIASITNwNAIAVBEGogBDYCACAFQQhqIBI3AgAgBSATNwIAIAMoAsABIgRFDQEgAygCxAEgBEEBEPoCDAELIANB4ABqIgQgA0GQAWopAwA3AwAgA0HoAGoiByADQZgBaigCADYCACADIAMpA4gBNwNYIAMoAnghCCADKAJ0IQogAygCcCEGIANBPGogA0G8AWooAgA2AgAgA0E0aiADQbQBaikCADcCACADQSxqIANBrAFqKQIANwIAIANBJGogA0GkAWopAgA3AgAgAyADKQKcATcCHCADQdAAaiILIAcoAgA2AgAgA0HIAGoiByAEKQMANwMAIAMgAykDWDcDQCADQRhqIAsoAgA2AgAgA0EQaiAHKQMANwMAIAMgAykDQDcDCCADIBI3AwAgAygCwAEiBARAIAMoAsQBIARBARD6AgsCQCASQgNSBEAgA0GEAWogA0EYaigCADYCACADIAg2AnggAyAKNgJ0IAMgBjYCcCADIAMpAxA3AnwgAyAD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KCACIAKtQoCAgIDgCIQ3AyAgAiACQSBqNgIQIAJBCGogAxC/AgALIwBBMGsiASQAIAEgAjYCBCABIAA2AgAgAUECNgIMIAFBqNPEADYCCCABQgI3AhQgASABQQRqrUKAgICA4AiENwMoIAEgAa1CgICAgOAIhDcDICABIAFBIGo2AhAgAUEIaiADEL8CAAsjAEEwayIAJAAgACACNgIEIAAgATYCACAAQQI2AgwgAEHQ0sQANgIIIABCAjcCFCAAIABBBGqtQoCAgIDgCIQ3AyggACAArUKAgICA4AiENwMgIAAgAEEgajYCECAAQQhqIAMQvwIAC0IBAX8jAEEgayIDJAAgA0EANgIQIANBATYCBCADQgQ3AgggAyABNgIcIAMgADYCGCADIANBGGo2AgAgAyACEL8CAAtBAQF/IAAoAgAiACgCqAEEQCAAQQA2AqgBCwJAIABBf0YNACAAIAAoAgRBAWsiATYCBCABDQAgAEGQD0EIEPoCCws9AQJ/AkAgACgCACICRQ0AIAAoAgQiACgCACIBBEAgAiABEQQACyAAKAIEIgFFDQAgAiABIAAoAggQ+gILCzkBAX8jAEEQayICJAAgAkEIaiAAKAIAIAAoAgQgACgCCBBeIAEgAigCCCACKAIMEJICIAJBEGokAAvfBwIEfwJ+IwBBEGsiCSQAIwBB0ABrIggkAAJAAkACQAJAIAAEQCAAQQhrIgsgCygCAEEBaiIKNgIAIApFDQEgACgCAA0CIABBfzYCACAIIAs2AkAgCCAANgI8IAggBDYCFCAIIAM2AhAgCCAENgIMIAggAEEIaiIKNgI4AkAgBkUEQEGAgICAeCEHDAELIAggBzYCICAIIAY2AhwLIAggBzYCGCAIQSRqIQQjAEGAAmsiAyQAIANBgICAgHg2AtgBIANB+AFqIAhBDGoiBkEIaigCADYCACADIAYpAgA3A/ABIANBiAFqIAogASACIANB2AFqIANB8AFqIAX8ByAIQRhqECQCQCADKQOYASINQgRRBEAgA0HgAGogA0GoAWopAwAiDTcDACADQegAaiADQbABaigCACIGNgIAIAMgAykDoAEiDDcDWCAEQRBqIAY2AgAgBEEIaiANNwIAIAQgDDcCACADKALwASIERQ0BIAMoAvQBIARBARD6AgwBCyADQRBqIgYgA0GQAWopAwA3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BUEKNgIAIAVBDGogAkEsaigCADYCACAHRQ0CIAogB0EBEPoCDAILIAVBDTYCECAFQdvCwAA2AgwgBUEONgIIIAVBzcLAADYCBCAFQQg2AgAMAQtByL7AAEErIAJB/wBqQbi+wABB9L7AABDmAQALIAJBgAFqJAAMAQtByMPAAEE3IAJB/wBqQbjDwABBgMTAABDmAQALIANBKGoiAiADQcQAaiIEKAIANgIAIAMgAykCPDcDICADKAI4IgdBCkcEQCADKAJIIQogBCACKAIANgIAIAMgAykDIDcCPCADIAo2AkggAyAHNgI4IAUQywEhAiAJQYCAgIB4NgIAIAkgAjYCBAwBCyAJIAMpAyA3AgAgCUEIaiACKAIANgIACyADQdAAaiQAIAEEQCAAIAFBARD6AgsCQAJAIAYCfyAIKAIEIgJBgICAgHhGBEBBACEBIAgoAgghAEEBDAELIAgoAgghAAJAIAgoAgwiCyACTwRAIAAhAQwBCyALRQRAQQEhASAAIAJBARD6AgwBCyAAIAJBASALEO0CIgFFDQILQQAhAEEACzYCDCAGIAA2AgggBiALNgIEIAYgATYCACAIQRBqJAAMAQtBASALENsCAAsgBigCACAGKAIEIAYoAgggBigCDCAGQRBqJAALlwQCB38CfiMAQRBrIgQkACMAQdAAayICJAAjAEEgayIDJAAgAkEoaiIFAn8gAUEgRgRAIANBAmogAEECai0AADoAACADQR9qIABBH2otAAA6AAAgAyAALwAAOwEAIAMgACkAFzcAFyADIAApAA83AA8gAyAAKAALNgALIAMgACkAAzcAAyAFQQFqIAMQ7gEgAxDCAUEADAELIAUgATYCDCAFQoCAgICABDcCBEEBCzoAACADQSBqJAACQAJAAkAgAi0AKCIGQQFGBEAgAkEbaiACQTxqKAIAIgM2AAAgAkETaiACQTRqKQIAIgk3AAAgAiACKQIsIgo3AAsgAkE4aiADNgIAIAJBMGogCTcDACACIAo3AyggBRDLASEDDAELIAJBIGoiByACQcEAaikAADcDACACQRhqIgggAkE5aikAADcDACACQRBqIgUgAkExaikAADcDACACIAIpACk3AwhBIEEBEIEDIgNFDQEgAyACKQMINwAAIANBGGogBykDADcAACADQRBqIAgpAwA3AAAgA0EIaiAFKQMANwAACyABBEAgACABQQEQ+gILIAQCfyAGBEBBACEAQQAhAUEBDAELQSAhASADIQBBACEDQQALNgIMIAQgAzYCCCAEIAE2AgQgBCAANgIAIAJB0ABqJAAMAQtBAUEgEJoDAAsgBCgCACAEKAIEIAQoAgggBCgCDCAEQRBqJAALgQ0CDH8CfiMAQRBrIgckACMAQRBrIgokACAKQQRqIQsjAEHQAGsiAyQAIANBDGogACABEE8CQCADKAIMQQFGBEAgAyADKQIQNwMYIAMgA0EYaq1CgICAgLABhDcDMCADQgE3AkQgA0EBNgI8IANB+KTAADYCOCADIANBMGo2AkAgA0EgaiADQThqEHkgAygCJCICIAMoAigQ4wIhBSADKAIgIgQEQCACIARBARD6AgsgC0GAgICAeDYCACALIAU2AgQMAQsgA0E4aiEFIAMoAhAhBCADKAIUIQgjAEGgAWsiAiQAAkACQAJAAkACQCAIQQ5JDQBB0MDAACAEQQ4QgwINACACQevAwAA2AkggAiAIQQ5rNgJEIAIgBEEOajYCQCACQfgAaiACQUBrIgQQnQEgAigCeCIIQYCAgIB4RgRAIAIgAikCfDcDaCACQQA2ApABIAJCgICAgBA3AogBIAJBoMPAADYCRCACQqCAgIAONwJIIAIgAkGIAWo2AkAgAkHoAGogBBCuAQ0EIAIpAogBIQ4gBSACKAKQATYCDCAFIA43AgQgBUEJNgIADAMLIAIoAnwhBCACKAKAASIGQSBHBEAgAkEcaiIJIAY2AgAgAkKAgICAgAQ3AhQgAkHQAGogAkEkaigCADYCACACQcgAaiAJKQIANwMAIAJCgICAgIAENwNAIAJBADYCgAEgAkKAgICAEDcCeCACQaDDwAA2AowBIAJCoICAgA43ApABIAIgAkH4AGo2AogBIAJBQGsgAkGIAWoQWQ0EIAJBGGohCSACQRRqIQYgAkHwAGogAkGAAWooAgA2AgAgAiACKQJ4NwNoAkAgAigCQCIMQQhNQQBBASAMdEHPA3EbDQAgAigCRCIMRQ0AIAIoAkggDEEBEPoCCyAJIAIpA2g3AgAgCUEIaiACQfAAaigCADYCACACQQU2AhQgBUEQaiAGQRBqKAIANgIAIAVBCGogBkEIaikCADcCACAFIAYpAgA3AgAgCEUNAyAEIAhBARD6AgwDCyACQcIAaiAEQQJqLQAAOgAAIAQpAAMhDiAEKAALIQYgBCkADyEPIAQvAAAhCSACQd8AaiAEQR9qLQAAOgAAIAIgCTsBQCACIAQpABc3AFcgAiAPNwBPIAIgBjYASyACIA43AEMgAkEQakEBciACQUBrIgYQ7gEgBhDCASACQdwAaiACQSlqKQAANwIAIAJB1ABqIAJBIWopAAA3AgAgAkHMAGogAkEZaikAADcCACACIAIpABE3AkQgAkHrwMAANgJAIAJBADYCkAEgAkKAgICAEDcCiAEgAkEgNgJ8IAIgAkHEAGo2AnggAiACQYgBaiIJNgJoIAJBCGogAkHoAGpBMCACQfgAaiIMQevAwAAQnAEgAigCCEEBcQ0BIAJBgAFqIAJBkAFqKAIANgIAIAIgAikCiAE3A3ggAiAMrUKAgICAwAaENwOIASACQgE3AkwgAkEBNgJEIAJBsMLAADYCQCACIAk2AkggAkE0aiAGEHkgAigCeCIGBEAgAigCfCAGQQEQ+gILIAUgAikCNDcCBCAFQQo2AgAgBUEMaiACQTxqKAIANgIAIAhFDQIgBCAIQQEQ+gIMAgsgBUENNgIQIAVB3sDAADYCDCAFQQ42AgggBUHQwMAANgIEIAVBCDYCAAwBC0HIvsAAQSsgAkGfAWpBuL7AAEH0vsAAEOYBAAsgAkGgAWokAAwBC0HIw8AAQTcgAkGfAWpBuMPAAEGAxMAAEOYBAAsgA0EoaiICIANBxABqIgQoAgA2AgAgAyADKQI8NwMgIAMoAjgiCEEKRwRAIAMoAkghBiAEIAIoAgA2AgAgAyADKQMgNwI8IAMgBjYCSCADIAg2AjggBRDLASECIAtBgICAgHg2AgAgCyACNgIEDAELIAsgAykDIDcCACALQQhqIAIoAgA2AgALIANB0ABqJAAgAQRAIAAgAUEBEPoCCwJAAkAgBwJ/IAooAgQiAkGAgICAeEYEQEEAIQEgCigCCCEAQQEMAQsgCigCCCEAAkAgCigCDCINIAJPBEAgACEBDAELIA1FBEBBASEBIAAgAkEBEPoCDAELIAAgAkEBIA0Q7QIiAUUNAgtBACEAQQALNgIMIAcgADYCCCAHIA02AgQgByABNgIAIApBEGokAAwBC0EBIA0Q2wIACyAHKAIAIAcoAgQgBygCCCAHKAIMIAdBEGokAAskAAJAIAAgARDcAkUNACAABEAgACABEIEDIgFFDQELIAEPCwALJwECfyMAQRBrIgAkACAAQQo2AgQgAEEEakEAQQAQkgIgAEEQaiQAC6QJAhJ/An4jAEEwayIPJAAgD0EMaiEQIwBBsAFrIgIkACACQThqQgA3AwAgAkEwakIANwMAIAJBKGpCADcDACACQSBqQgA3AwAgAkEYakIANwMAIAJBEGpCADcDACACQQhqQgA3AwAgAkIANwMAQQEhBwNAIAIgBWoiAyADKAIAIAEgBWoiAy0AAHIgA0EBai0AAEEIdHIgA0ECai0AAEEQdHIgA0EDai0AAEEYdHI2AgAgBUEEaiEFIAdBEEkgB0EBaiEHDQALIAJByABqIgEgAigCCCIKQQZ0IAIoAgQiBkEadnJB/////wFxNgIAIAJB0ABqIgUgAigCECILQQx0IAIoAgwiDEEUdnJB/////wFxNgIAIAJB2ABqIgcgAigCGCIEQRJ0IAIoAhQiDUEOdnJB/////wFxNgIAIAJB4ABqIgMgAigCICIOQRh0IAIoAhwiCEEIdnJB/////wFxNgIAIAIgAigCACIJQf////8BcTYCQCACIAZBA3QgCUEddnJB/////wFxNgJEIAIgDEEJdCAKQRd2ckH/////AXE2AkwgAiANQQ90IAtBEXZyQf////8BcTYCVCACIAhBFXQgBEELdnJB/////wFxNgJcIAJBiAFqIgogAigCPCIEQQ12NgIAIAJB8ABqIg0gAigCKCIIQQF0IAIoAiQiBkEfdnJB/////wFxNgIAIAJB+ABqIgsgAigCMCIJQQd0IAIoAiwiEUEZdnJB/////wFxNgIAIAJBgAFqIgwgAigCOCISQQ10IAIoAjQiE0ETdnJB/////wFxNgIAIAIgBkECdkH/////AXE2AmwgAiAGQRt0IA5BBXZyQf////8BcTYCaCACIBFBBHQgCEEcdnJB/////wFxNgJ0IAIgE0EKdCAJQRZ2ckH/////AXE2AnwgAiAEQRB0IBJBEHZyQf////8BcTYChAEgAkGMAWoiBiACQUBrQbzhwAAQMSADIAJBrAFqIgQoAgA2AgAgByACQaQBaiIOKQIANwMAIAUgAkGcAWoiCCkCADcDACABIAJBlAFqIgkpAgA3AwAgAiACKQKMATcDQCAGIAJB6ABqQZjhwAAQMSAKIAQoAgA2AgAgDCAOKQIANwMAIAsgCCkCADcDACANIAkpAgAiFDcDACACIAIpAowBIhU3A2ggAiACKAJAIBWnaiIEQf////8BcTYCjAEgAiACKAJEIAIoAmwgBEEddmpqIgRB/////wFxNgKQASACIAEoAgAgFKcgBEEddmpqIgFB/////wFxNgKUASACIAIoAkwgAigCdCABQR12amoiAUH/////AXE2ApgBIAIgBSgCACALKAIAIAFBHXZqaiIBQf////8BcTYCnAEgAiACKAJUIAIoAnwgAUEddmpqIgFB/////wFxNgKgASACIAcoAgAgDCgCACABQR12amoiAUH/////AXE2AqQBIAIgAigCXCACKAKEASABQR12amoiAUH/////AXE2AqgBIAIgAygCACAKKAIAIAFBHXZqakH/////AXE2AqwBIBAgBkHg4cAAEGggAkGwAWokACAAIBAQfyAPQTBqJAAL/AECAn8BfiMAQRBrIgIkACACQQE7AQwgAiABNgIIIAIgADYCBCMAQRBrIgEkACACQQRqIgApAgAhBCABIAA2AgwgASAENwIEIwBBEGsiACQAIAFBBGoiASgCACICKAIMIQMCQAJAAkACQCACKAIEDgIAAQILIAMNAUEBIQJBACEDDAILIAMNACACKAIAIgIoAgQhAyACKAIAIQIMAQsgAEGAgICAeDYCACAAIAE2AgwgAEH8p8QAIAEoAgQgASgCCCIALQAIIAAtAAkQxAEACyAAIAM2AgQgACACNgIAIABB4KfEACABKAIEIAEoAggiAC0ACCAALQAJEMQBAAu3FwIYfwd+IwBBEGsiEiQAIAEhFyMAQUBqIggkAAJAAkACQCAABEAgAEEIayITIBMoAgBBAWoiBDYCACAERQ0BIAAoAgANAiAAQX82AgAgCCATNgIMIAggADYCCCAIIABBCGoiBDYCBCAIIAI2AiggCCABNgIkIAggAjYCICAIQSxqIQ0gBCEBIAhBIGohFCMAQcAtayIEJAACQAJAIAMEQCABKAKUECEMIAEoApgQIQoMAQsgASgCmBAhCiABKAKUECEMIARBkBBqIAFBGGopAwA3AwAgBEGIEGogAUEQaikDADcDACAEQYAQaiABQQhqKQMANwMAIAQgASkDADcD+A8gBEHQH2ogAUH4AGopAwA3AwAgBEHIH2og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BjoAAAwHCyADQQc6AAAMBgsgA0EJOgAADAULIANBCjoAAAwEC0ELIQQLIAMgBDoAAAwCCyADQQE6AAAMAQsgA0ECOgAACyADIAEgAhDXASADQRBqJAALZAEEfyMAQRBrIgIkACMAQRBrIgMkACADQQhqIAAgARCJASADKAIMIQQgAygCCCEFIAEEQCAAIAFBARD6AgsgAiAFNgIAIAIgBDYCBCADQRBqJAAgAigCACACKAIEIAJBEGokAAvkAwIFfwN+IwBBEGsiBCQAIwBBEGsiBSQAIAVBCGohBiMAQYAQayICJAAgAkE4akIANwMAIAJBMGpCADcDACACQShqQgA3AwAgAkEgakIANwMAIAJBGGpCADcDACACQRBqQgA3AwAgAkEIakIANwMAIAJByABqQcDLwAApAgAiBzcDACACQdAAakHIy8AAKQIAIgg3AwAgAkHYAGpB0MvAACkCACIJNwMAIAJBiA9qIAc3AwAgAkGQD2ogCDcDACACQZgPaiAJNwMAIAJCADcDACACQbjLwAApAgAiBzcDQCACIAc3A4APIAJBoA9qIAJB4AD8CgAAIAIgAkGAD2oiA0GAAfwKAAAgAkGHAWpBADYAACACQQA2ApgBIAJCADcDkAEgAkIANwOAASACIAAgARApIAMgAhC/AUEgQQEQgQMiA0UEQEEBQSAQ2wIACyADIAIpAIAPNwAAIANBGGogAkGYD2opAAA3AAAgA0EQaiACQZAPaikAADcAACADQQhqIAJBiA9qKQAANwAAIAZBIDYCBCAGIAM2AgAgAkGAEGokACAFKAIMIQIgBSgCCCEDIAEEQCAAIAFBARD6AgsgBCADNgIAIAQgAjYCBCAFQRBqJAAgBCgCACAEKAIEIARBEGokAAshAAJAIAEgAxDcAgRAIAAgASADIAIQ7QIiAA0BCwALIAALogIBBH8jAEEQayIDJAAjAEEwayICJAACQAJAAkACQCAABEAgAEEIayIEIAQoAgBBAWoiATYCACABRQ0BIAAoAgAiAUF/Rg0CIAAgAUEBajYCACACIAQ2AgwgAiAANgIIIAIgAEEIaiIBNgIEIAJBEGogARC/AUEgQQEQgQMiAUUNAyABIAIpABA3AAAgAUEYaiACQShqKQAANwAAIAFBEGogAkEgaikAADcAACABQQhqIAJBGGopAAA3AAAgACAAKAIAQQFrNgIAIAQgBCgCAEEBayIANgIAIABFBEAgAkEMahCaAgsgA0EgNgIEIAMgATYCACACQTBqJAAMBAsQkAMLAAsQkQMAC0EBQSAQ2wIACyADKAIAIAMoAgQgA0EQaiQACyUAIABFBEBB9JvDAEEyEJIDAAsgACACIAMgBCAFIAEoAhAREAALxwIBCX8jAEEQayIDJAAjAEEQayIEJAAgBEEIaiEFIwBB0AJrIgAkACAAQYACaiICQgA3AwAgAEH4AWoiBkIANwMAIABB8AFqIgdCADcDACAAQgA3A+gBIABB6AFqIggQ1QEgAEGPAmoiASAIEDkgAEEIaiABEKICIAEQwAEgAEHQAWogBykDADcCACAAQdgBaiAGKQMANwIAIABB4AFqIAIpAwA3AgAgACAAKQPoATcCyAFBIEEBEIEDIgFFBEBBAUEgEJoDAAsgASAAQcgBaiICKQAANwAAIAFBGGogAkEYaikAADcAACABQRBqIAJBEGopAAA3AAAgAUEIaiACQQhqKQAANwAAIABBCGoQwwEgBUEgNgIEIAUgATYCACAAQdACaiQAIAMgBCkDCDcCACAEQRBqJAAgAygCACADKAIEIANBEGokAAulAgEIfyMAQRBrIgIkACMAQRBrIgMkACADQQhqIQQjAEEgayIBJAAjAEEwayIAJAAgAEEgaiIFQgA3AwAgAEEYaiIGQgA3AwAgAEEQaiIHQgA3AwAgAEIANwMIIABBCGoQ1QEgAUEYaiAFKQMANwAAIAFBEGogBikDADcAACABQQhqIAcpAwA3AAAgASAAKQMINwAAIABBMGokAEEgQQEQgQMiAEUEQEEBQSAQmgMACyAAIAEpAAA3AAAgAEEYaiABQRhqKQAANwAAIABBEGogAUEQaikAADcAACAAQQhqIAFBCGopAAA3AAAgARDCASAEQSA2AgQgBCAANgIAIAFBIGokACACIAMpAwg3AgAgA0EQaiQAIAIoAgAgAigCBCACQRBqJAALIwAgAEUEQEH0m8MAQTIQkgMACyAAIAIgAyAEIAEoAhARCgALIwAgAEUEQEH0m8MAQTIQkgMACyAAIAIgAyAEIAEoAhAREQALIwAgAEUEQEH0m8MAQTIQkgMACyAAIAIgAyAEIAEoAhAROAALIwAgAEUEQEH0m8MAQTIQkgMACyAAIAIgAyAEIAEoAhAROgALIwAgAEUEQEH0m8MAQTIQkgMACyAAIAIgAyAEIAEoAhARPAALKAEBfyAAKAIAIgFBgICAgHhyQYCAgIB4RwRAIAAoAgQgAUEBEPoCCwshACAARQRAQfSbwwBBMhCSAwALIAAgAiADIAEoAhARAwALIgAgAC0AAEUEQCABQZy0xABBBRBTDwsgAUGhtMQAQQQQUwsbACAAKAIAIgBBBGooAgAgAEEIaigCACABEEILHwAgAEUEQEH0m8MAQTIQkgMACyAAIAIgASgCEBEAAAscACAAIAAtAAQgAUEuRnI6AAQgACgCACABEOoCCxoBAX8gACgCACIBBEAgACgCBCABQQEQ+gILCxwAIAAoAgAiACgCACABIABBBGooAgAoAhARAAALHwAgAEEIakGg3sAAKQIANwIAIABBmN7AACkCADcCAAsfACAAQQhqQciSwwApAgA3AgAgAEHAksMAKQIANwIACx8AIABBCGpB5KDEACkCADcCACAAQdygxAApAgA3AgALHwAgAEEIakH0oMQAKQIANwIAIABB7KDEACkCADcCAAtFACAABEAgACABEJoDAAsjAEEgayIAJAAgAEEANgIYIABBATYCDCAAQcCtxAA2AgggAEIENwIQIABBCGpByK3EABC/AgALFQAgAWlBAUYgAEGAgICAeCABa01xCxcBAX8gABAVIgE2AgQgACABQQBHNgIACxcBAX8gABAYIgE2AgQgACABQQBHNgIACxcBAX8gABAZIgE2AgQgACABQQBHNgIACxcBAX8gABAaIgE2AgQgACABQQBHNgIACxwAIABBADYCECAAQgA3AgggAEKAgICAwAA3AgALFwEBbyAAIAEQACECEI8BIgAgAiYBIAALFwEBbyAAIAEQASECEI8BIgAgAiYBIAALFwEBbyAAJQEQECEBEI8BIgAgASYBIAALFgAgACgCACIAKAIEIAAoAgggARCbAwsWACAAKAIAIgAoAgAgACgCBCABEJsDCxUBAX8jAEEQayIBIAA6AA8gAS0ADwsQACABBEAgACABIAIQ+gILCxYAIAAoAgAgASACIAAoAgQoAgwRAQALFAAgACgCACABIAAoAgQoAhARAAALnAcBA38jAEHwAGsiBSQAIAUgAzYCDCAFIAI2AggCfwJAAkAgAUGBAk8EQEH9ASEGA0ACQCAAIAZq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ARCbAwsTACAAQSg2AgQgAEHw3cAANgIACxAAIAAoAgAgACgCBCABEEILEwAgAEEoNgIEIABBmJLDADYCAAsWAEHM5MQAIAA2AgBByOTEAEEBNgIACxAAIAAoAgQgACgCCCABEEILEQAgASAAKAIAIAAoAgQQ6QILEwAgAEG8qMQANgIEIAAgATYCAAsQACABIAAoAgAgACgCBBBTCxAAIAEoAgAgASgCBCAAEGALEQEBfxCPASIBIAAlASYBIAELYQEBfwJAAkAgAEEEaygCACICQXhxIgNBBEEIIAJBA3EiAhsgAWpPBEAgAkEAIAMgAUEnaksbDQEgABBNDAILQcyoxABBLkH8qMQAEJkCAAtBjKnEAEEuQbypxAAQmQIACwsPAEGs3MAAQS8gABCZAgALDwBBuNPEAEErIAAQmQIACw4AIAFB9KHAAEEFEOkCC6gBAQJ/IAAoAgAjAEEwayIAJAAoAgAhAiAAQgA3AyggAEEoaiIDIAIlARAeIAAgACgCLCICNgIkIAAgACgCKDYCICAAIAI2AhwgAEECNgIIIABBiJ7DADYCBCAAQgE3AhAgACAAQRxqrUKAgICAwA+ENwMoIAAgAzYCDCABKAIAIAEoAgQgAEEEahBgIAAoAhwiAgRAIAAoAiAgAkEBEPoCCyAAQTBqJAALDQAgAEGApcAAIAEQYAsOACABQfClwABBBRDpAgsaAAJ/IAFBCU8EQCABIAAQggEMAQsgABAjCwsOACABQc+uwABBGRDpAgsOACABQeiuwABBEBDpAgsOACABQfiuwABBGhDpAgsOACABQcSvwABBERDpAgsOACABQay4wABBERDpAgsOACABQfS5wABBERDpAgsOACABQdC9wABBBRDpAgsOACABQYS/wABBDhDpAgsNACAAQaDDwAAgARBgCw4AIAFBkMTAAEEFEOkCCw4AIAFB9MfAAEEFEOkCCwwAIAAoAgAgARCxAQsMACAAKAIAIAEQmwELCAAgACABECcLDQBBppzDAEEbEJIDAAsOAEHBnMMAQc8AEJIDAAsJACAAIAEQHQALDgAgAUHstsMAQQUQ6QILDQAgAEGsvcMAIAEQYAsNACAAQbygxAAgARBgCw0AIABByKfEACABEGALDAAgACABKQIANwMACw0AIABB2K3EACABEGALDgAgAUGsrMQAQQUQ6QILGgAgACABQZToxAAoAgAiAEGUASAAGxECAAALCgAgAiAAIAEQUwsNACAAQZy2xAAgARBgCw0AIAFB9uLEAEEYEFMLDQAgAUHU4sQAQSAQUwsOACABQdSgxABBCBDpAgsOACABQd7IwwBBDRDpAgsJACAAQQA2AgALTQEBfyMAQTBrIgEkACABQQE2AgwgAUHws8QANgIIIAFCATcCFCABIAFBL2qtQoCAgIDQFYQ3AyAgASABQSBqNgIQIAFBCGogABC/AgALUAEBfyMAQTBrIgAkACAAQQE2AgwgAEHws8QANgIIIABCATcCFCAAIABBL2qtQoCAgIDgFYQ3AyAgACAAQSBqNgIQIABBCGpB5J/AABC/AgALCAAgACUBEAILFQIBbwF/EBwhABCPASIBIAAmASABCwIACwur3wRAAEGAgMAAC4MfL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2FsbG9jL3NyYy9jb2xsZWN0aW9ucy9idHJlZS9tYXAvZW50cnkucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9iYXNlNjQtMC4yMi4xL3NyYy9lbmdpbmUvZ2VuZXJhbF9wdXJwb3NlL2RlY29kZV9zdWZmaXgucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9jdXJ2ZTI1NTE5LWRhbGVrLTQuMS4zL3NyYy93aW5kb3cucnMAbGlicmFyeS9jb3JlL3NyYy9udW0vZmx0MmRlYy9zdHJhdGVneS9ncmlzdS5ycwBsaWJyYXJ5L2FsbG9jL3NyYy9mbXQucnMAbGlicmFyeS9jb3JlL3NyYy9udW0vZGl5X2Zsb2F0LnJzAGNvanNvbi1jb3JlL3NyYy9jb3JlL2tleXMucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9yYW5kX2NvcmUtMC42LjQvc3JjL29zLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvY3VydmUyNTUxOS1kYWxlay00LjEuMy9zcmMvZWR3YXJkcy5ycwAvVXNlcnMvYW50b25pby5tdXNvbGluby8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvc3RkL3NyYy9zeXMvdGhyZWFkX2xvY2FsL25vX3RocmVhZHMucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9zZXJkZV9qc29uLTEuMC4xNDIvc3JjL2Vycm9yLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2Yvc2VyZGVfanNvbi0xLjAuMTQyL3NyYy9zZXIucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9zaWduYXR1cmUtMi4yLjAvc3JjL3NpZ25lci5ycwAvVXNlcnMvYW50b25pby5tdXNvbGluby8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL2N1cnZlMjU1MTktZGFsZWstNC4xLjMvc3JjL3NjYWxhci5ycwAvVXNlcnMvYW50b25pby5tdXNvbGluby8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvY29yZS9zcmMvc3RyL3BhdHRlcm4ucnMAbGlicmFyeS9jb3JlL3NyYy9udW0vZmx0MmRlYy9zdHJhdGVneS9kcmFnb24ucnMAbGlicmFyeS9jb3JlL3NyYy9udW0vYmlnbnVtLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvY2lwaGVyLTAuNC40L3NyYy9zdHJlYW0ucnMAY29qc29uLWNvcmUvc3JjL2NvcmUvc2Vzc2lvbl9sb2cucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2FsbG9jL3NyYy9zdHJpbmcucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2FsbG9jL3NyYy9jb2xsZWN0aW9ucy9idHJlZS9uYXZpZ2F0ZS5ycwBsaWJyYXJ5L2NvcmUvc3JjL3VuaWNvZGUvcHJpbnRhYmxlLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vL1dvcmtzcGFjZS9naXRodWIvamF6ei9jcmF0ZXMvY29qc29uLWNvcmUvc3JjL2NvcmUvY2FjaGUucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2FsbG9jL3NyYy9jb2xsZWN0aW9ucy9idHJlZS9ub2RlLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvYnM1OC0wLjUuMS9zcmMvZW5jb2RlLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvYmFzZTY0LTAuMjIuMS9zcmMvZW5jb2RlLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvYmFzZTY0LTAuMjIuMS9zcmMvZW5naW5lL2dlbmVyYWxfcHVycG9zZS9kZWNvZGUucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9iczU4LTAuNS4xL3NyYy9kZWNvZGUucnMAY29qc29uLWNvcmUvc3JjL2NvcmUvbm9uY2UucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9oYXNoYnJvd24tMC4xNS41L3NyYy9yYXcvbW9kLnJzAGxpYnJhcnkvY29yZS9zcmMvZm10L21vZC5ycwAvVXNlcnMvYW50b25pby5tdXNvbGluby8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL2Jhc2U2NC0wLjIyLjEvc3JjL2VuZ2luZS9nZW5lcmFsX3B1cnBvc2UvbW9kLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvYmFzZTY0LTAuMjIuMS9zcmMvZW5naW5lL21vZC5ycwBsaWJyYXJ5L2FsbG9jL3NyYy9yYXdfdmVjL21vZC5ycwBsaWJyYXJ5L2NvcmUvc3JjL251bS9mbHQyZGVjL21vZC5ycwAvVXNlcnMvYW50b25pby5tdXNvbGluby8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL3NlcmRlX2pzb24tMS4wLjE0Mi9zcmMvcmVhZC5ycwAvcnVzdC9kZXBzL2RsbWFsbG9jLTAuMi4xMC9zcmMvZGxtYWxsb2MucnMAbGlicmFyeS9zdGQvc3JjL2FsbG9jLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvYXJyYXl2ZWMtMC43LjYvc3JjL2FycmF5dmVjLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvZm9sZGhhc2gtMC4xLjUvc3JjL2xpYi5ycwAvVXNlcnMvYW50b25pby5tdXNvbGluby8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL29uY2VfY2VsbC0xLjIxLjMvc3JjL2xpYi5ycwAvVXNlcnMvYW50b25pby5tdXNvbGluby8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL2JsYWtlMy0xLjguMi9zcmMvbGliLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvbHJ1LTAuMTYuMS9zcmMvbGliLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvY3J5cHRvX3NlY3JldGJveC0wLjEuMS9zcmMvbGliLnJzAAAAAF8OEABiAAAAlAEAADYAAABIYXNoIHRhYmxlIGNhcGFjaXR5IG92ZXJmbG93RA8QABwAAABWChAAbAAAACUAAAAoAAAA//////////94DxAAQZCfwAALiQJ9RXhwZWN0ZWQgcHJpdmF0ZSB0cmFuc2FjdGlvbnNpZ25hdHVyZWVuY3J5cHRlZF9jaGFuZ2VzbWV0YUpzVmFsdWUgRXJyb3I6IAAAyw8QAA8AAACoBxAAUgAAAAgAAAARAAAAYXR0ZW1wdGVkIHRvIHRha2Ugb3duZXJzaGlwIG9mIFJ1c3QgdmFsdWUgd2hpbGUgaXQgd2FzIGJvcnJvd2VkSW52YWxpZCBzaWduYXR1cmUgbGVuZ3RoSW52YWxpZCBzaWduaW5nIGtleSBsZW5ndGhJbnZhbGlkIHZlcmlmeWluZyBrZXkgbGVuZ3RoAAAAAgAAAAwAAAAEAAAAAwAAAAQAAAAFAEGkocAAC/EDAQAAAAYAAABhIERpc3BsYXkgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3IgdW5leHBlY3RlZGx5AH4GEAB3AAAASwsAAA4AAABFcnJvckludmFsaWQgVVRGLTggaW4gc2VjcmV0OiAAAPkQEAAZAAAASW52YWxpZCBVVEYtOCBpbiBzaWduYXR1cmU6IBwREAAcAAAASW52YWxpZCBVVEYtOCBpbiBpZDogAAAAQBEQABUAAAAAAAAABAAAAAQAAAAIAAAAAAAAAAQAAAAEAAAACQAAAFV0ZjhFcnJvcnZhbGlkX3VwX3RvZXJyb3JfbGVuYXR0ZW1wdGVkIHRvIHRha2Ugb3duZXJzaGlwIG9mIFJ1c3QgdmFsdWUgd2hpbGUgaXQgd2FzIGJvcnJvd2VkZ+YJaoWuZ7ty8248OvVPpX9SDlGMaAWbq9mDHxnN4Fu+DBAAawAAAHsEAAAPAAAAAAAAAAQAAAAEAAAACgAAAE5vbmVTb21laW50ZXJuYWwgZXJyb3I6IGVudGVyZWQgdW5yZWFjaGFibGUgY29kZd8DEABqAAAAgQIAACoAAABJbnZhbGlkIFVURi04IGluIHNlY3JldDogAAAAXBIQABkAAAAMAAAADAAAAAQAAAANAAAADgAAAAUAQaClwAAL/wMBAAAADwAAAGEgRGlzcGxheSBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvciB1bmV4cGVjdGVkbHkAfgYQAHcAAABLCwAADgAAAEVycm9yAAAAAAAAAAQAAAAEAAAAEAAAAAAAAAAEAAAABAAAAAkAAABVdGY4RXJyb3J2YWxpZF91cF90b2Vycm9yX2xlblZlcmlmeWluZ0tleX0BAAFBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1f////////////////////////////////////////////////////////////Pv//NDU2Nzg5Ojs8Pf////////8AAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGf////8//xobHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIz/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////2VuY3J5cHRlZF9VhRQQAAsAAABwcml2YXRlAEGoqcAAC50JAQAAABIAAABjYWxsZWQgYFJlc3VsdDo6dW53cmFwKClgIG9uIGFuIGBFcnJgIHZhbHVlAPIFEABnAAAAeAAAACcAAAD/////////////////////////////////////////////////////////////////AAECAwQFBgcI/////////wkKCwwNDg8Q/xESExQV/xYXGBkaGxwdHh8g////////ISIjJCUmJygpKiv/LC0uLzAxMjM0NTY3ODn//////zEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXoiaGFzaF96IgAAphUQAAcAAACtFRAAAQAAABMAAAAEAAAABAAAABQAAABaBhAAIwAAANEAAAA2AAAAWgYQACMAAADAAQAAOAAAAFoGEAAjAAAAlQEAADQAAABn5glqha5nu3Lzbjw69U+lf1IOUYxoBZur2YMfGc3gWxUAAAAIAAAABAAAABYAAABJbnZhbGlkIHB1YmxpYyBrZXkAAFoGEAAjAAAAagAAABIAAAAXAAAAFAAAAAQAAAAYAAAAWgYQACMAAABnAAAAGgAAAFByaXZhdGVUcmFuc2FjdGlvbmVuY3J5cHRlZENoYW5nZXNrZXlVc2VkbWFkZUF0bWV0YXByaXZhY3kAAIYWEAAQAAAAlhYQAAcAAACdFhAABgAAAKMWEAAEAAAApxYQAAcAAABUcnVzdGluZ1RyYW5zYWN0aW9uY2hhbmdlcwAA6xYQAAcAAACdFhAABgAAAKMWEAAEAAAApxYQAAcAAABkYXRhIGRpZCBub3QgbWF0Y2ggYW55IHZhcmlhbnQgb2YgdW50YWdnZWQgZW51bSBUcmFuc2FjdGlvbnN0cnVjdCBQcml2YXRlVHJhbnNhY3Rpb25maWVsZCBpZGVudGlmaWVyc3RydWN0IFRydXN0aW5nVHJhbnNhY3Rpb24AACcFEAB7AAAA5QUAABQAAAAnBRAAewAAAOUFAAAhAAAAJwUQAHsAAADZBQAAIQAAAFN0cmVhbUNpcGhlckVycm9yAAAAAAAAAAQAAAAEAAAAGQAAAFRyYW5zYWN0aW9uTm90Rm91bmRJbnZhbGlkRW5jcnlwdGVkUHJlZml4AAAAAAAAAAQAAAAEAAAAGgAAAEJhc2U2NERlY29kZQAAAAAEAAAABAAAABsAAABVdGY4AAAAAAQAAAAEAAAAHAAAAEpzb24AAAAABAAAAAQAAAAdAAAAU2lnbmF0dXJlVmVyaWZpY2F0aW9uSW52YWxpZERlY29kaW5nUHJlZml4AAAAAAAABAAAAAQAAAAeAAAAAAAAAAQAAAAEAAAAHwAAAEludmFsaWRLZXlMZW5ndGgAAAAABAAAAAQAAAAgAAAASW52YWxpZEJhc2U1OFRyYW5zYWN0aW9uVG9vTGFyZ2UnBRAAewAAAGkEAAAkAAAAXw4QAGIAAACUAQAANgAAAEhhc2ggdGFibGUgY2FwYWNpdHkgb3ZlcmZsb3cUGRAAHAAAAFYKEABsAAAAJQAAACgAQdCywAALBQEAAAAhAEHgssAACwUBAAAAIgBB8LLAAAsFAQAAACMAQYCzwAALBQEAAAAkAEGQs8AAC/kEAQAAACQAAABlbmNyeXB0ZWRDaGFuZ2Vza2V5VXNlZG1hZGVBdG1ldGFwcml2YWN5c3RydWN0IFByaXZhdGVUcmFuc2FjdGlvbiB3aXRoIDUgZWxlbWVudHMAAADAGRAAKQAAAAAAAAAIAAAABAAAACUAAABjaGFuZ2Vzc3RydWN0IFRydXN0aW5nVHJhbnNhY3Rpb24gd2l0aCA0IGVsZW1lbnRzAAAACxoQACoAAAAAAAAABAAAAAQAAAAmAAAAAAAQAIwAAACgAQAALgAAAGFzc2VydGlvbiBmYWlsZWQ6IGVkZ2UuaGVpZ2h0ID09IHNlbGYuaGVpZ2h0IC0gMfsHEACHAAAAtgIAAAkAAAD7BxAAhwAAAPAAAABNAAAAYXNzZXJ0aW9uIGZhaWxlZDogc3JjLmxlbigpID09IGRzdC5sZW4oKfsHEACHAAAAVAcAAAUAAAD7BxAAhwAAANAEAAAjAAAA+wcQAIcAAAATBQAAJAAAAGFzc2VydGlvbiBmYWlsZWQ6IGVkZ2UuaGVpZ2h0ID09IHNlbGYubm9kZS5oZWlnaHQgLSAxAAAA+wcQAIcAAAADBAAACQAAAPYGEACLAAAAWAIAADAAAABn5glqha5nu3Lzbjw69U+lf1IOUYxoBZur2YMfGc3gWycAAAAEAAAABAAAABQAAABjYWxsZWQgYFJlc3VsdDo6dW53cmFwKClgIG9uIGFuIGBFcnJgIHZhbHVlADgKEAAdAAAANAAAADwAAABzZXNzaW9uSUR0eEluZGV4ZGVzdCBpcyBvdXQgb2YgYm91bmRzAAAA3BsQABUAAAD2BhAAiwAAABYCAAAvAEGUuMAAC0kBAAAAKAAAAPIFEABnAAAAeAAAACcAAABTdHJlYW1DaXBoZXJFcnJvcgAAAMIOEABuAAAA/QAAABkAAADCDhAAbgAAAAUBAAAYAEHouMAACz0BAAAAIQAAAGludGVybmFsIGVycm9yOiBlbnRlcmVkIHVucmVhY2hhYmxlIGNvZGXfAxAAagAAAKYCAAAqAEGwucAAC8UDAQAAACwAAABjYWxsZWQgYFJlc3VsdDo6dW53cmFwKClgIG9uIGFuIGBFcnJgIHZhbHVlAPIFEABnAAAAeAAAACcAAABTdHJlYW1DaXBoZXJFcnJvckludmFsaWQga2V5IGxlbmd0aCAoZXhwZWN0ZWQgLCBnb3QgKQAAAAUdEAAdAAAAIh0QAAYAAAAoHRAAAQAAAEludmFsaWQgbm9uY2UgbGVuZ3RoSW52YWxpZCBzZWFsZXIgc2VjcmV0IGZvcm1hdDogbXVzdCBzdGFydCB3aXRoICdzZWFsZXJTZWNyZXRfeidJbnZhbGlkIHNpZ25hdHVyZSBsZW5ndGhJbnZhbGlkIHZlcmlmeWluZyBrZXk6IAAAAK4dEAAXAAAASW52YWxpZCBwdWJsaWMga2V5OiDQHRAAFAAAAFdyb25nIHRhZ0ZhaWxlZCB0byBjcmVhdGUgY2lwaGVySW52YWxpZCAgZm9ybWF0OiBtdXN0IHN0YXJ0IHdpdGggJycADB4QAAgAAAAUHhAAGgAAAC4eEAABAAAASW52YWxpZCBiYXNlNTg6IEgeEAAQAAAALQAAAAwAAAAEAAAALgAAAC8AAAAwAEGAvcAAC7UBAQAAADEAAABhIERpc3BsYXkgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3IgdW5leHBlY3RlZGx5AH4GEAB3AAAASwsAAA4AAABFcnJvcgAAAN0HEAAdAAAAGQAAADEAAADdBxAAHQAAACcAAAA4AAAAgwgQAGUAAADRAQAAEAAAAIMIEABlAAAA0AEAABsAAACDCBAAZQAAAMwBAAAJAAAAgwgQAGUAAAC5AQAAIABBwL7AAAv1BAEAAAAyAAAAY2FsbGVkIGBSZXN1bHQ6OnVud3JhcCgpYCBvbiBhbiBgRXJyYCB2YWx1ZQCDCBAAZQAAAD0BAAAgAAAAQnVmZmVyVG9vU21hbGwAADMAAAAIAAAABAAAABYAAABzaWduYXR1cmUgb3BlcmF0aW9uIGZhaWxlZAAASgQQAGoAAAAQAAAAHAAAAHVzaXplIG92ZXJmbG93IHdoZW4gY2FsY3VsYXRpbmcgYjY0IGxlbmd0aAAA6QgQAGgAAABXAAAACgAAAOkIEABoAAAAUAAAADMAAABIYXNoIHRhYmxlIGNhcGFjaXR5IG92ZXJmbG93HCAQABwAAABWChAAbAAAACUAAAAoAAAAc2VhbGVyU2VjcmV0X3pzZWFsZXIgc2VjcmV0/////////////////////////////////////////////////////////////////wABAgMEBQYHCP////////8JCgsMDQ4PEP8REhMUFf8WFxgZGhscHR4fIP///////yEiIyQlJicoKSor/ywtLi8wMTIzNDU2Nzg5//////8xMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6c2VhbGVyX3oAAAAlIRAACAAAAGtleVNlY3JldF96a2V5IHNlY3JldHNpZ25lclNlY3JldF96c2lnbmVyIHNlY3JldHNpZ25lcl96aCEQAAgAAABzaWduYXR1cmVfegB4IRAACwAAAHNpZ25hdHVyZXNpZ25lciBJRAAANQAAAAwAAAAEAAAANgAAADcAAAAwAEHAw8AAC9kDAQAAADgAAABhIERpc3BsYXkgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3IgdW5leHBlY3RlZGx5AH4GEAB3AAAASwsAAA4AAABFcnJvcgAAADUAAAAMAAAABAAAADkAAAAAAAAABAAAAAQAAAA6AAAARnJvbVV0ZjhFcnJvcmJ5dGVzZXJyb3IAOwAAABQAAAAEAAAAPAAAAGNhbGxlZCBgUmVzdWx0Ojp1bndyYXAoKWAgb24gYW4gYEVycmAgdmFsdWUAgwgQAGUAAACTAAAAKwAAAHNlYWxlclNlY3JldF96c2VhbGVyIHNlY3JldP////////////////////////////////////////////////////////////////8AAQIDBAUGBwj/////////CQoLDA0ODxD/ERITFBX/FhcYGRobHB0eHyD///////8hIiMkJSYnKCkqK/8sLS4vMDEyMzQ1Njc4Of//////MTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5enNlYWxlcl96c2VhbGVyIElEAAA9AAAADAAAAAQAAAA+AAAAPwAAADAAQaTHwAAL4Q8BAAAAQAAAAGEgRGlzcGxheSBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvciB1bmV4cGVjdGVkbHkAfgYQAHcAAABLCwAADgAAAEVycm9yAAAAAAAAAAQAAAAEAAAAQQAAAAAAAAAEAAAABAAAAEIAAABJbnZhbGlkQnl0ZQAAAAAABAAAAAQAAAAfAAAASW52YWxpZExlbmd0aEludmFsaWRMYXN0U3ltYm9sSW52YWxpZFBhZGRpbmf/////////////////////////////////////////////////////////////////AAECAwQFBgcI/////////wkKCwwNDg8Q/xESExQV/xYXGBkaGxwdHh8g////////ISIjJCUmJygpKiv/LC0uLzAxMjM0NTY3ODn//////zEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpzaWduYXR1cmVfegAAAB4lEAALAAAAbWlzc2luZyBmaWVsZCBgYDQlEAAPAAAAQyUQAAEAAABpbnZhbGlkIGxlbmd0aCAsIGV4cGVjdGVkIAAAVCUQAA8AAABjJRAACwAAAGR1cGxpY2F0ZSBm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cmU6IFZ4V29ya3MgUk5HIG1vZHVsZSBpcyBub3QgaW5pdGlhbGl6ZWROb2RlLmpzIGNyeXB0byBDb21tb25KUyBtb2R1bGUgaXMgdW5hdmFpbGFibGVDYWxsaW5nIE5vZGUuanMgQVBJIGNyeXB0by5yYW5kb21GaWxsU3luYyBmYWlsZWROb2RlLmpzIEVTIG1vZHVsZXMgYXJlIG5vdCBkaXJlY3RseSBzdXBwb3J0ZWQsIHNlZSBodHRwczovL2RvY3MucnMvZ2V0cmFuZG9tI25vZGVqcy1lcy1tb2R1bGUtc3VwcG9ydAAAAAAAAAQAAAAEAAAAZwAAAGludGVybmFsX2NvZGUAAAAAAAAACAAAAAQAAABoAAAAZGVzY3JpcHRpb251bmtub3duX2NvZGUAAAAAAAQAAAAEAAAAaQAAAG9zX2Vycm9yVW5rbm93biBFcnJvcjogAMDMEAAPAAAAT1MgRXJyb3I6IAAA2MwQAAoAAABjcnlwdG8AABHKEAA4yhAAXsoQAHLKEACkyhAA0coQAADLEAAhyxAAPssQAEGgmsMACzFryxAAnMsQAMnLEAD5yxAAJwAAACYAAAAUAAAAMgAAAC0AAAAvAAAAIQAAAB0AAAAtAEHcmsMAC70GMQAAAC0AAAAwAAAAZQAAAKwxEQC4MREAxDERANAxEQByZXR1cm4gdGhpc0xhenkgaW5zdGFuY2UgaGFzIHByZXZpb3VzbHkgYmVlbiBwb2lzb25lZAAAAIfNEAAqAAAAkQ0QAGgAAAAIAwAAGQAAAHJlZW50cmFudCBpbml0AADMzRAADgAAAJENEABoAAAAegIAAA0AAABjbG9zdXJlIGludm9rZWQgcmVjdXJzaXZlbHkgb3IgYWZ0ZXIgYmVpbmcgZHJvcHBlZG51bGwgcG9pbnRlciBwYXNzZWQgdG8gcnVzdHJlY3Vyc2l2ZSB1c2Ugb2YgYW4gb2JqZWN0IGRldGVjdGVkIHdoaWNoIHdvdWxkIGxlYWQgdG8gdW5zYWZlIGFsaWFzaW5nIGluIHJ1c3RMYXp5IGluc3RhbmNlIGhhcyBwcmV2aW91c2x5IGJlZW4gcG9pc29uZWQAAJDOEAAqAAAAkQ0QAGgAAAAIAwAAGQAAAHJlZW50cmFudCBpbml0AADUzhAADgAAAJENEABoAAAAegIAAA0A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ZiByYW5nZWludmFsaWQgdW5pY29kZSBjb2RlIHBvaW50Y29udHJvbCBjaGFyYWN0ZXIgKFx1MDAwMC1cdTAwMUYpIGZvdW5kIHdoaWxlIHBhcnNpbmcgYSBzdHJpbmdrZXkgbXVzdCBiZSBhIHN0cmluZ2ludmFsaWQgdmFsdWU6IGV4cGVjdGVkIGtleSB0byBiZSBhIG51bWJlciBpbiBxdW90ZXNmbG9hdCBrZXkgbXVzdCBiZSBmaW5pdGUgKGdvdCBOYU4gb3IgKy8taW5mKWxvbmUgbGVhZGluZyBzdXJyb2dhdGUgaW4gaGV4IGVzY2FwZXRyYWlsaW5nIGNvbW1hdHJhaWxpbmcgY2hhcmFjdGVyc3VuZXhwZWN0ZWQgZW5kIG9mIGhleCBlc2NhcGVyZWN1cnNpb24gbGltaXQgZXhjZWVkZWQBAAAAAAAAAEjaEAAJAAAAdNoQAAgAAABmbG9hdGluZyBwb2ludCBgYAAAAHTeEAAQAAAAhN4QAAEAAABudWxsJwUQAHsAAAC9BAAAJAAAAIgAAAAMAAAABAAAAIkAAACKAAAAhgAAAP///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////wAAAQACAAMABAAFAAYABwAIAAkA//////////////////8KAAsADAANAA4ADwD/////////////////////////////////////////////////////////////////////CgALAAwADQAOAA8A////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////AAAQACAAMABAAFAAYABwAIAAkAD//////////////////6AAsADAANAA4ADwAP////////////////////////////////////////////////////////////////////+gALAAwADQAOAA8AD///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8ODBAAawAAALMBAAAaAAAADgwQAGsAAAAAAgAAEwAAAA4MEABrAAAABQIAADMAAAAODBAAawAAAAkCAAA+AAAADgwQAGsAAAAPAgAAOgAAAA4MEABrAAAAqwEAAD0AAAAODBAAawAAAKYBAABFAAAADgwQAGsAAABuAgAAGQAAAGluZi1pbmZOYU51dXV1dXV1dWJ0bnVmcnV1dXV1dXV1dXV1dXV1dXV1dQAAIgBBqsfDAAsBXABBzsjDAAvlATAxMjM0NTY3ODlhYmNkZWZhIEpTT04gbnVtYmVyMDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5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ZyBwb2ludCBgcA8RABAAAAA4DxEAAQAAAGNoYXJhY3RlciBgAJAPEQALAAAAOA8RAAEAAABzdHJpbmcgAKwPEQAHAAAAYnl0ZSBhcnJheXVuaXQgdmFsdWVPcHRpb24gdmFsdWVuZXd0eXBlIHN0cnVjdHNlcXVlbmNlbWFwZW51bXVuaXQgdmFyaWFudG5ld3R5cGUgdmFyaWFudHR1cGxlIHZhcmlhbnRzdHJ1Y3QgdmFyaWFudAABAAAAAAAAAC4wAAAAAAAACAAAAAQAAACRAAAAkgAAAJMAAABhIHN0cmluZ3z9izJX5lf5At9Ev+NI569tXcvWLFDrY3hBpldxG4u5AQAAAAAAAABlbnRpdHkgbm90IGZvdW5kcGVybWlzc2lvbiBkZW5pZWRjb25uZWN0aW9uIHJlZnVzZWRjb25uZWN0aW9uIHJlc2V0aG9zdCB1bnJlYWNoYWJsZW5ldHdvcmsgdW5yZWFjaGFibGVjb25uZWN0aW9uIGFib3J0ZWRub3QgY29ubmVjdGVkYWRkcmVzcyBpbiB1c2VhZGRyZXNzIG5vdCBhdmFpbGFibGVuZXR3b3JrIGRvd25icm9rZW4gcGlwZWVudGl0eSBhbHJlYWR5IGV4aXN0c29wZXJhdGlvbiB3b3VsZCBibG9ja25vdCBhIGRpcmVjdG9yeWlzIGEgZGlyZWN0b3J5ZGlyZWN0b3J5IG5vdCBlbXB0eXJlYWQtb25seSBmaWxlc3lzdGVtIG9yIHN0b3JhZ2UgbWVkaXVtZmlsZXN5c3RlbSBsb29wIG9yIGluZGlyZWN0aW9uIGxpbWl0IChlLmcuIHN5bWxpbmsgbG9vcClzdGFsZSBuZXR3b3JrIGZpbGUgaGFuZGxlaW52YWxpZCBpbnB1dCBwYXJhbWV0ZXJpbnZhbGlkIGRhdGF0aW1lZCBvdXR3cml0ZSB6ZXJvbm8gc3RvcmFnZSBzcGFjZXNlZWsgb24gdW5zZWVrYWJsZSBmaWxlcXVvdGEgZXhjZWVkZWRmaWxlIHRvbyBsYXJnZXJlc291cmNlIGJ1c3lleGVjdXRhYmxlIGZpbGUgYnVzeWRlYWRsb2NrY3Jvc3MtZGV2aWNlIGxpbmsgb3IgcmVuYW1ldG9vIG1hbnkgbGlua3NpbnZhbGlkIGZpbGVuYW1lYXJndW1lbnQgbGlz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";
async function initialize() {
  const response = await fetch(data);
  const arrayBuffer = await response.arrayBuffer();
  return await __wbg_init({ module_or_path: arrayBuffer });
}
function base64ToArrayBuffer(base64) {
  if (typeof Buffer !== "undefined") {
    return Buffer.from(base64, "base64").buffer;
  }
  if (typeof globalThis !== "undefined" && typeof globalThis.atob === "function") {
    const binary = globalThis.atob(base64);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
    return bytes.buffer;
  }
  throw new Error("Unable to decode base64 WASM payload: no atob() or Buffer available.");
}
function initializeSync() {
  const base64 = data.split(",")[1];
  const bytes = base64ToArrayBuffer(base64);
  return initSync({ module: bytes });
}
function isCloudflare() {
  if (
    // @ts-ignore
    typeof navigator !== "undefined" && // @ts-ignore
    navigator?.userAgent?.includes("Cloudflare")
  ) {
    return true;
  }
  return false;
}
const isEvalAllowed = () => {
  if (isCloudflare()) {
    return false;
  }
  try {
    const F = Function;
    new F("");
    return true;
  } catch (_) {
    return false;
  }
};
let wasmInit = initialize;
let wasmInitSync = initializeSync;
const wasmCryptoErrorMessage = (e) => `Critical Error: Failed to load WASM module

${!isEvalAllowed() ? `You need to add \`import "jazz-tools/load-edge-wasm";\` on top of your entry module to make Jazz work with ${isCloudflare() ? "Cloudflare workers" : "this runtime"}` : e.message}

A native crypto module is required for Jazz to work. See https://jazz.tools/docs/react/reference/performance#use-the-best-crypto-implementation-for-your-platform for possible alternatives.`;
async function initWasmCrypto() {
  try {
    await wasmInit();
  } catch (e) {
    throw new Error(wasmCryptoErrorMessage(e), { cause: e });
  }
}
class WasmCrypto extends CryptoProvider {
  constructor() {
    super();
  }
  static setInit(value) {
    wasmInit = value;
  }
  static setInitSync(value) {
    wasmInitSync = value;
  }
  static createSync() {
    try {
      wasmInitSync();
    } catch (e) {
      throw new Error(wasmCryptoErrorMessage(e), { cause: e });
    }
    return new WasmCrypto();
  }
  // TODO: Remove this method and use createSync instead, this is not necessary since we can use createSync in the browser and in the worker.
  // @deprecated
  static async create() {
    await initWasmCrypto();
    return new WasmCrypto();
  }
  blake3HashOnce(data2) {
    return blake3HashOnce(data2);
  }
  blake3HashOnceWithContext(data2, { context }) {
    return blake3HashOnceWithContext(data2, context);
  }
  newEd25519SigningKey() {
    return newEd25519SigningKey();
  }
  getSignerID(secret) {
    return getSignerId(textEncoder.encode(secret));
  }
  sign(secret, message) {
    return sign(textEncoder.encode(stableStringify(message)), textEncoder.encode(secret));
  }
  verify(signature, message, id2) {
    const result = verify(textEncoder.encode(signature), textEncoder.encode(stableStringify(message)), textEncoder.encode(id2));
    return result;
  }
  newX25519StaticSecret() {
    return newX25519PrivateKey();
  }
  getSealerID(secret) {
    return getSealerId(textEncoder.encode(secret));
  }
  encrypt(value, keySecret, nOnceMaterial) {
    return `encrypted_U${bytesToBase64url(encrypt(textEncoder.encode(stableStringify(value)), keySecret, textEncoder.encode(stableStringify(nOnceMaterial))))}`;
  }
  decryptRaw(encrypted, keySecret, nOnceMaterial) {
    return textDecoder.decode(decrypt(base64URLtoBytes(encrypted.substring("encrypted_U".length)), keySecret, textEncoder.encode(stableStringify(nOnceMaterial))));
  }
  seal({ message, from, to, nOnceMaterial }) {
    return `sealed_U${bytesToBase64url(seal(textEncoder.encode(stableStringify(message)), from, to, textEncoder.encode(stableStringify(nOnceMaterial))))}`;
  }
  unseal(sealed, sealer, from, nOnceMaterial) {
    const plaintext = textDecoder.decode(unseal(base64URLtoBytes(sealed.substring("sealed_U".length)), sealer, from, textEncoder.encode(stableStringify(nOnceMaterial))));
    try {
      return JSON.parse(plaintext);
    } catch (e) {
      logger.error("Failed to decrypt/parse sealed message", { err: e });
      return void 0;
    }
  }
  createSessionLog(coID, sessionID, signerID) {
    return new SessionLogAdapter(new SessionLog(coID, sessionID, signerID));
  }
}
class SessionLogAdapter {
  constructor(sessionLog) {
    this.sessionLog = sessionLog;
  }
  tryAdd(transactions, newSignature, skipVerify) {
    for (const tx of transactions) {
      if (tx.privacy === "private") {
        this.sessionLog.addExistingPrivateTransaction(tx.encryptedChanges, tx.keyUsed, tx.madeAt, tx.meta);
      } else {
        this.sessionLog.addExistingTrustingTransaction(tx.changes, tx.madeAt, tx.meta);
      }
    }
    this.sessionLog.commitTransactions(newSignature, skipVerify);
  }
  addNewPrivateTransaction(signerAgent, changes, keyID, keySecret, madeAt, meta) {
    const output = this.sessionLog.addNewPrivateTransaction(
      // We can avoid stableStringify because it will be encrypted.
      JSON.stringify(changes),
      signerAgent.currentSignerSecret(),
      keySecret,
      keyID,
      madeAt,
      // We can avoid stableStringify because it will be encrypted.
      meta ? JSON.stringify(meta) : void 0
    );
    const parsedOutput = JSON.parse(output);
    const transaction = {
      privacy: "private",
      madeAt,
      encryptedChanges: parsedOutput.encrypted_changes,
      keyUsed: keyID,
      meta: parsedOutput.meta
    };
    return { signature: parsedOutput.signature, transaction };
  }
  addNewTrustingTransaction(signerAgent, changes, madeAt, meta) {
    const stringifiedChanges = JSON.stringify(changes);
    const stringifiedMeta = meta ? JSON.stringify(meta) : void 0;
    const output = this.sessionLog.addNewTrustingTransaction(stringifiedChanges, signerAgent.currentSignerSecret(), madeAt, stringifiedMeta);
    const transaction = {
      privacy: "trusting",
      madeAt,
      changes: stringifiedChanges,
      meta: stringifiedMeta
    };
    return { signature: output, transaction };
  }
  decryptNextTransactionChangesJson(txIndex, keySecret) {
    const output = this.sessionLog.decryptNextTransactionChangesJson(txIndex, keySecret);
    return output;
  }
  decryptNextTransactionMetaJson(txIndex, keySecret) {
    return this.sessionLog.decryptNextTransactionMetaJson(txIndex, keySecret);
  }
  free() {
    this.sessionLog.free();
  }
  clone() {
    return new SessionLogAdapter(this.sessionLog.clone());
  }
}
async function schemaMigration(account, node, creationProps) {
  const accountName = creationProps?.name || "maia";
  let profileId = account.get("profile");
  let profile;
  let universalGroup;
  if (profileId) {
    const loadedProfile = node.getCoValue(profileId);
    if (loadedProfile && loadedProfile.type === "comap") {
      const profileContent = node.getCoValue(profileId)?.getCurrentContent?.();
      if (profileContent && typeof profileContent.get === "function") {
        profile = profileContent;
        console.log("     Profile already exists:", profileId);
        const existingGroupId = profile.get("group");
        if (existingGroupId) {
          const loadedGroup = node.getCoValue(existingGroupId);
          if (loadedGroup && loadedGroup.type === "group") {
            const groupContent = loadedGroup.getCurrentContent?.();
            if (groupContent && typeof groupContent.createMap === "function") {
              universalGroup = groupContent;
              console.log("     Universal group already exists (from profile):", existingGroupId);
            }
          }
        }
      }
    }
  }
  if (!universalGroup) {
    universalGroup = node.createGroup();
  }
  if (!profile) {
    profile = account.createMap({
      name: accountName,
      group: universalGroup.id
      // Reference to universal group (single source of truth)
    }, { $schema: "ProfileSchema" });
    account.set("profile", profile.id);
  } else {
    if (!profile.get("group")) {
      profile.set("group", universalGroup.id);
    }
  }
}
const $defs$6 = { "comap": { "description": "CoMap - CRDT-based collaborative map/object", "type": "object", "properties": {}, "additionalProperties": { "anyOf": [{ "type": "string", "description": "Standard string value" }, { "type": "number", "description": "Standard number value" }, { "type": "integer", "description": "Standard integer value" }, { "type": "boolean", "description": "Standard boolean value" }, { "type": "null", "description": "Null value" }, { "type": "object", "description": "Nested object value" }, { "type": "array", "description": "Array value" }, { "type": "string", "pattern": "^co_z[a-zA-Z0-9]+$", "description": "Co-id reference to another CoValue" }, { "type": "string", "pattern": "^key_[a-zA-Z0-9_]+$", "description": "Key reference" }, { "type": "string", "pattern": "^sealed_", "description": "Sealed/encrypted value" }] } }, "costream": { "description": "CoStream - CRDT-based append-only stream", "type": "array", "items": { "anyOf": [{ "type": "object", "description": "Stream item object" }, { "type": "string", "description": "Stream item string" }, { "type": "number", "description": "Stream item number" }, { "type": "boolean", "description": "Stream item boolean" }, { "type": "null", "description": "Stream item null" }] } }, "colist": { "description": "CoList - CRDT-based collaborative list/array", "type": "array", "items": { "anyOf": [{ "type": "object", "description": "List item object" }, { "type": "string", "description": "List item string (can be co-id reference)" }, { "type": "number", "description": "List item number" }, { "type": "integer", "description": "List item integer" }, { "type": "boolean", "description": "List item boolean" }, { "type": "null", "description": "List item null" }, { "type": "array", "description": "Nested array" }] } } };
const coTypesDefs = {
  $defs: $defs$6
};
const coTypes_defs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  $defs: $defs$6,
  default: coTypesDefs
}, Symbol.toStringTag, { value: "Module" }));
class ReactiveStore {
  constructor(initialValue) {
    this._value = initialValue;
    this._subscribers = /* @__PURE__ */ new Set();
    this._unsubscribe = null;
  }
  /**
   * Get current value
   * @returns {any} Current store value
   */
  get value() {
    return this._value;
  }
  /**
   * Subscribe to value changes
   * Callback is called immediately with current value, then on every update
   * Automatically calls _unsubscribe() when the last subscriber unsubscribes
   * @param {Function} callback - Function called with new value
   * @param {Object} [options] - Subscription options
   * @param {boolean} [options.skipInitial=false] - If true, don't call callback immediately with current value
   * @returns {Function} Unsubscribe function
   */
  subscribe(callback, options = {}) {
    this._subscribers.add(callback);
    if (!options.skipInitial) {
      callback(this._value);
    }
    return () => {
      this._subscribers.delete(callback);
      if (this._subscribers.size === 0 && this._unsubscribe) {
        this._unsubscribe();
      }
    };
  }
  /**
   * Internal method to update store value
   * Notifies all subscribers of the change
   * @param {any} newValue - New value to set
   * @private
   */
  _set(newValue) {
    this._value = newValue;
    this._subscribers.forEach((cb) => cb(newValue));
  }
}
async function resolveSchemaCoId(backend, schema) {
  if (!schema || typeof schema !== "string") {
    return null;
  }
  return await resolve$1(backend, schema, { returnType: "coId" });
}
async function getSchemaIndexColistId(backend, schema) {
  const schemaCoId = await resolveSchemaCoId(backend, schema);
  if (!schemaCoId) {
    return null;
  }
  const osId = backend.account.get("os");
  if (!osId) {
    return null;
  }
  const osCore = await ensureCoValueLoaded(backend, osId);
  if (!osCore || !backend.isAvailable(osCore)) {
    return null;
  }
  const osContent = backend.getCurrentContent(osCore);
  if (!osContent || typeof osContent.get !== "function") {
    return null;
  }
  const indexColistId = osContent.get(schemaCoId);
  if (indexColistId && typeof indexColistId === "string" && indexColistId.startsWith("co_")) {
    return indexColistId;
  }
  return null;
}
async function getCoListId(backend, collectionNameOrSchema) {
  if (collectionNameOrSchema && typeof collectionNameOrSchema === "string" && (collectionNameOrSchema.startsWith("co_z") || collectionNameOrSchema.startsWith("@schema/"))) {
    return await getSchemaIndexColistId(backend, collectionNameOrSchema);
  }
  const osId = backend.account.get("os");
  if (!osId) {
    return null;
  }
  const osCore = await ensureCoValueLoaded(backend, osId);
  if (!osCore || !backend.isAvailable(osCore)) {
    return null;
  }
  const osContent = backend.getCurrentContent(osCore);
  if (!osContent || typeof osContent.get !== "function") {
    return null;
  }
  const collectionListId = osContent.get(collectionNameOrSchema);
  if (collectionListId && typeof collectionListId === "string" && collectionListId.startsWith("co_")) {
    return collectionListId;
  }
  return null;
}
async function ensureCoValueLoaded(backend, coId, options = {}) {
  const { waitForAvailable = false, timeoutMs = 2e3 } = options;
  if (!coId || !coId.startsWith("co_")) {
    return null;
  }
  const coValueCore = backend.getCoValue(coId);
  if (!coValueCore) {
    return null;
  }
  if (coValueCore.isAvailable()) {
    return coValueCore;
  }
  backend.node.loadCoValueCore(coId).catch((err) => {
    console.error(`[CoJSONBackend] Failed to load CoValue ${coId}:`, err);
  });
  if (waitForAvailable) {
    await new Promise((resolve2, reject) => {
      let unsubscribe;
      const timeout = setTimeout(() => {
        console.warn(`[CoJSONBackend] Timeout waiting for CoValue ${coId} to load`);
        unsubscribe();
        reject(new Error(`Timeout waiting for CoValue ${coId} to load after ${timeoutMs}ms`));
      }, timeoutMs);
      unsubscribe = coValueCore.subscribe((core2) => {
        if (core2.isAvailable()) {
          clearTimeout(timeout);
          unsubscribe();
          resolve2();
        }
      });
    });
  }
  return coValueCore;
}
function extractCoValueData(backend, coValueCore, schemaHint = null) {
  const content = backend.getCurrentContent(coValueCore);
  const header = backend.getHeader(coValueCore);
  const headerMeta = header?.meta || null;
  const ruleset = coValueCore.ruleset || header?.ruleset;
  const rawType = content?.type || "unknown";
  let schema = headerMeta?.$schema || null;
  if (schemaHint === "@group" || ruleset && ruleset.type === "group") {
    schema = "@group";
  } else if (schemaHint === "@account" || headerMeta && headerMeta.type === "account") {
    schema = "@account";
  } else if (schemaHint === "@meta-schema" || schema === "GenesisSchema") {
    schema = "@meta-schema";
  }
  if (rawType === "colist" && content && content.toJSON) {
    try {
      const items2 = content.toJSON();
      return {
        id: coValueCore.id,
        $schema: schema,
        // Use $schema for consistency with headerMeta.$schema
        type: "colist",
        items: items2
        // Items ARE the CoList content (not a property)
        // No properties array - CoLists don't have custom key-value properties, only items
      };
    } catch (e) {
      return {
        id: coValueCore.id,
        $schema: schema,
        // Use $schema for consistency with headerMeta.$schema
        type: "colist",
        items: []
      };
    }
  } else if (rawType === "costream" && content) {
    try {
      const streamData = content.toJSON();
      const items2 = [];
      if (streamData && typeof streamData === "object" && !(streamData instanceof Uint8Array)) {
        for (const sessionKey in streamData) {
          if (Array.isArray(streamData[sessionKey])) {
            items2.push(...streamData[sessionKey]);
          }
        }
      }
      console.log(`[CoJSONBackend]  Read CoStream ${coValueCore.id} (${items2.length} items)`);
      if (items2.length > 0) {
        console.log(`[CoJSONBackend]   First item:`, JSON.stringify(items2[0]).substring(0, 100));
      } else {
        console.log(`[CoJSONBackend]   Stream data type:`, typeof streamData, streamData instanceof Uint8Array ? "Uint8Array" : "object");
        if (streamData && typeof streamData === "object" && !(streamData instanceof Uint8Array)) {
          console.log(`[CoJSONBackend]   Session keys:`, Object.keys(streamData));
          console.log(`[CoJSONBackend]   Session counts:`, Object.fromEntries(Object.entries(streamData).map(([k, v]) => [k, Array.isArray(v) ? v.length : "not array"])));
        }
      }
      return {
        id: coValueCore.id,
        schema,
        type: "costream",
        items: items2
        // Items ARE the CoStream content (not a property)
        // No properties array - CoStreams don't have custom key-value properties, only items
      };
    } catch (e) {
      console.error(`[CoJSONBackend]  Error reading CoStream ${coValueCore.id.substring(0, 12)}...:`, e);
      return {
        id: coValueCore.id,
        $schema: schema,
        // Use $schema for consistency with headerMeta.$schema
        type: "costream",
        items: []
      };
    }
  } else if (content && content.get && typeof content.get === "function") {
    const accountType = headerMeta?.type || null;
    const normalized = {
      id: coValueCore.id,
      // Always add id field (derived from co-id)
      $schema: schema,
      // Use $schema for consistency with headerMeta.$schema
      type: rawType,
      // Add type for DB viewer
      displayName: accountType === "account" ? "Account" : schema || "CoMap",
      // Display name for DB viewer
      properties: []
      // Properties array for DB viewer
    };
    if (accountType) {
      normalized.headerMeta = { type: accountType };
    }
    const keys = content.keys && typeof content.keys === "function" ? content.keys() : Object.keys(content);
    for (const key of keys) {
      try {
        const value = content.get && typeof content.get === "function" ? content.get(key) : content[key];
        let type2 = typeof value;
        let displayValue = value;
        if (typeof value === "string" && value.startsWith("co_")) {
          type2 = "co-id";
        } else if (typeof value === "string" && value.startsWith("key_")) {
          type2 = "key";
        } else if (typeof value === "string" && value.startsWith("sealed_")) {
          type2 = "sealed";
          displayValue = "sealed_***";
        } else if (value === null) {
          type2 = "null";
        } else if (value === void 0) {
          type2 = "undefined";
        } else if (typeof value === "object" && value !== null) {
          type2 = "object";
          displayValue = JSON.stringify(value);
        } else if (Array.isArray(value)) {
          type2 = "array";
          displayValue = JSON.stringify(value);
        }
        normalized.properties.push({
          key,
          value: displayValue,
          type: type2
        });
      } catch (e) {
        normalized.properties.push({
          key,
          value: `<error: ${e.message}>`,
          type: "error"
        });
      }
    }
    return normalized;
  }
  return {
    id: coValueCore.id,
    type: rawType,
    $schema: schema,
    headerMeta
  };
}
function parseNestedJsonStrings(data2) {
  if (typeof data2 === "string" && (data2.startsWith("{") || data2.startsWith("["))) {
    try {
      const parsed = JSON.parse(data2);
      return parseNestedJsonStrings(parsed);
    } catch (e) {
      return data2;
    }
  } else if (Array.isArray(data2)) {
    return data2.map((item) => parseNestedJsonStrings(item));
  } else if (typeof data2 === "object" && data2 !== null) {
    const result = {};
    for (const [key, val] of Object.entries(data2)) {
      result[key] = parseNestedJsonStrings(val);
    }
    return result;
  }
  return data2;
}
function extractCoValueDataFlat(backend, coValueCore, schemaHint = null) {
  const header = backend.getHeader(coValueCore);
  const headerMeta = header?.meta || null;
  coValueCore.ruleset || header?.ruleset;
  const isAccount = schemaHint === "@account" || headerMeta && headerMeta.type === "account" || backend.account && backend.account.id === coValueCore.id;
  if (isAccount && backend.account && backend.account.id === coValueCore.id) {
    const header2 = backend.getHeader(coValueCore);
    const headerMeta2 = header2?.meta || null;
    const schema2 = headerMeta2?.$schema || null;
    const result = {
      id: backend.account.id,
      type: "comap",
      // Accounts are CoMaps
      $schema: schema2
      // Include $schema for metadata lookup
    };
    try {
      const keys = backend.account.keys && typeof backend.account.keys === "function" ? backend.account.keys() : Object.keys(backend.account);
      for (const key of keys) {
        try {
          result[key] = backend.account.get(key);
        } catch (e) {
          console.warn(`[CoJSONBackend] Failed to read account key ${key}:`, e);
        }
      }
    } catch (e) {
      console.warn(`[CoJSONBackend] Failed to extract account keys:`, e);
    }
    return result;
  }
  const content = backend.getCurrentContent(coValueCore);
  if (!content) {
    if (isAccount && backend.account && backend.account.id === coValueCore.id) {
      const header3 = backend.getHeader(coValueCore);
      const headerMeta3 = header3?.meta || null;
      const schema3 = headerMeta3?.$schema || null;
      const result = {
        id: backend.account.id,
        type: "comap",
        $schema: schema3
      };
      try {
        const keys = backend.account.keys && typeof backend.account.keys === "function" ? backend.account.keys() : Object.keys(backend.account);
        for (const key of keys) {
          result[key] = backend.account.get(key);
        }
      } catch (e) {
      }
      return result;
    }
    const header2 = backend.getHeader(coValueCore);
    const headerMeta2 = header2?.meta || null;
    const schema2 = headerMeta2?.$schema || null;
    return {
      id: coValueCore.id,
      type: "unknown",
      $schema: schema2
    };
  }
  const rawType = content?.type || "unknown";
  const schema = headerMeta?.$schema || null;
  if (rawType === "colist" && content && content.toJSON) {
    try {
      const items2 = content.toJSON();
      return {
        id: coValueCore.id,
        type: "colist",
        $schema: schema,
        items: items2
      };
    } catch (e) {
      return {
        id: coValueCore.id,
        type: "colist",
        $schema: schema,
        items: []
      };
    }
  }
  if (rawType === "costream" && content) {
    try {
      const streamData = content.toJSON();
      const items2 = [];
      if (streamData && typeof streamData === "object" && !(streamData instanceof Uint8Array)) {
        for (const sessionKey in streamData) {
          if (Array.isArray(streamData[sessionKey])) {
            items2.push(...streamData[sessionKey]);
          }
        }
      }
      return {
        id: coValueCore.id,
        type: "costream",
        $schema: schema,
        items: items2
      };
    } catch (e) {
      console.error(`[CoJSONBackend] Error extracting CoStream ${coValueCore.id.substring(0, 12)}...:`, e);
      return {
        id: coValueCore.id,
        type: "costream",
        $schema: schema,
        items: []
      };
    }
  }
  if (content && content.get && typeof content.get === "function") {
    const hasCotype = content.get("cotype");
    const hasTitle = content.get("title");
    const hasProperties = content.get("properties");
    const hasItems = content.get("items");
    const isSchema = schema === "GenesisSchema" || (hasCotype || hasTitle || hasProperties || hasItems);
    const result = {
      // Only include 'id' and 'type' for non-schema co-values
      // Schemas are content-addressable by co-ID and use 'cotype', not 'type'
      ...isSchema ? {} : {
        id: coValueCore.id,
        type: rawType === "comap" ? "comap" : rawType
      },
      $schema: schema
      // Include $schema for metadata lookup
    };
    const keys = content.keys && typeof content.keys === "function" ? content.keys() : Object.keys(content);
    for (const key of keys) {
      let value = content.get(key);
      if (key === "allMessages" || schema && schema.includes("context")) {
        console.log(`[extractCoValueDataFlat]  Raw value for key "${key}":`, {
          type: typeof value,
          isString: typeof value === "string",
          isObject: typeof value === "object" && value !== null,
          startsWithBrace: typeof value === "string" && value.startsWith("{"),
          valueSample: typeof value === "string" ? value.substring(0, 200) : typeof value === "object" ? JSON.stringify(value).substring(0, 200) : value,
          hasOptions: typeof value === "object" && value !== null ? "options" in value : false,
          optionsType: typeof value === "object" && value !== null && "options" in value ? typeof value.options : "N/A"
        });
      }
      const skipJsonParsingFields = ["error", "message", "content"];
      if (typeof value === "string" && (value.startsWith("{") || value.startsWith("[")) && !skipJsonParsingFields.includes(key)) {
        try {
          const parsed = JSON.parse(value);
          console.log(`[extractCoValueDataFlat]  Parsed JSON string for "${key}":`, {
            parsedType: typeof parsed,
            parsedKeys: typeof parsed === "object" && parsed !== null ? Object.keys(parsed) : [],
            hasOptions: typeof parsed === "object" && parsed !== null ? "options" in parsed : false,
            optionsType: typeof parsed === "object" && parsed !== null && "options" in parsed ? typeof parsed.options : "N/A",
            parsedSample: JSON.stringify(parsed).substring(0, 300)
          });
          value = parseNestedJsonStrings(parsed);
          console.log(`[extractCoValueDataFlat]  After recursive parse for "${key}":`, {
            finalType: typeof value,
            finalKeys: typeof value === "object" && value !== null ? Object.keys(value) : [],
            hasOptions: typeof value === "object" && value !== null ? "options" in value : false,
            optionsKeys: typeof value === "object" && value !== null && "options" in value && typeof value.options === "object" ? Object.keys(value.options) : [],
            hasMap: typeof value === "object" && value !== null && "options" in value && typeof value.options === "object" ? "map" in value.options : false,
            finalSample: JSON.stringify(value).substring(0, 400)
          });
        } catch (e) {
          console.warn(`[extractCoValueDataFlat] Failed to parse JSON string for "${key}":`, e);
        }
      } else if (typeof value === "object" && value !== null && !Array.isArray(value)) {
        if (key === "allMessages" || schema && schema.includes("context")) {
          const hasOptionsBefore = "options" in value;
          const optionsTypeBefore = hasOptionsBefore ? typeof value.options : "N/A";
          const optionsIsString = hasOptionsBefore && typeof value.options === "string" && (value.options.startsWith("{") || value.options.startsWith("["));
          console.log(`[extractCoValueDataFlat]  Before recursive parse for "${key}":`, {
            hasOptions: hasOptionsBefore,
            optionsType: optionsTypeBefore,
            optionsIsString,
            optionsValue: hasOptionsBefore ? typeof value.options === "string" ? value.options.substring(0, 200) : JSON.stringify(value.options).substring(0, 200) : "N/A",
            allKeys: Object.keys(value)
          });
        }
        const beforeParse = JSON.stringify(value).substring(0, 200);
        value = parseNestedJsonStrings(value);
        const afterParse = JSON.stringify(value).substring(0, 200);
        if (key === "allMessages" || schema && schema.includes("context")) {
          const hasOptionsAfter = "options" in value;
          const optionsTypeAfter = hasOptionsAfter ? typeof value.options : "N/A";
          const hasMap = hasOptionsAfter && typeof value.options === "object" && value.options !== null ? "map" in value.options : false;
          console.log(`[extractCoValueDataFlat]  After recursive parse for "${key}":`, {
            hasOptions: hasOptionsAfter,
            optionsType: optionsTypeAfter,
            hasMap,
            optionsKeys: hasOptionsAfter && typeof value.options === "object" && value.options !== null ? Object.keys(value.options) : [],
            mapKeys: hasMap ? Object.keys(value.options.map) : [],
            changed: beforeParse !== afterParse,
            finalSample: JSON.stringify(value).substring(0, 400)
          });
        }
      }
      result[key] = value;
    }
    return result;
  }
  return {
    id: coValueCore.id,
    type: rawType,
    $schema: schema
  };
}
async function resolveCoValueReferences(backend, data2, options = {}, visited = /* @__PURE__ */ new Set(), maxDepth = 10, currentDepth = 0) {
  const { fields = null, schemas = null, timeoutMs = 2e3 } = options;
  if (currentDepth > maxDepth) {
    return data2;
  }
  if (data2 === null || data2 === void 0) {
    return data2;
  }
  if (typeof data2 !== "object") {
    if (typeof data2 === "string" && data2.startsWith("co_z")) {
      const resolved = await resolveCoId(backend, data2, options, visited, maxDepth, currentDepth);
      return resolved;
    }
    return data2;
  }
  if (Array.isArray(data2)) {
    return Promise.all(data2.map(
      (item) => resolveCoValueReferences(backend, item, options, visited, maxDepth, currentDepth + 1)
    ));
  }
  const result = {};
  for (const [key, value] of Object.entries(data2)) {
    if (key === "id" || key === "$schema" || key === "type" || key === "loading" || key === "error") {
      result[key] = value;
      continue;
    }
    const shouldResolve = fields === null || fields.includes(key);
    if (value === null || value === void 0) {
      result[key] = value;
      continue;
    }
    if (shouldResolve && typeof value === "string" && value.startsWith("co_z")) {
      const resolved = await resolveCoId(backend, value, { ...options, timeoutMs, maxDepth, currentDepth }, visited, maxDepth, currentDepth + 1);
      result[key] = resolved;
    } else {
      result[key] = await resolveCoValueReferences(backend, value, options, visited, maxDepth, currentDepth + 1);
    }
  }
  return result;
}
async function resolveCoId(backend, coId, options = {}, visited = /* @__PURE__ */ new Set(), maxDepth = 10, currentDepth = 0) {
  const { schemas = null, timeoutMs = 2e3 } = options;
  if (visited.has(coId)) {
    return { id: coId };
  }
  const cache = backend.subscriptionCache;
  const cacheOptions = {
    deepResolve: false,
    // We don't need deep resolution here
    resolveReferences: options,
    // Use the same resolution options
    map: null,
    // No map transform in resolveCoId
    maxDepth,
    timeoutMs
  };
  const cachedResolved = cache.getResolvedData(coId, cacheOptions);
  if (cachedResolved) {
    if (schemas !== null && schemas.length > 0) {
      const dataSchema = cachedResolved.$schema;
      if (!schemas.includes(dataSchema)) {
        return { id: coId };
      }
    }
    return cachedResolved;
  }
  try {
    const { waitForStoreReady: waitForStoreReady2 } = await Promise.resolve().then(() => readOperations);
    const coValueStore = await backend.read(null, coId, null, null, {
      deepResolve: false,
      // Don't deep resolve here - we'll resolve nested refs ourselves
      timeoutMs
    });
    if (!coValueStore) {
      console.warn(`[resolveCoId] No store returned for ${coId.substring(0, 12)}...`);
      return { id: coId };
    }
    try {
      await waitForStoreReady2(coValueStore, coId, timeoutMs);
    } catch (err) {
      console.warn(`[resolveCoId] Store not ready for ${coId.substring(0, 12)}...:`, err.message);
      return { id: coId };
    }
    const coValueData = coValueStore.value;
    if (!coValueData) {
      console.warn(`[resolveCoId] No data in store for ${coId.substring(0, 12)}...`);
      return { id: coId };
    }
    if (coValueData.error) {
      console.warn(`[resolveCoId] Store has error for ${coId.substring(0, 12)}...:`, coValueData.error);
      return { id: coId, error: coValueData.error };
    }
    if (typeof coValueData !== "object" || Array.isArray(coValueData)) {
      console.warn(`[resolveCoId] Invalid data type for ${coId.substring(0, 12)}...:`, typeof coValueData);
      return { id: coId };
    }
    if (schemas !== null && schemas.length > 0) {
      const dataSchema = coValueData.$schema;
      if (!schemas.includes(dataSchema)) {
        return { id: coId };
      }
    }
    visited.add(coId);
    const resolved = await resolveCoValueReferences(
      backend,
      coValueData,
      options,
      visited,
      maxDepth,
      currentDepth + 1
    );
    const finalResolved = {
      ...resolved,
      id: resolved.id || coValueData.id || coId
    };
    cache.setResolvedData(coId, cacheOptions, finalResolved);
    return finalResolved;
  } catch (err) {
    console.error(`[resolveCoId]  Error resolving ${coId.substring(0, 12)}...:`, err);
    return { id: coId };
  }
}
function extractCoStreamWithSessions(backend, coValueCore) {
  const content = backend.getCurrentContent(coValueCore);
  const header = backend.getHeader(coValueCore);
  const headerMeta = header?.meta || null;
  const rawType = content?.type || "unknown";
  if (rawType !== "costream" || !content) {
    return null;
  }
  if (content.items && typeof content.items === "object") {
    const sessions = {};
    for (const [sessionID, items2] of Object.entries(content.items)) {
      if (Array.isArray(items2)) {
        sessions[sessionID] = items2.map((item) => {
          const isCoIdReference = typeof item.value === "string" && item.value.startsWith("co_z");
          if (isCoIdReference) {
            return {
              _coId: item.value,
              // Message CoMap co-id (native co-id)
              _sessionID: sessionID,
              // Internal metadata: session ID
              _madeAt: item.madeAt,
              // Internal metadata: CRDT madeAt timestamp
              _tx: item.tx
              // Internal metadata: transaction ID
            };
          } else {
            return {
              ...item.value,
              // Message data (type, payload, from, id)
              _sessionID: sessionID,
              // Internal metadata: session ID
              _madeAt: item.madeAt,
              // Internal metadata: CRDT madeAt timestamp
              _tx: item.tx
              // Internal metadata: transaction ID
            };
          }
        });
      }
    }
    return {
      id: coValueCore.id,
      type: "costream",
      $schema: headerMeta?.$schema || null,
      sessions
      // Preserve session structure: { sessionID: [messages...] }
    };
  }
  return {
    id: coValueCore.id,
    type: "costream",
    $schema: headerMeta?.$schema || null,
    sessions: {}
  };
}
function extractCoValueDataFromContent(content) {
  if (!content) return null;
  const rawType = content.type || "unknown";
  const properties2 = {};
  if (content.get && typeof content.get === "function") {
    const keys = content.keys && typeof content.keys === "function" ? content.keys() : Object.keys(content);
    for (const key of keys) {
      properties2[key] = content.get(key);
    }
  } else {
    const keys = Object.keys(content);
    for (const key of keys) {
      properties2[key] = content[key];
    }
  }
  let items2 = null;
  if (rawType === "colist" && content.toJSON) {
    try {
      items2 = content.toJSON();
    } catch (e) {
    }
  }
  return {
    id: content.id,
    type: rawType,
    properties: properties2,
    items: items2,
    content
  };
}
function matchesFilter(data2, filter) {
  if (Array.isArray(data2)) {
    return data2.some((item) => {
      for (const [key, value] of Object.entries(filter)) {
        if (item[key] !== value) {
          return false;
        }
      }
      return true;
    });
  }
  if (data2 && typeof data2 === "object") {
    for (const [key, value] of Object.entries(filter)) {
      if (data2[key] !== value) {
        return false;
      }
    }
    return true;
  }
  return false;
}
class CoCache {
  /**
   * Create a new unified cache
   * 
   * @param {number} cleanupTimeout - Time in ms before cleaning up unused entries (default: 5000)
   */
  constructor(cleanupTimeout = 5e3) {
    this.cache = /* @__PURE__ */ new Map();
    this.cleanupTimeout = cleanupTimeout;
    this.cleanupTimers = /* @__PURE__ */ new Map();
  }
  /**
   * Get existing entry or create new one (unified getOrCreate for all types)
   * 
   * @param {string} key - Cache key (MUST be namespaced: `subscription:${id}`, `store:${key}`, etc.)
   * @param {Function} factory - Function that creates new entry
   * @returns {any} Cached or newly created entry
   */
  getOrCreate(key, factory) {
    const existing = this.cache.get(key);
    if (existing) {
      this.cancelCleanup(key);
      return existing;
    }
    const entry = factory();
    this.cache.set(key, entry);
    return entry;
  }
  /**
   * Get existing subscription or create new one (backward compatibility)
   * 
   * @param {string} id - CoValue ID
   * @param {Function} factory - Function that creates new subscription
   * @returns {Object} Subscription object
   */
  getOrCreateSubscription(id2, factory) {
    return this.getOrCreate(`subscription:${id2}`, factory);
  }
  /**
   * Get existing store or create new one
   * 
   * @param {string} key - Store cache key (schema+filter+options)
   * @param {Function} factory - Function that creates new ReactiveStore
   * @returns {ReactiveStore} ReactiveStore instance
   */
  getOrCreateStore(key, factory) {
    return this.getOrCreate(`store:${key}`, factory);
  }
  /**
   * Get existing resolution promise or create new one
   * 
   * @param {string} coId - CoValue ID
   * @param {Function} factory - Function that creates resolution Promise
   * @returns {Promise|true} Resolution promise or true if already resolved
   */
  getOrCreateResolution(coId, factory) {
    const key = `resolution:${coId}`;
    const existing = this.cache.get(key);
    if (existing === true) {
      return true;
    }
    if (existing && typeof existing.then === "function") {
      return existing;
    }
    const promise = factory();
    this.cache.set(key, promise);
    return promise;
  }
  /**
   * Mark resolution as completed
   * 
   * @param {string} coId - CoValue ID
   */
  markResolved(coId) {
    this.cache.set(`resolution:${coId}`, true);
  }
  /**
   * Check if CoValue is already resolved or being resolved
   * 
   * @param {string} coId - CoValue ID
   * @returns {boolean} True if already resolved or being resolved
   */
  isResolved(coId) {
    const cached = this.cache.get(`resolution:${coId}`);
    return cached === true || cached && typeof cached.then === "function";
  }
  /**
   * Get cached resolved+mapped data
   * 
   * @param {string} coId - CoValue ID
   * @param {Object} options - Options object (for cache key)
   * @returns {any|null} Cached resolved data or null
   */
  getResolvedData(coId, options) {
    const key = `resolved:${coId}:${JSON.stringify(options || {})}`;
    const cached = this.cache.get(key);
    if (cached && typeof cached.then === "function") {
      return null;
    }
    return cached || null;
  }
  /**
   * Get or create resolved data (prevents concurrent processing)
   * 
   * @param {string} coId - CoValue ID
   * @param {Object} options - Options object (for cache key)
   * @param {Function} factory - Async function that creates/resolves the data
   * @returns {Promise<any>} Resolved data (from cache or factory)
   */
  async getOrCreateResolvedData(coId, options, factory) {
    const key = `resolved:${coId}:${JSON.stringify(options || {})}`;
    let existing = this.cache.get(key);
    if (existing && typeof existing.then !== "function") {
      return existing;
    }
    if (existing && typeof existing.then === "function") {
      try {
        return await existing;
      } catch (err) {
        this.cache.delete(key);
      }
    }
    const promise = (async () => {
      try {
        const data2 = await factory();
        this.cache.set(key, data2);
        return data2;
      } catch (err) {
        this.cache.delete(key);
        throw err;
      }
    })();
    this.cache.set(key, promise);
    return promise;
  }
  /**
   * Cache resolved+mapped data
   * 
   * @param {string} coId - CoValue ID
   * @param {Object} options - Options object (for cache key)
   * @param {any} data - Resolved+mapped data to cache
   */
  setResolvedData(coId, options, data2) {
    const key = `resolved:${coId}:${JSON.stringify(options || {})}`;
    this.cache.set(key, data2);
  }
  /**
   * Invalidate all cached resolved data for a CoValue
   * Used when CoValue changes to force re-processing
   * 
   * @param {string} coId - CoValue ID
   */
  invalidateResolvedData(coId) {
    const prefix = `resolved:${coId}:`;
    const keysToDelete = [];
    for (const key of this.cache.keys()) {
      if (key.startsWith(prefix)) {
        keysToDelete.push(key);
      }
    }
    for (const key of keysToDelete) {
      this.cache.delete(key);
    }
  }
  /**
   * Schedule cleanup for unused entry
   * 
   * @param {string} key - Cache key (MUST be namespaced)
   */
  scheduleCleanup(key) {
    this.cancelCleanup(key);
    const timerId = setTimeout(() => {
      this.destroy(key);
    }, this.cleanupTimeout);
    this.cleanupTimers.set(key, timerId);
  }
  /**
   * Cancel scheduled cleanup
   * 
   * @param {string} key - Cache key (MUST be namespaced)
   */
  cancelCleanup(key) {
    const timerId = this.cleanupTimers.get(key);
    if (timerId) {
      clearTimeout(timerId);
      this.cleanupTimers.delete(key);
    }
  }
  /**
   * Manually destroy entry and remove from cache
   * 
   * @param {string} key - Cache key (MUST be namespaced)
   */
  destroy(key) {
    const entry = this.cache.get(key);
    if (!entry) {
      return;
    }
    if (entry && typeof entry === "object") {
      if (entry.unsubscribe && typeof entry.unsubscribe === "function") {
        try {
          entry.unsubscribe();
        } catch (error) {
        }
      }
      if (entry._unsubscribe && typeof entry._unsubscribe === "function") {
        try {
          entry._unsubscribe();
        } catch (error) {
        }
      }
    }
    this.cache.delete(key);
    this.cancelCleanup(key);
  }
  /**
   * Check if entry exists in cache
   * 
   * @param {string} key - Cache key (MUST be namespaced)
   * @returns {boolean}
   */
  has(key) {
    return this.cache.has(key);
  }
  /**
   * Get entry from cache without creating
   * 
   * @param {string} key - Cache key (MUST be namespaced)
   * @returns {any|null} Entry or null
   */
  get(key) {
    return this.cache.get(key) || null;
  }
  /**
   * Get cache size (number of active entries)
   * 
   * @returns {number}
   */
  get size() {
    return this.cache.size;
  }
  /**
   * Clear all entries and timers
   * 
   * Useful for cleanup on app shutdown or context switch
   * CRITICAL: Properly unsubscribes from all entries before clearing
   */
  clear() {
    const keys = Array.from(this.cache.keys());
    for (const key of keys) {
      this.destroy(key);
    }
    this.cache.clear();
    this.cleanupTimers.clear();
  }
}
let globalCache = null;
let currentNode = null;
function getGlobalCoCache(node, cleanupTimeout) {
  if (typeof node === "number") {
    cleanupTimeout = node;
    node = null;
  }
  if (node && currentNode !== node) {
    if (globalCache) {
      globalCache.clear();
    }
    currentNode = node;
    globalCache = new CoCache(cleanupTimeout);
  } else if (!globalCache) {
    if (node) {
      currentNode = node;
    }
    globalCache = new CoCache(cleanupTimeout);
  }
  return globalCache;
}
function extractCoValueIds(data2, visited = /* @__PURE__ */ new Set(), depth = 0, maxDepth = 10) {
  const coIds = /* @__PURE__ */ new Set();
  if (depth > maxDepth) {
    return coIds;
  }
  if (!data2 || typeof data2 !== "object") {
    return coIds;
  }
  if (Array.isArray(data2)) {
    for (const item of data2) {
      const itemIds = extractCoValueIds(item, visited, depth + 1, maxDepth);
      itemIds.forEach((id2) => {
        if (!visited.has(id2)) {
          coIds.add(id2);
        }
      });
    }
    return coIds;
  }
  for (const [key, value] of Object.entries(data2)) {
    if (key === "id" || key === "$schema" || key === "type" || key === "loading" || key === "error") {
      continue;
    }
    if (typeof value === "string" && value.startsWith("co_")) {
      if (!visited.has(value)) {
        coIds.add(value);
      }
    } else if (typeof value === "object" && value !== null) {
      const nestedIds = extractCoValueIds(value, visited, depth + 1, maxDepth);
      nestedIds.forEach((id2) => {
        if (!visited.has(id2)) {
          coIds.add(id2);
        }
      });
    }
  }
  return coIds;
}
async function waitForCoValueAvailable(backend, coId, timeoutMs = 5e3) {
  const coValueCore = backend.getCoValue(coId);
  if (!coValueCore) {
    throw new Error(`CoValue ${coId} not found`);
  }
  if (backend.isAvailable(coValueCore)) {
    return;
  }
  await ensureCoValueLoaded(backend, coId, { waitForAvailable: true, timeoutMs });
  const updatedCore = backend.getCoValue(coId);
  if (!updatedCore || !backend.isAvailable(updatedCore)) {
    throw new Error(`CoValue ${coId} failed to load within ${timeoutMs}ms`);
  }
}
async function resolveNestedReferences(backend, data2, visited = /* @__PURE__ */ new Set(), options = {}) {
  const {
    maxDepth = 10,
    timeoutMs = 5e3,
    currentDepth = 0
  } = options;
  const depthPrefix = `[DeepResolution:depth${currentDepth}]`;
  if (currentDepth > maxDepth) {
    console.warn(`${depthPrefix}  Max depth ${maxDepth} reached, stopping recursion`);
    return;
  }
  const coIds = extractCoValueIds(data2, visited, currentDepth, maxDepth);
  if (coIds.size === 0) {
    return;
  }
  const loadPromises = Array.from(coIds).map(async (coId) => {
    if (visited.has(coId)) {
      return;
    }
    visited.add(coId);
    try {
      await waitForCoValueAvailable(backend, coId, timeoutMs);
      const coValueCore = backend.getCoValue(coId);
      if (!coValueCore || !backend.isAvailable(coValueCore)) {
        return;
      }
      const nestedData = extractCoValueDataFlat(backend, coValueCore);
      await resolveNestedReferences(backend, nestedData, visited, {
        maxDepth,
        timeoutMs,
        currentDepth: currentDepth + 1
      });
      const unsubscribe = coValueCore.subscribe(() => {
      });
      backend.subscriptionCache.getOrCreate(`subscription:${coId}`, () => ({ unsubscribe }));
    } catch (error) {
    }
  });
  await Promise.all(loadPromises);
}
async function deepResolveCoValue(backend, coId, options = {}) {
  const {
    deepResolve = true,
    maxDepth = 10,
    timeoutMs = 5e3
  } = options;
  `[deepResolveCoValue:${coId.substring(0, 12)}...]`;
  if (!deepResolve) {
    return;
  }
  const cache = backend.subscriptionCache;
  if (cache.isResolved(coId)) {
    return;
  }
  const resolutionPromise = cache.getOrCreateResolution(coId, () => {
    return (async () => {
      try {
        const startTime = Date.now();
        await ensureCoValueLoaded(backend, coId, { waitForAvailable: true, timeoutMs });
        const coValueCore = backend.getCoValue(coId);
        if (!coValueCore || !backend.isAvailable(coValueCore)) {
          throw new Error(`CoValue ${coId} failed to load`);
        }
        const data2 = extractCoValueDataFlat(backend, coValueCore);
        const visited = /* @__PURE__ */ new Set([coId]);
        await resolveNestedReferences(backend, data2, visited, {
          maxDepth,
          timeoutMs,
          currentDepth: 0
        });
        cache.markResolved(coId);
      } catch (error) {
        cache.destroy(`resolution:${coId}`);
        throw error;
      }
    })();
  });
  if (resolutionPromise === true) {
    return;
  }
  await resolutionPromise;
}
async function resolveNestedReferencesPublic(backend, data2, options = {}) {
  return await resolveNestedReferences(backend, data2, /* @__PURE__ */ new Set(), options);
}
async function applyMapTransform(backend, item, mapConfig, options = {}) {
  if (!mapConfig || typeof mapConfig !== "object") {
    return item;
  }
  const { timeoutMs = 2e3 } = options;
  let resolvedItem = item;
  try {
    resolvedItem = await resolveCoValueReferences(backend, item, {
      fields: null,
      // Resolve all co-id fields
      timeoutMs: timeoutMs || 5e3
      // Increase timeout for deep resolution
    }, /* @__PURE__ */ new Set(), 20, 0);
  } catch (err) {
    console.warn(`[applyMapTransform] Failed to resolve references:`, err);
    resolvedItem = item;
  }
  const { Evaluator: Evaluator2 } = await Promise.resolve().then(() => evaluator);
  const evaluator$1 = new Evaluator2();
  const data2 = {
    context: {},
    // No context needed for map transformations
    item: resolvedItem
    // The resolved item is available via $$ shortcut
  };
  const mappedItem = { ...resolvedItem };
  const coIdsToRemove = /* @__PURE__ */ new Set();
  for (const [targetField, expression] of Object.entries(mapConfig)) {
    try {
      if (typeof expression !== "string" || !expression.startsWith("$$")) {
        throw new Error(`Map expression for "${targetField}" must use strict $$ syntax. Got: "${expression}". Expected format: "$$property.path"`);
      }
      const processedExpression = expression;
      const rootProperty = expression.substring(2).split(".")[0];
      if (rootProperty && rootProperty in item) {
        const originalValue = item[rootProperty];
        if (originalValue && typeof originalValue === "string" && originalValue.startsWith("co_z")) {
          coIdsToRemove.add(rootProperty);
        }
      }
      let mappedValue;
      try {
        mappedValue = await evaluator$1.evaluate(processedExpression, data2);
        if (mappedValue === void 0) {
          const propertyPath = expression.substring(2);
          const pathParts = propertyPath.split(".");
          let directValue = resolvedItem;
          for (const part of pathParts) {
            if (directValue && typeof directValue === "object" && part in directValue) {
              directValue = directValue[part];
            } else {
              directValue = void 0;
              break;
            }
          }
          if (directValue !== void 0) {
            console.warn(`[applyMapTransform]  Evaluator returned undefined, using direct access for "${targetField}" = "${expression}"`);
            mappedValue = directValue;
          }
        }
        mappedItem[targetField] = mappedValue;
      } catch (evalErr) {
        const propertyPath = expression.substring(2);
        const pathParts = propertyPath.split(".");
        let directValue = resolvedItem;
        for (const part of pathParts) {
          if (directValue && typeof directValue === "object" && part in directValue) {
            directValue = directValue[part];
          } else {
            directValue = void 0;
            break;
          }
        }
        console.warn(`[applyMapTransform]  Evaluation failed for "${targetField}" = "${expression}":`, {
          error: evalErr.message,
          processedExpression,
          propertyPath,
          directValue,
          resolvedItemKeys: Object.keys(resolvedItem)
        });
        mappedItem[targetField] = directValue !== void 0 ? directValue : void 0;
      }
    } catch (err) {
      console.warn(`[applyMapTransform] Failed to evaluate expression "${expression}" for field "${targetField}":`, err);
      console.warn(`[applyMapTransform] Resolved item keys:`, Object.keys(resolvedItem));
      mappedItem[targetField] = void 0;
    }
  }
  for (const coIdKey of coIdsToRemove) {
    delete mappedItem[coIdKey];
  }
  return mappedItem;
}
async function read(backend, coId = null, schema = null, filter = null, schemaHint = null, options = {}) {
  const {
    deepResolve = true,
    maxDepth = 10,
    timeoutMs = 5e3,
    resolveReferences = null,
    map = null,
    onChange = null
  } = options;
  const readOptions = { deepResolve, maxDepth, timeoutMs, resolveReferences, map, onChange };
  if (coId) {
    return await readSingleCoValue(backend, coId, schemaHint || schema, readOptions);
  }
  if (schema) {
    return await readCollection(backend, schema, filter, readOptions);
  }
  return await readAllCoValues(backend, filter, { deepResolve, maxDepth, timeoutMs });
}
async function createUnifiedStore(backend, contextStore, options = {}) {
  const unifiedStore = new ReactiveStore({});
  const queryStores = /* @__PURE__ */ new Map();
  const queryDefinitions = /* @__PURE__ */ new Map();
  const { timeoutMs = 5e3, onChange } = options;
  let lastUnifiedValue = null;
  let updateTimer = null;
  const updateUnifiedValue = () => {
    if (updateTimer) {
      return;
    }
    updateTimer = queueMicrotask(() => {
      updateTimer = null;
      const contextValue = contextStore.value || {};
      const mergedValue = { ...contextValue };
      delete mergedValue["@stores"];
      const $op = {};
      for (const [key, queryDef] of queryDefinitions.entries()) {
        $op[key] = queryDef;
      }
      if (Object.keys($op).length > 0) {
        mergedValue.$op = $op;
      }
      for (const [key, queryStore] of queryStores.entries()) {
        if (queryStore && typeof queryStore.subscribe === "function" && "value" in queryStore) {
          delete mergedValue[key];
          mergedValue[key] = queryStore.value;
        }
      }
      const currentValueStr = JSON.stringify(mergedValue);
      const lastValueStr = lastUnifiedValue ? JSON.stringify(lastUnifiedValue) : null;
      if (currentValueStr !== lastValueStr) {
        lastUnifiedValue = mergedValue;
        unifiedStore._set(mergedValue);
      }
    });
  };
  const resolveQueries = async (contextValue) => {
    if (!contextValue || typeof contextValue !== "object" || Array.isArray(contextValue)) {
      updateUnifiedValue();
      return;
    }
    const currentQueryKeys = /* @__PURE__ */ new Set();
    for (const [key, value] of Object.entries(contextValue)) {
      if (key === "$schema" || key === "$id" || key === "@stores") continue;
      if (value && typeof value === "object" && !Array.isArray(value) && value.schema) {
        currentQueryKeys.add(key);
        const existingStore = queryStores.get(key);
        try {
          let schemaCoId = value.schema;
          if (typeof schemaCoId === "string" && !schemaCoId.startsWith("co_z")) {
            if (schemaCoId.startsWith("@schema/")) {
              schemaCoId = await resolve$1(backend, schemaCoId, { returnType: "coId", timeoutMs });
              if (!schemaCoId || !schemaCoId.startsWith("co_z")) {
                console.error(`[createUnifiedStore] Failed to resolve schema ${value.schema} for query "${key}"`);
                continue;
              }
            } else {
              console.error(`[createUnifiedStore] Invalid schema format for query "${key}": ${schemaCoId}`);
              continue;
            }
          }
          const queryOptions = {
            ...options,
            timeoutMs,
            // Extract options from query object (e.g., value.options.map)
            ...value.options || {}
          };
          const queryStore = await read(backend, null, schemaCoId, value.filter || null, null, queryOptions);
          queryDefinitions.set(key, {
            schema: value.schema,
            ...value.options ? { options: value.options } : {},
            ...value.filter ? { filter: value.filter } : {}
          });
          if (!existingStore || existingStore !== queryStore) {
            if (existingStore && existingStore._queryUnsubscribe) {
              existingStore._queryUnsubscribe();
            }
            const unsubscribe = queryStore.subscribe(() => {
              updateUnifiedValue();
            });
            queryStore._queryUnsubscribe = unsubscribe;
            queryStores.set(key, queryStore);
            updateUnifiedValue();
          }
        } catch (error) {
          console.error(`[createUnifiedStore] Failed to resolve query "${key}":`, error);
        }
      }
    }
    for (const [key, store] of queryStores.entries()) {
      if (!currentQueryKeys.has(key)) {
        if (store._queryUnsubscribe) {
          store._queryUnsubscribe();
          delete store._queryUnsubscribe;
        }
        queryStores.delete(key);
        queryDefinitions.delete(key);
      }
    }
    updateUnifiedValue();
  };
  const contextUnsubscribe = contextStore.subscribe(async (newContextValue) => {
    await resolveQueries(newContextValue);
  });
  const originalUnsubscribe = unifiedStore._unsubscribe;
  unifiedStore._unsubscribe = () => {
    if (originalUnsubscribe) originalUnsubscribe();
    contextUnsubscribe();
    for (const store of queryStores.values()) {
      if (store._queryUnsubscribe) {
        store._queryUnsubscribe();
        delete store._queryUnsubscribe;
      }
    }
    queryStores.clear();
  };
  await resolveQueries(contextStore.value);
  return unifiedStore;
}
async function processCoValueData(backend, coValueCore, schemaHint, options, visited = /* @__PURE__ */ new Set()) {
  const {
    deepResolve = true,
    maxDepth = 10,
    timeoutMs = 5e3,
    resolveReferences = null,
    map = null
  } = options;
  let data2 = extractCoValueDataFlat(backend, coValueCore, schemaHint);
  if (deepResolve) {
    try {
      await deepResolveCoValue(backend, coValueCore.id, { deepResolve, maxDepth, timeoutMs });
    } catch (err) {
    }
  }
  if (resolveReferences) {
    try {
      const resolutionOptions = { ...resolveReferences, timeoutMs };
      data2 = await resolveCoValueReferences(backend, data2, resolutionOptions, visited, maxDepth, 0);
    } catch (err) {
    }
  }
  if (map) {
    try {
      data2 = await applyMapTransform(backend, data2, map, { timeoutMs });
    } catch (err) {
      console.warn(`[processCoValueData] Failed to apply map transform:`, err);
    }
  }
  return data2;
}
async function readSingleCoValue(backend, coId, schemaHint = null, options = {}) {
  const {
    deepResolve = true,
    maxDepth = 10,
    timeoutMs = 5e3,
    resolveReferences = null,
    map = null
  } = options;
  const cache = backend.subscriptionCache;
  const cacheOptions = { deepResolve, resolveReferences, map, maxDepth, timeoutMs };
  const cachedData = cache.getResolvedData(coId, cacheOptions);
  if (cachedData) {
    const store2 = new ReactiveStore(cachedData);
    const coValueCore2 = backend.getCoValue(coId);
    if (coValueCore2) {
      const unsubscribe2 = coValueCore2.subscribe(async (core2) => {
        if (core2.isAvailable()) {
          const newData = await processCoValueData(backend, core2, schemaHint, options, /* @__PURE__ */ new Set());
          cache.setResolvedData(coId, cacheOptions, newData);
          store2._set(newData);
        }
      });
      backend.subscriptionCache.getOrCreate(`subscription:${coId}`, () => ({ unsubscribe: unsubscribe2 }));
      const originalUnsubscribe2 = store2._unsubscribe;
      store2._unsubscribe = () => {
        if (originalUnsubscribe2) originalUnsubscribe2();
        backend.subscriptionCache.scheduleCleanup(`subscription:${coId}`);
      };
    }
    return store2;
  }
  const store = new ReactiveStore(null);
  const coValueCore = backend.getCoValue(coId);
  if (!coValueCore) {
    store._set({ error: "CoValue not found", id: coId });
    return store;
  }
  const sharedVisited = /* @__PURE__ */ new Set();
  const processAndCache = async (core2) => {
    const processedData = await processCoValueData(backend, core2, schemaHint, options, sharedVisited);
    cache.setResolvedData(coId, cacheOptions, processedData);
    return processedData;
  };
  const unsubscribe = coValueCore.subscribe(async (core2) => {
    if (!core2.isAvailable()) {
      store._set({ id: coId, loading: true });
      return;
    }
    const data2 = await processAndCache(core2);
    const hasQueryObjects = data2 && typeof data2 === "object" && Object.values(data2).some(
      (value) => value && typeof value === "object" && !Array.isArray(value) && value.schema
    );
    if (hasQueryObjects) {
      store._set(data2);
      return;
    }
    store._set(data2);
  });
  backend.subscriptionCache.getOrCreate(`subscription:${coId}`, () => ({ unsubscribe }));
  if (coValueCore.isAvailable()) {
    const data2 = await processAndCache(coValueCore);
    const hasQueryObjects = data2 && typeof data2 === "object" && Object.values(data2).some(
      (value) => value && typeof value === "object" && !Array.isArray(value) && value.schema
    );
    if (hasQueryObjects) {
      store._set(data2);
      return await createUnifiedStore(backend, store, options);
    }
    store._set(data2);
    return store;
  } else {
    store._set({ id: coId, loading: true });
    ensureCoValueLoaded(backend, coId).then(async () => {
    }).catch((err) => {
      store._set({ error: err.message, id: coId });
    });
  }
  const originalUnsubscribe = store._unsubscribe;
  store._unsubscribe = () => {
    if (originalUnsubscribe) originalUnsubscribe();
    backend.subscriptionCache.scheduleCleanup(`subscription:${coId}`);
  };
  return store;
}
async function readCollection(backend, schema, filter = null, options = {}) {
  const {
    deepResolve = true,
    maxDepth = 10,
    timeoutMs = 5e3,
    resolveReferences = null,
    map = null
  } = options;
  const optionsKey = options && (options.map || options.resolveReferences) ? JSON.stringify({ map: options.map || null, resolveReferences: options.resolveReferences || null }) : "";
  const cacheKey = `${schema}:${JSON.stringify(filter || {})}:${optionsKey}`;
  const store = backend.subscriptionCache.getOrCreateStore(cacheKey, () => {
    return new ReactiveStore([]);
  });
  const coListId = await getCoListId(backend, schema);
  if (!coListId) {
    return store;
  }
  let coListCore = backend.getCoValue(coListId);
  if (!coListCore) {
    return store;
  }
  if (!backend.isAvailable(coListCore)) {
    ensureCoValueLoaded(backend, coListId, { waitForAvailable: false }).catch((err) => {
      console.warn(`[readCollection] Failed to load CoList ${coListId.substring(0, 12)}...:`, err);
    });
    if (coListCore) {
      const unsubscribeColist = coListCore.subscribe((core2) => {
        if (core2 && backend.isAvailable(core2)) {
          updateStore().catch((err) => {
            console.warn(`[readCollection] Error updating store after colist load:`, err);
          });
        }
      });
      backend.subscriptionCache.getOrCreate(`subscription:${coListId}`, () => ({ unsubscribe: unsubscribeColist }));
    }
    return store;
  }
  const subscribedItemIds = /* @__PURE__ */ new Set();
  const sharedVisited = /* @__PURE__ */ new Set();
  const cache = backend.subscriptionCache;
  let updateStore;
  const subscribeToItem = (itemId) => {
    if (subscribedItemIds.has(itemId)) {
      return;
    }
    subscribedItemIds.add(itemId);
    const itemCore = backend.getCoValue(itemId);
    if (!itemCore || !backend.isAvailable(itemCore)) {
      ensureCoValueLoaded(backend, itemId, { waitForAvailable: true, timeoutMs: 2e3 }).then(() => {
        const loadedItemCore = backend.getCoValue(itemId);
        if (loadedItemCore && backend.isAvailable(loadedItemCore)) {
          const unsubscribeItem2 = loadedItemCore.subscribe(() => {
            cache.invalidateResolvedData(itemId);
            updateStore().catch((err) => {
              console.warn(`[CoJSONBackend] Error updating store:`, err);
            });
          });
          backend.subscriptionCache.getOrCreate(`subscription:${itemId}`, () => ({ unsubscribe: unsubscribeItem2 }));
          updateStore().catch((err) => {
            console.warn(`[CoJSONBackend] Error updating store after item load:`, err);
          });
        }
      }).catch((err) => {
        console.error(`[CoJSONBackend] Failed to load item ${itemId}:`, err);
      });
      return;
    }
    const unsubscribeItem = itemCore.subscribe(() => {
      cache.invalidateResolvedData(itemId);
      updateStore().catch((err) => {
        console.warn(`[CoJSONBackend] Error updating store:`, err);
      });
    });
    backend.subscriptionCache.getOrCreate(`subscription:${itemId}`, () => ({ unsubscribe: unsubscribeItem }));
  };
  updateStore = async () => {
    const results = [];
    if (!backend.isAvailable(coListCore)) {
      ensureCoValueLoaded(backend, coListId).catch((err) => {
        console.error(`[readCollection] Failed to reload CoList:`, err);
      });
      return;
    }
    const content = backend.getCurrentContent(coListCore);
    if (!content || !content.toJSON) {
      return;
    }
    try {
      const itemIdsArray = content.toJSON();
      let availableCount = 0;
      let unavailableCount = 0;
      for (const itemId of itemIdsArray) {
        if (typeof itemId !== "string" || !itemId.startsWith("co_")) {
          continue;
        }
        subscribeToItem(itemId);
        const itemCore = backend.getCoValue(itemId);
        if (!itemCore) {
          unavailableCount++;
          continue;
        }
        if (backend.isAvailable(itemCore)) {
          availableCount++;
          const itemCacheOptions = { deepResolve, resolveReferences, map, maxDepth, timeoutMs };
          const currentItemCore = backend.getCoValue(itemId);
          if (!currentItemCore || !backend.isAvailable(currentItemCore)) {
            continue;
          }
          const itemData = await cache.getOrCreateResolvedData(itemId, itemCacheOptions, async () => {
            let processedData = extractCoValueDataFlat(backend, currentItemCore);
            const dataKeys2 = Object.keys(processedData).filter(
              (key) => !["id", "type", "$schema"].includes(key)
            );
            if (dataKeys2.length === 0 && processedData.type === "comap") {
              return processedData;
            }
            if (deepResolve && !cache.isResolved(itemId)) {
              try {
                await resolveNestedReferences(backend, processedData, sharedVisited, {
                  maxDepth,
                  timeoutMs,
                  currentDepth: 0
                });
              } catch (err) {
              }
            }
            if (resolveReferences) {
              try {
                const resolutionOptions = { ...resolveReferences, timeoutMs };
                const resolvedData = await resolveCoValueReferences(backend, processedData, resolutionOptions, sharedVisited, maxDepth, 0);
                Object.assign(processedData, resolvedData);
              } catch (err) {
              }
            }
            if (map) {
              try {
                processedData = await applyMapTransform(backend, processedData, map, { timeoutMs });
              } catch (err) {
                console.warn(`[readCollection] Failed to apply map transform:`, err);
              }
            }
            return processedData;
          });
          const dataKeys = Object.keys(itemData).filter(
            (key) => !["id", "type", "$schema"].includes(key)
          );
          if (dataKeys.length === 0 && itemData.type === "comap") {
            continue;
          }
          if (!filter || matchesFilter(itemData, filter)) {
            results.push(itemData);
          }
        } else {
          unavailableCount++;
        }
      }
    } catch (e) {
      console.warn(`[readCollection] Error reading CoList items:`, e);
    }
    store._set(results);
  };
  const unsubscribeCoList = coListCore.subscribe(() => {
    updateStore().catch((err) => {
      console.warn(`[CoJSONBackend] Error updating store:`, err);
    });
  });
  backend.subscriptionCache.getOrCreate(`subscription:${coListId}`, () => ({ unsubscribe: unsubscribeCoList }));
  if (backend.isAvailable(coListCore)) {
    const content = backend.getCurrentContent(coListCore);
    if (content && content.toJSON) {
      try {
        const itemIdsArray = content.toJSON();
        for (const itemId of itemIdsArray) {
          if (typeof itemId === "string" && itemId.startsWith("co_")) {
            const itemCore = backend.getCoValue(itemId);
            if (itemCore && !backend.isAvailable(itemCore)) {
              ensureCoValueLoaded(backend, itemId).catch((err) => {
                console.error(`[CoJSONBackend] Failed to load item ${itemId}:`, err);
              });
            }
          }
        }
      } catch (e) {
      }
    }
  }
  await updateStore();
  const originalUnsubscribe = store._unsubscribe;
  store._unsubscribe = () => {
    backend.subscriptionCache.scheduleCleanup(`store:${cacheKey}`);
    if (originalUnsubscribe) originalUnsubscribe();
    backend.subscriptionCache.scheduleCleanup(`subscription:${coListId}`);
    for (const itemId of subscribedItemIds) {
      backend.subscriptionCache.scheduleCleanup(`subscription:${itemId}`);
    }
  };
  return store;
}
async function readAllCoValues(backend, filter = null, options = {}) {
  const {
    deepResolve = true,
    maxDepth = 10,
    timeoutMs = 5e3
  } = options;
  const store = new ReactiveStore([]);
  const subscribedCoIds = /* @__PURE__ */ new Set();
  let updateStore;
  const subscribeToCoValue = (coId, coValueCore) => {
    if (subscribedCoIds.has(coId)) {
      return;
    }
    subscribedCoIds.add(coId);
    const unsubscribe = coValueCore.subscribe(() => {
      updateStore();
    });
    backend.subscriptionCache.getOrCreate(`subscription:${coId}`, () => ({ unsubscribe }));
  };
  updateStore = async () => {
    const allCoValues = backend.getAllCoValues();
    const results = [];
    for (const [coId, coValueCore] of allCoValues.entries()) {
      if (!coId || typeof coId !== "string" || !coId.startsWith("co_")) {
        continue;
      }
      subscribeToCoValue(coId, coValueCore);
      if (!backend.isAvailable(coValueCore)) {
        ensureCoValueLoaded(backend, coId).catch((err) => {
          console.error(`[CoJSONBackend] Failed to load CoValue ${coId}:`, err);
        });
        continue;
      }
      const data2 = extractCoValueDataFlat(backend, coValueCore);
      const dataKeys = Object.keys(data2).filter(
        (key) => !["id", "type", "$schema"].includes(key)
      );
      if (dataKeys.length === 0 && data2.type === "comap") {
        continue;
      }
      if (deepResolve) {
        try {
          await resolveNestedReferencesPublic(backend, data2, { maxDepth, timeoutMs });
        } catch (err) {
        }
      }
      if (!filter || matchesFilter(data2, filter)) {
        results.push(data2);
      }
    }
    store._set(results);
  };
  await updateStore();
  const originalUnsubscribe = store._unsubscribe;
  store._unsubscribe = () => {
    if (originalUnsubscribe) originalUnsubscribe();
    for (const coId of subscribedCoIds) {
      backend.subscriptionCache.scheduleCleanup(`subscription:${coId}`);
    }
  };
  return store;
}
async function waitForStoreReady(store, coId, timeoutMs = 5e3) {
  const initialValue = store.value;
  const isReady = initialValue && !initialValue.loading && !initialValue.error && (initialValue.hasProperties !== false || initialValue.properties || typeof initialValue === "object" && Object.keys(initialValue).length > 0 && initialValue.id);
  if (isReady) {
    return;
  }
  if (initialValue?.error) {
    throw new Error(`CoValue error (co-id: ${coId}): ${initialValue.error}`);
  }
  return new Promise((resolve2, reject) => {
    let resolved = false;
    let unsubscribe;
    unsubscribe = store.subscribe((data2) => {
      if (resolved) return;
      if (data2?.error) {
        resolved = true;
        unsubscribe();
        reject(new Error(`CoValue error (co-id: ${coId}): ${data2.error}`));
        return;
      }
      const hasData = !data2?.loading && data2 !== null && (data2?.hasProperties !== false || data2?.properties || typeof data2 === "object" && Object.keys(data2).length > 0 && data2.id);
      if (hasData) {
        resolved = true;
        unsubscribe();
        resolve2();
      }
    });
    const current = store.value;
    if (current?.error) {
      resolved = true;
      unsubscribe();
      reject(new Error(`CoValue error (co-id: ${coId}): ${current.error}`));
    } else {
      const currentHasData = !current?.loading && current !== null && (current?.hasProperties !== false || current?.properties || typeof current === "object" && Object.keys(current).length > 0 && current.id);
      if (currentHasData) {
        resolved = true;
        unsubscribe();
        resolve2();
      }
    }
    setTimeout(() => {
      if (!resolved) {
        resolved = true;
        unsubscribe();
        reject(new Error(`CoValue timeout loading (co-id: ${coId}). Make sure the CoValue was seeded correctly.`));
      }
    }, timeoutMs);
  });
}
const readOperations = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  waitForStoreReady
}, Symbol.toStringTag, { value: "Module" }));
function removeIdFields(obj) {
  if (obj === null || obj === void 0) {
    return obj;
  }
  if (typeof obj !== "object") {
    return obj;
  }
  if (Array.isArray(obj)) {
    return obj.map((item) => removeIdFields(item));
  }
  const cleaned = {};
  for (const [key, value] of Object.entries(obj)) {
    if (key === "id") {
      continue;
    }
    if (value !== null && value !== void 0 && typeof value === "object") {
      cleaned[key] = removeIdFields(value);
    } else {
      cleaned[key] = value;
    }
  }
  return cleaned;
}
async function resolve$1(backend, identifier, options = {}) {
  const {
    returnType = "schema",
    deepResolve = false,
    timeoutMs = 5e3
  } = options;
  if (!backend) {
    throw new Error("[resolve] backend is required");
  }
  if (identifier && typeof identifier === "object" && !Array.isArray(identifier)) {
    if (identifier.fromCoValue) {
      if (!identifier.fromCoValue.startsWith("co_z")) {
        throw new Error(`[resolve] fromCoValue must be a valid co-id (co_z...), got: ${identifier.fromCoValue}`);
      }
      const coValueStore = await read(backend, identifier.fromCoValue, null, null, null, {
        deepResolve: false,
        timeoutMs
      });
      try {
        await waitForStoreReady(coValueStore, identifier.fromCoValue, timeoutMs);
      } catch (error) {
        return null;
      }
      const coValueData = coValueStore.value;
      if (!coValueData || coValueData.error) {
        return null;
      }
      const schemaCoId = coValueData.$schema || null;
      if (!schemaCoId) {
        return null;
      }
      if (returnType === "coId") {
        return schemaCoId;
      }
      return await resolve$1(backend, schemaCoId, { returnType, deepResolve, timeoutMs });
    }
    throw new Error('[resolve] Invalid identifier object. Expected { fromCoValue: "co_z..." }');
  }
  if (typeof identifier !== "string") {
    throw new Error(`[resolve] Invalid identifier type. Expected string or object, got: ${typeof identifier}`);
  }
  if (identifier.startsWith("co_z")) {
    const store = await read(backend, identifier, null, null, null, {
      deepResolve,
      timeoutMs
    });
    try {
      await waitForStoreReady(store, identifier, timeoutMs);
    } catch (error) {
      return null;
    }
    const data2 = store.value;
    if (!data2 || data2.error) {
      return null;
    }
    if (returnType === "coValue") {
      return store;
    }
    if (returnType === "coId") {
      return identifier;
    }
    const cotype2 = data2.cotype;
    const properties2 = data2.properties;
    const items2 = data2.items;
    const title2 = data2.title;
    const hasSchemaProps = cotype2 || properties2 || items2 || title2;
    if (hasSchemaProps) {
      const { id: id2, type: type2, ...schemaData } = data2;
      const cleanedSchema = removeIdFields(schemaData);
      return {
        ...cleanedSchema,
        $id: identifier
        // Ensure $id is set
      };
    }
    return null;
  }
  if (identifier.startsWith("@schema/") || identifier.startsWith("@vibe/") || !identifier.startsWith("@") && !identifier.startsWith("co_z")) {
    let normalizedKey = identifier;
    if (!normalizedKey.startsWith("@schema/") && !normalizedKey.startsWith("@vibe/") && !normalizedKey.startsWith("@")) {
      normalizedKey = `@schema/${normalizedKey}`;
    }
    if (!backend.account || typeof backend.account.get !== "function") {
      console.warn("[resolve] Account not available for registry lookup");
      return null;
    }
    const isSchemaKey = normalizedKey.startsWith("@schema/");
    if (isSchemaKey) {
      const osId = backend.account.get("os");
      if (!osId || typeof osId !== "string" || !osId.startsWith("co_z")) {
        console.warn(`[resolve] account.os not found for schema key: ${identifier}`);
        return null;
      }
      const osStore = await read(backend, osId, null, null, null, {
        deepResolve: false,
        timeoutMs
      });
      try {
        await waitForStoreReady(osStore, osId, timeoutMs);
      } catch (error) {
        return null;
      }
      const osData = osStore.value;
      if (!osData || osData.error) {
        return null;
      }
      const schematasId = osData.schematas;
      if (!schematasId || typeof schematasId !== "string" || !schematasId.startsWith("co_z")) {
        console.warn(`[resolve] account.os.schematas not found`);
        return null;
      }
      const schematasStore = await read(backend, schematasId, null, null, null, {
        deepResolve: false,
        timeoutMs
      });
      try {
        await waitForStoreReady(schematasStore, schematasId, timeoutMs);
      } catch (error) {
        return null;
      }
      const schematasData = schematasStore.value;
      if (!schematasData || schematasData.error) {
        return null;
      }
      const registryCoId = schematasData[normalizedKey] || schematasData[identifier];
      if (registryCoId && typeof registryCoId === "string" && registryCoId.startsWith("co_z")) {
        if (returnType === "coId") {
          return registryCoId;
        }
        return await resolve$1(backend, registryCoId, { returnType, deepResolve, timeoutMs });
      }
      const isIndexSchema = normalizedKey.startsWith("@schema/index/");
      if (!isIndexSchema) {
        console.warn(`[resolve] schema key ${identifier} (normalized: ${normalizedKey}) not found in os.schematas registry`);
      }
      return null;
    } else if (identifier.startsWith("@vibe/") || !identifier.startsWith("@")) {
      const vibesId = backend.account.get("vibes");
      if (!vibesId || typeof vibesId !== "string" || !vibesId.startsWith("co_z")) {
        console.warn(`[resolve] account.vibes not found for vibe key: ${identifier}`);
        return null;
      }
      const vibesStore = await read(backend, vibesId, null, null, null, {
        deepResolve: false,
        timeoutMs
      });
      try {
        await waitForStoreReady(vibesStore, vibesId, timeoutMs);
      } catch (error) {
        return null;
      }
      const vibesData = vibesStore.value;
      if (!vibesData || vibesData.error) {
        return null;
      }
      const vibeName = identifier.startsWith("@vibe/") ? identifier.replace("@vibe/", "") : identifier;
      const registryCoId = vibesData[vibeName];
      if (registryCoId && typeof registryCoId === "string" && registryCoId.startsWith("co_z")) {
        if (returnType === "coId") {
          return registryCoId;
        }
        return await resolve$1(backend, registryCoId, { returnType, deepResolve, timeoutMs });
      }
      console.warn(`[resolve] Vibe ${identifier} not found in account.vibes registry`);
      return null;
    }
  }
  console.warn(`[resolve] Unknown key format: ${identifier}`);
  return null;
}
async function checkCotype(backend, schemaCoId, expectedCotype) {
  const schema = await resolve$1(backend, schemaCoId, { returnType: "schema" });
  if (!schema) {
    throw new Error(`[checkCotype] Schema ${schemaCoId} not found`);
  }
  const cotype2 = schema.cotype || "comap";
  return cotype2 === expectedCotype;
}
const AccountSchema = {
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $id: "https://maia.city/AccountSchema",
  title: "Account",
  description: "Schema for account CoMap (special CoMap with authentication properties)",
  allOf: [
    { $ref: "#/$defs/comap" }
  ],
  properties: {
    sealer: {
      type: "string",
      pattern: "^sealer_",
      description: "Sealer key for encryption"
    },
    signer: {
      type: "string",
      pattern: "^signer_",
      description: "Signer key for signing"
    },
    readKey: {
      type: "string",
      description: "Read key for decryption"
    },
    profile: {
      allOf: [
        {
          type: "string",
          pattern: "^co_z[a-zA-Z0-9]+$",
          description: "Co-id reference to Profile CoMap"
        },
        {
          $ref: "https://maia.city/ProfileSchema"
        }
      ]
    },
    examples: {
      type: "string",
      pattern: "^co_z[a-zA-Z0-9]+$",
      description: "Co-id reference to Examples CoMap (optional)"
    }
  },
  required: ["profile"],
  $defs: coTypesDefs.$defs
};
const GroupSchema = {
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $id: "https://maia.city/GroupSchema",
  title: "Group",
  description: "Schema for group CoMap (special CoMap with member management)",
  allOf: [
    { $ref: "#/$defs/comap" }
  ],
  properties: {
    // Groups can have members (co-ids) and permissions
    // Structure depends on cojson's group implementation
  },
  $defs: coTypesDefs.$defs
};
const ProfileSchema = {
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $id: "https://maia.city/ProfileSchema",
  title: "Profile",
  description: "Schema for profile CoMap",
  allOf: [
    { $ref: "#/$defs/comap" }
  ],
  properties: {
    name: {
      type: "string",
      minLength: 1,
      description: "User's display name"
    },
    group: {
      type: "string",
      pattern: "^co_z[a-zA-Z0-9]+$",
      description: "Co-id reference to universal group (set by migration)"
    }
  },
  required: ["name"],
  $defs: coTypesDefs.$defs
};
const SCHEMA_REGISTRY = {
  AccountSchema,
  GroupSchema,
  ProfileSchema
};
function getAllSchemas$1() {
  return { ...SCHEMA_REGISTRY };
}
function hasSchemaInRegistry(schemaName) {
  const EXCEPTION_SCHEMAS_LIST = ["@account", "@group", "GenesisSchema"];
  if (EXCEPTION_SCHEMAS_LIST.includes(schemaName)) {
    return true;
  }
  return schemaName in SCHEMA_REGISTRY;
}
const EXCEPTION_SCHEMAS = {
  ACCOUNT: "@account",
  GROUP: "@group",
  META_SCHEMA: "GenesisSchema"
};
function isExceptionSchema(schema) {
  return schema === EXCEPTION_SCHEMAS.ACCOUNT || schema === EXCEPTION_SCHEMAS.GROUP || schema === EXCEPTION_SCHEMAS.META_SCHEMA;
}
function createSchemaMeta(schemaName) {
  if (!isExceptionSchema(schemaName) && !schemaName.startsWith("co_z") && !hasSchemaInRegistry(schemaName)) {
    console.warn(`[createSchemaMeta] Schema '${schemaName}' not found in registry`);
  }
  return {
    $schema: schemaName
    // Schema name, co-id, or exception schema
  };
}
function ajvCoTypesPlugin(ajv2) {
  ajv2.addKeyword({
    keyword: "$co",
    macro: (schemaCoId) => ({
      type: "string",
      pattern: "^co_z[a-zA-Z0-9]+$",
      _schemaRef: schemaCoId
      // Store schema co-id for metadata
    }),
    metaSchema: {
      type: "string",
      anyOf: [
        {
          pattern: "^co_z[a-zA-Z0-9]+$",
          description: "Co-id reference (after transformation)"
        },
        {
          pattern: "^@schema/",
          description: "Human-readable schema ID (before transformation)"
        }
      ],
      description: "Reference to schema that this property value must conform to (human-readable ID or co-id)"
    }
  });
  ajv2.addKeyword({
    keyword: "cotype",
    validate: (schema, data2) => {
      if (data2 === null || typeof data2 !== "object") {
        return true;
      }
      if (schema === "comap") {
        return !Array.isArray(data2);
      }
      if (schema === "colist" || schema === "costream") {
        if (Array.isArray(data2)) {
          return true;
        }
        if (typeof data2 === "object" && data2 !== null && Array.isArray(data2.items)) {
          return true;
        }
        return false;
      }
      return false;
    },
    metaSchema: {
      enum: ["comap", "colist", "costream"]
    }
  });
}
const $schema$s = "https://json-schema.org/draft/2020-12/schema";
const $id$t = "@schema/meta";
const $vocabulary$8 = { "https://json-schema.org/draft/2020-12/vocab/core": true, "https://json-schema.org/draft/2020-12/vocab/applicator": true, "https://json-schema.org/draft/2020-12/vocab/unevaluated": true, "https://json-schema.org/draft/2020-12/vocab/validation": true, "https://json-schema.org/draft/2020-12/vocab/meta-data": true, "https://json-schema.org/draft/2020-12/vocab/format-annotation": true, "https://json-schema.org/draft/2020-12/vocab/content": true, "https://maiaos.dev/vocab/cojson": true };
const allOf$2 = [{ "$ref": "https://json-schema.org/draft/2020-12/schema" }];
const title$s = "@schema/meta";
const type$a = ["object", "boolean"];
const indexing$j = false;
const properties$p = { "title": { "type": "string", "description": "Human-readable schema title (required)" }, "cotype": { "enum": ["comap", "colist", "costream"], "description": "CRDT type at schema root. Schemas can be comap (with properties), colist (with items), or costream (with items). CoText is modeled as colist with string items." }, "$co": { "type": "string", "anyOf": [{ "pattern": "^co_z[a-zA-Z0-9]+$", "description": "Co-id reference (after transformation)" }, { "pattern": "^@schema/", "description": "Human-readable schema ID (before transformation)" }], "description": "Reference to schema that this property value must conform to (human-readable ID or co-id). Use $co in properties to reference separate CoValues, never use cotype in properties." }, "indexing": { "type": "boolean", "default": false, "description": "Whether instances of this schema should be indexed in account.os.{schemaCoId}" } };
const required$9 = ["title", "cotype"];
const $defs$5 = { "comap": { "description": "CoMap - CRDT-based collaborative map/object", "type": "object", "properties": {}, "additionalProperties": { "anyOf": [{ "type": "string", "description": "Standard string value" }, { "type": "number", "description": "Standard number value" }, { "type": "integer", "description": "Standard integer value" }, { "type": "boolean", "description": "Standard boolean value" }, { "type": "null", "description": "Null value" }, { "type": "object", "description": "Nested object value" }, { "type": "array", "description": "Array value" }, { "type": "string", "pattern": "^co_z[a-zA-Z0-9]+$", "description": "Co-id reference to another CoValue" }, { "type": "string", "pattern": "^key_[a-zA-Z0-9_]+$", "description": "Key reference" }, { "type": "string", "pattern": "^sealed_", "description": "Sealed/encrypted value" }] } }, "costream": { "description": "CoStream - CRDT-based append-only stream", "type": "array", "items": { "anyOf": [{ "type": "object", "description": "Stream item object" }, { "type": "string", "description": "Stream item string" }, { "type": "number", "description": "Stream item number" }, { "type": "boolean", "description": "Stream item boolean" }, { "type": "null", "description": "Stream item null" }] } }, "colist": { "description": "CoList - CRDT-based collaborative list/array", "type": "array", "items": { "anyOf": [{ "type": "object", "description": "List item object" }, { "type": "string", "description": "List item string (can be co-id reference)" }, { "type": "number", "description": "List item number" }, { "type": "integer", "description": "List item integer" }, { "type": "boolean", "description": "List item boolean" }, { "type": "null", "description": "List item null" }, { "type": "array", "description": "Nested array" }] } } };
const mergedMetaSchema = {
  $schema: $schema$s,
  $id: $id$t,
  $vocabulary: $vocabulary$8,
  allOf: allOf$2,
  title: title$s,
  type: type$a,
  indexing: indexing$j,
  properties: properties$p,
  required: required$9,
  $defs: $defs$5
};
class ValidationEngine {
  constructor(options = {}) {
    this.ajv = null;
    this.ajvPromise = null;
    this.initialized = false;
    this.schemas = /* @__PURE__ */ new Map();
    this.schemaResolver = null;
    this.registrySchemas = options.registrySchemas || null;
  }
  /**
   * Set schema resolver function for resolving $schema references from IndexedDB
   * @param {Function} resolver - Async function that takes a schema key and returns the schema
   */
  setSchemaResolver(resolver) {
    this.schemaResolver = resolver;
  }
  /**
   * Initialize AJV (loads from CDN in browser, uses import in Node/Bun)
   * @returns {Promise<void>}
   */
  async initialize() {
    if (this.initialized) {
      return;
    }
    if (this.ajvPromise) {
      await this.ajvPromise;
      return;
    }
    this.ajvPromise = (async () => {
      let Ajv;
      try {
        const ajvModule = await Promise.resolve().then(() => _2020$1);
        Ajv = ajvModule.default || ajvModule.Ajv2020 || ajvModule;
      } catch (e) {
        try {
          Ajv = (await Promise.resolve().then(() => ajv$1)).default;
        } catch (e2) {
          try {
            const ajvModule = await import("https://esm.sh/ajv@8.12.0/dist/2020.js");
            Ajv = ajvModule.default || ajvModule.Ajv2020 || ajvModule;
          } catch (e3) {
            const ajvModule = await import("https://esm.sh/ajv@8.12.0");
            Ajv = ajvModule.default || ajvModule;
          }
        }
      }
      this.ajv = new Ajv({
        allErrors: true,
        // Collect all errors, not just first
        verbose: true,
        // Include schema and data paths in errors
        strict: false,
        // Be permissive initially
        validateSchema: true,
        // Validate schemas themselves (meta-schema will be loaded)
        validateFormats: true,
        // Enable format validation
        removeAdditional: false,
        // Don't remove extra properties
        useDefaults: false,
        // Don't add defaults
        coerceTypes: false,
        // Don't coerce types
        loadSchema: async (uri2) => {
          if (uri2.startsWith("co_z")) {
            if (this.schemaResolver) {
              try {
                let schema = await this.schemaResolver(uri2);
                if (schema && schema.$coId && !schema.$schema) {
                  schema = await this.schemaResolver(schema.$coId);
                }
                return schema || void 0;
              } catch (error) {
                console.warn(`[ValidationEngine] loadSchema failed for ${uri2}:`, error);
                return void 0;
              }
            }
            return void 0;
          }
          return void 0;
        }
      });
      this.ajv.addFormat("uri-reference", {
        type: "string",
        validate: (uri2) => {
          if (!uri2 || typeof uri2 !== "string") return false;
          if (uri2 === "") return true;
          try {
            new URL(uri2);
            return true;
          } catch {
            return true;
          }
        }
      });
      this.ajv.addFormat("regex", {
        type: "string",
        validate: (pattern2) => {
          if (!pattern2 || typeof pattern2 !== "string") return false;
          try {
            new RegExp(pattern2);
            return true;
          } catch {
            return false;
          }
        }
      });
      this._loadMetaSchema();
      this._loadCoJsonMetaSchema();
      ajvCoTypesPlugin(this.ajv);
      await this._loadCoTypeDefinitions();
      if (this.registrySchemas) {
        await this.registerAllSchemas(this.registrySchemas);
      }
      this.initialized = true;
    })();
    await this.ajvPromise;
  }
  /**
   * Get the CoJSON custom meta-schema (extends JSON Schema Draft 2020-12)
   * @returns {Object} Meta schema object
   */
  static getMetaSchema() {
    return mergedMetaSchema;
  }
  /**
   * Get the base JSON Schema Draft 2020-12 meta-schema
   * @returns {Object} Meta schema object
   */
  static getBaseMetaSchema() {
    return mergedMetaSchema;
  }
  /**
   * Load JSON Schema Draft 2020-12 meta-schema (hardcoded)
   * @private
   */
  _loadMetaSchema() {
    const metaSchemaId = "https://json-schema.org/draft/2020-12/schema";
    const metaSchemaDynamicId = "@schema/meta-schema";
    const metaSchema = ValidationEngine.getBaseMetaSchema();
    try {
      withSchemaValidationDisabled(this.ajv, () => {
        if (!this.ajv.getSchema(metaSchemaId)) {
          this.ajv.addMetaSchema(metaSchema, metaSchema.$id);
        }
        if (!this.ajv.getSchema(metaSchemaDynamicId)) {
          const metaSchemaCopy = JSON.parse(JSON.stringify(metaSchema));
          metaSchemaCopy.$id = metaSchemaDynamicId;
          this.ajv.addMetaSchema(metaSchemaCopy, metaSchemaDynamicId);
        }
      });
    } catch (error) {
      if (!error.message || !error.message.includes("already exists")) {
        console.warn("[ValidationEngine] Failed to add meta-schema:", error.message);
        return;
      }
    }
  }
  /**
   * Load CoJSON custom meta-schema
   * @private
   */
  _loadCoJsonMetaSchema() {
    const customMetaSchemaId = "@schema/meta";
    try {
      withSchemaValidationDisabled(this.ajv, () => {
        if (!this.ajv.getSchema(customMetaSchemaId)) {
          this.ajv.addMetaSchema(mergedMetaSchema, customMetaSchemaId);
        }
      });
    } catch (error) {
      if (!error.message || !error.message.includes("already exists")) {
        console.warn("[ValidationEngine] Failed to add CoJSON meta-schema:", error.message);
      }
    }
  }
  /**
   * Resolve meta-schema ID from co-id or return as-is
   * @private
   * @param {string} schemaMetaSchemaId - Meta-schema ID (may be co-id)
   * @returns {Promise<{resolvedMetaSchemaId: string, metaSchemaObject: Object|null}>}
   */
  async _resolveMetaSchemaId(schemaMetaSchemaId) {
    let resolvedMetaSchemaId = schemaMetaSchemaId;
    let metaSchemaObject = null;
    if (schemaMetaSchemaId.startsWith("co_z")) {
      if (this.schemaResolver) {
        metaSchemaObject = await this.schemaResolver(schemaMetaSchemaId);
        if (metaSchemaObject && metaSchemaObject.$id) {
          resolvedMetaSchemaId = metaSchemaObject.$id;
        } else {
          const coIdValidator = this.ajv.getSchema(schemaMetaSchemaId);
          if (coIdValidator) {
            resolvedMetaSchemaId = schemaMetaSchemaId;
          } else {
            throw new Error(`[ValidationEngine] Could not resolve meta-schema co-id '${schemaMetaSchemaId}'. Schema resolver returned null or undefined.`);
          }
        }
      } else {
        const coIdValidator = this.ajv.getSchema(schemaMetaSchemaId);
        if (coIdValidator) {
          resolvedMetaSchemaId = schemaMetaSchemaId;
        } else {
          throw new Error(`[ValidationEngine] Meta-schema co-id '${schemaMetaSchemaId}' not found and no schema resolver available.`);
        }
      }
    }
    return { resolvedMetaSchemaId, metaSchemaObject };
  }
  /**
   * Determine meta-schema type (CoJSON vs standard JSON Schema)
   * @private
   * @param {Object} metaSchemaObject - Resolved meta-schema object
   * @returns {string} Target meta-schema ID ('@schema/meta' or standard meta-schema ID)
   */
  _determineMetaSchemaType(metaSchemaObject) {
    const hasCotypeProperty = metaSchemaObject.properties && metaSchemaObject.properties.cotype && metaSchemaObject.properties.cotype.enum && Array.isArray(metaSchemaObject.properties.cotype.enum) && metaSchemaObject.properties.cotype.enum.includes("comap");
    const hasCojsonVocabulary = metaSchemaObject.$vocabulary && metaSchemaObject.$vocabulary["https://maiaos.dev/vocab/cojson"] === true;
    if (hasCotypeProperty || hasCojsonVocabulary) {
      return "@schema/meta";
    } else if (metaSchemaObject.$vocabulary) {
      return "https://json-schema.org/draft/2020-12/schema";
    } else {
      return "@schema/meta";
    }
  }
  /**
   * Get meta-schema validator, registering if necessary
   * @private
   * @param {string} resolvedMetaSchemaId - Resolved meta-schema ID
   * @param {Object|null} metaSchemaObject - Resolved meta-schema object (if available)
   * @returns {Function|null} Meta-schema validator function
   */
  _getMetaSchemaValidator(resolvedMetaSchemaId, metaSchemaObject) {
    if (resolvedMetaSchemaId === "@schema/meta" || resolvedMetaSchemaId === "@schema/meta-schema") {
      return this.ajv.getSchema("@schema/meta");
    } else if (resolvedMetaSchemaId === "https://json-schema.org/draft/2020-12/schema") {
      return this.ajv.getSchema("https://json-schema.org/draft/2020-12/schema");
    } else if (resolvedMetaSchemaId.startsWith("co_z")) {
      let metaValidator = this.ajv.getSchema(resolvedMetaSchemaId);
      if (!metaValidator && metaSchemaObject) {
        const targetMetaSchemaId = this._determineMetaSchemaType(metaSchemaObject);
        metaValidator = this.ajv.getSchema(targetMetaSchemaId);
        if (!metaValidator && metaSchemaObject) {
          try {
            withSchemaValidationDisabled(this.ajv, () => {
              this.ajv.addSchema(metaSchemaObject, resolvedMetaSchemaId);
              if (targetMetaSchemaId !== resolvedMetaSchemaId) {
                this.ajv.addSchema(metaSchemaObject, targetMetaSchemaId);
              }
              metaValidator = this.ajv.getSchema(targetMetaSchemaId);
            });
          } catch (error) {
            metaValidator = this.ajv.getSchema(targetMetaSchemaId);
          }
        }
      }
      if (!metaValidator) {
        throw new Error(`[ValidationEngine] Meta-schema validator not found for co-id '${resolvedMetaSchemaId}'. Make sure the meta-schema is registered in AJV.`);
      }
      return metaValidator;
    } else {
      throw new Error(`[ValidationEngine] Unknown meta schema (resolved to '${resolvedMetaSchemaId}'). Expected '@schema/meta' or standard JSON Schema meta schema.`);
    }
  }
  /**
   * Validate a schema against its meta-schema
   * @param {Object} schema - Schema to validate
   * @returns {{valid: boolean, errors: Array|null}} Validation result
   */
  async validateSchemaAgainstMeta(schema) {
    await this.initialize();
    const schemaMetaSchemaId = schema.$schema;
    if (!schemaMetaSchemaId) {
      throw new Error(`[ValidationEngine] Schema missing required $schema field. All schemas must declare their meta schema.`);
    }
    const { resolvedMetaSchemaId, metaSchemaObject } = await this._resolveMetaSchemaId(schemaMetaSchemaId);
    const metaValidator = this._getMetaSchemaValidator(resolvedMetaSchemaId, metaSchemaObject);
    if (!metaValidator) {
      console.warn(`[ValidationEngine] Meta schema '${schemaMetaSchemaId}' not available, skipping schema validation`);
      return { valid: true, errors: null };
    }
    const standardMetaSchemaId = "https://json-schema.org/draft/2020-12/schema";
    const isSelfValidation = schema.$id === standardMetaSchemaId || schema.$id === "@schema/meta" || schema.$schema === standardMetaSchemaId && schema.$id && schema.$id.includes("schema");
    if (isSelfValidation) {
      return withSchemaValidationDisabled(this.ajv, () => {
        const valid2 = metaValidator(schema);
        if (valid2) {
          return { valid: true, errors: null };
        }
        const errors3 = metaValidator.errors || [];
        const formattedErrors2 = formatValidationErrors(errors3);
        return {
          valid: false,
          errors: formattedErrors2
        };
      });
    }
    const valid = metaValidator(schema);
    if (valid) {
      return { valid: true, errors: null };
    }
    const errors2 = metaValidator.errors || [];
    const formattedErrors = formatValidationErrors(errors2);
    return {
      valid: false,
      errors: formattedErrors
    };
  }
  /**
   * Load a schema for a given type
   * @param {string} type - Schema type identifier (e.g., 'actor', 'context', 'state')
   * @param {object} schema - JSON Schema object
   */
  async loadSchema(type2, schema) {
    await this.initialize();
    if (!type2 || typeof type2 !== "string") {
      throw new Error("Schema type must be a non-empty string");
    }
    if (!schema || typeof schema !== "object") {
      throw new Error("Schema must be an object");
    }
    if (this.schemas.has(type2)) {
      return this.schemas.get(type2);
    }
    await this._resolveAndRegisterSchemaDependencies(schema);
    if (schema.$id) {
      const existingValidator = this.ajv.getSchema(schema.$id);
      if (existingValidator) {
        this.schemas.set(type2, existingValidator);
        return existingValidator;
      }
    }
    try {
      const validate2 = this.ajv.compile(schema);
      this.schemas.set(type2, validate2);
      return validate2;
    } catch (error) {
      if (error.message && error.message.includes("already exists") && schema.$id) {
        const existingValidator = this.ajv.getSchema(schema.$id);
        if (existingValidator) {
          this.schemas.set(type2, existingValidator);
          return existingValidator;
        }
      }
      throw new Error(`Failed to load schema for type '${type2}': ${error.message}`);
    }
  }
  /**
   * Resolve $schema reference (co-id) and register meta-schema
   * @private
   * @param {string} coId - Co-id of the meta-schema
   * @param {Set} resolvedSchemas - Set of already resolved schema co-ids
   * @param {Set} resolvingSchemas - Set of schemas currently being resolved
   * @param {Function} resolveRecursive - Recursive resolution function
   * @returns {Promise<void>}
   */
  async _resolveSchemaReference(coId, resolvedSchemas, resolvingSchemas, resolveRecursive) {
    if (resolvedSchemas.has(coId) || resolvingSchemas.has(coId)) {
      return;
    }
    resolvingSchemas.add(coId);
    try {
      let metaSchema = await this.schemaResolver(coId);
      if (metaSchema && metaSchema.$coId && !metaSchema.$schema) {
        metaSchema = await this.schemaResolver(metaSchema.$coId);
      }
      if (metaSchema) {
        await resolveRecursive(metaSchema);
        if (metaSchema.$id) {
          if (!this.ajv.getSchema(metaSchema.$id)) {
            this.ajv.addMetaSchema(metaSchema, metaSchema.$id);
          }
        }
        if (!this.ajv.getSchema(coId)) {
          this.ajv.addMetaSchema(metaSchema, coId);
        }
        resolvedSchemas.add(coId);
      } else {
        console.warn(`[ValidationEngine] Schema resolver returned null for $schema co-id ${coId}`);
      }
    } catch (error) {
      console.error(`[ValidationEngine] Failed to resolve $schema co-id ${coId}:`, error);
      throw error;
    } finally {
      resolvingSchemas.delete(coId);
    }
  }
  /**
   * Register a resolved schema in AJV
   * @private
   * @param {Object} schema - Schema to register
   * @param {string} ref - Reference ID (should be co-id after transformation)
   * @param {string} coId - Co-id of the schema
   */
  _registerResolvedSchema(schema, ref2, coId) {
    if (ref2 && ref2.startsWith("@schema/")) {
      console.warn(`[ValidationEngine] Warning: Registering schema with @schema/ reference: ${ref2}. This should be a co-id after seeding. Schema may be from source files instead of database.`);
    }
    if (ref2 !== coId && ref2 && !this.ajv.getSchema(ref2)) {
      try {
        withSchemaValidationDisabled(this.ajv, () => {
          this.ajv.addSchema(schema, ref2);
        });
      } catch (error) {
        if (error.message && error.message.includes("already exists")) ;
        else {
          throw error;
        }
      }
    }
    if (coId && !this.ajv.getSchema(coId)) {
      try {
        withSchemaValidationDisabled(this.ajv, () => {
          this.ajv.addSchema(schema, coId);
        });
      } catch (error) {
        if (error.message && error.message.includes("already exists")) ;
        else {
          throw error;
        }
      }
    }
  }
  /**
   * Resolve $co reference and register schema
   * @private
   * @param {string} ref - Reference (co-id or human-readable ID)
   * @param {Set} resolvedSchemas - Set of already resolved schema co-ids
   * @param {Set} resolvingSchemas - Set of schemas currently being resolved
   * @param {Function} resolveRecursive - Recursive resolution function
   * @returns {Promise<void>}
   */
  async _resolveCoReference(ref2, resolvedSchemas, resolvingSchemas, resolveRecursive) {
    if (resolvedSchemas.has(ref2) || resolvingSchemas.has(ref2)) {
      return;
    }
    if (ref2 && ref2.startsWith("@schema/")) {
      console.warn(`[ValidationEngine] Warning: Resolving $co reference with @schema/ pattern: ${ref2}. This should be a co-id after seeding. The schema may not have been transformed correctly.`);
    }
    resolvingSchemas.add(ref2);
    try {
      let referencedSchema = await this.schemaResolver(ref2);
      if (referencedSchema && referencedSchema.$coId && !referencedSchema.$schema) {
        referencedSchema = await this.schemaResolver(referencedSchema.$coId);
      }
      if (!referencedSchema) {
        const errorMsg = `[ValidationEngine] Schema resolver returned null for $co reference ${ref2}. This schema must be registered before it can be referenced. If this is an @schema/... reference, ensure schemas were transformed correctly during seeding.`;
        console.error(errorMsg);
        throw new Error(errorMsg);
      }
      const schemaCoId = referencedSchema.$id;
      if (schemaCoId && resolvedSchemas.has(schemaCoId)) {
        resolvingSchemas.delete(ref2);
        return;
      }
      await resolveRecursive(referencedSchema);
      if (schemaCoId) {
        resolvedSchemas.add(schemaCoId);
      }
      resolvedSchemas.add(ref2);
      this._registerResolvedSchema(referencedSchema, ref2, schemaCoId);
    } catch (error) {
      if (error.message && error.message.includes("already exists")) {
        console.warn(`[ValidationEngine] Duplicate registration handled for ${ref2}`);
      } else {
        console.error(`[ValidationEngine] Failed to resolve $co reference ${ref2}:`, error);
        throw error;
      }
    } finally {
      resolvingSchemas.delete(ref2);
    }
  }
  /**
   * Resolve and register all schema dependencies ($schema and $co references)
   * @private
   * @param {Object} schema - Schema object
   */
  async _resolveAndRegisterSchemaDependencies(schema) {
    if (!schema || typeof schema !== "object" || !this.schemaResolver) {
      return;
    }
    await withSchemaValidationDisabled(this.ajv, async () => {
      const resolvedSchemas = /* @__PURE__ */ new Set();
      const resolvingSchemas = /* @__PURE__ */ new Set();
      const resolveRecursive = async (obj) => {
        if (!obj || typeof obj !== "object") {
          return;
        }
        if (obj.$schema && typeof obj.$schema === "string" && obj.$schema.startsWith("co_z")) {
          await this._resolveSchemaReference(obj.$schema, resolvedSchemas, resolvingSchemas, resolveRecursive);
        }
        if (obj.$co && typeof obj.$co === "string") {
          await this._resolveCoReference(obj.$co, resolvedSchemas, resolvingSchemas, resolveRecursive);
        }
        for (const value of Object.values(obj)) {
          if (Array.isArray(value)) {
            for (const item of value) {
              await resolveRecursive(item);
            }
          } else if (value && typeof value === "object") {
            await resolveRecursive(value);
          }
        }
      };
      await resolveRecursive(schema);
    });
  }
  /**
   * Check if a schema is loaded
   * @param {string} type - Schema type identifier
   * @returns {boolean} True if schema is loaded
   */
  hasSchema(type2) {
    return this.schemas.has(type2);
  }
  /**
   * Validate data against a schema
   * @param {string} type - Schema type identifier
   * @param {any} data - Data to validate
   * @returns {{valid: boolean, errors: Array|null}} Validation result
   */
  async validate(type2, data2) {
    await this.initialize();
    if (!this.schemas.has(type2)) {
      throw new Error(`Schema '${type2}' not loaded. Call loadSchema() first.`);
    }
    const validate2 = this.schemas.get(type2);
    const valid = validate2(data2);
    if (valid) {
      return {
        valid: true,
        errors: null
      };
    }
    const errors2 = validate2.errors || [];
    const formattedErrors = formatValidationErrors(errors2);
    return {
      valid: false,
      errors: formattedErrors
    };
  }
  /**
   * Validate data and throw if invalid
   * @param {string} type - Schema type identifier
   * @param {any} data - Data to validate
   * @param {string} context - Optional context for error message (e.g., file path)
   * @throws {Error} If validation fails
   */
  async validateOrThrow(type2, data2, context = "") {
    const result = await this.validate(type2, data2);
    if (!result.valid) {
      const contextMsg = context ? ` in ${context}` : "";
      const errorDetails = result.errors.map((err) => `  - ${err.instancePath}: ${err.message}`).join("\n");
      throw new Error(
        `Validation failed for '${type2}'${contextMsg}:
${errorDetails}`
      );
    }
    return result;
  }
  /**
   * Load co-type definitions into AJV (REQUIRED for all CoValue validation)
   * @private
   */
  async _loadCoTypeDefinitions() {
    const coTypesDefs2 = await Promise.resolve().then(() => coTypes_defs);
    const coTypesSchema = {
      $id: "https://maia.city/schemas/co-types",
      $defs: coTypesDefs2.$defs
    };
    if (!this.ajv.getSchema(coTypesSchema.$id)) {
      try {
        withSchemaValidationDisabled(this.ajv, () => {
          this.ajv.addSchema(coTypesSchema, coTypesSchema.$id);
        });
      } catch (error) {
        if (!error.message || !error.message.includes("already exists")) {
          console.warn("[ValidationEngine] Failed to add co-type definitions:", error.message);
        }
      }
    }
  }
  /**
   * Register all schemas from registry into AJV (MIGRATIONS/SEEDING ONLY)
   * @param {Object} schemas - Map of schema names to schema definitions
   * @returns {Promise<void>}
   */
  async registerAllSchemas(schemas) {
    await this.initialize();
    if (!schemas || typeof schemas !== "object") {
      return;
    }
    const ajv2 = this.ajv;
    const originalValidateSchema = ajv2.opts.validateSchema;
    ajv2.opts.validateSchema = false;
    try {
      for (const [name, schema] of Object.entries(schemas)) {
        if (schema && schema.$id && !ajv2.getSchema(schema.$id)) {
          try {
            ajv2.addSchema(schema, schema.$id);
          } catch (error) {
            if (!error.message.includes("already exists")) {
              console.warn(`[ValidationEngine] Failed to add schema ${name}:`, error);
            }
          }
        }
      }
    } finally {
      ajv2.opts.validateSchema = originalValidateSchema;
    }
  }
  /**
   * Validate data against a schema by name (MIGRATIONS/SEEDING ONLY)
   * CRITICAL: This method is ONLY for migrations/seeding
   * Runtime validation MUST use validateAgainstSchema() with schema loaded from CoValue header metadata
   * 
   * @param {string} schemaName - Schema name (human-readable ID from registry)
   * @param {any} data - Data to validate
   * @returns {Promise<{valid: boolean, errors: Array|null}>} Validation result
   */
  async validateData(schemaName, data2) {
    await this.initialize();
    if (!this.registrySchemas) {
      throw new Error("[ValidationEngine] validateData() requires registrySchemas. This method is ONLY for migrations/seeding. Runtime validation must use validateAgainstSchema() with schema from CoValue header metadata.");
    }
    const schema = this.registrySchemas[schemaName];
    if (!schema) {
      return {
        valid: false,
        errors: [{ message: `Schema '${schemaName}' not found in registry` }]
      };
    }
    let validate2;
    if (schema.$id) {
      validate2 = this.ajv.getSchema(schema.$id);
    }
    if (!validate2) {
      try {
        await this._resolveAndRegisterSchemaDependencies(schema);
        validate2 = this.ajv.compile(schema);
      } catch (error) {
        return {
          valid: false,
          errors: [{ message: `Failed to compile schema '${schemaName}': ${error.message}` }]
        };
      }
    }
    try {
      const valid = validate2(data2);
      if (valid) {
        return {
          valid: true,
          errors: null
        };
      }
      const errors2 = validate2.errors || [];
      const formattedErrors = formatValidationErrors(errors2);
      return {
        valid: false,
        errors: formattedErrors
      };
    } catch (error) {
      return {
        valid: false,
        errors: [{ message: `Validation error: ${error.message}` }]
      };
    }
  }
}
function transformForSeeding(schemaOrInstance, coIdMap, options = {}) {
  if (!schemaOrInstance || typeof schemaOrInstance !== "object") {
    return schemaOrInstance;
  }
  const schemaRef = schemaOrInstance.$schema;
  const isMetaSchema = schemaRef === "@schema/meta" || typeof schemaRef === "string" && schemaRef.startsWith("https://json-schema.org/") || typeof schemaRef === "string" && schemaRef.startsWith("https://");
  if (isMetaSchema) {
    return transformSchemaForSeeding(schemaOrInstance, coIdMap);
  }
  const hasInstanceProperties = schemaOrInstance.actor !== void 0 || schemaOrInstance.context !== void 0 || schemaOrInstance.view !== void 0 || schemaOrInstance.state !== void 0 || schemaOrInstance.brand !== void 0 || schemaOrInstance.style !== void 0 || schemaOrInstance.inbox !== void 0 || schemaOrInstance.subscribers !== void 0 || schemaOrInstance.name !== void 0 && schemaOrInstance.description !== void 0;
  const isDataSchema = schemaRef && typeof schemaRef === "string" && schemaRef.startsWith("@schema/") && schemaRef !== "@schema/meta";
  if (isDataSchema || hasInstanceProperties) {
    return transformInstanceForSeeding(schemaOrInstance, coIdMap, options);
  }
  const hasSchemaStructure = schemaOrInstance.properties !== void 0 || schemaOrInstance.$defs !== void 0 || schemaOrInstance.items !== void 0 && typeof schemaOrInstance.items === "object" && !Array.isArray(schemaOrInstance.items) || schemaOrInstance.cotype !== void 0;
  if (hasSchemaStructure) {
    return transformSchemaForSeeding(schemaOrInstance, coIdMap);
  }
  return transformInstanceForSeeding(schemaOrInstance, coIdMap, options);
}
function transformSchemaForSeeding(schema, coIdMap) {
  if (!schema || typeof schema !== "object") {
    return schema;
  }
  const transformed = JSON.parse(JSON.stringify(schema));
  if (transformed.$schema) {
    const schemaRef = transformed.$schema;
    if (schemaRef.startsWith("@schema/")) {
      const coId = coIdMap.get(schemaRef);
      if (coId) {
        transformed.$schema = coId;
      }
    }
  }
  if (transformed.$id && typeof transformed.$id === "string") {
    if (transformed.$id.startsWith("@schema/") || transformed.$id.startsWith("https://")) {
      const coId = coIdMap.get(transformed.$id);
      if (coId) {
        transformed.$id = coId;
      }
    }
  }
  if (transformed.properties) {
    transformProperties(transformed.properties, coIdMap);
  }
  if (transformed.$defs) {
    for (const [defName, defSchema] of Object.entries(transformed.$defs)) {
      transformed.$defs[defName] = transformSchemaForSeeding(defSchema, coIdMap);
    }
  }
  const transformedCount = transformCoReferences(transformed, coIdMap, transformed.$id || "root");
  if (transformedCount > 0 && transformed.$id) ;
  if (transformed.items) {
    transformed.items = transformSchemaForSeeding(transformed.items, coIdMap);
  }
  if (transformed.additionalProperties && typeof transformed.additionalProperties === "object") {
    transformed.additionalProperties = transformSchemaForSeeding(transformed.additionalProperties, coIdMap);
  }
  ["allOf", "anyOf", "oneOf"].forEach((keyword2) => {
    if (transformed[keyword2] && Array.isArray(transformed[keyword2])) {
      transformed[keyword2] = transformed[keyword2].map(
        (item) => transformSchemaForSeeding(item, coIdMap)
      );
    }
  });
  return transformed;
}
function transformProperties(properties2, coIdMap) {
  for (const [propName, propSchema] of Object.entries(properties2)) {
    if (propSchema && typeof propSchema === "object") {
      properties2[propName] = transformSchemaForSeeding(propSchema, coIdMap);
    }
  }
}
function transformCoReferences(obj, coIdMap, path = "") {
  if (!obj || typeof obj !== "object") {
    return 0;
  }
  let transformedCount = 0;
  if (obj.$co && typeof obj.$co === "string") {
    const refValue = obj.$co;
    if (refValue.startsWith("co_z")) {
      return 0;
    }
    if (refValue.startsWith("@schema/")) {
      const coId = coIdMap.get(refValue);
      if (coId) {
        obj.$co = coId;
        transformedCount++;
      } else {
        const availableKeys = Array.from(coIdMap.keys()).filter((k) => k.startsWith("@schema/")).slice(0, 10).join(", ");
        console.error(`[SchemaTransformer]  No co-id found for $co reference at ${path || "root"}: ${refValue}. Available schema keys (first 10): ${availableKeys}`);
        throw new Error(`[SchemaTransformer] Failed to transform $co reference: ${refValue}. Schema must be registered before it can be referenced.`);
      }
    }
  }
  for (const [key, value] of Object.entries(obj)) {
    if (key === "$schema" || key === "$id" || key.startsWith("$")) {
      continue;
    }
    if (value && typeof value === "object" && !Array.isArray(value)) {
      const nestedPath = path ? `${path}.${key}` : key;
      transformedCount += transformCoReferences(value, coIdMap, nestedPath);
    } else if (Array.isArray(value)) {
      value.forEach((item, index2) => {
        if (item && typeof item === "object") {
          const arrayPath = path ? `${path}.${key}[${index2}]` : `${key}[${index2}]`;
          transformedCount += transformCoReferences(item, coIdMap, arrayPath);
        }
      });
    }
  }
  return transformedCount;
}
function transformInstanceForSeeding(instance, coIdMap, options = {}) {
  if (!instance || typeof instance !== "object") {
    return instance;
  }
  const transformed = JSON.parse(JSON.stringify(instance));
  if (transformed.$schema) {
    const schemaRef = transformed.$schema;
    if (schemaRef.startsWith("@schema/")) {
      const coId = coIdMap.get(schemaRef);
      if (coId) {
        transformed.$schema = coId;
      }
    }
  }
  if (transformed.$id && typeof transformed.$id === "string") {
    if (!transformed.$id.startsWith("co_z")) {
      const isHumanReadablePattern = transformed.$id.startsWith("@schema/") || transformed.$id.startsWith("vibe/") || transformed.$id.startsWith("actor/") || transformed.$id.startsWith("view/") || transformed.$id.startsWith("context/") || transformed.$id.startsWith("state/") || transformed.$id.startsWith("interface/") || transformed.$id.startsWith("style/") || transformed.$id.startsWith("brand/") || transformed.$id.startsWith("tool/");
      const coId = coIdMap.get(transformed.$id);
      if (coId) {
        transformed.$id = coId;
      } else if (isHumanReadablePattern) {
        console.warn(`[SchemaTransformer] No co-id found for $id: ${transformed.$id}`);
      }
    }
  }
  const referenceProps = ["actor", "context", "view", "state", "brand", "style", "inbox", "subscribers"];
  for (const prop of referenceProps) {
    if (transformed[prop] && typeof transformed[prop] === "string") {
      const ref2 = transformed[prop];
      if (ref2.startsWith("co_z")) {
        continue;
      }
      if (!ref2.startsWith("@")) {
        throw new Error(`[SchemaTransformer] ${prop} reference must use @maiatype/instance format, got: ${ref2}`);
      }
      const coId = coIdMap.get(ref2);
      if (coId) {
        transformed[prop] = coId;
      } else {
        const availableKeys = Array.from(coIdMap.keys()).filter((k) => k.startsWith("@")).slice(0, 10).join(", ");
        throw new Error(
          `[SchemaTransformer] No co-id found for ${prop} reference: ${ref2}. Make sure the referenced instance exists and has a unique $id. Available refs (first 10): ${availableKeys}`
        );
      }
    }
  }
  if (transformed.actors && typeof transformed.actors === "object" && !Array.isArray(transformed.actors)) {
    for (const [namekey, actorRef] of Object.entries(transformed.actors)) {
      if (typeof actorRef === "string") {
        if (actorRef.startsWith("co_z")) {
          continue;
        }
        if (!actorRef.match(/^@[^/]+\/actor\//)) {
          throw new Error(`[SchemaTransformer] context.actors[${namekey}] must use @namespace/actor/instance format, got: ${actorRef}`);
        }
        const coId = coIdMap.get(actorRef);
        if (coId) {
          transformed.actors[namekey] = coId;
        } else {
          throw new Error(
            `[SchemaTransformer] No co-id found for context.actors[${namekey}] reference: ${actorRef}. Make sure the referenced actor exists and has a unique $id.`
          );
        }
      }
    }
  }
  if (transformed.children && typeof transformed.children === "object") {
    for (const [key, childRef] of Object.entries(transformed.children)) {
      if (typeof childRef === "string" && !childRef.startsWith("co_z")) {
        if (!childRef.match(/^@[^/]+\/actor\//)) {
          throw new Error(`[SchemaTransformer] children[${key}] reference must use @namespace/actor/instance format, got: ${childRef}`);
        }
        const coId = coIdMap.get(childRef);
        if (coId) {
          transformed.children[key] = coId;
        } else {
          const availableActors = Array.from(coIdMap.keys()).filter((k) => k.startsWith("@actor/")).slice(0, 10).join(", ");
          throw new Error(
            `[SchemaTransformer] No co-id found for children[${key}] reference: ${childRef}. Available actors (first 10): ${availableActors}`
          );
        }
      }
    }
  }
  if (transformed.items && Array.isArray(transformed.items)) {
    const hasReferences = transformed.items.some(
      (item) => typeof item === "string" && item.startsWith("@") && !item.startsWith("co_z")
    );
    if (hasReferences) {
      transformed.items = transformed.items.map((ref2) => {
        if (typeof ref2 === "string" && !ref2.startsWith("co_z")) {
          if (!ref2.startsWith("@")) {
            throw new Error(`[SchemaTransformer] items array reference must use @maiatype/instance format, got: ${ref2}`);
          }
          const coId = coIdMap.get(ref2);
          if (coId) {
            return coId;
          } else {
            throw new Error(`[SchemaTransformer] No co-id found for items reference: ${ref2}. Make sure the referenced instance exists and has a unique $id.`);
          }
        }
        return ref2;
      });
    }
  }
  if (transformed.source && typeof transformed.source === "string" && !transformed.source.startsWith("co_z")) {
    if (!transformed.source.startsWith("@")) {
      throw new Error(`[SchemaTransformer] source reference must use @actor/instance format, got: ${transformed.source}`);
    }
    const coId = coIdMap.get(transformed.source);
    if (coId) {
      transformed.source = coId;
    } else {
      throw new Error(`[SchemaTransformer] No co-id found for source reference: ${transformed.source}`);
    }
  }
  if (transformed.target && typeof transformed.target === "string" && !transformed.target.startsWith("co_z")) {
    if (!transformed.target.match(/^@[^/]+\/actor\//)) {
      throw new Error(`[SchemaTransformer] target reference must use @namespace/actor/instance format, got: ${transformed.target}`);
    }
    const coId = coIdMap.get(transformed.target);
    if (coId) {
      transformed.target = coId;
    } else {
      throw new Error(`[SchemaTransformer] No co-id found for target reference: ${transformed.target}`);
    }
  }
  if (transformed.states && typeof transformed.states === "object" && !Array.isArray(transformed.states)) {
    for (const [stateName, stateDef] of Object.entries(transformed.states)) {
      if (!stateDef || typeof stateDef !== "object") {
        continue;
      }
      if (stateDef.entry) {
        if (stateDef.entry.tool && stateDef.entry.payload) {
          transformToolPayload(stateDef.entry.payload, coIdMap, transformQueryObjects);
        } else if (stateDef.entry.mapData && typeof stateDef.entry.mapData === "object") {
          const mapData = stateDef.entry.mapData;
          for (const [contextKey, operationConfig] of Object.entries(mapData)) {
            if (operationConfig && typeof operationConfig === "object" && operationConfig.schema && typeof operationConfig.schema === "string") {
              const coId = transformSchemaReference(operationConfig.schema, coIdMap, `mapData.${contextKey}.schema`);
              if (coId) {
                operationConfig.schema = coId;
              }
            }
            if (operationConfig && typeof operationConfig === "object") {
              transformQueryObjects(operationConfig, coIdMap);
            }
          }
        } else if (Array.isArray(stateDef.entry)) {
          transformArrayItems(stateDef.entry, coIdMap, transformQueryObjects);
        } else if (stateDef.entry.payload) {
          transformToolPayload(stateDef.entry.payload, coIdMap, transformQueryObjects);
        }
      }
      if (stateDef.on && typeof stateDef.on === "object") {
        for (const [eventName, transition] of Object.entries(stateDef.on)) {
          if (transition && typeof transition === "object" && Array.isArray(transition.actions)) {
            transformArrayItems(transition.actions, coIdMap, transformQueryObjects);
          }
        }
      }
    }
  }
  transformQueryObjects(transformed, coIdMap);
  return transformed;
}
function transformSchemaReference(schemaRef, coIdMap, context = "") {
  if (schemaRef.startsWith("@schema/") && !schemaRef.startsWith("co_z")) {
    const coId = coIdMap.get(schemaRef);
    if (coId) {
      return coId;
    } else {
      console.warn(`[SchemaTransformer] No co-id found for ${context} schema: ${schemaRef}. Make sure data collections are registered before transformation.`);
      return null;
    }
  }
  return schemaRef;
}
function transformTargetReference(targetRef, coIdMap, context = "") {
  if (targetRef.match(/^@[^/]+\/actor\//) && !targetRef.startsWith("co_z")) {
    const coId = coIdMap.get(targetRef);
    if (coId) {
      return coId;
    } else {
      const actorKeys = Array.from(coIdMap.keys()).filter((k) => k.includes("actor") || k.includes("vibe") || k.includes("composite"));
      const keyCount = actorKeys.length;
      const keySample = actorKeys.slice(0, context.includes("array") ? 10 : 20).join(", ");
      const keySuffix = keyCount > (context.includes("array") ? 10 : 20) ? "..." : "";
      console.warn(`[SchemaTransformer]  No co-id found for ${context} target: ${targetRef}. Available actor keys (${keyCount}): ${keySample}${keySuffix}`);
      return null;
    }
  }
  return targetRef;
}
function transformQueryObjectSchema(queryObj, coIdMap) {
  if ("key" in queryObj && !("op" in queryObj)) {
    return;
  }
  if (queryObj.schema && typeof queryObj.schema === "string") {
    const coId = transformSchemaReference(queryObj.schema, coIdMap, "query object");
    if (coId) {
      queryObj.schema = coId;
    }
  }
}
function transformToolPayload(payload, coIdMap, transformRecursive) {
  if (!payload || typeof payload !== "object") {
    return;
  }
  transformRecursive(payload, coIdMap);
  if (payload.schema && typeof payload.schema === "string") {
    const coId = transformSchemaReference(payload.schema, coIdMap, "tool payload");
    if (coId) {
      payload.schema = coId;
    }
  }
  if (payload.target && typeof payload.target === "string") {
    const coId = transformTargetReference(payload.target, coIdMap, "tool payload");
    if (coId) {
      payload.target = coId;
    }
  }
}
function transformActionPayload(action, coIdMap, transformRecursive) {
  if (!action.payload || typeof action.payload !== "object") {
    return;
  }
  if (action.payload.target && typeof action.payload.target === "string") {
    const coId = transformTargetReference(action.payload.target, coIdMap, "tool action");
    if (coId) {
      action.payload.target = coId;
    }
  }
  transformRecursive(action.payload, coIdMap);
}
function transformArrayItems(arr, coIdMap, transformRecursive) {
  for (let i = 0; i < arr.length; i++) {
    const item = arr[i];
    if (item && typeof item === "object") {
      if (item.mapData && typeof item.mapData === "object") {
        for (const [contextKey, operationConfig] of Object.entries(item.mapData)) {
          if (operationConfig && typeof operationConfig === "object" && operationConfig.schema && typeof operationConfig.schema === "string") {
            const coId = transformSchemaReference(operationConfig.schema, coIdMap, `mapData.${contextKey}.schema in array`);
            if (coId) {
              operationConfig.schema = coId;
            }
          }
          if (operationConfig && typeof operationConfig === "object") {
            transformRecursive(operationConfig, coIdMap);
          }
        }
      } else if (item.tool && typeof item.tool === "string" && item.payload && typeof item.payload === "object") {
        transformActionPayload(item, coIdMap, transformRecursive);
        transformToolPayload(item.payload, coIdMap, transformRecursive);
      } else if (item.payload && typeof item.payload === "object") {
        if (item.payload.target && typeof item.payload.target === "string") {
          const coId = transformTargetReference(item.payload.target, coIdMap, "action payload.target in array");
          if (coId) {
            item.payload.target = coId;
          }
        }
        transformToolPayload(item.payload, coIdMap, transformRecursive);
      } else {
        transformRecursive(item, coIdMap);
      }
    } else if (typeof item === "string" && item.startsWith("@actor/") && !item.startsWith("co_z")) {
      const coId = coIdMap.get(item);
      if (coId) {
        arr[i] = coId;
      }
    }
  }
}
function transformQueryObjects(obj, coIdMap, depth = 0) {
  if (!obj || typeof obj !== "object" || Array.isArray(obj)) {
    return;
  }
  for (const [key, value] of Object.entries(obj)) {
    if (key === "$schema" || key === "$id" || key.startsWith("$")) {
      continue;
    }
    if (key === "schema" && typeof value === "string") {
      const coId = transformSchemaReference(value, coIdMap, "top-level schema field");
      if (coId) {
        obj[key] = coId;
      }
      continue;
    }
    if (key === "@actors" && value && typeof value === "object" && !Array.isArray(value)) {
      for (const [namekey, actorRef] of Object.entries(value)) {
        if (typeof actorRef === "string") {
          if (actorRef.startsWith("co_z")) {
            continue;
          }
          if (!actorRef.match(/^@[^/]+\/actor\//)) {
            throw new Error(`[SchemaTransformer] context.@actors[${namekey}] must use @namespace/actor/instance format, got: ${actorRef}`);
          }
          const coId = transformTargetReference(actorRef, coIdMap, `context.@actors[${namekey}]`);
          if (coId) {
            value[namekey] = coId;
          }
        }
      }
      continue;
    }
    if (key === "actors" && value && typeof value === "object" && !Array.isArray(value)) {
      throw new Error(`[SchemaTransformer] Legacy "actors" property found. Please migrate to "@actors" system property.`);
    }
    if (key === "target" && typeof value === "string") {
      const coId = transformTargetReference(value, coIdMap, "target field");
      if (coId) {
        obj[key] = coId;
      }
      continue;
    }
    if (value && typeof value === "object" && !Array.isArray(value)) {
      if (value.mapData && typeof value.mapData === "object") {
        const mapData = value.mapData;
        for (const [contextKey, operationConfig] of Object.entries(mapData)) {
          if (operationConfig && typeof operationConfig === "object" && operationConfig.schema && typeof operationConfig.schema === "string") {
            const coId = transformSchemaReference(operationConfig.schema, coIdMap, `mapData.${contextKey}.schema`);
            if (coId) {
              operationConfig.schema = coId;
            }
          }
          if (operationConfig && typeof operationConfig === "object") {
            transformQueryObjects(operationConfig, coIdMap, depth + 1);
          }
        }
        continue;
      } else if (value.schema && typeof value.schema === "string" && !("key" in value) && !("op" in value)) {
        transformQueryObjectSchema(value, coIdMap);
      } else if (value.payload && typeof value.payload === "object") {
        transformToolPayload(value.payload, coIdMap, transformQueryObjects);
      } else if (value.tool && typeof value.tool === "string" && value.payload && typeof value.payload === "object") {
        transformActionPayload(value, coIdMap, transformQueryObjects);
      } else {
        transformQueryObjects(value, coIdMap, depth + 1);
      }
    } else if (value && typeof value === "object" && Array.isArray(value)) {
      transformArrayItems(value, coIdMap, transformQueryObjects);
    }
  }
}
function validateSchemaStructure(schema, path = "", options = {}) {
  const { checkSchemaReferences = true, checkNestedCoTypes = true } = options;
  const errors2 = [];
  if (!schema || typeof schema !== "object") {
    return errors2;
  }
  if (checkSchemaReferences) {
    if (schema.$co && typeof schema.$co === "string") {
      if (schema.$co.startsWith("@schema/")) {
        errors2.push(`Found @schema/ reference in $co at ${path || "root"}: ${schema.$co}. All $co references must be transformed to co-ids.`);
      }
    }
    if (schema.$schema && typeof schema.$schema === "string" && schema.$schema.startsWith("@schema/")) {
      errors2.push(`Found @schema/ reference in $schema at ${path || "root"}: ${schema.$schema}. $schema must be transformed to co-id.`);
    }
    if (schema.$id && typeof schema.$id === "string" && schema.$id.startsWith("@schema/")) {
      errors2.push(`Found @schema/ reference in $id at ${path || "root"}: ${schema.$id}. $id must be transformed to co-id.`);
    }
  }
  if (checkNestedCoTypes) {
    if (schema.cotype) {
      if (path !== "") {
        errors2.push(`Nested co-type detected at ${path}. Use \`$co\` keyword to reference a separate CoValue entity instead.`);
        return errors2;
      }
    }
  }
  for (const [key, value] of Object.entries(schema)) {
    if (value && typeof value === "object" && !Array.isArray(value)) {
      const nestedPath = path ? `${path}.${key}` : key;
      const nestedErrors = validateSchemaStructure(value, nestedPath, options);
      errors2.push(...nestedErrors);
    } else if (Array.isArray(value)) {
      value.forEach((item, index2) => {
        if (item && typeof item === "object") {
          const arrayPath = path ? `${path}.${key}[${index2}]` : `${key}[${index2}]`;
          const arrayErrors = validateSchemaStructure(item, arrayPath, options);
          errors2.push(...arrayErrors);
        }
      });
    }
  }
  return errors2;
}
const schemaTransformer = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  transformForSeeding,
  validateSchemaStructure
}, Symbol.toStringTag, { value: "Module" }));
class CoIdRegistry {
  constructor() {
    this.registry = /* @__PURE__ */ new Map();
    this.reverseRegistry = /* @__PURE__ */ new Map();
  }
  /**
   * Register a co-id for a human-readable ID
   * @param {string} humanId - Human-readable ID (e.g., "@schema/actor", "actor_001")
   * @param {string} coId - Generated co-id
   */
  register(humanId, coId) {
    if (this.registry.has(humanId)) {
      const existingCoId = this.registry.get(humanId);
      if (existingCoId !== coId) {
        throw new Error(`Co-id already registered for ${humanId}: ${existingCoId} (trying to register ${coId})`);
      }
      return;
    }
    this.registry.set(humanId, coId);
    if (!this.reverseRegistry.has(coId)) {
      this.reverseRegistry.set(coId, humanId);
    }
  }
  /**
   * Get co-id for a human-readable ID
   * @param {string} humanId - Human-readable ID
   * @returns {string|null} Co-id or null if not found
   */
  get(humanId) {
    return this.registry.get(humanId) || null;
  }
  /**
   * Get human-readable ID for a co-id
   * @param {string} coId - Co-id
   * @returns {string|null} Human-readable ID or null if not found
   */
  getHumanId(coId) {
    return this.reverseRegistry.get(coId) || null;
  }
  /**
   * Check if human-readable ID is registered
   * @param {string} humanId - Human-readable ID
   * @returns {boolean}
   */
  has(humanId) {
    return this.registry.has(humanId);
  }
  /**
   * Get all registered mappings
   * @returns {Map<string, string>} Map of human-readable ID  co-id
   */
  getAll() {
    return new Map(this.registry);
  }
  /**
   * Clear all registrations
   */
  clear() {
    this.registry.clear();
    this.reverseRegistry.clear();
  }
}
const coIdGenerator = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CoIdRegistry
}, Symbol.toStringTag, { value: "Module" }));
const $schema$r = "@schema/meta";
const $id$s = "@schema/actor";
const title$r = "@schema/actor";
const description$h = "Pure declarative actor specification";
const cotype$i = "comap";
const indexing$i = true;
const properties$o = { "role": { "type": "string", "description": "Actor role (e.g., 'kanban-view', 'vibe', 'composite', 'leaf')" }, "context": { "$co": "@schema/context", "description": "Co-id reference to context definition" }, "view": { "$co": "@schema/view", "description": "Co-id reference to view definition" }, "state": { "$co": "@schema/state", "description": "Co-id reference to state machine definition" }, "brand": { "$co": "@schema/style", "description": "Co-id reference to brand style definition (uses style schema)" }, "style": { "$co": "@schema/style", "description": "Co-id reference to local style definition" }, "inbox": { "$co": "@schema/inbox", "description": "Co-id reference to message inbox costream (append-only message feed)" } };
const actorSchema = {
  $schema: $schema$r,
  $id: $id$s,
  title: title$r,
  description: description$h,
  cotype: cotype$i,
  indexing: indexing$i,
  properties: properties$o
};
const $schema$q = "@schema/meta";
const $id$r = "@schema/context";
const title$q = "@schema/context";
const description$g = "Runtime data for an actor (flexible JSON structure). The context itself is a comap CoValue (for CRDT sync/versioning), but all inner properties are plain JS objects/arrays/strings - NOT CoJSON types.";
const cotype$h = "comap";
const indexing$h = true;
const additionalProperties$9 = { "description": "Any context fields (query objects, collections, UI state, form values, etc.). Query objects have schema + options properties. All inner properties are plain JS types (objects/arrays/strings/primitives) - NOT CoJSON types.", "anyOf": [{ "type": "object", "description": "Query object for reactive subscription (has schema property). Can include nested options object with map, filter, etc.", "properties": { "schema": { "type": "string", "description": "Schema reference (e.g., '@schema/message' or co-id)" }, "options": { "type": "object", "description": "Query options (map, filter, etc.)", "properties": { "map": { "type": "object", "description": "Map transformation expressions (e.g., { sender: '$$source.role' })", "additionalProperties": { "type": "string" } }, "filter": { "description": "Filter criteria", "oneOf": [{ "type": "object" }, { "type": "null" }] } }, "additionalProperties": true }, "filter": { "description": "Filter criteria (legacy - use options.filter instead)", "oneOf": [{ "type": "object" }, { "type": "null" }] } }, "required": ["schema"], "additionalProperties": true }, { "type": "array", "description": "Array of data items (after SubscriptionEngine processes the query object)" }, { "type": "string" }, { "type": "number" }, { "type": "boolean" }, { "type": "null" }, { "type": "object", "description": "Any other nested object (UI state, form values, etc.)" }] };
const contextSchema = {
  $schema: $schema$q,
  $id: $id$r,
  title: title$q,
  description: description$g,
  cotype: cotype$h,
  indexing: indexing$h,
  additionalProperties: additionalProperties$9
};
const $schema$p = "@schema/meta";
const $id$q = "@schema/state";
const title$p = "@schema/state";
const description$f = "XState-like state machine with states, transitions, guards, and actions";
const cotype$g = "comap";
const indexing$g = true;
const required$8 = ["initial", "states"];
const properties$n = { "initial": { "type": "string", "description": "Initial state name" }, "states": { "type": "object", "description": "State definitions", "additionalProperties": { "type": "object", "properties": { "entry": { "oneOf": [{ "type": "object", "description": "Inline tool action object", "properties": { "tool": { "type": "string", "description": "Tool identifier" }, "payload": { "type": "object", "description": "Tool payload", "additionalProperties": true } }, "required": ["tool"] }, { "type": "object", "description": "Infrastructure context update action", "properties": { "updateContext": { "type": "object", "description": "Context updates (infrastructure, not a tool)", "additionalProperties": true } }, "required": ["updateContext"] }, { "type": "object", "description": "Map operations engine configs to context keys (universal API)", "properties": { "mapData": { "type": "object", "description": "Map operations engine configs to context keys (universal API)", "additionalProperties": { "type": "object", "description": "Operations engine config (op, schema, filter, key, keys, etc.)", "properties": { "op": { "type": "string", "description": "Operation type (read, create, update, delete, schema, resolve, etc.)", "default": "read" } }, "additionalProperties": true } } }, "required": ["mapData"] }, { "type": "array", "description": "Array of inline action objects", "items": { "oneOf": [{ "type": "object", "properties": { "tool": { "type": "string", "description": "Tool identifier" }, "payload": { "type": "object", "description": "Tool payload", "additionalProperties": true } }, "required": ["tool"] }, { "type": "object", "properties": { "updateContext": { "type": "object", "description": "Context updates (infrastructure, not a tool)", "additionalProperties": true } }, "required": ["updateContext"] }, { "type": "object", "properties": { "mapData": { "type": "object", "description": "Map operations engine configs to context keys (universal API)", "additionalProperties": { "type": "object", "description": "Operations engine config (op, schema, filter, key, keys, etc.)", "properties": { "op": { "type": "string", "description": "Operation type (read, create, update, delete, schema, resolve, etc.)", "default": "read" } }, "additionalProperties": true } } }, "required": ["mapData"] }] } }, { "$co": "@schema/action", "description": "Co-id reference to action CoValue" }, { "type": "array", "description": "Array of action co-id references", "items": { "$co": "@schema/action" } }] }, "exit": { "oneOf": [{ "type": "object", "description": "Inline tool action object", "properties": { "tool": { "type": "string", "description": "Tool identifier" }, "payload": { "type": "object", "description": "Tool payload", "additionalProperties": true } }, "required": ["tool"] }, { "type": "object", "description": "Infrastructure context update action", "properties": { "updateContext": { "type": "object", "description": "Context updates (infrastructure, not a tool)", "additionalProperties": true } }, "required": ["updateContext"] }, { "type": "object", "description": "Map operations engine configs to context keys (universal API)", "properties": { "mapData": { "type": "object", "description": "Map operations engine configs to context keys (universal API)", "additionalProperties": { "type": "object", "description": "Operations engine config (op, schema, filter, key, keys, etc.)", "properties": { "op": { "type": "string", "description": "Operation type (read, create, update, delete, schema, resolve, etc.)", "default": "read" } }, "additionalProperties": true } } }, "required": ["mapData"] }, { "type": "array", "description": "Array of inline action objects", "items": { "oneOf": [{ "type": "object", "properties": { "tool": { "type": "string", "description": "Tool identifier" }, "payload": { "type": "object", "description": "Tool payload", "additionalProperties": true } }, "required": ["tool"] }, { "type": "object", "properties": { "updateContext": { "type": "object", "description": "Context updates (infrastructure, not a tool)", "additionalProperties": true } }, "required": ["updateContext"] }, { "type": "object", "properties": { "mapData": { "type": "object", "description": "Map operations engine configs to context keys (universal API)", "additionalProperties": { "type": "object", "description": "Operations engine config (op, schema, filter, key, keys, etc.)", "properties": { "op": { "type": "string", "description": "Operation type (read, create, update, delete, schema, resolve, etc.)", "default": "read" } }, "additionalProperties": true } } }, "required": ["mapData"] }] } }, { "$co": "@schema/action", "description": "Co-id reference to action CoValue" }, { "type": "array", "description": "Array of action co-id references", "items": { "$co": "@schema/action" } }] }, "on": { "type": "object", "description": "Event handlers (transitions)", "additionalProperties": { "oneOf": [{ "type": "string", "description": "Simple target state name" }, { "type": "object", "description": "Inline transition object", "properties": { "target": { "type": "string", "description": "Target state name" }, "guard": { "type": "object", "description": "Guard condition", "additionalProperties": true }, "actions": { "type": "array", "description": "Transition actions", "items": { "oneOf": [{ "type": "object", "properties": { "tool": { "type": "string", "description": "Tool identifier" }, "payload": { "type": "object", "additionalProperties": true } }, "required": ["tool"] }, { "type": "object", "properties": { "updateContext": { "type": "object", "description": "Context updates (infrastructure, not a tool)", "additionalProperties": true } }, "required": ["updateContext"] }, { "$co": "@schema/action" }] } } }, "required": ["target"] }, { "$co": "@schema/transition", "description": "Co-id reference to transition CoValue" }] } } }, "additionalProperties": false } } };
const stateSchema = {
  $schema: $schema$p,
  $id: $id$q,
  title: title$p,
  description: description$f,
  cotype: cotype$g,
  indexing: indexing$g,
  required: required$8,
  properties: properties$n
};
const $schema$o = "@schema/meta";
const $id$p = "@schema/view";
const title$o = "@schema/view";
const description$e = "UI structure definition with DOM tree, expressions, loops, and event handlers (recursive viewNode structure)";
const cotype$f = "comap";
const indexing$f = true;
const properties$m = { "content": { "type": "object", "description": "View content structure (recursive viewNode)", "$ref": "#/$defs/viewNode" } };
const $defs$4 = { "viewNode": { "type": "object", "description": "Recursive DOM node structure", "properties": { "tag": { "type": "string" }, "class": { "type": "string" }, "text": { "anyOf": [{ "type": "string", "pattern": "^\\$\\$" }, { "type": "string", "pattern": "^@" }, { "type": "string", "pattern": "^\\$[^$]" }, { "type": "string" }, { "type": "number" }, { "type": "boolean" }, { "type": "null" }] }, "value": { "anyOf": [{ "type": "string", "pattern": "^\\$\\$" }, { "type": "string", "pattern": "^@" }, { "type": "string", "pattern": "^\\$[^$]" }, { "type": "string" }, { "type": "number" }, { "type": "boolean" }, { "type": "null" }] }, "attrs": { "type": "object", "additionalProperties": { "anyOf": [{ "type": "string", "pattern": "^\\$\\$" }, { "type": "string", "pattern": "^@" }, { "type": "string", "pattern": "^\\$[^$]" }, { "type": "string" }, { "type": "number" }, { "type": "boolean" }, { "type": "null" }, { "type": "object", "additionalProperties": { "anyOf": [{ "type": "string", "pattern": "^\\$\\$" }, { "type": "string", "pattern": "^@" }, { "type": "string", "pattern": "^\\$[^$]" }, { "type": "string" }, { "type": "number" }, { "type": "boolean" }, { "type": "null" }] } }] } }, "children": { "type": "array", "items": { "$ref": "#/$defs/viewNode" } }, "$on": { "type": "object", "additionalProperties": { "type": "object", "properties": { "send": { "type": "string" }, "payload": { "type": "object", "additionalProperties": true }, "key": { "type": "string" } }, "required": ["send"] } }, "$each": { "type": "object", "properties": { "items": { "anyOf": [{ "type": "string", "pattern": "^\\$\\$" }, { "type": "string", "pattern": "^@" }, { "type": "string", "pattern": "^\\$[^$]" }, { "type": "string" }, { "type": "number" }, { "type": "boolean" }, { "type": "null" }] }, "template": { "$ref": "#/$defs/viewNode" } }, "required": ["items", "template"] }, "$slot": { "anyOf": [{ "type": "string", "pattern": "^\\$\\$" }, { "type": "string", "pattern": "^@" }, { "type": "string", "pattern": "^\\$[^$]" }, { "type": "string" }, { "type": "number" }, { "type": "boolean" }, { "type": "null" }] } }, "additionalProperties": false } };
const additionalProperties$8 = false;
const viewSchema = {
  $schema: $schema$o,
  $id: $id$p,
  title: title$o,
  description: description$e,
  cotype: cotype$f,
  indexing: indexing$f,
  properties: properties$m,
  $defs: $defs$4,
  additionalProperties: additionalProperties$8
};
const $schema$n = "@schema/meta";
const $id$o = "@schema/style";
const title$n = "@schema/style";
const description$d = "Style definition (brand or actor-specific). Brand styles typically include selectors, actor styles are overrides.";
const cotype$e = "comap";
const indexing$e = true;
const properties$l = { "tokens": { "type": "object", "description": "Design tokens (colors, spacing, typography, etc.)", "additionalProperties": true }, "components": { "type": "object", "description": "Component styles", "additionalProperties": true }, "selectors": { "type": "object", "description": "CSS selector-based styles (typically used in brand styles)", "additionalProperties": { "type": "object", "description": "CSS properties and values", "additionalProperties": { "oneOf": [{ "type": "string" }, { "type": "number" }, { "type": "object", "additionalProperties": true }] } } } };
const styleSchema = {
  $schema: $schema$n,
  $id: $id$o,
  title: title$n,
  description: description$d,
  cotype: cotype$e,
  indexing: indexing$e,
  properties: properties$l
};
const $schema$m = "@schema/meta";
const $id$n = "@schema/tool";
const title$m = "@schema/tool";
const description$c = "Tool metadata (AI-compatible JSON schema)";
const cotype$d = "comap";
const indexing$d = true;
const required$7 = ["name", "description", "parameters"];
const properties$k = { "name": { "type": "string", "description": "Tool identifier (e.g., '@mutation/create')", "pattern": "^@" }, "description": { "type": "string", "description": "Tool description" }, "parameters": { "type": "object", "description": "JSON Schema for tool parameters (standard JSON Schema format)", "properties": { "type": { "type": "string", "enum": ["object", "array", "string", "number", "boolean", "null"] }, "properties": { "type": "object", "additionalProperties": { "type": "object", "description": "Parameter property schema", "properties": { "type": { "type": "string" }, "description": { "type": "string" }, "required": { "type": "boolean" }, "properties": { "type": "object", "additionalProperties": true } }, "additionalProperties": true } }, "required": { "type": "array", "items": { "type": "string" } } }, "required": ["type"], "additionalProperties": true } };
const toolSchema = {
  $schema: $schema$m,
  $id: $id$n,
  title: title$m,
  description: description$c,
  cotype: cotype$d,
  indexing: indexing$d,
  required: required$7,
  properties: properties$k
};
const $schema$l = "@schema/meta";
const $id$m = "@schema/vibe";
const title$l = "@schema/vibe";
const description$b = "Vibe manifest/metadata";
const cotype$c = "comap";
const indexing$c = true;
const required$6 = ["name", "description", "actor"];
const properties$j = { "name": { "type": "string", "description": "Vibe name" }, "description": { "type": "string", "description": "Vibe description" }, "actor": { "$co": "@schema/actor", "description": "Co-id reference to actor definition (root actor for this vibe)" } };
const vibeSchema = {
  $schema: $schema$l,
  $id: $id$m,
  title: title$l,
  description: description$b,
  cotype: cotype$c,
  indexing: indexing$c,
  required: required$6,
  properties: properties$j
};
const $schema$k = "@schema/meta";
const $id$l = "@schema/message";
const title$k = "@schema/message";
const description$a = "Actor message for state machine transitions";
const cotype$b = "comap";
const indexing$b = true;
const required$5 = ["type"];
const properties$i = { "type": { "type": "string", "description": "Message type (event name)" }, "payload": { "type": "object", "description": "Message payload data" }, "source": { "$co": "@schema/actor", "description": "Co-id reference to source actor" }, "target": { "$co": "@schema/actor", "description": "Co-id reference to target actor (required for direct messaging)" }, "processed": { "type": "boolean", "description": "Whether this message has been processed", "default": false } };
const messageSchema = {
  $schema: $schema$k,
  $id: $id$l,
  title: title$k,
  description: description$a,
  cotype: cotype$b,
  indexing: indexing$b,
  required: required$5,
  properties: properties$i
};
const $schema$j = "@schema/meta";
const $id$k = "@schema/guard";
const title$j = "@schema/guard";
const description$9 = "Guard condition for state machine transitions";
const cotype$a = "comap";
const indexing$a = true;
const properties$h = {};
const additionalProperties$7 = true;
const guardSchema = {
  $schema: $schema$j,
  $id: $id$k,
  title: title$j,
  description: description$9,
  cotype: cotype$a,
  indexing: indexing$a,
  properties: properties$h,
  additionalProperties: additionalProperties$7
};
const $schema$i = "@schema/meta";
const $id$j = "@schema/action";
const title$i = "@schema/action";
const description$8 = "Action (tool invocation, context update, or data mapping)";
const cotype$9 = "comap";
const indexing$9 = true;
const oneOf$1 = [{ "type": "object", "properties": { "tool": { "type": "string", "description": "Tool identifier (e.g., '@mutation/create')" }, "payload": { "description": "Tool payload (can contain expressions)", "type": "object", "additionalProperties": true } }, "required": ["tool"] }, { "type": "object", "properties": { "updateContext": { "type": "object", "description": "Context updates (infrastructure, not a tool)", "additionalProperties": true } }, "required": ["updateContext"] }, { "type": "object", "properties": { "mapData": { "type": "object", "description": "Map operations engine configs to context keys (universal API)", "additionalProperties": { "type": "object", "description": "Operations engine config (op, schema, filter, key, keys, etc.)", "properties": { "op": { "type": "string", "description": "Operation type (read, create, update, delete, schema, resolve, etc.)", "default": "read" } }, "additionalProperties": true } } }, "required": ["mapData"] }];
const actionSchema = {
  $schema: $schema$i,
  $id: $id$j,
  title: title$i,
  description: description$8,
  cotype: cotype$9,
  indexing: indexing$9,
  oneOf: oneOf$1
};
const $schema$h = "@schema/meta";
const $id$i = "@schema/transition";
const title$h = "@schema/transition";
const description$7 = "State machine transition";
const cotype$8 = "comap";
const indexing$8 = true;
const properties$g = { "target": { "type": "string", "description": "Target state name" }, "guard": { "$co": "@schema/guard" }, "actions": { "type": "array", "items": { "$co": "@schema/action" } } };
const required$4 = ["target"];
const transitionSchema = {
  $schema: $schema$h,
  $id: $id$i,
  title: title$h,
  description: description$7,
  cotype: cotype$8,
  indexing: indexing$8,
  properties: properties$g,
  required: required$4
};
const $schema$g = "@schema/meta";
const $id$h = "@schema/messagePayload";
const title$g = "@schema/messagePayload";
const description$6 = "Message payload definition";
const cotype$7 = "comap";
const indexing$7 = true;
const properties$f = {};
const additionalProperties$6 = true;
const messagePayloadSchema = {
  $schema: $schema$g,
  $id: $id$h,
  title: title$g,
  description: description$6,
  cotype: cotype$7,
  indexing: indexing$7,
  properties: properties$f,
  additionalProperties: additionalProperties$6
};
const $schema$f = "@schema/meta";
const $id$g = "@schema/maia-script-expression";
const title$f = "@schema/maia-script-expression";
const cotype$6 = "comap";
const indexing$6 = false;
const description$5 = "JSON-based DSL expression schema for MaiaScript runtime logic. Supports data access, comparisons, logical operations, control flow, and nested expressions.";
const anyOf$1 = [{ "description": "Primitive value", "type": ["number", "boolean", "null"] }, { "description": "String value (including shortcut syntax $key or $$key)", "type": "string" }, { "$ref": "#/$defs/expressionObject" }];
const $defs$3 = { "expressionObject": { "description": "MaiaScript expression object (DSL operation)", "type": "object", "oneOf": [{ "description": "$context operation - access context data", "properties": { "$context": { "type": "string", "description": "Dot-separated path in context object (e.g., 'user.name')", "pattern": "^[a-zA-Z_][a-zA-Z0-9_]*(\\.[a-zA-Z_][a-zA-Z0-9_]*)*$" } }, "required": ["$context"], "additionalProperties": false }, { "description": "$item operation - access item data", "properties": { "$item": { "type": "string", "description": "Dot-separated path in item object (e.g., 'id', 'status.value')", "pattern": "^[a-zA-Z_][a-zA-Z0-9_]*(\\.[a-zA-Z_][a-zA-Z0-9_]*)*$" } }, "required": ["$item"], "additionalProperties": false }, { "description": "$eq operation - equality comparison", "properties": { "$eq": { "type": "array", "description": "Array of two expressions to compare", "items": { "$ref": "#" }, "minItems": 2, "maxItems": 2 } }, "required": ["$eq"], "additionalProperties": false }, { "description": "$ne operation - inequality comparison", "properties": { "$ne": { "type": "array", "description": "Array of two expressions to compare", "items": { "$ref": "#" }, "minItems": 2, "maxItems": 2 } }, "required": ["$ne"], "additionalProperties": false }, { "description": "$not operation - logical NOT (negate boolean)", "properties": { "$not": { "$ref": "#", "description": "Expression to negate (evaluated to boolean, then negated)" } }, "required": ["$not"], "additionalProperties": false }, { "description": "$and operation - logical AND (all operands must be truthy)", "properties": { "$and": { "type": "array", "description": "Array of expressions to evaluate (all must be truthy)", "items": { "$ref": "#" }, "minItems": 1 } }, "required": ["$and"], "additionalProperties": false }, { "description": "$or operation - logical OR (at least one operand must be truthy)", "properties": { "$or": { "type": "array", "description": "Array of expressions to evaluate (at least one must be truthy)", "items": { "$ref": "#" }, "minItems": 1 } }, "required": ["$or"], "additionalProperties": false }, { "description": "$trim operation - trim whitespace from string", "properties": { "$trim": { "$ref": "#", "description": "Expression to trim (evaluated to string, then trimmed of leading/trailing whitespace)" } }, "required": ["$trim"], "additionalProperties": false }, { "description": "$gt operation - greater than comparison", "properties": { "$gt": { "type": "array", "description": "Array of two expressions to compare (left > right)", "items": { "$ref": "#" }, "minItems": 2, "maxItems": 2 } }, "required": ["$gt"], "additionalProperties": false }, { "description": "$length operation - get array or string length", "properties": { "$length": { "$ref": "#", "description": "Expression to get length of (evaluated to array or string)" } }, "required": ["$length"], "additionalProperties": false }, { "description": "$concat operation - concatenate arrays", "properties": { "$concat": { "type": "array", "description": "Array of expressions, arrays, or objects to concatenate (all evaluated to arrays, then flattened)", "items": { "anyOf": [{ "$ref": "#" }, { "type": ["array", "object", "string", "number", "boolean", "null"] }] }, "minItems": 1 } }, "required": ["$concat"], "additionalProperties": false }, { "description": "$map operation - map over array", "properties": { "$map": { "type": "object", "description": "Map configuration object", "properties": { "array": { "$ref": "#", "description": "Expression evaluating to array to map over" }, "as": { "type": "string", "description": "Variable name for each item in the array (default: 'item')" }, "return": { "description": "Expression, object, or array to evaluate for each item (result becomes item in returned array). 'do' is also supported as an alias.", "anyOf": [{ "$ref": "#" }, { "type": ["object", "array", "string", "number", "boolean", "null"] }] }, "do": { "description": "Alias for 'return' - expression, object, or array to evaluate for each item", "anyOf": [{ "$ref": "#" }, { "type": ["object", "array", "string", "number", "boolean", "null"] }] } }, "required": ["array"], "additionalProperties": false } }, "required": ["$map"], "additionalProperties": false }, { "description": "$if operation - conditional expression", "properties": { "$if": { "type": "object", "description": "Conditional expression object", "properties": { "condition": { "$ref": "#", "description": "Condition expression (evaluated to boolean)" }, "then": { "$ref": "#", "description": "Expression to evaluate if condition is true" }, "else": { "$ref": "#", "description": "Expression to evaluate if condition is false" } }, "required": ["condition", "then", "else"], "additionalProperties": false } }, "required": ["$if"], "additionalProperties": false }] } };
const expressionSchema = {
  $schema: $schema$f,
  $id: $id$g,
  title: title$f,
  cotype: cotype$6,
  indexing: indexing$6,
  description: description$5,
  anyOf: anyOf$1,
  $defs: $defs$3
};
const $schema$e = "@schema/meta";
const $id$f = "@schema/subscribers";
const title$e = "@schema/subscribers";
const description$4 = "A colist of actor co-ids subscribed to a topic";
const cotype$5 = "colist";
const indexing$5 = true;
const items$2 = { "$co": "@schema/actor", "description": "Each item is a co-id reference to an actor subscribed to this topic" };
const subscribersSchema = {
  $schema: $schema$e,
  $id: $id$f,
  title: title$e,
  description: description$4,
  cotype: cotype$5,
  indexing: indexing$5,
  items: items$2
};
const $schema$d = "@schema/meta";
const $id$e = "@schema/inbox";
const title$d = "@schema/inbox";
const description$3 = "A costream (append-only stream) of messages received by this actor";
const cotype$4 = "costream";
const indexing$4 = true;
const items$1 = { "$co": "@schema/message", "description": "Each item is a co-id reference to a message" };
const inboxSchema = {
  $schema: $schema$d,
  $id: $id$e,
  title: title$d,
  description: description$3,
  cotype: cotype$4,
  indexing: indexing$4,
  items: items$1
};
const $schema$c = "@schema/meta";
const $id$d = "@schema/children";
const title$c = "@schema/children";
const description$2 = "A comap of child actors (namekey  actor co-id)";
const cotype$3 = "comap";
const indexing$3 = true;
const properties$e = {};
const additionalProperties$5 = { "$co": "@schema/actor", "description": "Each value is a co-id reference to a child actor" };
const childrenSchema = {
  $schema: $schema$c,
  $id: $id$d,
  title: title$c,
  description: description$2,
  cotype: cotype$3,
  indexing: indexing$3,
  properties: properties$e,
  additionalProperties: additionalProperties$5
};
const $schema$b = "@schema/meta";
const $id$c = "@schema/os/schematas-registry";
const title$b = "@schema/os/schematas-registry";
const description$1 = "Schema registry CoMap - maps schema namekeys (e.g., @schema/data/todos) to schema co-ids (co_z...). Stored in account.os.schematas";
const cotype$2 = "comap";
const indexing$2 = false;
const properties$d = { "@schema/meta": { "type": "string", "description": "Metaschema co-id (co_z...)" } };
const additionalProperties$4 = { "type": "string", "description": "Schema namekey  schema co-id mapping (e.g., @schema/data/todos  co_z123...)" };
const schematasRegistrySchema = {
  $schema: $schema$b,
  $id: $id$c,
  title: title$b,
  description: description$1,
  cotype: cotype$2,
  indexing: indexing$2,
  properties: properties$d,
  additionalProperties: additionalProperties$4
};
const $id$b = "@schema/data/todos";
const $schema$a = "@schema/meta";
const title$a = "@schema/data/todos";
const cotype$1 = "comap";
const indexing$1 = true;
const properties$c = { "text": { "type": "string", "minLength": 1, "pattern": ".*\\S.*", "description": "The todo item text content (must contain at least one non-whitespace character)" }, "done": { "type": "boolean", "description": "Whether the todo item is completed" } };
const required$3 = ["text", "done"];
const additionalProperties$3 = false;
const todosDataSchema = {
  $id: $id$b,
  $schema: $schema$a,
  title: title$a,
  cotype: cotype$1,
  indexing: indexing$1,
  properties: properties$c,
  required: required$3,
  additionalProperties: additionalProperties$3
};
const $id$a = "@schema/data/chat";
const $schema$9 = "@schema/meta";
const title$9 = "@schema/data/chat";
const cotype = "comap";
const indexing = true;
const properties$b = { "role": { "type": "string", "enum": ["user", "assistant", "system"], "description": "The role of the message sender" }, "content": { "type": "string", "minLength": 1, "description": "The message content" } };
const required$2 = ["role", "content"];
const additionalProperties$2 = false;
const chatDataSchema = {
  $id: $id$a,
  $schema: $schema$9,
  title: title$9,
  cotype,
  indexing,
  properties: properties$b,
  required: required$2,
  additionalProperties: additionalProperties$2
};
function getMetaSchema() {
  return ValidationEngine.getMetaSchema();
}
const SCHEMAS = {
  actor: actorSchema,
  context: contextSchema,
  state: stateSchema,
  view: viewSchema,
  style: styleSchema,
  brand: styleSchema,
  "brand.style": styleSchema,
  "actor.style": styleSchema,
  tool: toolSchema,
  vibe: vibeSchema,
  message: messageSchema,
  // Extracted $defs as separate schemas (expression is inline type definition, not a CoValue)
  guard: guardSchema,
  action: actionSchema,
  transition: transitionSchema,
  messagePayload: messagePayloadSchema,
  // MaiaScript expression schema (for validating DSL expressions)
  "maia-script-expression": expressionSchema,
  // CoValue schemas (separate CoValues referenced via $co)
  subscribers: subscribersSchema,
  inbox: inboxSchema,
  children: childrenSchema,
  // OS infrastructure schemas
  "os/schematas-registry": schematasRegistrySchema
};
const DATA_SCHEMAS = {
  "data/todos": todosDataSchema,
  "data/chat": chatDataSchema
};
function getSchema(type2) {
  return SCHEMAS[type2] || DATA_SCHEMAS[type2] || null;
}
function getAllSchemas() {
  return { ...SCHEMAS, ...DATA_SCHEMAS };
}
const index$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CoIdRegistry,
  ValidationEngine,
  coTypesDefs,
  getAllSchemas,
  getMetaSchema,
  getSchema,
  getValidationEngine,
  resolve: resolve$1,
  setSchemaResolver,
  transformForSeeding,
  validateAgainstSchema,
  validateAgainstSchemaOrThrow,
  validateSchemaStructure
}, Symbol.toStringTag, { value: "Module" }));
function formatValidationErrors(errors2) {
  return errors2.map((error) => ({
    instancePath: error.instancePath || "/",
    schemaPath: error.schemaPath || "",
    keyword: error.keyword || "",
    message: error.message || "",
    params: error.params || {}
  }));
}
async function withSchemaValidationDisabled(ajv2, callback) {
  const originalValidateSchema = ajv2.opts.validateSchema;
  ajv2.opts.validateSchema = false;
  try {
    return await callback();
  } finally {
    ajv2.opts.validateSchema = originalValidateSchema;
  }
}
let validationEngine = null;
let pendingSchemaResolver = null;
function setSchemaResolver(options) {
  if (!options || typeof options !== "object") {
    throw new Error("[setSchemaResolver] Options object required: { dbEngine }");
  }
  const { dbEngine } = options;
  if (!dbEngine) {
    throw new Error("[setSchemaResolver] dbEngine is REQUIRED. No fallbacks allowed.");
  }
  const operationsResolver = async (schemaKey) => {
    try {
      if (!dbEngine.backend) {
        throw new Error("[SchemaResolver] dbEngine.backend is required");
      }
      const { resolve: resolve2 } = await Promise.resolve().then(() => index$1);
      const schema = await resolve2(dbEngine.backend, schemaKey, { returnType: "schema" });
      if (!schema) {
        throw new Error(`[SchemaResolver] Schema ${schemaKey} not found`);
      }
      return schema;
    } catch (error) {
      throw new Error(`[SchemaResolver] Failed to load schema ${schemaKey}: ${error.message}`);
    }
  };
  pendingSchemaResolver = operationsResolver;
  if (validationEngine) {
    validationEngine.setSchemaResolver(operationsResolver);
  }
}
async function getValidationEngine(options = null) {
  let registrySchemas = null;
  if (options && typeof options === "object") {
    registrySchemas = options.registrySchemas || null;
  }
  let schemaResolver = null;
  if (pendingSchemaResolver) {
    schemaResolver = pendingSchemaResolver;
  }
  if (!validationEngine) {
    validationEngine = new ValidationEngine({ registrySchemas });
  } else if (registrySchemas && !validationEngine.registrySchemas) {
    validationEngine = new ValidationEngine({ registrySchemas });
  }
  if (schemaResolver && !validationEngine.schemaResolver) {
    validationEngine.setSchemaResolver(schemaResolver);
  }
  await validationEngine.initialize();
  return validationEngine;
}
async function validateAgainstSchema(schema, data2, context = "", throwOnError = false) {
  const engine = await getValidationEngine();
  await engine.initialize();
  try {
    await engine._resolveAndRegisterSchemaDependencies(schema);
    let validate2;
    if (schema.$id) {
      const existingValidator = engine.ajv.getSchema(schema.$id);
      if (existingValidator) {
        validate2 = existingValidator;
      } else {
        validate2 = engine.ajv.compile(schema);
      }
    } else {
      validate2 = engine.ajv.compile(schema);
    }
    const valid = validate2(data2);
    if (valid) {
      return { valid: true, errors: null };
    }
    const errors2 = validate2.errors || [];
    const formattedErrors = formatValidationErrors(errors2);
    if (throwOnError) {
      const contextMsg = context ? ` for '${context}'` : "";
      const errorDetails = formattedErrors.map((err) => `  - ${err.instancePath}: ${err.message}`).join("\n");
      throw new Error(
        `Validation failed${contextMsg}:
${errorDetails}`
      );
    }
    return {
      valid: false,
      errors: formattedErrors
    };
  } catch (error) {
    if (error.message && error.message.includes("already exists") && schema.$id) {
      const existingValidator = engine.ajv.getSchema(schema.$id);
      if (existingValidator) {
        const valid = existingValidator(data2);
        if (valid) {
          return { valid: true, errors: null };
        }
        const errors2 = existingValidator.errors || [];
        const formattedErrors = formatValidationErrors(errors2);
        if (throwOnError) {
          const contextMsg = context ? ` for '${context}'` : "";
          const errorDetails = formattedErrors.map((err) => `  - ${err.instancePath}: ${err.message}`).join("\n");
          throw new Error(
            `Validation failed${contextMsg}:
${errorDetails}`
          );
        }
        return {
          valid: false,
          errors: formattedErrors
        };
      }
    }
    throw new Error(`[Validation] Failed to compile schema for ${context}: ${error.message}`);
  }
}
async function validateAgainstSchemaOrThrow(schema, data2, context = "") {
  return await validateAgainstSchema(schema, data2, context, true);
}
function validateItems(schema, items2) {
  if (!Array.isArray(items2)) {
    throw new Error("[validateItems] Items must be an array");
  }
  if (schema.items && schema.items.$co) {
    for (const item of items2) {
      if (typeof item !== "string" || !item.startsWith("co_z")) {
        throw new Error(`[validateItems] Items must be co-ids when schema.items.$co is specified, got: ${item}`);
      }
    }
  }
}
function validateCoId(id2, operationName) {
  if (!id2) {
    throw new Error(`[${operationName}] coId required`);
  }
  if (!id2.startsWith("co_z")) {
    throw new Error(`[${operationName}] coId must be a valid co-id (co_z...), got: ${id2}`);
  }
}
function requireParam(param, paramName, operationName) {
  if (param === void 0 || param === null) {
    throw new Error(`[${operationName}] ${paramName} required`);
  }
}
function requireDbEngine(dbEngine, operationName, reason = "") {
  if (!dbEngine) {
    const reasonText = reason ? ` (${reason})` : "";
    throw new Error(`[${operationName}] dbEngine required${reasonText}`);
  }
}
async function ensureCoValueAvailable(backend, coId, operationName) {
  const coValueCore = backend.getCoValue(coId);
  if (!coValueCore) {
    throw new Error(`[${operationName}] CoValue not found: ${coId}`);
  }
  if (!coValueCore.isAvailable()) {
    await backend.node.loadCoValueCore(coId);
    let attempts = 0;
    while (!coValueCore.isAvailable() && attempts < 10) {
      await new Promise((resolve2) => setTimeout(resolve2, 100));
      attempts++;
    }
    if (!coValueCore.isAvailable()) {
      throw new Error(`[${operationName}] CoValue ${coId} is not available (may still be loading)`);
    }
  }
  return coValueCore;
}
const validation_helper = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ensureCoValueAvailable,
  formatValidationErrors,
  getValidationEngine,
  requireDbEngine,
  requireParam,
  setSchemaResolver,
  validateAgainstSchema,
  validateAgainstSchemaOrThrow,
  validateCoId,
  validateItems,
  withSchemaValidationDisabled
}, Symbol.toStringTag, { value: "Module" }));
async function createCoMap(accountOrGroup, init = {}, schemaName, node = null, dbEngine = null) {
  let group = accountOrGroup;
  if (accountOrGroup && typeof accountOrGroup.createMap === "function") {
    group = accountOrGroup;
  } else if (accountOrGroup && typeof accountOrGroup.get === "function") {
    const profileId = accountOrGroup.get("profile");
    if (profileId) {
      if (!node) {
        throw new Error("[createCoMap] Node parameter required when passing account");
      }
      let profileCore = node.getCoValue(profileId);
      if (!profileCore) {
        console.log(`[createCoMap] Loading profile ${profileId.substring(0, 12)}...`);
        profileCore = await node.loadCoValueCore(profileId);
      }
      if (!profileCore || !profileCore.isAvailable()) {
        console.log(`[createCoMap] Waiting for profile ${profileId.substring(0, 12)}... to be available...`);
        await new Promise((resolve2, reject) => {
          let unsubscribe = null;
          const timeout = setTimeout(() => {
            if (unsubscribe) unsubscribe();
            reject(new Error(`Timeout waiting for profile ${profileId} to be available. The profile may not exist or may not be synced yet.`));
          }, 1e4);
          if (!profileCore) {
            clearTimeout(timeout);
            reject(new Error(`Profile core not found: ${profileId}. Ensure the account has a valid profile.`));
            return;
          }
          unsubscribe = profileCore.subscribe((core2) => {
            if (core2 && core2.isAvailable()) {
              clearTimeout(timeout);
              if (unsubscribe) unsubscribe();
              resolve2();
            }
          });
          node.loadCoValueCore(profileId).catch((err) => {
            clearTimeout(timeout);
            if (unsubscribe) unsubscribe();
            reject(err);
          });
        });
        profileCore = node.getCoValue(profileId);
      }
      if (!profileCore || profileCore.type !== "comap") {
        throw new Error(`[createCoMap] Profile not available or invalid type: ${profileId}. Expected comap, got ${profileCore?.type || "null"}. Ensure the account has a valid profile.`);
      }
      const profile = profileCore.getCurrentContent?.();
      if (!profile || typeof profile.get !== "function") {
        throw new Error(`[createCoMap] Profile content not available: ${profileId}`);
      }
      const universalGroupId = profile.get("group");
      if (!universalGroupId) {
        throw new Error("[createCoMap] Universal group not found in profile.group. Ensure identity migration has run.");
      }
      let universalGroupCore = node.getCoValue(universalGroupId);
      if (!universalGroupCore) {
        console.log(`[createCoMap] Loading universal group ${universalGroupId.substring(0, 12)}...`);
        universalGroupCore = await node.loadCoValueCore(universalGroupId);
      }
      if (!universalGroupCore.isAvailable()) {
        console.log(`[createCoMap] Waiting for universal group ${universalGroupId.substring(0, 12)}... to be available...`);
        await new Promise((resolve2, reject) => {
          let unsubscribe = null;
          const timeout = setTimeout(() => {
            if (unsubscribe) unsubscribe();
            reject(new Error(`Timeout waiting for universal group ${universalGroupId} to be available`));
          }, 1e4);
          unsubscribe = universalGroupCore.subscribe((core2) => {
            if (core2.isAvailable()) {
              clearTimeout(timeout);
              if (unsubscribe) unsubscribe();
              resolve2();
            }
          });
          node.loadCoValueCore(universalGroupId).catch((err) => {
            clearTimeout(timeout);
            if (unsubscribe) unsubscribe();
            reject(err);
          });
        });
        universalGroupCore = node.getCoValue(universalGroupId);
      }
      if (!universalGroupCore) {
        throw new Error(`[createCoMap] Universal group core not found: ${universalGroupId}`);
      }
      const header = universalGroupCore.verified?.header;
      const ruleset = universalGroupCore.ruleset || header?.ruleset;
      if (!ruleset || ruleset.type !== "group") {
        throw new Error(`[createCoMap] Universal group is not a group type (ruleset.type !== 'group'): ${universalGroupId}`);
      }
      const universalGroupContent = universalGroupCore.getCurrentContent?.();
      if (!universalGroupContent || typeof universalGroupContent.createMap !== "function") {
        throw new Error(`[createCoMap] Universal group content not available: ${universalGroupId}`);
      }
      group = universalGroupContent;
      console.log(`[createCoMap] Using universal group via account.profile.group: ${universalGroupId}`);
    }
  }
  if (!schemaName || typeof schemaName !== "string") {
    throw new Error('[createCoMap] Schema name is REQUIRED. Provide a valid schema name (e.g., "ProfileSchema", "@meta-schema")');
  }
  if (schemaName === "GenesisSchema") {
    const meta2 = { $schema: "GenesisSchema" };
    const comap2 = group.createMap(init, meta2);
    console.log(" CoMap created (GenesisSchema):", comap2.id);
    console.log("   Schema:", schemaName);
    console.log("   HeaderMeta:", comap2.headerMeta);
    return comap2;
  }
  if (!isExceptionSchema(schemaName) && !schemaName.startsWith("co_z") && !hasSchemaInRegistry(schemaName)) {
    throw new Error(`[createCoMap] Schema '${schemaName}' not found in registry. Available schemas: AccountSchema, GroupSchema, ProfileSchema`);
  }
  if (!isExceptionSchema(schemaName)) {
    if (schemaName.startsWith("co_z")) {
      if (!dbEngine) {
        throw new Error(`[createCoMap] dbEngine is REQUIRED for co-id schema validation. Schema: ${schemaName}. Pass dbEngine as 5th parameter.`);
      }
      const schemaDef = await resolve$1(dbEngine.backend, schemaName, { returnType: "schema" });
      if (!schemaDef) {
        throw new Error(`[createCoMap] Schema not found in database: ${schemaName}`);
      }
      await validateAgainstSchemaOrThrow(schemaDef, init, `createCoMap for schema ${schemaName}`);
    } else {
      const engine = await getValidationEngine({
        registrySchemas: getAllSchemas$1()
      });
      const validation2 = await engine.validateData(schemaName, init);
      if (!validation2.valid) {
        const errorDetails = validation2.errors.map((err) => `  - ${err.instancePath}: ${err.message}`).join("\n");
        throw new Error(`[createCoMap] Data validation failed for schema '${schemaName}':
${errorDetails}`);
      }
    }
  }
  const meta = createSchemaMeta(schemaName);
  const comap = group.createMap(init, meta);
  return comap;
}
async function createCoList(accountOrGroup, init = [], schemaName, node = null, dbEngine = null) {
  let group = accountOrGroup;
  if (accountOrGroup && typeof accountOrGroup.get === "function") {
    const profileId = accountOrGroup.get("profile");
    if (profileId) {
      if (!node) {
        throw new Error("[createCoList] Node parameter required when passing account");
      }
      const profileCore = node.getCoValue(profileId);
      if (!profileCore || profileCore.type !== "comap") {
        throw new Error(`[createCoList] Profile not available: ${profileId}`);
      }
      const profile = profileCore.getCurrentContent?.();
      if (!profile || typeof profile.get !== "function") {
        throw new Error(`[createCoList] Profile content not available: ${profileId}`);
      }
      const universalGroupId = profile.get("group");
      if (!universalGroupId) {
        throw new Error("[createCoList] Universal group not found in profile.group. Ensure identity migration has run.");
      }
      const universalGroupCore = node.getCoValue(universalGroupId);
      if (!universalGroupCore) {
        throw new Error(`[createCoList] Universal group core not found: ${universalGroupId}`);
      }
      const header = universalGroupCore.verified?.header;
      const ruleset = universalGroupCore.ruleset || header?.ruleset;
      if (!ruleset || ruleset.type !== "group") {
        throw new Error(`[createCoList] Universal group is not a group type (ruleset.type !== 'group'): ${universalGroupId}`);
      }
      const universalGroupContent = universalGroupCore.getCurrentContent?.();
      if (!universalGroupContent || typeof universalGroupContent.createList !== "function") {
        throw new Error(`[createCoList] Universal group content not available: ${universalGroupId}`);
      }
      group = universalGroupContent;
      console.log(`[createCoList] Using universal group via account.profile.group: ${universalGroupId}`);
    }
  }
  if (!schemaName || typeof schemaName !== "string") {
    throw new Error('[createCoList] Schema name is REQUIRED. Provide a valid schema name (e.g., "NotesSchema") or co-id (e.g., "co_z123...")');
  }
  if (!isExceptionSchema(schemaName) && !schemaName.startsWith("co_z") && !hasSchemaInRegistry(schemaName)) {
    throw new Error(`[createCoList] Schema '${schemaName}' not found in registry. Available schemas: AccountSchema, GroupSchema, ProfileSchema`);
  }
  if (!isExceptionSchema(schemaName)) {
    if (schemaName.startsWith("co_z")) {
      if (!dbEngine) {
        throw new Error(`[createCoList] dbEngine is REQUIRED for co-id schema validation. Schema: ${schemaName}. Pass dbEngine as 5th parameter.`);
      }
      const schemaDef = await resolve$1(dbEngine.backend, schemaName, { returnType: "schema" });
      if (!schemaDef) {
        throw new Error(`[createCoList] Schema not found in database: ${schemaName}`);
      }
      await validateAgainstSchemaOrThrow(schemaDef, init, `createCoList for schema ${schemaName}`);
    } else {
      const engine = await getValidationEngine({
        registrySchemas: getAllSchemas$1()
      });
      const validation2 = await engine.validateData(schemaName, init);
      if (!validation2.valid) {
        const errorDetails = validation2.errors.map((err) => `  - ${err.instancePath}: ${err.message}`).join("\n");
        throw new Error(`[createCoList] Data validation failed for schema '${schemaName}':
${errorDetails}`);
      }
    }
  }
  const meta = createSchemaMeta(schemaName);
  const colist = group.createList(init, meta);
  console.log(" CoList created:", colist.id);
  console.log("   Schema:", schemaName);
  console.log("   HeaderMeta:", colist.headerMeta);
  console.log("   Initial items:", init.length);
  return colist;
}
function createCoStream(accountOrGroup, schemaName, node = null) {
  let group = accountOrGroup;
  if (accountOrGroup && typeof accountOrGroup.get === "function") {
    const profileId = accountOrGroup.get("profile");
    if (profileId) {
      if (!node) {
        throw new Error("[createCoStream] Node parameter required when passing account");
      }
      const profileCore = node.getCoValue(profileId);
      if (!profileCore || profileCore.type !== "comap") {
        throw new Error(`[createCoStream] Profile not available: ${profileId}`);
      }
      const profile = profileCore.getCurrentContent?.();
      if (!profile || typeof profile.get !== "function") {
        throw new Error(`[createCoStream] Profile content not available: ${profileId}`);
      }
      const universalGroupId = profile.get("group");
      if (!universalGroupId) {
        throw new Error("[createCoStream] Universal group not found in profile.group. Ensure identity migration has run.");
      }
      const universalGroupCore = node.getCoValue(universalGroupId);
      if (!universalGroupCore) {
        throw new Error(`[createCoStream] Universal group core not found: ${universalGroupId}`);
      }
      const header = universalGroupCore.verified?.header;
      const ruleset = universalGroupCore.ruleset || header?.ruleset;
      if (!ruleset || ruleset.type !== "group") {
        throw new Error(`[createCoStream] Universal group is not a group type (ruleset.type !== 'group'): ${universalGroupId}`);
      }
      const universalGroupContent = universalGroupCore.getCurrentContent?.();
      if (!universalGroupContent || typeof universalGroupContent.createStream !== "function") {
        throw new Error(`[createCoStream] Universal group content not available: ${universalGroupId}`);
      }
      group = universalGroupContent;
      console.log(`[createCoStream] Using universal group via account.profile.group: ${universalGroupId}`);
    }
  }
  if (!schemaName || typeof schemaName !== "string") {
    throw new Error('[createCoStream] Schema name is REQUIRED. Provide a valid schema name (e.g., schema co-id or "@meta-schema")');
  }
  if (!hasSchemaInRegistry(schemaName)) {
    throw new Error(`[createCoStream] Schema '${schemaName}' not found in registry. Available schemas: AccountSchema, GroupSchema, ProfileSchema`);
  }
  const meta = createSchemaMeta(schemaName);
  const costream = group.createStream(meta);
  console.log(" CoStream created:", costream.id);
  console.log("   Schema:", schemaName);
  console.log("   HeaderMeta:", costream.headerMeta);
  return costream;
}
class ReadOperation {
  constructor(backend) {
    this.backend = backend;
  }
  /**
   * Execute read operation - always returns reactive store (or array of stores for batch reads)
   * @param {Object} params
   * @param {string} params.schema - Schema co-id (co_z...) - MUST be a co-id, not '@schema/...'
   * @param {string} [params.key] - Specific key (co-id) for single item
   * @param {string[]} [params.keys] - Array of co-ids for batch reads (consolidates getBatch)
   * @param {Object} [params.filter] - Filter criteria for collection queries
   * @param {Object} [params.options] - Options for deep resolution and transformations
   * @param {boolean} [params.options.deepResolve=true] - Enable/disable deep resolution (default: true)
   * @param {number} [params.options.maxDepth=10] - Maximum depth for recursive resolution (default: 10)
   * @param {number} [params.options.timeoutMs=5000] - Timeout for waiting for nested CoValues (default: 5000)
   * @param {Object} [params.options.resolveReferences] - Options for resolving CoValue references
   * @param {string[]} [params.options.resolveReferences.fields] - Specific field names to resolve (e.g., ['source', 'target']). If not provided, resolves all co-id references
   * @param {string[]} [params.options.resolveReferences.schemas] - Specific schema co-ids to resolve. If not provided, resolves all CoValues
   * @param {Object} [params.options.map] - Map configuration for transforming data during read (e.g., { "sender": "$item.source.role", "recipient": "$item.target.role" })
   * @returns {Promise<ReactiveStore|ReactiveStore[]>} Reactive store(s) that hold current value and notify on updates
   */
  async execute(params) {
    const { schema, key, keys, filter, options } = params;
    if (schema && !schema.startsWith("co_z") && !["@account", "@group", "@meta-schema"].includes(schema)) {
      throw new Error(`[ReadOperation] Schema must be a co-id (co_z...) or special schema hint (@account, @group, @meta-schema), got: ${schema}. Runtime code must use co-ids only, not '@schema/...' patterns.`);
    }
    if (keys !== void 0 && !Array.isArray(keys)) {
      throw new Error("[ReadOperation] keys parameter must be an array of co-ids");
    }
    if (key && keys) {
      throw new Error("[ReadOperation] Cannot provide both key and keys parameters");
    }
    const result = await this.backend.read(schema, key, keys, filter, options);
    return result;
  }
}
class CreateOperation {
  constructor(backend, dbEngine = null) {
    this.backend = backend;
    this.dbEngine = dbEngine;
  }
  /**
   * Execute create operation
   * @param {Object} params
   * @param {string} params.schema - Schema co-id (co_z...) or human-readable reference (@schema/...)
   * @param {Object} params.data - Data to create
   * @returns {Promise<Object>} Created record with generated co-id
   */
  async execute(params) {
    const { schema, data: data2 } = params;
    requireParam(schema, "schema", "CreateOperation");
    requireParam(data2, "data", "CreateOperation");
    requireDbEngine(this.dbEngine, "CreateOperation", "runtime schema validation");
    const schemaCoId = await resolve$1(this.backend, schema, { returnType: "coId" });
    if (!schemaCoId) {
      throw new Error(`[CreateOperation] Could not resolve schema: ${schema}`);
    }
    const schemaDef = await resolve$1(this.backend, schemaCoId, { returnType: "schema" });
    if (!schemaDef) {
      throw new Error(`[CreateOperation] Schema ${schemaCoId} not found`);
    }
    await validateAgainstSchemaOrThrow(schemaDef, data2, `create operation for schema ${schemaCoId}`);
    return await this.backend.create(schemaCoId, data2);
  }
}
async function resolveExpressions(payload, evaluator2, data2) {
  if (typeof payload === "string" && payload.startsWith("$")) {
    return await evaluator2.evaluate(payload, data2);
  }
  if (payload === null || typeof payload !== "object") {
    return payload;
  }
  if (Array.isArray(payload)) {
    return Promise.all(payload.map((item) => resolveExpressions(item, evaluator2, data2)));
  }
  const keys = Object.keys(payload);
  if (keys.length === 1 && keys[0].startsWith("$")) {
    return await evaluator2.evaluate(payload, data2);
  }
  const resolved = {};
  for (const [key, value] of Object.entries(payload)) {
    if (value && typeof value === "object") {
      if (evaluator2.isDSLOperation(value)) {
        resolved[key] = await evaluator2.evaluate(value, data2);
      } else {
        resolved[key] = await resolveExpressions(value, evaluator2, data2);
      }
    } else {
      resolved[key] = await evaluator2.evaluate(value, data2);
    }
  }
  return resolved;
}
class UpdateOperation {
  constructor(backend, dbEngine = null, evaluator2 = null) {
    this.backend = backend;
    this.dbEngine = dbEngine;
    this.evaluator = evaluator2;
  }
  /**
   * Execute update operation - handles ALL CoValues uniformly (data + configs)
   * @param {Object} params
   * @param {string} params.id - Record co-id to update
   * @param {Object} params.data - Data to update
   * @returns {Promise<Object>} Updated record
   * 
   * Schema is ALWAYS extracted from CoValue headerMeta using universal resolver
   */
  async execute(params) {
    const { id: id2, data: data2 } = params;
    requireParam(id2, "id", "UpdateOperation");
    validateCoId(id2, "UpdateOperation");
    requireParam(data2, "data", "UpdateOperation");
    requireDbEngine(this.dbEngine, "UpdateOperation", "schema validation");
    const rawExistingData = await this.backend.getRawRecord(id2);
    if (!rawExistingData) {
      throw new Error(`[UpdateOperation] Record not found: ${id2}`);
    }
    const schemaCoId = await resolve$1(this.backend, { fromCoValue: id2 }, { returnType: "coId" });
    if (!schemaCoId) {
      throw new Error(`[UpdateOperation] Failed to extract schema from CoValue ${id2} headerMeta`);
    }
    const { $schema: _schema, ...existingDataWithoutMetadata } = rawExistingData;
    const evaluatedData = await this._evaluateDataWithExisting(data2, existingDataWithoutMetadata);
    const schema = await resolve$1(this.backend, schemaCoId, { returnType: "schema" });
    if (!schema) {
      throw new Error(`[UpdateOperation] Schema ${schemaCoId} not found`);
    }
    const mergedData = {
      ...existingDataWithoutMetadata,
      ...evaluatedData
    };
    await validateAgainstSchemaOrThrow(schema, mergedData, `update operation for schema ${schemaCoId}`);
    return await this.backend.update(schemaCoId, id2, evaluatedData);
  }
  /**
   * Evaluate MaiaScript expressions in data payload with access to existing data
   * Allows expressions like {"done": {"$not": "$existing.done"}} to toggle values
   * @param {Object} data - Update data (may contain MaiaScript expressions)
   * @param {Object} existingData - Existing record data (without $schema metadata)
   * @returns {Promise<Object>} Evaluated data
   */
  async _evaluateDataWithExisting(data2, existingData) {
    if (!this.evaluator) {
      return data2;
    }
    const dataContext = {
      context: { existing: existingData },
      item: {}
    };
    return await resolveExpressions(data2, this.evaluator, dataContext);
  }
}
class DeleteOperation {
  constructor(backend, dbEngine = null) {
    this.backend = backend;
    this.dbEngine = dbEngine;
  }
  /**
   * Execute delete operation
   * @param {Object} params
   * @param {string} params.id - Record co-id to delete
   * @returns {Promise<boolean>} true if deleted successfully
   * 
   * Schema is ALWAYS extracted from CoValue headerMeta using universal resolver
   */
  async execute(params) {
    const { id: id2 } = params;
    requireParam(id2, "id", "DeleteOperation");
    validateCoId(id2, "DeleteOperation");
    requireDbEngine(this.dbEngine, "DeleteOperation", "extract schema from CoValue headerMeta");
    const schemaCoId = await resolve$1(this.dbEngine.backend, { fromCoValue: id2 }, { returnType: "coId" });
    if (!schemaCoId) {
      throw new Error(`[DeleteOperation] Failed to extract schema from CoValue ${id2} headerMeta`);
    }
    return await this.backend.delete(schemaCoId, id2);
  }
}
class SeedOperation {
  constructor(backend) {
    this.backend = backend;
  }
  /**
   * Execute seed operation
   * @param {Object} params
   * @param {Object} params.configs - Config registry (actors, views, styles, etc.)
   * @param {Object} params.schemas - Schema definitions
   * @param {Object} params.data - Initial application data
   * @returns {Promise<void>}
   */
  async execute(params) {
    const { configs, schemas, data: data2 } = params;
    if (!configs) {
      throw new Error("[SeedOperation] Configs required");
    }
    if (!schemas) {
      throw new Error("[SeedOperation] Schemas required");
    }
    return await this.backend.seed(configs, schemas, data2 || {});
  }
}
class SchemaOperation {
  constructor(backend, dbEngine = null) {
    this.backend = backend;
    this.dbEngine = dbEngine;
  }
  /**
   * Extract schema definition from CoValue data
   * @private
   * @param {Object} coValueData - CoValue data from read() operation (has properties array format)
   * @param {string} schemaCoId - Schema co-id
   * @returns {Object|null} Schema definition or null if not found
   */
  _extractSchemaDefinition(coValueData, schemaCoId) {
    if (!coValueData || coValueData.error) {
      return null;
    }
    const schemaObj = {};
    if (coValueData.properties && Array.isArray(coValueData.properties)) {
      for (const prop of coValueData.properties) {
        if (prop && prop.key !== void 0) {
          let value = prop.value;
          if (typeof value === "string" && (value.startsWith("{") || value.startsWith("["))) {
            try {
              value = JSON.parse(value);
            } catch (e) {
            }
          }
          schemaObj[prop.key] = value;
        }
      }
    } else {
      Object.assign(schemaObj, coValueData);
    }
    const { id: id2, loading, error, type: type2, ...schemaOnly } = schemaObj;
    if (schemaOnly.definition) {
      const { id: defId, type: defType, ...definitionOnly } = schemaOnly.definition;
      return {
        ...definitionOnly,
        $id: schemaCoId
      };
    }
    const hasSchemaProps = schemaOnly.cotype || schemaOnly.properties || schemaOnly.items || schemaOnly.title || schemaOnly.description;
    if (hasSchemaProps) {
      return {
        ...schemaOnly,
        $id: schemaCoId
      };
    }
    return null;
  }
  /**
   * Execute schema operation - always returns ReactiveStore
   * CRITICAL: Uses operations API exclusively - read operation for reactive schema loading
   * @param {Object} params
   * @param {string} [params.coId] - Schema co-id (co_z...) - direct load
   * @param {string} [params.fromCoValue] - CoValue co-id - extracts headerMeta.$schema internally (PREFERRED)
   * @returns {Promise<ReactiveStore>} ReactiveStore with schema definition (or null if not found)
   */
  async execute(params) {
    const { coId, fromCoValue } = params;
    const paramCount = [coId, fromCoValue].filter(Boolean).length;
    if (paramCount === 0) {
      throw new Error("[SchemaOperation] One of coId or fromCoValue must be provided");
    }
    if (paramCount > 1) {
      throw new Error("[SchemaOperation] Only one of coId or fromCoValue can be provided");
    }
    let schemaCoId = null;
    if (coId) {
      validateCoId(coId, "SchemaOperation");
      schemaCoId = coId;
    }
    if (fromCoValue) {
      validateCoId(fromCoValue, "SchemaOperation");
      schemaCoId = await resolve$1(this.backend, { fromCoValue }, { returnType: "coId" });
      if (!schemaCoId) {
        console.warn(`[SchemaOperation] Could not extract schema co-id from CoValue ${fromCoValue} headerMeta`);
        return new ReactiveStore(null);
      }
    }
    const schemaCoMapStore = await this.backend.read(null, schemaCoId);
    const schemaStore = new ReactiveStore(null);
    const updateSchema = (coValueData) => {
      const schema = this._extractSchemaDefinition(coValueData, schemaCoId);
      schemaStore._set(schema);
    };
    const unsubscribe = schemaCoMapStore.subscribe((coValueData) => {
      updateSchema(coValueData);
    });
    updateSchema(schemaCoMapStore.value);
    const originalUnsubscribe = schemaStore._unsubscribe;
    schemaStore._unsubscribe = () => {
      if (originalUnsubscribe) originalUnsubscribe();
      unsubscribe();
    };
    return schemaStore;
  }
}
class ResolveOperation {
  constructor(backend) {
    this.backend = backend;
  }
  /**
   * Execute resolve operation - resolves human-readable key to co-id
   * @deprecated This operation should only be used during seeding. At runtime, all IDs should already be co-ids.
   * @param {Object} params
   * @param {string} params.humanReadableKey - Human-readable ID (e.g., '@schema/actor', '@vibe/todos')
   * @returns {Promise<string|null>} Co-id (co_z...) or null if not found
   */
  async execute(params) {
    const { humanReadableKey } = params;
    requireParam(humanReadableKey, "humanReadableKey", "ResolveOperation");
    if (typeof humanReadableKey !== "string") {
      throw new Error("[ResolveOperation] humanReadableKey must be a string");
    }
    if (humanReadableKey.startsWith("@schema/") || humanReadableKey.startsWith("@actor/") || humanReadableKey.startsWith("@vibe/")) {
      console.warn(`[ResolveOperation] resolve() called with human-readable key: ${humanReadableKey}. This should only be used during seeding. At runtime, all IDs should already be co-ids.`);
    }
    return await resolve$1(this.backend, humanReadableKey, { returnType: "coId" });
  }
}
class AppendOperation {
  constructor(backend, dbEngine = null) {
    this.backend = backend;
    this.dbEngine = dbEngine;
  }
  async execute(params) {
    const { coId, item, items: items2, cotype: cotype2 } = params;
    requireParam(coId, "coId", "AppendOperation");
    validateCoId(coId, "AppendOperation");
    requireDbEngine(this.dbEngine, "AppendOperation", "check schema cotype");
    const coValueCore = await ensureCoValueAvailable(this.backend, coId, "AppendOperation");
    const schemaCoId = await resolve$1(this.backend, { fromCoValue: coId }, { returnType: "coId" });
    if (!schemaCoId) {
      throw new Error(`[AppendOperation] Failed to extract schema from CoValue ${coId} headerMeta`);
    }
    let targetCotype = cotype2;
    if (!targetCotype) {
      const isColist = await checkCotype(this.backend, schemaCoId, "colist");
      const isCoStream = await checkCotype(this.backend, schemaCoId, "costream");
      if (isColist) {
        targetCotype = "colist";
      } else if (isCoStream) {
        targetCotype = "costream";
      } else {
        throw new Error(`[AppendOperation] CoValue ${coId} must be a CoList (colist) or CoStream (costream), got schema cotype: ${schemaCoId}`);
      }
    }
    const isValidCotype = await checkCotype(this.backend, schemaCoId, targetCotype);
    if (!isValidCotype) {
      throw new Error(`[AppendOperation] CoValue ${coId} is not a ${targetCotype} (schema cotype check failed)`);
    }
    const schema = await resolve$1(this.backend, schemaCoId, { returnType: "schema" });
    if (!schema) {
      throw new Error(`[AppendOperation] Schema ${schemaCoId} not found`);
    }
    const content = this.backend.getCurrentContent(coValueCore);
    const methodName = targetCotype === "colist" ? "append" : "push";
    if (!content || typeof content[methodName] !== "function") {
      throw new Error(`[AppendOperation] ${targetCotype === "colist" ? "CoList" : "CoStream"} ${coId} doesn't have ${methodName} method`);
    }
    const itemsToAppend = items2 || (item ? [item] : []);
    if (itemsToAppend.length === 0) {
      throw new Error("[AppendOperation] At least one item required (use item or items parameter)");
    }
    validateItems(schema, itemsToAppend);
    let appendedCount = 0;
    if (targetCotype === "colist") {
      let existingItems = [];
      try {
        if (typeof content.toJSON === "function") {
          existingItems = content.toJSON() || [];
        }
      } catch (e) {
        console.warn(`[AppendOperation] Error checking existing items:`, e);
      }
      for (const itemToAppend of itemsToAppend) {
        if (!existingItems.includes(itemToAppend)) {
          content.append(itemToAppend);
          appendedCount++;
        }
      }
    } else {
      for (const itemToAppend of itemsToAppend) {
        content.push(itemToAppend);
        appendedCount++;
      }
    }
    if (this.backend.node && this.backend.node.storage) {
      await this.backend.node.syncManager.waitForStorageSync(coId);
    }
    const resultKey = targetCotype === "colist" ? "itemsAppended" : "itemsPushed";
    return {
      success: true,
      coId,
      [resultKey]: appendedCount,
      ...targetCotype === "colist" && { itemsSkipped: itemsToAppend.length - appendedCount }
    };
  }
}
class ProcessInboxOperation {
  constructor(backend, dbEngine = null) {
    this.backend = backend;
    this.dbEngine = dbEngine;
  }
  /**
   * Execute process inbox operation
   * @param {Object} params
   * @param {string} params.actorId - Actor co-id
   * @param {string} params.inboxCoId - Inbox CoStream co-id
   * @returns {Promise<Object>} Object with messages array and updatedWatermarks map
   */
  async execute(params) {
    const { actorId, inboxCoId } = params;
    requireParam(actorId, "actorId", "ProcessInboxOperation");
    requireParam(inboxCoId, "inboxCoId", "ProcessInboxOperation");
    validateCoId(actorId, "ProcessInboxOperation");
    validateCoId(inboxCoId, "ProcessInboxOperation");
    const { processInbox: processInbox2 } = await Promise.resolve().then(() => index$1);
    return await processInbox2(this.backend, actorId, inboxCoId);
  }
}
let DBEngine$1 = class DBEngine {
  /**
   * Create a new DBEngine instance
   * @param {DBAdapter} backend - Backend adapter instance (must implement DBAdapter interface)
   * @param {Object} [options] - Optional configuration
   * @param {Object} [options.evaluator] - Optional MaiaScript evaluator for expression evaluation in updates
   */
  constructor(backend, options = {}) {
    this.backend = backend;
    const { evaluator: evaluator2 } = options;
    if (backend && typeof backend.setDbEngine === "function") {
      backend.setDbEngine(this);
    } else if (backend && backend.constructor.name === "CoJSONBackend") {
      backend.dbEngine = this;
    }
    const appendOp = new AppendOperation(this.backend, this);
    this.operations = {
      read: new ReadOperation(this.backend),
      // Unified reactive read operation
      create: new CreateOperation(this.backend, this),
      update: new UpdateOperation(this.backend, this, evaluator2),
      // Unified for data + configs, optional evaluator
      delete: new DeleteOperation(this.backend, this),
      // Needs dbEngine to extract schema from CoValue headerMeta
      seed: new SeedOperation(this.backend),
      schema: new SchemaOperation(this.backend, this),
      // Schema loading operation (needs dbEngine for resolve operation)
      resolve: new ResolveOperation(this.backend),
      // Co-id resolution operation
      append: appendOp,
      // CoList append operation
      push: appendOp,
      // CoStream append operation (routed to append with cotype='costream')
      processInbox: new ProcessInboxOperation(this.backend, this)
      // Inbox processing with session-based watermarks
    };
  }
  /**
   * Execute a database operation
   * @param {Object} payload - Operation payload
   * @param {string} payload.op - Operation name (read, create, update, delete, seed)
   * @param {Object} payload params - Operation-specific parameters
   * @returns {Promise<any>} Operation result
   */
  async execute(payload) {
    const { op, ...params } = payload;
    if (!op) {
      throw new Error('[DBEngine] Operation required: {op: "read|create|update|delete|seed|schema|resolve|append|push"}');
    }
    if (op === "push") {
      return await this.operations.append.execute({ ...params, cotype: "costream" });
    }
    const operation = this.operations[op];
    if (!operation) {
      throw new Error(`[DBEngine] Unknown operation: ${op}`);
    }
    try {
      const result = await operation.execute(params);
      return result;
    } catch (error) {
      console.error(`[DBEngine] Operation ${op} failed:`, error);
      throw error;
    }
  }
  /**
   * Resolve a human-readable ID to a co-id
   * DEPRECATED: This method should only be used during seeding. At runtime, all IDs should already be co-ids.
   * @deprecated Use co-ids directly at runtime. This method is only for seeding/backward compatibility.
   * @param {string} humanReadableId - Human-readable ID (e.g., '@vibe/todos', 'vibe/vibe')
   * @returns {Promise<string|null>} Co-id (co_z...) or null if not found
   */
};
class DBAdapter {
  /**
   * Read data from database
   * @param {string} schema - Schema co-id (co_z...)
   * @param {string} [key] - Specific key (co-id) for single item
   * @param {string[]} [keys] - Array of co-ids for batch reads
   * @param {Object} [filter] - Filter criteria for collection queries
   * @returns {Promise<ReactiveStore|ReactiveStore[]>} Reactive store(s) that hold current value and notify on updates
   */
  async read(schema, key, keys, filter) {
    throw new Error("[DBAdapter] read() must be implemented by backend");
  }
  /**
   * Create new record
   * @param {string} schema - Schema co-id (co_z...) for data collections
   * @param {Object} data - Data to create
   * @returns {Promise<Object>} Created record with generated co-id
   */
  async create(schema, data2) {
    throw new Error("[DBAdapter] create() must be implemented by backend");
  }
  /**
   * Update existing record (unified for data collections and configs)
   * @param {string} schema - Schema co-id (co_z...) - MUST be a co-id, not '@schema/...'
   * @param {string} id - Record co-id to update
   * @param {Object} data - Data to update
   * @returns {Promise<Object>} Updated record
   */
  async update(schema, id2, data2) {
    throw new Error("[DBAdapter] update() must be implemented by backend");
  }
  /**
   * Delete record
   * @param {string} schema - Schema co-id (co_z...)
   * @param {string} id - Record co-id to delete
   * @returns {Promise<boolean>} true if deleted successfully
   */
  async delete(schema, id2) {
    throw new Error("[DBAdapter] delete() must be implemented by backend");
  }
  /**
   * Get raw record from database (without normalization)
   * Used for validation - returns stored data as-is (with $schema metadata, without id)
   * @param {string} id - Record co-id
   * @returns {Promise<Object|null>} Raw stored record or null if not found
   */
  async getRawRecord(id2) {
    throw new Error("[DBAdapter] getRawRecord() must be implemented by backend");
  }
  /**
   * Seed database with configs, schemas, and initial data (optional - backend-specific)
   * @param {Object} configs - Config registry
   * @param {Object} schemas - Schema definitions
   * @param {Object} data - Initial application data
   * @returns {Promise<void>}
   */
  async seed(configs, schemas, data2) {
    throw new Error("[DBAdapter] seed() is optional - backend may not implement this");
  }
}
async function determineCotype(backend, schema, data2) {
  try {
    const schemaCore = await ensureCoValueLoaded(backend, schema, { waitForAvailable: true });
    if (schemaCore && backend.isAvailable(schemaCore)) {
      const schemaContent = backend.getCurrentContent(schemaCore);
      if (schemaContent && schemaContent.get) {
        const definition = schemaContent.get("definition");
        if (definition && definition.cotype) {
          if (definition.cotype === "cotext" || definition.cotype === "coplaintext") {
            throw new Error(`[CoJSONBackend] CoText (cotext) support has been eliminated. Schema ${schema} specifies cotext, which is no longer supported.`);
          }
          return definition.cotype;
        }
      }
    }
  } catch (e) {
    console.warn(`[CoJSONBackend] Failed to load schema ${schema} for cotype:`, e);
  }
  if (Array.isArray(data2)) {
    return "colist";
  } else if (typeof data2 === "string") {
    throw new Error(`[CoJSONBackend] Cannot determine cotype from data type for schema ${schema}. String data type is not supported (CoText/cotext support has been eliminated). Use CoMap or CoList instead.`);
  } else if (typeof data2 === "object" && data2 !== null) {
    return "comap";
  } else {
    throw new Error(`[CoJSONBackend] Cannot determine cotype from data type for schema ${schema}`);
  }
}
async function create(backend, schema, data2) {
  const cotype2 = await determineCotype(backend, schema, data2);
  if (!backend.account) {
    throw new Error("[CoJSONBackend] Account required for create");
  }
  const group = await backend.getDefaultGroup();
  let coValue;
  switch (cotype2) {
    case "comap":
      if (!data2 || typeof data2 !== "object" || Array.isArray(data2)) {
        throw new Error("[CoJSONBackend] Data must be object for comap");
      }
      coValue = await createCoMap(group, data2, schema, backend.node, backend.dbEngine);
      break;
    case "colist":
      if (!Array.isArray(data2)) {
        throw new Error("[CoJSONBackend] Data must be array for colist");
      }
      coValue = await createCoList(group, data2, schema, backend.node, backend.dbEngine);
      break;
    case "costream":
      coValue = createCoStream(group, schema, backend.node);
      break;
    default:
      throw new Error(`[CoJSONBackend] Unsupported cotype: ${cotype2}`);
  }
  const coValueCore = backend.node.getCoValue(coValue.id);
  if (coValueCore && backend.isAvailable(coValueCore)) {
    const content = backend.getCurrentContent(coValueCore);
    if (content && typeof content.get === "function") {
      const result = { id: coValue.id, ...data2 };
      const keys = content.keys && typeof content.keys === "function" ? content.keys() : Object.keys(content);
      for (const key of keys) {
        result[key] = content.get(key);
      }
      return result;
    }
    const extracted = extractCoValueData(backend, coValueCore);
    return { ...data2, id: coValue.id, ...extracted };
  }
  return {
    id: coValue.id,
    ...data2,
    // Include original data to ensure text and other properties are available
    type: cotype2,
    schema
  };
}
const create$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  create
}, Symbol.toStringTag, { value: "Module" }));
async function ensureOsCoMap(backend) {
  if (!backend.account) {
    throw new Error("[SchemaIndexManager] Account required");
  }
  let osId = backend.account.get("os");
  if (osId) {
    try {
      const osStore = await read(backend, osId, null, null, null, {
        deepResolve: false,
        // Don't need deep resolution for infrastructure
        timeoutMs: 1e4
        // 10 second timeout for critical infrastructure
      });
      if (!osStore || osStore.value?.error) {
        console.warn(`[SchemaIndexManager] account.os CoValue not found or error: ${osId.substring(0, 12)}...`);
        return null;
      }
      const osCore = backend.getCoValue(osId);
      if (!osCore || !osCore.isAvailable()) {
        console.warn(`[SchemaIndexManager] account.os (${osId.substring(0, 12)}...) is not available after read()`);
        return null;
      }
      const osContent = osCore.getCurrentContent?.();
      if (!osContent) {
        console.warn(`[SchemaIndexManager] account.os (${osId.substring(0, 12)}...) is available but getCurrentContent() returned nothing`);
        return null;
      }
      const contentType = osContent.cotype || osContent.type;
      const header = backend.getHeader(osCore);
      const headerMeta = header?.meta || null;
      const schema = headerMeta?.$schema || null;
      const isCoMap = contentType === "comap" && typeof osContent.get === "function";
      if (!isCoMap) {
        console.warn(`[SchemaIndexManager] account.os (${osId.substring(0, 12)}...) is not a CoMap (cotype: ${contentType}, schema: ${schema}, has get: ${typeof osContent.get})`);
        return null;
      }
      return osContent;
    } catch (e) {
      console.warn(`[SchemaIndexManager] Failed to load account.os (${osId.substring(0, 12)}...):`, e.message);
      return null;
    }
  }
  const group = await backend.getDefaultGroup();
  const osMeta = { $schema: EXCEPTION_SCHEMAS.META_SCHEMA };
  const osCoMap = group.createMap({}, osMeta);
  backend.account.set("os", osCoMap.id);
  return osCoMap;
}
async function ensureSchemaSpecificIndexColistSchema(backend, schemaCoId, metaSchemaCoId = null) {
  if (!schemaCoId || !schemaCoId.startsWith("co_z")) {
    throw new Error(`[SchemaIndexManager] Invalid schema co-id: ${schemaCoId}`);
  }
  if (!metaSchemaCoId) {
    const schemaCoValueCore = backend.getCoValue(schemaCoId);
    if (schemaCoValueCore) {
      const header = backend.getHeader(schemaCoValueCore);
      const headerMeta = header?.meta;
      metaSchemaCoId = headerMeta?.$schema;
      if (metaSchemaCoId && !metaSchemaCoId.startsWith("co_z")) {
        metaSchemaCoId = await resolve$1(backend, metaSchemaCoId, { returnType: "coId" });
      }
    }
    if (!metaSchemaCoId || !metaSchemaCoId.startsWith("co_z")) {
      metaSchemaCoId = await getMetaschemaCoId(backend);
    }
  }
  if (!metaSchemaCoId || !metaSchemaCoId.startsWith("co_z")) {
    console.warn(`[SchemaIndexManager] Cannot create schema-specific index colist schema - metaSchema not available`);
    return null;
  }
  const schemaDef = await resolve$1(backend, schemaCoId, { returnType: "schema" });
  if (!schemaDef) {
    console.warn(`[SchemaIndexManager] Cannot load schema definition for ${schemaCoId.substring(0, 12)}...`);
    return null;
  }
  const schemaTitle = schemaDef.title || schemaDef.$id;
  if (!schemaTitle || typeof schemaTitle !== "string" || !schemaTitle.startsWith("@schema/")) {
    console.warn(`[SchemaIndexManager] Schema ${schemaCoId.substring(0, 12)}... has invalid title: ${schemaTitle}`);
    return null;
  }
  const schemaNamePart = schemaTitle.replace("@schema/", "");
  const indexColistSchemaTitle = `@schema/index/${schemaNamePart}`;
  const existingSchemaCoId = await resolve$1(backend, indexColistSchemaTitle, { returnType: "coId" });
  if (existingSchemaCoId && existingSchemaCoId.startsWith("co_z")) {
    return existingSchemaCoId;
  }
  const indexColistSchemaDef = {
    title: indexColistSchemaTitle,
    description: `Schema-specific index colist for ${schemaTitle} - only allows instances of this schema`,
    cotype: "colist",
    indexing: false,
    // Index colist schemas themselves should not be indexed
    items: {
      $co: schemaTitle
      // Enforces type safety - only co-ids referencing the target schema are allowed
    }
  };
  try {
    const createdSchema = await create(backend, metaSchemaCoId, indexColistSchemaDef);
    const indexColistSchemaCoId = createdSchema.id;
    const schematasRegistry = await ensureSchemataRegistry(backend);
    if (schematasRegistry) {
      schematasRegistry.set(indexColistSchemaTitle, indexColistSchemaCoId);
    }
    return indexColistSchemaCoId;
  } catch (error) {
    console.error(`[SchemaIndexManager] Failed to create schema-specific index colist schema for ${schemaTitle}:`, error);
    return null;
  }
}
async function ensureSchemaIndexColist(backend, schemaCoId, metaSchemaCoId = null) {
  if (!schemaCoId || !schemaCoId.startsWith("co_z")) {
    throw new Error(`[SchemaIndexManager] Invalid schema co-id: ${schemaCoId}`);
  }
  const schemaDef = await resolve$1(backend, schemaCoId, { returnType: "schema" });
  if (!schemaDef) {
    console.warn(`[SchemaIndexManager] Cannot load schema definition for ${schemaCoId.substring(0, 12)}...`);
    return null;
  }
  if (schemaDef.indexing !== true) {
    return null;
  }
  const container = await ensureOsCoMap(backend);
  if (!container) {
    console.warn(`[SchemaIndexManager] Cannot create index colist - account.os not available`);
    return null;
  }
  let indexColistId = container.get(schemaCoId);
  if (indexColistId) {
    try {
      const indexColistStore = await read(backend, indexColistId, null, null, null, {
        deepResolve: false,
        // Don't need deep resolution for index colists
        timeoutMs: 5e3
      });
      if (indexColistStore && !indexColistStore.value?.error) {
        const indexColistCore2 = backend.getCoValue(indexColistId);
        if (indexColistCore2 && indexColistCore2.isAvailable()) {
          const indexColistContent = indexColistCore2.getCurrentContent?.();
          if (indexColistContent && typeof indexColistContent.append === "function") {
            const contentType = indexColistContent.cotype || indexColistContent.type;
            if (contentType === "colist") {
              return indexColistContent;
            }
          }
        }
      }
    } catch (e) {
      console.warn(`[SchemaIndexManager] Failed to read index colist (${indexColistId.substring(0, 12)}...):`, e.message);
    }
    console.warn(`[SchemaIndexManager] Index colist (${indexColistId.substring(0, 12)}...) exists but could not be loaded. Skipping to prevent overwriting.`);
    return null;
  }
  const indexSchemaCoId = await ensureSchemaSpecificIndexColistSchema(backend, schemaCoId, metaSchemaCoId);
  if (!indexSchemaCoId) {
    console.warn(`[SchemaIndexManager] Cannot create index colist - schema-specific index colist schema not available for ${schemaCoId.substring(0, 12)}...`);
    return null;
  }
  const group = await backend.getDefaultGroup();
  const indexMeta = { $schema: indexSchemaCoId };
  const indexColistRaw = group.createList([], indexMeta);
  indexColistId = indexColistRaw.id;
  container.set(schemaCoId, indexColistId);
  const indexColistCore = backend.node.getCoValue(indexColistId);
  if (indexColistCore && indexColistCore.type === "colist") {
    const indexColistContent = indexColistCore.getCurrentContent?.();
    if (indexColistContent && typeof indexColistContent.append === "function") {
      return indexColistContent;
    }
  }
  return indexColistRaw;
}
async function ensureUnknownColist(backend) {
  const osCoMap = await ensureOsCoMap(backend);
  if (!osCoMap) {
    console.warn(`[SchemaIndexManager] Cannot create unknown colist - account.os not available`);
    return null;
  }
  const unknownColistId = osCoMap.get("unknown");
  if (unknownColistId) {
    const unknownColistCore = backend.node.getCoValue(unknownColistId);
    if (unknownColistCore && unknownColistCore.type === "colist") {
      const unknownColistContent = unknownColistCore.getCurrentContent?.();
      if (unknownColistContent && typeof unknownColistContent.append === "function") {
        return unknownColistContent;
      }
    }
  }
  const group = await backend.getDefaultGroup();
  const unknownMeta = { $schema: EXCEPTION_SCHEMAS.META_SCHEMA };
  const unknownColist = group.createList([], unknownMeta);
  osCoMap.set("unknown", unknownColist.id);
  return unknownColist;
}
async function isInternalCoValue(backend, coId) {
  if (!backend.account || !coId) {
    return false;
  }
  const osId = backend.account.get("os");
  if (coId === osId) {
    return true;
  }
  if (osId) {
    const osCore = backend.node.getCoValue(osId);
    if (osCore && osCore.type === "comap") {
      const osContent = osCore.getCurrentContent?.();
      if (osContent && typeof osContent.get === "function") {
        const schematasId = osContent.get("schematas");
        if (coId === schematasId) {
          return true;
        }
        const unknownId = osContent.get("unknown");
        if (coId === unknownId) {
          return true;
        }
        const keys = osContent.keys && typeof osContent.keys === "function" ? osContent.keys() : Object.keys(osContent);
        for (const key of keys) {
          if (key !== "schematas" && key !== "unknown" && osContent.get(key) === coId) {
            return true;
          }
        }
      }
    }
  }
  return false;
}
async function shouldIndexCoValue(backend, coValueCore) {
  if (!coValueCore) {
    return { shouldIndex: false, schemaCoId: null };
  }
  const isInternal = await isInternalCoValue(backend, coValueCore.id);
  if (isInternal) {
    return { shouldIndex: false, schemaCoId: null };
  }
  const header = backend.getHeader(coValueCore);
  if (!header || !header.meta) {
    return { shouldIndex: false, schemaCoId: null };
  }
  const headerMeta = header.meta;
  const schema = headerMeta.$schema;
  if (EXCEPTION_SCHEMAS.ACCOUNT === schema || EXCEPTION_SCHEMAS.GROUP === schema || EXCEPTION_SCHEMAS.META_SCHEMA === schema) {
    return { shouldIndex: false, schemaCoId: null };
  }
  if (headerMeta.type === "account" || schema === EXCEPTION_SCHEMAS.ACCOUNT) {
    return { shouldIndex: false, schemaCoId: null };
  }
  const ruleset = coValueCore.ruleset || header?.ruleset;
  if (ruleset && ruleset.type === "group") {
    return { shouldIndex: false, schemaCoId: null };
  }
  if (schema && typeof schema === "string" && schema.startsWith("co_z")) {
    try {
      const schemaDef = await resolve$1(backend, schema, { returnType: "schema" });
      if (schemaDef) {
        const indexing2 = schemaDef.indexing;
        if (indexing2 !== true) {
          return { shouldIndex: false, schemaCoId: schema };
        }
      }
    } catch (error) {
    }
    return { shouldIndex: true, schemaCoId: schema };
  }
  if (!schema) {
    return { shouldIndex: false, schemaCoId: null };
  }
  return { shouldIndex: false, schemaCoId: null };
}
async function getMetaschemaCoId(backend) {
  if (!backend.account) {
    return null;
  }
  const osId = backend.account.get("os");
  if (!osId) {
    return null;
  }
  const osCore = backend.node.getCoValue(osId);
  if (!osCore || osCore.type !== "comap") {
    return null;
  }
  const osContent = osCore.getCurrentContent?.();
  if (!osContent || typeof osContent.get !== "function") {
    return null;
  }
  const schematasId = osContent.get("schematas");
  if (!schematasId) {
    return null;
  }
  const schematasCore = backend.node.getCoValue(schematasId);
  if (!schematasCore || schematasCore.type !== "comap") {
    return null;
  }
  const schematasContent = schematasCore.getCurrentContent?.();
  if (!schematasContent || typeof schematasContent.get !== "function") {
    return null;
  }
  const metaSchemaCoId = schematasContent.get("@schema/meta");
  if (metaSchemaCoId && typeof metaSchemaCoId === "string" && metaSchemaCoId.startsWith("co_z")) {
    return metaSchemaCoId;
  }
  return null;
}
async function ensureSchemataRegistry(backend) {
  const osCoMap = await ensureOsCoMap(backend);
  if (!osCoMap) {
    console.warn(`[SchemaIndexManager] Cannot create schematas registry - account.os not available`);
    return null;
  }
  const schematasId = osCoMap.get("schematas");
  if (schematasId) {
    try {
      const schematasStore = await read(backend, schematasId, null, null, null, {
        deepResolve: false,
        // Don't need deep resolution for registry
        timeoutMs: 5e3
      });
      if (schematasStore && !schematasStore.value?.error) {
        const schematasCore = backend.getCoValue(schematasId);
        if (schematasCore && schematasCore.isAvailable()) {
          const schematasContent = schematasCore.getCurrentContent?.();
          if (schematasContent && typeof schematasContent.set === "function") {
            const contentType = schematasContent.cotype || schematasContent.type;
            if (contentType === "comap") {
              return schematasContent;
            }
          }
        }
      }
    } catch (e) {
      console.warn(`[SchemaIndexManager] Failed to read schematas registry (${schematasId.substring(0, 12)}...):`, e.message);
    }
    console.warn(`[SchemaIndexManager] account.os.schematas (${schematasId.substring(0, 12)}...) exists but could not be loaded. Skipping to prevent overwriting.`);
    return null;
  }
  const group = await backend.getDefaultGroup();
  let schematasSchemaCoId = await resolve$1(backend, "@schema/os/schematas-registry", { returnType: "coId" });
  const schematasMeta = schematasSchemaCoId ? { $schema: schematasSchemaCoId } : { $schema: EXCEPTION_SCHEMAS.META_SCHEMA };
  const schematasCoMap = group.createMap({}, schematasMeta);
  osCoMap.set("schematas", schematasCoMap.id);
  return schematasCoMap;
}
async function registerSchemaCoValue(backend, schemaCoValueCore) {
  if (!schemaCoValueCore || !schemaCoValueCore.id) {
    return;
  }
  const content = backend.getCurrentContent(schemaCoValueCore);
  if (!content || typeof content.get !== "function") {
    return;
  }
  const title2 = content.get("title");
  if (!title2 || typeof title2 !== "string" || !title2.startsWith("@schema/")) {
    return;
  }
  const schematasRegistry = await ensureSchemataRegistry(backend);
  if (!schematasRegistry) {
    return;
  }
  const existingCoId = schematasRegistry.get(title2);
  if (existingCoId === schemaCoValueCore.id) {
    return;
  }
  if (existingCoId && existingCoId !== schemaCoValueCore.id) {
    return;
  }
  schematasRegistry.set(title2, schemaCoValueCore.id);
  const indexing2 = content.get("indexing");
  if (indexing2 !== true) {
    return;
  }
  const header = backend.getHeader(schemaCoValueCore);
  const headerMeta = header?.meta;
  let metaSchemaCoId = headerMeta?.$schema;
  if (metaSchemaCoId && !metaSchemaCoId.startsWith("co_z")) {
    metaSchemaCoId = await resolve$1(backend, metaSchemaCoId, { returnType: "coId" });
  }
  await ensureSchemaIndexColist(backend, schemaCoValueCore.id, metaSchemaCoId);
}
async function isSchemaCoValue(backend, coValueCore) {
  if (!coValueCore) {
    return false;
  }
  const header = backend.getHeader(coValueCore);
  if (!header || !header.meta) {
    return false;
  }
  const headerMeta = header.meta;
  const schema = headerMeta.$schema;
  if (!schema) {
    return false;
  }
  if (schema === EXCEPTION_SCHEMAS.META_SCHEMA) {
    const content = backend.getCurrentContent(coValueCore);
    if (content && typeof content.get === "function") {
      const title2 = content.get("title");
      if (title2 === "@schema/meta") {
        return true;
      }
    }
    return false;
  }
  if (schema && typeof schema === "string" && schema.startsWith("co_z")) {
    try {
      const referencedStore = await read(backend, schema, null, null, null, {
        deepResolve: false,
        // Don't need deep resolution for schema detection
        timeoutMs: 5e3
        // 5 second timeout - metaschema should be available but may need more time during seeding
      });
      if (referencedStore && !referencedStore.value?.error) {
        const referencedCoValueCore = backend.getCoValue(schema);
        if (referencedCoValueCore && referencedCoValueCore.isAvailable()) {
          const referencedContent = backend.getCurrentContent(referencedCoValueCore);
          if (referencedContent && typeof referencedContent.get === "function") {
            const referencedTitle = referencedContent.get("title");
            if (referencedTitle === "@schema/meta") {
              return true;
            }
          }
        }
      }
    } catch (e) {
    }
    const metaSchemaCoId = await getMetaschemaCoId(backend);
    if (metaSchemaCoId && schema === metaSchemaCoId) {
      return true;
    }
  }
  return false;
}
const indexingInProgress = /* @__PURE__ */ new Set();
async function indexCoValue(backend, coValueCoreOrId) {
  let coValueCore = coValueCoreOrId;
  let coId = null;
  if (typeof coValueCoreOrId === "string") {
    coId = coValueCoreOrId;
    coValueCore = backend.getCoValue(coId);
    if (!coValueCore || !backend.isAvailable(coValueCore)) {
      return;
    }
  } else {
    coId = coValueCoreOrId?.id;
  }
  if (!coValueCore || !coId) {
    return;
  }
  if (indexingInProgress.has(coId)) {
    return;
  }
  indexingInProgress.add(coId);
  try {
    const { shouldIndex, schemaCoId } = await shouldIndexCoValue(backend, coValueCore);
    if (shouldIndex && schemaCoId) {
      const indexColist = await ensureSchemaIndexColist(backend, schemaCoId);
      if (!indexColist) {
        return;
      }
      const header = backend.getHeader(coValueCore);
      const headerMeta = header?.meta;
      const coValueSchemaCoId = headerMeta?.$schema;
      if (!coValueSchemaCoId || coValueSchemaCoId !== schemaCoId) {
        return;
      }
      try {
        const items2 = indexColist.toJSON ? indexColist.toJSON() : [];
        if (Array.isArray(items2) && items2.includes(coId)) {
          return;
        }
      } catch (e) {
      }
      try {
        indexColist.append(coId);
      } catch (e) {
        return;
      }
    } else {
      const unknownColist = await ensureUnknownColist(backend);
      if (!unknownColist) {
        return;
      }
      try {
        const items2 = unknownColist.toJSON ? unknownColist.toJSON() : [];
        if (Array.isArray(items2) && items2.includes(coId)) {
          return;
        }
      } catch (e) {
      }
      unknownColist.append(coId);
    }
  } finally {
    indexingInProgress.delete(coId);
  }
}
async function getSchemaIndexColistForRemoval(backend, schemaCoId) {
  if (!schemaCoId || !schemaCoId.startsWith("co_z")) {
    return null;
  }
  if (!backend.account) {
    return null;
  }
  const container = await ensureOsCoMap(backend);
  if (!container) {
    return null;
  }
  const indexColistId = container.get(schemaCoId);
  if (!indexColistId || typeof indexColistId !== "string" || !indexColistId.startsWith("co_")) {
    return null;
  }
  try {
    const indexColistStore = await read(backend, indexColistId, null, null, null, {
      deepResolve: false,
      // Don't need deep resolution for removal
      timeoutMs: 2e3
    });
    if (indexColistStore && !indexColistStore.value?.error) {
      const indexColistCore = backend.getCoValue(indexColistId);
      if (indexColistCore && backend.isAvailable(indexColistCore)) {
        const indexColistContent = backend.getCurrentContent(indexColistCore);
        if (indexColistContent && typeof indexColistContent.toJSON === "function" && typeof indexColistContent.delete === "function") {
          const contentType = indexColistContent.cotype || indexColistContent.type;
          if (contentType === "colist") {
            return indexColistContent;
          }
        }
      }
    }
  } catch (e) {
  }
  return null;
}
async function removeFromIndex(backend, coId, schemaCoId = null) {
  if (!coId || !coId.startsWith("co_z")) {
    return;
  }
  if (!schemaCoId) {
    const coValueCore = backend.getCoValue(coId);
    if (coValueCore && backend.isAvailable(coValueCore)) {
      const header = backend.getHeader(coValueCore);
      if (header && header.meta) {
        schemaCoId = header.meta.$schema;
      }
    }
  }
  if (schemaCoId && typeof schemaCoId === "string" && schemaCoId.startsWith("co_z")) {
    const indexColist = await getSchemaIndexColistForRemoval(backend, schemaCoId);
    if (indexColist && typeof indexColist.toJSON === "function" && typeof indexColist.delete === "function") {
      const items2 = indexColist.toJSON();
      const itemIndex = items2.indexOf(coId);
      if (itemIndex !== -1) {
        indexColist.delete(itemIndex);
      }
    }
  } else {
    const unknownColist = await ensureUnknownColist(backend);
    if (unknownColist && typeof unknownColist.toJSON === "function" && typeof unknownColist.delete === "function") {
      const items2 = unknownColist.toJSON();
      const itemIndex = items2.indexOf(coId);
      if (itemIndex !== -1) {
        unknownColist.delete(itemIndex);
      }
    }
  }
}
async function deleteRecord(backend, schema, id2) {
  const coValueCore = await ensureCoValueLoaded(backend, id2, { waitForAvailable: true });
  if (!coValueCore) {
    throw new Error(`[CoJSONBackend] CoValue not found: ${id2}`);
  }
  if (!backend.isAvailable(coValueCore)) {
    throw new Error(`[CoJSONBackend] CoValue not available: ${id2}`);
  }
  const content = backend.getCurrentContent(coValueCore);
  const rawType = content?.cotype || content?.type;
  const itemHeader = backend.getHeader(coValueCore);
  const itemHeaderMeta = itemHeader?.meta || null;
  const itemSchemaCoId = itemHeaderMeta?.$schema || schema;
  await removeFromIndex(backend, id2, itemSchemaCoId);
  let deletionSuccessful = false;
  if (rawType === "comap" && content.set) {
    if (content.keys && typeof content.keys === "function") {
      const keys = Array.from(content.keys());
      for (const key of keys) {
        if (typeof content.delete === "function") {
          content.delete(key);
        }
      }
    } else if (typeof content.delete === "function") {
      const keys = Object.keys(content);
      for (const key of keys) {
        content.delete(key);
      }
    }
    deletionSuccessful = true;
  } else if (rawType === "colist" && content.delete) {
    if (typeof content.toJSON === "function") {
      const items2 = content.toJSON();
      for (let i = items2.length - 1; i >= 0; i--) {
        if (typeof content.delete === "function") {
          content.delete(i);
        }
      }
    }
    deletionSuccessful = true;
  } else if (rawType === "costream") {
    deletionSuccessful = true;
  } else if (rawType === "coplaintext" && content.delete) {
    if (typeof content.toString === "function") {
      const text = content.toString();
      for (let i = text.length - 1; i >= 0; i--) {
        if (typeof content.delete === "function") {
          content.delete(i, 1);
        }
      }
    }
    deletionSuccessful = true;
  } else {
    throw new Error(`[CoJSONBackend] Delete not supported for type: ${rawType}. Supported types: comap, colist, costream, coplaintext`);
  }
  if (deletionSuccessful && backend.node.storage) {
    await backend.node.syncManager.waitForStorageSync(id2);
  }
  return deletionSuccessful;
}
async function deleteSeededCoValues(account, node, backend) {
  let deletedCount = 0;
  let errorCount = 0;
  try {
    const osId = account.get("os");
    if (!osId) {
      return { deleted: 0, errors: 0 };
    }
    const osCore = await ensureCoValueLoaded(backend, osId, {
      waitForAvailable: true,
      timeoutMs: 5e3
    });
    if (!osCore || !backend.isAvailable(osCore)) {
      return { deleted: 0, errors: 0 };
    }
    const osCoMap = backend.getCurrentContent(osCore);
    if (!osCoMap || typeof osCoMap.get !== "function") {
      return { deleted: 0, errors: 0 };
    }
    const schematasId = osCoMap.get("schematas");
    const schemaCoIds = /* @__PURE__ */ new Set();
    if (schematasId) {
      const schematasCore = await ensureCoValueLoaded(backend, schematasId, {
        waitForAvailable: true,
        timeoutMs: 5e3
      });
      if (schematasCore && backend.isAvailable(schematasCore)) {
        const schematasContent = backend.getCurrentContent(schematasCore);
        if (schematasContent && typeof schematasContent.get === "function") {
          const keys2 = schematasContent.keys && typeof schematasContent.keys === "function" ? schematasContent.keys() : Object.keys(schematasContent);
          for (const key of keys2) {
            const schemaCoId = schematasContent.get(key);
            if (schemaCoId && typeof schemaCoId === "string" && schemaCoId.startsWith("co_z")) {
              schemaCoIds.add(schemaCoId);
            }
          }
        }
      }
    }
    const metaSchemaId = osCoMap.get("metaSchema");
    if (metaSchemaId && typeof metaSchemaId === "string" && metaSchemaId.startsWith("co_z")) {
      schemaCoIds.add(metaSchemaId);
    }
    const coValuesToDelete = /* @__PURE__ */ new Set();
    const keys = osCoMap.keys && typeof osCoMap.keys === "function" ? osCoMap.keys() : [];
    for (const key of keys) {
      if (key === "schematas" || key === "unknown" || key === "metaSchema") continue;
      if (key.startsWith("co_z")) {
        const indexColistId = osCoMap.get(key);
        if (indexColistId) {
          try {
            const indexColistCore = await ensureCoValueLoaded(backend, indexColistId, {
              waitForAvailable: true,
              timeoutMs: 2e3
            });
            if (indexColistCore && backend.isAvailable(indexColistCore)) {
              const indexColistContent = backend.getCurrentContent(indexColistCore);
              if (indexColistContent && typeof indexColistContent.toJSON === "function") {
                const items2 = indexColistContent.toJSON();
                for (const item of items2) {
                  if (item && typeof item === "string" && item.startsWith("co_z")) {
                    coValuesToDelete.add(item);
                  }
                }
              }
            }
          } catch (e) {
            console.warn(`[Seed] Failed to read index colist ${key ? key.substring(0, 12) : "undefined"}...:`, e.message);
            errorCount++;
          }
        }
      }
    }
    const unknownId = osCoMap.get("unknown");
    if (unknownId) {
      try {
        const unknownCore = await ensureCoValueLoaded(backend, unknownId, {
          waitForAvailable: true,
          timeoutMs: 2e3
        });
        if (unknownCore && backend.isAvailable(unknownCore)) {
          const unknownContent = backend.getCurrentContent(unknownCore);
          if (unknownContent && typeof unknownContent.toJSON === "function") {
            const items2 = unknownContent.toJSON();
            for (const item of items2) {
              if (item && typeof item === "string" && item.startsWith("co_z")) {
                coValuesToDelete.add(item);
              }
            }
          }
        }
      } catch (e) {
        console.warn(`[Seed] Failed to read unknown colist:`, e.message);
        errorCount++;
      }
    }
    const coValuesToDeleteFiltered = Array.from(coValuesToDelete).filter((coId) => {
      if (schemaCoIds.has(coId)) {
        return false;
      }
      return true;
    });
    for (const coId of coValuesToDeleteFiltered) {
      try {
        const coValueCore = backend.getCoValue(coId);
        if (!coValueCore) {
          continue;
        }
        const header = backend.getHeader(coValueCore);
        const headerMeta = header?.meta || null;
        const schemaCoId = headerMeta?.$schema;
        if (schemaCoId && schemaCoIds.has(coId)) {
          continue;
        }
        try {
          await deleteRecord(backend, schemaCoId || null, coId);
          deletedCount++;
        } catch (deleteError) {
          if (deleteError.message && (deleteError.message.includes("Cannot access") || deleteError.message.includes("before initialization") || deleteError.message.includes("ReferenceError"))) {
            deletedCount++;
          } else {
            throw deleteError;
          }
        }
      } catch (e) {
        console.warn(`[Seed] Failed to delete co-value ${coId ? coId.substring(0, 12) : "undefined"}...:`, e.message);
        errorCount++;
      }
    }
    const vibesId = account.get("vibes");
    if (vibesId) {
      try {
        const vibesCore = await ensureCoValueLoaded(backend, vibesId, {
          waitForAvailable: true,
          timeoutMs: 2e3
        });
        if (vibesCore && backend.isAvailable(vibesCore)) {
          const vibesContent = backend.getCurrentContent(vibesCore);
          if (vibesContent && typeof vibesContent.get === "function") {
            const vibeKeys = vibesContent.keys && typeof vibesContent.keys === "function" ? vibesContent.keys() : Object.keys(vibesContent);
            for (const vibeKey of vibeKeys) {
              const vibeCoId = vibesContent.get(vibeKey);
              if (vibeCoId && typeof vibeCoId === "string" && vibeCoId.startsWith("co_z")) {
                try {
                  const vibeCore = backend.getCoValue(vibeCoId);
                  if (vibeCore) {
                    const header = backend.getHeader(vibeCore);
                    const headerMeta = header?.meta || null;
                    const schemaCoId = headerMeta?.$schema;
                    await deleteRecord(backend, schemaCoId || null, vibeCoId);
                    deletedCount++;
                  }
                } catch (e) {
                  console.warn(`[Seed] Failed to delete vibe ${vibeCoId ? vibeCoId.substring(0, 12) : "undefined"}...:`, e.message);
                  errorCount++;
                }
              }
            }
            for (const vibeKey of vibeKeys) {
              if (typeof vibesContent.delete === "function") {
                vibesContent.delete(vibeKey);
              }
            }
          }
        }
      } catch (e) {
        console.warn(`[Seed] Failed to delete vibes:`, e.message);
        errorCount++;
      }
    }
    const osKeys = osCoMap.keys && typeof osCoMap.keys === "function" ? osCoMap.keys() : [];
    const indexColistsToDelete = [];
    for (const key of osKeys) {
      if (key === "schematas" || key === "unknown" || key === "metaSchema") continue;
      if (key.startsWith("co_z")) {
        const indexColistId = osCoMap.get(key);
        if (indexColistId && typeof indexColistId === "string" && indexColistId.startsWith("co_z")) {
          const schemaCoId = key;
          indexColistsToDelete.push({ schemaCoId, indexColistId });
        }
      }
    }
    for (const { schemaCoId, indexColistId } of indexColistsToDelete) {
      try {
        const schemaDef = await resolve$1(backend, schemaCoId, { returnType: "schema" });
        if (!schemaDef || !schemaDef.title) {
          console.warn(`[Seed] Cannot get schema title for ${schemaCoId ? schemaCoId.substring(0, 12) : "undefined"}..., skipping index colist deletion`);
          continue;
        }
        const schemaTitle = schemaDef.title;
        if (!schemaTitle.startsWith("@schema/")) {
          console.warn(`[Seed] Invalid schema title format: ${schemaTitle}, skipping index colist deletion`);
          continue;
        }
        const schemaNamePart = schemaTitle.replace("@schema/", "");
        const indexColistSchemaTitle = `@schema/index/${schemaNamePart}`;
        const indexColistSchemaCoId = await resolve$1(backend, indexColistSchemaTitle, { returnType: "coId" });
        if (!indexColistSchemaCoId) {
          console.warn(`[Seed] Cannot resolve index colist schema ${indexColistSchemaTitle}, skipping index colist deletion`);
          continue;
        }
        try {
          await deleteRecord(backend, indexColistSchemaCoId, indexColistId);
          deletedCount++;
          if (typeof osCoMap.delete === "function") {
            osCoMap.delete(schemaCoId);
          }
        } catch (deleteError) {
          if (deleteError.message && (deleteError.message.includes("Cannot access") || deleteError.message.includes("before initialization") || deleteError.message.includes("ReferenceError"))) {
            deletedCount++;
            if (typeof osCoMap.delete === "function") {
              osCoMap.delete(schemaCoId);
            }
          } else {
            throw deleteError;
          }
        }
      } catch (e) {
        console.warn(`[Seed] Failed to delete index colist ${indexColistId ? indexColistId.substring(0, 12) : "undefined"}...:`, e.message);
        errorCount++;
      }
    }
    if (indexColistsToDelete.length > 0) {
    }
    return { deleted: deletedCount, errors: errorCount };
  } catch (e) {
    console.error(`[Seed] Error during cleanup:`, e);
    return { deleted: deletedCount, errors: errorCount + 1 };
  }
}
function buildMetaSchemaForSeeding(metaSchemaCoId) {
  const metaSchemaId = metaSchemaCoId ? `https://maia.city/${metaSchemaCoId}` : "https://json-schema.org/draft/2020-12/schema";
  const fullMetaSchema = {
    ...mergedMetaSchema,
    $id: metaSchemaId,
    $schema: metaSchemaId
  };
  return {
    definition: fullMetaSchema
  };
}
async function seed(account, node, configs, schemas, data2, existingBackend = null) {
  function removeIdFields2(obj) {
    if (obj === null || obj === void 0) {
      return obj;
    }
    if (typeof obj !== "object") {
      return obj;
    }
    if (Array.isArray(obj)) {
      return obj.map((item) => removeIdFields2(item));
    }
    const cleaned = {};
    for (const [key, value] of Object.entries(obj)) {
      if (key === "id") {
        continue;
      }
      if (value !== null && value !== void 0 && typeof value === "object") {
        cleaned[key] = removeIdFields2(value);
      } else {
        cleaned[key] = value;
      }
    }
    return cleaned;
  }
  const { CoIdRegistry: CoIdRegistry2 } = await Promise.resolve().then(() => coIdGenerator);
  const { transformForSeeding: transformForSeeding2, validateSchemaStructure: validateSchemaStructure2 } = await Promise.resolve().then(() => schemaTransformer);
  const coIdRegistry = new CoIdRegistry2();
  const { CoJSONBackend: CoJSONBackend2 } = await Promise.resolve().then(() => cojsonBackend);
  const backend = existingBackend || new CoJSONBackend2(node, account);
  await deleteSeededCoValues(account, node, backend);
  const profileId = account.get("profile");
  if (!profileId) {
    throw new Error("[CoJSONSeed] Profile not found on account. Ensure identity migration has run.");
  }
  const profileStore = await backend.read(null, profileId);
  if (profileStore.loading) {
    await new Promise((resolve2, reject) => {
      let unsubscribe;
      const timeout = setTimeout(() => {
        reject(new Error(`Timeout waiting for profile ${profileId} to be available`));
      }, 1e4);
      unsubscribe = profileStore.subscribe(() => {
        if (!profileStore.loading) {
          clearTimeout(timeout);
          unsubscribe();
          resolve2();
        }
      });
    });
  }
  if (profileStore.error || !profileStore.value) {
    throw new Error(`[CoJSONSeed] Profile not available: ${profileId}`);
  }
  const profileData = profileStore.value;
  let universalGroupId;
  if (profileData.properties && Array.isArray(profileData.properties)) {
    const groupProperty = profileData.properties.find((p) => p.key === "group");
    if (!groupProperty || !groupProperty.value) {
      throw new Error("[CoJSONSeed] Universal group not found in profile.group. Ensure identity migration has run.");
    }
    universalGroupId = groupProperty.value;
  } else if (profileData.group && typeof profileData.group === "string") {
    universalGroupId = profileData.group;
  } else {
    throw new Error("[CoJSONSeed] Universal group not found in profile.group. Ensure identity migration has run.");
  }
  const groupStore = await backend.read("@group", universalGroupId);
  if (groupStore.loading) {
    await new Promise((resolve2, reject) => {
      let unsubscribe;
      const timeout = setTimeout(() => {
        reject(new Error(`Timeout waiting for universal group ${universalGroupId} to be available`));
      }, 1e4);
      unsubscribe = groupStore.subscribe(() => {
        if (!groupStore.loading) {
          clearTimeout(timeout);
          unsubscribe();
          resolve2();
        }
      });
    });
  }
  if (groupStore.error || !groupStore.value) {
    throw new Error(`[CoJSONSeed] Universal group not available: ${universalGroupId}`);
  }
  const universalGroupCore = node.getCoValue(universalGroupId);
  if (!universalGroupCore) {
    throw new Error(`[CoJSONSeed] Universal group core not found: ${universalGroupId}`);
  }
  const header = universalGroupCore.verified?.header;
  const ruleset = universalGroupCore.ruleset || header?.ruleset;
  if (!ruleset || ruleset.type !== "group") {
    throw new Error(`[CoJSONSeed] Universal group is not a group type (ruleset.type !== 'group'): ${universalGroupId}`);
  }
  const universalGroup = universalGroupCore.getCurrentContent?.();
  if (!universalGroup || typeof universalGroup.createMap !== "function") {
    throw new Error(`[CoJSONSeed] Universal group content not available: ${universalGroupId}`);
  }
  const uniqueSchemasBy$id = /* @__PURE__ */ new Map();
  for (const [name, schema] of Object.entries(schemas)) {
    const schemaKey = schema.$id || `@schema/${name}`;
    if (!uniqueSchemasBy$id.has(schemaKey)) {
      uniqueSchemasBy$id.set(schemaKey, { name, schema });
    }
  }
  const findCoReferences = (obj, visited = /* @__PURE__ */ new Set()) => {
    const refs = /* @__PURE__ */ new Set();
    if (!obj || typeof obj !== "object" || visited.has(obj)) {
      return refs;
    }
    visited.add(obj);
    if (obj.$co && typeof obj.$co === "string" && obj.$co.startsWith("@schema/")) {
      refs.add(obj.$co);
    }
    for (const value of Object.values(obj)) {
      if (value && typeof value === "object") {
        if (Array.isArray(value)) {
          for (const item of value) {
            if (item && typeof item === "object") {
              const itemRefs = findCoReferences(item, visited);
              itemRefs.forEach((ref2) => refs.add(ref2));
            }
          }
        } else {
          const nestedRefs = findCoReferences(value, visited);
          nestedRefs.forEach((ref2) => refs.add(ref2));
        }
      }
    }
    return refs;
  };
  const schemaDependencies = /* @__PURE__ */ new Map();
  for (const [schemaKey, { schema }] of uniqueSchemasBy$id) {
    const refs = findCoReferences(schema);
    schemaDependencies.set(schemaKey, refs);
  }
  const sortedSchemaKeys = [];
  const processed = /* @__PURE__ */ new Set();
  const processing = /* @__PURE__ */ new Set();
  const visitSchema = (schemaKey) => {
    if (processed.has(schemaKey)) {
      return;
    }
    if (processing.has(schemaKey)) {
      return;
    }
    processing.add(schemaKey);
    const deps = schemaDependencies.get(schemaKey) || /* @__PURE__ */ new Set();
    for (const dep of deps) {
      if (dep.startsWith("@schema/") && uniqueSchemasBy$id.has(dep)) {
        visitSchema(dep);
      }
    }
    processing.delete(schemaKey);
    processed.add(schemaKey);
    sortedSchemaKeys.push(schemaKey);
  };
  for (const schemaKey of uniqueSchemasBy$id.keys()) {
    if (schemaKey !== "@schema/meta") {
      visitSchema(schemaKey);
    }
  }
  await ensureAccountOs(account, node, universalGroup);
  let metaSchemaCoId = null;
  const osId = account.get("os");
  if (osId) {
    const osCore = await ensureCoValueLoaded(backend, osId, {
      waitForAvailable: true,
      timeoutMs: 2e3
    });
    if (osCore && backend.isAvailable(osCore)) {
      const osContent = backend.getCurrentContent(osCore);
      if (osContent && typeof osContent.get === "function") {
        metaSchemaCoId = osContent.get("metaSchema");
        if (!metaSchemaCoId) {
          const schematasId = osContent.get("schematas");
          if (schematasId) {
            const schematasCore = await ensureCoValueLoaded(backend, schematasId, {
              waitForAvailable: true,
              timeoutMs: 2e3
            });
            if (schematasCore && backend.isAvailable(schematasCore)) {
              const schematasContent = backend.getCurrentContent(schematasCore);
              if (schematasContent && typeof schematasContent.get === "function") {
                metaSchemaCoId = schematasContent.get("@schema/meta");
              }
            }
          }
        }
      }
    }
  }
  if (!metaSchemaCoId) {
    const metaSchemaMeta = { $schema: "GenesisSchema" };
    const tempMetaSchemaDef = buildMetaSchemaForSeeding("co_zTEMP");
    const cleanedTempDef = {
      definition: removeIdFields2(tempMetaSchemaDef.definition || tempMetaSchemaDef)
    };
    const metaSchemaCoMap = universalGroup.createMap(
      cleanedTempDef,
      // Will update $id after creation
      metaSchemaMeta
    );
    const actualMetaSchemaCoId = metaSchemaCoMap.id;
    const updatedMetaSchemaDef = buildMetaSchemaForSeeding(actualMetaSchemaCoId);
    const { $schema: $schema2, $id: $id2, id: id2, ...directProperties } = updatedMetaSchemaDef.definition || updatedMetaSchemaDef;
    const cleanedProperties = removeIdFields2(directProperties);
    for (const [key, value] of Object.entries(cleanedProperties)) {
      metaSchemaCoMap.set(key, value);
    }
    metaSchemaCoId = actualMetaSchemaCoId;
  } else {
    const updatedMetaSchemaDef = buildMetaSchemaForSeeding(metaSchemaCoId);
    const { $schema: $schema2, $id: $id2, id: id2, ...directProperties } = updatedMetaSchemaDef.definition || updatedMetaSchemaDef;
    const cleanedProperties = removeIdFields2(directProperties);
    const metaSchemaCore = await ensureCoValueLoaded(backend, metaSchemaCoId, {
      waitForAvailable: true,
      timeoutMs: 2e3
    });
    if (metaSchemaCore && backend.isAvailable(metaSchemaCore)) {
      const metaSchemaCoMap = backend.getCurrentContent(metaSchemaCore);
      if (metaSchemaCoMap && typeof metaSchemaCoMap.set === "function") {
        for (const [key, value] of Object.entries(cleanedProperties)) {
          metaSchemaCoMap.set(key, value);
        }
      }
    }
  }
  if (!coIdRegistry.has("@schema/meta")) {
    coIdRegistry.register("@schema/meta", metaSchemaCoId);
  } else {
    const existingCoId = coIdRegistry.get("@schema/meta");
    if (existingCoId !== metaSchemaCoId) {
      console.warn(`[Seed] Metaschema already registered with different co-id: ${existingCoId}, using existing instead of ${metaSchemaCoId}`);
      metaSchemaCoId = existingCoId;
    }
  }
  const schemaCoIdMap = /* @__PURE__ */ new Map();
  const schemaCoMaps = /* @__PURE__ */ new Map();
  const crudCreate = await Promise.resolve().then(() => create$1);
  const crudUpdate = await Promise.resolve().then(() => update$1);
  const existingSchemaRegistry = /* @__PURE__ */ new Map();
  if (osId) {
    const osCore = await ensureCoValueLoaded(backend, osId, {
      waitForAvailable: true,
      timeoutMs: 2e3
    });
    if (osCore && backend.isAvailable(osCore)) {
      const osContent = backend.getCurrentContent(osCore);
      if (osContent && typeof osContent.get === "function") {
        const schematasId = osContent.get("schematas");
        if (schematasId) {
          const schematasCore = await ensureCoValueLoaded(backend, schematasId, {
            waitForAvailable: true,
            timeoutMs: 2e3
          });
          if (schematasCore && backend.isAvailable(schematasCore)) {
            const schematasContent = backend.getCurrentContent(schematasCore);
            if (schematasContent && typeof schematasContent.get === "function") {
              const keys = schematasContent.keys && typeof schematasContent.keys === "function" ? schematasContent.keys() : Object.keys(schematasContent);
              for (const key of keys) {
                const schemaCoId = schematasContent.get(key);
                if (schemaCoId && typeof schemaCoId === "string" && schemaCoId.startsWith("co_z")) {
                  existingSchemaRegistry.set(key, schemaCoId);
                }
              }
            }
          }
        }
      }
    }
  }
  for (const schemaKey of sortedSchemaKeys) {
    const { name, schema } = uniqueSchemasBy$id.get(schemaKey);
    const { $schema: $schema2, $id: $id2, id: id2, ...directProperties } = schema;
    const cleanedProperties = removeIdFields2(directProperties);
    const existingSchemaCoId = existingSchemaRegistry.get(schemaKey);
    let actualCoId;
    if (existingSchemaCoId) {
      await crudUpdate.update(backend, metaSchemaCoId, existingSchemaCoId, cleanedProperties);
      actualCoId = existingSchemaCoId;
    } else {
      const createdSchema = await crudCreate.create(backend, metaSchemaCoId, cleanedProperties);
      actualCoId = createdSchema.id;
    }
    schemaCoIdMap.set(schemaKey, actualCoId);
    const schemaCoValueCore = backend.getCoValue(actualCoId);
    if (schemaCoValueCore && backend.isAvailable(schemaCoValueCore)) {
      const schemaCoMapContent = backend.getCurrentContent(schemaCoValueCore);
      if (schemaCoMapContent && typeof schemaCoMapContent.set === "function") {
        schemaCoMaps.set(schemaKey, schemaCoMapContent);
      }
    }
    coIdRegistry.register(schemaKey, actualCoId);
  }
  if (metaSchemaCoId && !schemaCoIdMap.has("@schema/meta")) {
    schemaCoIdMap.set("@schema/meta", metaSchemaCoId);
  }
  const transformedSchemasByKey = /* @__PURE__ */ new Map();
  for (const schemaKey of sortedSchemaKeys) {
    const { name, schema } = uniqueSchemasBy$id.get(schemaKey);
    const schemaCoId = schemaCoIdMap.get(schemaKey);
    const schemaCoMap = schemaCoMaps.get(schemaKey);
    const transformedSchema = transformForSeeding2(schema, schemaCoIdMap);
    transformedSchema.$id = `https://maia.city/${schemaCoId}`;
    const verificationErrors = validateSchemaStructure2(transformedSchema, schemaKey, { checkSchemaReferences: true, checkNestedCoTypes: false });
    if (verificationErrors.length > 0) {
      const errorMsg = `[Seed] Schema ${schemaKey} still contains @schema/ references after transformation:
${verificationErrors.join("\n")}`;
      console.error(errorMsg);
      throw new Error(errorMsg);
    }
    transformedSchemasByKey.set(schemaKey, transformedSchema);
    const { $schema: $schema2, $id: $id2, id: id2, ...directProperties } = transformedSchema;
    const cleanedProperties = removeIdFields2(directProperties);
    for (const [key, value] of Object.entries(cleanedProperties)) {
      schemaCoMap.set(key, value);
    }
  }
  const seededSchemas = [];
  for (const schemaKey of sortedSchemaKeys) {
    const { name } = uniqueSchemasBy$id.get(schemaKey);
    const schemaCoId = schemaCoIdMap.get(schemaKey);
    const schemaCoMap = schemaCoMaps.get(schemaKey);
    seededSchemas.push({
      name,
      key: schemaKey,
      coId: schemaCoId,
      coMapId: schemaCoMap.id
    });
  }
  const instanceCoIdMap = /* @__PURE__ */ new Map();
  const getCombinedRegistry = async () => {
    const schemaRegistry = /* @__PURE__ */ new Map();
    const osId2 = account.get("os");
    if (osId2) {
      const osCore = node.getCoValue(osId2);
      if (osCore && osCore.type === "comap") {
        const osContent = osCore.getCurrentContent?.();
        if (osContent && typeof osContent.get === "function") {
          const schematasId = osContent.get("schematas");
          if (schematasId) {
            const schematasCore = node.getCoValue(schematasId);
            if (schematasCore && schematasCore.type === "comap") {
              const schematasContent = schematasCore.getCurrentContent?.();
              if (schematasContent && typeof schematasContent.get === "function") {
                const keys = schematasContent.keys();
                for (const key of keys) {
                  const coId = schematasContent.get(key);
                  if (coId && typeof coId === "string" && coId.startsWith("co_z")) {
                    schemaRegistry.set(key, coId);
                  }
                }
                if (schemaRegistry.size > 0) ;
              }
            }
          }
        }
      }
    }
    if (schemaRegistry.size === 0) {
      for (const [schemaKey, actualCoId] of schemaCoIdMap.entries()) {
        schemaRegistry.set(schemaKey, actualCoId);
      }
      if (metaSchemaCoId) {
        schemaRegistry.set("@schema/meta", metaSchemaCoId);
      }
    }
    return schemaRegistry;
  };
  let combinedRegistry = await getCombinedRegistry();
  if (data2) {
    for (const [collectionName] of Object.entries(data2)) {
      const schemaKey = `@schema/${collectionName}`;
      const dataSchemaKey = `@schema/data/${collectionName}`;
      const dataSchemaCoId = combinedRegistry.get(dataSchemaKey);
      if (dataSchemaCoId) {
        combinedRegistry.set(schemaKey, dataSchemaCoId);
        coIdRegistry.register(schemaKey, dataSchemaCoId);
      }
    }
  }
  let seededConfigs = { configs: [], count: 0 };
  const transformSchemaRefsOnly = (instance, schemaRegistry) => {
    if (!instance || typeof instance !== "object") {
      return instance;
    }
    const transformed = JSON.parse(JSON.stringify(instance));
    if (transformed.$schema && transformed.$schema.startsWith("@schema/")) {
      const coId = schemaRegistry.get(transformed.$schema);
      if (coId) {
        transformed.$schema = coId;
      }
    }
    return transformed;
  };
  const refreshCombinedRegistry = () => {
    const refreshed = new Map(combinedRegistry);
    for (const [key, coId] of instanceCoIdMap.entries()) {
      if (coId && typeof coId === "string" && coId.startsWith("co_z")) {
        refreshed.set(key, coId);
      }
    }
    for (const [key, coId] of coIdRegistry.getAll()) {
      if (coId && typeof coId === "string" && coId.startsWith("co_z")) {
        refreshed.set(key, coId);
      }
    }
    return refreshed;
  };
  const seedConfigTypeAndRegister = async (configTypeKey, configsOfType, singularTypeName) => {
    if (!configsOfType || typeof configsOfType !== "object") {
      return { configs: [], count: 0 };
    }
    const transformed = {};
    for (const [instanceKey, instance] of Object.entries(configsOfType)) {
      transformed[instanceKey] = transformSchemaRefsOnly(instance, combinedRegistry);
    }
    const configsToSeed = { [configTypeKey]: transformed };
    const seeded = await seedConfigs(account, node, universalGroup, configsToSeed, instanceCoIdMap, schemaCoMaps, schemaCoIdMap);
    for (const configInfo of seeded.configs || []) {
      const actualCoId = configInfo.coId;
      const path = configInfo.path;
      const originalId = configInfo.expectedCoId;
      instanceCoIdMap.set(path, actualCoId);
      if (originalId) {
        instanceCoIdMap.set(originalId, actualCoId);
        combinedRegistry.set(originalId, actualCoId);
        coIdRegistry.register(originalId, actualCoId);
      }
      coIdRegistry.register(path, actualCoId);
    }
    return seeded;
  };
  if (configs) {
    const stylesSeeded = await seedConfigTypeAndRegister("styles", configs.styles);
    seededConfigs.configs.push(...stylesSeeded.configs || []);
    seededConfigs.count += stylesSeeded.count || 0;
    combinedRegistry = refreshCombinedRegistry();
    const actorsSeeded = await seedConfigTypeAndRegister("actors", configs.actors);
    seededConfigs.configs.push(...actorsSeeded.configs || []);
    seededConfigs.count += actorsSeeded.count || 0;
    combinedRegistry = refreshCombinedRegistry();
    const viewsSeeded = await seedConfigTypeAndRegister("views", configs.views);
    seededConfigs.configs.push(...viewsSeeded.configs || []);
    seededConfigs.count += viewsSeeded.count || 0;
    combinedRegistry = refreshCombinedRegistry();
    const contextsSeeded = await seedConfigTypeAndRegister("contexts", configs.contexts);
    seededConfigs.configs.push(...contextsSeeded.configs || []);
    seededConfigs.count += contextsSeeded.count || 0;
    combinedRegistry = refreshCombinedRegistry();
    const statesSeeded = await seedConfigTypeAndRegister("states", configs.states);
    seededConfigs.configs.push(...statesSeeded.configs || []);
    seededConfigs.count += statesSeeded.count || 0;
    combinedRegistry = refreshCombinedRegistry();
    const interfacesSeeded = await seedConfigTypeAndRegister("interfaces", configs.interfaces);
    seededConfigs.configs.push(...interfacesSeeded.configs || []);
    seededConfigs.count += interfacesSeeded.count || 0;
    combinedRegistry = refreshCombinedRegistry();
    const subscriptionsSeeded = await seedConfigTypeAndRegister("subscriptions", configs.subscriptions);
    seededConfigs.configs.push(...subscriptionsSeeded.configs || []);
    seededConfigs.count += subscriptionsSeeded.count || 0;
    combinedRegistry = refreshCombinedRegistry();
    const inboxesSeeded = await seedConfigTypeAndRegister("inboxes", configs.inboxes);
    seededConfigs.configs.push(...inboxesSeeded.configs || []);
    seededConfigs.count += inboxesSeeded.count || 0;
    combinedRegistry = refreshCombinedRegistry();
    const childrenSeeded = await seedConfigTypeAndRegister("children", configs.children);
    seededConfigs.configs.push(...childrenSeeded.configs || []);
    seededConfigs.count += childrenSeeded.count || 0;
    combinedRegistry = refreshCombinedRegistry();
    const toolsSeeded = await seedConfigTypeAndRegister("tool", configs.tool);
    seededConfigs.configs.push(...toolsSeeded.configs || []);
    seededConfigs.count += toolsSeeded.count || 0;
    combinedRegistry = refreshCombinedRegistry();
  }
  const updateConfigReferences = async (configsToUpdate, originalConfigs) => {
    if (!configsToUpdate || !originalConfigs) {
      return 0;
    }
    const latestRegistry = refreshCombinedRegistry();
    let updatedCount = 0;
    for (const configInfo of configsToUpdate) {
      configInfo.coId;
      const originalId = configInfo.expectedCoId;
      const originalConfig = originalId && originalConfigs ? Object.values(originalConfigs).find((cfg) => cfg.$id === originalId) : null;
      if (!originalConfig) {
        continue;
      }
      const fullyTransformed = transformForSeeding2(originalConfig, latestRegistry);
      const coValue = configInfo.coMap;
      const cotype2 = configInfo.cotype || "comap";
      if (cotype2 === "colist") {
        if (coValue && typeof coValue.append === "function") {
          const transformedItems = fullyTransformed.items || [];
          for (const item of transformedItems) {
            coValue.append(item);
          }
          updatedCount++;
        }
      } else if (cotype2 === "costream") {
        if (coValue && typeof coValue.push === "function") {
          const transformedItems = fullyTransformed.items || [];
          for (const item of transformedItems) {
            coValue.push(item);
          }
          updatedCount++;
        }
      } else {
        if (coValue && typeof coValue.set === "function") {
          const { $id: $id2, $schema: $schema2, ...propsToSet } = fullyTransformed;
          if (propsToSet.states && typeof propsToSet.states === "object") ;
          for (const [key, value] of Object.entries(propsToSet)) {
            coValue.set(key, value);
          }
          updatedCount++;
        }
      }
    }
    return updatedCount;
  };
  if (configs) {
    const subscriptionsToUpdate = seededConfigs.configs.filter((c) => c.type === "subscription");
    await updateConfigReferences(subscriptionsToUpdate, configs.subscriptions);
    const inboxesToUpdate = seededConfigs.configs.filter((c) => c.type === "inbox");
    await updateConfigReferences(inboxesToUpdate, configs.inboxes);
    const childrenToUpdate = seededConfigs.configs.filter((c) => c.type === "children");
    await updateConfigReferences(childrenToUpdate, configs.children);
    refreshCombinedRegistry();
    const actorsToUpdate = seededConfigs.configs.filter((c) => c.type === "actor");
    await updateConfigReferences(actorsToUpdate, configs.actors);
    const viewsToUpdate = seededConfigs.configs.filter((c) => c.type === "view");
    await updateConfigReferences(viewsToUpdate, configs.views);
    const contextsToUpdate = seededConfigs.configs.filter((c) => c.type === "context");
    await updateConfigReferences(contextsToUpdate, configs.contexts);
    const statesToUpdate = seededConfigs.configs.filter((c) => c.type === "state");
    await updateConfigReferences(statesToUpdate, configs.states);
    const interfacesToUpdate = seededConfigs.configs.filter((c) => c.type === "interface");
    await updateConfigReferences(interfacesToUpdate, configs.interfaces);
  }
  const allVibes = configs?.vibes || (configs?.vibe ? [configs.vibe] : []);
  if (allVibes.length > 0) {
    combinedRegistry = refreshCombinedRegistry();
    let vibesId = account.get("vibes");
    let vibes;
    if (vibesId) {
      const vibesCore = node.getCoValue(vibesId);
      if (vibesCore && vibesCore.type === "comap") {
        const vibesContent = vibesCore.getCurrentContent?.();
        if (vibesContent && typeof vibesContent.set === "function") {
          vibes = vibesContent;
        }
      }
    }
    if (!vibes) {
      const vibesMeta = { $schema: "GenesisSchema" };
      vibes = universalGroup.createMap({}, vibesMeta);
      account.set("vibes", vibes.id);
      console.log(`[CoJSONSeed] Created new account.vibes CoMap: ${vibes.id}`);
    } else {
      console.log(`[CoJSONSeed] Using existing account.vibes CoMap: ${vibesId}`);
    }
    for (const vibe of allVibes) {
      const actorRef = vibe.actor;
      if (actorRef && !actorRef.startsWith("co_z")) {
        const actorCoId = combinedRegistry.get(actorRef);
        if (!actorCoId) {
          const availableKeys = Array.from(combinedRegistry.keys()).filter((k) => k.startsWith("@actor/")).slice(0, 10).join(", ");
          console.warn(`[CoJSONSeed] Actor reference ${actorRef} not found in registry for vibe ${vibe.$id || vibe.name}. Available actor keys (first 10): ${availableKeys}`);
        }
      }
      const retransformedVibe = transformForSeeding2(vibe, combinedRegistry);
      console.log(`[CoJSONSeed] Transforming vibe '${vibe.$id || vibe.name}':`, {
        originalActor: vibe.actor,
        transformedActor: retransformedVibe.actor,
        isCoId: retransformedVibe.actor?.startsWith("co_z")
      });
      if (retransformedVibe.actor && !retransformedVibe.actor.startsWith("co_z")) {
        console.error(`[CoJSONSeed]  Vibe actor transformation failed! Expected co-id, got: ${retransformedVibe.actor}`);
        console.error(`[CoJSONSeed] Original actor: ${vibe.actor}, Registry has: ${combinedRegistry.has(vibe.actor)}`);
      }
      const originalVibeId = vibe.$id || "";
      const vibeKey = originalVibeId.startsWith("@vibe/") ? originalVibeId.replace("@vibe/", "") : (vibe.name || "default").toLowerCase().replace(/\s+/g, "-");
      const vibeConfigs = { vibe: retransformedVibe };
      const vibeSeeded = await seedConfigs(account, node, universalGroup, vibeConfigs, instanceCoIdMap, schemaCoMaps, schemaCoIdMap);
      seededConfigs.configs.push(...vibeSeeded.configs || []);
      seededConfigs.count += vibeSeeded.count || 0;
      if (vibeSeeded.configs && vibeSeeded.configs.length > 0) {
        const vibeInfo = vibeSeeded.configs[0];
        const vibeCoId = vibeInfo.coId;
        if (vibes && typeof vibes.set === "function") {
          vibes.set(vibeKey, vibeCoId);
          console.log(`[CoJSONSeed] Stored vibe in account.vibes: ${vibeKey} = ${vibeCoId}`);
          const storedValue = vibes.get(vibeKey);
          if (storedValue !== vibeCoId) {
            console.warn(`[CoJSONSeed]  Vibe ${vibeKey} storage verification failed! Expected ${vibeCoId}, got ${storedValue}`);
          }
        } else {
          console.error(`[CoJSONSeed]  Cannot store vibe ${vibeKey}: vibes CoMap not available`);
        }
        const originalVibeIdForRegistry = vibe.$id;
        if (allVibes.length === 1 || allVibes.indexOf(vibe) === allVibes.length - 1) {
          instanceCoIdMap.set("vibe", vibeCoId);
        }
        if (originalVibeIdForRegistry) {
          instanceCoIdMap.set(originalVibeIdForRegistry, vibeCoId);
          combinedRegistry.set(originalVibeIdForRegistry, vibeCoId);
          coIdRegistry.register(originalVibeIdForRegistry, vibeCoId);
        }
        if (allVibes.length === 1 || allVibes.indexOf(vibe) === allVibes.length - 1) {
          coIdRegistry.register("vibe", vibeCoId);
        }
      }
    }
    if (vibes && typeof vibes.get === "function") {
      console.log(`[CoJSONSeed] Verifying stored vibes in account.vibes:`);
      for (const vibe of allVibes) {
        const originalVibeId = vibe.$id || "";
        const vibeKey = originalVibeId.startsWith("@vibe/") ? originalVibeId.replace("@vibe/", "") : (vibe.name || "default").toLowerCase().replace(/\s+/g, "-");
        const storedValue = vibes.get(vibeKey);
        if (storedValue) {
          console.log(`[CoJSONSeed]  Verified: ${vibeKey} = ${storedValue}`);
        } else {
          console.error(`[CoJSONSeed]  Missing: ${vibeKey} not found in account.vibes!`);
        }
      }
    }
  }
  const seededData = await seedData(account, node, universalGroup, data2, coIdRegistry);
  await storeRegistry(account, node, universalGroup, coIdRegistry, schemaCoIdMap);
  return {
    metaSchema: metaSchemaCoId,
    schemas: seededSchemas,
    configs: seededConfigs,
    data: seededData,
    registry: coIdRegistry.getAll()
  };
}
async function seedConfigs(account, node, universalGroup, transformedConfigs, instanceCoIdMap, schemaCoMaps, schemaCoIdMap) {
  const seededConfigs = [];
  let totalCount = 0;
  const createConfig = async (config2, configType, path) => {
    const schemaCoId = config2.$schema;
    if (!schemaCoId || !schemaCoId.startsWith("co_z")) {
      throw new Error(`[CoJSONSeed] Config ${configType}:${path} has invalid $schema: ${schemaCoId}`);
    }
    let cotype2 = "comap";
    let schemaCoMap = null;
    for (const [schemaKey, coId] of schemaCoIdMap.entries()) {
      if (coId === schemaCoId) {
        schemaCoMap = schemaCoMaps.get(schemaKey);
        break;
      }
    }
    if (!schemaCoMap) {
      const schemaCore = node.getCoValue(schemaCoId);
      if (schemaCore && schemaCore.type === "comap") {
        schemaCoMap = schemaCore.getCurrentContent?.();
      }
    }
    if (schemaCoMap && typeof schemaCoMap.get === "function") {
      cotype2 = schemaCoMap.get("cotype") || "comap";
    } else {
      console.warn(`     Cannot read schema CoMap for ${schemaCoId ? schemaCoId.substring(0, 12) : "undefined"}... (config: ${path}), schemaCoMap type: ${typeof schemaCoMap}`);
    }
    const { $id: $id2, $schema: $schema2, ...configWithoutId } = config2;
    const meta = { $schema: schemaCoId };
    let coValue;
    let actualCoId;
    if (cotype2 === "colist") {
      coValue = universalGroup.createList([], meta);
      actualCoId = coValue.id;
    } else if (cotype2 === "costream") {
      coValue = universalGroup.createStream(meta);
      actualCoId = coValue.id;
    } else {
      coValue = universalGroup.createMap({}, meta);
      actualCoId = coValue.id;
      for (const [key, value] of Object.entries(configWithoutId)) {
        coValue.set(key, value);
      }
    }
    if ($id2) {
      instanceCoIdMap.set(path, actualCoId);
      instanceCoIdMap.set($id2, actualCoId);
    }
    return {
      type: configType,
      path,
      coId: actualCoId,
      expectedCoId: $id2 || void 0,
      // Use $id from config (line 899), or undefined if not present
      coMapId: actualCoId,
      coMap: coValue,
      // Store the actual CoValue reference (CoMap, CoList, or CoStream)
      cotype: cotype2
      // Store the type for reference
    };
  };
  if (transformedConfigs.vibe) {
    const vibeInfo = await createConfig(transformedConfigs.vibe, "vibe", "vibe");
    seededConfigs.push(vibeInfo);
    totalCount++;
  }
  const seedConfigType = async (configType, configsOfType) => {
    if (!configsOfType || typeof configsOfType !== "object") {
      return 0;
    }
    let typeCount = 0;
    for (const [path, config2] of Object.entries(configsOfType)) {
      if (config2 && typeof config2 === "object" && config2.$schema) {
        const configInfo = await createConfig(config2, configType, path);
        seededConfigs.push(configInfo);
        typeCount++;
      }
    }
    return typeCount;
  };
  totalCount += await seedConfigType("style", transformedConfigs.styles);
  totalCount += await seedConfigType("actor", transformedConfigs.actors);
  totalCount += await seedConfigType("view", transformedConfigs.views);
  totalCount += await seedConfigType("context", transformedConfigs.contexts);
  totalCount += await seedConfigType("state", transformedConfigs.states);
  totalCount += await seedConfigType("interface", transformedConfigs.interfaces);
  totalCount += await seedConfigType("subscription", transformedConfigs.subscriptions);
  totalCount += await seedConfigType("inbox", transformedConfigs.inboxes);
  totalCount += await seedConfigType("children", transformedConfigs.children);
  return {
    count: totalCount,
    types: [...new Set(seededConfigs.map((c) => c.type))],
    configs: seededConfigs
  };
}
async function seedData(account, node, universalGroup, data2, coIdRegistry) {
  const { transformForSeeding: transformForSeeding2 } = await Promise.resolve().then(() => schemaTransformer);
  if (!data2 || Object.keys(data2).length === 0) {
    return {
      collections: [],
      totalItems: 0
    };
  }
  const seededCollections = [];
  let totalItems = 0;
  for (const [collectionName, collectionItems] of Object.entries(data2)) {
    if (!Array.isArray(collectionItems)) {
      console.warn(`[CoJSONSeed] Skipping ${collectionName}: not an array`);
      continue;
    }
    const schemaKey1 = `data/${collectionName}`;
    const schemaKey2 = `@schema/data/${collectionName}`;
    const schemaKey3 = `@schema/${collectionName}`;
    const schemaCoId = coIdRegistry.registry.get(schemaKey1) || coIdRegistry.registry.get(schemaKey2) || coIdRegistry.registry.get(schemaKey3);
    if (!schemaCoId) {
      console.warn(`[CoJSONSeed] No schema found for collection ${collectionName} (tried: ${schemaKey1}, ${schemaKey2}, ${schemaKey3}), skipping`);
      continue;
    }
    let itemCount = 0;
    for (const item of collectionItems) {
      const transformedItem = transformForSeeding2(item, coIdRegistry.getAll());
      const { $id: $id2, ...itemWithoutId } = transformedItem;
      const itemMeta = { $schema: schemaCoId };
      universalGroup.createMap(itemWithoutId, itemMeta);
      itemCount++;
    }
    seededCollections.push({
      name: collectionName,
      schemaCoId,
      itemCount
    });
    totalItems += itemCount;
  }
  return {
    collections: seededCollections,
    totalItems
  };
}
async function ensureAccountOs(account, node, universalGroup) {
  let osId = account.get("os");
  if (osId) {
    let osCore2 = node.getCoValue(osId);
    if (!osCore2 && node.loadCoValueCore) {
      await node.loadCoValueCore(osId);
      osCore2 = node.getCoValue(osId);
    }
    if (osCore2 && osCore2.isAvailable()) {
      return;
    }
  }
  const osMeta = { $schema: "GenesisSchema" };
  const os = universalGroup.createMap({}, osMeta);
  account.set("os", os.id);
  if (node.storage && node.syncManager) {
    try {
      await node.syncManager.waitForStorageSync(os.id);
      await node.syncManager.waitForStorageSync(account.id);
    } catch (e) {
      console.warn(`[Seed] Storage sync wait failed for account.os:`, e);
    }
  }
  let osCore = node.getCoValue(os.id);
  if (osCore && !osCore.isAvailable()) {
    await new Promise((resolve2) => {
      let unsubscribe;
      const timeout = setTimeout(resolve2, 5e3);
      unsubscribe = osCore.subscribe((core2) => {
        if (core2 && core2.isAvailable()) {
          clearTimeout(timeout);
          unsubscribe();
          resolve2();
        }
      });
    });
  }
  osCore = node.getCoValue(os.id);
  if (osCore && osCore.isAvailable()) {
    const osContent = osCore.getCurrentContent?.();
    if (osContent && typeof osContent.get === "function") {
      const schematasId = osContent.get("schematas");
      if (!schematasId) {
        const schematasMeta = { $schema: "GenesisSchema" };
        const schematas = universalGroup.createMap({}, schematasMeta);
        osContent.set("schematas", schematas.id);
        if (node.storage && node.syncManager) {
          try {
            await node.syncManager.waitForStorageSync(schematas.id);
            await node.syncManager.waitForStorageSync(os.id);
          } catch (e) {
            console.warn(`[Seed] Storage sync wait failed for account.os.schematas:`, e);
          }
        }
      }
    }
  }
}
async function storeRegistry(account, node, universalGroup, coIdRegistry, schemaCoIdMap, instanceCoIdMap, configs, seededSchemas) {
  const osId = account.get("os");
  if (!osId) {
    console.warn(`[Seed] account.os not found - should have been created in Phase 0`);
    return;
  }
  let osCore = node.getCoValue(osId);
  if (!osCore && node.loadCoValueCore) {
    await node.loadCoValueCore(osId);
    osCore = node.getCoValue(osId);
  }
  if (!osCore || !osCore.isAvailable()) {
    console.warn(`[Seed] account.os (${osId ? osId.substring(0, 12) : "undefined"}...) not available`);
    return;
  }
  const osContent = osCore.getCurrentContent?.();
  if (!osContent || typeof osContent.get !== "function") {
    console.warn(`[Seed] account.os content not available`);
    return;
  }
  let schematasId = osContent.get("schematas");
  let schematas;
  if (schematasId) {
    const schematasCore = node.getCoValue(schematasId);
    if (schematasCore && schematasCore.isAvailable()) {
      const schematasContent = schematasCore.getCurrentContent?.();
      if (schematasContent && typeof schematasContent.set === "function") {
        schematas = schematasContent;
      }
    }
  }
  if (!schematas) {
    let schematasSchemaCoId = null;
    if (schemaCoIdMap && schemaCoIdMap.has("@schema/os/schematas-registry")) {
      schematasSchemaCoId = schemaCoIdMap.get("@schema/os/schematas-registry");
    }
    const schematasMeta = schematasSchemaCoId ? { $schema: schematasSchemaCoId } : { $schema: "GenesisSchema" };
    schematas = universalGroup.createMap({}, schematasMeta);
    osContent.set("schematas", schematas.id);
    if (node.storage && node.syncManager) {
      try {
        await node.syncManager.waitForStorageSync(schematas.id);
        await node.syncManager.waitForStorageSync(osId);
      } catch (e) {
        console.warn(`[Seed] Storage sync wait failed for account.os.schematas:`, e);
      }
    }
  }
  const metaschemaCoId = coIdRegistry.get("@schema/meta");
  if (metaschemaCoId) {
    const existingCoId = schematas.get("@schema/meta");
    if (!existingCoId) {
      schematas.set("@schema/meta", metaschemaCoId);
    } else if (existingCoId !== metaschemaCoId) {
      console.warn(`[Seed] Metaschema already registered with different co-id: ${existingCoId ? existingCoId.substring(0, 12) : "undefined"}... (new: ${metaschemaCoId ? metaschemaCoId.substring(0, 12) : "undefined"}...). Skipping.`);
    } else ;
  }
}
async function getGroup(node, groupId) {
  const groupCore = node.getCoValue(groupId);
  if (!groupCore || !(groupCore?.isAvailable() || false)) {
    return null;
  }
  const content = groupCore?.getCurrentContent();
  if (!content || typeof content.addMember !== "function") {
    return null;
  }
  return content;
}
async function getDefaultGroup(backend) {
  if (backend._cachedUniversalGroup) {
    return backend._cachedUniversalGroup;
  }
  const profileStore = await backend.read(null, backend.account.get("profile"));
  if (!profileStore || profileStore.error) {
    throw new Error("[CoJSONBackend] Profile not found on account. Ensure the account has a valid profile.");
  }
  await new Promise((resolve2, reject) => {
    if (!profileStore.loading) {
      resolve2();
      return;
    }
    let unsubscribe;
    const timeout = setTimeout(() => {
      reject(new Error("[CoJSONBackend] Timeout waiting for profile to be available"));
    }, 1e4);
    unsubscribe = profileStore.subscribe(() => {
      if (!profileStore.loading) {
        clearTimeout(timeout);
        unsubscribe();
        resolve2();
      }
    });
  });
  const profileData = profileStore.value;
  if (!profileData) {
    throw new Error("[CoJSONBackend] Profile data not available. Ensure the profile is properly loaded.");
  }
  const profileKeys = Object.keys(profileData).filter((key) => !["id", "type", "$schema"].includes(key));
  if (profileKeys.length === 0 && (!profileData.properties || profileData.properties.length === 0)) {
    throw new Error("[CoJSONBackend] Profile CoMap is empty. This may indicate the identity migration has not run. Please ensure schemaMigration() has been called during account creation/loading.");
  }
  let universalGroupId;
  if (profileData.properties && Array.isArray(profileData.properties)) {
    const groupProperty = profileData.properties.find((p) => p.key === "group");
    if (!groupProperty || !groupProperty.value) {
      throw new Error('[CoJSONBackend] Universal group not found in profile.group. The profile exists but does not have a "group" property. This indicates the identity migration may not have completed successfully. Please check that schemaMigration() sets profile.set("group", universalGroupId).');
    }
    universalGroupId = groupProperty.value;
  } else if (profileData.group && typeof profileData.group === "string") {
    universalGroupId = profileData.group;
  } else {
    throw new Error('[CoJSONBackend] Universal group not found in profile.group. The profile exists but does not have a "group" property. This indicates the identity migration may not have completed successfully. Please ensure schemaMigration() has been called and sets profile.set("group", universalGroupId).');
  }
  if (!universalGroupId || typeof universalGroupId !== "string" || !universalGroupId.startsWith("co_z")) {
    throw new Error(`[CoJSONBackend] Invalid universal group ID format: ${universalGroupId}. Expected a valid co-id (co_z...). This may indicate a migration issue.`);
  }
  const groupStore = await backend.read("@group", universalGroupId);
  if (!groupStore || groupStore.error) {
    throw new Error(`[CoJSONBackend] Universal group not available: ${universalGroupId}. Ensure the group exists and is synced.`);
  }
  await new Promise((resolve2, reject) => {
    if (!groupStore.loading) {
      resolve2();
      return;
    }
    let unsubscribe;
    const timeout = setTimeout(() => {
      reject(new Error(`[CoJSONBackend] Timeout waiting for universal group ${universalGroupId} to be available`));
    }, 1e4);
    unsubscribe = groupStore.subscribe(() => {
      if (!groupStore.loading) {
        clearTimeout(timeout);
        unsubscribe();
        resolve2();
      }
    });
  });
  const universalGroupCore = backend.getCoValue(universalGroupId);
  if (!universalGroupCore) {
    throw new Error(`[CoJSONBackend] Universal group core not found: ${universalGroupId}. Ensure the group is loaded in the node.`);
  }
  const universalGroup = backend.getCurrentContent(universalGroupCore);
  if (!universalGroup || typeof universalGroup.createMap !== "function") {
    throw new Error(`[CoJSONBackend] Universal group content not available: ${universalGroupId}. Ensure the group is properly initialized.`);
  }
  backend._cachedUniversalGroup = universalGroup;
  return universalGroup;
}
function extractAccountMembers(groupContent) {
  const accountMembers = [];
  try {
    if (groupContent.members && typeof groupContent.members[Symbol.iterator] === "function") {
      for (const member of groupContent.members) {
        if (member && member.account) {
          const accountRef = member.account;
          const memberId = typeof accountRef === "string" ? accountRef : accountRef.id || accountRef.$jazz && accountRef.$jazz.id || "unknown";
          let role = null;
          if (typeof groupContent.getRoleOf === "function") {
            try {
              role = groupContent.getRoleOf(memberId);
            } catch (e) {
            }
          }
          if (role && role !== "revoked") {
            accountMembers.push({
              id: memberId,
              role: role || "unknown"
            });
          }
        }
      }
    }
  } catch (e) {
    console.warn("[CoJSONBackend] Error extracting account members:", e);
  }
  return accountMembers;
}
function extractEveryoneRole(groupContent) {
  try {
    let everyoneRole = null;
    if (typeof groupContent.getRoleOf === "function") {
      try {
        const role = groupContent.getRoleOf("everyone");
        if (role && typeof role === "string" && role !== "revoked") {
          everyoneRole = role;
        }
      } catch (e) {
      }
    }
    if (!everyoneRole && typeof groupContent.get === "function") {
      try {
        const value = groupContent.get("everyone");
        if (value && typeof value === "string" && value !== "revoked") {
          everyoneRole = value;
        }
      } catch (e) {
      }
    }
    if (!everyoneRole && groupContent.everyone !== void 0) {
      const value = groupContent.everyone;
      if (value && typeof value === "string" && value !== "revoked") {
        everyoneRole = value;
      }
    }
    return everyoneRole;
  } catch (e) {
    return null;
  }
}
function extractGroupMembers(groupContent) {
  const groupMembers = [];
  try {
    if (typeof groupContent.getParentGroups === "function") {
      const parentGroups = groupContent.getParentGroups();
      if (parentGroups && typeof parentGroups[Symbol.iterator] === "function") {
        for (const parentGroup of parentGroups) {
          const parentId = typeof parentGroup === "string" ? parentGroup : parentGroup.id || parentGroup.$jazz && parentGroup.$jazz.id || "unknown";
          let role = null;
          if (typeof groupContent.getRoleOf === "function") {
            try {
              role = groupContent.getRoleOf(parentId);
            } catch (e) {
            }
          }
          groupMembers.push({
            id: parentId,
            role: role || "admin"
          });
        }
      }
    }
  } catch (e) {
    console.warn("[CoJSONBackend] Error extracting group members:", e);
  }
  return groupMembers;
}
function getGroupInfoFromGroup(group) {
  if (!group || typeof group.addMember !== "function") {
    return null;
  }
  try {
    const groupId = group.id || group.$jazz && group.$jazz.id;
    if (!groupId) {
      return null;
    }
    const accountMembers = extractAccountMembers(group);
    const everyoneRole = extractEveryoneRole(group);
    if (everyoneRole) {
      const everyoneExists = accountMembers.some((m) => m.id === "everyone");
      if (!everyoneExists) {
        accountMembers.push({
          id: "everyone",
          role: everyoneRole
        });
      }
    }
    const groupMembers = extractGroupMembers(group);
    return {
      groupId,
      accountMembers,
      groupMembers
    };
  } catch (error) {
    console.warn("[CoJSONBackend] Error getting group info from group:", error);
    return null;
  }
}
async function addGroupMember(node, group, memberId, role) {
  if (typeof group.addMember !== "function") {
    throw new Error("[CoJSONBackend] Group does not support addMember");
  }
  const memberCore = node.getCoValue(memberId);
  if (!memberCore) {
    throw new Error(`[CoJSONBackend] Member not found: ${memberId}`);
  }
  try {
    group.addMember(memberId, role);
  } catch (error) {
    const memberContent = memberCore?.getCurrentContent();
    if (memberContent && memberContent.account) {
      group.addMember(memberContent.account, role);
    } else {
      throw new Error(`[CoJSONBackend] Failed to add member: ${error.message}`);
    }
  }
}
async function removeGroupMember(group, memberId) {
  if (typeof group.removeMember !== "function") {
    throw new Error("[CoJSONBackend] Group does not support removeMember");
  }
  group.removeMember(memberId);
}
async function setGroupMemberRole(node, group, memberId, role) {
  if (typeof group.setRole === "function") {
    group.setRole(memberId, role);
  } else if (typeof group.removeMember === "function" && typeof group.addMember === "function") {
    group.removeMember(memberId);
    await addGroupMember(node, group, memberId, role);
  } else {
    throw new Error("[CoJSONBackend] Group does not support role changes");
  }
}
async function update(backend, schema, id2, data2) {
  const coValueCore = await ensureCoValueLoaded(backend, id2, { waitForAvailable: true });
  if (!coValueCore) {
    throw new Error(`[CoJSONBackend] CoValue not found: ${id2}`);
  }
  if (!backend.isAvailable(coValueCore)) {
    throw new Error(`[CoJSONBackend] CoValue not available: ${id2}`);
  }
  const content = backend.getCurrentContent(coValueCore);
  const rawType = content?.type || "unknown";
  if (rawType === "comap" && content.set) {
    for (const [key, value] of Object.entries(data2)) {
      content.set(key, value);
    }
  } else {
    throw new Error(`[CoJSONBackend] Update not supported for type: ${rawType}`);
  }
  return extractCoValueData(backend, coValueCore);
}
const update$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  update
}, Symbol.toStringTag, { value: "Module" }));
const pendingIndexing = /* @__PURE__ */ new Set();
function wrapStorageWithIndexingHooks(storage, backend) {
  if (!storage || !backend) {
    return storage;
  }
  const originalStore = storage.store.bind(storage);
  const wrappedStorage = new Proxy(storage, {
    get(target, prop) {
      if (prop === "store") {
        return function(msg, correctionCallback) {
          return wrappedStore.call(target, msg, correctionCallback, originalStore);
        };
      }
      const value = target[prop];
      if (typeof value === "function") {
        return value.bind(target);
      }
      return value;
    }
  });
  function wrappedStore(msg, correctionCallback, originalStore2) {
    const coId = msg.id;
    let shouldSkipIndexing = false;
    if (msg.header && msg.header.meta) {
      const schema = msg.header.meta.$schema;
      if (schema === EXCEPTION_SCHEMAS.ACCOUNT || schema === EXCEPTION_SCHEMAS.GROUP) {
        shouldSkipIndexing = true;
      }
      if (msg.header.meta.type === "account") {
        shouldSkipIndexing = true;
      }
      if (msg.header.ruleset && msg.header.ruleset.type === "group") {
        shouldSkipIndexing = true;
      }
    }
    if (!shouldSkipIndexing && backend.account) {
      const osId = backend.account.get("os");
      if (coId === osId) {
        shouldSkipIndexing = true;
      } else if (osId) {
        const osCore = backend.node.getCoValue(osId);
        if (osCore && backend.isAvailable(osCore) && osCore.type === "comap") {
          const osContent = osCore.getCurrentContent?.();
          if (osContent && typeof osContent.get === "function") {
            const schematasId = osContent.get("schematas");
            if (coId === schematasId) {
              shouldSkipIndexing = true;
            }
            const unknownId = osContent.get("unknown");
            if (coId === unknownId) {
              shouldSkipIndexing = true;
            }
            try {
              const keys = osContent.keys && typeof osContent.keys === "function" ? osContent.keys() : Object.keys(osContent);
              for (const key of keys) {
                if (key !== "schematas" && key !== "unknown") {
                  const valueId = osContent.get(key);
                  if (valueId === coId) {
                    shouldSkipIndexing = true;
                    break;
                  }
                }
              }
            } catch (e) {
              shouldSkipIndexing = true;
            }
          }
        } else if (!osCore || !backend.isAvailable(osCore)) {
          shouldSkipIndexing = true;
        }
      }
    }
    const storeResult = originalStore2(msg, correctionCallback);
    if (shouldSkipIndexing) {
      return storeResult;
    }
    Promise.resolve(storeResult).then(async () => {
      if (pendingIndexing.has(coId)) {
        return;
      }
      pendingIndexing.add(coId);
      try {
        let coValueCore = backend.getCoValue(coId);
        if (!coValueCore || !backend.isAvailable(coValueCore)) {
          if (backend.node && backend.node.loadCoValueCore) {
            backend.node.loadCoValueCore(coId).catch(() => {
            });
          }
          if (!coValueCore || !backend.isAvailable(coValueCore)) {
            return;
          }
        }
        const updatedCoValueCore = backend.getCoValue(coId);
        if (!updatedCoValueCore || !backend.isAvailable(updatedCoValueCore)) {
          return;
        }
        const isSchema = await isSchemaCoValue(backend, updatedCoValueCore);
        if (isSchema) {
          setTimeout(() => {
            if (!pendingIndexing.has(coId)) {
              return;
            }
            registerSchemaCoValue(backend, updatedCoValueCore).then(() => {
              pendingIndexing.delete(coId);
            }).catch(() => {
              pendingIndexing.delete(coId);
            });
          }, 0);
          return;
        }
        const { shouldIndex } = await shouldIndexCoValue(backend, updatedCoValueCore);
        if (!shouldIndex) {
          return;
        }
        setTimeout(() => {
          if (!pendingIndexing.has(coId)) {
            return;
          }
          indexCoValue(backend, updatedCoValueCore).then(() => {
            pendingIndexing.delete(coId);
          }).catch(() => {
            pendingIndexing.delete(coId);
          });
        }, 0);
      } catch (error) {
        pendingIndexing.delete(coId);
      }
    }).catch(() => {
      const coId2 = msg.id;
      pendingIndexing.delete(coId2);
    });
    return storeResult;
  }
  return wrappedStorage;
}
class CoJSONBackend extends DBAdapter {
  constructor(node, account, dbEngine = null) {
    super();
    this.node = node;
    this.account = account;
    this.dbEngine = dbEngine;
    this.subscriptionCache = getGlobalCoCache(node);
    this._cachedUniversalGroup = null;
    if (node.storage) {
      node.storage = wrapStorageWithIndexingHooks(node.storage, this);
    }
  }
  /**
   * Reset all subscription-related caches
   * 
   * Called when new backend is created to clear stale subscriptions from previous session.
   */
  _resetCaches() {
    if (this._cachedUniversalGroup) {
      this._cachedUniversalGroup = null;
    }
  }
  /**
   * Get a CoValue by ID
   * @param {string} coId - CoValue ID
   * @returns {CoValueCore|null} CoValueCore or null if not found
   */
  getCoValue(coId) {
    return this.node.getCoValue(coId);
  }
  /**
   * Get all CoValues from the node
   * @returns {Map<string, CoValueCore>} Map of CoValue IDs to CoValueCore instances
   */
  getAllCoValues() {
    return this.node.coValues || /* @__PURE__ */ new Map();
  }
  /**
   * Check if CoValue is available (has verified state)
   * @param {CoValueCore} coValueCore - CoValueCore instance
   * @returns {boolean} True if available
   */
  isAvailable(coValueCore) {
    return coValueCore?.isAvailable() || false;
  }
  /**
   * Get current content from CoValueCore
   * @param {CoValueCore} coValueCore - CoValueCore instance
   * @returns {RawCoValue|null} Current content or null
   */
  getCurrentContent(coValueCore) {
    if (!coValueCore || !coValueCore.isAvailable()) {
      return null;
    }
    return coValueCore.getCurrentContent();
  }
  /**
   * Get header from CoValueCore
   * @param {CoValueCore} coValueCore - CoValueCore instance
   * @returns {Object|null} Header object or null
   */
  getHeader(coValueCore) {
    return coValueCore?.verified?.header || null;
  }
  /**
   * Get account (for create operations)
   * @returns {RawAccount} Account CoMap
   */
  getAccount() {
    return this.account;
  }
  /**
   * Get current session ID from the node
   * @returns {string|null} Current session ID or null if node not available
   */
  getCurrentSessionID() {
    if (!this.node || !this.node.currentSessionID) {
      return null;
    }
    return this.node.currentSessionID;
  }
  /**
   * Read inbox CoStream with session structure and CRDT metadata preserved
   * Backend-to-backend method for inbox processing
   * @param {string} inboxCoId - Inbox CoStream co-id
   * @returns {Object|null} CoStream data with sessions and CRDT metadata, or null if not found/not a CoStream
   */
  readInboxWithSessions(inboxCoId) {
    const coValueCore = this.getCoValue(inboxCoId);
    if (!coValueCore || !this.isAvailable(coValueCore)) {
      return null;
    }
    return extractCoStreamWithSessions(this, coValueCore);
  }
  /**
   * Get default group from account (for create operations)
   * Returns universal group via account.profile.group using read() API
   * Uses @group exception since groups don't have $schema
   * Caches result after first resolution for performance
   * @returns {RawGroup|null} Universal group or account as fallback
   */
  async getDefaultGroup() {
    return await getDefaultGroup(this);
  }
  /**
   * Get group information for a CoValue
   * Extracts owner group, account members, and group members with roles
   * @param {CoValueCore} coValueCore - CoValueCore instance
   * @returns {Object|null} Group info object or null if no group found
   */
  getGroupInfo(coValueCore) {
    if (!coValueCore || !this.isAvailable(coValueCore)) {
      return null;
    }
    try {
      const header = this.getHeader(coValueCore);
      const content = this.getCurrentContent(coValueCore);
      const ruleset = coValueCore.ruleset || header?.ruleset;
      if (!ruleset) {
        return null;
      }
      let ownerGroupId = null;
      let ownerGroupCore = null;
      let ownerGroupContent = null;
      if (ruleset.type === "group") {
        ownerGroupId = coValueCore.id;
        ownerGroupCore = coValueCore;
        ownerGroupContent = content;
      } else {
        if (content && content.group) {
          const groupRef = content.group;
          ownerGroupId = typeof groupRef === "string" ? groupRef : groupRef.id || groupRef.$jazz && groupRef.$jazz.id;
          if (ownerGroupId) {
            ownerGroupCore = this.getCoValue(ownerGroupId);
            if (ownerGroupCore && this.isAvailable(ownerGroupCore)) {
              ownerGroupContent = this.getCurrentContent(ownerGroupCore);
            }
          }
        } else {
          return null;
        }
      }
      if (!ownerGroupContent || typeof ownerGroupContent.addMember !== "function") {
        return null;
      }
      return getGroupInfoFromGroup(ownerGroupContent);
    } catch (error) {
      console.warn("[CoJSONBackend] Error getting group info:", error);
      return null;
    }
  }
  /**
   * Get a Group CoValue by ID
   * @param {string} groupId - Group CoValue ID
   * @returns {Promise<RawGroup|null>} Group CoValue or null if not found
   */
  async getGroup(groupId) {
    return await getGroup(this.node, groupId);
  }
  /**
   * Get group info from a RawGroup
   * @param {RawGroup} group - RawGroup instance
   * @returns {Object|null} Group info object
   */
  getGroupInfoFromGroup(group) {
    return getGroupInfoFromGroup(group);
  }
  /**
   * Add a member to a group
   * @param {RawGroup} group - Group CoValue
   * @param {string} memberId - Member ID (account or group Co-ID)
   * @param {string} role - Role name
   * @returns {Promise<void>}
   */
  async addGroupMember(group, memberId, role) {
    return await addGroupMember(this.node, group, memberId, role);
  }
  /**
   * Remove a member from a group
   * @param {RawGroup} group - Group CoValue
   * @param {string} memberId - Member ID to remove
   * @returns {Promise<void>}
   */
  async removeGroupMember(group, memberId) {
    return await removeGroupMember(group, memberId);
  }
  /**
   * Set a member's role in a group
   * @param {RawGroup} group - Group CoValue
   * @param {string} memberId - Member ID
   * @param {string} role - New role name
   * @returns {Promise<void>}
   */
  async setGroupMemberRole(group, memberId, role) {
    return await setGroupMemberRole(this.node, group, memberId, role);
  }
  // ============================================================================
  // DBAdapter Interface Implementation
  // ============================================================================
  /**
   * Read data from database - directly translates to CoJSON raw operations
   * @param {string} schema - Schema co-id (co_z...) or special exceptions:
   *   - '@group' - For groups (no $schema, use ruleset.type === 'group')
   *   - '@account' - For accounts (no $schema, use headerMeta.type === 'account')
   *   - '@meta-schema' or 'GenesisSchema' - For meta schema
   * @param {string} [key] - Specific key (co-id) for single item
   * @param {string[]} [keys] - Array of co-ids for batch reads
   * @param {Object} [filter] - Filter criteria for collection queries
   * @param {Object} [options] - Options for deep resolution
   * @param {boolean} [options.deepResolve=true] - Enable/disable deep resolution (default: true)
   * @param {number} [options.maxDepth=10] - Maximum depth for recursive resolution (default: 10)
   * @param {number} [options.timeoutMs=5000] - Timeout for waiting for nested CoValues (default: 5000)
   * @param {Object} [options.resolveReferences] - Configuration for resolving CoValue references (e.g., { fields: ['source', 'target'] })
   * @param {Object} [options.map] - Map transformation config (e.g., { sender: '$$source.role', recipient: '$$target.role' })
   * @returns {Promise<ReactiveStore|ReactiveStore[]>} Reactive store(s) that hold current value and notify on updates
   */
  async read(schema, key, keys, filter, options = {}) {
    const {
      deepResolve = true,
      maxDepth = 10,
      timeoutMs = 5e3,
      resolveReferences = null,
      map = null,
      onChange = null
    } = options;
    const readOptions = { deepResolve, maxDepth, timeoutMs, resolveReferences, map, onChange };
    if (keys && Array.isArray(keys)) {
      const stores = await Promise.all(keys.map((coId) => read(this, coId, schema, null, schema, readOptions)));
      return stores;
    }
    if (key) {
      return await read(this, key, schema, null, schema, readOptions);
    }
    if (!schema) {
      return await read(this, null, null, filter, null, readOptions);
    }
    return await read(this, null, schema, filter, null, readOptions);
  }
  /**
   * Read a single CoValue by ID and wrap in ReactiveStore
   * Waits for CoValue to be loaded before returning store (operations API abstraction)
   * @private
   * @param {string} coId - CoValue ID
   * @param {string} [schemaHint] - Schema hint for special types (@group, @account, @meta-schema)
   * @returns {Promise<ReactiveStore>} ReactiveStore with CoValue data (already loaded)
   */
  async _readSingleItem(coId, schemaHint = null) {
    return await read(this, coId, schemaHint, null, schemaHint);
  }
  /**
   * Wait for a ReactiveStore to be ready (loaded and not in error state)
   * Used internally by _readSingleItem to ensure stores are ready before returning
   * @private
   * @param {ReactiveStore} store - Store to wait for
   * @param {string} coId - CoValue ID (for error messages)
   * @param {number} timeoutMs - Timeout in milliseconds (default: 5000)
   * @returns {Promise<void>} Resolves when store is ready, rejects on timeout or error
   */
  async _waitForStoreReady(store, coId, timeoutMs = 5e3) {
    return await waitForStoreReady(store, coId, timeoutMs);
  }
  /**
   * Get CoList ID from schema index (account.os.<schemaCoId>)
   * Supports schema co-ids, human-readable schema names, or collection names (legacy fallback)
   * @private
   * @param {string} collectionNameOrSchema - Collection name (e.g., "todos"), schema co-id (co_z...), or namekey (@schema/data/todos)
   * @returns {Promise<string|null>} CoList ID or null if not found
   */
  async _getCoListId(collectionName) {
    return await getCoListId(this, collectionName);
  }
  /**
   * Ensure CoValue is loaded from IndexedDB (jazz-tools pattern)
   * Generic method that works for ANY CoValue type (CoMap, CoList, CoStream, etc.)
   * After re-login, CoValues exist in IndexedDB but aren't loaded into node memory
   * This method explicitly loads them before accessing, just like jazz-tools does
   * @private
   * @param {string} coId - CoValue ID (co-id)
   * @param {Object} [options] - Options
   * @param {boolean} [options.waitForAvailable=false] - Wait for CoValue to become available
   * @param {number} [options.timeoutMs=2000] - Timeout in milliseconds
   * @returns {Promise<CoValueCore|null>} CoValueCore or null if not found
   */
  async _ensureCoValueLoaded(coId, options = {}) {
    return await ensureCoValueLoaded(this, coId, options);
  }
  /**
   * Read a collection of CoValues by schema
   * @private
   * @param {string} schema - Schema co-id (co_z...)
   * @param {Object} [filter] - Filter criteria
   * @returns {Promise<ReactiveStore>} ReactiveStore with array of CoValue data
   */
  async _readCollection(schema, filter) {
    return await read(this, null, schema, filter);
  }
  /**
   * Read all CoValues (no schema filter)
   * @private
   * @param {Object} [filter] - Filter criteria
   * @returns {Promise<ReactiveStore>} ReactiveStore with array of all CoValue data
   */
  async _readAllCoValues(filter) {
    return await read(this, null, null, filter);
  }
  /**
   * Extract CoValue data from CoValueCore and normalize (match IndexedDB format)
   * @private
   * @param {CoValueCore} coValueCore - CoValueCore instance
   * @param {string} [schemaHint] - Schema hint for special types (@group, @account, @meta-schema)
   * @returns {Object} Normalized CoValue data (flattened properties, id field added)
   */
  _extractCoValueData(coValueCore, schemaHint = null) {
    return extractCoValueData(this, coValueCore, schemaHint);
  }
  /**
   * Extract CoValue data as flat object (for SubscriptionEngine and UI)
   * Returns flat objects like {id: '...', text: '...', done: false} instead of normalized format
   * @private
   * @param {CoValueCore} coValueCore - CoValueCore instance
   * @param {string} [schemaHint] - Schema hint for special types
   * @returns {Object|Array} Flat object or array of items
   */
  _extractCoValueDataFlat(coValueCore, schemaHint = null) {
    return extractCoValueDataFlat(this, coValueCore, schemaHint);
  }
  /**
   * Extract CoValue data from RawCoValue content
   * @private
   * @param {RawCoValue} content - RawCoValue content
   * @returns {Object} Extracted data
   */
  _extractCoValueDataFromContent(content) {
    return extractCoValueDataFromContent(content);
  }
  /**
   * Check if CoValue data matches filter criteria
   * @private
   * @param {Object|Array} data - CoValue data (object for CoMap, array for CoList)
   * @param {Object} filter - Filter criteria
   * @returns {boolean} True if matches filter
   */
  _matchesFilter(data2, filter) {
    return matchesFilter(data2, filter);
  }
  /**
   * Create new record - directly creates CoValue using CoJSON raw methods
   * @param {string} schema - Schema co-id (co_z...) for data collections
   * @param {Object} data - Data to create
   * @returns {Promise<Object>} Created record with generated co-id
   */
  async create(schema, data2) {
    return await create(this, schema, data2);
  }
  /**
   * Update existing record - directly updates CoValue using CoJSON raw methods
   * @param {string} schema - Schema co-id (co_z...)
   * @param {string} id - Record co-id to update
   * @param {Object} data - Data to update
   * @returns {Promise<Object>} Updated record
   */
  async update(schema, id2, data2) {
    return await update(this, schema, id2, data2);
  }
  /**
   * Delete record - hard delete using CoJSON native operations
   * Removes item from CoList (hard delete) and clears CoMap content
   * @param {string} schema - Schema co-id (co_z...)
   * @param {string} id - Record co-id to delete
   * @returns {Promise<boolean>} true if deleted successfully
   */
  async delete(schema, id2) {
    return await deleteRecord(this, schema, id2);
  }
  /**
   * Get raw record from database (without normalization)
   * Used for validation - returns stored data as-is (with $schema metadata, without id)
   * @param {string} id - Record co-id
   * @returns {Promise<Object|null>} Raw stored record or null if not found
   */
  async getRawRecord(id2) {
    const coValueCore = this.getCoValue(id2);
    if (!coValueCore || !this.isAvailable(coValueCore)) {
      return null;
    }
    const content = this.getCurrentContent(coValueCore);
    const header = this.getHeader(coValueCore);
    const headerMeta = header?.meta || null;
    const schema = headerMeta?.$schema || null;
    if (content && content.get && typeof content.get === "function") {
      const raw = {
        $schema: schema
        // Metadata for querying/validation
      };
      const keys = content.keys && typeof content.keys === "function" ? content.keys() : Object.keys(content);
      for (const key of keys) {
        raw[key] = content.get && typeof content.get === "function" ? content.get(key) : content[key];
      }
      return raw;
    }
    if (content && content.toJSON) {
      try {
        return content.toJSON();
      } catch (e) {
        return null;
      }
    }
    return null;
  }
  /**
   * Seed database with configs, schemas, and initial data
   * @param {Object} configs - Config registry {vibe, styles, actors, views, contexts, states, interfaces}
   * @param {Object} schemas - Schema definitions
   * @param {Object} data - Initial application data {todos: [], ...}
   * @returns {Promise<Object>} Summary of what was seeded
   */
  async seed(configs, schemas, data2) {
    if (!this.account) {
      throw new Error("[CoJSONBackend] Account required for seed");
    }
    return await seed(this.account, this.node, configs, schemas, data2 || {}, this);
  }
}
const cojsonBackend = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CoJSONBackend
}, Symbol.toStringTag, { value: "Module" }));
function createCoJSONAPI(node, account) {
  if (!node) {
    throw new Error("[createCoJSONAPI] Node required");
  }
  if (!account) {
    throw new Error("[createCoJSONAPI] Account required");
  }
  const backend = new CoJSONBackend(node, account);
  const dbEngine = new DBEngine$1(backend);
  backend.dbEngine = dbEngine;
  return {
    /**
     * Execute a database operation
     * @param {Object} payload - Operation payload
     * @param {string} payload.op - Operation name (read, create, update, delete)
     * @param {Object} payload params - Operation-specific parameters
     * @returns {Promise<any>} Operation result
     */
    cojson: async (payload) => {
      return await dbEngine.execute(payload);
    }
  };
}
async function createAndPushMessage(dbEngine, inboxCoId, messageData) {
  if (!dbEngine) {
    throw new Error("[createAndPushMessage] dbEngine is required");
  }
  if (!inboxCoId || !inboxCoId.startsWith("co_z")) {
    throw new Error(`[createAndPushMessage] inboxCoId must be a valid co-id (co_z...), got: ${inboxCoId}`);
  }
  if (!messageData || typeof messageData !== "object") {
    throw new Error("[createAndPushMessage] messageData must be an object");
  }
  let messageSchemaCoId = null;
  try {
    const inboxSchemaStore = await dbEngine.execute({
      op: "schema",
      fromCoValue: inboxCoId
    });
    const inboxSchema2 = inboxSchemaStore.value;
    if (inboxSchema2 && inboxSchema2.items && inboxSchema2.items.$co) {
      const messageSchemaRef = inboxSchema2.items.$co;
      if (messageSchemaRef.startsWith("co_z")) {
        messageSchemaCoId = messageSchemaRef;
      } else if (messageSchemaRef.startsWith("@schema/")) {
        const schemaName = messageSchemaRef.replace("@schema/", "");
        const messageSchemaStore = await dbEngine.execute({
          op: "schema",
          schemaName
        });
        const messageSchema3 = messageSchemaStore.value;
        if (messageSchema3 && messageSchema3.$id) {
          messageSchemaCoId = messageSchema3.$id;
        }
      }
    }
    if (!messageSchemaCoId) {
      messageSchemaCoId = await dbEngine.execute({
        op: "resolve",
        humanReadableKey: "@schema/message"
      });
    }
    if (!messageSchemaCoId || !messageSchemaCoId.startsWith("co_z")) {
      throw new Error(`[createAndPushMessage] Failed to get message schema co-id. Inbox schema items.$co: ${inboxSchema2?.items?.$co || "not found"}`);
    }
  } catch (error) {
    throw new Error(`[createAndPushMessage] Failed to get message schema co-id: ${error.message}`);
  }
  const messageSchema2 = await resolve$1(dbEngine.backend, messageSchemaCoId, { returnType: "schema" });
  if (!messageSchema2) {
    throw new Error(`[createAndPushMessage] Message schema not found: ${messageSchemaCoId}`);
  }
  const messageDataWithDefaults = {
    processed: false,
    ...messageData
  };
  await validateAgainstSchemaOrThrow(messageSchema2, messageDataWithDefaults, "createAndPushMessage");
  const createResult = await dbEngine.execute({
    op: "create",
    schema: messageSchemaCoId,
    data: messageDataWithDefaults
  });
  if (!createResult || !createResult.id) {
    throw new Error("[createAndPushMessage] Failed to create message CoMap - create operation returned no id");
  }
  const messageCoId = createResult.id;
  if (!messageCoId.startsWith("co_z")) {
    throw new Error(`[createAndPushMessage] Invalid message co-id returned: ${messageCoId}`);
  }
  await dbEngine.execute({
    op: "push",
    coId: inboxCoId,
    item: messageCoId
    // Push co-id string, not plain object
  });
  return messageCoId;
}
async function processInbox(backend, actorId, inboxCoId) {
  if (!backend || !actorId || !inboxCoId) {
    throw new Error("[processInbox] backend, actorId, and inboxCoId are required");
  }
  const currentSessionID = backend.getCurrentSessionID();
  if (!currentSessionID) {
    throw new Error("[processInbox] Cannot get current session ID from backend");
  }
  const dbEngine = backend.dbEngine;
  if (!dbEngine) {
    throw new Error("[processInbox] Backend must have dbEngine set");
  }
  let messageSchemaCoId = null;
  try {
    const inboxSchemaStore = await dbEngine.execute({
      op: "schema",
      fromCoValue: inboxCoId
    });
    const inboxSchema2 = inboxSchemaStore.value;
    if (inboxSchema2 && inboxSchema2.items && inboxSchema2.items.$co) {
      const messageSchemaRef = inboxSchema2.items.$co;
      if (messageSchemaRef.startsWith("co_z")) {
        messageSchemaCoId = messageSchemaRef;
      } else if (messageSchemaRef.startsWith("@schema/")) {
        const schemaName = messageSchemaRef.replace("@schema/", "");
        const messageSchemaStore = await dbEngine.execute({
          op: "schema",
          schemaName
        });
        const messageSchema2 = messageSchemaStore.value;
        if (messageSchema2 && messageSchema2.$id) {
          messageSchemaCoId = messageSchema2.$id;
        } else {
          console.warn(`[processInbox] Failed to resolve message schema reference ${messageSchemaRef}`);
        }
      } else {
        console.warn(`[processInbox] Unknown message schema reference format: ${messageSchemaRef}`);
      }
    }
  } catch (error) {
    console.warn(`[processInbox] Failed to get message schema:`, error);
  }
  const inboxData = backend.readInboxWithSessions(inboxCoId);
  if (!inboxData || !inboxData.sessions) {
    return { messages: [] };
  }
  const unprocessedMessages = [];
  for (const [sessionID, messages] of Object.entries(inboxData.sessions)) {
    for (const message of messages) {
      const isSystemMessage = message.type === "INIT" || message.from === "system";
      if (isSystemMessage) {
        continue;
      }
      const madeAt = message._madeAt || 0;
      const messageCoId = message._coId;
      if (!messageCoId) {
        console.error(
          `[processInbox]  REJECTED legacy plain object message in inbox ${inboxCoId}. All messages must be CoMap references (co-id strings). Message data: ${JSON.stringify(message).substring(0, 200)}`
        );
        continue;
      }
      try {
        const messageStore = await read(backend, messageCoId, messageSchemaCoId);
        try {
          await waitForStoreReady(messageStore, messageCoId, 2e3);
        } catch (waitError) {
          console.warn(`[processInbox] Message CoMap not available: ${messageCoId} - ${waitError.message}`);
          continue;
        }
        const messageData = messageStore.value;
        if (!messageData || messageData.error) {
          console.warn(`[processInbox] Message CoMap error: ${messageCoId} - ${messageData?.error || "unknown error"}`);
          continue;
        }
        const isProcessed = messageData.processed === true;
        if (!isProcessed) {
          try {
            await dbEngine.execute({
              op: "update",
              schema: messageSchemaCoId,
              id: messageCoId,
              data: { processed: true }
            });
            try {
              const verifyStore = await read(backend, messageCoId, messageSchemaCoId);
              await waitForStoreReady(verifyStore, messageCoId, 1e3);
              const verifyData = verifyStore.value;
              if (verifyData && verifyData.processed !== true) {
                console.warn(`[processInbox] Update verification failed for ${messageCoId} - processed flag is still false`);
              }
            } catch (verifyError) {
              console.warn(`[processInbox] Update verification failed for ${messageCoId}:`, verifyError.message);
            }
          } catch (updateError) {
            console.error(`[processInbox] Failed to mark message ${messageCoId} as processed:`, updateError);
          }
          const extractedMessageData = {};
          const keys = Object.keys(messageData);
          for (const key of keys) {
            if (key !== "processed" && !key.startsWith("_") && key !== "id" && key !== "$schema" && key !== "hasProperties" && key !== "properties") {
              extractedMessageData[key] = messageData[key];
            }
          }
          if (!extractedMessageData.type) {
            console.error(
              `[processInbox]  REJECTED message ${messageCoId} - missing required 'type' field. Keys found: [${keys.join(", ")}]. All values: ${JSON.stringify(messageData).substring(0, 300)}`
            );
            continue;
          }
          unprocessedMessages.push({
            ...extractedMessageData,
            _coId: messageCoId,
            // Keep co-id for reference
            _sessionID: sessionID,
            _madeAt: madeAt
          });
        }
      } catch (error) {
        console.error(`[processInbox] Failed to read message CoMap ${messageCoId}:`, error);
      }
    }
  }
  unprocessedMessages.sort((a, b) => (a._madeAt || 0) - (b._madeAt || 0));
  return {
    messages: unprocessedMessages
  };
}
const index$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CoCache,
  CoJSONBackend,
  checkCotype,
  createAndPushMessage,
  createCoJSONAPI,
  createCoList,
  createCoMap,
  createCoStream,
  createSchemaMeta,
  getCoListId,
  getGlobalCoCache,
  getSchemaIndexColistId,
  processInbox,
  resolve: resolve$1,
  schemaMigration
}, Symbol.toStringTag, { value: "Module" }));
class ActorEngine {
  constructor(styleEngine, viewEngine, moduleRegistry, toolEngine, stateEngine = null) {
    this.styleEngine = styleEngine;
    this.viewEngine = viewEngine;
    this.registry = moduleRegistry;
    this.toolEngine = toolEngine;
    this.stateEngine = stateEngine;
    this.actors = /* @__PURE__ */ new Map();
    this.pendingMessages = /* @__PURE__ */ new Map();
    this.dbEngine = null;
    this.os = null;
    this._containerActors = /* @__PURE__ */ new Map();
    this._vibeActors = /* @__PURE__ */ new Map();
    this.viewEngine.setActorEngine(this);
    this.pendingRerenders = /* @__PURE__ */ new Set();
    this.batchTimer = null;
  }
  async updateContextCoValue(actor, updates) {
    if (!actor.contextCoId || !this.dbEngine) {
      if (!actor.contextCoId) console.warn(`[ActorEngine] Actor ${actor.id} has no contextCoId`);
      return;
    }
    const contextSchemaCoId = actor.contextSchemaCoId || await resolve$1(this.dbEngine.backend, { fromCoValue: actor.contextCoId }, { returnType: "coId" });
    const sanitizedUpdates = {};
    for (const [key, value] of Object.entries(updates)) {
      sanitizedUpdates[key] = value === void 0 ? null : value;
    }
    await this.dbEngine.execute({
      op: "update",
      schema: contextSchemaCoId,
      id: actor.contextCoId,
      data: sanitizedUpdates
    });
  }
  async _loadActorConfigs(actorConfig) {
    if (!actorConfig.view) throw new Error(`[ActorEngine] Actor config must have 'view' property`);
    const actorId = actorConfig.id || "temp";
    const viewStore = await this.dbEngine.execute({ op: "read", schema: null, key: actorConfig.view });
    const viewData = viewStore.value;
    const viewSchemaCoId = viewData?.$schema;
    if (!viewSchemaCoId) {
      throw new Error(`[ActorEngine] Failed to extract schema co-id from view CoValue ${actorConfig.view}`);
    }
    const viewStore2 = await this.dbEngine.execute({ op: "read", schema: viewSchemaCoId, key: actorConfig.view });
    const viewDef = viewStore2.value;
    viewStore2.subscribe((updatedView) => {
      const actor = this.actors.get(actorId);
      if (actor) {
        actor.viewDef = updatedView;
        if (actor._initialRenderComplete) this._scheduleRerender(actor.id);
      }
    }, { skipInitial: true });
    const loadPromises = [];
    let contextPromise = null;
    if (actorConfig.context) {
      contextPromise = (async () => {
        const coId = actorConfig.context;
        let actualContextCoId = coId;
        if (typeof coId === "string" && !coId.startsWith("co_z")) {
          const resolved = await this.dbEngine.execute({ op: "resolve", humanReadableKey: coId });
          if (resolved && resolved.startsWith("co_z")) {
            actualContextCoId = resolved;
          } else {
            throw new Error(`[ActorEngine] Failed to resolve context reference "${coId}"`);
          }
        }
        const contextSchemaCoId2 = await resolve$1(this.dbEngine.backend, { fromCoValue: actualContextCoId }, { returnType: "coId" });
        const contextStore = await this.dbEngine.execute({
          op: "read",
          schema: contextSchemaCoId2,
          key: actualContextCoId
        });
        return { context: contextStore, contextCoId: actualContextCoId, contextSchemaCoId: contextSchemaCoId2, store: contextStore };
      })();
      loadPromises.push(contextPromise);
    }
    let stylePromise = null;
    let brandPromise = null;
    if (actorConfig.style) {
      stylePromise = (async () => {
        try {
          const styleSchemaCoId = await resolve$1(this.dbEngine.backend, { fromCoValue: actorConfig.style }, { returnType: "coId" });
          const styleStore = await this.dbEngine.execute({ op: "read", schema: styleSchemaCoId, key: actorConfig.style });
          styleStore.subscribe(async (updatedStyle) => {
            const actor = this.actors.get(actorId);
            if (actor && this.styleEngine) {
              try {
                const styleSheets = await this.styleEngine.getStyleSheets(actor.config);
                actor.shadowRoot.adoptedStyleSheets = styleSheets;
                if (actor._initialRenderComplete) {
                  this._scheduleRerender(actor.id);
                }
              } catch (error) {
                console.error(`[ActorEngine] Failed to update stylesheets after style change:`, error);
              }
            }
          }, { skipInitial: true });
          return styleStore;
        } catch (error) {
          console.error(`[ActorEngine] Failed to load style:`, error);
          return null;
        }
      })();
      loadPromises.push(stylePromise);
    }
    if (actorConfig.brand) {
      brandPromise = (async () => {
        try {
          const brandSchemaCoId = await resolve$1(this.dbEngine.backend, { fromCoValue: actorConfig.brand }, { returnType: "coId" });
          const brandStore = await this.dbEngine.execute({ op: "read", schema: brandSchemaCoId, key: actorConfig.brand });
          brandStore.subscribe(async (updatedBrand) => {
            const actor = this.actors.get(actorId);
            if (actor && this.styleEngine) {
              try {
                const styleSheets = await this.styleEngine.getStyleSheets(actor.config);
                actor.shadowRoot.adoptedStyleSheets = styleSheets;
                if (actor._initialRenderComplete) {
                  this._scheduleRerender(actor.id);
                }
              } catch (error) {
                console.error(`[ActorEngine] Failed to update stylesheets after brand change:`, error);
              }
            }
          }, { skipInitial: true });
          return brandStore;
        } catch (error) {
          console.error(`[ActorEngine] Failed to load brand:`, error);
          return null;
        }
      })();
      loadPromises.push(brandPromise);
    }
    let inboxPromise = null;
    if (actorConfig.inbox) {
      inboxPromise = (async () => {
        const inboxSchemaCoId = await resolve$1(this.dbEngine.backend, { fromCoValue: actorConfig.inbox }, { returnType: "coId" });
        return await this.dbEngine.execute({ op: "read", schema: inboxSchemaCoId, key: actorConfig.inbox });
      })();
      loadPromises.push(inboxPromise);
    }
    await Promise.all(loadPromises);
    let context = null, contextCoId = null, contextSchemaCoId = null;
    if (contextPromise) {
      const result = await contextPromise;
      context = result.store;
      contextCoId = result.contextCoId;
      contextSchemaCoId = result.contextSchemaCoId;
    }
    let inbox = null, inboxCoId = null;
    if (inboxPromise) {
      inboxCoId = actorConfig.inbox;
      inbox = await inboxPromise;
    }
    return { viewDef, context, contextCoId, contextSchemaCoId, inbox, inboxCoId };
  }
  /**
   * Set up reactive subscriptions for inbox costream
   * @param {Object} actor - Actor instance
   * @param {Object} actorConfig - The actor configuration
   * @returns {Promise<void>}
   * @private
   */
  async _setupMessageSubscriptions(actor, actorConfig) {
    if (actorConfig.inbox) {
      try {
        const inboxSchemaCoId = await resolve$1(this.dbEngine.backend, { fromCoValue: actorConfig.inbox }, { returnType: "coId" });
        const store = await this.dbEngine.execute({
          op: "read",
          schema: inboxSchemaCoId,
          key: actorConfig.inbox
        });
        store.subscribe((updatedCostream) => {
          console.log(`[ActorEngine] Inbox subscription fired for actor ${actor.id}:`, {
            hasActor: this.actors.has(actor.id),
            hasItems: !!updatedCostream?.items,
            itemsCount: updatedCostream?.items?.length || 0
          });
          if (this.actors.has(actor.id) && updatedCostream?.items) {
            this.processMessages(actor.id);
          }
        });
      } catch (error) {
        console.error(`[ActorEngine] Failed to subscribe to inbox:`, error);
      }
    }
  }
  /**
   * Initialize actor state (state machine)
   * @param {Object} actor - Actor instance
   * @param {Object} actorConfig - The actor configuration
   * @returns {Promise<void>}
   * @private
   */
  async _initializeActorState(actor, actorConfig) {
    if (this.stateEngine && actorConfig.state && !actor.machine) {
      try {
        const stateSchemaStore = await this.dbEngine.execute({
          op: "schema",
          fromCoValue: actorConfig.state
        });
        const stateSchemaCoId = stateSchemaStore.value?.$id;
        if (!stateSchemaCoId) {
          throw new Error(`[ActorEngine] Failed to extract schema co-id from state CoValue ${actorConfig.state}`);
        }
        const stateStore = await this.dbEngine.execute({
          op: "read",
          schema: stateSchemaCoId,
          key: actorConfig.state
        });
        const stateDef = stateStore.value;
        const actorId = actor.id;
        stateStore.subscribe(async (updatedStateDef) => {
          const currentActor = this.actors.get(actorId);
          if (currentActor && this.stateEngine) {
            try {
              if (currentActor.machine) this.stateEngine.destroyMachine(currentActor.machine.id);
              currentActor.machine = await this.stateEngine.createMachine(updatedStateDef, currentActor);
              if (currentActor._initialRenderComplete) this._scheduleRerender(actorId);
            } catch (error) {
              console.error(`[ActorEngine] Failed to update state machine:`, error);
            }
          }
        }, { skipInitial: true });
        actor.machine = await this.stateEngine.createMachine(stateDef, actor);
      } catch (error) {
        console.error(`[ActorEngine] Failed to load state machine:`, error);
      }
    }
  }
  // Query resolution handled by backend unified store automatically
  /**
   * Determine if an actor is a service actor (orchestrator) vs UI actor (presentation)
   * Service actors: Have role "agent" OR have minimal view (only renders child actors via $slot)
   * UI actors: Have full view (render actual UI components)
   * @param {Object} actorConfig - Actor configuration
   * @param {Object} viewDef - View definition (optional, will be loaded if not provided)
   * @returns {Promise<boolean>} True if service actor, false if UI actor
   * @private
   */
  async _isServiceActor(actorConfig, viewDef = null) {
    if (actorConfig.role === "agent" || !actorConfig.view) return true;
    if (!viewDef) {
      try {
        const viewStore = await this.dbEngine.execute({ op: "read", schema: null, key: actorConfig.view });
        const viewData = viewStore.value;
        const viewSchemaCoId = viewData?.$schema;
        if (!viewSchemaCoId) {
          throw new Error(`[ActorEngine] Failed to extract schema co-id from view CoValue ${actorConfig.view}`);
        }
        const viewStore2 = await this.dbEngine.execute({ op: "read", schema: viewSchemaCoId, key: actorConfig.view });
        viewDef = viewStore2.value;
      } catch {
        return false;
      }
    }
    const rootNode = viewDef.content || viewDef.root || viewDef;
    if (!rootNode) return true;
    if (rootNode.$slot && !rootNode.children) return true;
    if (rootNode.children?.every((child) => child.$slot || child.children?.every((c) => c.$slot))) return true;
    return !(rootNode.tag && (rootNode.text || rootNode.value || rootNode.$on || rootNode.children?.some((child) => child.tag && (child.text || child.value || child.$on))));
  }
  /**
   * Create a child actor lazily if it doesn't exist yet
   * Only creates the child actor when it's actually needed (referenced by context.currentView)
   * @param {Object} actor - Parent actor instance
   * @param {string} namekey - Child actor namekey (e.g., "list", "kanban")
   * @param {string} [vibeKey] - Optional vibe key for tracking child actors
   * @returns {Promise<Object|null>} The child actor instance, or null if not found/created
   * @private
   */
  async _createChildActorIfNeeded(actor, namekey, vibeKey = null) {
    if (actor.children?.[namekey]) return actor.children[namekey];
    if (!actor.children) actor.children = {};
    const contextValue = actor.context.value;
    if (!contextValue["@actors"]?.[namekey]) return null;
    const childActorCoId = contextValue["@actors"][namekey];
    if (!childActorCoId.startsWith("co_z")) {
      throw new Error(`[ActorEngine] Child actor ID must be co-id: ${childActorCoId}`);
    }
    try {
      const actorSchemaCoId = await resolve$1(this.dbEngine.backend, { fromCoValue: childActorCoId }, { returnType: "coId" });
      const store = await this.dbEngine.execute({ op: "read", schema: actorSchemaCoId, key: childActorCoId });
      const childActorConfig = store.value;
      if (childActorConfig.$id !== childActorCoId) childActorConfig.$id = childActorCoId;
      const childContainer = document.createElement("div");
      childContainer.dataset.namekey = namekey;
      childContainer.dataset.childActorId = childActorCoId;
      const childActor = await this.createActor(childActorConfig, childContainer, vibeKey);
      childActor.namekey = namekey;
      actor.children[namekey] = childActor;
      return childActor;
    } catch (error) {
      console.error(`[ActorEngine] Failed to create child actor:`, error);
      return null;
    }
  }
  async createActor(actorConfig, containerElement, vibeKey = null) {
    const actorId = actorConfig.$id || actorConfig.id;
    if (this.actors.has(actorId)) {
      return vibeKey ? await this.reuseActor(actorId, containerElement, vibeKey) : this.actors.get(actorId);
    }
    const shadowRoot = containerElement.attachShadow({ mode: "open" });
    const styleSheets = await this.styleEngine.getStyleSheets(actorConfig);
    const { viewDef, context, contextCoId, contextSchemaCoId, inbox, inboxCoId, tempSubscriptions } = await this._loadActorConfigs(actorConfig);
    const actorType = await this._isServiceActor(actorConfig, viewDef) ? "service" : "ui";
    const actor = {
      id: actorId,
      config: actorConfig,
      shadowRoot,
      context,
      contextCoId,
      contextSchemaCoId,
      containerElement,
      actorEngine: this,
      viewDef,
      actorType,
      vibeKey,
      inbox,
      inboxCoId,
      _initialRenderComplete: false,
      children: {}
    };
    await this._setupMessageSubscriptions(actor, actorConfig);
    this.actors.set(actorId, actor);
    if (actor.context && typeof actor.context.subscribe === "function") {
      let lastContextValue = JSON.stringify(actor.context.value || {});
      actor._contextUnsubscribe = actor.context.subscribe(() => {
        const currentContextValue = JSON.stringify(actor.context.value || {});
        const contextChanged = currentContextValue !== lastContextValue;
        lastContextValue = currentContextValue;
        if (actor._initialRenderComplete && !actor._isRerendering && contextChanged) {
          this._scheduleRerender(actorId);
        }
      }, { skipInitial: true });
    }
    if (containerElement) {
      if (!this._containerActors.has(containerElement)) {
        this._containerActors.set(containerElement, /* @__PURE__ */ new Set());
      }
      this._containerActors.get(containerElement).add(actorId);
    }
    if (vibeKey) this.registerActorForVibe(actorId, vibeKey);
    await this._initializeActorState(actor, actorConfig);
    await this.viewEngine.render(viewDef, actor.context, shadowRoot, styleSheets, actorId);
    actor._initialRenderComplete = true;
    if (actor._needsPostInitRerender) {
      delete actor._needsPostInitRerender;
      this._scheduleRerender(actorId);
    }
    if (this.pendingMessages.has(actorId)) {
      for (const message of this.pendingMessages.get(actorId)) {
        await this.sendMessage(actorId, message);
      }
      this.pendingMessages.delete(actorId);
    }
    return actor;
  }
  /**
   * Schedule a rerender for an actor (batched via microtask queue)
   * Following Svelte's batching pattern: multiple updates in same tick = one rerender
   * @param {string} actorId - The actor ID to rerender
   */
  _scheduleRerender(actorId) {
    this.pendingRerenders.add(actorId);
    if (!this.batchTimer) {
      this.batchTimer = queueMicrotask(async () => {
        await this._flushRerenders();
      });
    }
  }
  /**
   * Flush all pending rerenders in batch
   * Processes all actors that need rerendering in one microtask
   */
  async _flushRerenders() {
    const actorIds = Array.from(this.pendingRerenders);
    this.pendingRerenders.clear();
    this.batchTimer = null;
    await Promise.all(actorIds.map((actorId) => this.rerender(actorId)));
  }
  /**
   * Rerender an actor (private implementation - only called by _flushRerenders)
   * @param {string} actorId - The actor ID to rerender
   * @private
   */
  async rerender(actorId) {
    const actor = this.actors.get(actorId);
    if (!actor) {
      console.warn(`[ActorEngine] rerender called for non-existent actor: ${actorId}`);
      return;
    }
    actor._isRerendering = true;
    const viewStore = await this.dbEngine.execute({ op: "read", schema: null, key: actor.config.view });
    const viewData = viewStore.value;
    const viewSchemaCoId = viewData?.$schema;
    if (!viewSchemaCoId) {
      throw new Error(`[ActorEngine] Failed to extract schema co-id from view CoValue ${actor.config.view}`);
    }
    const viewStore2 = await this.dbEngine.execute({ op: "read", schema: viewSchemaCoId, key: actor.config.view });
    const viewDef = viewStore2.value;
    const styleSheets = await this.styleEngine.getStyleSheets(actor.config);
    await this.viewEngine.render(viewDef, actor.context, actor.shadowRoot, styleSheets, actorId);
    actor._isRerendering = false;
  }
  /**
   * Get actor by ID
   * @param {string} actorId - The actor ID
   * @returns {Object|undefined} The actor instance
   */
  getActor(actorId) {
    return this.actors.get(actorId);
  }
  /**
   * Register an actor with a vibe key for reuse tracking
   * @param {string} actorId - The actor ID
   * @param {string} vibeKey - The vibe key (e.g., 'todos')
   */
  registerActorForVibe(actorId, vibeKey) {
    if (!vibeKey) return;
    if (!this._vibeActors.has(vibeKey)) {
      this._vibeActors.set(vibeKey, /* @__PURE__ */ new Set());
    }
    this._vibeActors.get(vibeKey).add(actorId);
  }
  /**
   * Get all actors for a vibe
   * @param {string} vibeKey - The vibe key (e.g., 'todos')
   * @returns {Set<string>|undefined} Set of actor IDs for the vibe
   */
  getActorsForVibe(vibeKey) {
    return this._vibeActors.get(vibeKey);
  }
  /**
   * Reuse an existing actor by reattaching it to a new container
   * @param {string} actorId - The actor ID
   * @param {HTMLElement} containerElement - The new container to attach to
   * @param {string} vibeKey - The vibe key (e.g., 'todos')
   * @returns {Promise<Object>} The reused actor instance
   */
  async reuseActor(actorId, containerElement, vibeKey) {
    const actor = this.actors.get(actorId);
    if (!actor) throw new Error(`[ActorEngine] Cannot reuse actor ${actorId}`);
    const oldContainer = actor.containerElement;
    actor.containerElement = containerElement;
    if (oldContainer && this._containerActors.has(oldContainer)) {
      const oldContainerActors = this._containerActors.get(oldContainer);
      oldContainerActors.delete(actorId);
      if (oldContainerActors.size === 0) this._containerActors.delete(oldContainer);
    }
    if (containerElement) {
      if (!this._containerActors.has(containerElement)) this._containerActors.set(containerElement, /* @__PURE__ */ new Set());
      this._containerActors.get(containerElement).add(actorId);
    }
    this.registerActorForVibe(actorId, vibeKey);
    if (actor.shadowRoot) {
      const oldHost = actor.shadowRoot.host;
      if (oldHost && oldHost !== containerElement) {
        if (oldHost.parentNode) oldHost.parentNode.removeChild(oldHost);
        containerElement.appendChild(oldHost);
      }
    } else {
      actor.shadowRoot = containerElement.attachShadow({ mode: "open" });
    }
    if (actor._initialRenderComplete) this._scheduleRerender(actorId);
    return actor;
  }
  /**
   * Destroy an actor
   * @param {string} actorId - The actor ID
   */
  destroyActor(actorId) {
    const actor = this.actors.get(actorId);
    if (!actor) return;
    actor.shadowRoot.innerHTML = "";
    if (this.viewEngine) this.viewEngine.cleanupActor(actorId);
    if (actor._contextUnsubscribe && typeof actor._contextUnsubscribe === "function") {
      actor._contextUnsubscribe();
      delete actor._contextUnsubscribe;
    }
    if (actor.machine && this.stateEngine) this.stateEngine.destroyMachine(actor.machine.id);
    if (actor._processedMessageKeys) {
      actor._processedMessageKeys.clear();
      delete actor._processedMessageKeys;
    }
    if (actor.containerElement && this._containerActors.has(actor.containerElement)) {
      const containerActors = this._containerActors.get(actor.containerElement);
      containerActors.delete(actorId);
      if (containerActors.size === 0) this._containerActors.delete(actor.containerElement);
    }
    for (const [vibeKey, vibeActorIds] of this._vibeActors.entries()) {
      if (vibeActorIds.has(actorId)) {
        vibeActorIds.delete(actorId);
        if (vibeActorIds.size === 0) this._vibeActors.delete(vibeKey);
        break;
      }
    }
    this.actors.delete(actorId);
  }
  /**
   * Destroy all actors for a given container
   * Used when unloading a vibe to clean up all actors associated with that container
   * @param {HTMLElement} containerElement - The container element
   */
  destroyActorsForContainer(containerElement) {
    const actorIds = this._containerActors.get(containerElement);
    if (!actorIds?.size) return;
    for (const actorId of Array.from(actorIds)) {
      this.destroyActor(actorId);
    }
    this._containerActors.delete(containerElement);
  }
  /**
   * Detach all actors for a vibe (hide UI, keep actors alive)
   * Used when navigating away from a vibe - preserves actors for reuse
   * @param {string} vibeKey - The vibe key (e.g., 'todos')
   */
  detachActorsForVibe(vibeKey) {
    const actorIds = this._vibeActors.get(vibeKey);
    if (!actorIds?.size) return;
    for (const actorId of actorIds) {
      const actor = this.actors.get(actorId);
      if (actor?.shadowRoot?.host?.parentNode) {
        actor.shadowRoot.host.parentNode.removeChild(actor.shadowRoot.host);
      }
      if (actor?.containerElement && this._containerActors.has(actor.containerElement)) {
        const containerActors = this._containerActors.get(actor.containerElement);
        containerActors.delete(actorId);
        if (containerActors.size === 0) this._containerActors.delete(actor.containerElement);
      }
    }
  }
  /**
   * Reattach all actors for a vibe to a new container
   * Used when navigating back to a vibe - reuses existing actors
   * @param {string} vibeKey - The vibe key (e.g., 'todos')
   * @param {HTMLElement} containerElement - The container element for the root actor
   * @returns {Promise<Object|undefined>} The root actor instance, or undefined if no actors found
   */
  async reattachActorsForVibe(vibeKey, containerElement) {
    const actorIds = this._vibeActors.get(vibeKey);
    if (!vibeKey || !containerElement || !actorIds?.size) return void 0;
    const rootActorId = Array.from(actorIds)[0];
    const rootActor = this.actors.get(rootActorId);
    if (!rootActor) return void 0;
    await this.reuseActor(rootActorId, containerElement, vibeKey);
    return rootActor;
  }
  /**
   * Destroy all actors for a vibe (complete cleanup)
   * Used for explicit cleanup when needed (e.g., app shutdown)
   * @param {string} vibeKey - The vibe key (e.g., 'todos')
   */
  destroyActorsForVibe(vibeKey) {
    const actorIds = this._vibeActors.get(vibeKey);
    if (!vibeKey || !actorIds?.size) return;
    for (const actorId of Array.from(actorIds)) {
      this.destroyActor(actorId);
    }
    this._vibeActors.delete(vibeKey);
  }
  // ============================================
  // MESSAGE PASSING SYSTEM (v0.2)
  // ============================================
  /**
   * Send a message to an actor's inbox
   * CRDT handles persistence and sync automatically - no MessageQueue needed
   * @param {string} actorId - Target actor ID
   * @param {Object} message - Message object { type, payload, from, timestamp }
   */
  async sendMessage(actorId, message) {
    const actor = this.actors.get(actorId);
    if (!actor) {
      if (!this.pendingMessages.has(actorId)) this.pendingMessages.set(actorId, []);
      const pending = this.pendingMessages.get(actorId);
      const key = message.id || `${message.type}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      if (!pending.some((m) => m.id === key || !m.id && !message.id && m.type === message.type)) {
        pending.push(message);
      }
      return;
    }
    if (actor.inboxCoId && this.dbEngine) {
      try {
        const messageData = {
          type: message.type,
          payload: message.payload || {},
          source: message.from || message.source,
          target: actorId,
          processed: false
        };
        await createAndPushMessage(this.dbEngine, actor.inboxCoId, messageData);
      } catch (error) {
        console.error(`[ActorEngine] Failed to send message:`, error);
      }
    }
  }
  async sendInternalEvent(actorId, eventType, payload = {}) {
    console.log(`[ActorEngine] sendInternalEvent called:`, {
      actorId,
      eventType,
      payloadKeys: Object.keys(payload || {}),
      hasResult: !!payload?.result
    });
    const actor = this.actors.get(actorId);
    if (!actor || !actor.inboxCoId || !this.dbEngine) {
      console.warn(`[ActorEngine] Cannot send internal event:`, {
        hasActor: !!actor,
        hasInboxCoId: !!actor?.inboxCoId,
        hasDbEngine: !!this.dbEngine
      });
      return;
    }
    try {
      console.log(`[ActorEngine] Creating message in inbox:`, {
        inboxCoId: actor.inboxCoId,
        eventType,
        payloadKeys: Object.keys(payload || {})
      });
      await createAndPushMessage(this.dbEngine, actor.inboxCoId, {
        type: eventType,
        payload,
        source: actorId,
        target: actorId,
        processed: false
      });
      console.log(`[ActorEngine] Message created successfully in inbox`);
      console.log(`[ActorEngine] Scheduling deferred message processing for ${eventType} event`);
      setTimeout(() => {
        console.log(`[ActorEngine] Processing deferred messages for actor ${actorId}`);
        this.processMessages(actorId).catch((err) => {
          console.error(`[ActorEngine] Error processing deferred messages:`, err);
        });
      }, 0);
    } catch (error) {
      console.error(`[ActorEngine] Failed to send internal event:`, error);
    }
  }
  async processMessages(actorId) {
    const actor = this.actors.get(actorId);
    if (!actor || !actor.inboxCoId || !this.dbEngine || actor._isProcessing) return;
    actor._isProcessing = true;
    try {
      const result = await this.dbEngine.execute({ op: "processInbox", actorId, inboxCoId: actor.inboxCoId });
      const messages = result.messages || [];
      console.log(`[ActorEngine] processMessages: Found ${messages.length} messages for actor ${actorId}`);
      for (const message of messages) {
        if (message.type === "INIT" || message.from === "system") continue;
        console.log(`[ActorEngine] Processing message:`, {
          type: message.type,
          hasPayload: !!message.payload,
          payloadKeys: message.payload ? Object.keys(message.payload) : []
        });
        try {
          const payload = message.payload || {};
          if (actor.machine && this.stateEngine) {
            await this.stateEngine.send(actor.machine.id, message.type, payload);
          } else {
            console.error(`[ActorEngine] Actor ${actorId} has no state machine. All actors must have state machines. Message type: ${message.type}`);
          }
        } catch (error) {
          console.error(`[ActorEngine] Failed to process message:`, error);
        }
      }
    } catch (error) {
      console.error(`[ActorEngine] Error processing messages:`, error);
    } finally {
      actor._isProcessing = false;
    }
  }
}
function extractDOMValues(payload, element) {
  if (!payload || typeof payload !== "object") {
    return payload;
  }
  if (Array.isArray(payload)) {
    return payload.map((item) => extractDOMValues(item, element));
  }
  const result = {};
  for (const [key, value] of Object.entries(payload)) {
    if (value === "@inputValue") {
      result[key] = element.value || "";
    } else if (value === "@dataColumn") {
      result[key] = element.dataset.column || element.getAttribute("data-column") || null;
    } else if (typeof value === "object" && value !== null) {
      result[key] = extractDOMValues(value, element);
    } else {
      result[key] = value;
    }
  }
  return result;
}
function sanitizeAttribute(value) {
  if (value === null || value === void 0) return "";
  return String(value).replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;").replace(/\//g, "&#x2F;");
}
function containsDangerousHTML(str) {
  if (typeof str !== "string") return false;
  return [/<script/i, /javascript:/i, /on\w+\s*=/i, /<iframe/i, /<object/i, /<embed/i, /<link/i, /<meta/i, /<style/i].some((pattern2) => pattern2.test(str));
}
class ViewEngine {
  constructor(evaluator2, actorEngine, moduleRegistry) {
    this.evaluator = evaluator2;
    this.actorEngine = actorEngine;
    this.moduleRegistry = moduleRegistry;
    this.dbEngine = null;
    this.actorInputCounters = /* @__PURE__ */ new Map();
  }
  async loadView(coId) {
    const viewStore = await this.dbEngine.execute({
      op: "read",
      schema: null,
      key: coId
    });
    const viewData = viewStore.value;
    const viewSchemaCoId = viewData?.$schema || null;
    if (!viewSchemaCoId) {
      throw new Error(`[ViewEngine] Failed to extract schema co-id from view CoValue ${coId}. View must have $schema in headerMeta. View data: ${JSON.stringify({ id: viewData?.id, loading: viewData?.loading, hasProperties: viewData?.hasProperties, properties: viewData?.properties?.length })}`);
    }
    const store = await this.dbEngine.execute({
      op: "read",
      schema: viewSchemaCoId,
      key: coId
    });
    return store;
  }
  async render(viewDef, context, shadowRoot, styleSheets, actorId) {
    this.actorInputCounters.set(actorId, 0);
    shadowRoot.innerHTML = "";
    shadowRoot.adoptedStyleSheets = styleSheets;
    this.currentActorId = actorId;
    const viewNode = viewDef.content || viewDef;
    if (!context) {
      console.error(`[ViewEngine] Context is null/undefined for actor ${actorId}`);
      return;
    }
    const contextForRender = context.value || {};
    const element = await this.renderNode(viewNode, { context: contextForRender }, actorId);
    if (element) {
      element.style.containerType = "inline-size";
      element.style.containerName = "actor-root";
      element.dataset.actorId = actorId;
      shadowRoot.appendChild(element);
    } else {
      console.error(`[ViewEngine.render] renderNode returned null for actor ${actorId}`, {
        viewNode: viewNode ? { tag: viewNode.tag, hasContent: !!viewNode.content } : null,
        contextKeys: Object.keys(contextForRender)
      });
    }
  }
  async renderNode(node, data2, actorId) {
    if (!node) return null;
    const tag = node.tag || "div";
    const element = document.createElement(tag);
    await this._applyNodeAttributes(element, node, data2, actorId);
    if (node.$each) {
      element.innerHTML = "";
      const fragment = await this.renderEach(node.$each, data2, actorId);
      element.appendChild(fragment);
    }
    if (node.$on) {
      this.attachEvents(element, node.$on, data2, actorId);
    }
    if (node.$slot) {
      await this._renderSlot(node, data2, element, actorId);
      return element;
    }
    if (node.slot) {
      throw new Error('[ViewEngine] Old "slot" syntax is no longer supported. Use "$slot" instead.');
    }
    if (!node.$each) {
      await this._renderNodeChildren(element, node, data2, actorId);
    }
    return element;
  }
  async _applyNodeAttributes(element, node, data2, actorId) {
    if (node.class) {
      if (typeof node.class === "object" && node.class.$if) {
        throw new Error('[ViewEngine] "$if" is no longer supported in class property. Use data-attributes and CSS instead.');
      }
      const classValue = await this.evaluator.evaluate(node.class, data2);
      if (classValue) {
        element.className = classValue;
      }
    }
    if (node.attrs) {
      for (const [attrName, attrValue] of Object.entries(node.attrs)) {
        if (attrName === "data") {
          await this._resolveDataAttributes(attrValue, data2, element);
        } else {
          const resolvedValue = await this.evaluator.evaluate(attrValue, data2);
          if (resolvedValue !== void 0 && resolvedValue !== null) {
            const booleanAttributes = ["disabled", "readonly", "checked", "selected", "autofocus", "required", "multiple"];
            if (booleanAttributes.includes(attrName.toLowerCase())) {
              const boolValue = Boolean(resolvedValue);
              element[attrName] = boolValue;
              if (boolValue) {
                element.setAttribute(attrName, "");
              } else {
                element.removeAttribute(attrName);
              }
            } else {
              let stringValue = typeof resolvedValue === "boolean" ? String(resolvedValue) : String(resolvedValue);
              if (containsDangerousHTML(stringValue)) {
                console.warn(`[ViewEngine] Potentially dangerous HTML detected in attribute ${attrName}, sanitizing`);
                stringValue = sanitizeAttribute(stringValue);
              }
              element.setAttribute(attrName, stringValue);
            }
          }
        }
      }
    }
    if (node.value !== void 0) {
      const resolvedValue = await this.evaluator.evaluate(node.value, data2);
      if (element.tagName === "INPUT" || element.tagName === "TEXTAREA") {
        const newValue = resolvedValue || "";
        const isFocused = document.activeElement === element;
        if (!isFocused) {
          if (element.tagName === "INPUT") element.value = newValue;
          else element.textContent = newValue;
        }
        if (!this.actorInputCounters.has(actorId)) this.actorInputCounters.set(actorId, 0);
        const inputIndex = this.actorInputCounters.get(actorId);
        this.actorInputCounters.set(actorId, inputIndex + 1);
        element.setAttribute("data-actor-input", `${actorId}_input_${inputIndex}`);
      }
    }
    if (node.text !== void 0) {
      const textValue = await this.evaluator.evaluate(node.text, data2);
      if (textValue && typeof textValue === "object") {
        if (textValue.role && textValue.id && textValue.id.startsWith("co_z")) {
          const truncatedId = textValue.id.substring(0, 15) + "...";
          element.textContent = `${textValue.role} (${truncatedId})`;
        } else {
          try {
            element.textContent = JSON.stringify(textValue, null, 2);
          } catch (e) {
            element.textContent = String(textValue);
          }
        }
      } else {
        let displayText = String(textValue || "");
        if (displayText.startsWith("co_z") && displayText.length > 15) {
          displayText = displayText.substring(0, 15) + "...";
        }
        element.textContent = displayText;
      }
    }
  }
  async _renderNodeChildren(element, node, data2, actorId) {
    if (node.children && Array.isArray(node.children)) {
      for (const child of node.children) {
        if (child && typeof child === "object" && child.$if) {
          throw new Error('[ViewEngine] "$if" is no longer supported in view templates. Use data-attributes and CSS instead.');
        }
        const childElement = await this.renderNode(child, data2, actorId);
        if (childElement) {
          element.appendChild(childElement);
        }
      }
    }
  }
  async _resolveDataAttributes(dataSpec, data2, element) {
    if (typeof dataSpec === "string") {
      if (dataSpec.includes(".$$")) {
        const [contextKey, itemKey] = dataSpec.split(".");
        const contextObj = await this.evaluator.evaluate(contextKey, data2);
        const itemId = await this.evaluator.evaluate(itemKey, data2);
        if (contextObj && typeof contextObj === "object" && itemId) {
          const value = contextObj[itemId];
          if (value !== null && value !== void 0) {
            const key = contextKey.substring(1);
            const attrName = `data-${this._toKebabCase(key)}`;
            element.setAttribute(attrName, String(value));
          }
        }
      } else {
        const value = await this.evaluator.evaluate(dataSpec, data2);
        if (value !== null && value !== void 0) {
          const key = dataSpec.startsWith("$$") ? dataSpec.substring(2) : dataSpec.substring(1);
          const attrName = `data-${this._toKebabCase(key)}`;
          element.setAttribute(attrName, String(value));
        }
      }
    } else if (typeof dataSpec === "object" && dataSpec !== null) {
      for (const [key, valueSpec] of Object.entries(dataSpec)) {
        let value;
        if (typeof valueSpec === "object" && valueSpec !== null && valueSpec.$eq) {
          const comparisonResult = await this.evaluator.evaluate(valueSpec, data2);
          value = comparisonResult ? "true" : null;
        } else if (typeof valueSpec === "string" && valueSpec.includes(".$$")) {
          const [contextKey, itemKey] = valueSpec.split(".");
          const contextObj = await this.evaluator.evaluate(contextKey, data2);
          const itemId = await this.evaluator.evaluate(itemKey, data2);
          if (contextObj && typeof contextObj === "object" && itemId) {
            value = contextObj[itemId];
          }
        } else {
          value = await this.evaluator.evaluate(valueSpec, data2);
        }
        if (value !== null && value !== void 0) {
          const attrName = `data-${this._toKebabCase(key)}`;
          element.setAttribute(attrName, String(value));
        }
      }
    }
  }
  _toKebabCase(str) {
    return str.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
  }
  async _renderSlot(node, data2, wrapperElement, actorId) {
    const slotKey = node.$slot;
    if (!slotKey || !slotKey.startsWith("$")) {
      console.warn(`[ViewEngine] Slot key must start with $: ${slotKey}`);
      return;
    }
    const contextKey = slotKey.slice(1);
    const contextValue = data2.context || {};
    const slotValue = contextValue[contextKey];
    if (!slotValue) {
      console.warn(`[ViewEngine] No context value for slot key: ${contextKey}`, {
        actorId,
        availableKeys: Object.keys(contextValue || {}),
        contextType: "ReactiveStore"
      });
      return;
    }
    let namekey;
    if (typeof slotValue === "string" && slotValue.startsWith("@")) {
      namekey = slotValue.slice(1);
      const actorsMap = contextValue["@actors"];
      if (actorsMap && !actorsMap[namekey]) {
        console.warn(`[ViewEngine] Namekey "${namekey}" not found in context["@actors"]`, {
          actorId,
          contextKey,
          contextValue,
          availableActors: actorsMap ? Object.keys(actorsMap) : []
        });
      }
    } else {
      wrapperElement.textContent = String(contextValue);
      return;
    }
    const actor = this.actorEngine?.getActor(actorId);
    if (!actor) {
      console.warn(`[ViewEngine] Parent actor not found: ${actorId}`);
      return;
    }
    let childActor = actor.children?.[namekey];
    if (!childActor) {
      const vibeKey = actor.vibeKey || null;
      childActor = await this.actorEngine._createChildActorIfNeeded(actor, namekey, vibeKey);
      if (!childActor) {
        if (actor._initialRenderComplete) {
          console.warn(`[ViewEngine] Failed to create child actor for namekey: ${namekey}`, {
            actorId,
            availableChildren: actor?.children ? Object.keys(actor.children) : [],
            contextValue,
            namekey
          });
        }
        return;
      }
    }
    if (childActor.containerElement) {
      if (actor?.children) {
        for (const [key, child] of Object.entries(actor.children)) {
          if (key === namekey) continue;
          if (child.actorType === "ui") {
            this.actorEngine.destroyActor(child.id);
            delete actor.children[key];
          }
        }
      }
      if (childActor._initialRenderComplete && this.actorEngine) {
        this.actorEngine._scheduleRerender(childActor.id);
      }
      if (childActor.containerElement.parentNode !== wrapperElement) {
        if (childActor.containerElement.parentNode) {
          childActor.containerElement.parentNode.removeChild(childActor.containerElement);
        }
        wrapperElement.innerHTML = "";
        wrapperElement.appendChild(childActor.containerElement);
      }
    } else {
      console.warn(`[ViewEngine] Child actor ${namekey} has no containerElement`, {
        actorId,
        namekey,
        childActorId: childActor.id
      });
    }
  }
  async renderEach(eachDef, data2, actorId) {
    const fragment = document.createDocumentFragment();
    const items2 = await this.evaluator.evaluate(eachDef.items, data2);
    if (!items2 || !Array.isArray(items2) || items2.length === 0) {
      return fragment;
    }
    for (let i = 0; i < items2.length; i++) {
      const item = items2[i];
      const itemData = {
        context: data2.context,
        item,
        index: i
      };
      const itemElement = await this.renderNode(eachDef.template, itemData, actorId);
      if (itemElement) {
        fragment.appendChild(itemElement);
      }
    }
    return fragment;
  }
  attachEvents(element, events, data2, actorId) {
    for (const [eventName, eventDef] of Object.entries(events)) {
      element.addEventListener(eventName, async (e) => {
        try {
          await this._handleEvent(e, eventDef, data2, element, actorId);
        } catch (error) {
          console.error(`[ViewEngine] Error handling event ${eventName}:`, error);
        }
      });
    }
  }
  async _handleEvent(e, eventDef, data2, element, actorId) {
    const eventName = eventDef.send;
    let payload = eventDef.payload || {};
    if (e.type === "dragover" || e.type === "drop" || e.type === "dragenter") {
      e.preventDefault();
      if (e.type === "dragover") {
        e.dataTransfer.dropEffect = "move";
      }
    }
    if (eventName === "STOP_PROPAGATION") {
      e.stopPropagation();
      return;
    }
    if (eventDef.key && e.key !== eventDef.key) {
      return;
    }
    if (eventName === "UPDATE_INPUT" && e.type === "input") {
      return;
    }
    if (this.actorEngine) {
      const actor = this.actorEngine.getActor(actorId);
      if (actor && actor.machine) {
        payload = extractDOMValues(payload, element);
        const currentContext = actor.context.value;
        const expressionData = {
          context: currentContext,
          item: data2.item || {}
        };
        payload = await resolveExpressions(payload, this.evaluator, expressionData);
        if (eventName === "UPDATE_INPUT" && e.type === "blur" && payload && typeof payload === "object") {
          let allMatch = true;
          for (const [key, value] of Object.entries(payload)) {
            const contextValue = currentContext[key];
            if (value !== contextValue) {
              allMatch = false;
              break;
            }
          }
          if (allMatch) {
            return;
          }
        }
        await this.actorEngine.sendInternalEvent(actorId, eventName, payload);
        if (eventName !== "UPDATE_INPUT") {
          this._clearInputFields(element, actorId);
        }
      } else {
        console.warn(`Cannot send event ${eventName}: Actor has no state machine`);
      }
    } else {
      console.warn("No actorEngine set, cannot handle event:", eventName);
    }
  }
  /**
   * Clear all input and textarea fields in the form containing the element
   * If no form found, clears inputs in the actor's shadow root
   * @param {HTMLElement} element - The element that triggered the event
   * @param {string} actorId - The actor ID
   * @private
   */
  _clearInputFields(element, actorId) {
    let container = element.closest("form");
    if (!container && this.actorEngine) {
      const actor = this.actorEngine.getActor(actorId);
      if (actor && actor.shadowRoot) {
        container = actor.shadowRoot;
      }
    }
    if (!container) return;
    const inputs = container.querySelectorAll("input, textarea");
    inputs.forEach((input) => {
      if (input.hasAttribute("data-actor-input")) {
        if (input.tagName === "INPUT") {
          input.value = "";
        } else if (input.tagName === "TEXTAREA") {
          input.value = "";
        }
      }
    });
  }
  setActorEngine(actorEngine) {
    this.actorEngine = actorEngine;
  }
  cleanupActor(actorId) {
  }
}
function resolvePath$1(obj, path) {
  if (!obj || !path) return void 0;
  return path.split(".").reduce((acc, key) => acc?.[key], obj);
}
class StyleEngine {
  constructor() {
    this.cache = /* @__PURE__ */ new Map();
    this.dbEngine = null;
  }
  resolveStyleRef(ref2) {
    if (!ref2 || !ref2.startsWith("co_z")) {
      throw new Error(`[StyleEngine] Style reference must be a co-id (starts with 'co_z'), got: ${ref2}`);
    }
    return ref2;
  }
  deepMerge(target, source) {
    const output = { ...target };
    for (const key in source) {
      if (source[key] instanceof Object && !Array.isArray(source[key]) && key in target) {
        output[key] = this.deepMerge(target[key], source[key]);
      } else {
        output[key] = source[key];
      }
    }
    return output;
  }
  _interpolateTokens(value, tokens) {
    if (typeof value !== "string") return value;
    return value.replace(/\{([^}]+)\}/g, (match, path) => {
      const tokenValue = resolvePath$1(tokens, path);
      return tokenValue !== void 0 ? tokenValue : match;
    });
  }
  _toKebabCase(str) {
    return str.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
  }
  compileModifierStyles(styles, tokens) {
    if (typeof styles !== "object" || styles === null || Array.isArray(styles)) return "";
    return Object.entries(styles).map(([prop, value]) => {
      const cssProp = prop.replace(/([A-Z])/g, "-$1").toLowerCase();
      const cssValue = this._interpolateTokens(value, tokens);
      return `  ${cssProp}: ${cssValue};`;
    }).join("\n");
  }
  _flattenTokens(tokens, prefix = "") {
    const result = {};
    for (const [key, value] of Object.entries(tokens)) {
      const varName = prefix ? `${prefix}-${key}` : key;
      if (typeof value === "object" && value !== null && !Array.isArray(value)) {
        Object.assign(result, this._flattenTokens(value, varName));
      } else {
        result[`--${varName}`] = value;
      }
    }
    return result;
  }
  compileTokensToCSS(tokens) {
    const flatTokens = this._flattenTokens(tokens);
    const cssVars = Object.entries(flatTokens).map(([name, value]) => `  ${name}: ${value};`).join("\n");
    let fontFacesCSS = "";
    if (tokens.typography?.fontFaces && Array.isArray(tokens.typography.fontFaces)) {
      fontFacesCSS = tokens.typography.fontFaces.map((face) => {
        const props = Object.entries(face).map(([prop, value]) => {
          const cssProp = prop.replace(/([A-Z])/g, "-$1").toLowerCase();
          return `  ${cssProp}: ${value};`;
        }).join("\n");
        return `@font-face {
${props}
}`;
      }).join("\n\n") + "\n\n";
    }
    return `${fontFacesCSS}:host {
${cssVars}
}
`;
  }
  _compileDataAttributeSelectors(baseSelector, dataTree, tokens, currentPath = "") {
    const cssRules = [];
    if (!dataTree || typeof dataTree !== "object" || Array.isArray(dataTree)) return cssRules;
    for (const [dataKey, dataValue] of Object.entries(dataTree)) {
      if (typeof dataValue !== "object" || dataValue === null || Array.isArray(dataValue)) continue;
      const kebabDataKey = this._toKebabCase(dataKey);
      for (const [valueKey, styles] of Object.entries(dataValue)) {
        if (typeof styles !== "object" || styles === null || Array.isArray(styles)) continue;
        const kebabValueKey = this._toKebabCase(valueKey);
        const dataAttr = `[data-${kebabDataKey}="${kebabValueKey}"]`;
        const selector = `${baseSelector}${currentPath}${dataAttr}`;
        const cssProps = {};
        const pseudoSelectors = {};
        let nestedData = null;
        for (const [prop, propValue] of Object.entries(styles)) {
          if (prop === "data") nestedData = propValue;
          else if (prop.startsWith(":")) pseudoSelectors[prop] = propValue;
          else cssProps[prop] = propValue;
        }
        if (Object.keys(cssProps).length > 0) {
          cssRules.push(`${selector} {
${this.compileModifierStyles(cssProps, tokens)}
}`);
        }
        for (const [pseudo, pseudoStyles] of Object.entries(pseudoSelectors)) {
          cssRules.push(`${selector}${pseudo} {
${this.compileModifierStyles(pseudoStyles, tokens)}
}`);
        }
        if (nestedData && typeof nestedData === "object" && !Array.isArray(nestedData)) {
          cssRules.push(...this._compileDataAttributeSelectors(baseSelector, nestedData, tokens, `${currentPath}${dataAttr}`));
        }
      }
    }
    return cssRules;
  }
  compileComponentsToCSS(components, tokens) {
    if (!components || Object.keys(components).length === 0) return "";
    const cssRules = [];
    for (const [className, styles] of Object.entries(components)) {
      const kebabClassName = className.replace(/([A-Z])/g, "-$1").toLowerCase();
      const dataTree = styles.data;
      const stylesWithoutData = { ...styles };
      delete stylesWithoutData.data;
      const baseStyles = {};
      const modifiers = {};
      for (const [prop, value] of Object.entries(stylesWithoutData)) {
        const isModifier = prop.startsWith(":") || prop.startsWith("[") || typeof value === "object" && value !== null && !Array.isArray(value);
        if (isModifier) modifiers[prop] = value;
        else baseStyles[prop] = value;
      }
      if (Object.keys(baseStyles).length > 0) {
        const cssProperties = Object.entries(baseStyles).map(([prop, value]) => {
          const cssProp = prop.replace(/([A-Z])/g, "-$1").toLowerCase();
          return `  ${cssProp}: ${this._interpolateTokens(value, tokens)};`;
        }).join("\n");
        cssRules.push(`.${kebabClassName} {
${cssProperties}
}`);
      }
      for (const [modifier, modifierStyles] of Object.entries(modifiers)) {
        let selector;
        if (modifier.startsWith(":")) selector = `.${kebabClassName}${modifier}`;
        else if (modifier.startsWith("[")) selector = `.${kebabClassName}${modifier}`;
        else if (modifier.includes(" ")) selector = `.${kebabClassName} ${modifier}`;
        else selector = `.${kebabClassName}[${modifier}]`;
        cssRules.push(`${selector} {
${this.compileModifierStyles(modifierStyles, tokens)}
}`);
      }
      if (dataTree && typeof dataTree === "object" && !Array.isArray(dataTree)) {
        cssRules.push(...this._compileDataAttributeSelectors(`.${kebabClassName}`, dataTree, tokens));
      }
    }
    return cssRules.join("\n\n");
  }
  compileSelectors(selectors, tokens) {
    if (!selectors || Object.keys(selectors).length === 0) return "";
    const cssRules = [];
    for (const [selector, styles] of Object.entries(selectors)) {
      const cssProperties = Object.entries(styles).map(([prop, value]) => {
        const cssProp = prop.replace(/([A-Z])/g, "-$1").toLowerCase();
        return `  ${cssProp}: ${this._interpolateTokens(value, tokens)};`;
      }).join("\n");
      cssRules.push(`${selector} {
${cssProperties}
}`);
    }
    return cssRules.join("\n\n");
  }
  compileToCSS(tokens, components, selectors = {}, rawCSS = "") {
    let css = `${this.compileTokensToCSS(tokens)}
${this.compileComponentsToCSS(components, tokens)}`;
    const selectorCSS = this.compileSelectors(selectors, tokens);
    if (selectorCSS) css += `

/* State-based selectors */
${selectorCSS}`;
    if (rawCSS) css += `

/* Raw CSS fallback */
${rawCSS}`;
    return css;
  }
  async getStyleSheets(actorConfig) {
    const brandCoId = actorConfig.brand;
    const styleCoId = actorConfig.style;
    if (!brandCoId) {
      throw new Error(`[StyleEngine] Actor config must have 'brand' property with co-id. Config keys: ${Object.keys(actorConfig).join(", ")}. Config: ${JSON.stringify(actorConfig, null, 2)}`);
    }
    const cacheKey = `${brandCoId}_${styleCoId || "none"}`;
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey);
    }
    const brandResolved = this.resolveStyleRef(brandCoId);
    const brandSchemaCoId = await resolve$1(this.dbEngine.backend, { fromCoValue: brandResolved }, { returnType: "coId" });
    const brandStore = await this.dbEngine.execute({ op: "read", schema: brandSchemaCoId, key: brandResolved });
    const brand = brandStore.value;
    let actor = { tokens: {}, components: {} };
    if (styleCoId) {
      const styleResolved = this.resolveStyleRef(styleCoId);
      const styleSchemaCoId = await resolve$1(this.dbEngine.backend, { fromCoValue: styleResolved }, { returnType: "coId" });
      const styleStore = await this.dbEngine.execute({ op: "read", schema: styleSchemaCoId, key: styleResolved });
      actor = styleStore.value;
    }
    const mergedTokens = this.deepMerge(brand.tokens || {}, actor.tokens || {});
    const mergedComponents = this.deepMerge(brand.components || {}, actor.components || {});
    const mergedSelectors = this.deepMerge(brand.selectors || {}, actor.selectors || {});
    const rawCSS = [brand.rawCSS, actor.rawCSS].filter(Boolean).join("\n\n");
    const css = this.compileToCSS(mergedTokens, mergedComponents, mergedSelectors, rawCSS);
    const sheet = new CSSStyleSheet();
    sheet.replaceSync(css);
    const sheets = [sheet];
    this.cache.set(cacheKey, sheets);
    return sheets;
  }
  clearCache() {
    this.cache.clear();
  }
}
class StateEngine {
  constructor(toolEngine, evaluator2, actorEngine = null) {
    this.toolEngine = toolEngine;
    this.evaluator = evaluator2;
    this.actorEngine = actorEngine;
    this.machines = /* @__PURE__ */ new Map();
    this.dbEngine = null;
  }
  async createMachine(stateDef, actor) {
    const machineId = `${actor.id}_machine`;
    const machine = {
      id: machineId,
      definition: stateDef,
      actor,
      currentState: stateDef.initial,
      history: [],
      eventPayload: {}
    };
    this.machines.set(machineId, machine);
    machine._isInitialCreation = true;
    await this._executeEntry(machine, stateDef.initial);
    machine._isInitialCreation = false;
    return machine;
  }
  async send(machineId, event, payload = {}) {
    console.log(`[StateEngine] send() called:`, { machineId, event, payloadKeys: Object.keys(payload || {}) });
    const machine = this.machines.get(machineId);
    if (!machine) {
      console.warn(`[StateEngine] Machine not found: ${machineId}`);
      return;
    }
    const currentStateDef = machine.definition.states[machine.currentState];
    if (!currentStateDef) {
      console.warn(`[StateEngine] State definition not found for state: ${machine.currentState}`);
      return;
    }
    const transition = (currentStateDef.on || {})[event];
    if (!transition) {
      console.warn(`[StateEngine] No transition handler for event '${event}' in state '${machine.currentState}'`);
      return;
    }
    await this._executeTransition(machine, transition, event, payload);
  }
  async _executeTransition(machine, transition, event, payload) {
    machine.eventPayload = payload || {};
    if (event === "SUCCESS") machine.lastToolResult = payload.result || null;
    const targetState = typeof transition === "string" ? transition : transition.target;
    const guard = typeof transition === "object" ? transition.guard : null;
    const actions = typeof transition === "object" ? transition.actions : null;
    console.log(`[StateEngine] Transition: ${machine.currentState} --${event}--> ${targetState}`, {
      actorId: machine.actor?.id,
      hasGuard: guard !== void 0 && guard !== null,
      hasActions: !!actions
    });
    if (guard !== void 0 && guard !== null) {
      const guardResult = await this._evaluateGuard(guard, machine.actor.context, machine.eventPayload, machine.actor);
      console.log(`[StateEngine] Guard evaluated: ${guardResult}`);
      if (!guardResult) return;
    }
    await this._executeExit(machine, machine.currentState);
    if (actions) await this._executeActions(machine, actions, machine.eventPayload);
    machine.history.push({ from: machine.currentState, to: targetState, event, timestamp: Date.now() });
    const previousState = machine.currentState;
    machine.currentState = targetState;
    const entryPayload = machine.eventPayload;
    if (previousState !== targetState) {
      machine.eventPayload = entryPayload;
      await this._executeEntry(machine, targetState);
    }
    const shouldRerender = previousState !== targetState && targetState !== "dragging" && !machine._isInitialCreation && !(previousState === "init" && targetState === "idle") && machine.actor._initialRenderComplete && machine.actor.actorEngine;
    if (shouldRerender) machine.actor.actorEngine._scheduleRerender(machine.actor.id);
  }
  async _evaluateGuard(guard, context, payload, actor = null) {
    if (typeof guard === "boolean") return guard;
    try {
      const contextValue = context.value;
      return Boolean(await this.evaluator.evaluate(guard, { context: contextValue, item: payload }));
    } catch (error) {
      return false;
    }
  }
  async _executeStateActions(machine, stateName, type2) {
    try {
      if (!machine || !machine.definition || !machine.definition.states) {
        console.warn("[StateEngine] Invalid machine or definition in _executeStateActions", { machine, stateName, type: type2 });
        return;
      }
      if (!stateName || typeof stateName !== "string") {
        console.warn("[StateEngine] Invalid stateName in _executeStateActions", { stateName, type: type2 });
        return;
      }
      const stateDef = machine.definition.states[stateName];
      if (!stateDef || typeof stateDef !== "object") {
        console.warn("[StateEngine] State not found or invalid in definition", {
          stateName,
          stateDef,
          availableStates: Object.keys(machine.definition.states || {})
        });
        return;
      }
      if (type2 === void 0 || type2 === null || typeof type2 !== "string") {
        console.warn("[StateEngine] Type is undefined/null or not a string in _executeStateActions", { stateName, type: type2, typeOf: typeof type2 });
        return;
      }
      const actions = stateDef?.[type2];
      console.log(`[StateEngine] _executeStateActions:`, {
        stateName,
        type: type2,
        hasActions: !!actions,
        actionsType: actions ? Array.isArray(actions) ? "array" : typeof actions : "null",
        actionsLength: Array.isArray(actions) ? actions.length : "N/A",
        hasTool: !!(actions && actions.tool),
        actionsValue: actions
      });
      if (!actions) {
        console.log(`[StateEngine] No actions found for ${type2} in state ${stateName}`);
        return;
      }
      if (!machine.actor) {
        console.warn("[StateEngine] Machine has no actor in _executeStateActions", { machineId: machine.id, stateName, type: type2 });
        return;
      }
      if (actions.tool) {
        console.log(`[StateEngine] Processing single tool action: ${actions.tool}`);
        const result = await this._invokeTool(machine, actions.tool, actions.payload);
        if (result) machine.lastToolResult = result;
      } else if (Array.isArray(actions)) {
        const originalEventPayload = machine.eventPayload || {};
        console.log(`[StateEngine] Executing array of actions (${actions.length} actions) for ${type2} in state ${stateName}`);
        await this._executeActions(machine, actions, machine.eventPayload);
        console.log(`[StateEngine] Actions completed, checking for SUCCESS handler:`, {
          type: type2,
          isEntry: type2 === "entry",
          hasSuccessHandler: !!stateDef.on?.SUCCESS,
          hasActorEngine: !!machine.actor?.actorEngine,
          lastToolResult: machine.lastToolResult ? Object.keys(machine.lastToolResult) : null,
          stateDefOn: stateDef.on,
          stateDefOnSuccess: stateDef.on?.SUCCESS
        });
        const conditionCheck = type2 === "entry" && stateDef.on?.SUCCESS && machine.actor?.actorEngine;
        console.log(`[StateEngine]  Condition check result:`, {
          conditionCheck,
          typeIsEntry: type2 === "entry",
          stateDefOnSuccess: stateDef.on?.SUCCESS,
          hasActorEngine: !!machine.actor?.actorEngine,
          stateDefOnType: typeof stateDef.on,
          stateDefOnValue: stateDef.on
        });
        if (conditionCheck) {
          const successPayload = {
            result: machine.lastToolResult || null,
            ...originalEventPayload
          };
          console.log(`[StateEngine]  Sending SUCCESS event after entry actions`, {
            actorId: machine.actor.id,
            stateName,
            hasResult: !!successPayload.result,
            resultKeys: successPayload.result ? Object.keys(successPayload.result) : [],
            resultContent: successPayload.result?.content?.substring(0, 50)
          });
          try {
            await machine.actor.actorEngine.sendInternalEvent(machine.actor.id, "SUCCESS", successPayload);
            console.log(`[StateEngine]  SUCCESS event sent successfully`);
          } catch (error) {
            console.error(`[StateEngine]  Failed to send SUCCESS event:`, error);
          }
        } else {
          console.warn(`[StateEngine]  NOT sending SUCCESS event:`, {
            type: type2,
            isEntry: type2 === "entry",
            hasSuccessHandler: !!stateDef.on?.SUCCESS,
            hasActorEngine: !!machine.actor?.actorEngine,
            stateDefOnKeys: stateDef.on ? Object.keys(stateDef.on) : null
          });
        }
      } else if (typeof actions === "object" && actions !== null) {
        const originalEventPayload = machine.eventPayload || {};
        await this._executeActions(machine, actions, machine.eventPayload);
        if (type2 === "entry" && stateDef.on?.SUCCESS && machine.actor?.actorEngine) {
          const successPayload = {
            result: machine.lastToolResult || null,
            ...originalEventPayload
          };
          await machine.actor.actorEngine.sendInternalEvent(machine.actor.id, "SUCCESS", successPayload);
        }
      }
    } catch (error) {
      console.error("[StateEngine] Error in _executeStateActions", {
        error: error.message,
        stack: error.stack,
        machineId: machine?.id,
        stateName,
        type: type2,
        machine: machine ? { id: machine.id, hasActor: !!machine.actor, hasDefinition: !!machine.definition } : null
      });
    }
  }
  async _executeEntry(machine, stateName) {
    console.log(`[StateEngine] Executing entry for state: ${stateName}`, {
      actorId: machine.actor?.id,
      hasEntry: !!machine.definition.states[stateName]?.entry,
      eventPayloadKeys: machine.eventPayload ? Object.keys(machine.eventPayload) : [],
      eventPayloadHasResult: !!machine.eventPayload?.result,
      eventPayloadResultContent: machine.eventPayload?.result?.content?.substring(0, 50),
      lastToolResultKeys: machine.lastToolResult ? Object.keys(machine.lastToolResult) : [],
      lastToolResultContent: machine.lastToolResult?.content?.substring(0, 50)
    });
    await this._executeStateActions(machine, stateName, "entry");
    console.log(`[StateEngine] Entry completed for state: ${stateName}`);
  }
  async _executeExit(machine, stateName) {
    await this._executeStateActions(machine, stateName, "exit");
  }
  _sanitizeUpdates(updates, fallback = {}) {
    if (typeof updates === "string" && updates === "$$result") return fallback;
    if (typeof updates !== "object" || updates === null || Array.isArray(updates)) return {};
    return Object.fromEntries(Object.entries(updates).map(([k, v]) => [k, v === void 0 ? null : v]));
  }
  async _executeActions(machine, actions, payload = {}) {
    if (!machine || !machine.actor) {
      console.warn("[StateEngine] Machine has no actor in _executeActions", { machineId: machine?.id });
      return;
    }
    if (!Array.isArray(actions)) actions = [actions];
    const contextUpdates = {};
    for (const action of actions) {
      if (typeof action === "string") {
        await this._executeNamedAction(machine, action, payload);
      } else if (action?.mapData) {
        await this._executeMapData(machine, action.mapData, payload);
      } else if (action?.updateContext) {
        const updates = await this._evaluatePayload(action.updateContext, machine.actor.context, payload, machine.lastToolResult, machine.actor);
        Object.assign(contextUpdates, this._sanitizeUpdates(updates, machine.lastToolResult || {}));
      } else if (action?.tool) {
        console.log(`[StateEngine] Executing tool action in _executeActions: ${action.tool}`);
        const result = await this._invokeTool(machine, action.tool, action.payload, false);
        console.log(`[StateEngine] Tool action completed, storing result:`, {
          tool: action.tool,
          hasResult: !!result,
          resultKeys: result ? Object.keys(result) : []
        });
        if (result) {
          machine.lastToolResult = result;
          console.log(`[StateEngine] Stored lastToolResult:`, Object.keys(machine.lastToolResult));
        }
        if (action.onSuccess?.updateContext && result) {
          const updates = await this._evaluatePayload(action.onSuccess.updateContext, machine.actor.context, machine.eventPayload, result, machine.actor);
          Object.assign(contextUpdates, this._sanitizeUpdates(updates, result || {}));
        }
      }
    }
    if (Object.keys(contextUpdates).length > 0 && machine.actor?.actorEngine) {
      await machine.actor.actorEngine.updateContextCoValue(machine.actor, contextUpdates);
    }
  }
  /**
   * Execute mapData action - map operations engine configs to context keys
   * Universal API that supports any operation (read, create, update, etc.)
   * @param {Object} machine - State machine instance
   * @param {Object} mapData - Map of context keys to operation configs: { contextKey: { op: 'read', schema: '...', ... } }
   * @param {Object} payload - Event payload for expression evaluation
   */
  async _executeMapData(machine, mapData, payload = {}) {
    if (!machine || !machine.actor) {
      console.warn("[StateEngine] Machine has no actor in _executeMapData", { machineId: machine?.id });
      return;
    }
    if (!this.dbEngine) {
      console.error("[StateEngine] Cannot execute mapData: dbEngine not available");
      return;
    }
    if (!mapData || typeof mapData !== "object") {
      console.error("[StateEngine] mapData must be an object mapping context keys to operation configs", { mapData });
      return;
    }
    console.log(`[StateEngine._executeMapData] Executing mapData:`, mapData);
    for (const [contextKey, operationConfig] of Object.entries(mapData)) {
      if (!contextKey || typeof contextKey !== "string") {
        console.error("[StateEngine] mapData context keys must be strings", { contextKey, operationConfig });
        continue;
      }
      if (!operationConfig || typeof operationConfig !== "object") {
        console.error("[StateEngine] mapData operation config must be an object", { contextKey, operationConfig });
        continue;
      }
      const evaluatedConfig = await this._evaluatePayload(
        operationConfig,
        machine.actor.context,
        payload,
        machine.lastToolResult,
        machine.actor
      );
      const { op = "read", ...params } = evaluatedConfig;
      if (!op || typeof op !== "string") {
        console.error('[StateEngine] mapData operation config must have an "op" property', { contextKey, operationConfig });
        continue;
      }
      if (params.schema && typeof params.schema === "string" && !params.schema.startsWith("co_z")) {
        if (params.schema.startsWith("@schema/")) {
          try {
            const resolved = await this.dbEngine.execute({ op: "resolve", humanReadableKey: params.schema });
            if (resolved?.startsWith("co_z")) {
              params.schema = resolved;
            } else {
              console.error(`[StateEngine] Failed to resolve schema ${params.schema} for context key ${contextKey}`);
              continue;
            }
          } catch (error) {
            console.error(`[StateEngine] Error resolving schema ${params.schema} for context key ${contextKey}:`, error);
            continue;
          }
        } else {
          console.error(`[StateEngine] Invalid schema format for context key ${contextKey}: ${params.schema}. Expected co-id or @schema/... pattern.`);
          continue;
        }
      }
      try {
        const operationParams = { op, ...params };
        console.log(`[StateEngine._executeMapData] Executing operation for ${contextKey}:`, {
          op,
          params: {
            ...params,
            options: params.options ? {
              ...params.options,
              map: params.options.map ? Object.keys(params.options.map) : null
            } : null
          }
        });
        const result = await this.dbEngine.execute(operationParams);
        console.log(`[StateEngine._executeMapData] Operation result for ${contextKey}:`, {
          isReactiveStore: result && typeof result.subscribe === "function",
          hasValue: result && "value" in result
        });
        if (result && typeof result === "object" && typeof result.subscribe === "function" && "value" in result) {
          const actor = machine.actor;
          if (actor && actor.contextCoId && actor.contextSchemaCoId && this.actorEngine) {
            const queryConfig = mapData[contextKey];
            if (queryConfig && queryConfig.op === "read" && queryConfig.schema) {
              await this.actorEngine.updateContextCoValue(actor, {
                [contextKey]: {
                  schema: queryConfig.schema,
                  filter: queryConfig.filter || null,
                  options: queryConfig.options || null
                }
              });
            }
          }
        } else {
          console.warn(`[StateEngine] mapData operation "${op}" did not return a ReactiveStore. Mutations should use tool calls instead.`);
        }
      } catch (error) {
        console.error(`[StateEngine] Failed to execute ${op} operation for context key ${contextKey}:`, error);
      }
    }
  }
  async _executeNamedAction(machine, actionName, payload) {
    const commonActions = {
      resetError: { error: null },
      setLoading: { isLoading: true },
      clearLoading: { isLoading: false }
    };
    const updates = commonActions[actionName];
    if (updates) await machine.actor.actorEngine.updateContextCoValue(machine.actor, updates);
  }
  async _invokeTool(machine, toolName, payload = {}, autoTransition = true) {
    console.log(`[StateEngine] Invoking tool: ${toolName}`, {
      actorId: machine.actor?.id,
      currentState: machine.currentState,
      autoTransition,
      payloadKeys: Object.keys(payload || {})
    });
    try {
      const originalEventPayload = machine.eventPayload || {};
      const evaluatedPayload = await this._evaluatePayload(payload, machine.actor.context, machine.eventPayload || {}, machine.lastToolResult, machine.actor);
      console.log(`[StateEngine] Tool payload evaluated:`, {
        toolName,
        evaluatedPayloadKeys: Object.keys(evaluatedPayload || {}),
        hasMessages: !!evaluatedPayload?.messages,
        messagesLength: evaluatedPayload?.messages?.length
      });
      const result = await this.toolEngine.execute(toolName, machine.actor, evaluatedPayload);
      console.log(`[StateEngine] Tool executed successfully: ${toolName}`, {
        hasResult: !!result,
        resultKeys: result ? Object.keys(result) : [],
        resultContent: result?.content?.substring(0, 100)
      });
      if (autoTransition) {
        const stateDef = machine.definition.states[machine.currentState];
        console.log(`[StateEngine] Sending SUCCESS event for ${toolName}`, {
          currentState: machine.currentState,
          hasSuccessHandler: !!stateDef.on?.SUCCESS
        });
        await machine.actor.actorEngine.sendInternalEvent(machine.actor.id, "SUCCESS", {
          ...originalEventPayload,
          result
          // This must come last to override any result from originalEventPayload
        });
      }
      return result;
    } catch (error) {
      console.error(`[StateEngine] Tool execution failed: ${toolName}`, {
        error: error.message,
        stack: error.stack,
        currentState: machine.currentState,
        autoTransition
      });
      if (autoTransition) {
        const stateDef = machine.definition.states[machine.currentState];
        if (stateDef.on?.ERROR) {
          console.log(`[StateEngine] Sending ERROR event for ${toolName}`);
          await machine.actor.actorEngine.sendInternalEvent(machine.actor.id, "ERROR", { error: error.message });
        } else {
          console.warn(`[StateEngine] No ERROR handler for ${toolName} in state ${machine.currentState}`);
        }
      }
      throw error;
    }
  }
  async _evaluatePayload(payload, context, eventPayload = {}, lastToolResult = null, actor = null) {
    const contextValue = context.value;
    const result = eventPayload?.result || lastToolResult || null;
    if (payload && typeof payload === "object" && JSON.stringify(payload).includes("result")) {
      console.log(`[StateEngine] _evaluatePayload:`, {
        hasEventPayloadResult: !!eventPayload?.result,
        eventPayloadResultType: eventPayload?.result ? typeof eventPayload.result : null,
        eventPayloadResultKeys: eventPayload?.result ? Object.keys(eventPayload.result) : null,
        eventPayloadResultContent: eventPayload?.result?.content?.substring(0, 50),
        hasLastToolResult: !!lastToolResult,
        lastToolResultType: lastToolResult ? typeof lastToolResult : null,
        lastToolResultKeys: lastToolResult ? Object.keys(lastToolResult) : null,
        lastToolResultContent: lastToolResult?.content?.substring(0, 50),
        usingResult: result ? Object.keys(result) : null,
        resultContent: result?.content?.substring(0, 50)
      });
    }
    const data2 = { context: contextValue, item: eventPayload || {}, result };
    const resolved = await resolveExpressions(payload, this.evaluator, data2);
    return resolved;
  }
  getCurrentState(machineId) {
    return this.machines.get(machineId)?.currentState || null;
  }
  getMachine(machineId) {
    return this.machines.get(machineId) || null;
  }
  destroyMachine(machineId) {
    this.machines.delete(machineId);
  }
}
class ToolEngine {
  constructor(moduleRegistry) {
    this.moduleRegistry = moduleRegistry;
    this.tools = /* @__PURE__ */ new Map();
  }
  async registerTool(namespacePath, toolRegistryName, options = {}) {
    if (!options.definition || !options.function) return;
    this.tools.set(toolRegistryName, { definition: options.definition, function: options.function, namespacePath });
  }
  async execute(actionName, actor, payload) {
    const tool = this.tools.get(actionName);
    if (!tool) {
      const availableTools = Array.from(this.tools.keys());
      console.error(`[ToolEngine] Tool not found: ${actionName}`, {
        availableTools,
        totalTools: availableTools.length
      });
      throw new Error(`Tool not found: ${actionName}. Available tools: ${availableTools.join(", ")}`);
    }
    const parametersSchema = tool.definition.parameters || tool.definition.params;
    if (parametersSchema) {
      await validateAgainstSchemaOrThrow(this._normalizeToolSchema(parametersSchema), payload, "tool-payload");
    }
    return await tool.function.execute(actor, payload);
  }
  _normalizeToolSchema(schema) {
    const cleanProps = (props2) => {
      const cleaned2 = {};
      const required3 = [];
      for (const [key, prop] of Object.entries(props2)) {
        if (prop && typeof prop === "object" && prop.type !== "function") {
          const { required: req, type: type2, ...rest } = prop;
          cleaned2[key] = { type: type2, ...rest };
          if (req === true) required3.push(key);
        } else if (prop && typeof prop === "object") {
          cleaned2[key] = prop;
        }
      }
      return { cleaned: cleaned2, required: required3 };
    };
    if (schema.type === "object" && !schema.properties) return schema;
    const props = schema.properties || schema;
    const { cleaned, required: required2 } = cleanProps(props);
    const existingRequired = Array.isArray(schema.required) ? schema.required : [];
    return {
      type: "object",
      properties: cleaned,
      required: [.../* @__PURE__ */ new Set([...existingRequired, ...required2])]
    };
  }
  getToolDefinition(toolName) {
    return this.tools.get(toolName)?.definition || null;
  }
  getAllTools() {
    return Array.from(this.tools.values()).map((t) => t.definition);
  }
}
function resolvePath(obj, path) {
  if (!obj || !path) return void 0;
  return path.split(".").reduce((acc, key) => acc?.[key], obj);
}
class Evaluator {
  constructor(moduleRegistry = null, options = {}) {
    this.registry = moduleRegistry;
    this.maxDepth = options.maxDepth || 50;
    this.validateExpressions = options.validateExpressions !== false;
    this.dbEngine = options.dbEngine || null;
  }
  /**
   * Evaluate a MaiaScript expression
   * @param {any} expression - The expression to evaluate
   * @param {Object} data - The data context { context, item }
   * @param {number} depth - Current recursion depth (internal)
   * @returns {Promise<any>} The evaluated result
   */
  async evaluate(expression, data2, depth = 0) {
    if (depth > this.maxDepth) {
      throw new Error(`[Evaluator] Maximum recursion depth (${this.maxDepth}) exceeded. Expression may be malicious or too complex.`);
    }
    if (this.validateExpressions && depth === 0 && typeof expression === "object" && expression !== null && !Array.isArray(expression)) {
      try {
        const { getSchema: getSchema2 } = await Promise.resolve().then(() => index$2);
        const expressionSchema2 = getSchema2("maia-script-expression");
        if (expressionSchema2) {
          await validateAgainstSchemaOrThrow(expressionSchema2, expression, "maia-script-expression");
        }
      } catch (error) {
        console.error("[Evaluator] Expression validation failed:", error);
        throw new Error(`[Evaluator] Invalid MaiaScript expression: ${error.message}`);
      }
    }
    if (typeof expression === "number" || typeof expression === "boolean" || expression === null || expression === void 0) {
      return expression;
    }
    if (typeof expression === "string" && expression.startsWith("$")) {
      return this.evaluateShortcut(expression, data2);
    }
    if (typeof expression !== "object") return expression;
    if ("$context" in expression) {
      return resolvePath(data2.context, expression.$context);
    }
    if ("$item" in expression) {
      return resolvePath(data2.item, expression.$item);
    }
    if ("$eq" in expression) {
      const [left, right] = expression.$eq;
      const leftValue = await this.evaluate(left, data2, depth + 1);
      const rightValue = await this.evaluate(right, data2, depth + 1);
      return leftValue === rightValue;
    }
    if ("$ne" in expression) {
      const [left, right] = expression.$ne;
      const leftValue = await this.evaluate(left, data2, depth + 1);
      const rightValue = await this.evaluate(right, data2, depth + 1);
      return leftValue !== rightValue;
    }
    if ("$not" in expression) {
      const operand = await this.evaluate(expression.$not, data2, depth + 1);
      return !operand;
    }
    if ("$and" in expression) {
      const operands = Array.isArray(expression.$and) ? expression.$and : [expression.$and];
      for (const operand of operands) {
        const value = await this.evaluate(operand, data2, depth + 1);
        if (!value) {
          return false;
        }
      }
      return true;
    }
    if ("$or" in expression) {
      const operands = Array.isArray(expression.$or) ? expression.$or : [expression.$or];
      for (const operand of operands) {
        const value = await this.evaluate(operand, data2, depth + 1);
        if (value) {
          return true;
        }
      }
      return false;
    }
    if ("$trim" in expression) {
      const value = await this.evaluate(expression.$trim, data2, depth + 1);
      if (typeof value === "string") {
        return value.trim();
      }
      return value;
    }
    if ("$gt" in expression) {
      const [left, right] = expression.$gt;
      const leftValue = await this.evaluate(left, data2, depth + 1);
      const rightValue = await this.evaluate(right, data2, depth + 1);
      return leftValue > rightValue;
    }
    if ("$length" in expression) {
      const value = await this.evaluate(expression.$length, data2, depth + 1);
      return Array.isArray(value) ? value.length : typeof value === "string" ? value.length : 0;
    }
    if ("$concat" in expression) {
      const arrays = Array.isArray(expression.$concat) ? expression.$concat : [expression.$concat];
      const evaluatedArrays = await Promise.all(arrays.map((arr) => this.evaluate(arr, data2, depth + 1)));
      const validArrays = evaluatedArrays.filter((arr) => arr != null).map((arr) => Array.isArray(arr) ? arr : [arr]);
      return validArrays.flat();
    }
    if ("$map" in expression) {
      const mapConfig = expression.$map;
      const array = await this.evaluate(mapConfig.array, data2, depth + 1);
      if (!array || !Array.isArray(array)) {
        return [];
      }
      const itemKey = mapConfig.as || "item";
      const returnExpr = mapConfig.return || mapConfig.do;
      if (!returnExpr) {
        throw new Error('[Evaluator] $map operation requires either "return" or "do" property');
      }
      const results = [];
      for (const item of array) {
        const itemData = {
          ...data2,
          item
        };
        const result = await this.evaluateMapReturn(returnExpr, itemData, itemKey, item, depth + 1);
        results.push(result);
      }
      return results;
    }
    if ("$if" in expression) {
      let condition = expression.$if.condition;
      if (typeof condition === "string" && condition.startsWith("$")) {
        condition = this.evaluateShortcut(condition, data2);
      } else {
        condition = await this.evaluate(condition, data2, depth + 1);
      }
      return condition ? await this.evaluate(expression.$if.then, data2, depth + 1) : await this.evaluate(expression.$if.else, data2, depth + 1);
    }
    if (typeof expression === "string" && expression.includes("?") && expression.includes(":")) {
      const [conditionStr, rest] = expression.split("?").map((s) => s.trim());
      if (rest) {
        const [thenStr, elseStr] = rest.split(":").map((s) => s.trim());
        const condition = conditionStr.startsWith("$") ? this.evaluateShortcut(conditionStr, data2) : await this.evaluate(conditionStr, data2, depth + 1);
        return condition ? await this.evaluate(thenStr, data2, depth + 1) : await this.evaluate(elseStr, data2, depth + 1);
      }
    }
    return expression;
  }
  /**
   * Evaluate return expression in $map context with custom item key
   * Handles shortcuts like $$msg.role when as="msg" by treating $$itemKey.path as item.path
   * @param {any} returnExpr - The return expression to evaluate
   * @param {Object} data - The data context { context, item, result }
   * @param {string} itemKey - The 'as' variable name (e.g., "msg")
   * @param {any} currentItem - The current array item being mapped
   * @param {number} depth - Current recursion depth
   * @returns {Promise<any>} The evaluated result
   */
  async evaluateMapReturn(returnExpr, data2, itemKey, currentItem, depth) {
    if (typeof returnExpr === "string" && returnExpr.startsWith("$$" + itemKey + ".")) {
      const path = returnExpr.substring(2 + itemKey.length + 1);
      return resolvePath(currentItem, path);
    }
    if (typeof returnExpr === "object" && returnExpr !== null && !Array.isArray(returnExpr)) {
      const result = {};
      for (const [key, value] of Object.entries(returnExpr)) {
        if (typeof value === "string" && value.startsWith("$$" + itemKey + ".")) {
          const path = value.substring(2 + itemKey.length + 1);
          result[key] = resolvePath(currentItem, path);
        } else {
          result[key] = await this.evaluate(value, data2, depth + 1);
        }
      }
      return result;
    }
    return await this.evaluate(returnExpr, data2, depth + 1);
  }
  /**
   * Evaluate compact shortcut syntax: $key or $$key
   * v0.2 syntax:
   * - $key  context.key (implicit context)
   * - $$key  item.key (explicit item with double-dollar)
   * - $$result  result (tool result with double-dollar)
   * @param {string} shortcut - The shortcut string (e.g., "$title", "$$text", "$$result.draggedItemId")
   * @param {Object} data - The data context { context, item, result }
   * @returns {any} The evaluated result
   */
  evaluateShortcut(shortcut, data2) {
    if (shortcut.startsWith("$$result")) {
      const path2 = shortcut.substring(8);
      if (path2.startsWith(".")) return resolvePath(data2.result, path2.substring(1));
      if (path2 === "") return data2.result;
    }
    if (shortcut.startsWith("$$")) {
      return resolvePath(data2.item, shortcut.substring(2));
    }
    const path = shortcut.substring(1);
    const resolved = resolvePath(data2.context, path);
    if (resolved instanceof ReactiveStore) {
      return resolved.value;
    }
    return resolved;
  }
  /**
   * Check if an expression is a DSL operation
   * @param {any} expression - The expression to check
   * @returns {boolean} True if it's a DSL operation
   */
  isDSLOperation(expression) {
    if (typeof expression === "string" && expression.startsWith("$")) {
      return true;
    }
    if (typeof expression !== "object" || expression === null) return false;
    return "$context" in expression || "$item" in expression || "$if" in expression || "$eq" in expression || "$ne" in expression || "$not" in expression || "$and" in expression || "$or" in expression || "$trim" in expression || "$gt" in expression || "$length" in expression || "$concat" in expression || "$map" in expression;
  }
}
const evaluator = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Evaluator
}, Symbol.toStringTag, { value: "Module" }));
const noopDef = {
  "$schema": "@schema/tool",
  "$id": "tool_noop_001",
  "name": "@core/noop",
  "description": "No operation tool (does nothing)",
  "parameters": {
    "type": "object",
    "properties": {}
  }
};
const publishMessageDef = {
  "$schema": "@schema/tool",
  "$id": "tool_publish_message_001",
  "name": "@core/publishMessage",
  "description": "Publishes a message to subscribed actors",
  "parameters": {
    "type": "object",
    "properties": {
      "type": {
        "type": "string",
        "description": "Message type"
      },
      "payload": {
        "type": "object",
        "description": "Message payload",
        "required": false
      }
    },
    "required": ["type"]
  }
};
const memoryDef = {
  "$schema": "@schema/tool",
  "$id": "tool_memory_001",
  "name": "@memory",
  "description": "Memory tool for interacting with Honcho - persistent agent memory system",
  "parameters": {
    "type": "object",
    "properties": {
      "op": {
        "type": "string",
        "enum": ["createSession", "addMessage", "getContext", "chat"],
        "description": "Memory operation to execute"
      },
      "workspaceId": {
        "type": "string",
        "description": "Honcho workspace ID (default: 'maiaos-dev')"
      },
      "peerId": {
        "type": "string",
        "description": "Peer ID ('maia' for agent, 'samuel' for user)"
      },
      "sessionId": {
        "type": "string",
        "description": "Session ID (required for addMessage, optional for chat)"
      },
      "content": {
        "type": "string",
        "description": "Message content (required for addMessage)"
      },
      "query": {
        "type": "string",
        "description": "Query for chat/getContext operations"
      },
      "target": {
        "type": "string",
        "description": "Target peer ID for chat (optional, defaults to querying about the peer)"
      }
    },
    "required": ["op"]
  }
};
const llmDef = {
  "$schema": "@schema/tool",
  "$id": "tool_llm_001",
  "name": "@llm/chat",
  "description": "LLM chat tool using RedPill API (OpenAI-compatible)",
  "parameters": {
    "type": "object",
    "properties": {
      "messages": {
        "type": "array",
        "description": "Array of messages with role and content",
        "items": {
          "type": "object",
          "properties": {
            "role": {
              "type": "string",
              "enum": ["system", "user", "assistant"],
              "description": "Message role"
            },
            "content": {
              "type": "string",
              "description": "Message content"
            }
          },
          "required": ["role", "content"]
        }
      },
      "model": {
        "type": "string",
        "description": "Model to use (default: moonshotai/kimi-k2.5)",
        "default": "moonshotai/kimi-k2.5"
      },
      "temperature": {
        "type": "number",
        "description": "Temperature for response (0-2, default: 1)",
        "default": 1
      }
    },
    "required": ["messages"]
  }
};
const privateLlmToolDef = {
  "$schema": "@schema/tool",
  "$id": "tool_private_llm_001",
  "name": "@private-llm/chat",
  "description": "Private LLM chat tool using RedPill API (OpenAI-compatible) for RedPill models",
  "parameters": {
    "type": "object",
    "properties": {
      "messages": {
        "type": "array",
        "description": "Array of messages with role and content",
        "items": {
          "type": "object",
          "properties": {
            "role": {
              "type": "string",
              "enum": ["system", "user", "assistant"],
              "description": "Message role"
            },
            "content": {
              "type": "string",
              "description": "Message content"
            }
          },
          "required": ["role", "content"]
        }
      },
      "model": {
        "type": "string",
        "description": "RedPill model to use (default: moonshotai/kimi-k2.5)",
        "default": "moonshotai/kimi-k2.5"
      },
      "temperature": {
        "type": "number",
        "description": "Temperature for response (0-2, default: 1)",
        "default": 1
      }
    },
    "required": ["messages"]
  }
};
const noopFn = {
  async execute(actor, payload) {
  }
};
const publishMessageFn = {
  async execute(actor, payload) {
    const { type: type2, payload: messagePayload = {}, target } = payload;
    if (!type2) {
      throw new Error("Message type is required");
    }
    if (!target) {
      throw new Error("Target is required. Topics infrastructure removed - use direct messaging with target parameter.");
    }
    if (actor.actorEngine) {
      if (target.startsWith("@actor/")) {
        console.error(`[publishMessage]  Target not transformed: ${target}. Should be a co-id. Check schema transformer.`);
        return;
      }
      await actor.actorEngine.sendMessage(target, {
        type: type2,
        payload: messagePayload,
        from: actor.id,
        timestamp: Date.now()
      });
    } else {
      console.warn("[publishMessage] Actor has no actorEngine reference");
    }
  }
};
const getApiBaseUrl$2 = () => {
  const domain = "localhost:4201";
  if (domain.startsWith("http://") || domain.startsWith("https://")) {
    return domain;
  }
  return `http://${domain}`;
};
const API_BASE_URL$2 = getApiBaseUrl$2();
async function callApi(endpoint, body) {
  const url = `${API_BASE_URL$2}${endpoint}`;
  const response = await fetch(url, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify(body)
  });
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({ error: "Unknown error" }));
    throw new Error(`[@memory] API request failed: ${errorData.error || errorData.message || response.statusText}`);
  }
  return await response.json();
}
const memoryFn = {
  async execute(actor, payload) {
    const { op, workspaceId = "maiaos-dev", peerId, sessionId, content, query, target } = payload;
    try {
      switch (op) {
        case "createSession": {
          if (!peerId) {
            throw new Error("[@memory] peerId is required for createSession");
          }
          const result = await callApi("/api/v0/memory/create-session", {
            workspaceId,
            peerId,
            sessionId
          });
          return { sessionId: result.sessionId, workspaceId: result.workspaceId, peerId: result.peerId };
        }
        case "addMessage": {
          if (!sessionId || !peerId || !content) {
            throw new Error("[@memory] sessionId, peerId, and content are required for addMessage");
          }
          const result = await callApi("/api/v0/memory/add-message", {
            workspaceId,
            sessionId,
            peerId,
            content
          });
          return { success: result.success, sessionId: result.sessionId, peerId: result.peerId, content: result.content };
        }
        case "getContext": {
          if (!peerId || !query) {
            throw new Error("[@memory] peerId and query are required for getContext");
          }
          const result = await callApi("/api/v0/memory/get-context", {
            workspaceId,
            peerId,
            sessionId,
            query,
            target
          });
          return { context: result.context };
        }
        case "chat": {
          if (!peerId || !query) {
            throw new Error("[@memory] peerId and query are required for chat");
          }
          const result = await callApi("/api/v0/memory/chat", {
            workspaceId,
            peerId,
            sessionId,
            query,
            target
          });
          return { response: result.response };
        }
        default:
          throw new Error(`[@memory] Unknown operation: ${op}`);
      }
    } catch (error) {
      console.error("[@memory] Error:", error);
      throw error;
    }
  }
};
const getApiBaseUrl$1 = () => {
  const domain = "localhost:4201";
  if (domain.startsWith("http://") || domain.startsWith("https://")) {
    return domain;
  }
  return `http://${domain}`;
};
const API_BASE_URL$1 = getApiBaseUrl$1();
const llmFn = {
  async execute(actor, payload) {
    const { messages, model = "moonshotai/kimi-k2.5", temperature = 1 } = payload;
    if (!messages || !Array.isArray(messages) || messages.length === 0) {
      throw new Error("[@llm/chat] messages array is required");
    }
    try {
      const response = await fetch(`${API_BASE_URL$1}/api/v0/llm/chat`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          model,
          messages,
          temperature
        })
      });
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: "Unknown error" }));
        throw new Error(`[@llm/chat] API request failed: ${errorData.error || errorData.message || response.statusText}`);
      }
      const data2 = await response.json();
      return {
        content: data2.content,
        role: data2.role || "assistant",
        usage: data2.usage || null
      };
    } catch (error) {
      console.error("[@llm/chat] Error:", error);
      throw error;
    }
  }
};
const getApiBaseUrl = () => {
  const domain = "localhost:4201";
  if (domain.startsWith("http://") || domain.startsWith("https://")) {
    return domain;
  }
  return `http://${domain}`;
};
const API_BASE_URL = getApiBaseUrl();
const privateLlmTool = {
  async execute(actor, payload) {
    console.log("[@private-llm/chat] Tool called with payload:", {
      messagesCount: payload?.messages?.length,
      model: payload?.model,
      temperature: payload?.temperature,
      messages: payload?.messages
    });
    const { messages, model = "moonshotai/kimi-k2.5", temperature = 1 } = payload;
    if (!messages || !Array.isArray(messages) || messages.length === 0) {
      console.error("[@private-llm/chat] Invalid messages:", messages);
      throw new Error("[@private-llm/chat] messages array is required");
    }
    try {
      console.log("[@private-llm/chat] Calling API:", `${API_BASE_URL}/api/v0/llm/chat`);
      const response = await fetch(`${API_BASE_URL}/api/v0/llm/chat`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          model,
          messages,
          temperature
        })
      });
      console.log("[@private-llm/chat] API response status:", response.status, response.statusText);
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: "Unknown error" }));
        console.error("[@private-llm/chat] API error:", errorData);
        throw new Error(`[@private-llm/chat] API request failed: ${errorData.error || errorData.message || response.statusText}`);
      }
      const data2 = await response.json();
      console.log("[@private-llm/chat] API response data:", {
        hasContent: !!data2.content,
        contentLength: data2.content?.length,
        role: data2.role,
        usage: data2.usage
      });
      const result = {
        content: data2.content,
        role: data2.role || "assistant",
        usage: data2.usage || null
      };
      console.log("[@private-llm/chat] Returning result:", result);
      return result;
    } catch (error) {
      console.error("[@private-llm/chat] Error:", error);
      throw error;
    }
  }
};
const TOOLS = {
  "core/noop": { definition: noopDef, function: noopFn },
  "core/publishMessage": { definition: publishMessageDef, function: publishMessageFn },
  "memory/memory": { definition: memoryDef, function: memoryFn },
  "llm/llm": { definition: llmDef, function: llmFn },
  "private-llm/chat": { definition: privateLlmToolDef, function: privateLlmTool }
};
function getTool(namespacePath) {
  return TOOLS[namespacePath] || null;
}
function getAllToolDefinitions() {
  const definitions2 = {};
  for (const [path, tool] of Object.entries(TOOLS)) {
    definitions2[path] = tool.definition;
  }
  return definitions2;
}
const index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  TOOLS,
  getAllToolDefinitions,
  getTool
}, Symbol.toStringTag, { value: "Module" }));
class Registry {
  constructor() {
    this.modules = /* @__PURE__ */ new Map();
    this.moduleConfigs = /* @__PURE__ */ new Map();
  }
  /**
   * Register a MaiaScript module
   * @param {string} name - Module name (e.g., 'core', 'dragdrop')
   * @param {Object} module - Module instance or class
   * @param {Object} config - Optional module configuration/metadata
   */
  registerModule(name, module2, config2 = {}) {
    if (this.modules.has(name)) {
      console.warn(`[Registry] Module "${name}" already registered, overwriting`);
    }
    this.modules.set(name, module2);
    this.moduleConfigs.set(name, {
      name,
      version: config2.version || "1.0.0",
      description: config2.description || "",
      ...config2
    });
  }
  /**
   * Get a module by name
   * @param {string} name - Module name
   * @returns {Object|null} Module instance or null
   */
  getModule(name) {
    return this.modules.get(name) || null;
  }
  /**
   * Get module configuration
   * @param {string} name - Module name
   * @returns {Object|null} Module config or null
   */
  getModuleConfig(name) {
    return this.moduleConfigs.get(name) || null;
  }
  /**
   * Check if a module exists
   * @param {string} name - Module name
   * @returns {boolean}
   */
  hasModule(name) {
    return this.modules.has(name);
  }
  /**
   * List all registered modules
   * @returns {Array<string>} Array of module names
   */
  listModules() {
    return Array.from(this.modules.keys());
  }
  /**
   * List all module configs
   * @returns {Array<Object>} Array of module configurations
   */
  listModuleConfigs() {
    return Array.from(this.moduleConfigs.values());
  }
  /**
   * Clear all registered modules
   * @internal For testing purposes only
   */
  clear() {
    this.modules.clear();
    this.moduleConfigs.clear();
    console.log("[Registry] Cleared all modules");
  }
  /**
   * Load a module (imports and registers)
   * @param {string} moduleName - Module name to load
   * @param {string} modulePath - Path to module file (optional, defaults to modules/{name}.module.js)
   * @returns {Promise<void>}
   */
  async loadModule(moduleName, modulePath = null) {
    if (this.hasModule(moduleName)) {
      console.log(`[Registry] Module "${moduleName}" already loaded`);
      return;
    }
    const path = modulePath || `./${moduleName}.module.js`;
    try {
      const module2 = await import(
        /* @vite-ignore */
        path
      );
      if (module2.default && typeof module2.default.register === "function") {
        await module2.default.register(this);
      } else if (typeof module2.register === "function") {
        await module2.register(this);
      } else {
        console.warn(`[Registry] Module "${moduleName}" has no register method`);
      }
    } catch (error) {
      console.error(`[Registry] Failed to load module "${moduleName}":`, error);
      throw error;
    }
  }
  /**
   * Query module for configuration/data
   * @param {string} moduleName - Module name
   * @param {string} query - Query string
   * @returns {any} Query result or null
   */
  query(moduleName, query) {
    const module2 = this.getModule(moduleName);
    if (!module2) return null;
    if (typeof module2.query === "function") return module2.query(query);
    if (module2.config && query in module2.config) return module2.config[query];
    return null;
  }
  /**
   * Get tool engine from registry
   * @param {string} moduleName - Module name for error messages
   * @returns {Object} ToolEngine instance
   */
  _getToolEngine(moduleName) {
    const toolEngine = this._toolEngine;
    if (!toolEngine) {
      throw new Error(`[${moduleName}] ToolEngine not available in registry`);
    }
    return toolEngine;
  }
  /**
   * Register tools from tools registry
   * @param {string} moduleName - Module name
   * @param {Array<string>} toolNames - Array of tool names
   * @param {string} namespace - Namespace prefix (e.g., '@core')
   * @param {Object} options - Options (silent, etc.)
   * @returns {Promise<Array<string>>} Array of registered tool names
   */
  async _registerToolsFromRegistry(moduleName, toolNames, namespace, options = {}) {
    const { silent = false } = options;
    const toolEngine = this._getToolEngine(moduleName);
    const registeredTools = [];
    for (const toolName of toolNames) {
      try {
        const tool = getTool(`${moduleName}/${toolName}`);
        if (tool) {
          await toolEngine.registerTool(`${moduleName}/${toolName}`, `${namespace}/${toolName}`, {
            definition: tool.definition,
            function: tool.function
          });
          registeredTools.push(`${namespace}/${toolName}`);
        }
      } catch (error) {
        if (!silent) {
          console.error(`[${moduleName}] Failed to register ${namespace}/${toolName}:`, error.message);
        }
      }
    }
    return registeredTools;
  }
}
class DBEngine2 extends DBEngine$1 {
  constructor(backend) {
    const evaluator2 = new Evaluator();
    super(backend, { evaluator: evaluator2 });
  }
}
const dbTool = {
  async execute(actor, payload) {
    if (!actor) {
      throw new Error("[@db] Actor context required");
    }
    const os = actor.actorEngine.os;
    if (!os || !os.db) {
      throw new Error("[@db] Database engine not available");
    }
    if (payload.op === "create" && payload.schema) {
      if (!payload.schema.startsWith("co_z")) {
        throw new Error(`[@db] Schema must be a co-id (co_z...), got: ${payload.schema}. State machine entry actions should be transformed during seeding. No human-readable fallbacks allowed.`);
      }
    }
    const result = await os.db(payload);
    return result;
  }
};
const dbToolDef = {
  "$schema": "@schema/tool",
  "$id": "db",
  "name": "Database Tool",
  "description": "Unified API for all database operations (query, create, update, delete)",
  "schema": "@schema/tool",
  "params": {
    "op": {
      "type": "string",
      "enum": ["query", "create", "update", "delete", "seed"],
      "description": "Database operation to execute"
    },
    "schema": {
      "type": "string",
      "description": "Schema reference (co-id) - REQUIRED for 'create' operation only (no CoValue exists yet). OPTIONAL for 'update' and 'delete' operations (schema is extracted from CoValue headerMeta internally by operations)."
    },
    "key": {
      "type": "string",
      "description": "Optional: Specific key for config queries"
    },
    "filter": {
      "type": "object",
      "description": "Optional: Filter criteria for data queries"
    },
    "callback": {
      "description": "Optional: Callback function for reactive subscriptions (not validated - runtime only)"
    },
    "id": {
      "type": "string",
      "description": "Optional: Record ID for update/delete operations"
    },
    "data": {
      "type": "object",
      "description": "Optional: Data for create/update operations"
    }
  },
  "returns": {
    "type": "any",
    "description": "Operation result (data, unsubscribe function, created/updated/deleted record, etc.)"
  }
};
const config$2 = {
  version: "1.0.0",
  description: "Unified database operation API",
  namespace: "@db",
  tools: ["@db"]
};
async function register$2(registry) {
  const toolEngine = registry._getToolEngine("DBModule");
  toolEngine.tools.set("@db", {
    definition: dbToolDef,
    function: dbTool,
    namespacePath: "db/db"
  });
  registry.registerModule("db", { config: config$2, query: (q) => q === "tools" ? ["@db"] : null }, {
    version: config$2.version,
    description: config$2.description,
    namespace: config$2.namespace,
    tools: config$2.tools
  });
}
const dbModule = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  config: config$2,
  register: register$2
}, Symbol.toStringTag, { value: "Module" }));
const config$1 = {
  version: "1.0.0",
  description: "Core UI tools (view modes, modals, utilities)",
  namespace: "@core",
  tools: ["noop", "preventDefault", "publishMessage"]
};
async function register$1(registry) {
  const toolNames = config$1.tools;
  const registeredTools = await registry._registerToolsFromRegistry("core", toolNames, config$1.namespace, { silent: true });
  registry.registerModule("core", { config: config$1, query: () => null }, {
    version: config$1.version,
    description: config$1.description,
    namespace: config$1.namespace,
    tools: registeredTools
  });
}
const coreModule = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  config: config$1,
  register: register$1
}, Symbol.toStringTag, { value: "Module" }));
const config = {
  version: "1.0.0",
  description: "Private LLM tool for RedPill API integration",
  namespace: "@private-llm",
  tools: ["@private-llm/chat"]
};
async function register(registry) {
  const toolEngine = registry._getToolEngine("PrivateLLMModule");
  toolEngine.tools.set("@private-llm/chat", {
    definition: privateLlmToolDef,
    function: privateLlmTool,
    namespacePath: "private-llm/chat"
  });
  registry.registerModule("private-llm", { config, query: (q) => q === "tools" ? ["@private-llm/chat"] : null }, {
    version: config.version,
    description: config.description,
    namespace: config.namespace,
    tools: config.tools
  });
}
const privateLlmModule = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  config,
  register
}, Symbol.toStringTag, { value: "Module" }));
const preloadedModules = {
  "db": dbModule,
  "core": coreModule,
  "private-llm": privateLlmModule
};
class MaiaOS {
  constructor() {
    this.moduleRegistry = null;
    this.evaluator = null;
    this.toolEngine = null;
    this.stateEngine = null;
    this.styleEngine = null;
    this.viewEngine = null;
    this.actorEngine = null;
    this.subscriptionEngine = null;
    this.dbEngine = null;
    this._node = null;
    this._account = null;
    this._syncDomain = null;
  }
  /**
   * Compatibility property for maia-city and other tools
   * Exposes node and account for CoJSON backend access
   */
  get id() {
    if (!this._node || !this._account) {
      return null;
    }
    return {
      maiaId: this._account,
      node: this._node
    };
  }
  /**
   * Get all CoValues from the node (for maia-city compatibility)
   * @returns {Array} Array of CoValue metadata
   */
  getAllCoValues() {
    if (!this._node) {
      return [];
    }
    const allCoValues = [];
    const coValuesMap = this._node.coValues;
    if (coValuesMap && typeof coValuesMap.entries === "function") {
      for (const [coId, coValueCore] of coValuesMap.entries()) {
        try {
          if (!coValueCore.isAvailable()) {
            allCoValues.push({
              id: coId,
              type: "loading",
              schema: null,
              headerMeta: null,
              keys: "N/A",
              content: null,
              createdAt: null
            });
            continue;
          }
          const content = coValueCore.getCurrentContent();
          const header = coValueCore.verified?.header;
          const headerMeta = header?.meta || null;
          const schema = headerMeta?.$schema || null;
          const createdAt = header?.createdAt || null;
          let keysCount = "N/A";
          if (content && content.keys && typeof content.keys === "function") {
            try {
              const keys = content.keys();
              keysCount = keys.length;
            } catch (e) {
            }
          }
          const type2 = content?.type || "unknown";
          let specialContent = null;
          if (type2 === "costream") {
            try {
              const streamData = content.toJSON();
              if (streamData instanceof Uint8Array) {
                specialContent = {
                  type: "stream",
                  itemCount: "binary",
                  preview: `${streamData.length} bytes`
                };
              } else if (streamData && typeof streamData === "object") {
                const allItems = [];
                for (const sessionKey in streamData) {
                  if (Array.isArray(streamData[sessionKey])) {
                    allItems.push(...streamData[sessionKey]);
                  }
                }
                specialContent = {
                  type: "stream",
                  itemCount: allItems.length,
                  preview: allItems.slice(0, 3)
                };
              }
            } catch (e) {
            }
          } else if (type2 === "coplaintext") {
            try {
              specialContent = {
                type: "plaintext",
                content: content.text || content.toString()
              };
            } catch (e) {
            }
          }
          allCoValues.push({
            id: coId,
            type: type2,
            schema,
            headerMeta,
            keys: keysCount,
            content: specialContent || content,
            createdAt
          });
        } catch (error) {
          console.warn(`Error processing CoValue ${coId}:`, error);
          allCoValues.push({
            id: coId,
            type: "error",
            schema: null,
            headerMeta: null,
            keys: "N/A",
            content: null,
            createdAt: null,
            error: error.message
          });
        }
      }
    }
    return allCoValues;
  }
  /**
   * Boot the operating system
   * @param {Object} config - Boot configuration
   * @param {Object} [config.node] - LocalNode instance (required for CoJSON backend if backend not provided)
   * @param {Object} [config.account] - RawAccount instance (required for CoJSON backend if backend not provided)
   * @param {Object} [config.backend] - Pre-initialized backend (alternative to node+account)
   * @param {Object} [config.registry] - Config registry for seeding
   * @param {string} [config.syncDomain] - Sync service domain (overrides env vars, single source of truth)
   * @returns {Promise<MaiaOS>} Booted OS instance
   * @throws {Error} If neither backend nor node+account is provided
   */
  static async boot(config2 = {}) {
    const os = new MaiaOS();
    if (config2.syncDomain) {
      os._syncDomain = config2.syncDomain;
    }
    if (config2.node && config2.account) {
      os._node = config2.node;
      os._account = config2.account;
    }
    const backend = await MaiaOS._initializeDatabase(os, config2);
    if (config2.registry) {
      await MaiaOS._seedDatabase(os, backend, config2);
    }
    MaiaOS._initializeEngines(os, config2);
    await MaiaOS._loadModules(os, config2);
    return os;
  }
  /**
   * Initialize database backend and engine
   * Requires either a pre-initialized backend or CoJSON node+account
   * @param {MaiaOS} os - OS instance
   * @param {Object} config - Boot configuration
   * @param {Object} [config.node] - LocalNode instance (required for CoJSON backend)
   * @param {Object} [config.account] - RawAccount instance (required for CoJSON backend)
   * @param {Object} [config.backend] - Pre-initialized backend (alternative to node+account)
   * @returns {Promise<DBAdapter>} Initialized backend
   * @throws {Error} If neither backend nor node+account is provided
   */
  static async _initializeDatabase(os, config2 = {}) {
    if (config2.backend) {
      os.dbEngine = new DBEngine2(config2.backend);
      return config2.backend;
    }
    if (config2.node && config2.account) {
      const { CoJSONBackend: CoJSONBackend2 } = await Promise.resolve().then(() => index$1);
      const backend = new CoJSONBackend2(config2.node, config2.account);
      os.dbEngine = new DBEngine2(backend);
      backend.dbEngine = os.dbEngine;
      return backend;
    }
    throw new Error(
      "MaiaOS.boot() requires either a backend or node+account for CoJSON backend. Provide either: { backend: <DBAdapter> } or { node: <LocalNode>, account: <RawAccount> }"
    );
  }
  /**
   * Collect schemas from schemata module
   * @returns {Object} Schemas object
   */
  static _collectSchemas() {
    const schemas = {};
    if (typeof getAllSchemas === "function") {
      Object.assign(schemas, getAllSchemas());
    }
    if (typeof getMetaSchema === "function") {
      schemas["meta-schema"] = getMetaSchema();
    }
    return schemas;
  }
  /**
   * Validate schemas against meta schema
   * @param {Object} schemas - Schemas to validate
   * @param {ValidationEngine} validationEngine - Validation engine instance
   * @throws {Error} If any schema fails validation
   */
  static async _validateSchemas(schemas, validationEngine2) {
    for (const [name, schema] of Object.entries(schemas)) {
      const result = await validationEngine2.validateSchemaAgainstMeta(schema);
      if (!result.valid) {
        const errorDetails = result.errors.map((err) => `  - ${err.instancePath}: ${err.message}`).join("\n");
        console.error(` Schema '${name}' failed meta schema validation:
${errorDetails}`);
        throw new Error(`Schema '${name}' is not valid JSON Schema`);
      }
    }
  }
  /**
   * Seed database with configs, schemas, and tool definitions
   * @param {MaiaOS} os - OS instance
   * @param {DBAdapter} backend - Database backend (CoJSONBackend)
   * @param {Object} config - Boot configuration
   */
  static async _seedDatabase(os, backend, config2) {
    const { getAllToolDefinitions: getAllToolDefinitions2 } = await Promise.resolve().then(() => index);
    const toolDefs = getAllToolDefinitions2();
    const configsWithTools = {
      ...config2.registry,
      tool: toolDefs
      // Add tool definitions under 'tool' key
    };
    const schemas = MaiaOS._collectSchemas();
    const validationEngine2 = new ValidationEngine();
    await validationEngine2.initialize();
    await MaiaOS._validateSchemas(schemas, validationEngine2);
    const defaultData = config2.registry?.data || {};
    const seedData2 = defaultData;
    await os.dbEngine.execute({
      op: "seed",
      configs: configsWithTools,
      schemas,
      data: seedData2
    });
    const { setSchemaResolver: setSchemaResolver2 } = await Promise.resolve().then(() => validation_helper);
    setSchemaResolver2({ dbEngine: os.dbEngine });
  }
  /**
   * Initialize all engines and wire dependencies
   * @param {MaiaOS} os - OS instance
   * @param {Object} config - Boot configuration
   */
  static _initializeEngines(os, config2) {
    os.moduleRegistry = new Registry();
    os.evaluator = new Evaluator(os.moduleRegistry, { dbEngine: os.dbEngine });
    os.toolEngine = new ToolEngine(os.moduleRegistry);
    os.moduleRegistry._toolEngine = os.toolEngine;
    os.moduleRegistry._dbEngine = os.dbEngine;
    os.stateEngine = new StateEngine(os.toolEngine, os.evaluator);
    os.styleEngine = new StyleEngine();
    if (config2.isDevelopment || false) {
      os.styleEngine.clearCache();
    }
    os.viewEngine = new ViewEngine(os.evaluator, null, os.moduleRegistry);
    os.actorEngine = new ActorEngine(
      os.styleEngine,
      os.viewEngine,
      os.moduleRegistry,
      os.toolEngine,
      os.stateEngine
    );
    os.actorEngine.dbEngine = os.dbEngine;
    os.viewEngine.dbEngine = os.dbEngine;
    os.styleEngine.dbEngine = os.dbEngine;
    os.stateEngine.dbEngine = os.dbEngine;
    os.actorEngine.os = os;
    os.viewEngine.actorEngine = os.actorEngine;
    os.stateEngine.actorEngine = os.actorEngine;
  }
  /**
   * Load modules
   * @param {MaiaOS} os - OS instance
   * @param {Object} config - Boot configuration
   */
  static async _loadModules(os, config2) {
    const modules = config2.modules || ["db", "core"];
    for (const moduleName of modules) {
      try {
        if (preloadedModules[moduleName]) {
          const module2 = preloadedModules[moduleName];
          if (module2.default && typeof module2.default.register === "function") {
            await module2.default.register(os.moduleRegistry);
          } else if (typeof module2.register === "function") {
            await module2.register(os.moduleRegistry);
          }
        } else {
          await os.moduleRegistry.loadModule(moduleName);
        }
      } catch (error) {
        console.error(`Failed to load module "${moduleName}":`, error);
      }
    }
  }
  /**
   * Create an actor
   * @param {string} actorPath - Path to actor.maia file
   * @param {HTMLElement} container - Container element
   * @returns {Promise<Object>} Created actor
   */
  async createActor(actorPath, container) {
    let actorConfig;
    if (typeof actorPath === "object" && actorPath !== null) {
      actorConfig = actorPath;
    } else if (typeof actorPath === "string" && actorPath.startsWith("co_z")) {
      const actorSchemaCoId = await resolve$1(this.actorEngine.dbEngine.backend, { fromCoValue: actorPath }, { returnType: "coId" });
      const store = await this.actorEngine.dbEngine.execute({ op: "read", schema: actorSchemaCoId, key: actorPath });
      actorConfig = store.value;
    } else {
      throw new Error(`[MaiaOS] createActor expects co-id (co_z...) or config object, got: ${typeof actorPath}`);
    }
    const actor = await this.actorEngine.createActor(actorConfig, container);
    return actor;
  }
  /**
   * Load a vibe (app manifest) from file and create its root actor
   * @param {string} vibePath - Path to vibe manifest
   * @param {HTMLElement} container - Container element
   * @returns {Promise<{vibe: Object, actor: Object}>} Vibe metadata and actor instance
   */
  async loadVibe(vibePath, container) {
    const response = await fetch(vibePath);
    if (!response.ok) {
      throw new Error(`Failed to load vibe: ${vibePath}`);
    }
    const vibe = await response.json();
    const vibeDir = vibePath.substring(0, vibePath.lastIndexOf("/"));
    const actorPath = `${vibeDir}/${vibe.actor}`;
    const actor = await this.createActor(actorPath, container);
    return { vibe, actor };
  }
  /**
   * Load a vibe from account.vibes using the abstracted operations API
   * @param {string} vibeKey - Vibe key in account.vibes (e.g., "todos")
   * @param {HTMLElement} container - Container element
   * @returns {Promise<{vibe: Object, actor: Object}>} Vibe metadata and actor instance
   */
  async loadVibeFromAccount(vibeKey, container) {
    if (!this.dbEngine || !this._account) {
      throw new Error("[Kernel] Cannot load vibe from account - dbEngine or account not available");
    }
    const account = this._account;
    const accountStore = await this.dbEngine.execute({
      op: "read",
      schema: "@account",
      key: account.id
    });
    const accountData = accountStore.value;
    if (!accountData) {
      throw new Error("[Kernel] Failed to read account CoMap");
    }
    const vibesId = accountData.vibes;
    if (!vibesId || typeof vibesId !== "string" || !vibesId.startsWith("co_")) {
      throw new Error(`[Kernel] account.vibes not found. Make sure the vibe was seeded correctly. Account data: ${JSON.stringify({ id: accountData.id, hasVibes: !!accountData.vibes })}`);
    }
    const vibesStore = await this.dbEngine.execute({
      op: "read",
      schema: vibesId,
      key: vibesId
    });
    const vibesData = vibesStore.value;
    if (!vibesData || vibesData.error) {
      throw new Error(`[Kernel] account.vibes CoMap not found or error (co-id: ${vibesId}): ${vibesData?.error || "Unknown error"}. Make sure the vibe was seeded correctly.`);
    }
    console.log(`[Kernel] Looking up vibe key '${vibeKey}' in account.vibes:`, vibesData);
    const vibeCoId = vibesData[vibeKey];
    if (!vibeCoId || typeof vibeCoId !== "string" || !vibeCoId.startsWith("co_")) {
      const availableVibes = Object.keys(vibesData).filter((k) => k !== "id" && k !== "$schema" && k !== "type" && typeof vibesData[k] === "string" && vibesData[k].startsWith("co_"));
      console.error(`[Kernel] Vibe '${vibeKey}' not found in account.vibes. Available vibes:`, availableVibes);
      throw new Error(`[Kernel] Vibe '${vibeKey}' not found in account.vibes. Available vibes: ${availableVibes.join(", ")}`);
    }
    console.log(`[Kernel]  Found vibe co-id for '${vibeKey}': ${vibeCoId}`);
    return await this.loadVibeFromDatabase(vibeCoId, container, vibeKey);
  }
  /**
   * Load a vibe from database (maia.db)
   * @param {string} vibeId - Vibe ID (co-id or human-readable like "@vibe/todos")
   * @param {HTMLElement} container - Container element
   * @param {string} [vibeKey] - Optional vibe key for actor reuse tracking (e.g., 'todos')
   * @returns {Promise<{vibe: Object, actor: Object}>} Vibe metadata and actor instance
   */
  async loadVibeFromDatabase(vibeId, container, vibeKey = null) {
    if (!vibeId.startsWith("co_z")) {
      throw new Error(`[Kernel] Vibe ID must be co-id at runtime: ${vibeId}. This should have been resolved during seeding.`);
    }
    const vibeCoId = vibeId;
    const vibeStore = await this.dbEngine.execute({
      op: "read",
      schema: null,
      // No schema filter - read CoValue directly
      key: vibeCoId
    });
    const schemaStore = await this.dbEngine.execute({
      op: "schema",
      fromCoValue: vibeCoId
      //  Extracts headerMeta.$schema internally
    });
    const vibeSchemaCoId = schemaStore.value?.$id || vibeStore.value?.$schema;
    if (!vibeSchemaCoId) {
      throw new Error(`[Kernel] Failed to extract schema co-id from vibe ${vibeCoId}. Vibe must have $schema in headerMeta.`);
    }
    const store = vibeStore;
    let vibe = store.value;
    if (!vibe || vibe.error) {
      console.error(`[Kernel] Vibe not found! Trying to debug...`);
      console.error(`[Kernel] Vibe co-id: ${vibeCoId}`);
      console.error(`[Kernel] Schema co-id: ${vibeSchemaCoId}`);
      try {
        const directStore = await this.dbEngine.execute({
          op: "read",
          schema: null,
          // Read CoValue directly
          key: vibeCoId
        });
        const directValue = directStore.value;
        console.error(`[Kernel] Direct read() result:`, directValue ? "FOUND" : "NULL", directValue);
      } catch (err) {
        console.error(`[Kernel] Direct read() error:`, err);
      }
      throw new Error(`Vibe not found in database: ${vibeId} (co-id: ${vibeCoId})`);
    }
    if (vibe.properties && Array.isArray(vibe.properties)) {
      const plainVibe = {};
      for (const prop of vibe.properties) {
        plainVibe[prop.key] = prop.value;
      }
      if (vibe.id) plainVibe.id = vibe.id;
      if (vibe.$schema) plainVibe.$schema = vibe.$schema;
      if (vibe.type) plainVibe.type = vibe.type;
      vibe = plainVibe;
      console.log(`[Kernel] Converted vibe from properties array format. Actor: ${vibe.actor}`);
    }
    const schema = schemaStore.value;
    if (schema) {
      await validateAgainstSchemaOrThrow(schema, vibe, "vibe");
    }
    let actorCoId = vibe.actor;
    console.log(`[Kernel] Loading vibe '${vibeKey || vibeCoId}':`, {
      vibeCoId,
      vibeName: vibe.name || vibe.$id,
      actorCoId,
      vibeKeys: Object.keys(vibe)
    });
    if (!actorCoId) {
      throw new Error(`[MaiaOS] Vibe ${vibeId} (${vibeCoId}) does not have an 'actor' property. Vibe structure: ${JSON.stringify(Object.keys(vibe))}`);
    }
    if (!actorCoId.startsWith("co_z")) {
      throw new Error(`[Kernel] Actor ID must be co-id at runtime: ${actorCoId}. This should have been resolved during seeding.`);
    }
    console.log(`[Kernel]  Extracted actor co-id from vibe: ${actorCoId}`);
    const actorSchemaStore = await this.dbEngine.execute({
      op: "schema",
      fromCoValue: actorCoId
      //  Extracts headerMeta.$schema from actor instance
    });
    const actorSchemaCoId = actorSchemaStore.value?.$id;
    if (!actorSchemaCoId) {
      throw new Error(`[Kernel] Failed to extract schema co-id from actor ${actorCoId}. Actor must have $schema in headerMeta.`);
    }
    const actorStore = await this.dbEngine.execute({
      op: "read",
      schema: actorSchemaCoId,
      key: actorCoId
    });
    const actorExists = actorStore.value;
    if (!actorExists) {
      throw new Error(`[MaiaOS] Actor with co-id ${actorCoId} not found in database. The actor may not have been seeded correctly.`);
    }
    if (vibeKey) {
      const existingActorIds = this.actorEngine.getActorsForVibe(vibeKey);
      console.log(`[Kernel] Checking for existing actors for vibe '${vibeKey}':`, existingActorIds ? `${existingActorIds.size} found` : "none");
      if (existingActorIds && existingActorIds.size > 0) {
        const firstActorId = Array.from(existingActorIds)[0];
        const firstActor = this.actorEngine.actors.get(firstActorId);
        const existingActorCoId = firstActor?.config?.id || "unknown";
        console.log(`[Kernel] Existing actor co-id: ${existingActorCoId}, Expected: ${actorCoId}`);
        if (firstActor && firstActor.config && firstActor.config.id === actorCoId) {
          console.log(`[Kernel]  Reusing existing actors for vibe: ${vibeKey} (actor: ${actorCoId})`);
          const rootActor = await this.actorEngine.reattachActorsForVibe(vibeKey, container);
          if (rootActor) {
            console.log(` Vibe reattached: ${vibe.name}`);
            return { vibe, actor: rootActor };
          }
        } else {
          console.log(`[Kernel]  Existing actors for vibe '${vibeKey}' don't match actor ${actorCoId} (existing: ${existingActorCoId}), detaching and recreating`);
          this.actorEngine.detachActorsForVibe(vibeKey);
        }
      } else {
        console.log(`[Kernel] No existing actors for vibe '${vibeKey}', creating new actors`);
      }
    }
    const actorConfig = actorStore.value;
    const actor = await this.actorEngine.createActor(actorConfig, container, vibeKey);
    return { vibe, actor };
  }
  /**
   * Debug helper to list coIdRegistry keys (for troubleshooting)
   * @private
   */
  async _debugCoIdRegistry() {
    try {
      const transaction = this.dbEngine.backend.db.transaction(["coIdRegistry"], "readonly");
      const store = transaction.objectStore("coIdRegistry");
      const request = store.getAllKeys();
      const keys = await new Promise((resolve2, reject) => {
        request.onsuccess = () => resolve2(request.result);
        request.onerror = () => reject(request.error);
      });
      return keys.filter((k) => k && (k.includes("actor") || k.includes("agent")));
    } catch (error) {
      return [`Error: ${error.message}`];
    }
  }
  /**
   * Get actor by ID
   * @param {string} actorId - Actor ID
   * @returns {Object|null} Actor instance
   */
  getActor(actorId) {
    return this.actorEngine.getActor(actorId);
  }
  /**
   * Send message to actor
   * @param {string} actorId - Target actor ID
   * @param {Object} message - Message object
   */
  sendMessage(actorId, message) {
    this.actorEngine.sendMessage(actorId, message);
  }
  /**
   * Execute database operation (internal use + @db tool)
   * @param {Object} payload - Operation payload {op: 'query|create|update|delete|seed', ...}
   * @returns {Promise<any>} Operation result
   */
  async db(payload) {
    return await this.dbEngine.execute(payload);
  }
  /**
   * Get sync domain (single source of truth)
   * Returns the sync domain configured during boot, or null if not set
   * @returns {string|null} Sync domain or null
   */
  getSyncDomain() {
    return this._syncDomain;
  }
  /**
   * Expose engines for debugging
   */
  getEngines() {
    return {
      actorEngine: this.actorEngine,
      viewEngine: this.viewEngine,
      styleEngine: this.styleEngine,
      stateEngine: this.stateEngine,
      toolEngine: this.toolEngine,
      dbEngine: this.dbEngine,
      evaluator: this.evaluator,
      moduleRegistry: this.moduleRegistry
    };
  }
}
const BUFFER_LIMIT = 1e5;
const BUFFER_LIMIT_POLLING_INTERVAL = 10;
function isWebSocketOpen(websocket) {
  return websocket.readyState === 1;
}
function hasWebSocketTooMuchBufferedData(websocket) {
  return websocket.bufferedAmount > BUFFER_LIMIT && isWebSocketOpen(websocket);
}
function waitForWebSocketOpen(websocket) {
  return new Promise((resolve2) => {
    if (websocket.readyState === 1) {
      resolve2();
    } else {
      websocket.addEventListener("open", () => resolve2(), { once: true });
    }
  });
}
async function waitForWebSocketBufferedAmount(websocket) {
  while (hasWebSocketTooMuchBufferedData(websocket)) {
    await new Promise((resolve2) => setTimeout(resolve2, BUFFER_LIMIT_POLLING_INTERVAL));
  }
}
const { CO_VALUE_PRIORITY, getContentMessageSize: getContentMessageSize$1, WEBSOCKET_CONFIG } = cojsonInternals;
class BatchedOutgoingMessages {
  constructor(websocket, batching, peerRole, meta, meter) {
    this.websocket = websocket;
    this.batching = batching;
    this.meta = meta;
    this.backlog = [];
    this.processing = false;
    this.closed = false;
    this.closeListeners = /* @__PURE__ */ new Set();
    this.egressBytesCounter = (meter ?? metrics.getMeter("cojson-transport-ws")).createCounter("jazz.usage.egress", {
      description: "Total egress bytes",
      unit: "bytes",
      valueType: ValueType.INT
    });
    this.queue = new PriorityBasedMessageQueue(CO_VALUE_PRIORITY.HIGH, "outgoing", {
      peerRole
    });
    this.egressBytesCounter.add(0, this.meta);
  }
  push(msg) {
    if (msg === "Disconnected") {
      this.close();
      return;
    }
    if (this.closed) {
      return;
    }
    if (this.processing) {
      this.queue.push(msg);
      return;
    }
    if (isWebSocketOpen(this.websocket) && !hasWebSocketTooMuchBufferedData(this.websocket)) {
      this.processMessage(msg, true);
      return;
    }
    this.queue.push(msg);
    this.processQueue().catch((e) => {
      logger.error("Error while processing sendMessage queue", { err: e });
    });
  }
  async processQueue() {
    const { websocket } = this;
    this.processing = true;
    let msg = this.queue.pull();
    while (msg) {
      if (this.closed) {
        return;
      }
      if (!isWebSocketOpen(websocket)) {
        await waitForWebSocketOpen(websocket);
      }
      if (hasWebSocketTooMuchBufferedData(websocket)) {
        await waitForWebSocketBufferedAmount(websocket);
      }
      if (isWebSocketOpen(websocket)) {
        this.processMessage(msg);
        msg = this.queue.pull();
      }
    }
    this.sendMessagesInBulk();
    this.processing = false;
  }
  processMessage(msg, skipBatching = false) {
    if (msg.action === "content") {
      this.egressBytesCounter.add(getContentMessageSize$1(msg), this.meta);
    }
    const stringifiedMsg = this.serializeMessage(msg);
    if (!this.batching || skipBatching) {
      this.websocket.send(stringifiedMsg);
      return;
    }
    const msgSize = stringifiedMsg.length;
    const newBacklogSize = this.backlog.length + msgSize;
    if (this.backlog.length > 0 && newBacklogSize > WEBSOCKET_CONFIG.MAX_OUTGOING_MESSAGES_CHUNK_BYTES) {
      this.sendMessagesInBulk();
    }
    this.appendMessage(stringifiedMsg);
    if (msgSize >= WEBSOCKET_CONFIG.MAX_OUTGOING_MESSAGES_CHUNK_BYTES) {
      this.sendMessagesInBulk();
    }
  }
  serializeMessage(msg) {
    return JSON.stringify(msg);
  }
  appendMessage(msg) {
    this.backlog.push(msg);
  }
  sendMessagesInBulk() {
    if (this.backlog.length > 0 && isWebSocketOpen(this.websocket)) {
      this.websocket.send(this.backlog.join("\n"));
      this.backlog.length = 0;
    }
  }
  drain() {
    while (this.queue.pull()) {
    }
  }
  setBatching(enabled) {
    this.batching = enabled;
  }
  onClose(callback) {
    this.closeListeners.add(callback);
  }
  close() {
    if (this.closed) {
      return;
    }
    let msg = this.queue.pull();
    while (msg) {
      this.processMessage(msg);
      msg = this.queue.pull();
    }
    this.closed = true;
    this.sendMessagesInBulk();
    for (const listener of this.closeListeners) {
      listener();
    }
    this.closeListeners.clear();
  }
}
function deserializeMessages(messages) {
  if (typeof messages !== "string") {
    return {
      ok: false,
      error: new Error("Expected a string")
    };
  }
  try {
    return {
      ok: true,
      messages: messages.split("\n").map((msg) => JSON.parse(msg))
    };
  } catch (e) {
    logger.error("Error while deserializing messages", { err: e });
    return {
      ok: false,
      error: e
    };
  }
}
const { ConnectedPeerChannel: ConnectedPeerChannel2, getContentMessageSize } = cojsonInternals;
function createPingTimeoutListener(enabled, timeout, callback) {
  if (!enabled) {
    return {
      reset() {
      },
      clear() {
      }
    };
  }
  let pingTimeout = null;
  return {
    reset() {
      pingTimeout && clearTimeout(pingTimeout);
      pingTimeout = setTimeout(() => {
        callback();
      }, timeout);
    },
    clear() {
      pingTimeout && clearTimeout(pingTimeout);
    }
  };
}
function createClosedEventEmitter(callback = () => {
}) {
  let disconnected = false;
  return () => {
    if (disconnected)
      return;
    disconnected = true;
    callback();
  };
}
function createWebSocketPeer({ id: id2, websocket, role, expectPings = true, batchingByDefault = true, deletePeerStateOnClose = false, pingTimeout = 1e4, onSuccess, onClose, meter, meta }) {
  const ingressBytesCounter = (meter ?? metrics.getMeter("cojson-transport-ws")).createCounter("jazz.usage.ingress", {
    description: "Total ingress bytes from peer",
    unit: "bytes",
    valueType: ValueType.INT
  });
  ingressBytesCounter.add(0, meta);
  const incoming = new ConnectedPeerChannel2();
  const emitClosedEvent = createClosedEventEmitter(onClose);
  function cleanup() {
    websocket.removeEventListener("message", handleIncomingMsg);
    websocket.removeEventListener("close", handleClose);
    websocket.removeEventListener("error", handleError2);
    pingTimeoutListener.clear();
    outgoing.drain();
  }
  function handleClose() {
    incoming.push("Disconnected");
    emitClosedEvent();
    cleanup();
  }
  function handleError2(err) {
    if (err instanceof Error && err.message) {
      logger.warn("WebSocket error", { err });
    }
    handleClose();
  }
  websocket.addEventListener("close", handleClose);
  websocket.addEventListener("error", handleError2);
  const pingTimeoutListener = createPingTimeoutListener(expectPings, pingTimeout, () => {
    handleClose();
    logger.warn("Ping timeout from peer", {
      peerId: id2,
      peerRole: role
    });
  });
  const outgoing = new BatchedOutgoingMessages(websocket, batchingByDefault, role, meta, meter);
  let isFirstMessage = true;
  function handleIncomingMsg(event) {
    pingTimeoutListener.reset();
    if (event.data === "") {
      return;
    }
    const result = deserializeMessages(event.data);
    if (!result.ok) {
      logger.warn("Error while deserializing messages", { err: result.error });
      return;
    }
    if (isFirstMessage) {
      onSuccess?.();
      isFirstMessage = false;
    }
    const { messages } = result;
    if (messages.length > 1) {
      outgoing.setBatching(true);
    }
    for (const msg of messages) {
      if (msg && "action" in msg) {
        incoming.push(msg);
        if (msg.action === "content") {
          ingressBytesCounter.add(getContentMessageSize(msg), meta);
        }
      }
    }
  }
  websocket.addEventListener("message", handleIncomingMsg);
  outgoing.onClose(() => {
    cleanup();
    emitClosedEvent();
    if (websocket.readyState === 0) {
      websocket.addEventListener("open", function handleClose2() {
        websocket.close();
      }, { once: true });
    } else if (websocket.readyState === 1) {
      websocket.close();
    }
  });
  return {
    id: id2,
    incoming,
    outgoing,
    role,
    persistent: !deletePeerStateOnClose
  };
}
class WebSocketPeerWithReconnection {
  constructor(opts) {
    this.enabled = false;
    this.closed = true;
    this.connected = false;
    this.currentPeer = void 0;
    this.unsubscribeNetworkChange = void 0;
    this.reconnectionAttempts = 0;
    this.onConnectionChangeListeners = /* @__PURE__ */ new Set();
    this.waitUntilConnected = async () => {
      if (this.closed) {
        return new Promise((resolve2) => {
          const listener = (connected) => {
            if (connected) {
              resolve2();
              this.onConnectionChangeListeners.delete(listener);
            }
          };
          this.onConnectionChangeListeners.add(listener);
        });
      }
    };
    this.subscribe = (listener) => {
      this.onConnectionChangeListeners.add(listener);
      listener(!this.closed);
    };
    this.unsubscribe = (listener) => {
      this.onConnectionChangeListeners.delete(listener);
    };
    this.startConnection = async () => {
      if (!this.enabled)
        return;
      if (this.currentPeer) {
        this.removePeer(this.currentPeer);
        this.currentPeer.outgoing.close();
        this.reconnectionAttempts++;
        const timeout = this.reconnectionTimeout * this.reconnectionAttempts;
        logger.debug(`Websocket disconnected, trying to reconnect in ${timeout}ms`);
        await this.waitForOnline(timeout);
      }
      if (!this.enabled)
        return;
      this.currentPeer = createWebSocketPeer({
        websocket: new this.WebSocketConstructor(this.peer),
        pingTimeout: this.pingTimeout,
        id: this.peer,
        role: "server",
        onClose: () => {
          this.closed = true;
          this.connected = false;
          for (const listener of this.onConnectionChangeListeners) {
            listener(false);
          }
          this.startConnection();
        },
        onSuccess: () => {
          this.closed = false;
          this.connected = true;
          for (const listener of this.onConnectionChangeListeners) {
            listener(true);
          }
          logger.debug("Websocket connection successful");
          this.reconnectionAttempts = 0;
        }
      });
      this.addPeer(this.currentPeer);
    };
    this.enable = () => {
      if (this.enabled)
        return;
      this.connected = true;
      this.enabled = true;
      this.startConnection();
    };
    this.disable = () => {
      if (!this.enabled)
        return;
      this.enabled = false;
      this.reconnectionAttempts = 0;
      this.unsubscribeNetworkChange?.();
      this.unsubscribeNetworkChange = void 0;
      if (this.currentPeer) {
        this.removePeer(this.currentPeer);
        this.currentPeer.outgoing.close();
        this.currentPeer = void 0;
      }
    };
    this.peer = opts.peer;
    this.reconnectionTimeout = opts.reconnectionTimeout || 500;
    this.addPeer = opts.addPeer;
    this.removePeer = opts.removePeer;
    this.WebSocketConstructor = opts.WebSocketConstructor || WebSocket;
    this.pingTimeout = opts.pingTimeout || 1e4;
  }
  // Basic implementation for environments that don't support network change events (e.g. Node.js)
  // Needs to be extended to handle platform specific APIs
  onNetworkChange(callback) {
    return () => {
    };
  }
  waitForOnline(timeout) {
    return new Promise((resolve2) => {
      const unsubscribeNetworkChange = this.onNetworkChange((connected) => {
        if (connected) {
          handleTimeoutOrOnline();
        }
      });
      function handleTimeoutOrOnline() {
        clearTimeout(timer);
        unsubscribeNetworkChange?.();
        resolve2();
      }
      const timer = setTimeout(handleTimeoutOrOnline, timeout);
    });
  }
}
async function isPRFSupported() {
  if (!window.PublicKeyCredential) {
    throw new Error(
      "WebAuthn not supported. Please use:\n- Chrome on macOS/Linux/Windows 11\n- Safari on macOS 13+/iOS 16+\nFirefox and Windows 10 are NOT supported."
    );
  }
  try {
    const available = await PublicKeyCredential.isConditionalMediationAvailable?.();
    if (!available) {
      throw new Error(
        "WebAuthn PRF not supported. Please use:\n- Chrome on macOS/Linux/Windows 11\n- Safari on macOS 13+/iOS 16+\nFirefox and Windows 10 are NOT supported."
      );
    }
    return true;
  } catch (error) {
    throw new Error(
      "WebAuthn PRF not supported. Please use:\n- Chrome on macOS/Linux/Windows 11\n- Safari on macOS 13+/iOS 16+\nFirefox and Windows 10 are NOT supported."
    );
  }
}
async function requirePRFSupport() {
  await isPRFSupported();
}
function arrayBufferToBase64(buffer) {
  const bytes = new Uint8Array(buffer);
  let binary = "";
  for (let i = 0; i < bytes.byteLength; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}
function stringToUint8Array(str) {
  return new TextEncoder().encode(str);
}
async function evaluatePRF({ salt, rpId = window.location.hostname }) {
  try {
    const assertion = await navigator.credentials.get({
      publicKey: {
        challenge: crypto.getRandomValues(new Uint8Array(32)),
        rpId,
        userVerification: "required",
        authenticatorAttachment: "platform",
        // ONLY platform authenticators!
        // WebAuthn Level 3: Hint the browser UI to show platform authenticator
        hints: ["client-device"],
        // Prioritize local device, suppress QR code UI
        extensions: {
          prf: {
            eval: {
              first: salt
              // The salt we want to evaluate
            }
          }
        }
      },
      mediation: "optional"
      // Show passkey picker
    });
    if (!assertion) {
      throw new Error("No passkey selected");
    }
    const prfResults = assertion.getClientExtensionResults()?.prf;
    if (!prfResults?.results?.first) {
      throw new Error("PRF evaluation failed: no results returned");
    }
    return {
      prfOutput: new Uint8Array(prfResults.results.first),
      credentialId: assertion.rawId
    };
  } catch (error) {
    console.error("PRF evaluation error:", error);
    throw new Error(`Failed to evaluate PRF: ${error.message}`);
  }
}
async function createPasskeyWithPRF({ name, userId, rpId = window.location.hostname, salt }) {
  try {
    const prfConfig = salt ? {
      prf: {
        eval: {
          first: salt
          // Evaluate PRF during creation!
        }
      }
    } : {
      prf: {}
      // Just enable PRF without evaluation
    };
    const credential = await navigator.credentials.create({
      publicKey: {
        challenge: crypto.getRandomValues(new Uint8Array(32)),
        rp: {
          name: "Maia OS",
          id: rpId
        },
        user: {
          id: userId,
          name,
          displayName: name
        },
        pubKeyCredParams: [
          { type: "public-key", alg: -7 },
          // ES256
          { type: "public-key", alg: -257 }
          // RS256
        ],
        authenticatorSelection: {
          authenticatorAttachment: "platform",
          // ONLY platform authenticators
          residentKey: "required",
          userVerification: "required"
        },
        // WebAuthn Level 3: Hint the browser UI to show platform authenticator first
        hints: ["client-device"],
        // Prioritize local device authenticator UI
        extensions: prfConfig
      }
    });
    const extensionResults = credential.getClientExtensionResults();
    if (!extensionResults.prf?.enabled) {
      throw new Error("PRF extension not enabled on credential");
    }
    const prfOutput = extensionResults.prf?.results?.first ? new Uint8Array(extensionResults.prf.results.first) : null;
    return {
      credentialId: credential.rawId,
      response: credential.response,
      prfOutput
      // May be null if salt wasn't provided
    };
  } catch (error) {
    console.error("Passkey creation error:", error);
    throw new Error(`Failed to create passkey: ${error.message}`);
  }
}
const DEFAULT_TX_STORES = [
  "coValues",
  "sessions",
  "transactions",
  "signatureAfter",
  "deletedCoValues"
];
class CoJsonIDBTransaction {
  constructor(db, storeNames = DEFAULT_TX_STORES) {
    this.db = db;
    this.storeNames = storeNames;
    this.pendingRequests = [];
    this.rejectHandlers = [];
    this.id = Math.random();
    this.running = false;
    this.failed = false;
    this.done = false;
    this.refresh();
  }
  refresh() {
    this.tx = this.db.transaction(this.storeNames, "readwrite");
    this.tx.oncomplete = () => {
      this.done = true;
    };
    this.tx.onabort = () => {
      this.done = true;
    };
  }
  rollback() {
    this.tx.abort();
  }
  getObjectStore(name) {
    try {
      return this.tx.objectStore(name);
    } catch (error) {
      this.refresh();
      return this.tx.objectStore(name);
    }
  }
  pushRequest(handler) {
    const next2 = () => {
      const next3 = this.pendingRequests.shift();
      if (next3) {
        next3(this);
      } else {
        this.running = false;
        this.done = true;
      }
    };
    if (this.running) {
      return new Promise((resolve2, reject) => {
        this.rejectHandlers.push(reject);
        this.pendingRequests.push(async () => {
          try {
            const result = await handler(this, next2);
            resolve2(result);
          } catch (error) {
            reject(error);
          }
        });
      });
    }
    this.running = true;
    return handler(this, next2);
  }
  handleRequest(handler) {
    return this.pushRequest((txEntry, next2) => {
      return new Promise((resolve2, reject) => {
        const request = handler(txEntry);
        request.onerror = () => {
          this.failed = true;
          this.tx.abort();
          console.error(request.error);
          reject(request.error);
          for (const handler2 of this.rejectHandlers) {
            handler2();
          }
        };
        request.onsuccess = () => {
          resolve2(request.result);
          next2();
        };
      });
    });
  }
  commit() {
    if (!this.done) {
      this.tx.commit();
    }
  }
}
function queryIndexedDbStore(db, storeName, callback) {
  return new Promise((resolve2, reject) => {
    const tx = db.transaction(storeName, "readonly");
    const request = callback(tx.objectStore(storeName));
    request.onerror = () => {
      reject(request.error);
    };
    request.onsuccess = () => {
      resolve2(request.result);
      tx.commit();
    };
  });
}
function putIndexedDbStore(db, storeName, value) {
  return new Promise((resolve2, reject) => {
    const tx = db.transaction(storeName, "readwrite");
    const request = tx.objectStore(storeName).put(value);
    request.onerror = () => {
      reject(request.error);
    };
    request.onsuccess = () => {
      resolve2(request.result);
      tx.commit();
    };
  });
}
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _IDBTransaction_instances, _IDBTransaction_deleteAllBySesPrefix;
class IDBTransaction {
  constructor(tx) {
    _IDBTransaction_instances.add(this);
    this.tx = tx;
  }
  async run(handler) {
    return this.tx.handleRequest(handler);
  }
  async getSingleCoValueSession(coValueRowId, sessionID) {
    return this.run((tx) => tx.getObjectStore("sessions").index("uniqueSessions").get([coValueRowId, sessionID]));
  }
  async markCoValueAsDeleted(id2) {
    await this.run((tx) => tx.getObjectStore("deletedCoValues").put({
      coValueID: id2,
      status: "pending"
    }));
  }
  async deleteCoValueContent(coValue) {
    const coValueRowID = coValue.rowID;
    const sessions = await this.run((tx) => tx.getObjectStore("sessions").index("sessionsByCoValue").getAll(coValueRowID));
    const sessionsToDelete = sessions.filter((s) => !s.sessionID.endsWith("$")).map((s) => s.rowID);
    const ops = [];
    for (const sessionRowID of sessionsToDelete) {
      ops.push(__classPrivateFieldGet(this, _IDBTransaction_instances, "m", _IDBTransaction_deleteAllBySesPrefix).call(this, "transactions", sessionRowID), __classPrivateFieldGet(this, _IDBTransaction_instances, "m", _IDBTransaction_deleteAllBySesPrefix).call(this, "signatureAfter", sessionRowID), this.run((tx) => tx.getObjectStore("sessions").delete(sessionRowID)));
    }
    ops.push(this.run((tx) => tx.getObjectStore("deletedCoValues").put({
      coValueID: coValue.id,
      status: "done"
    })));
    await Promise.all(ops);
  }
  async addSessionUpdate({ sessionUpdate, sessionRow }) {
    return this.run((tx) => tx.getObjectStore("sessions").put(sessionRow?.rowID ? {
      rowID: sessionRow.rowID,
      ...sessionUpdate
    } : sessionUpdate));
  }
  async addTransaction(sessionRowID, idx, newTransaction) {
    await this.run((tx) => tx.getObjectStore("transactions").add({
      ses: sessionRowID,
      idx,
      tx: newTransaction
    }));
  }
  async addSignatureAfter({ sessionRowID, idx, signature }) {
    return this.run((tx) => tx.getObjectStore("signatureAfter").put({
      ses: sessionRowID,
      idx,
      signature
    }));
  }
  /**
   * Get an unsynced CoValue record by coValueId and peerId.
   */
  async getUnsyncedCoValueRecord(coValueId, peerId) {
    return this.run((tx) => tx.getObjectStore("unsyncedCoValues").index("uniqueUnsyncedCoValues").get([coValueId, peerId]));
  }
  /**
   * Get all unsynced CoValue records for a given coValueId.
   */
  async getAllUnsyncedCoValueRecords(coValueId) {
    return this.run((tx) => tx.getObjectStore("unsyncedCoValues").index("byCoValueId").getAll(coValueId));
  }
  /**
   * Delete an unsynced CoValue record by rowID.
   */
  async deleteUnsyncedCoValueRecord(rowID) {
    await this.run((tx) => tx.getObjectStore("unsyncedCoValues").delete(rowID));
  }
  /**
   * Insert or update an unsynced CoValue record.
   */
  async putUnsyncedCoValueRecord(record) {
    await this.run((tx) => tx.getObjectStore("unsyncedCoValues").put(record));
  }
}
_IDBTransaction_instances = /* @__PURE__ */ new WeakSet(), _IDBTransaction_deleteAllBySesPrefix = async function _IDBTransaction_deleteAllBySesPrefix2(storeName, sesRowID) {
  const range = IDBKeyRange.bound([sesRowID, 0], [sesRowID, Number.POSITIVE_INFINITY]);
  const keys = await this.run((tx) => tx.getObjectStore(storeName).getAllKeys(range));
  for (const key of keys) {
    await this.run((tx) => tx.getObjectStore(storeName).delete(key));
  }
};
class IDBClient {
  constructor(db) {
    this.db = db;
  }
  async getCoValue(coValueId) {
    return queryIndexedDbStore(this.db, "coValues", (store) => store.index("coValuesById").get(coValueId));
  }
  async getCoValueRowID(coValueId) {
    return this.getCoValue(coValueId).then((row) => row?.rowID);
  }
  async getCoValueSessions(coValueRowId) {
    return queryIndexedDbStore(this.db, "sessions", (store) => store.index("sessionsByCoValue").getAll(coValueRowId));
  }
  async getNewTransactionInSession(sessionRowId, fromIdx, toIdx) {
    return queryIndexedDbStore(this.db, "transactions", (store) => store.getAll(IDBKeyRange.bound([sessionRowId, fromIdx], [sessionRowId, toIdx])));
  }
  async getSignatures(sessionRowId, firstNewTxIdx) {
    return queryIndexedDbStore(this.db, "signatureAfter", (store) => store.getAll(IDBKeyRange.bound([sessionRowId, firstNewTxIdx], [sessionRowId, Number.POSITIVE_INFINITY])));
  }
  async upsertCoValue(id2, header) {
    if (!header) {
      return this.getCoValueRowID(id2);
    }
    return putIndexedDbStore(this.db, "coValues", {
      id: id2,
      header
    }).catch(() => this.getCoValueRowID(id2));
  }
  async getAllCoValuesWaitingForDelete() {
    const entries = await queryIndexedDbStore(this.db, "deletedCoValues", (store) => store.index("deletedCoValuesByStatus").getAll("pending"));
    return entries.map((e) => e.coValueID);
  }
  async transaction(operationsCallback, storeNames) {
    const tx = new CoJsonIDBTransaction(this.db, storeNames);
    try {
      await operationsCallback(new IDBTransaction(tx));
      tx.commit();
    } catch (error) {
      tx.rollback();
    }
  }
  async trackCoValuesSyncState(updates) {
    if (updates.length === 0) {
      return;
    }
    await this.transaction(async (tx) => {
      await Promise.all(updates.map(async (update2) => {
        const record = await tx.getUnsyncedCoValueRecord(update2.id, update2.peerId);
        if (update2.synced) {
          if (record) {
            await tx.deleteUnsyncedCoValueRecord(record.rowID);
          }
        } else {
          await tx.putUnsyncedCoValueRecord(record ? {
            rowID: record.rowID,
            coValueId: update2.id,
            peerId: update2.peerId
          } : {
            coValueId: update2.id,
            peerId: update2.peerId
          });
        }
      }));
    }, ["unsyncedCoValues"]);
  }
  async eraseCoValueButKeepTombstone(coValueID) {
    const coValue = await this.getCoValue(coValueID);
    if (!coValue) {
      console.warn(`CoValue ${coValueID} not found, skipping deletion`);
      return;
    }
    await this.transaction((tx) => tx.deleteCoValueContent(coValue));
  }
  async getUnsyncedCoValueIDs() {
    const records = await queryIndexedDbStore(this.db, "unsyncedCoValues", (store) => store.getAll());
    const uniqueIds = /* @__PURE__ */ new Set();
    for (const record of records) {
      uniqueIds.add(record.coValueId);
    }
    return Array.from(uniqueIds);
  }
  async stopTrackingSyncState(id2) {
    await this.transaction(async (tx) => {
      const idbTx = tx;
      const records = await idbTx.getAllUnsyncedCoValueRecords(id2);
      await Promise.all(records.map((record) => idbTx.deleteUnsyncedCoValueRecord(record.rowID)));
    }, ["unsyncedCoValues"]);
  }
  async getCoValueKnownState(coValueId) {
    const coValueRow = await this.getCoValue(coValueId);
    if (!coValueRow) {
      return void 0;
    }
    const sessions = await this.getCoValueSessions(coValueRow.rowID);
    const knownState = {
      id: coValueId,
      header: true,
      sessions: {}
    };
    for (const session of sessions) {
      knownState.sessions[session.sessionID] = session.lastIdx;
    }
    return knownState;
  }
}
let DATABASE_NAME = "jazz-storage";
async function getIndexedDBStorage(name = DATABASE_NAME) {
  const dbPromise = new Promise((resolve2, reject) => {
    const request = indexedDB.open(name, 6);
    request.onerror = () => {
      reject(request.error);
    };
    request.onsuccess = () => {
      resolve2(request.result);
    };
    request.onupgradeneeded = async (ev) => {
      const db2 = request.result;
      if (ev.oldVersion === 0) {
        const coValues = db2.createObjectStore("coValues", {
          autoIncrement: true,
          keyPath: "rowID"
        });
        coValues.createIndex("coValuesById", "id", {
          unique: true
        });
        const sessions = db2.createObjectStore("sessions", {
          autoIncrement: true,
          keyPath: "rowID"
        });
        sessions.createIndex("sessionsByCoValue", "coValue");
        sessions.createIndex("uniqueSessions", ["coValue", "sessionID"], {
          unique: true
        });
        db2.createObjectStore("transactions", {
          keyPath: ["ses", "idx"]
        });
      }
      if (ev.oldVersion <= 1) {
        db2.createObjectStore("signatureAfter", {
          keyPath: ["ses", "idx"]
        });
      }
      if (ev.oldVersion <= 4) {
        const unsyncedCoValues = db2.createObjectStore("unsyncedCoValues", {
          autoIncrement: true,
          keyPath: "rowID"
        });
        unsyncedCoValues.createIndex("byCoValueId", "coValueId");
        unsyncedCoValues.createIndex("uniqueUnsyncedCoValues", ["coValueId", "peerId"], {
          unique: true
        });
      }
      if (ev.oldVersion <= 5) {
        const deletedCoValues = db2.createObjectStore("deletedCoValues", {
          keyPath: "coValueID"
        });
        deletedCoValues.createIndex("deletedCoValuesByStatus", "status", {
          unique: false
        });
      }
    };
  });
  const db = await dbPromise;
  return new StorageApiAsync(new IDBClient(db));
}
async function getStorage() {
  try {
    const storage = await getIndexedDBStorage();
    console.log(" [STORAGE] IndexedDB initialized");
    return storage;
  } catch (error) {
    console.warn("  [STORAGE] IndexedDB unavailable, running without persistence:", error);
    console.warn("   This may happen in incognito mode or unsupported browsers");
    return void 0;
  }
}
const __vite_import_meta_env__ = {};
const { accountHeaderForInitialAgentSecret, idforHeader } = cojsonInternals;
let syncState = {
  connected: false,
  syncing: false,
  error: null
};
const syncStateListeners = /* @__PURE__ */ new Set();
function subscribeSyncState(listener) {
  syncStateListeners.add(listener);
  listener(syncState);
  return () => syncStateListeners.delete(listener);
}
function notifySyncStateChange() {
  for (const listener of syncStateListeners) {
    listener(syncState);
  }
}
function setupSyncPeers(syncDomain = null) {
  const isDev = window.location.hostname === "localhost";
  const apiDomain = syncDomain || typeof window !== "undefined" && window.__PUBLIC_API_DOMAIN__ || __vite_import_meta_env__?.PUBLIC_API_DOMAIN;
  let syncServerUrl;
  if (isDev) {
    const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
    syncServerUrl = `${protocol}//${window.location.host}/sync`;
  } else if (apiDomain) {
    const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
    syncServerUrl = `${protocol}//${apiDomain}/sync`;
  } else {
    console.warn(" [SYNC] Sync domain not set! Falling back to same origin. Sync may not work.");
    const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
    syncServerUrl = `${protocol}//${window.location.host}/sync`;
  }
  console.log(` [SYNC] Connecting to sync server: ${syncServerUrl}`);
  if (isDev) {
    console.log(`   Mode: Development (using Vite proxy)`);
  } else {
    console.log(`   Sync Domain: ${apiDomain || "(not set - using same origin fallback)"}`);
    console.log(`   Source: ${syncDomain ? "kernel" : typeof window !== "undefined" && window.__PUBLIC_API_DOMAIN__ ? "runtime env" : __vite_import_meta_env__?.PUBLIC_API_DOMAIN ? "build-time env" : "fallback"}`);
  }
  let node = void 0;
  const peers = [];
  let connectionTimeout = null;
  let websocketConnected = false;
  let websocketConnectedResolve = null;
  const websocketConnectedPromise = new Promise((resolve2) => {
    websocketConnectedResolve = resolve2;
  });
  const wsPeer = new WebSocketPeerWithReconnection({
    peer: syncServerUrl,
    reconnectionTimeout: 5e3,
    addPeer: (peer) => {
      if (connectionTimeout) {
        clearTimeout(connectionTimeout);
        connectionTimeout = null;
      }
      console.log(" [SYNC] Peer added to array");
      peers.push(peer);
      if (node) {
        node.syncManager.addPeer(peer);
      }
    },
    removePeer: (peer) => {
      const index2 = peers.indexOf(peer);
      if (index2 > -1) {
        peers.splice(index2, 1);
      }
      if (syncState.connected) {
        console.warn(" [SYNC] Peer removed, connection lost");
      }
      websocketConnected = false;
      syncState = { connected: false, syncing: false, error: "Disconnected" };
      notifySyncStateChange();
    }
  });
  wsPeer.subscribe((connected) => {
    if (connected && !websocketConnected) {
      console.log(" [SYNC] WebSocket connection successful");
      websocketConnected = true;
      syncState = { connected: true, syncing: true, error: null };
      notifySyncStateChange();
      if (websocketConnectedResolve) {
        websocketConnectedResolve();
        websocketConnectedResolve = null;
      }
    } else if (!connected && websocketConnected) {
      console.warn(" [SYNC] WebSocket connection lost");
      websocketConnected = false;
      syncState = { connected: false, syncing: false, error: "Offline" };
      notifySyncStateChange();
    }
  });
  connectionTimeout = setTimeout(() => {
    if (!syncState.connected) {
      console.error(` [SYNC] Connection timeout after 10s. Check:`);
      console.error(`   1. Server service is running: curl https://${apiDomain || window.location.hostname}/health`);
      console.error(`   2. PUBLIC_API_DOMAIN is set correctly: ${apiDomain || "NOT SET"}`);
      console.error(`   3. WebSocket URL: ${syncServerUrl}`);
      syncState = { connected: false, syncing: false, error: "Connection timeout" };
      notifySyncStateChange();
    }
  }, 1e4);
  wsPeer.enable();
  return {
    peers,
    wsPeer,
    // Wait for WebSocket to be actually connected (not just peer object created)
    waitForPeer: () => {
      return new Promise((resolve2) => {
        if (websocketConnected && peers.length > 0) {
          resolve2(true);
          return;
        }
        let resolved = false;
        const timeout = setTimeout(() => {
          if (!resolved) {
            resolved = true;
            resolve2(false);
          }
        }, 1e4);
        websocketConnectedPromise.then(() => {
          if (!resolved && peers.length > 0) {
            resolved = true;
            clearTimeout(timeout);
            resolve2(true);
          }
        }).catch(() => {
          if (!resolved) {
            resolved = true;
            clearTimeout(timeout);
            resolve2(false);
          }
        });
      });
    },
    setNode: (n) => {
      node = n;
      if (peers.length > 0) {
        console.log(`[SYNC] Adding ${peers.length} queued peer(s) to node`);
        for (const peer of peers) {
          node.syncManager.addPeer(peer);
        }
      }
    }
  };
}
async function signUpWithPasskey({ name = "maia", salt = "maia.city" } = {}) {
  console.log(" Starting passkey sign-up (TRUE single-passkey flow)...");
  console.log("    ONE passkey, ONE biometric prompt, ZERO storage!");
  await requirePRFSupport();
  const saltBytes = stringToUint8Array(salt);
  const crypto2 = await WasmCrypto.create();
  console.log(" Step 1/3: Creating passkey and deriving secret...");
  const { credentialId, prfOutput } = await createPasskeyWithPRF({
    name,
    userId: globalThis.crypto.getRandomValues(new Uint8Array(32)),
    // Random userID - we don't store anything!
    salt: saltBytes
  });
  if (!prfOutput) {
    throw new Error("PRF evaluation failed");
  }
  console.log(" Passkey created and secret derived!");
  console.log("    AccountID will be re-computed on every login!");
  console.log(" Step 2/3: Computing accountID deterministically...");
  const agentSecret = crypto2.agentSecretFromSecretSeed(prfOutput);
  const accountHeader = accountHeaderForInitialAgentSecret(agentSecret, crypto2);
  const computedAccountID = idforHeader(accountHeader, crypto2);
  console.log(" AccountID computed:", computedAccountID);
  console.log("    Chain: PRF  agentSecret  header  accountID");
  console.log("     Same passkey + salt = same accountID (always!)");
  console.log(" Step 3/3: Creating account...");
  const { LocalNode: LocalNode2 } = await Promise.resolve().then(() => index$3);
  const storage = await getStorage();
  let syncSetup = null;
  {
    console.log(" [SYNC] Setting up self-hosted sync...");
    syncSetup = setupSyncPeers();
  }
  const { schemaMigration: schemaMigration2 } = await Promise.resolve().then(() => index$1);
  const result = await LocalNode2.withNewlyCreatedAccount({
    creationProps: { name },
    crypto: crypto2,
    initialAgentSecret: agentSecret,
    peers: syncSetup ? syncSetup.peers : [],
    // Pass peers array directly!
    storage,
    // Pass storage directly! (jazz-tools pattern)
    migration: schemaMigration2
    // Schema migration: profile + hierarchical structure
  });
  if (syncSetup) {
    syncSetup.setNode(result.node);
  }
  const account = result.node.expectCurrentAccount("signUpWithPasskey");
  const createdAccountID = account.id;
  if (createdAccountID !== computedAccountID) {
    throw new Error(
      `CRITICAL: AccountID mismatch!
  Computed: ${computedAccountID}
  Created:  ${createdAccountID}
This should never happen - deterministic computation failed!`
    );
  }
  if (!syncSetup) {
    console.warn("  [SYNC] Sync service unavailable - account won't sync to cloud!");
  }
  return {
    accountID: createdAccountID,
    agentSecret,
    node: result.node,
    account,
    credentialId: arrayBufferToBase64(credentialId)
  };
}
async function signInWithPasskey({ salt = "maia.city" } = {}) {
  console.log(" Starting passkey sign-in (TRUE single-passkey flow)...");
  console.log("    ONE biometric prompt, ZERO storage reads!");
  await requirePRFSupport();
  const saltBytes = stringToUint8Array(salt);
  console.log(" Authenticating and re-evaluating PRF...");
  const { prfOutput } = await evaluatePRF({ salt: saltBytes });
  if (!prfOutput) {
    throw new Error("PRF evaluation failed during sign-in");
  }
  console.log(" Passkey authenticated and PRF re-evaluated!");
  console.log("    Same passkey + salt  same prfOutput (deterministic!)");
  console.log(" Deriving agentSecret...");
  const crypto2 = await WasmCrypto.create();
  const agentSecret = crypto2.agentSecretFromSecretSeed(prfOutput);
  console.log(" Computing accountID deterministically...");
  const accountHeader = accountHeaderForInitialAgentSecret(agentSecret, crypto2);
  const accountID = idforHeader(accountHeader, crypto2);
  console.log(" AccountID re-computed:", accountID);
  console.log("    Chain: PRF  agentSecret  header  accountID");
  console.log("     No storage needed - computed on the fly!");
  console.log(" Loading account...");
  const storage = await getStorage();
  let syncSetup = null;
  {
    console.log(" [SYNC] Setting up self-hosted sync...");
    syncSetup = setupSyncPeers();
  }
  const { LocalNode: LocalNode2 } = await Promise.resolve().then(() => index$3);
  const withLoadedAccountPromise = LocalNode2.withLoadedAccount({
    accountID,
    accountSecret: agentSecret,
    crypto: crypto2,
    peers: syncSetup ? syncSetup.peers : [],
    storage,
    migration: schemaMigration
    //  Runs on every load, idempotent
  });
  const timeoutPromise = new Promise((_, reject) => {
    setTimeout(() => {
      reject(new Error(`withLoadedAccount() timed out after 30 seconds. AccountID: ${accountID}. This might indicate the account doesn't exist on the sync server or sync isn't working.`));
    }, 3e4);
  });
  let node;
  try {
    console.log(" Waiting for account to load (this may take a moment if loading from cloud)...");
    node = await Promise.race([withLoadedAccountPromise, timeoutPromise]);
    console.log(" LocalNode.withLoadedAccount() completed successfully");
  } catch (loadError) {
    console.error(" LocalNode.withLoadedAccount() failed:", loadError);
    console.error("   Error message:", loadError.message);
    console.error("   Error stack:", loadError.stack);
    console.error("   AccountID:", accountID);
    console.error("   Peers available:", syncSetup ? syncSetup.peers.length : 0);
    if (syncSetup && syncSetup.peers.length > 0) {
      console.error("   Peer IDs:", syncSetup.peers.map((p) => p.id || "unknown"));
    }
    throw loadError;
  }
  if (syncSetup) {
    syncSetup.setNode(node);
    console.log(" [SYNC] Jazz sync peer connected");
  }
  if (storage) {
    console.log(" [STORAGE] Account loaded from IndexedDB");
  }
  console.log(" Getting account from node...");
  const account = node.expectCurrentAccount("signInWithPasskey");
  console.log(" Account loaded! ID:", account.id);
  console.log(" Sign-in complete! TRUE single-passkey flow!");
  console.log("    1 biometric prompt");
  console.log("    0 secrets retrieved from storage");
  console.log("    Everything computed deterministically!");
  console.log(" Returning from signInWithPasskey()...");
  return {
    accountID: account.id,
    agentSecret,
    node,
    account
  };
}
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var _2020$2 = { exports: {} };
var core$1 = {};
var validate = {};
var boolSchema = {};
var errors = {};
var codegen = {};
var code$1 = {};
var hasRequiredCode$1;
function requireCode$1() {
  if (hasRequiredCode$1) return code$1;
  hasRequiredCode$1 = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.regexpCode = exports$1.getEsmExportName = exports$1.getProperty = exports$1.safeStringify = exports$1.stringify = exports$1.strConcat = exports$1.addCodeArg = exports$1.str = exports$1._ = exports$1.nil = exports$1._Code = exports$1.Name = exports$1.IDENTIFIER = exports$1._CodeOrName = void 0;
    class _CodeOrName {
    }
    exports$1._CodeOrName = _CodeOrName;
    exports$1.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    class Name extends _CodeOrName {
      constructor(s) {
        super();
        if (!exports$1.IDENTIFIER.test(s))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = s;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return false;
      }
      get names() {
        return { [this.str]: 1 };
      }
    }
    exports$1.Name = Name;
    class _Code extends _CodeOrName {
      constructor(code2) {
        super();
        this._items = typeof code2 === "string" ? [code2] : code2;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return false;
        const item = this._items[0];
        return item === "" || item === '""';
      }
      get str() {
        var _a;
        return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
      }
      get names() {
        var _a;
        return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names2, c) => {
          if (c instanceof Name)
            names2[c.str] = (names2[c.str] || 0) + 1;
          return names2;
        }, {});
      }
    }
    exports$1._Code = _Code;
    exports$1.nil = new _Code("");
    function _(strs, ...args) {
      const code2 = [strs[0]];
      let i = 0;
      while (i < args.length) {
        addCodeArg(code2, args[i]);
        code2.push(strs[++i]);
      }
      return new _Code(code2);
    }
    exports$1._ = _;
    const plus = new _Code("+");
    function str(strs, ...args) {
      const expr = [safeStringify(strs[0])];
      let i = 0;
      while (i < args.length) {
        expr.push(plus);
        addCodeArg(expr, args[i]);
        expr.push(plus, safeStringify(strs[++i]));
      }
      optimize(expr);
      return new _Code(expr);
    }
    exports$1.str = str;
    function addCodeArg(code2, arg) {
      if (arg instanceof _Code)
        code2.push(...arg._items);
      else if (arg instanceof Name)
        code2.push(arg);
      else
        code2.push(interpolate(arg));
    }
    exports$1.addCodeArg = addCodeArg;
    function optimize(expr) {
      let i = 1;
      while (i < expr.length - 1) {
        if (expr[i] === plus) {
          const res = mergeExprItems(expr[i - 1], expr[i + 1]);
          if (res !== void 0) {
            expr.splice(i - 1, 3, res);
            continue;
          }
          expr[i++] = "+";
        }
        i++;
      }
    }
    function mergeExprItems(a, b) {
      if (b === '""')
        return a;
      if (a === '""')
        return b;
      if (typeof a == "string") {
        if (b instanceof Name || a[a.length - 1] !== '"')
          return;
        if (typeof b != "string")
          return `${a.slice(0, -1)}${b}"`;
        if (b[0] === '"')
          return a.slice(0, -1) + b.slice(1);
        return;
      }
      if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
        return `"${a}${b.slice(1)}`;
      return;
    }
    function strConcat(c1, c2) {
      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
    }
    exports$1.strConcat = strConcat;
    function interpolate(x) {
      return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
    }
    function stringify(x) {
      return new _Code(safeStringify(x));
    }
    exports$1.stringify = stringify;
    function safeStringify(x) {
      return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    exports$1.safeStringify = safeStringify;
    function getProperty(key) {
      return typeof key == "string" && exports$1.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
    }
    exports$1.getProperty = getProperty;
    function getEsmExportName(key) {
      if (typeof key == "string" && exports$1.IDENTIFIER.test(key)) {
        return new _Code(`${key}`);
      }
      throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
    }
    exports$1.getEsmExportName = getEsmExportName;
    function regexpCode(rx) {
      return new _Code(rx.toString());
    }
    exports$1.regexpCode = regexpCode;
  })(code$1);
  return code$1;
}
var scope = {};
var hasRequiredScope;
function requireScope() {
  if (hasRequiredScope) return scope;
  hasRequiredScope = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.ValueScope = exports$1.ValueScopeName = exports$1.Scope = exports$1.varKinds = exports$1.UsedValueState = void 0;
    const code_1 = requireCode$1();
    class ValueError extends Error {
      constructor(name) {
        super(`CodeGen: "code" for ${name} not defined`);
        this.value = name.value;
      }
    }
    var UsedValueState;
    (function(UsedValueState2) {
      UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
      UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
    })(UsedValueState || (exports$1.UsedValueState = UsedValueState = {}));
    exports$1.varKinds = {
      const: new code_1.Name("const"),
      let: new code_1.Name("let"),
      var: new code_1.Name("var")
    };
    class Scope {
      constructor({ prefixes, parent } = {}) {
        this._names = {};
        this._prefixes = prefixes;
        this._parent = parent;
      }
      toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
      }
      name(prefix) {
        return new code_1.Name(this._newName(prefix));
      }
      _newName(prefix) {
        const ng = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng.index++}`;
      }
      _nameGroup(prefix) {
        var _a, _b;
        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
          throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
        }
        return this._names[prefix] = { prefix, index: 0 };
      }
    }
    exports$1.Scope = Scope;
    class ValueScopeName extends code_1.Name {
      constructor(prefix, nameStr) {
        super(nameStr);
        this.prefix = prefix;
      }
      setValue(value, { property, itemIndex }) {
        this.value = value;
        this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
      }
    }
    exports$1.ValueScopeName = ValueScopeName;
    const line = (0, code_1._)`\n`;
    class ValueScope extends Scope {
      constructor(opts) {
        super(opts);
        this._values = {};
        this._scope = opts.scope;
        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
      }
      get() {
        return this._scope;
      }
      name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
      }
      value(nameOrPrefix, value) {
        var _a;
        if (value.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const name = this.toName(nameOrPrefix);
        const { prefix } = name;
        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
        let vs = this._values[prefix];
        if (vs) {
          const _name = vs.get(valueKey);
          if (_name)
            return _name;
        } else {
          vs = this._values[prefix] = /* @__PURE__ */ new Map();
        }
        vs.set(valueKey, name);
        const s = this._scope[prefix] || (this._scope[prefix] = []);
        const itemIndex = s.length;
        s[itemIndex] = value.ref;
        name.setValue(value, { property: prefix, itemIndex });
        return name;
      }
      getValue(prefix, keyOrRef) {
        const vs = this._values[prefix];
        if (!vs)
          return;
        return vs.get(keyOrRef);
      }
      scopeRefs(scopeName, values = this._values) {
        return this._reduceValues(values, (name) => {
          if (name.scopePath === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return (0, code_1._)`${scopeName}${name.scopePath}`;
        });
      }
      scopeCode(values = this._values, usedValues, getCode) {
        return this._reduceValues(values, (name) => {
          if (name.value === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return name.value.code;
        }, usedValues, getCode);
      }
      _reduceValues(values, valueCode, usedValues = {}, getCode) {
        let code2 = code_1.nil;
        for (const prefix in values) {
          const vs = values[prefix];
          if (!vs)
            continue;
          const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
          vs.forEach((name) => {
            if (nameSet.has(name))
              return;
            nameSet.set(name, UsedValueState.Started);
            let c = valueCode(name);
            if (c) {
              const def = this.opts.es5 ? exports$1.varKinds.var : exports$1.varKinds.const;
              code2 = (0, code_1._)`${code2}${def} ${name} = ${c};${this.opts._n}`;
            } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
              code2 = (0, code_1._)`${code2}${c}${this.opts._n}`;
            } else {
              throw new ValueError(name);
            }
            nameSet.set(name, UsedValueState.Completed);
          });
        }
        return code2;
      }
    }
    exports$1.ValueScope = ValueScope;
  })(scope);
  return scope;
}
var hasRequiredCodegen;
function requireCodegen() {
  if (hasRequiredCodegen) return codegen;
  hasRequiredCodegen = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.or = exports$1.and = exports$1.not = exports$1.CodeGen = exports$1.operators = exports$1.varKinds = exports$1.ValueScopeName = exports$1.ValueScope = exports$1.Scope = exports$1.Name = exports$1.regexpCode = exports$1.stringify = exports$1.getProperty = exports$1.nil = exports$1.strConcat = exports$1.str = exports$1._ = void 0;
    const code_1 = requireCode$1();
    const scope_1 = requireScope();
    var code_2 = requireCode$1();
    Object.defineProperty(exports$1, "_", { enumerable: true, get: function() {
      return code_2._;
    } });
    Object.defineProperty(exports$1, "str", { enumerable: true, get: function() {
      return code_2.str;
    } });
    Object.defineProperty(exports$1, "strConcat", { enumerable: true, get: function() {
      return code_2.strConcat;
    } });
    Object.defineProperty(exports$1, "nil", { enumerable: true, get: function() {
      return code_2.nil;
    } });
    Object.defineProperty(exports$1, "getProperty", { enumerable: true, get: function() {
      return code_2.getProperty;
    } });
    Object.defineProperty(exports$1, "stringify", { enumerable: true, get: function() {
      return code_2.stringify;
    } });
    Object.defineProperty(exports$1, "regexpCode", { enumerable: true, get: function() {
      return code_2.regexpCode;
    } });
    Object.defineProperty(exports$1, "Name", { enumerable: true, get: function() {
      return code_2.Name;
    } });
    var scope_2 = requireScope();
    Object.defineProperty(exports$1, "Scope", { enumerable: true, get: function() {
      return scope_2.Scope;
    } });
    Object.defineProperty(exports$1, "ValueScope", { enumerable: true, get: function() {
      return scope_2.ValueScope;
    } });
    Object.defineProperty(exports$1, "ValueScopeName", { enumerable: true, get: function() {
      return scope_2.ValueScopeName;
    } });
    Object.defineProperty(exports$1, "varKinds", { enumerable: true, get: function() {
      return scope_2.varKinds;
    } });
    exports$1.operators = {
      GT: new code_1._Code(">"),
      GTE: new code_1._Code(">="),
      LT: new code_1._Code("<"),
      LTE: new code_1._Code("<="),
      EQ: new code_1._Code("==="),
      NEQ: new code_1._Code("!=="),
      NOT: new code_1._Code("!"),
      OR: new code_1._Code("||"),
      AND: new code_1._Code("&&"),
      ADD: new code_1._Code("+")
    };
    class Node {
      optimizeNodes() {
        return this;
      }
      optimizeNames(_names, _constants) {
        return this;
      }
    }
    class Def extends Node {
      constructor(varKind, name, rhs) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.rhs = rhs;
      }
      render({ es5, _n }) {
        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
        const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n;
      }
      optimizeNames(names2, constants) {
        if (!names2[this.name.str])
          return;
        if (this.rhs)
          this.rhs = optimizeExpr(this.rhs, names2, constants);
        return this;
      }
      get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
      }
    }
    class Assign extends Node {
      constructor(lhs, rhs, sideEffects) {
        super();
        this.lhs = lhs;
        this.rhs = rhs;
        this.sideEffects = sideEffects;
      }
      render({ _n }) {
        return `${this.lhs} = ${this.rhs};` + _n;
      }
      optimizeNames(names2, constants) {
        if (this.lhs instanceof code_1.Name && !names2[this.lhs.str] && !this.sideEffects)
          return;
        this.rhs = optimizeExpr(this.rhs, names2, constants);
        return this;
      }
      get names() {
        const names2 = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
        return addExprNames(names2, this.rhs);
      }
    }
    class AssignOp extends Assign {
      constructor(lhs, op, rhs, sideEffects) {
        super(lhs, rhs, sideEffects);
        this.op = op;
      }
      render({ _n }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
      }
    }
    class Label extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        return `${this.label}:` + _n;
      }
    }
    class Break extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        const label = this.label ? ` ${this.label}` : "";
        return `break${label};` + _n;
      }
    }
    class Throw extends Node {
      constructor(error) {
        super();
        this.error = error;
      }
      render({ _n }) {
        return `throw ${this.error};` + _n;
      }
      get names() {
        return this.error.names;
      }
    }
    class AnyCode extends Node {
      constructor(code2) {
        super();
        this.code = code2;
      }
      render({ _n }) {
        return `${this.code};` + _n;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(names2, constants) {
        this.code = optimizeExpr(this.code, names2, constants);
        return this;
      }
      get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
      }
    }
    class ParentNode extends Node {
      constructor(nodes = []) {
        super();
        this.nodes = nodes;
      }
      render(opts) {
        return this.nodes.reduce((code2, n) => code2 + n.render(opts), "");
      }
      optimizeNodes() {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i].optimizeNodes();
          if (Array.isArray(n))
            nodes.splice(i, 1, ...n);
          else if (n)
            nodes[i] = n;
          else
            nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      optimizeNames(names2, constants) {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i];
          if (n.optimizeNames(names2, constants))
            continue;
          subtractNames(names2, n.names);
          nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((names2, n) => addNames(names2, n.names), {});
      }
    }
    class BlockNode extends ParentNode {
      render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
      }
    }
    class Root extends ParentNode {
    }
    class Else extends BlockNode {
    }
    Else.kind = "else";
    class If extends BlockNode {
      constructor(condition, nodes) {
        super(nodes);
        this.condition = condition;
      }
      render(opts) {
        let code2 = `if(${this.condition})` + super.render(opts);
        if (this.else)
          code2 += "else " + this.else.render(opts);
        return code2;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const cond = this.condition;
        if (cond === true)
          return this.nodes;
        let e = this.else;
        if (e) {
          const ns = e.optimizeNodes();
          e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
        }
        if (e) {
          if (cond === false)
            return e instanceof If ? e : e.nodes;
          if (this.nodes.length)
            return this;
          return new If(not2(cond), e instanceof If ? [e] : e.nodes);
        }
        if (cond === false || !this.nodes.length)
          return void 0;
        return this;
      }
      optimizeNames(names2, constants) {
        var _a;
        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names2, constants);
        if (!(super.optimizeNames(names2, constants) || this.else))
          return;
        this.condition = optimizeExpr(this.condition, names2, constants);
        return this;
      }
      get names() {
        const names2 = super.names;
        addExprNames(names2, this.condition);
        if (this.else)
          addNames(names2, this.else.names);
        return names2;
      }
    }
    If.kind = "if";
    class For extends BlockNode {
    }
    For.kind = "for";
    class ForLoop extends For {
      constructor(iteration) {
        super();
        this.iteration = iteration;
      }
      render(opts) {
        return `for(${this.iteration})` + super.render(opts);
      }
      optimizeNames(names2, constants) {
        if (!super.optimizeNames(names2, constants))
          return;
        this.iteration = optimizeExpr(this.iteration, names2, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iteration.names);
      }
    }
    class ForRange extends For {
      constructor(varKind, name, from, to) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.from = from;
        this.to = to;
      }
      render(opts) {
        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
        const { name, from, to } = this;
        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
      }
      get names() {
        const names2 = addExprNames(super.names, this.from);
        return addExprNames(names2, this.to);
      }
    }
    class ForIter extends For {
      constructor(loop, varKind, name, iterable) {
        super();
        this.loop = loop;
        this.varKind = varKind;
        this.name = name;
        this.iterable = iterable;
      }
      render(opts) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
      }
      optimizeNames(names2, constants) {
        if (!super.optimizeNames(names2, constants))
          return;
        this.iterable = optimizeExpr(this.iterable, names2, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iterable.names);
      }
    }
    class Func extends BlockNode {
      constructor(name, args, async) {
        super();
        this.name = name;
        this.args = args;
        this.async = async;
      }
      render(opts) {
        const _async = this.async ? "async " : "";
        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
      }
    }
    Func.kind = "func";
    class Return extends ParentNode {
      render(opts) {
        return "return " + super.render(opts);
      }
    }
    Return.kind = "return";
    class Try extends BlockNode {
      render(opts) {
        let code2 = "try" + super.render(opts);
        if (this.catch)
          code2 += this.catch.render(opts);
        if (this.finally)
          code2 += this.finally.render(opts);
        return code2;
      }
      optimizeNodes() {
        var _a, _b;
        super.optimizeNodes();
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
        return this;
      }
      optimizeNames(names2, constants) {
        var _a, _b;
        super.optimizeNames(names2, constants);
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names2, constants);
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names2, constants);
        return this;
      }
      get names() {
        const names2 = super.names;
        if (this.catch)
          addNames(names2, this.catch.names);
        if (this.finally)
          addNames(names2, this.finally.names);
        return names2;
      }
    }
    class Catch extends BlockNode {
      constructor(error) {
        super();
        this.error = error;
      }
      render(opts) {
        return `catch(${this.error})` + super.render(opts);
      }
    }
    Catch.kind = "catch";
    class Finally extends BlockNode {
      render(opts) {
        return "finally" + super.render(opts);
      }
    }
    Finally.kind = "finally";
    class CodeGen {
      constructor(extScope, opts = {}) {
        this._values = {};
        this._blockStarts = [];
        this._constants = {};
        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
        this._extScope = extScope;
        this._scope = new scope_1.Scope({ parent: extScope });
        this._nodes = [new Root()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(prefix) {
        return this._scope.name(prefix);
      }
      // reserves unique name in the external scope
      scopeName(prefix) {
        return this._extScope.name(prefix);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(prefixOrName, value) {
        const name = this._extScope.value(prefixOrName, value);
        const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
        vs.add(name);
        return name;
      }
      getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(varKind, nameOrPrefix, rhs, constant) {
        const name = this._scope.toName(nameOrPrefix);
        if (rhs !== void 0 && constant)
          this._constants[name.str] = rhs;
        this._leafNode(new Def(varKind, name, rhs));
        return name;
      }
      // `const` declaration (`var` in es5 mode)
      const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
      }
      // `var` declaration with optional assignment
      var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
      }
      // assignment code
      assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
      }
      // `+=` code
      add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports$1.operators.ADD, rhs));
      }
      // appends passed SafeExpr to code or executes Block
      code(c) {
        if (typeof c == "function")
          c();
        else if (c !== code_1.nil)
          this._leafNode(new AnyCode(c));
        return this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...keyValues) {
        const code2 = ["{"];
        for (const [key, value] of keyValues) {
          if (code2.length > 1)
            code2.push(",");
          code2.push(key);
          if (key !== value || this.opts.es5) {
            code2.push(":");
            (0, code_1.addCodeArg)(code2, value);
          }
        }
        code2.push("}");
        return new code_1._Code(code2);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(condition, thenBody, elseBody) {
        this._blockNode(new If(condition));
        if (thenBody && elseBody) {
          this.code(thenBody).else().code(elseBody).endIf();
        } else if (thenBody) {
          this.code(thenBody).endIf();
        } else if (elseBody) {
          throw new Error('CodeGen: "else" body without "then" body');
        }
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(condition) {
        return this._elseNode(new If(condition));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new Else());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(If, Else);
      }
      _for(node, forBody) {
        this._blockNode(node);
        if (forBody)
          this.code(forBody).endFor();
        return this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
      }
      // `for` statement for a range of values
      forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        const name = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
          const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
          return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
            this.var(name, (0, code_1._)`${arr}[${i}]`);
            forBody(name);
          });
        }
        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties) {
          return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
        }
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(For);
      }
      // `label` statement
      label(label) {
        return this._leafNode(new Label(label));
      }
      // `break` statement
      break(label) {
        return this._leafNode(new Break(label));
      }
      // `return` statement
      return(value) {
        const node = new Return();
        this._blockNode(node);
        this.code(value);
        if (node.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
      }
      // `try` statement
      try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const node = new Try();
        this._blockNode(node);
        this.code(tryBody);
        if (catchCode) {
          const error = this.name("e");
          this._currNode = node.catch = new Catch(error);
          catchCode(error);
        }
        if (finallyCode) {
          this._currNode = node.finally = new Finally();
          this.code(finallyCode);
        }
        return this._endBlockNode(Catch, Finally);
      }
      // `throw` statement
      throw(error) {
        return this._leafNode(new Throw(error));
      }
      // start self-balancing block
      block(body, nodeCount) {
        this._blockStarts.push(this._nodes.length);
        if (body)
          this.code(body).endBlock(nodeCount);
        return this;
      }
      // end the current self-balancing block
      endBlock(nodeCount) {
        const len = this._blockStarts.pop();
        if (len === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const toClose = this._nodes.length - len;
        if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
          throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        }
        this._nodes.length = len;
        return this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(name, args = code_1.nil, async, funcBody) {
        this._blockNode(new Func(name, args, async));
        if (funcBody)
          this.code(funcBody).endFunc();
        return this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(Func);
      }
      optimize(n = 1) {
        while (n-- > 0) {
          this._root.optimizeNodes();
          this._root.optimizeNames(this._root.names, this._constants);
        }
      }
      _leafNode(node) {
        this._currNode.nodes.push(node);
        return this;
      }
      _blockNode(node) {
        this._currNode.nodes.push(node);
        this._nodes.push(node);
      }
      _endBlockNode(N1, N2) {
        const n = this._currNode;
        if (n instanceof N1 || N2 && n instanceof N2) {
          this._nodes.pop();
          return this;
        }
        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
      }
      _elseNode(node) {
        const n = this._currNode;
        if (!(n instanceof If)) {
          throw new Error('CodeGen: "else" without "if"');
        }
        this._currNode = n.else = node;
        return this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const ns = this._nodes;
        return ns[ns.length - 1];
      }
      set _currNode(node) {
        const ns = this._nodes;
        ns[ns.length - 1] = node;
      }
    }
    exports$1.CodeGen = CodeGen;
    function addNames(names2, from) {
      for (const n in from)
        names2[n] = (names2[n] || 0) + (from[n] || 0);
      return names2;
    }
    function addExprNames(names2, from) {
      return from instanceof code_1._CodeOrName ? addNames(names2, from.names) : names2;
    }
    function optimizeExpr(expr, names2, constants) {
      if (expr instanceof code_1.Name)
        return replaceName(expr);
      if (!canOptimize(expr))
        return expr;
      return new code_1._Code(expr._items.reduce((items2, c) => {
        if (c instanceof code_1.Name)
          c = replaceName(c);
        if (c instanceof code_1._Code)
          items2.push(...c._items);
        else
          items2.push(c);
        return items2;
      }, []));
      function replaceName(n) {
        const c = constants[n.str];
        if (c === void 0 || names2[n.str] !== 1)
          return n;
        delete names2[n.str];
        return c;
      }
      function canOptimize(e) {
        return e instanceof code_1._Code && e._items.some((c) => c instanceof code_1.Name && names2[c.str] === 1 && constants[c.str] !== void 0);
      }
    }
    function subtractNames(names2, from) {
      for (const n in from)
        names2[n] = (names2[n] || 0) - (from[n] || 0);
    }
    function not2(x) {
      return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
    }
    exports$1.not = not2;
    const andCode = mappend(exports$1.operators.AND);
    function and(...args) {
      return args.reduce(andCode);
    }
    exports$1.and = and;
    const orCode = mappend(exports$1.operators.OR);
    function or(...args) {
      return args.reduce(orCode);
    }
    exports$1.or = or;
    function mappend(op) {
      return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;
    }
    function par(x) {
      return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
    }
  })(codegen);
  return codegen;
}
var util = {};
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  Object.defineProperty(util, "__esModule", { value: true });
  util.checkStrictMode = util.getErrorPath = util.Type = util.useFunc = util.setEvaluated = util.evaluatedPropsToName = util.mergeEvaluated = util.eachItem = util.unescapeJsonPointer = util.escapeJsonPointer = util.escapeFragment = util.unescapeFragment = util.schemaRefOrVal = util.schemaHasRulesButRef = util.schemaHasRules = util.checkUnknownRules = util.alwaysValidSchema = util.toHash = void 0;
  const codegen_1 = requireCodegen();
  const code_1 = requireCode$1();
  function toHash(arr) {
    const hash = {};
    for (const item of arr)
      hash[item] = true;
    return hash;
  }
  util.toHash = toHash;
  function alwaysValidSchema(it, schema) {
    if (typeof schema == "boolean")
      return schema;
    if (Object.keys(schema).length === 0)
      return true;
    checkUnknownRules(it, schema);
    return !schemaHasRules(schema, it.self.RULES.all);
  }
  util.alwaysValidSchema = alwaysValidSchema;
  function checkUnknownRules(it, schema = it.schema) {
    const { opts, self: self2 } = it;
    if (!opts.strictSchema)
      return;
    if (typeof schema === "boolean")
      return;
    const rules2 = self2.RULES.keywords;
    for (const key in schema) {
      if (!rules2[key])
        checkStrictMode(it, `unknown keyword: "${key}"`);
    }
  }
  util.checkUnknownRules = checkUnknownRules;
  function schemaHasRules(schema, rules2) {
    if (typeof schema == "boolean")
      return !schema;
    for (const key in schema)
      if (rules2[key])
        return true;
    return false;
  }
  util.schemaHasRules = schemaHasRules;
  function schemaHasRulesButRef(schema, RULES) {
    if (typeof schema == "boolean")
      return !schema;
    for (const key in schema)
      if (key !== "$ref" && RULES.all[key])
        return true;
    return false;
  }
  util.schemaHasRulesButRef = schemaHasRulesButRef;
  function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword2, $data) {
    if (!$data) {
      if (typeof schema == "number" || typeof schema == "boolean")
        return schema;
      if (typeof schema == "string")
        return (0, codegen_1._)`${schema}`;
    }
    return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword2)}`;
  }
  util.schemaRefOrVal = schemaRefOrVal;
  function unescapeFragment(str) {
    return unescapeJsonPointer(decodeURIComponent(str));
  }
  util.unescapeFragment = unescapeFragment;
  function escapeFragment(str) {
    return encodeURIComponent(escapeJsonPointer(str));
  }
  util.escapeFragment = escapeFragment;
  function escapeJsonPointer(str) {
    if (typeof str == "number")
      return `${str}`;
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  util.escapeJsonPointer = escapeJsonPointer;
  function unescapeJsonPointer(str) {
    return str.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  util.unescapeJsonPointer = unescapeJsonPointer;
  function eachItem(xs, f) {
    if (Array.isArray(xs)) {
      for (const x of xs)
        f(x);
    } else {
      f(xs);
    }
  }
  util.eachItem = eachItem;
  function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
    return (gen, from, to, toName) => {
      const res = to === void 0 ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
      return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
    };
  }
  util.mergeEvaluated = {
    props: makeMergeEvaluated({
      mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
        gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
      }),
      mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {
        if (from === true) {
          gen.assign(to, true);
        } else {
          gen.assign(to, (0, codegen_1._)`${to} || {}`);
          setEvaluated(gen, to, from);
        }
      }),
      mergeValues: (from, to) => from === true ? true : { ...from, ...to },
      resultToName: evaluatedPropsToName
    }),
    items: makeMergeEvaluated({
      mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
      mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
      mergeValues: (from, to) => from === true ? true : Math.max(from, to),
      resultToName: (gen, items2) => gen.var("items", items2)
    })
  };
  function evaluatedPropsToName(gen, ps) {
    if (ps === true)
      return gen.var("props", true);
    const props = gen.var("props", (0, codegen_1._)`{}`);
    if (ps !== void 0)
      setEvaluated(gen, props, ps);
    return props;
  }
  util.evaluatedPropsToName = evaluatedPropsToName;
  function setEvaluated(gen, props, ps) {
    Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, true));
  }
  util.setEvaluated = setEvaluated;
  const snippets = {};
  function useFunc(gen, f) {
    return gen.scopeValue("func", {
      ref: f,
      code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
    });
  }
  util.useFunc = useFunc;
  var Type;
  (function(Type2) {
    Type2[Type2["Num"] = 0] = "Num";
    Type2[Type2["Str"] = 1] = "Str";
  })(Type || (util.Type = Type = {}));
  function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
    if (dataProp instanceof codegen_1.Name) {
      const isNumber = dataPropType === Type.Num;
      return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
  }
  util.getErrorPath = getErrorPath;
  function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
    if (!mode)
      return;
    msg = `strict mode: ${msg}`;
    if (mode === true)
      throw new Error(msg);
    it.self.logger.warn(msg);
  }
  util.checkStrictMode = checkStrictMode;
  return util;
}
var names = {};
var hasRequiredNames;
function requireNames() {
  if (hasRequiredNames) return names;
  hasRequiredNames = 1;
  Object.defineProperty(names, "__esModule", { value: true });
  const codegen_1 = requireCodegen();
  const names$1 = {
    // validation function arguments
    data: new codegen_1.Name("data"),
    // data passed to validation function
    // args passed from referencing schema
    valCxt: new codegen_1.Name("valCxt"),
    // validation/data context - should not be used directly, it is destructured to the names below
    instancePath: new codegen_1.Name("instancePath"),
    parentData: new codegen_1.Name("parentData"),
    parentDataProperty: new codegen_1.Name("parentDataProperty"),
    rootData: new codegen_1.Name("rootData"),
    // root data - same as the data passed to the first/top validation function
    dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
    // used to support recursiveRef and dynamicRef
    // function scoped variables
    vErrors: new codegen_1.Name("vErrors"),
    // null or array of validation errors
    errors: new codegen_1.Name("errors"),
    // counter of validation errors
    this: new codegen_1.Name("this"),
    // "globals"
    self: new codegen_1.Name("self"),
    scope: new codegen_1.Name("scope"),
    // JTD serialize/parse name for JSON string and position
    json: new codegen_1.Name("json"),
    jsonPos: new codegen_1.Name("jsonPos"),
    jsonLen: new codegen_1.Name("jsonLen"),
    jsonPart: new codegen_1.Name("jsonPart")
  };
  names.default = names$1;
  return names;
}
var hasRequiredErrors;
function requireErrors() {
  if (hasRequiredErrors) return errors;
  hasRequiredErrors = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.extendErrors = exports$1.resetErrorsCount = exports$1.reportExtraError = exports$1.reportError = exports$1.keyword$DataError = exports$1.keywordError = void 0;
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const names_1 = requireNames();
    exports$1.keywordError = {
      message: ({ keyword: keyword2 }) => (0, codegen_1.str)`must pass "${keyword2}" keyword validation`
    };
    exports$1.keyword$DataError = {
      message: ({ keyword: keyword2, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword2}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword2}" keyword is invalid ($data)`
    };
    function reportError(cxt, error = exports$1.keywordError, errorPaths, overrideAllErrors) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
        addError(gen, errObj);
      } else {
        returnErrors(it, (0, codegen_1._)`[${errObj}]`);
      }
    }
    exports$1.reportError = reportError;
    function reportExtraError(cxt, error = exports$1.keywordError, errorPaths) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      addError(gen, errObj);
      if (!(compositeRule || allErrors)) {
        returnErrors(it, names_1.default.vErrors);
      }
    }
    exports$1.reportExtraError = reportExtraError;
    function resetErrorsCount(gen, errsCount) {
      gen.assign(names_1.default.errors, errsCount);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
    }
    exports$1.resetErrorsCount = resetErrorsCount;
    function extendErrors({ gen, keyword: keyword2, schemaValue, data: data2, errsCount, it }) {
      if (errsCount === void 0)
        throw new Error("ajv implementation error");
      const err = gen.name("err");
      gen.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
        gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
        gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword2}`);
        if (it.opts.verbose) {
          gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
          gen.assign((0, codegen_1._)`${err}.data`, data2);
        }
      });
    }
    exports$1.extendErrors = extendErrors;
    function addError(gen, errObj) {
      const err = gen.const("err", errObj);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
      gen.code((0, codegen_1._)`${names_1.default.errors}++`);
    }
    function returnErrors(it, errs) {
      const { gen, validateName, schemaEnv } = it;
      if (schemaEnv.$async) {
        gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
        gen.return(false);
      }
    }
    const E = {
      keyword: new codegen_1.Name("keyword"),
      schemaPath: new codegen_1.Name("schemaPath"),
      // also used in JTD errors
      params: new codegen_1.Name("params"),
      propertyName: new codegen_1.Name("propertyName"),
      message: new codegen_1.Name("message"),
      schema: new codegen_1.Name("schema"),
      parentSchema: new codegen_1.Name("parentSchema")
    };
    function errorObjectCode(cxt, error, errorPaths) {
      const { createErrors } = cxt.it;
      if (createErrors === false)
        return (0, codegen_1._)`{}`;
      return errorObject(cxt, error, errorPaths);
    }
    function errorObject(cxt, error, errorPaths = {}) {
      const { gen, it } = cxt;
      const keyValues = [
        errorInstancePath(it, errorPaths),
        errorSchemaPath(cxt, errorPaths)
      ];
      extraErrorProps(cxt, error, keyValues);
      return gen.object(...keyValues);
    }
    function errorInstancePath({ errorPath }, { instancePath }) {
      const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
      return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
    }
    function errorSchemaPath({ keyword: keyword2, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
      let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword2}`;
      if (schemaPath) {
        schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
      }
      return [E.schemaPath, schPath];
    }
    function extraErrorProps(cxt, { params, message }, keyValues) {
      const { keyword: keyword2, data: data2, schemaValue, it } = cxt;
      const { opts, propertyName, topSchemaRef, schemaPath } = it;
      keyValues.push([E.keyword, keyword2], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
      if (opts.messages) {
        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
      }
      if (opts.verbose) {
        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data2]);
      }
      if (propertyName)
        keyValues.push([E.propertyName, propertyName]);
    }
  })(errors);
  return errors;
}
var hasRequiredBoolSchema;
function requireBoolSchema() {
  if (hasRequiredBoolSchema) return boolSchema;
  hasRequiredBoolSchema = 1;
  Object.defineProperty(boolSchema, "__esModule", { value: true });
  boolSchema.boolOrEmptySchema = boolSchema.topBoolOrEmptySchema = void 0;
  const errors_1 = requireErrors();
  const codegen_1 = requireCodegen();
  const names_1 = requireNames();
  const boolError = {
    message: "boolean schema is false"
  };
  function topBoolOrEmptySchema(it) {
    const { gen, schema, validateName } = it;
    if (schema === false) {
      falseSchemaError(it, false);
    } else if (typeof schema == "object" && schema.$async === true) {
      gen.return(names_1.default.data);
    } else {
      gen.assign((0, codegen_1._)`${validateName}.errors`, null);
      gen.return(true);
    }
  }
  boolSchema.topBoolOrEmptySchema = topBoolOrEmptySchema;
  function boolOrEmptySchema(it, valid) {
    const { gen, schema } = it;
    if (schema === false) {
      gen.var(valid, false);
      falseSchemaError(it);
    } else {
      gen.var(valid, true);
    }
  }
  boolSchema.boolOrEmptySchema = boolOrEmptySchema;
  function falseSchemaError(it, overrideAllErrors) {
    const { gen, data: data2 } = it;
    const cxt = {
      gen,
      keyword: "false schema",
      data: data2,
      schema: false,
      schemaCode: false,
      schemaValue: false,
      params: {},
      it
    };
    (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
  }
  return boolSchema;
}
var dataType = {};
var rules = {};
var hasRequiredRules;
function requireRules() {
  if (hasRequiredRules) return rules;
  hasRequiredRules = 1;
  Object.defineProperty(rules, "__esModule", { value: true });
  rules.getRules = rules.isJSONType = void 0;
  const _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
  const jsonTypes = new Set(_jsonTypes);
  function isJSONType(x) {
    return typeof x == "string" && jsonTypes.has(x);
  }
  rules.isJSONType = isJSONType;
  function getRules() {
    const groups = {
      number: { type: "number", rules: [] },
      string: { type: "string", rules: [] },
      array: { type: "array", rules: [] },
      object: { type: "object", rules: [] }
    };
    return {
      types: { ...groups, integer: true, boolean: true, null: true },
      rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
      post: { rules: [] },
      all: {},
      keywords: {}
    };
  }
  rules.getRules = getRules;
  return rules;
}
var applicability = {};
var hasRequiredApplicability;
function requireApplicability() {
  if (hasRequiredApplicability) return applicability;
  hasRequiredApplicability = 1;
  Object.defineProperty(applicability, "__esModule", { value: true });
  applicability.shouldUseRule = applicability.shouldUseGroup = applicability.schemaHasRulesForType = void 0;
  function schemaHasRulesForType({ schema, self: self2 }, type2) {
    const group = self2.RULES.types[type2];
    return group && group !== true && shouldUseGroup(schema, group);
  }
  applicability.schemaHasRulesForType = schemaHasRulesForType;
  function shouldUseGroup(schema, group) {
    return group.rules.some((rule) => shouldUseRule(schema, rule));
  }
  applicability.shouldUseGroup = shouldUseGroup;
  function shouldUseRule(schema, rule) {
    var _a;
    return schema[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== void 0));
  }
  applicability.shouldUseRule = shouldUseRule;
  return applicability;
}
var hasRequiredDataType;
function requireDataType() {
  if (hasRequiredDataType) return dataType;
  hasRequiredDataType = 1;
  Object.defineProperty(dataType, "__esModule", { value: true });
  dataType.reportTypeError = dataType.checkDataTypes = dataType.checkDataType = dataType.coerceAndCheckDataType = dataType.getJSONTypes = dataType.getSchemaTypes = dataType.DataType = void 0;
  const rules_1 = requireRules();
  const applicability_1 = requireApplicability();
  const errors_1 = requireErrors();
  const codegen_1 = requireCodegen();
  const util_1 = requireUtil();
  var DataType;
  (function(DataType2) {
    DataType2[DataType2["Correct"] = 0] = "Correct";
    DataType2[DataType2["Wrong"] = 1] = "Wrong";
  })(DataType || (dataType.DataType = DataType = {}));
  function getSchemaTypes(schema) {
    const types2 = getJSONTypes(schema.type);
    const hasNull = types2.includes("null");
    if (hasNull) {
      if (schema.nullable === false)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!types2.length && schema.nullable !== void 0) {
        throw new Error('"nullable" cannot be used without "type"');
      }
      if (schema.nullable === true)
        types2.push("null");
    }
    return types2;
  }
  dataType.getSchemaTypes = getSchemaTypes;
  function getJSONTypes(ts) {
    const types2 = Array.isArray(ts) ? ts : ts ? [ts] : [];
    if (types2.every(rules_1.isJSONType))
      return types2;
    throw new Error("type must be JSONType or JSONType[]: " + types2.join(","));
  }
  dataType.getJSONTypes = getJSONTypes;
  function coerceAndCheckDataType(it, types2) {
    const { gen, data: data2, opts } = it;
    const coerceTo = coerceToTypes(types2, opts.coerceTypes);
    const checkTypes = types2.length > 0 && !(coerceTo.length === 0 && types2.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types2[0]));
    if (checkTypes) {
      const wrongType = checkDataTypes(types2, data2, opts.strictNumbers, DataType.Wrong);
      gen.if(wrongType, () => {
        if (coerceTo.length)
          coerceData(it, types2, coerceTo);
        else
          reportTypeError(it);
      });
    }
    return checkTypes;
  }
  dataType.coerceAndCheckDataType = coerceAndCheckDataType;
  const COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
  function coerceToTypes(types2, coerceTypes) {
    return coerceTypes ? types2.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
  }
  function coerceData(it, types2, coerceTo) {
    const { gen, data: data2, opts } = it;
    const dataType2 = gen.let("dataType", (0, codegen_1._)`typeof ${data2}`);
    const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
    if (opts.coerceTypes === "array") {
      gen.if((0, codegen_1._)`${dataType2} == 'object' && Array.isArray(${data2}) && ${data2}.length == 1`, () => gen.assign(data2, (0, codegen_1._)`${data2}[0]`).assign(dataType2, (0, codegen_1._)`typeof ${data2}`).if(checkDataTypes(types2, data2, opts.strictNumbers), () => gen.assign(coerced, data2)));
    }
    gen.if((0, codegen_1._)`${coerced} !== undefined`);
    for (const t of coerceTo) {
      if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") {
        coerceSpecificType(t);
      }
    }
    gen.else();
    reportTypeError(it);
    gen.endIf();
    gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
      gen.assign(data2, coerced);
      assignParentData(it, coerced);
    });
    function coerceSpecificType(t) {
      switch (t) {
        case "string":
          gen.elseIf((0, codegen_1._)`${dataType2} == "number" || ${dataType2} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data2}`).elseIf((0, codegen_1._)`${data2} === null`).assign(coerced, (0, codegen_1._)`""`);
          return;
        case "number":
          gen.elseIf((0, codegen_1._)`${dataType2} == "boolean" || ${data2} === null
              || (${dataType2} == "string" && ${data2} && ${data2} == +${data2})`).assign(coerced, (0, codegen_1._)`+${data2}`);
          return;
        case "integer":
          gen.elseIf((0, codegen_1._)`${dataType2} === "boolean" || ${data2} === null
              || (${dataType2} === "string" && ${data2} && ${data2} == +${data2} && !(${data2} % 1))`).assign(coerced, (0, codegen_1._)`+${data2}`);
          return;
        case "boolean":
          gen.elseIf((0, codegen_1._)`${data2} === "false" || ${data2} === 0 || ${data2} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data2} === "true" || ${data2} === 1`).assign(coerced, true);
          return;
        case "null":
          gen.elseIf((0, codegen_1._)`${data2} === "" || ${data2} === 0 || ${data2} === false`);
          gen.assign(coerced, null);
          return;
        case "array":
          gen.elseIf((0, codegen_1._)`${dataType2} === "string" || ${dataType2} === "number"
              || ${dataType2} === "boolean" || ${data2} === null`).assign(coerced, (0, codegen_1._)`[${data2}]`);
      }
    }
  }
  function assignParentData({ gen, parentData, parentDataProperty }, expr) {
    gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
  }
  function checkDataType(dataType2, data2, strictNums, correct = DataType.Correct) {
    const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
    let cond;
    switch (dataType2) {
      case "null":
        return (0, codegen_1._)`${data2} ${EQ} null`;
      case "array":
        cond = (0, codegen_1._)`Array.isArray(${data2})`;
        break;
      case "object":
        cond = (0, codegen_1._)`${data2} && typeof ${data2} == "object" && !Array.isArray(${data2})`;
        break;
      case "integer":
        cond = numCond((0, codegen_1._)`!(${data2} % 1) && !isNaN(${data2})`);
        break;
      case "number":
        cond = numCond();
        break;
      default:
        return (0, codegen_1._)`typeof ${data2} ${EQ} ${dataType2}`;
    }
    return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
    function numCond(_cond = codegen_1.nil) {
      return (0, codegen_1.and)((0, codegen_1._)`typeof ${data2} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data2})` : codegen_1.nil);
    }
  }
  dataType.checkDataType = checkDataType;
  function checkDataTypes(dataTypes, data2, strictNums, correct) {
    if (dataTypes.length === 1) {
      return checkDataType(dataTypes[0], data2, strictNums, correct);
    }
    let cond;
    const types2 = (0, util_1.toHash)(dataTypes);
    if (types2.array && types2.object) {
      const notObj = (0, codegen_1._)`typeof ${data2} != "object"`;
      cond = types2.null ? notObj : (0, codegen_1._)`!${data2} || ${notObj}`;
      delete types2.null;
      delete types2.array;
      delete types2.object;
    } else {
      cond = codegen_1.nil;
    }
    if (types2.number)
      delete types2.integer;
    for (const t in types2)
      cond = (0, codegen_1.and)(cond, checkDataType(t, data2, strictNums, correct));
    return cond;
  }
  dataType.checkDataTypes = checkDataTypes;
  const typeError = {
    message: ({ schema }) => `must be ${schema}`,
    params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
  };
  function reportTypeError(it) {
    const cxt = getTypeErrorContext(it);
    (0, errors_1.reportError)(cxt, typeError);
  }
  dataType.reportTypeError = reportTypeError;
  function getTypeErrorContext(it) {
    const { gen, data: data2, schema } = it;
    const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
    return {
      gen,
      keyword: "type",
      data: data2,
      schema: schema.type,
      schemaCode,
      schemaValue: schemaCode,
      parentSchema: schema,
      params: {},
      it
    };
  }
  return dataType;
}
var defaults = {};
var hasRequiredDefaults;
function requireDefaults() {
  if (hasRequiredDefaults) return defaults;
  hasRequiredDefaults = 1;
  Object.defineProperty(defaults, "__esModule", { value: true });
  defaults.assignDefaults = void 0;
  const codegen_1 = requireCodegen();
  const util_1 = requireUtil();
  function assignDefaults(it, ty) {
    const { properties: properties2, items: items2 } = it.schema;
    if (ty === "object" && properties2) {
      for (const key in properties2) {
        assignDefault(it, key, properties2[key].default);
      }
    } else if (ty === "array" && Array.isArray(items2)) {
      items2.forEach((sch, i) => assignDefault(it, i, sch.default));
    }
  }
  defaults.assignDefaults = assignDefaults;
  function assignDefault(it, prop, defaultValue) {
    const { gen, compositeRule, data: data2, opts } = it;
    if (defaultValue === void 0)
      return;
    const childData = (0, codegen_1._)`${data2}${(0, codegen_1.getProperty)(prop)}`;
    if (compositeRule) {
      (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
      return;
    }
    let condition = (0, codegen_1._)`${childData} === undefined`;
    if (opts.useDefaults === "empty") {
      condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
    }
    gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
  }
  return defaults;
}
var keyword = {};
var code = {};
var hasRequiredCode;
function requireCode() {
  if (hasRequiredCode) return code;
  hasRequiredCode = 1;
  Object.defineProperty(code, "__esModule", { value: true });
  code.validateUnion = code.validateArray = code.usePattern = code.callValidateCode = code.schemaProperties = code.allSchemaProperties = code.noPropertyInData = code.propertyInData = code.isOwnProperty = code.hasPropFunc = code.reportMissingProp = code.checkMissingProp = code.checkReportMissingProp = void 0;
  const codegen_1 = requireCodegen();
  const util_1 = requireUtil();
  const names_1 = requireNames();
  const util_2 = requireUtil();
  function checkReportMissingProp(cxt, prop) {
    const { gen, data: data2, it } = cxt;
    gen.if(noPropertyInData(gen, data2, prop, it.opts.ownProperties), () => {
      cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
      cxt.error();
    });
  }
  code.checkReportMissingProp = checkReportMissingProp;
  function checkMissingProp({ gen, data: data2, it: { opts } }, properties2, missing) {
    return (0, codegen_1.or)(...properties2.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data2, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
  }
  code.checkMissingProp = checkMissingProp;
  function reportMissingProp(cxt, missing) {
    cxt.setParams({ missingProperty: missing }, true);
    cxt.error();
  }
  code.reportMissingProp = reportMissingProp;
  function hasPropFunc(gen) {
    return gen.scopeValue("func", {
      // eslint-disable-next-line @typescript-eslint/unbound-method
      ref: Object.prototype.hasOwnProperty,
      code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
    });
  }
  code.hasPropFunc = hasPropFunc;
  function isOwnProperty(gen, data2, property) {
    return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data2}, ${property})`;
  }
  code.isOwnProperty = isOwnProperty;
  function propertyInData(gen, data2, property, ownProperties) {
    const cond = (0, codegen_1._)`${data2}${(0, codegen_1.getProperty)(property)} !== undefined`;
    return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data2, property)}` : cond;
  }
  code.propertyInData = propertyInData;
  function noPropertyInData(gen, data2, property, ownProperties) {
    const cond = (0, codegen_1._)`${data2}${(0, codegen_1.getProperty)(property)} === undefined`;
    return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data2, property))) : cond;
  }
  code.noPropertyInData = noPropertyInData;
  function allSchemaProperties(schemaMap) {
    return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
  }
  code.allSchemaProperties = allSchemaProperties;
  function schemaProperties(it, schemaMap) {
    return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
  }
  code.schemaProperties = schemaProperties;
  function callValidateCode({ schemaCode, data: data2, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
    const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data2}, ${topSchemaRef}${schemaPath}` : data2;
    const valCxt = [
      [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
      [names_1.default.parentData, it.parentData],
      [names_1.default.parentDataProperty, it.parentDataProperty],
      [names_1.default.rootData, names_1.default.rootData]
    ];
    if (it.opts.dynamicRef)
      valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
    const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
    return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
  }
  code.callValidateCode = callValidateCode;
  const newRegExp = (0, codegen_1._)`new RegExp`;
  function usePattern({ gen, it: { opts } }, pattern2) {
    const u = opts.unicodeRegExp ? "u" : "";
    const { regExp } = opts.code;
    const rx = regExp(pattern2, u);
    return gen.scopeValue("pattern", {
      key: rx.toString(),
      ref: rx,
      code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern2}, ${u})`
    });
  }
  code.usePattern = usePattern;
  function validateArray(cxt) {
    const { gen, data: data2, keyword: keyword2, it } = cxt;
    const valid = gen.name("valid");
    if (it.allErrors) {
      const validArr = gen.let("valid", true);
      validateItems2(() => gen.assign(validArr, false));
      return validArr;
    }
    gen.var(valid, true);
    validateItems2(() => gen.break());
    return valid;
    function validateItems2(notValid) {
      const len = gen.const("len", (0, codegen_1._)`${data2}.length`);
      gen.forRange("i", 0, len, (i) => {
        cxt.subschema({
          keyword: keyword2,
          dataProp: i,
          dataPropType: util_1.Type.Num
        }, valid);
        gen.if((0, codegen_1.not)(valid), notValid);
      });
    }
  }
  code.validateArray = validateArray;
  function validateUnion(cxt) {
    const { gen, schema, keyword: keyword2, it } = cxt;
    if (!Array.isArray(schema))
      throw new Error("ajv implementation error");
    const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
    if (alwaysValid && !it.opts.unevaluated)
      return;
    const valid = gen.let("valid", false);
    const schValid = gen.name("_valid");
    gen.block(() => schema.forEach((_sch, i) => {
      const schCxt = cxt.subschema({
        keyword: keyword2,
        schemaProp: i,
        compositeRule: true
      }, schValid);
      gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
      const merged = cxt.mergeValidEvaluated(schCxt, schValid);
      if (!merged)
        gen.if((0, codegen_1.not)(valid));
    }));
    cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
  }
  code.validateUnion = validateUnion;
  return code;
}
var hasRequiredKeyword;
function requireKeyword() {
  if (hasRequiredKeyword) return keyword;
  hasRequiredKeyword = 1;
  Object.defineProperty(keyword, "__esModule", { value: true });
  keyword.validateKeywordUsage = keyword.validSchemaType = keyword.funcKeywordCode = keyword.macroKeywordCode = void 0;
  const codegen_1 = requireCodegen();
  const names_1 = requireNames();
  const code_1 = requireCode();
  const errors_1 = requireErrors();
  function macroKeywordCode(cxt, def) {
    const { gen, keyword: keyword2, schema, parentSchema, it } = cxt;
    const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
    const schemaRef = useKeyword(gen, keyword2, macroSchema);
    if (it.opts.validateSchema !== false)
      it.self.validateSchema(macroSchema, true);
    const valid = gen.name("valid");
    cxt.subschema({
      schema: macroSchema,
      schemaPath: codegen_1.nil,
      errSchemaPath: `${it.errSchemaPath}/${keyword2}`,
      topSchemaRef: schemaRef,
      compositeRule: true
    }, valid);
    cxt.pass(valid, () => cxt.error(true));
  }
  keyword.macroKeywordCode = macroKeywordCode;
  function funcKeywordCode(cxt, def) {
    var _a;
    const { gen, keyword: keyword2, schema, parentSchema, $data, it } = cxt;
    checkAsyncKeyword(it, def);
    const validate2 = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
    const validateRef = useKeyword(gen, keyword2, validate2);
    const valid = gen.let("valid");
    cxt.block$data(valid, validateKeyword);
    cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
    function validateKeyword() {
      if (def.errors === false) {
        assignValid();
        if (def.modifying)
          modifyData(cxt);
        reportErrs(() => cxt.error());
      } else {
        const ruleErrs = def.async ? validateAsync() : validateSync();
        if (def.modifying)
          modifyData(cxt);
        reportErrs(() => addErrs(cxt, ruleErrs));
      }
    }
    function validateAsync() {
      const ruleErrs = gen.let("ruleErrs", null);
      gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));
      return ruleErrs;
    }
    function validateSync() {
      const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
      gen.assign(validateErrs, null);
      assignValid(codegen_1.nil);
      return validateErrs;
    }
    function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
      const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
      const passSchema = !("compile" in def && !$data || def.schema === false);
      gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
    }
    function reportErrs(errors2) {
      var _a2;
      gen.if((0, codegen_1.not)((_a2 = def.valid) !== null && _a2 !== void 0 ? _a2 : valid), errors2);
    }
  }
  keyword.funcKeywordCode = funcKeywordCode;
  function modifyData(cxt) {
    const { gen, data: data2, it } = cxt;
    gen.if(it.parentData, () => gen.assign(data2, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
  }
  function addErrs(cxt, errs) {
    const { gen } = cxt;
    gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
      gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      (0, errors_1.extendErrors)(cxt);
    }, () => cxt.error());
  }
  function checkAsyncKeyword({ schemaEnv }, def) {
    if (def.async && !schemaEnv.$async)
      throw new Error("async keyword in sync schema");
  }
  function useKeyword(gen, keyword2, result) {
    if (result === void 0)
      throw new Error(`keyword "${keyword2}" failed to compile`);
    return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
  }
  function validSchemaType(schema, schemaType, allowUndefined = false) {
    return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
  }
  keyword.validSchemaType = validSchemaType;
  function validateKeywordUsage({ schema, opts, self: self2, errSchemaPath }, def, keyword2) {
    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword2) : def.keyword !== keyword2) {
      throw new Error("ajv implementation error");
    }
    const deps = def.dependencies;
    if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
      throw new Error(`parent schema must have dependencies of ${keyword2}: ${deps.join(",")}`);
    }
    if (def.validateSchema) {
      const valid = def.validateSchema(schema[keyword2]);
      if (!valid) {
        const msg = `keyword "${keyword2}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def.validateSchema.errors);
        if (opts.validateSchema === "log")
          self2.logger.error(msg);
        else
          throw new Error(msg);
      }
    }
  }
  keyword.validateKeywordUsage = validateKeywordUsage;
  return keyword;
}
var subschema = {};
var hasRequiredSubschema;
function requireSubschema() {
  if (hasRequiredSubschema) return subschema;
  hasRequiredSubschema = 1;
  Object.defineProperty(subschema, "__esModule", { value: true });
  subschema.extendSubschemaMode = subschema.extendSubschemaData = subschema.getSubschema = void 0;
  const codegen_1 = requireCodegen();
  const util_1 = requireUtil();
  function getSubschema(it, { keyword: keyword2, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
    if (keyword2 !== void 0 && schema !== void 0) {
      throw new Error('both "keyword" and "schema" passed, only one allowed');
    }
    if (keyword2 !== void 0) {
      const sch = it.schema[keyword2];
      return schemaProp === void 0 ? {
        schema: sch,
        schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword2)}`,
        errSchemaPath: `${it.errSchemaPath}/${keyword2}`
      } : {
        schema: sch[schemaProp],
        schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword2)}${(0, codegen_1.getProperty)(schemaProp)}`,
        errSchemaPath: `${it.errSchemaPath}/${keyword2}/${(0, util_1.escapeFragment)(schemaProp)}`
      };
    }
    if (schema !== void 0) {
      if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
        throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
      }
      return {
        schema,
        schemaPath,
        topSchemaRef,
        errSchemaPath
      };
    }
    throw new Error('either "keyword" or "schema" must be passed');
  }
  subschema.getSubschema = getSubschema;
  function extendSubschemaData(subschema2, it, { dataProp, dataPropType: dpType, data: data2, dataTypes, propertyName }) {
    if (data2 !== void 0 && dataProp !== void 0) {
      throw new Error('both "data" and "dataProp" passed, only one allowed');
    }
    const { gen } = it;
    if (dataProp !== void 0) {
      const { errorPath, dataPathArr, opts } = it;
      const nextData = gen.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
      dataContextProps(nextData);
      subschema2.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
      subschema2.parentDataProperty = (0, codegen_1._)`${dataProp}`;
      subschema2.dataPathArr = [...dataPathArr, subschema2.parentDataProperty];
    }
    if (data2 !== void 0) {
      const nextData = data2 instanceof codegen_1.Name ? data2 : gen.let("data", data2, true);
      dataContextProps(nextData);
      if (propertyName !== void 0)
        subschema2.propertyName = propertyName;
    }
    if (dataTypes)
      subschema2.dataTypes = dataTypes;
    function dataContextProps(_nextData) {
      subschema2.data = _nextData;
      subschema2.dataLevel = it.dataLevel + 1;
      subschema2.dataTypes = [];
      it.definedProperties = /* @__PURE__ */ new Set();
      subschema2.parentData = it.data;
      subschema2.dataNames = [...it.dataNames, _nextData];
    }
  }
  subschema.extendSubschemaData = extendSubschemaData;
  function extendSubschemaMode(subschema2, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
    if (compositeRule !== void 0)
      subschema2.compositeRule = compositeRule;
    if (createErrors !== void 0)
      subschema2.createErrors = createErrors;
    if (allErrors !== void 0)
      subschema2.allErrors = allErrors;
    subschema2.jtdDiscriminator = jtdDiscriminator;
    subschema2.jtdMetadata = jtdMetadata;
  }
  subschema.extendSubschemaMode = extendSubschemaMode;
  return subschema;
}
var resolve = {};
var fastDeepEqual;
var hasRequiredFastDeepEqual;
function requireFastDeepEqual() {
  if (hasRequiredFastDeepEqual) return fastDeepEqual;
  hasRequiredFastDeepEqual = 1;
  fastDeepEqual = function equal2(a, b) {
    if (a === b) return true;
    if (a && b && typeof a == "object" && typeof b == "object") {
      if (a.constructor !== b.constructor) return false;
      var length, i, keys;
      if (Array.isArray(a)) {
        length = a.length;
        if (length != b.length) return false;
        for (i = length; i-- !== 0; )
          if (!equal2(a[i], b[i])) return false;
        return true;
      }
      if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
      if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
      if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
      keys = Object.keys(a);
      length = keys.length;
      if (length !== Object.keys(b).length) return false;
      for (i = length; i-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
      for (i = length; i-- !== 0; ) {
        var key = keys[i];
        if (!equal2(a[key], b[key])) return false;
      }
      return true;
    }
    return a !== a && b !== b;
  };
  return fastDeepEqual;
}
var jsonSchemaTraverse = { exports: {} };
var hasRequiredJsonSchemaTraverse;
function requireJsonSchemaTraverse() {
  if (hasRequiredJsonSchemaTraverse) return jsonSchemaTraverse.exports;
  hasRequiredJsonSchemaTraverse = 1;
  var traverse = jsonSchemaTraverse.exports = function(schema, opts, cb) {
    if (typeof opts == "function") {
      cb = opts;
      opts = {};
    }
    cb = opts.cb || cb;
    var pre = typeof cb == "function" ? cb : cb.pre || function() {
    };
    var post = cb.post || function() {
    };
    _traverse(opts, pre, post, schema, "", schema);
  };
  traverse.keywords = {
    additionalItems: true,
    items: true,
    contains: true,
    additionalProperties: true,
    propertyNames: true,
    not: true,
    if: true,
    then: true,
    else: true
  };
  traverse.arrayKeywords = {
    items: true,
    allOf: true,
    anyOf: true,
    oneOf: true
  };
  traverse.propsKeywords = {
    $defs: true,
    definitions: true,
    properties: true,
    patternProperties: true,
    dependencies: true
  };
  traverse.skipKeywords = {
    default: true,
    enum: true,
    const: true,
    required: true,
    maximum: true,
    minimum: true,
    exclusiveMaximum: true,
    exclusiveMinimum: true,
    multipleOf: true,
    maxLength: true,
    minLength: true,
    pattern: true,
    format: true,
    maxItems: true,
    minItems: true,
    uniqueItems: true,
    maxProperties: true,
    minProperties: true
  };
  function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
    if (schema && typeof schema == "object" && !Array.isArray(schema)) {
      pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      for (var key in schema) {
        var sch = schema[key];
        if (Array.isArray(sch)) {
          if (key in traverse.arrayKeywords) {
            for (var i = 0; i < sch.length; i++)
              _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
          }
        } else if (key in traverse.propsKeywords) {
          if (sch && typeof sch == "object") {
            for (var prop in sch)
              _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
          }
        } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
          _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
        }
      }
      post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    }
  }
  function escapeJsonPtr(str) {
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  return jsonSchemaTraverse.exports;
}
var hasRequiredResolve;
function requireResolve() {
  if (hasRequiredResolve) return resolve;
  hasRequiredResolve = 1;
  Object.defineProperty(resolve, "__esModule", { value: true });
  resolve.getSchemaRefs = resolve.resolveUrl = resolve.normalizeId = resolve._getFullPath = resolve.getFullPath = resolve.inlineRef = void 0;
  const util_1 = requireUtil();
  const equal2 = requireFastDeepEqual();
  const traverse = requireJsonSchemaTraverse();
  const SIMPLE_INLINED = /* @__PURE__ */ new Set([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum",
    "const"
  ]);
  function inlineRef(schema, limit = true) {
    if (typeof schema == "boolean")
      return true;
    if (limit === true)
      return !hasRef(schema);
    if (!limit)
      return false;
    return countKeys(schema) <= limit;
  }
  resolve.inlineRef = inlineRef;
  const REF_KEYWORDS = /* @__PURE__ */ new Set([
    "$ref",
    "$recursiveRef",
    "$recursiveAnchor",
    "$dynamicRef",
    "$dynamicAnchor"
  ]);
  function hasRef(schema) {
    for (const key in schema) {
      if (REF_KEYWORDS.has(key))
        return true;
      const sch = schema[key];
      if (Array.isArray(sch) && sch.some(hasRef))
        return true;
      if (typeof sch == "object" && hasRef(sch))
        return true;
    }
    return false;
  }
  function countKeys(schema) {
    let count = 0;
    for (const key in schema) {
      if (key === "$ref")
        return Infinity;
      count++;
      if (SIMPLE_INLINED.has(key))
        continue;
      if (typeof schema[key] == "object") {
        (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));
      }
      if (count === Infinity)
        return Infinity;
    }
    return count;
  }
  function getFullPath(resolver, id2 = "", normalize) {
    if (normalize !== false)
      id2 = normalizeId(id2);
    const p = resolver.parse(id2);
    return _getFullPath(resolver, p);
  }
  resolve.getFullPath = getFullPath;
  function _getFullPath(resolver, p) {
    const serialized = resolver.serialize(p);
    return serialized.split("#")[0] + "#";
  }
  resolve._getFullPath = _getFullPath;
  const TRAILING_SLASH_HASH = /#\/?$/;
  function normalizeId(id2) {
    return id2 ? id2.replace(TRAILING_SLASH_HASH, "") : "";
  }
  resolve.normalizeId = normalizeId;
  function resolveUrl(resolver, baseId, id2) {
    id2 = normalizeId(id2);
    return resolver.resolve(baseId, id2);
  }
  resolve.resolveUrl = resolveUrl;
  const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
  function getSchemaRefs(schema, baseId) {
    if (typeof schema == "boolean")
      return {};
    const { schemaId, uriResolver } = this.opts;
    const schId = normalizeId(schema[schemaId] || baseId);
    const baseIds = { "": schId };
    const pathPrefix = getFullPath(uriResolver, schId, false);
    const localRefs = {};
    const schemaRefs = /* @__PURE__ */ new Set();
    traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
      if (parentJsonPtr === void 0)
        return;
      const fullPath = pathPrefix + jsonPtr;
      let innerBaseId = baseIds[parentJsonPtr];
      if (typeof sch[schemaId] == "string")
        innerBaseId = addRef.call(this, sch[schemaId]);
      addAnchor.call(this, sch.$anchor);
      addAnchor.call(this, sch.$dynamicAnchor);
      baseIds[jsonPtr] = innerBaseId;
      function addRef(ref2) {
        const _resolve = this.opts.uriResolver.resolve;
        ref2 = normalizeId(innerBaseId ? _resolve(innerBaseId, ref2) : ref2);
        if (schemaRefs.has(ref2))
          throw ambiguos(ref2);
        schemaRefs.add(ref2);
        let schOrRef = this.refs[ref2];
        if (typeof schOrRef == "string")
          schOrRef = this.refs[schOrRef];
        if (typeof schOrRef == "object") {
          checkAmbiguosRef(sch, schOrRef.schema, ref2);
        } else if (ref2 !== normalizeId(fullPath)) {
          if (ref2[0] === "#") {
            checkAmbiguosRef(sch, localRefs[ref2], ref2);
            localRefs[ref2] = sch;
          } else {
            this.refs[ref2] = fullPath;
          }
        }
        return ref2;
      }
      function addAnchor(anchor) {
        if (typeof anchor == "string") {
          if (!ANCHOR.test(anchor))
            throw new Error(`invalid anchor "${anchor}"`);
          addRef.call(this, `#${anchor}`);
        }
      }
    });
    return localRefs;
    function checkAmbiguosRef(sch1, sch2, ref2) {
      if (sch2 !== void 0 && !equal2(sch1, sch2))
        throw ambiguos(ref2);
    }
    function ambiguos(ref2) {
      return new Error(`reference "${ref2}" resolves to more than one schema`);
    }
  }
  resolve.getSchemaRefs = getSchemaRefs;
  return resolve;
}
var hasRequiredValidate;
function requireValidate() {
  if (hasRequiredValidate) return validate;
  hasRequiredValidate = 1;
  Object.defineProperty(validate, "__esModule", { value: true });
  validate.getData = validate.KeywordCxt = validate.validateFunctionCode = void 0;
  const boolSchema_1 = requireBoolSchema();
  const dataType_1 = requireDataType();
  const applicability_1 = requireApplicability();
  const dataType_2 = requireDataType();
  const defaults_1 = requireDefaults();
  const keyword_1 = requireKeyword();
  const subschema_1 = requireSubschema();
  const codegen_1 = requireCodegen();
  const names_1 = requireNames();
  const resolve_1 = requireResolve();
  const util_1 = requireUtil();
  const errors_1 = requireErrors();
  function validateFunctionCode(it) {
    if (isSchemaObj(it)) {
      checkKeywords(it);
      if (schemaCxtHasRules(it)) {
        topSchemaObjCode(it);
        return;
      }
    }
    validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
  }
  validate.validateFunctionCode = validateFunctionCode;
  function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
    if (opts.code.es5) {
      gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
        gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
        destructureValCxtES5(gen, opts);
        gen.code(body);
      });
    } else {
      gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
    }
  }
  function destructureValCxt(opts) {
    return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
  }
  function destructureValCxtES5(gen, opts) {
    gen.if(names_1.default.valCxt, () => {
      gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
      gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
      gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
      gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
      if (opts.dynamicRef)
        gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
    }, () => {
      gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
      gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
      gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
      gen.var(names_1.default.rootData, names_1.default.data);
      if (opts.dynamicRef)
        gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
    });
  }
  function topSchemaObjCode(it) {
    const { schema, opts, gen } = it;
    validateFunction(it, () => {
      if (opts.$comment && schema.$comment)
        commentKeyword(it);
      checkNoDefault(it);
      gen.let(names_1.default.vErrors, null);
      gen.let(names_1.default.errors, 0);
      if (opts.unevaluated)
        resetEvaluated(it);
      typeAndKeywords(it);
      returnResults(it);
    });
    return;
  }
  function resetEvaluated(it) {
    const { gen, validateName } = it;
    it.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
    gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));
    gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
  }
  function funcSourceUrl(schema, opts) {
    const schId = typeof schema == "object" && schema[opts.schemaId];
    return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
  }
  function subschemaCode(it, valid) {
    if (isSchemaObj(it)) {
      checkKeywords(it);
      if (schemaCxtHasRules(it)) {
        subSchemaObjCode(it, valid);
        return;
      }
    }
    (0, boolSchema_1.boolOrEmptySchema)(it, valid);
  }
  function schemaCxtHasRules({ schema, self: self2 }) {
    if (typeof schema == "boolean")
      return !schema;
    for (const key in schema)
      if (self2.RULES.all[key])
        return true;
    return false;
  }
  function isSchemaObj(it) {
    return typeof it.schema != "boolean";
  }
  function subSchemaObjCode(it, valid) {
    const { schema, gen, opts } = it;
    if (opts.$comment && schema.$comment)
      commentKeyword(it);
    updateContext(it);
    checkAsyncSchema(it);
    const errsCount = gen.const("_errs", names_1.default.errors);
    typeAndKeywords(it, errsCount);
    gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
  }
  function checkKeywords(it) {
    (0, util_1.checkUnknownRules)(it);
    checkRefsAndKeywords(it);
  }
  function typeAndKeywords(it, errsCount) {
    if (it.opts.jtd)
      return schemaKeywords(it, [], false, errsCount);
    const types2 = (0, dataType_1.getSchemaTypes)(it.schema);
    const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types2);
    schemaKeywords(it, types2, !checkedTypes, errsCount);
  }
  function checkRefsAndKeywords(it) {
    const { schema, errSchemaPath, opts, self: self2 } = it;
    if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self2.RULES)) {
      self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
    }
  }
  function checkNoDefault(it) {
    const { schema, opts } = it;
    if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
      (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
    }
  }
  function updateContext(it) {
    const schId = it.schema[it.opts.schemaId];
    if (schId)
      it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
  }
  function checkAsyncSchema(it) {
    if (it.schema.$async && !it.schemaEnv.$async)
      throw new Error("async schema in sync schema");
  }
  function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
    const msg = schema.$comment;
    if (opts.$comment === true) {
      gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
    } else if (typeof opts.$comment == "function") {
      const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
      const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
      gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
    }
  }
  function returnResults(it) {
    const { gen, schemaEnv, validateName, ValidationError, opts } = it;
    if (schemaEnv.$async) {
      gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
    } else {
      gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
      if (opts.unevaluated)
        assignEvaluated(it);
      gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
    }
  }
  function assignEvaluated({ gen, evaluated, props, items: items2 }) {
    if (props instanceof codegen_1.Name)
      gen.assign((0, codegen_1._)`${evaluated}.props`, props);
    if (items2 instanceof codegen_1.Name)
      gen.assign((0, codegen_1._)`${evaluated}.items`, items2);
  }
  function schemaKeywords(it, types2, typeErrors, errsCount) {
    const { gen, schema, data: data2, allErrors, opts, self: self2 } = it;
    const { RULES } = self2;
    if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
      gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
      return;
    }
    if (!opts.jtd)
      checkStrictTypes(it, types2);
    gen.block(() => {
      for (const group of RULES.rules)
        groupKeywords(group);
      groupKeywords(RULES.post);
    });
    function groupKeywords(group) {
      if (!(0, applicability_1.shouldUseGroup)(schema, group))
        return;
      if (group.type) {
        gen.if((0, dataType_2.checkDataType)(group.type, data2, opts.strictNumbers));
        iterateKeywords(it, group);
        if (types2.length === 1 && types2[0] === group.type && typeErrors) {
          gen.else();
          (0, dataType_2.reportTypeError)(it);
        }
        gen.endIf();
      } else {
        iterateKeywords(it, group);
      }
      if (!allErrors)
        gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
    }
  }
  function iterateKeywords(it, group) {
    const { gen, schema, opts: { useDefaults } } = it;
    if (useDefaults)
      (0, defaults_1.assignDefaults)(it, group.type);
    gen.block(() => {
      for (const rule of group.rules) {
        if ((0, applicability_1.shouldUseRule)(schema, rule)) {
          keywordCode(it, rule.keyword, rule.definition, group.type);
        }
      }
    });
  }
  function checkStrictTypes(it, types2) {
    if (it.schemaEnv.meta || !it.opts.strictTypes)
      return;
    checkContextTypes(it, types2);
    if (!it.opts.allowUnionTypes)
      checkMultipleTypes(it, types2);
    checkKeywordTypes(it, it.dataTypes);
  }
  function checkContextTypes(it, types2) {
    if (!types2.length)
      return;
    if (!it.dataTypes.length) {
      it.dataTypes = types2;
      return;
    }
    types2.forEach((t) => {
      if (!includesType(it.dataTypes, t)) {
        strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
      }
    });
    narrowSchemaTypes(it, types2);
  }
  function checkMultipleTypes(it, ts) {
    if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
      strictTypesError(it, "use allowUnionTypes to allow union type keyword");
    }
  }
  function checkKeywordTypes(it, ts) {
    const rules2 = it.self.RULES.all;
    for (const keyword2 in rules2) {
      const rule = rules2[keyword2];
      if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
        const { type: type2 } = rule.definition;
        if (type2.length && !type2.some((t) => hasApplicableType(ts, t))) {
          strictTypesError(it, `missing type "${type2.join(",")}" for keyword "${keyword2}"`);
        }
      }
    }
  }
  function hasApplicableType(schTs, kwdT) {
    return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
  }
  function includesType(ts, t) {
    return ts.includes(t) || t === "integer" && ts.includes("number");
  }
  function narrowSchemaTypes(it, withTypes) {
    const ts = [];
    for (const t of it.dataTypes) {
      if (includesType(withTypes, t))
        ts.push(t);
      else if (withTypes.includes("integer") && t === "number")
        ts.push("integer");
    }
    it.dataTypes = ts;
  }
  function strictTypesError(it, msg) {
    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
    msg += ` at "${schemaPath}" (strictTypes)`;
    (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
  }
  class KeywordCxt {
    constructor(it, def, keyword2) {
      (0, keyword_1.validateKeywordUsage)(it, def, keyword2);
      this.gen = it.gen;
      this.allErrors = it.allErrors;
      this.keyword = keyword2;
      this.data = it.data;
      this.schema = it.schema[keyword2];
      this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
      this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword2, this.$data);
      this.schemaType = def.schemaType;
      this.parentSchema = it.schema;
      this.params = {};
      this.it = it;
      this.def = def;
      if (this.$data) {
        this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
      } else {
        this.schemaCode = this.schemaValue;
        if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
          throw new Error(`${keyword2} value must be ${JSON.stringify(def.schemaType)}`);
        }
      }
      if ("code" in def ? def.trackErrors : def.errors !== false) {
        this.errsCount = it.gen.const("_errs", names_1.default.errors);
      }
    }
    result(condition, successAction, failAction) {
      this.failResult((0, codegen_1.not)(condition), successAction, failAction);
    }
    failResult(condition, successAction, failAction) {
      this.gen.if(condition);
      if (failAction)
        failAction();
      else
        this.error();
      if (successAction) {
        this.gen.else();
        successAction();
        if (this.allErrors)
          this.gen.endIf();
      } else {
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
    }
    pass(condition, failAction) {
      this.failResult((0, codegen_1.not)(condition), void 0, failAction);
    }
    fail(condition) {
      if (condition === void 0) {
        this.error();
        if (!this.allErrors)
          this.gen.if(false);
        return;
      }
      this.gen.if(condition);
      this.error();
      if (this.allErrors)
        this.gen.endIf();
      else
        this.gen.else();
    }
    fail$data(condition) {
      if (!this.$data)
        return this.fail(condition);
      const { schemaCode } = this;
      this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
    }
    error(append, errorParams, errorPaths) {
      if (errorParams) {
        this.setParams(errorParams);
        this._error(append, errorPaths);
        this.setParams({});
        return;
      }
      this._error(append, errorPaths);
    }
    _error(append, errorPaths) {
      (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
    }
    $dataError() {
      (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
    }
    reset() {
      if (this.errsCount === void 0)
        throw new Error('add "trackErrors" to keyword definition');
      (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
    }
    ok(cond) {
      if (!this.allErrors)
        this.gen.if(cond);
    }
    setParams(obj, assign) {
      if (assign)
        Object.assign(this.params, obj);
      else
        this.params = obj;
    }
    block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
      this.gen.block(() => {
        this.check$data(valid, $dataValid);
        codeBlock();
      });
    }
    check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
      if (!this.$data)
        return;
      const { gen, schemaCode, schemaType, def } = this;
      gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
      if (valid !== codegen_1.nil)
        gen.assign(valid, true);
      if (schemaType.length || def.validateSchema) {
        gen.elseIf(this.invalid$data());
        this.$dataError();
        if (valid !== codegen_1.nil)
          gen.assign(valid, false);
      }
      gen.else();
    }
    invalid$data() {
      const { gen, schemaCode, schemaType, def, it } = this;
      return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
      function wrong$DataType() {
        if (schemaType.length) {
          if (!(schemaCode instanceof codegen_1.Name))
            throw new Error("ajv implementation error");
          const st = Array.isArray(schemaType) ? schemaType : [schemaType];
          return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
        }
        return codegen_1.nil;
      }
      function invalid$DataSchema() {
        if (def.validateSchema) {
          const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
          return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
        }
        return codegen_1.nil;
      }
    }
    subschema(appl, valid) {
      const subschema2 = (0, subschema_1.getSubschema)(this.it, appl);
      (0, subschema_1.extendSubschemaData)(subschema2, this.it, appl);
      (0, subschema_1.extendSubschemaMode)(subschema2, appl);
      const nextContext = { ...this.it, ...subschema2, items: void 0, props: void 0 };
      subschemaCode(nextContext, valid);
      return nextContext;
    }
    mergeEvaluated(schemaCxt, toName) {
      const { it, gen } = this;
      if (!it.opts.unevaluated)
        return;
      if (it.props !== true && schemaCxt.props !== void 0) {
        it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
      }
      if (it.items !== true && schemaCxt.items !== void 0) {
        it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
      }
    }
    mergeValidEvaluated(schemaCxt, valid) {
      const { it, gen } = this;
      if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
        gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
        return true;
      }
    }
  }
  validate.KeywordCxt = KeywordCxt;
  function keywordCode(it, keyword2, def, ruleType) {
    const cxt = new KeywordCxt(it, def, keyword2);
    if ("code" in def) {
      def.code(cxt, ruleType);
    } else if (cxt.$data && def.validate) {
      (0, keyword_1.funcKeywordCode)(cxt, def);
    } else if ("macro" in def) {
      (0, keyword_1.macroKeywordCode)(cxt, def);
    } else if (def.compile || def.validate) {
      (0, keyword_1.funcKeywordCode)(cxt, def);
    }
  }
  const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
  const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
  function getData($data, { dataLevel, dataNames, dataPathArr }) {
    let jsonPointer;
    let data2;
    if ($data === "")
      return names_1.default.rootData;
    if ($data[0] === "/") {
      if (!JSON_POINTER.test($data))
        throw new Error(`Invalid JSON-pointer: ${$data}`);
      jsonPointer = $data;
      data2 = names_1.default.rootData;
    } else {
      const matches = RELATIVE_JSON_POINTER.exec($data);
      if (!matches)
        throw new Error(`Invalid JSON-pointer: ${$data}`);
      const up = +matches[1];
      jsonPointer = matches[2];
      if (jsonPointer === "#") {
        if (up >= dataLevel)
          throw new Error(errorMsg("property/index", up));
        return dataPathArr[dataLevel - up];
      }
      if (up > dataLevel)
        throw new Error(errorMsg("data", up));
      data2 = dataNames[dataLevel - up];
      if (!jsonPointer)
        return data2;
    }
    let expr = data2;
    const segments = jsonPointer.split("/");
    for (const segment of segments) {
      if (segment) {
        data2 = (0, codegen_1._)`${data2}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
        expr = (0, codegen_1._)`${expr} && ${data2}`;
      }
    }
    return expr;
    function errorMsg(pointerType, up) {
      return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
    }
  }
  validate.getData = getData;
  return validate;
}
var validation_error = {};
var hasRequiredValidation_error;
function requireValidation_error() {
  if (hasRequiredValidation_error) return validation_error;
  hasRequiredValidation_error = 1;
  Object.defineProperty(validation_error, "__esModule", { value: true });
  class ValidationError extends Error {
    constructor(errors2) {
      super("validation failed");
      this.errors = errors2;
      this.ajv = this.validation = true;
    }
  }
  validation_error.default = ValidationError;
  return validation_error;
}
var ref_error = {};
var hasRequiredRef_error;
function requireRef_error() {
  if (hasRequiredRef_error) return ref_error;
  hasRequiredRef_error = 1;
  Object.defineProperty(ref_error, "__esModule", { value: true });
  const resolve_1 = requireResolve();
  class MissingRefError extends Error {
    constructor(resolver, baseId, ref2, msg) {
      super(msg || `can't resolve reference ${ref2} from id ${baseId}`);
      this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref2);
      this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
    }
  }
  ref_error.default = MissingRefError;
  return ref_error;
}
var compile = {};
var hasRequiredCompile;
function requireCompile() {
  if (hasRequiredCompile) return compile;
  hasRequiredCompile = 1;
  Object.defineProperty(compile, "__esModule", { value: true });
  compile.resolveSchema = compile.getCompilingSchema = compile.resolveRef = compile.compileSchema = compile.SchemaEnv = void 0;
  const codegen_1 = requireCodegen();
  const validation_error_1 = requireValidation_error();
  const names_1 = requireNames();
  const resolve_1 = requireResolve();
  const util_1 = requireUtil();
  const validate_1 = requireValidate();
  class SchemaEnv {
    constructor(env) {
      var _a;
      this.refs = {};
      this.dynamicAnchors = {};
      let schema;
      if (typeof env.schema == "object")
        schema = env.schema;
      this.schema = env.schema;
      this.schemaId = env.schemaId;
      this.root = env.root || this;
      this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
      this.schemaPath = env.schemaPath;
      this.localRefs = env.localRefs;
      this.meta = env.meta;
      this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
      this.refs = {};
    }
  }
  compile.SchemaEnv = SchemaEnv;
  function compileSchema(sch) {
    const _sch = getCompilingSchema.call(this, sch);
    if (_sch)
      return _sch;
    const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
    const { es5, lines } = this.opts.code;
    const { ownProperties } = this.opts;
    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
    let _ValidationError;
    if (sch.$async) {
      _ValidationError = gen.scopeValue("Error", {
        ref: validation_error_1.default,
        code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
      });
    }
    const validateName = gen.scopeName("validate");
    sch.validateName = validateName;
    const schemaCxt = {
      gen,
      allErrors: this.opts.allErrors,
      data: names_1.default.data,
      parentData: names_1.default.parentData,
      parentDataProperty: names_1.default.parentDataProperty,
      dataNames: [names_1.default.data],
      dataPathArr: [codegen_1.nil],
      // TODO can its length be used as dataLevel if nil is removed?
      dataLevel: 0,
      dataTypes: [],
      definedProperties: /* @__PURE__ */ new Set(),
      topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
      validateName,
      ValidationError: _ValidationError,
      schema: sch.schema,
      schemaEnv: sch,
      rootId,
      baseId: sch.baseId || rootId,
      schemaPath: codegen_1.nil,
      errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
      errorPath: (0, codegen_1._)`""`,
      opts: this.opts,
      self: this
    };
    let sourceCode;
    try {
      this._compilations.add(sch);
      (0, validate_1.validateFunctionCode)(schemaCxt);
      gen.optimize(this.opts.code.optimize);
      const validateCode = gen.toString();
      sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
      if (this.opts.code.process)
        sourceCode = this.opts.code.process(sourceCode, sch);
      const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
      const validate2 = makeValidate(this, this.scope.get());
      this.scope.value(validateName, { ref: validate2 });
      validate2.errors = null;
      validate2.schema = sch.schema;
      validate2.schemaEnv = sch;
      if (sch.$async)
        validate2.$async = true;
      if (this.opts.code.source === true) {
        validate2.source = { validateName, validateCode, scopeValues: gen._values };
      }
      if (this.opts.unevaluated) {
        const { props, items: items2 } = schemaCxt;
        validate2.evaluated = {
          props: props instanceof codegen_1.Name ? void 0 : props,
          items: items2 instanceof codegen_1.Name ? void 0 : items2,
          dynamicProps: props instanceof codegen_1.Name,
          dynamicItems: items2 instanceof codegen_1.Name
        };
        if (validate2.source)
          validate2.source.evaluated = (0, codegen_1.stringify)(validate2.evaluated);
      }
      sch.validate = validate2;
      return sch;
    } catch (e) {
      delete sch.validate;
      delete sch.validateName;
      if (sourceCode)
        this.logger.error("Error compiling schema, function code:", sourceCode);
      throw e;
    } finally {
      this._compilations.delete(sch);
    }
  }
  compile.compileSchema = compileSchema;
  function resolveRef(root, baseId, ref2) {
    var _a;
    ref2 = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref2);
    const schOrFunc = root.refs[ref2];
    if (schOrFunc)
      return schOrFunc;
    let _sch = resolve2.call(this, root, ref2);
    if (_sch === void 0) {
      const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref2];
      const { schemaId } = this.opts;
      if (schema)
        _sch = new SchemaEnv({ schema, schemaId, root, baseId });
    }
    if (_sch === void 0)
      return;
    return root.refs[ref2] = inlineOrCompile.call(this, _sch);
  }
  compile.resolveRef = resolveRef;
  function inlineOrCompile(sch) {
    if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
      return sch.schema;
    return sch.validate ? sch : compileSchema.call(this, sch);
  }
  function getCompilingSchema(schEnv) {
    for (const sch of this._compilations) {
      if (sameSchemaEnv(sch, schEnv))
        return sch;
    }
  }
  compile.getCompilingSchema = getCompilingSchema;
  function sameSchemaEnv(s1, s2) {
    return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
  }
  function resolve2(root, ref2) {
    let sch;
    while (typeof (sch = this.refs[ref2]) == "string")
      ref2 = sch;
    return sch || this.schemas[ref2] || resolveSchema.call(this, root, ref2);
  }
  function resolveSchema(root, ref2) {
    const p = this.opts.uriResolver.parse(ref2);
    const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
    let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
    if (Object.keys(root.schema).length > 0 && refPath === baseId) {
      return getJsonPointer.call(this, p, root);
    }
    const id2 = (0, resolve_1.normalizeId)(refPath);
    const schOrRef = this.refs[id2] || this.schemas[id2];
    if (typeof schOrRef == "string") {
      const sch = resolveSchema.call(this, root, schOrRef);
      if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
        return;
      return getJsonPointer.call(this, p, sch);
    }
    if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
      return;
    if (!schOrRef.validate)
      compileSchema.call(this, schOrRef);
    if (id2 === (0, resolve_1.normalizeId)(ref2)) {
      const { schema } = schOrRef;
      const { schemaId } = this.opts;
      const schId = schema[schemaId];
      if (schId)
        baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
      return new SchemaEnv({ schema, schemaId, root, baseId });
    }
    return getJsonPointer.call(this, p, schOrRef);
  }
  compile.resolveSchema = resolveSchema;
  const PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
    "properties",
    "patternProperties",
    "enum",
    "dependencies",
    "definitions"
  ]);
  function getJsonPointer(parsedRef, { baseId, schema, root }) {
    var _a;
    if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
      return;
    for (const part of parsedRef.fragment.slice(1).split("/")) {
      if (typeof schema === "boolean")
        return;
      const partSchema = schema[(0, util_1.unescapeFragment)(part)];
      if (partSchema === void 0)
        return;
      schema = partSchema;
      const schId = typeof schema === "object" && schema[this.opts.schemaId];
      if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
        baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
      }
    }
    let env;
    if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
      const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
      env = resolveSchema.call(this, root, $ref);
    }
    const { schemaId } = this.opts;
    env = env || new SchemaEnv({ schema, schemaId, root, baseId });
    if (env.schema !== env.root.schema)
      return env;
    return void 0;
  }
  return compile;
}
const $id$9 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
const description = "Meta-schema for $data reference (JSON AnySchema extension proposal)";
const type$9 = "object";
const required$1 = ["$data"];
const properties$a = { "$data": { "type": "string", "anyOf": [{ "format": "relative-json-pointer" }, { "format": "json-pointer" }] } };
const additionalProperties$1 = false;
const require$$9 = {
  $id: $id$9,
  description,
  type: type$9,
  required: required$1,
  properties: properties$a,
  additionalProperties: additionalProperties$1
};
var uri = {};
var fastUri = { exports: {} };
var utils;
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  const isUUID = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu);
  const isIPv4 = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
  function stringArrayToHexStripped(input) {
    let acc = "";
    let code2 = 0;
    let i = 0;
    for (i = 0; i < input.length; i++) {
      code2 = input[i].charCodeAt(0);
      if (code2 === 48) {
        continue;
      }
      if (!(code2 >= 48 && code2 <= 57 || code2 >= 65 && code2 <= 70 || code2 >= 97 && code2 <= 102)) {
        return "";
      }
      acc += input[i];
      break;
    }
    for (i += 1; i < input.length; i++) {
      code2 = input[i].charCodeAt(0);
      if (!(code2 >= 48 && code2 <= 57 || code2 >= 65 && code2 <= 70 || code2 >= 97 && code2 <= 102)) {
        return "";
      }
      acc += input[i];
    }
    return acc;
  }
  const nonSimpleDomain = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
  function consumeIsZone(buffer) {
    buffer.length = 0;
    return true;
  }
  function consumeHextets(buffer, address, output) {
    if (buffer.length) {
      const hex = stringArrayToHexStripped(buffer);
      if (hex !== "") {
        address.push(hex);
      } else {
        output.error = true;
        return false;
      }
      buffer.length = 0;
    }
    return true;
  }
  function getIPV6(input) {
    let tokenCount = 0;
    const output = { error: false, address: "", zone: "" };
    const address = [];
    const buffer = [];
    let endipv6Encountered = false;
    let endIpv6 = false;
    let consume = consumeHextets;
    for (let i = 0; i < input.length; i++) {
      const cursor = input[i];
      if (cursor === "[" || cursor === "]") {
        continue;
      }
      if (cursor === ":") {
        if (endipv6Encountered === true) {
          endIpv6 = true;
        }
        if (!consume(buffer, address, output)) {
          break;
        }
        if (++tokenCount > 7) {
          output.error = true;
          break;
        }
        if (i > 0 && input[i - 1] === ":") {
          endipv6Encountered = true;
        }
        address.push(":");
        continue;
      } else if (cursor === "%") {
        if (!consume(buffer, address, output)) {
          break;
        }
        consume = consumeIsZone;
      } else {
        buffer.push(cursor);
        continue;
      }
    }
    if (buffer.length) {
      if (consume === consumeIsZone) {
        output.zone = buffer.join("");
      } else if (endIpv6) {
        address.push(buffer.join(""));
      } else {
        address.push(stringArrayToHexStripped(buffer));
      }
    }
    output.address = address.join("");
    return output;
  }
  function normalizeIPv6(host) {
    if (findToken(host, ":") < 2) {
      return { host, isIPV6: false };
    }
    const ipv6 = getIPV6(host);
    if (!ipv6.error) {
      let newHost = ipv6.address;
      let escapedHost = ipv6.address;
      if (ipv6.zone) {
        newHost += "%" + ipv6.zone;
        escapedHost += "%25" + ipv6.zone;
      }
      return { host: newHost, isIPV6: true, escapedHost };
    } else {
      return { host, isIPV6: false };
    }
  }
  function findToken(str, token) {
    let ind = 0;
    for (let i = 0; i < str.length; i++) {
      if (str[i] === token) ind++;
    }
    return ind;
  }
  function removeDotSegments(path) {
    let input = path;
    const output = [];
    let nextSlash = -1;
    let len = 0;
    while (len = input.length) {
      if (len === 1) {
        if (input === ".") {
          break;
        } else if (input === "/") {
          output.push("/");
          break;
        } else {
          output.push(input);
          break;
        }
      } else if (len === 2) {
        if (input[0] === ".") {
          if (input[1] === ".") {
            break;
          } else if (input[1] === "/") {
            input = input.slice(2);
            continue;
          }
        } else if (input[0] === "/") {
          if (input[1] === "." || input[1] === "/") {
            output.push("/");
            break;
          }
        }
      } else if (len === 3) {
        if (input === "/..") {
          if (output.length !== 0) {
            output.pop();
          }
          output.push("/");
          break;
        }
      }
      if (input[0] === ".") {
        if (input[1] === ".") {
          if (input[2] === "/") {
            input = input.slice(3);
            continue;
          }
        } else if (input[1] === "/") {
          input = input.slice(2);
          continue;
        }
      } else if (input[0] === "/") {
        if (input[1] === ".") {
          if (input[2] === "/") {
            input = input.slice(2);
            continue;
          } else if (input[2] === ".") {
            if (input[3] === "/") {
              input = input.slice(3);
              if (output.length !== 0) {
                output.pop();
              }
              continue;
            }
          }
        }
      }
      if ((nextSlash = input.indexOf("/", 1)) === -1) {
        output.push(input);
        break;
      } else {
        output.push(input.slice(0, nextSlash));
        input = input.slice(nextSlash);
      }
    }
    return output.join("");
  }
  function normalizeComponentEncoding(component, esc) {
    const func = esc !== true ? escape : unescape;
    if (component.scheme !== void 0) {
      component.scheme = func(component.scheme);
    }
    if (component.userinfo !== void 0) {
      component.userinfo = func(component.userinfo);
    }
    if (component.host !== void 0) {
      component.host = func(component.host);
    }
    if (component.path !== void 0) {
      component.path = func(component.path);
    }
    if (component.query !== void 0) {
      component.query = func(component.query);
    }
    if (component.fragment !== void 0) {
      component.fragment = func(component.fragment);
    }
    return component;
  }
  function recomposeAuthority(component) {
    const uriTokens = [];
    if (component.userinfo !== void 0) {
      uriTokens.push(component.userinfo);
      uriTokens.push("@");
    }
    if (component.host !== void 0) {
      let host = unescape(component.host);
      if (!isIPv4(host)) {
        const ipV6res = normalizeIPv6(host);
        if (ipV6res.isIPV6 === true) {
          host = `[${ipV6res.escapedHost}]`;
        } else {
          host = component.host;
        }
      }
      uriTokens.push(host);
    }
    if (typeof component.port === "number" || typeof component.port === "string") {
      uriTokens.push(":");
      uriTokens.push(String(component.port));
    }
    return uriTokens.length ? uriTokens.join("") : void 0;
  }
  utils = {
    nonSimpleDomain,
    recomposeAuthority,
    normalizeComponentEncoding,
    removeDotSegments,
    isIPv4,
    isUUID,
    normalizeIPv6,
    stringArrayToHexStripped
  };
  return utils;
}
var schemes;
var hasRequiredSchemes;
function requireSchemes() {
  if (hasRequiredSchemes) return schemes;
  hasRequiredSchemes = 1;
  const { isUUID } = requireUtils();
  const URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
  const supportedSchemeNames = (
    /** @type {const} */
    [
      "http",
      "https",
      "ws",
      "wss",
      "urn",
      "urn:uuid"
    ]
  );
  function isValidSchemeName(name) {
    return supportedSchemeNames.indexOf(
      /** @type {*} */
      name
    ) !== -1;
  }
  function wsIsSecure(wsComponent) {
    if (wsComponent.secure === true) {
      return true;
    } else if (wsComponent.secure === false) {
      return false;
    } else if (wsComponent.scheme) {
      return wsComponent.scheme.length === 3 && (wsComponent.scheme[0] === "w" || wsComponent.scheme[0] === "W") && (wsComponent.scheme[1] === "s" || wsComponent.scheme[1] === "S") && (wsComponent.scheme[2] === "s" || wsComponent.scheme[2] === "S");
    } else {
      return false;
    }
  }
  function httpParse(component) {
    if (!component.host) {
      component.error = component.error || "HTTP URIs must have a host.";
    }
    return component;
  }
  function httpSerialize(component) {
    const secure = String(component.scheme).toLowerCase() === "https";
    if (component.port === (secure ? 443 : 80) || component.port === "") {
      component.port = void 0;
    }
    if (!component.path) {
      component.path = "/";
    }
    return component;
  }
  function wsParse(wsComponent) {
    wsComponent.secure = wsIsSecure(wsComponent);
    wsComponent.resourceName = (wsComponent.path || "/") + (wsComponent.query ? "?" + wsComponent.query : "");
    wsComponent.path = void 0;
    wsComponent.query = void 0;
    return wsComponent;
  }
  function wsSerialize(wsComponent) {
    if (wsComponent.port === (wsIsSecure(wsComponent) ? 443 : 80) || wsComponent.port === "") {
      wsComponent.port = void 0;
    }
    if (typeof wsComponent.secure === "boolean") {
      wsComponent.scheme = wsComponent.secure ? "wss" : "ws";
      wsComponent.secure = void 0;
    }
    if (wsComponent.resourceName) {
      const [path, query] = wsComponent.resourceName.split("?");
      wsComponent.path = path && path !== "/" ? path : void 0;
      wsComponent.query = query;
      wsComponent.resourceName = void 0;
    }
    wsComponent.fragment = void 0;
    return wsComponent;
  }
  function urnParse(urnComponent, options) {
    if (!urnComponent.path) {
      urnComponent.error = "URN can not be parsed";
      return urnComponent;
    }
    const matches = urnComponent.path.match(URN_REG);
    if (matches) {
      const scheme = options.scheme || urnComponent.scheme || "urn";
      urnComponent.nid = matches[1].toLowerCase();
      urnComponent.nss = matches[2];
      const urnScheme = `${scheme}:${options.nid || urnComponent.nid}`;
      const schemeHandler = getSchemeHandler(urnScheme);
      urnComponent.path = void 0;
      if (schemeHandler) {
        urnComponent = schemeHandler.parse(urnComponent, options);
      }
    } else {
      urnComponent.error = urnComponent.error || "URN can not be parsed.";
    }
    return urnComponent;
  }
  function urnSerialize(urnComponent, options) {
    if (urnComponent.nid === void 0) {
      throw new Error("URN without nid cannot be serialized");
    }
    const scheme = options.scheme || urnComponent.scheme || "urn";
    const nid = urnComponent.nid.toLowerCase();
    const urnScheme = `${scheme}:${options.nid || nid}`;
    const schemeHandler = getSchemeHandler(urnScheme);
    if (schemeHandler) {
      urnComponent = schemeHandler.serialize(urnComponent, options);
    }
    const uriComponent = urnComponent;
    const nss = urnComponent.nss;
    uriComponent.path = `${nid || options.nid}:${nss}`;
    options.skipEscape = true;
    return uriComponent;
  }
  function urnuuidParse(urnComponent, options) {
    const uuidComponent = urnComponent;
    uuidComponent.uuid = uuidComponent.nss;
    uuidComponent.nss = void 0;
    if (!options.tolerant && (!uuidComponent.uuid || !isUUID(uuidComponent.uuid))) {
      uuidComponent.error = uuidComponent.error || "UUID is not valid.";
    }
    return uuidComponent;
  }
  function urnuuidSerialize(uuidComponent) {
    const urnComponent = uuidComponent;
    urnComponent.nss = (uuidComponent.uuid || "").toLowerCase();
    return urnComponent;
  }
  const http = (
    /** @type {SchemeHandler} */
    {
      scheme: "http",
      domainHost: true,
      parse: httpParse,
      serialize: httpSerialize
    }
  );
  const https = (
    /** @type {SchemeHandler} */
    {
      scheme: "https",
      domainHost: http.domainHost,
      parse: httpParse,
      serialize: httpSerialize
    }
  );
  const ws = (
    /** @type {SchemeHandler} */
    {
      scheme: "ws",
      domainHost: true,
      parse: wsParse,
      serialize: wsSerialize
    }
  );
  const wss = (
    /** @type {SchemeHandler} */
    {
      scheme: "wss",
      domainHost: ws.domainHost,
      parse: ws.parse,
      serialize: ws.serialize
    }
  );
  const urn = (
    /** @type {SchemeHandler} */
    {
      scheme: "urn",
      parse: urnParse,
      serialize: urnSerialize,
      skipNormalize: true
    }
  );
  const urnuuid = (
    /** @type {SchemeHandler} */
    {
      scheme: "urn:uuid",
      parse: urnuuidParse,
      serialize: urnuuidSerialize,
      skipNormalize: true
    }
  );
  const SCHEMES = (
    /** @type {Record<SchemeName, SchemeHandler>} */
    {
      http,
      https,
      ws,
      wss,
      urn,
      "urn:uuid": urnuuid
    }
  );
  Object.setPrototypeOf(SCHEMES, null);
  function getSchemeHandler(scheme) {
    return scheme && (SCHEMES[
      /** @type {SchemeName} */
      scheme
    ] || SCHEMES[
      /** @type {SchemeName} */
      scheme.toLowerCase()
    ]) || void 0;
  }
  schemes = {
    wsIsSecure,
    SCHEMES,
    isValidSchemeName,
    getSchemeHandler
  };
  return schemes;
}
var hasRequiredFastUri;
function requireFastUri() {
  if (hasRequiredFastUri) return fastUri.exports;
  hasRequiredFastUri = 1;
  const { normalizeIPv6, removeDotSegments, recomposeAuthority, normalizeComponentEncoding, isIPv4, nonSimpleDomain } = requireUtils();
  const { SCHEMES, getSchemeHandler } = requireSchemes();
  function normalize(uri2, options) {
    if (typeof uri2 === "string") {
      uri2 = /** @type {T} */
      serialize(parse(uri2, options), options);
    } else if (typeof uri2 === "object") {
      uri2 = /** @type {T} */
      parse(serialize(uri2, options), options);
    }
    return uri2;
  }
  function resolve2(baseURI, relativeURI, options) {
    const schemelessOptions = options ? Object.assign({ scheme: "null" }, options) : { scheme: "null" };
    const resolved = resolveComponent(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true);
    schemelessOptions.skipEscape = true;
    return serialize(resolved, schemelessOptions);
  }
  function resolveComponent(base, relative, options, skipNormalization) {
    const target = {};
    if (!skipNormalization) {
      base = parse(serialize(base, options), options);
      relative = parse(serialize(relative, options), options);
    }
    options = options || {};
    if (!options.tolerant && relative.scheme) {
      target.scheme = relative.scheme;
      target.userinfo = relative.userinfo;
      target.host = relative.host;
      target.port = relative.port;
      target.path = removeDotSegments(relative.path || "");
      target.query = relative.query;
    } else {
      if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (!relative.path) {
          target.path = base.path;
          if (relative.query !== void 0) {
            target.query = relative.query;
          } else {
            target.query = base.query;
          }
        } else {
          if (relative.path[0] === "/") {
            target.path = removeDotSegments(relative.path);
          } else {
            if ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path) {
              target.path = "/" + relative.path;
            } else if (!base.path) {
              target.path = relative.path;
            } else {
              target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
            }
            target.path = removeDotSegments(target.path);
          }
          target.query = relative.query;
        }
        target.userinfo = base.userinfo;
        target.host = base.host;
        target.port = base.port;
      }
      target.scheme = base.scheme;
    }
    target.fragment = relative.fragment;
    return target;
  }
  function equal2(uriA, uriB, options) {
    if (typeof uriA === "string") {
      uriA = unescape(uriA);
      uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true });
    } else if (typeof uriA === "object") {
      uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
    }
    if (typeof uriB === "string") {
      uriB = unescape(uriB);
      uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true });
    } else if (typeof uriB === "object") {
      uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
    }
    return uriA.toLowerCase() === uriB.toLowerCase();
  }
  function serialize(cmpts, opts) {
    const component = {
      host: cmpts.host,
      scheme: cmpts.scheme,
      userinfo: cmpts.userinfo,
      port: cmpts.port,
      path: cmpts.path,
      query: cmpts.query,
      nid: cmpts.nid,
      nss: cmpts.nss,
      uuid: cmpts.uuid,
      fragment: cmpts.fragment,
      reference: cmpts.reference,
      resourceName: cmpts.resourceName,
      secure: cmpts.secure,
      error: ""
    };
    const options = Object.assign({}, opts);
    const uriTokens = [];
    const schemeHandler = getSchemeHandler(options.scheme || component.scheme);
    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(component, options);
    if (component.path !== void 0) {
      if (!options.skipEscape) {
        component.path = escape(component.path);
        if (component.scheme !== void 0) {
          component.path = component.path.split("%3A").join(":");
        }
      } else {
        component.path = unescape(component.path);
      }
    }
    if (options.reference !== "suffix" && component.scheme) {
      uriTokens.push(component.scheme, ":");
    }
    const authority = recomposeAuthority(component);
    if (authority !== void 0) {
      if (options.reference !== "suffix") {
        uriTokens.push("//");
      }
      uriTokens.push(authority);
      if (component.path && component.path[0] !== "/") {
        uriTokens.push("/");
      }
    }
    if (component.path !== void 0) {
      let s = component.path;
      if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
        s = removeDotSegments(s);
      }
      if (authority === void 0 && s[0] === "/" && s[1] === "/") {
        s = "/%2F" + s.slice(2);
      }
      uriTokens.push(s);
    }
    if (component.query !== void 0) {
      uriTokens.push("?", component.query);
    }
    if (component.fragment !== void 0) {
      uriTokens.push("#", component.fragment);
    }
    return uriTokens.join("");
  }
  const URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
  function parse(uri2, opts) {
    const options = Object.assign({}, opts);
    const parsed = {
      scheme: void 0,
      userinfo: void 0,
      host: "",
      port: void 0,
      path: "",
      query: void 0,
      fragment: void 0
    };
    let isIP = false;
    if (options.reference === "suffix") {
      if (options.scheme) {
        uri2 = options.scheme + ":" + uri2;
      } else {
        uri2 = "//" + uri2;
      }
    }
    const matches = uri2.match(URI_PARSE);
    if (matches) {
      parsed.scheme = matches[1];
      parsed.userinfo = matches[3];
      parsed.host = matches[4];
      parsed.port = parseInt(matches[5], 10);
      parsed.path = matches[6] || "";
      parsed.query = matches[7];
      parsed.fragment = matches[8];
      if (isNaN(parsed.port)) {
        parsed.port = matches[5];
      }
      if (parsed.host) {
        const ipv4result = isIPv4(parsed.host);
        if (ipv4result === false) {
          const ipv6result = normalizeIPv6(parsed.host);
          parsed.host = ipv6result.host.toLowerCase();
          isIP = ipv6result.isIPV6;
        } else {
          isIP = true;
        }
      }
      if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && parsed.query === void 0 && !parsed.path) {
        parsed.reference = "same-document";
      } else if (parsed.scheme === void 0) {
        parsed.reference = "relative";
      } else if (parsed.fragment === void 0) {
        parsed.reference = "absolute";
      } else {
        parsed.reference = "uri";
      }
      if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) {
        parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
      }
      const schemeHandler = getSchemeHandler(options.scheme || parsed.scheme);
      if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
        if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {
          try {
            parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
          } catch (e) {
            parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
          }
        }
      }
      if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
        if (uri2.indexOf("%") !== -1) {
          if (parsed.scheme !== void 0) {
            parsed.scheme = unescape(parsed.scheme);
          }
          if (parsed.host !== void 0) {
            parsed.host = unescape(parsed.host);
          }
        }
        if (parsed.path) {
          parsed.path = escape(unescape(parsed.path));
        }
        if (parsed.fragment) {
          parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
        }
      }
      if (schemeHandler && schemeHandler.parse) {
        schemeHandler.parse(parsed, options);
      }
    } else {
      parsed.error = parsed.error || "URI can not be parsed.";
    }
    return parsed;
  }
  const fastUri$1 = {
    SCHEMES,
    normalize,
    resolve: resolve2,
    resolveComponent,
    equal: equal2,
    serialize,
    parse
  };
  fastUri.exports = fastUri$1;
  fastUri.exports.default = fastUri$1;
  fastUri.exports.fastUri = fastUri$1;
  return fastUri.exports;
}
var hasRequiredUri;
function requireUri() {
  if (hasRequiredUri) return uri;
  hasRequiredUri = 1;
  Object.defineProperty(uri, "__esModule", { value: true });
  const uri$1 = requireFastUri();
  uri$1.code = 'require("ajv/dist/runtime/uri").default';
  uri.default = uri$1;
  return uri;
}
var hasRequiredCore$1;
function requireCore$1() {
  if (hasRequiredCore$1) return core$1;
  hasRequiredCore$1 = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.CodeGen = exports$1.Name = exports$1.nil = exports$1.stringify = exports$1.str = exports$1._ = exports$1.KeywordCxt = void 0;
    var validate_1 = requireValidate();
    Object.defineProperty(exports$1, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = requireCodegen();
    Object.defineProperty(exports$1, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports$1, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports$1, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports$1, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports$1, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports$1, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    const validation_error_1 = requireValidation_error();
    const ref_error_1 = requireRef_error();
    const rules_1 = requireRules();
    const compile_1 = requireCompile();
    const codegen_2 = requireCodegen();
    const resolve_1 = requireResolve();
    const dataType_1 = requireDataType();
    const util_1 = requireUtil();
    const $dataRefSchema = require$$9;
    const uri_1 = requireUri();
    const defaultRegExp = (str, flags) => new RegExp(str, flags);
    defaultRegExp.code = "new RegExp";
    const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
    const EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]);
    const removedOptions = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    };
    const deprecatedOptions = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    };
    const MAX_EXPRESSION = 200;
    function requiredOptions(o) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
      const s = o.strict;
      const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
      const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
      const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
      const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
      return {
        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
        uriResolver
      };
    }
    class Ajv {
      constructor(opts = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = /* @__PURE__ */ new Set();
        this._loading = {};
        this._cache = /* @__PURE__ */ new Map();
        opts = this.opts = { ...opts, ...requiredOptions(opts) };
        const { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
        this.logger = getLogger(opts.logger);
        const formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = (0, rules_1.getRules)();
        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats)
          addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords)
          addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == "object")
          this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data, meta, schemaId } = this.opts;
        let _dataRefSchema = $dataRefSchema;
        if (schemaId === "id") {
          _dataRefSchema = { ...$dataRefSchema };
          _dataRefSchema.id = _dataRefSchema.$id;
          delete _dataRefSchema.$id;
        }
        if (meta && $data)
          this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
      }
      defaultMeta() {
        const { meta, schemaId } = this.opts;
        return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
      }
      validate(schemaKeyRef, data2) {
        let v;
        if (typeof schemaKeyRef == "string") {
          v = this.getSchema(schemaKeyRef);
          if (!v)
            throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        } else {
          v = this.compile(schemaKeyRef);
        }
        const valid = v(data2);
        if (!("$async" in v))
          this.errors = v.errors;
        return valid;
      }
      compile(schema, _meta) {
        const sch = this._addSchema(schema, _meta);
        return sch.validate || this._compileSchemaEnv(sch);
      }
      compileAsync(schema, meta) {
        if (typeof this.opts.loadSchema != "function") {
          throw new Error("options.loadSchema should be a function");
        }
        const { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta);
        async function runCompileAsync(_schema, _meta) {
          await loadMetaSchema.call(this, _schema.$schema);
          const sch = this._addSchema(_schema, _meta);
          return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
          if ($ref && !this.getSchema($ref)) {
            await runCompileAsync.call(this, { $ref }, true);
          }
        }
        async function _compileAsync(sch) {
          try {
            return this._compileSchemaEnv(sch);
          } catch (e) {
            if (!(e instanceof ref_error_1.default))
              throw e;
            checkLoaded.call(this, e);
            await loadMissingSchema.call(this, e.missingSchema);
            return _compileAsync.call(this, sch);
          }
        }
        function checkLoaded({ missingSchema: ref2, missingRef }) {
          if (this.refs[ref2]) {
            throw new Error(`AnySchema ${ref2} is loaded but ${missingRef} cannot be resolved`);
          }
        }
        async function loadMissingSchema(ref2) {
          const _schema = await _loadSchema.call(this, ref2);
          if (!this.refs[ref2])
            await loadMetaSchema.call(this, _schema.$schema);
          if (!this.refs[ref2])
            this.addSchema(_schema, ref2, meta);
        }
        async function _loadSchema(ref2) {
          const p = this._loading[ref2];
          if (p)
            return p;
          try {
            return await (this._loading[ref2] = loadSchema(ref2));
          } finally {
            delete this._loading[ref2];
          }
        }
      }
      // Adds schema to the instance
      addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
        if (Array.isArray(schema)) {
          for (const sch of schema)
            this.addSchema(sch, void 0, _meta, _validateSchema);
          return this;
        }
        let id2;
        if (typeof schema === "object") {
          const { schemaId } = this.opts;
          id2 = schema[schemaId];
          if (id2 !== void 0 && typeof id2 != "string") {
            throw new Error(`schema ${schemaId} must be string`);
          }
        }
        key = (0, resolve_1.normalizeId)(key || id2);
        this._checkUnique(key);
        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
        return this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
        this.addSchema(schema, key, true, _validateSchema);
        return this;
      }
      //  Validate schema against its meta-schema
      validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean")
          return true;
        let $schema2;
        $schema2 = schema.$schema;
        if ($schema2 !== void 0 && typeof $schema2 != "string") {
          throw new Error("$schema must be a string");
        }
        $schema2 = $schema2 || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema2) {
          this.logger.warn("meta-schema not available");
          this.errors = null;
          return true;
        }
        const valid = this.validate($schema2, schema);
        if (!valid && throwOrLogError) {
          const message = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(message);
          else
            throw new Error(message);
        }
        return valid;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(keyRef) {
        let sch;
        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
          keyRef = sch;
        if (sch === void 0) {
          const { schemaId } = this.opts;
          const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
          sch = compile_1.resolveSchema.call(this, root, keyRef);
          if (!sch)
            return;
          this.refs[keyRef] = sch;
        }
        return sch.validate || this._compileSchemaEnv(sch);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
          this._removeAllSchemas(this.schemas, schemaKeyRef);
          this._removeAllSchemas(this.refs, schemaKeyRef);
          return this;
        }
        switch (typeof schemaKeyRef) {
          case "undefined":
            this._removeAllSchemas(this.schemas);
            this._removeAllSchemas(this.refs);
            this._cache.clear();
            return this;
          case "string": {
            const sch = getSchEnv.call(this, schemaKeyRef);
            if (typeof sch == "object")
              this._cache.delete(sch.schema);
            delete this.schemas[schemaKeyRef];
            delete this.refs[schemaKeyRef];
            return this;
          }
          case "object": {
            const cacheKey = schemaKeyRef;
            this._cache.delete(cacheKey);
            let id2 = schemaKeyRef[this.opts.schemaId];
            if (id2) {
              id2 = (0, resolve_1.normalizeId)(id2);
              delete this.schemas[id2];
              delete this.refs[id2];
            }
            return this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(definitions2) {
        for (const def of definitions2)
          this.addKeyword(def);
        return this;
      }
      addKeyword(kwdOrDef, def) {
        let keyword2;
        if (typeof kwdOrDef == "string") {
          keyword2 = kwdOrDef;
          if (typeof def == "object") {
            this.logger.warn("these parameters are deprecated, see docs for addKeyword");
            def.keyword = keyword2;
          }
        } else if (typeof kwdOrDef == "object" && def === void 0) {
          def = kwdOrDef;
          keyword2 = def.keyword;
          if (Array.isArray(keyword2) && !keyword2.length) {
            throw new Error("addKeywords: keyword must be string or non-empty array");
          }
        } else {
          throw new Error("invalid addKeywords parameters");
        }
        checkKeyword.call(this, keyword2, def);
        if (!def) {
          (0, util_1.eachItem)(keyword2, (kwd) => addRule.call(this, kwd));
          return this;
        }
        keywordMetaschema.call(this, def);
        const definition = {
          ...def,
          type: (0, dataType_1.getJSONTypes)(def.type),
          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
        };
        (0, util_1.eachItem)(keyword2, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
        return this;
      }
      getKeyword(keyword2) {
        const rule = this.RULES.all[keyword2];
        return typeof rule == "object" ? rule.definition : !!rule;
      }
      // Remove keyword
      removeKeyword(keyword2) {
        const { RULES } = this;
        delete RULES.keywords[keyword2];
        delete RULES.all[keyword2];
        for (const group of RULES.rules) {
          const i = group.rules.findIndex((rule) => rule.keyword === keyword2);
          if (i >= 0)
            group.rules.splice(i, 1);
        }
        return this;
      }
      // Add format
      addFormat(name, format2) {
        if (typeof format2 == "string")
          format2 = new RegExp(format2);
        this.formats[name] = format2;
        return this;
      }
      errorsText(errors2 = this.errors, { separator = ", ", dataVar = "data" } = {}) {
        if (!errors2 || errors2.length === 0)
          return "No errors";
        return errors2.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
      }
      $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        const rules2 = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (const jsonPointer of keywordsJsonPointers) {
          const segments = jsonPointer.split("/").slice(1);
          let keywords = metaSchema;
          for (const seg of segments)
            keywords = keywords[seg];
          for (const key in rules2) {
            const rule = rules2[key];
            if (typeof rule != "object")
              continue;
            const { $data } = rule.definition;
            const schema = keywords[key];
            if ($data && schema)
              keywords[key] = schemaOrData(schema);
          }
        }
        return metaSchema;
      }
      _removeAllSchemas(schemas, regex) {
        for (const keyRef in schemas) {
          const sch = schemas[keyRef];
          if (!regex || regex.test(keyRef)) {
            if (typeof sch == "string") {
              delete schemas[keyRef];
            } else if (sch && !sch.meta) {
              this._cache.delete(sch.schema);
              delete schemas[keyRef];
            }
          }
        }
      }
      _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id2;
        const { schemaId } = this.opts;
        if (typeof schema == "object") {
          id2 = schema[schemaId];
        } else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          else if (typeof schema != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== void 0)
          return sch;
        baseId = (0, resolve_1.normalizeId)(id2 || baseId);
        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
        this._cache.set(sch.schema, sch);
        if (addSchema && !baseId.startsWith("#")) {
          if (baseId)
            this._checkUnique(baseId);
          this.refs[baseId] = sch;
        }
        if (validateSchema)
          this.validateSchema(schema, true);
        return sch;
      }
      _checkUnique(id2) {
        if (this.schemas[id2] || this.refs[id2]) {
          throw new Error(`schema with key or id "${id2}" already exists`);
        }
      }
      _compileSchemaEnv(sch) {
        if (sch.meta)
          this._compileMetaSchema(sch);
        else
          compile_1.compileSchema.call(this, sch);
        if (!sch.validate)
          throw new Error("ajv implementation error");
        return sch.validate;
      }
      _compileMetaSchema(sch) {
        const currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
          compile_1.compileSchema.call(this, sch);
        } finally {
          this.opts = currentOpts;
        }
      }
    }
    Ajv.ValidationError = validation_error_1.default;
    Ajv.MissingRefError = ref_error_1.default;
    exports$1.default = Ajv;
    function checkOptions(checkOpts, options, msg, log = "error") {
      for (const key in checkOpts) {
        const opt = key;
        if (opt in options)
          this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
      }
    }
    function getSchEnv(keyRef) {
      keyRef = (0, resolve_1.normalizeId)(keyRef);
      return this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
      const optsSchemas = this.opts.schemas;
      if (!optsSchemas)
        return;
      if (Array.isArray(optsSchemas))
        this.addSchema(optsSchemas);
      else
        for (const key in optsSchemas)
          this.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats() {
      for (const name in this.opts.formats) {
        const format2 = this.opts.formats[name];
        if (format2)
          this.addFormat(name, format2);
      }
    }
    function addInitialKeywords(defs) {
      if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const keyword2 in defs) {
        const def = defs[keyword2];
        if (!def.keyword)
          def.keyword = keyword2;
        this.addKeyword(def);
      }
    }
    function getMetaSchemaOptions() {
      const metaOpts = { ...this.opts };
      for (const opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
      return metaOpts;
    }
    const noLogs = { log() {
    }, warn() {
    }, error() {
    } };
    function getLogger(logger2) {
      if (logger2 === false)
        return noLogs;
      if (logger2 === void 0)
        return console;
      if (logger2.log && logger2.warn && logger2.error)
        return logger2;
      throw new Error("logger must implement log, warn and error methods");
    }
    const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword2, def) {
      const { RULES } = this;
      (0, util_1.eachItem)(keyword2, (kwd) => {
        if (RULES.keywords[kwd])
          throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
          throw new Error(`Keyword ${kwd} has invalid name`);
      });
      if (!def)
        return;
      if (def.$data && !("code" in def || "validate" in def)) {
        throw new Error('$data keyword must have "code" or "validate" function');
      }
    }
    function addRule(keyword2, definition, dataType2) {
      var _a;
      const post = definition === null || definition === void 0 ? void 0 : definition.post;
      if (dataType2 && post)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES } = this;
      let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType2);
      if (!ruleGroup) {
        ruleGroup = { type: dataType2, rules: [] };
        RULES.rules.push(ruleGroup);
      }
      RULES.keywords[keyword2] = true;
      if (!definition)
        return;
      const rule = {
        keyword: keyword2,
        definition: {
          ...definition,
          type: (0, dataType_1.getJSONTypes)(definition.type),
          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
        }
      };
      if (definition.before)
        addBeforeRule.call(this, ruleGroup, rule, definition.before);
      else
        ruleGroup.rules.push(rule);
      RULES.all[keyword2] = rule;
      (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before) {
      const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
      if (i >= 0) {
        ruleGroup.rules.splice(i, 0, rule);
      } else {
        ruleGroup.rules.push(rule);
        this.logger.warn(`rule ${before} is not defined`);
      }
    }
    function keywordMetaschema(def) {
      let { metaSchema } = def;
      if (metaSchema === void 0)
        return;
      if (def.$data && this.opts.$data)
        metaSchema = schemaOrData(metaSchema);
      def.validateSchema = this.compile(metaSchema, true);
    }
    const $dataRef = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function schemaOrData(schema) {
      return { anyOf: [schema, $dataRef] };
    }
  })(core$1);
  return core$1;
}
var draft2020 = {};
var core = {};
var id = {};
var hasRequiredId;
function requireId() {
  if (hasRequiredId) return id;
  hasRequiredId = 1;
  Object.defineProperty(id, "__esModule", { value: true });
  const def = {
    keyword: "id",
    code() {
      throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
    }
  };
  id.default = def;
  return id;
}
var ref = {};
var hasRequiredRef;
function requireRef() {
  if (hasRequiredRef) return ref;
  hasRequiredRef = 1;
  Object.defineProperty(ref, "__esModule", { value: true });
  ref.callRef = ref.getValidate = void 0;
  const ref_error_1 = requireRef_error();
  const code_1 = requireCode();
  const codegen_1 = requireCodegen();
  const names_1 = requireNames();
  const compile_1 = requireCompile();
  const util_1 = requireUtil();
  const def = {
    keyword: "$ref",
    schemaType: "string",
    code(cxt) {
      const { gen, schema: $ref, it } = cxt;
      const { baseId, schemaEnv: env, validateName, opts, self: self2 } = it;
      const { root } = env;
      if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
        return callRootRef();
      const schOrEnv = compile_1.resolveRef.call(self2, root, baseId, $ref);
      if (schOrEnv === void 0)
        throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
      if (schOrEnv instanceof compile_1.SchemaEnv)
        return callValidate(schOrEnv);
      return inlineRefSchema(schOrEnv);
      function callRootRef() {
        if (env === root)
          return callRef(cxt, validateName, env, env.$async);
        const rootName = gen.scopeValue("root", { ref: root });
        return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
      }
      function callValidate(sch) {
        const v = getValidate(cxt, sch);
        callRef(cxt, v, sch, sch.$async);
      }
      function inlineRefSchema(sch) {
        const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
        const valid = gen.name("valid");
        const schCxt = cxt.subschema({
          schema: sch,
          dataTypes: [],
          schemaPath: codegen_1.nil,
          topSchemaRef: schName,
          errSchemaPath: $ref
        }, valid);
        cxt.mergeEvaluated(schCxt);
        cxt.ok(valid);
      }
    }
  };
  function getValidate(cxt, sch) {
    const { gen } = cxt;
    return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
  }
  ref.getValidate = getValidate;
  function callRef(cxt, v, sch, $async) {
    const { gen, it } = cxt;
    const { allErrors, schemaEnv: env, opts } = it;
    const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
    if ($async)
      callAsyncRef();
    else
      callSyncRef();
    function callAsyncRef() {
      if (!env.$async)
        throw new Error("async schema referenced by sync schema");
      const valid = gen.let("valid");
      gen.try(() => {
        gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
        addEvaluatedFrom(v);
        if (!allErrors)
          gen.assign(valid, true);
      }, (e) => {
        gen.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
        addErrorsFrom(e);
        if (!allErrors)
          gen.assign(valid, false);
      });
      cxt.ok(valid);
    }
    function callSyncRef() {
      cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
    }
    function addErrorsFrom(source) {
      const errs = (0, codegen_1._)`${source}.errors`;
      gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
      gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
    }
    function addEvaluatedFrom(source) {
      var _a;
      if (!it.opts.unevaluated)
        return;
      const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
      if (it.props !== true) {
        if (schEvaluated && !schEvaluated.dynamicProps) {
          if (schEvaluated.props !== void 0) {
            it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
          }
        } else {
          const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
          it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
        }
      }
      if (it.items !== true) {
        if (schEvaluated && !schEvaluated.dynamicItems) {
          if (schEvaluated.items !== void 0) {
            it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
          }
        } else {
          const items2 = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
          it.items = util_1.mergeEvaluated.items(gen, items2, it.items, codegen_1.Name);
        }
      }
    }
  }
  ref.callRef = callRef;
  ref.default = def;
  return ref;
}
var hasRequiredCore;
function requireCore() {
  if (hasRequiredCore) return core;
  hasRequiredCore = 1;
  Object.defineProperty(core, "__esModule", { value: true });
  const id_1 = requireId();
  const ref_1 = requireRef();
  const core$12 = [
    "$schema",
    "$id",
    "$defs",
    "$vocabulary",
    { keyword: "$comment" },
    "definitions",
    id_1.default,
    ref_1.default
  ];
  core.default = core$12;
  return core;
}
var validation = {};
var limitNumber = {};
var hasRequiredLimitNumber;
function requireLimitNumber() {
  if (hasRequiredLimitNumber) return limitNumber;
  hasRequiredLimitNumber = 1;
  Object.defineProperty(limitNumber, "__esModule", { value: true });
  const codegen_1 = requireCodegen();
  const ops = codegen_1.operators;
  const KWDs = {
    maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
    minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
    exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
    exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
  };
  const error = {
    message: ({ keyword: keyword2, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword2].okStr} ${schemaCode}`,
    params: ({ keyword: keyword2, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword2].okStr}, limit: ${schemaCode}}`
  };
  const def = {
    keyword: Object.keys(KWDs),
    type: "number",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
      const { keyword: keyword2, data: data2, schemaCode } = cxt;
      cxt.fail$data((0, codegen_1._)`${data2} ${KWDs[keyword2].fail} ${schemaCode} || isNaN(${data2})`);
    }
  };
  limitNumber.default = def;
  return limitNumber;
}
var multipleOf = {};
var hasRequiredMultipleOf;
function requireMultipleOf() {
  if (hasRequiredMultipleOf) return multipleOf;
  hasRequiredMultipleOf = 1;
  Object.defineProperty(multipleOf, "__esModule", { value: true });
  const codegen_1 = requireCodegen();
  const error = {
    message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
    params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
  };
  const def = {
    keyword: "multipleOf",
    type: "number",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
      const { gen, data: data2, schemaCode, it } = cxt;
      const prec = it.opts.multipleOfPrecision;
      const res = gen.let("res");
      const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
      cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data2}/${schemaCode}, ${invalid}))`);
    }
  };
  multipleOf.default = def;
  return multipleOf;
}
var limitLength = {};
var ucs2length = {};
var hasRequiredUcs2length;
function requireUcs2length() {
  if (hasRequiredUcs2length) return ucs2length;
  hasRequiredUcs2length = 1;
  Object.defineProperty(ucs2length, "__esModule", { value: true });
  function ucs2length$1(str) {
    const len = str.length;
    let length = 0;
    let pos = 0;
    let value;
    while (pos < len) {
      length++;
      value = str.charCodeAt(pos++);
      if (value >= 55296 && value <= 56319 && pos < len) {
        value = str.charCodeAt(pos);
        if ((value & 64512) === 56320)
          pos++;
      }
    }
    return length;
  }
  ucs2length.default = ucs2length$1;
  ucs2length$1.code = 'require("ajv/dist/runtime/ucs2length").default';
  return ucs2length;
}
var hasRequiredLimitLength;
function requireLimitLength() {
  if (hasRequiredLimitLength) return limitLength;
  hasRequiredLimitLength = 1;
  Object.defineProperty(limitLength, "__esModule", { value: true });
  const codegen_1 = requireCodegen();
  const util_1 = requireUtil();
  const ucs2length_1 = requireUcs2length();
  const error = {
    message({ keyword: keyword2, schemaCode }) {
      const comp = keyword2 === "maxLength" ? "more" : "fewer";
      return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
    },
    params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
  };
  const def = {
    keyword: ["maxLength", "minLength"],
    type: "string",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
      const { keyword: keyword2, data: data2, schemaCode, it } = cxt;
      const op = keyword2 === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
      const len = it.opts.unicode === false ? (0, codegen_1._)`${data2}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data2})`;
      cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
    }
  };
  limitLength.default = def;
  return limitLength;
}
var pattern = {};
var hasRequiredPattern;
function requirePattern() {
  if (hasRequiredPattern) return pattern;
  hasRequiredPattern = 1;
  Object.defineProperty(pattern, "__esModule", { value: true });
  const code_1 = requireCode();
  const codegen_1 = requireCodegen();
  const error = {
    message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
    params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
  };
  const def = {
    keyword: "pattern",
    type: "string",
    schemaType: "string",
    $data: true,
    error,
    code(cxt) {
      const { data: data2, $data, schema, schemaCode, it } = cxt;
      const u = it.opts.unicodeRegExp ? "u" : "";
      const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
      cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data2})`);
    }
  };
  pattern.default = def;
  return pattern;
}
var limitProperties = {};
var hasRequiredLimitProperties;
function requireLimitProperties() {
  if (hasRequiredLimitProperties) return limitProperties;
  hasRequiredLimitProperties = 1;
  Object.defineProperty(limitProperties, "__esModule", { value: true });
  const codegen_1 = requireCodegen();
  const error = {
    message({ keyword: keyword2, schemaCode }) {
      const comp = keyword2 === "maxProperties" ? "more" : "fewer";
      return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
    },
    params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
  };
  const def = {
    keyword: ["maxProperties", "minProperties"],
    type: "object",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
      const { keyword: keyword2, data: data2, schemaCode } = cxt;
      const op = keyword2 === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
      cxt.fail$data((0, codegen_1._)`Object.keys(${data2}).length ${op} ${schemaCode}`);
    }
  };
  limitProperties.default = def;
  return limitProperties;
}
var required = {};
var hasRequiredRequired;
function requireRequired() {
  if (hasRequiredRequired) return required;
  hasRequiredRequired = 1;
  Object.defineProperty(required, "__esModule", { value: true });
  const code_1 = requireCode();
  const codegen_1 = requireCodegen();
  const util_1 = requireUtil();
  const error = {
    message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
    params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
  };
  const def = {
    keyword: "required",
    type: "object",
    schemaType: "array",
    $data: true,
    error,
    code(cxt) {
      const { gen, schema, schemaCode, data: data2, $data, it } = cxt;
      const { opts } = it;
      if (!$data && schema.length === 0)
        return;
      const useLoop = schema.length >= opts.loopRequired;
      if (it.allErrors)
        allErrorsMode();
      else
        exitOnErrorMode();
      if (opts.strictRequired) {
        const props = cxt.parentSchema.properties;
        const { definedProperties } = cxt.it;
        for (const requiredKey of schema) {
          if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
            const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
            const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
            (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
          }
        }
      }
      function allErrorsMode() {
        if (useLoop || $data) {
          cxt.block$data(codegen_1.nil, loopAllRequired);
        } else {
          for (const prop of schema) {
            (0, code_1.checkReportMissingProp)(cxt, prop);
          }
        }
      }
      function exitOnErrorMode() {
        const missing = gen.let("missing");
        if (useLoop || $data) {
          const valid = gen.let("valid", true);
          cxt.block$data(valid, () => loopUntilMissing(missing, valid));
          cxt.ok(valid);
        } else {
          gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
      function loopAllRequired() {
        gen.forOf("prop", schemaCode, (prop) => {
          cxt.setParams({ missingProperty: prop });
          gen.if((0, code_1.noPropertyInData)(gen, data2, prop, opts.ownProperties), () => cxt.error());
        });
      }
      function loopUntilMissing(missing, valid) {
        cxt.setParams({ missingProperty: missing });
        gen.forOf(missing, schemaCode, () => {
          gen.assign(valid, (0, code_1.propertyInData)(gen, data2, missing, opts.ownProperties));
          gen.if((0, codegen_1.not)(valid), () => {
            cxt.error();
            gen.break();
          });
        }, codegen_1.nil);
      }
    }
  };
  required.default = def;
  return required;
}
var limitItems = {};
var hasRequiredLimitItems;
function requireLimitItems() {
  if (hasRequiredLimitItems) return limitItems;
  hasRequiredLimitItems = 1;
  Object.defineProperty(limitItems, "__esModule", { value: true });
  const codegen_1 = requireCodegen();
  const error = {
    message({ keyword: keyword2, schemaCode }) {
      const comp = keyword2 === "maxItems" ? "more" : "fewer";
      return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
    },
    params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
  };
  const def = {
    keyword: ["maxItems", "minItems"],
    type: "array",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
      const { keyword: keyword2, data: data2, schemaCode } = cxt;
      const op = keyword2 === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
      cxt.fail$data((0, codegen_1._)`${data2}.length ${op} ${schemaCode}`);
    }
  };
  limitItems.default = def;
  return limitItems;
}
var uniqueItems = {};
var equal = {};
var hasRequiredEqual;
function requireEqual() {
  if (hasRequiredEqual) return equal;
  hasRequiredEqual = 1;
  Object.defineProperty(equal, "__esModule", { value: true });
  const equal$1 = requireFastDeepEqual();
  equal$1.code = 'require("ajv/dist/runtime/equal").default';
  equal.default = equal$1;
  return equal;
}
var hasRequiredUniqueItems;
function requireUniqueItems() {
  if (hasRequiredUniqueItems) return uniqueItems;
  hasRequiredUniqueItems = 1;
  Object.defineProperty(uniqueItems, "__esModule", { value: true });
  const dataType_1 = requireDataType();
  const codegen_1 = requireCodegen();
  const util_1 = requireUtil();
  const equal_1 = requireEqual();
  const error = {
    message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
    params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
  };
  const def = {
    keyword: "uniqueItems",
    type: "array",
    schemaType: "boolean",
    $data: true,
    error,
    code(cxt) {
      const { gen, data: data2, $data, schema, parentSchema, schemaCode, it } = cxt;
      if (!$data && !schema)
        return;
      const valid = gen.let("valid");
      const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
      cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
      cxt.ok(valid);
      function validateUniqueItems() {
        const i = gen.let("i", (0, codegen_1._)`${data2}.length`);
        const j = gen.let("j");
        cxt.setParams({ i, j });
        gen.assign(valid, true);
        gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
      }
      function canOptimize() {
        return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
      }
      function loopN(i, j) {
        const item = gen.name("item");
        const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
        const indices = gen.const("indices", (0, codegen_1._)`{}`);
        gen.for((0, codegen_1._)`;${i}--;`, () => {
          gen.let(item, (0, codegen_1._)`${data2}[${i}]`);
          gen.if(wrongType, (0, codegen_1._)`continue`);
          if (itemTypes.length > 1)
            gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
          gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
            gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);
            cxt.error();
            gen.assign(valid, false).break();
          }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
        });
      }
      function loopN2(i, j) {
        const eql = (0, util_1.useFunc)(gen, equal_1.default);
        const outer = gen.name("outer");
        gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data2}[${i}], ${data2}[${j}])`, () => {
          cxt.error();
          gen.assign(valid, false).break(outer);
        })));
      }
    }
  };
  uniqueItems.default = def;
  return uniqueItems;
}
var _const = {};
var hasRequired_const;
function require_const() {
  if (hasRequired_const) return _const;
  hasRequired_const = 1;
  Object.defineProperty(_const, "__esModule", { value: true });
  const codegen_1 = requireCodegen();
  const util_1 = requireUtil();
  const equal_1 = requireEqual();
  const error = {
    message: "must be equal to constant",
    params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
  };
  const def = {
    keyword: "const",
    $data: true,
    error,
    code(cxt) {
      const { gen, data: data2, $data, schemaCode, schema } = cxt;
      if ($data || schema && typeof schema == "object") {
        cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data2}, ${schemaCode})`);
      } else {
        cxt.fail((0, codegen_1._)`${schema} !== ${data2}`);
      }
    }
  };
  _const.default = def;
  return _const;
}
var _enum = {};
var hasRequired_enum;
function require_enum() {
  if (hasRequired_enum) return _enum;
  hasRequired_enum = 1;
  Object.defineProperty(_enum, "__esModule", { value: true });
  const codegen_1 = requireCodegen();
  const util_1 = requireUtil();
  const equal_1 = requireEqual();
  const error = {
    message: "must be equal to one of the allowed values",
    params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
  };
  const def = {
    keyword: "enum",
    schemaType: "array",
    $data: true,
    error,
    code(cxt) {
      const { gen, data: data2, $data, schema, schemaCode, it } = cxt;
      if (!$data && schema.length === 0)
        throw new Error("enum must have non-empty array");
      const useLoop = schema.length >= it.opts.loopEnum;
      let eql;
      const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
      let valid;
      if (useLoop || $data) {
        valid = gen.let("valid");
        cxt.block$data(valid, loopEnum);
      } else {
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const vSchema = gen.const("vSchema", schemaCode);
        valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
      }
      cxt.pass(valid);
      function loopEnum() {
        gen.assign(valid, false);
        gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data2}, ${v})`, () => gen.assign(valid, true).break()));
      }
      function equalCode(vSchema, i) {
        const sch = schema[i];
        return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data2}, ${vSchema}[${i}])` : (0, codegen_1._)`${data2} === ${sch}`;
      }
    }
  };
  _enum.default = def;
  return _enum;
}
var hasRequiredValidation;
function requireValidation() {
  if (hasRequiredValidation) return validation;
  hasRequiredValidation = 1;
  Object.defineProperty(validation, "__esModule", { value: true });
  const limitNumber_1 = requireLimitNumber();
  const multipleOf_1 = requireMultipleOf();
  const limitLength_1 = requireLimitLength();
  const pattern_1 = requirePattern();
  const limitProperties_1 = requireLimitProperties();
  const required_1 = requireRequired();
  const limitItems_1 = requireLimitItems();
  const uniqueItems_1 = requireUniqueItems();
  const const_1 = require_const();
  const enum_1 = require_enum();
  const validation$1 = [
    // number
    limitNumber_1.default,
    multipleOf_1.default,
    // string
    limitLength_1.default,
    pattern_1.default,
    // object
    limitProperties_1.default,
    required_1.default,
    // array
    limitItems_1.default,
    uniqueItems_1.default,
    // any
    { keyword: "type", schemaType: ["string", "array"] },
    { keyword: "nullable", schemaType: "boolean" },
    const_1.default,
    enum_1.default
  ];
  validation.default = validation$1;
  return validation;
}
var applicator = {};
var additionalItems = {};
var hasRequiredAdditionalItems;
function requireAdditionalItems() {
  if (hasRequiredAdditionalItems) return additionalItems;
  hasRequiredAdditionalItems = 1;
  Object.defineProperty(additionalItems, "__esModule", { value: true });
  additionalItems.validateAdditionalItems = void 0;
  const codegen_1 = requireCodegen();
  const util_1 = requireUtil();
  const error = {
    message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
    params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
  };
  const def = {
    keyword: "additionalItems",
    type: "array",
    schemaType: ["boolean", "object"],
    before: "uniqueItems",
    error,
    code(cxt) {
      const { parentSchema, it } = cxt;
      const { items: items2 } = parentSchema;
      if (!Array.isArray(items2)) {
        (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
        return;
      }
      validateAdditionalItems(cxt, items2);
    }
  };
  function validateAdditionalItems(cxt, items2) {
    const { gen, schema, data: data2, keyword: keyword2, it } = cxt;
    it.items = true;
    const len = gen.const("len", (0, codegen_1._)`${data2}.length`);
    if (schema === false) {
      cxt.setParams({ len: items2.length });
      cxt.pass((0, codegen_1._)`${len} <= ${items2.length}`);
    } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
      const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items2.length}`);
      gen.if((0, codegen_1.not)(valid), () => validateItems2(valid));
      cxt.ok(valid);
    }
    function validateItems2(valid) {
      gen.forRange("i", items2.length, len, (i) => {
        cxt.subschema({ keyword: keyword2, dataProp: i, dataPropType: util_1.Type.Num }, valid);
        if (!it.allErrors)
          gen.if((0, codegen_1.not)(valid), () => gen.break());
      });
    }
  }
  additionalItems.validateAdditionalItems = validateAdditionalItems;
  additionalItems.default = def;
  return additionalItems;
}
var prefixItems = {};
var items = {};
var hasRequiredItems;
function requireItems() {
  if (hasRequiredItems) return items;
  hasRequiredItems = 1;
  Object.defineProperty(items, "__esModule", { value: true });
  items.validateTuple = void 0;
  const codegen_1 = requireCodegen();
  const util_1 = requireUtil();
  const code_1 = requireCode();
  const def = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "array", "boolean"],
    before: "uniqueItems",
    code(cxt) {
      const { schema, it } = cxt;
      if (Array.isArray(schema))
        return validateTuple(cxt, "additionalItems", schema);
      it.items = true;
      if ((0, util_1.alwaysValidSchema)(it, schema))
        return;
      cxt.ok((0, code_1.validateArray)(cxt));
    }
  };
  function validateTuple(cxt, extraItems, schArr = cxt.schema) {
    const { gen, parentSchema, data: data2, keyword: keyword2, it } = cxt;
    checkStrictTuple(parentSchema);
    if (it.opts.unevaluated && schArr.length && it.items !== true) {
      it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
    }
    const valid = gen.name("valid");
    const len = gen.const("len", (0, codegen_1._)`${data2}.length`);
    schArr.forEach((sch, i) => {
      if ((0, util_1.alwaysValidSchema)(it, sch))
        return;
      gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
        keyword: keyword2,
        schemaProp: i,
        dataProp: i
      }, valid));
      cxt.ok(valid);
    });
    function checkStrictTuple(sch) {
      const { opts, errSchemaPath } = it;
      const l = schArr.length;
      const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
      if (opts.strictTuples && !fullTuple) {
        const msg = `"${keyword2}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
        (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
      }
    }
  }
  items.validateTuple = validateTuple;
  items.default = def;
  return items;
}
var hasRequiredPrefixItems;
function requirePrefixItems() {
  if (hasRequiredPrefixItems) return prefixItems;
  hasRequiredPrefixItems = 1;
  Object.defineProperty(prefixItems, "__esModule", { value: true });
  const items_1 = requireItems();
  const def = {
    keyword: "prefixItems",
    type: "array",
    schemaType: ["array"],
    before: "uniqueItems",
    code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
  };
  prefixItems.default = def;
  return prefixItems;
}
var items2020 = {};
var hasRequiredItems2020;
function requireItems2020() {
  if (hasRequiredItems2020) return items2020;
  hasRequiredItems2020 = 1;
  Object.defineProperty(items2020, "__esModule", { value: true });
  const codegen_1 = requireCodegen();
  const util_1 = requireUtil();
  const code_1 = requireCode();
  const additionalItems_1 = requireAdditionalItems();
  const error = {
    message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
    params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
  };
  const def = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    error,
    code(cxt) {
      const { schema, parentSchema, it } = cxt;
      const { prefixItems: prefixItems2 } = parentSchema;
      it.items = true;
      if ((0, util_1.alwaysValidSchema)(it, schema))
        return;
      if (prefixItems2)
        (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems2);
      else
        cxt.ok((0, code_1.validateArray)(cxt));
    }
  };
  items2020.default = def;
  return items2020;
}
var contains = {};
var hasRequiredContains;
function requireContains() {
  if (hasRequiredContains) return contains;
  hasRequiredContains = 1;
  Object.defineProperty(contains, "__esModule", { value: true });
  const codegen_1 = requireCodegen();
  const util_1 = requireUtil();
  const error = {
    message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
    params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
  };
  const def = {
    keyword: "contains",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    trackErrors: true,
    error,
    code(cxt) {
      const { gen, schema, parentSchema, data: data2, it } = cxt;
      let min;
      let max;
      const { minContains, maxContains } = parentSchema;
      if (it.opts.next) {
        min = minContains === void 0 ? 1 : minContains;
        max = maxContains;
      } else {
        min = 1;
      }
      const len = gen.const("len", (0, codegen_1._)`${data2}.length`);
      cxt.setParams({ min, max });
      if (max === void 0 && min === 0) {
        (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
        return;
      }
      if (max !== void 0 && min > max) {
        (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
        cxt.fail();
        return;
      }
      if ((0, util_1.alwaysValidSchema)(it, schema)) {
        let cond = (0, codegen_1._)`${len} >= ${min}`;
        if (max !== void 0)
          cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
        cxt.pass(cond);
        return;
      }
      it.items = true;
      const valid = gen.name("valid");
      if (max === void 0 && min === 1) {
        validateItems2(valid, () => gen.if(valid, () => gen.break()));
      } else if (min === 0) {
        gen.let(valid, true);
        if (max !== void 0)
          gen.if((0, codegen_1._)`${data2}.length > 0`, validateItemsWithCount);
      } else {
        gen.let(valid, false);
        validateItemsWithCount();
      }
      cxt.result(valid, () => cxt.reset());
      function validateItemsWithCount() {
        const schValid = gen.name("_valid");
        const count = gen.let("count", 0);
        validateItems2(schValid, () => gen.if(schValid, () => checkLimits(count)));
      }
      function validateItems2(_valid, block) {
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword: "contains",
            dataProp: i,
            dataPropType: util_1.Type.Num,
            compositeRule: true
          }, _valid);
          block();
        });
      }
      function checkLimits(count) {
        gen.code((0, codegen_1._)`${count}++`);
        if (max === void 0) {
          gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
        } else {
          gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());
          if (min === 1)
            gen.assign(valid, true);
          else
            gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));
        }
      }
    }
  };
  contains.default = def;
  return contains;
}
var dependencies = {};
var hasRequiredDependencies;
function requireDependencies() {
  if (hasRequiredDependencies) return dependencies;
  hasRequiredDependencies = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.validateSchemaDeps = exports$1.validatePropertyDeps = exports$1.error = void 0;
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const code_1 = requireCode();
    exports$1.error = {
      message: ({ params: { property, depsCount, deps } }) => {
        const property_ies = depsCount === 1 ? "property" : "properties";
        return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
      },
      params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
      // TODO change to reference
    };
    const def = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: exports$1.error,
      code(cxt) {
        const [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps);
        validateSchemaDeps(cxt, schDeps);
      }
    };
    function splitDependencies({ schema }) {
      const propertyDeps = {};
      const schemaDeps = {};
      for (const key in schema) {
        if (key === "__proto__")
          continue;
        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema[key];
      }
      return [propertyDeps, schemaDeps];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
      const { gen, data: data2, it } = cxt;
      if (Object.keys(propertyDeps).length === 0)
        return;
      const missing = gen.let("missing");
      for (const prop in propertyDeps) {
        const deps = propertyDeps[prop];
        if (deps.length === 0)
          continue;
        const hasProperty = (0, code_1.propertyInData)(gen, data2, prop, it.opts.ownProperties);
        cxt.setParams({
          property: prop,
          depsCount: deps.length,
          deps: deps.join(", ")
        });
        if (it.allErrors) {
          gen.if(hasProperty, () => {
            for (const depProp of deps) {
              (0, code_1.checkReportMissingProp)(cxt, depProp);
            }
          });
        } else {
          gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
    }
    exports$1.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
      const { gen, data: data2, keyword: keyword2, it } = cxt;
      const valid = gen.name("valid");
      for (const prop in schemaDeps) {
        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
          continue;
        gen.if(
          (0, code_1.propertyInData)(gen, data2, prop, it.opts.ownProperties),
          () => {
            const schCxt = cxt.subschema({ keyword: keyword2, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
          },
          () => gen.var(valid, true)
          // TODO var
        );
        cxt.ok(valid);
      }
    }
    exports$1.validateSchemaDeps = validateSchemaDeps;
    exports$1.default = def;
  })(dependencies);
  return dependencies;
}
var propertyNames = {};
var hasRequiredPropertyNames;
function requirePropertyNames() {
  if (hasRequiredPropertyNames) return propertyNames;
  hasRequiredPropertyNames = 1;
  Object.defineProperty(propertyNames, "__esModule", { value: true });
  const codegen_1 = requireCodegen();
  const util_1 = requireUtil();
  const error = {
    message: "property name must be valid",
    params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
  };
  const def = {
    keyword: "propertyNames",
    type: "object",
    schemaType: ["object", "boolean"],
    error,
    code(cxt) {
      const { gen, schema, data: data2, it } = cxt;
      if ((0, util_1.alwaysValidSchema)(it, schema))
        return;
      const valid = gen.name("valid");
      gen.forIn("key", data2, (key) => {
        cxt.setParams({ propertyName: key });
        cxt.subschema({
          keyword: "propertyNames",
          data: key,
          dataTypes: ["string"],
          propertyName: key,
          compositeRule: true
        }, valid);
        gen.if((0, codegen_1.not)(valid), () => {
          cxt.error(true);
          if (!it.allErrors)
            gen.break();
        });
      });
      cxt.ok(valid);
    }
  };
  propertyNames.default = def;
  return propertyNames;
}
var additionalProperties = {};
var hasRequiredAdditionalProperties;
function requireAdditionalProperties() {
  if (hasRequiredAdditionalProperties) return additionalProperties;
  hasRequiredAdditionalProperties = 1;
  Object.defineProperty(additionalProperties, "__esModule", { value: true });
  const code_1 = requireCode();
  const codegen_1 = requireCodegen();
  const names_1 = requireNames();
  const util_1 = requireUtil();
  const error = {
    message: "must NOT have additional properties",
    params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
  };
  const def = {
    keyword: "additionalProperties",
    type: ["object"],
    schemaType: ["boolean", "object"],
    allowUndefined: true,
    trackErrors: true,
    error,
    code(cxt) {
      const { gen, schema, parentSchema, data: data2, errsCount, it } = cxt;
      if (!errsCount)
        throw new Error("ajv implementation error");
      const { allErrors, opts } = it;
      it.props = true;
      if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
        return;
      const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
      const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
      checkAdditionalProperties();
      cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
      function checkAdditionalProperties() {
        gen.forIn("key", data2, (key) => {
          if (!props.length && !patProps.length)
            additionalPropertyCode(key);
          else
            gen.if(isAdditional(key), () => additionalPropertyCode(key));
        });
      }
      function isAdditional(key) {
        let definedProp;
        if (props.length > 8) {
          const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
          definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
        } else if (props.length) {
          definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._)`${key} === ${p}`));
        } else {
          definedProp = codegen_1.nil;
        }
        if (patProps.length) {
          definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key})`));
        }
        return (0, codegen_1.not)(definedProp);
      }
      function deleteAdditional(key) {
        gen.code((0, codegen_1._)`delete ${data2}[${key}]`);
      }
      function additionalPropertyCode(key) {
        if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
          deleteAdditional(key);
          return;
        }
        if (schema === false) {
          cxt.setParams({ additionalProperty: key });
          cxt.error();
          if (!allErrors)
            gen.break();
          return;
        }
        if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
          const valid = gen.name("valid");
          if (opts.removeAdditional === "failing") {
            applyAdditionalSchema(key, valid, false);
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.reset();
              deleteAdditional(key);
            });
          } else {
            applyAdditionalSchema(key, valid);
            if (!allErrors)
              gen.if((0, codegen_1.not)(valid), () => gen.break());
          }
        }
      }
      function applyAdditionalSchema(key, valid, errors2) {
        const subschema2 = {
          keyword: "additionalProperties",
          dataProp: key,
          dataPropType: util_1.Type.Str
        };
        if (errors2 === false) {
          Object.assign(subschema2, {
            compositeRule: true,
            createErrors: false,
            allErrors: false
          });
        }
        cxt.subschema(subschema2, valid);
      }
    }
  };
  additionalProperties.default = def;
  return additionalProperties;
}
var properties$9 = {};
var hasRequiredProperties;
function requireProperties() {
  if (hasRequiredProperties) return properties$9;
  hasRequiredProperties = 1;
  Object.defineProperty(properties$9, "__esModule", { value: true });
  const validate_1 = requireValidate();
  const code_1 = requireCode();
  const util_1 = requireUtil();
  const additionalProperties_1 = requireAdditionalProperties();
  const def = {
    keyword: "properties",
    type: "object",
    schemaType: "object",
    code(cxt) {
      const { gen, schema, parentSchema, data: data2, it } = cxt;
      if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
        additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
      }
      const allProps = (0, code_1.allSchemaProperties)(schema);
      for (const prop of allProps) {
        it.definedProperties.add(prop);
      }
      if (it.opts.unevaluated && allProps.length && it.props !== true) {
        it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
      }
      const properties2 = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
      if (properties2.length === 0)
        return;
      const valid = gen.name("valid");
      for (const prop of properties2) {
        if (hasDefault(prop)) {
          applyPropertySchema(prop);
        } else {
          gen.if((0, code_1.propertyInData)(gen, data2, prop, it.opts.ownProperties));
          applyPropertySchema(prop);
          if (!it.allErrors)
            gen.else().var(valid, true);
          gen.endIf();
        }
        cxt.it.definedProperties.add(prop);
        cxt.ok(valid);
      }
      function hasDefault(prop) {
        return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
      }
      function applyPropertySchema(prop) {
        cxt.subschema({
          keyword: "properties",
          schemaProp: prop,
          dataProp: prop
        }, valid);
      }
    }
  };
  properties$9.default = def;
  return properties$9;
}
var patternProperties = {};
var hasRequiredPatternProperties;
function requirePatternProperties() {
  if (hasRequiredPatternProperties) return patternProperties;
  hasRequiredPatternProperties = 1;
  Object.defineProperty(patternProperties, "__esModule", { value: true });
  const code_1 = requireCode();
  const codegen_1 = requireCodegen();
  const util_1 = requireUtil();
  const util_2 = requireUtil();
  const def = {
    keyword: "patternProperties",
    type: "object",
    schemaType: "object",
    code(cxt) {
      const { gen, schema, data: data2, parentSchema, it } = cxt;
      const { opts } = it;
      const patterns = (0, code_1.allSchemaProperties)(schema);
      const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
      if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
        return;
      }
      const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
      const valid = gen.name("valid");
      if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
        it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
      }
      const { props } = it;
      validatePatternProperties();
      function validatePatternProperties() {
        for (const pat of patterns) {
          if (checkProperties)
            checkMatchingProperties(pat);
          if (it.allErrors) {
            validateProperties(pat);
          } else {
            gen.var(valid, true);
            validateProperties(pat);
            gen.if(valid);
          }
        }
      }
      function checkMatchingProperties(pat) {
        for (const prop in checkProperties) {
          if (new RegExp(pat).test(prop)) {
            (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
          }
        }
      }
      function validateProperties(pat) {
        gen.forIn("key", data2, (key) => {
          gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
            const alwaysValid = alwaysValidPatterns.includes(pat);
            if (!alwaysValid) {
              cxt.subschema({
                keyword: "patternProperties",
                schemaProp: pat,
                dataProp: key,
                dataPropType: util_2.Type.Str
              }, valid);
            }
            if (it.opts.unevaluated && props !== true) {
              gen.assign((0, codegen_1._)`${props}[${key}]`, true);
            } else if (!alwaysValid && !it.allErrors) {
              gen.if((0, codegen_1.not)(valid), () => gen.break());
            }
          });
        });
      }
    }
  };
  patternProperties.default = def;
  return patternProperties;
}
var not = {};
var hasRequiredNot;
function requireNot() {
  if (hasRequiredNot) return not;
  hasRequiredNot = 1;
  Object.defineProperty(not, "__esModule", { value: true });
  const util_1 = requireUtil();
  const def = {
    keyword: "not",
    schemaType: ["object", "boolean"],
    trackErrors: true,
    code(cxt) {
      const { gen, schema, it } = cxt;
      if ((0, util_1.alwaysValidSchema)(it, schema)) {
        cxt.fail();
        return;
      }
      const valid = gen.name("valid");
      cxt.subschema({
        keyword: "not",
        compositeRule: true,
        createErrors: false,
        allErrors: false
      }, valid);
      cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
    },
    error: { message: "must NOT be valid" }
  };
  not.default = def;
  return not;
}
var anyOf = {};
var hasRequiredAnyOf;
function requireAnyOf() {
  if (hasRequiredAnyOf) return anyOf;
  hasRequiredAnyOf = 1;
  Object.defineProperty(anyOf, "__esModule", { value: true });
  const code_1 = requireCode();
  const def = {
    keyword: "anyOf",
    schemaType: "array",
    trackErrors: true,
    code: code_1.validateUnion,
    error: { message: "must match a schema in anyOf" }
  };
  anyOf.default = def;
  return anyOf;
}
var oneOf = {};
var hasRequiredOneOf;
function requireOneOf() {
  if (hasRequiredOneOf) return oneOf;
  hasRequiredOneOf = 1;
  Object.defineProperty(oneOf, "__esModule", { value: true });
  const codegen_1 = requireCodegen();
  const util_1 = requireUtil();
  const error = {
    message: "must match exactly one schema in oneOf",
    params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
  };
  const def = {
    keyword: "oneOf",
    schemaType: "array",
    trackErrors: true,
    error,
    code(cxt) {
      const { gen, schema, parentSchema, it } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      if (it.opts.discriminator && parentSchema.discriminator)
        return;
      const schArr = schema;
      const valid = gen.let("valid", false);
      const passing = gen.let("passing", null);
      const schValid = gen.name("_valid");
      cxt.setParams({ passing });
      gen.block(validateOneOf);
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
      function validateOneOf() {
        schArr.forEach((sch, i) => {
          let schCxt;
          if ((0, util_1.alwaysValidSchema)(it, sch)) {
            gen.var(schValid, true);
          } else {
            schCxt = cxt.subschema({
              keyword: "oneOf",
              schemaProp: i,
              compositeRule: true
            }, schValid);
          }
          if (i > 0) {
            gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
          }
          gen.if(schValid, () => {
            gen.assign(valid, true);
            gen.assign(passing, i);
            if (schCxt)
              cxt.mergeEvaluated(schCxt, codegen_1.Name);
          });
        });
      }
    }
  };
  oneOf.default = def;
  return oneOf;
}
var allOf$1 = {};
var hasRequiredAllOf;
function requireAllOf() {
  if (hasRequiredAllOf) return allOf$1;
  hasRequiredAllOf = 1;
  Object.defineProperty(allOf$1, "__esModule", { value: true });
  const util_1 = requireUtil();
  const def = {
    keyword: "allOf",
    schemaType: "array",
    code(cxt) {
      const { gen, schema, it } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const valid = gen.name("valid");
      schema.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it, sch))
          return;
        const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
        cxt.ok(valid);
        cxt.mergeEvaluated(schCxt);
      });
    }
  };
  allOf$1.default = def;
  return allOf$1;
}
var _if = {};
var hasRequired_if;
function require_if() {
  if (hasRequired_if) return _if;
  hasRequired_if = 1;
  Object.defineProperty(_if, "__esModule", { value: true });
  const codegen_1 = requireCodegen();
  const util_1 = requireUtil();
  const error = {
    message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
    params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
  };
  const def = {
    keyword: "if",
    schemaType: ["object", "boolean"],
    trackErrors: true,
    error,
    code(cxt) {
      const { gen, parentSchema, it } = cxt;
      if (parentSchema.then === void 0 && parentSchema.else === void 0) {
        (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
      }
      const hasThen = hasSchema(it, "then");
      const hasElse = hasSchema(it, "else");
      if (!hasThen && !hasElse)
        return;
      const valid = gen.let("valid", true);
      const schValid = gen.name("_valid");
      validateIf();
      cxt.reset();
      if (hasThen && hasElse) {
        const ifClause = gen.let("ifClause");
        cxt.setParams({ ifClause });
        gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
      } else if (hasThen) {
        gen.if(schValid, validateClause("then"));
      } else {
        gen.if((0, codegen_1.not)(schValid), validateClause("else"));
      }
      cxt.pass(valid, () => cxt.error(true));
      function validateIf() {
        const schCxt = cxt.subschema({
          keyword: "if",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, schValid);
        cxt.mergeEvaluated(schCxt);
      }
      function validateClause(keyword2, ifClause) {
        return () => {
          const schCxt = cxt.subschema({ keyword: keyword2 }, schValid);
          gen.assign(valid, schValid);
          cxt.mergeValidEvaluated(schCxt, valid);
          if (ifClause)
            gen.assign(ifClause, (0, codegen_1._)`${keyword2}`);
          else
            cxt.setParams({ ifClause: keyword2 });
        };
      }
    }
  };
  function hasSchema(it, keyword2) {
    const schema = it.schema[keyword2];
    return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it, schema);
  }
  _if.default = def;
  return _if;
}
var thenElse = {};
var hasRequiredThenElse;
function requireThenElse() {
  if (hasRequiredThenElse) return thenElse;
  hasRequiredThenElse = 1;
  Object.defineProperty(thenElse, "__esModule", { value: true });
  const util_1 = requireUtil();
  const def = {
    keyword: ["then", "else"],
    schemaType: ["object", "boolean"],
    code({ keyword: keyword2, parentSchema, it }) {
      if (parentSchema.if === void 0)
        (0, util_1.checkStrictMode)(it, `"${keyword2}" without "if" is ignored`);
    }
  };
  thenElse.default = def;
  return thenElse;
}
var hasRequiredApplicator;
function requireApplicator() {
  if (hasRequiredApplicator) return applicator;
  hasRequiredApplicator = 1;
  Object.defineProperty(applicator, "__esModule", { value: true });
  const additionalItems_1 = requireAdditionalItems();
  const prefixItems_1 = requirePrefixItems();
  const items_1 = requireItems();
  const items2020_1 = requireItems2020();
  const contains_1 = requireContains();
  const dependencies_1 = requireDependencies();
  const propertyNames_1 = requirePropertyNames();
  const additionalProperties_1 = requireAdditionalProperties();
  const properties_1 = requireProperties();
  const patternProperties_1 = requirePatternProperties();
  const not_1 = requireNot();
  const anyOf_1 = requireAnyOf();
  const oneOf_1 = requireOneOf();
  const allOf_1 = requireAllOf();
  const if_1 = require_if();
  const thenElse_1 = requireThenElse();
  function getApplicator(draft20202 = false) {
    const applicator2 = [
      // any
      not_1.default,
      anyOf_1.default,
      oneOf_1.default,
      allOf_1.default,
      if_1.default,
      thenElse_1.default,
      // object
      propertyNames_1.default,
      additionalProperties_1.default,
      dependencies_1.default,
      properties_1.default,
      patternProperties_1.default
    ];
    if (draft20202)
      applicator2.push(prefixItems_1.default, items2020_1.default);
    else
      applicator2.push(additionalItems_1.default, items_1.default);
    applicator2.push(contains_1.default);
    return applicator2;
  }
  applicator.default = getApplicator;
  return applicator;
}
var dynamic = {};
var dynamicAnchor = {};
var hasRequiredDynamicAnchor;
function requireDynamicAnchor() {
  if (hasRequiredDynamicAnchor) return dynamicAnchor;
  hasRequiredDynamicAnchor = 1;
  Object.defineProperty(dynamicAnchor, "__esModule", { value: true });
  dynamicAnchor.dynamicAnchor = void 0;
  const codegen_1 = requireCodegen();
  const names_1 = requireNames();
  const compile_1 = requireCompile();
  const ref_1 = requireRef();
  const def = {
    keyword: "$dynamicAnchor",
    schemaType: "string",
    code: (cxt) => dynamicAnchor$1(cxt, cxt.schema)
  };
  function dynamicAnchor$1(cxt, anchor) {
    const { gen, it } = cxt;
    it.schemaEnv.root.dynamicAnchors[anchor] = true;
    const v = (0, codegen_1._)`${names_1.default.dynamicAnchors}${(0, codegen_1.getProperty)(anchor)}`;
    const validate2 = it.errSchemaPath === "#" ? it.validateName : _getValidate(cxt);
    gen.if((0, codegen_1._)`!${v}`, () => gen.assign(v, validate2));
  }
  dynamicAnchor.dynamicAnchor = dynamicAnchor$1;
  function _getValidate(cxt) {
    const { schemaEnv, schema, self: self2 } = cxt.it;
    const { root, baseId, localRefs, meta } = schemaEnv.root;
    const { schemaId } = self2.opts;
    const sch = new compile_1.SchemaEnv({ schema, schemaId, root, baseId, localRefs, meta });
    compile_1.compileSchema.call(self2, sch);
    return (0, ref_1.getValidate)(cxt, sch);
  }
  dynamicAnchor.default = def;
  return dynamicAnchor;
}
var dynamicRef = {};
var hasRequiredDynamicRef;
function requireDynamicRef() {
  if (hasRequiredDynamicRef) return dynamicRef;
  hasRequiredDynamicRef = 1;
  Object.defineProperty(dynamicRef, "__esModule", { value: true });
  dynamicRef.dynamicRef = void 0;
  const codegen_1 = requireCodegen();
  const names_1 = requireNames();
  const ref_1 = requireRef();
  const def = {
    keyword: "$dynamicRef",
    schemaType: "string",
    code: (cxt) => dynamicRef$1(cxt, cxt.schema)
  };
  function dynamicRef$1(cxt, ref2) {
    const { gen, keyword: keyword2, it } = cxt;
    if (ref2[0] !== "#")
      throw new Error(`"${keyword2}" only supports hash fragment reference`);
    const anchor = ref2.slice(1);
    if (it.allErrors) {
      _dynamicRef();
    } else {
      const valid = gen.let("valid", false);
      _dynamicRef(valid);
      cxt.ok(valid);
    }
    function _dynamicRef(valid) {
      if (it.schemaEnv.root.dynamicAnchors[anchor]) {
        const v = gen.let("_v", (0, codegen_1._)`${names_1.default.dynamicAnchors}${(0, codegen_1.getProperty)(anchor)}`);
        gen.if(v, _callRef(v, valid), _callRef(it.validateName, valid));
      } else {
        _callRef(it.validateName, valid)();
      }
    }
    function _callRef(validate2, valid) {
      return valid ? () => gen.block(() => {
        (0, ref_1.callRef)(cxt, validate2);
        gen.let(valid, true);
      }) : () => (0, ref_1.callRef)(cxt, validate2);
    }
  }
  dynamicRef.dynamicRef = dynamicRef$1;
  dynamicRef.default = def;
  return dynamicRef;
}
var recursiveAnchor = {};
var hasRequiredRecursiveAnchor;
function requireRecursiveAnchor() {
  if (hasRequiredRecursiveAnchor) return recursiveAnchor;
  hasRequiredRecursiveAnchor = 1;
  Object.defineProperty(recursiveAnchor, "__esModule", { value: true });
  const dynamicAnchor_1 = requireDynamicAnchor();
  const util_1 = requireUtil();
  const def = {
    keyword: "$recursiveAnchor",
    schemaType: "boolean",
    code(cxt) {
      if (cxt.schema)
        (0, dynamicAnchor_1.dynamicAnchor)(cxt, "");
      else
        (0, util_1.checkStrictMode)(cxt.it, "$recursiveAnchor: false is ignored");
    }
  };
  recursiveAnchor.default = def;
  return recursiveAnchor;
}
var recursiveRef = {};
var hasRequiredRecursiveRef;
function requireRecursiveRef() {
  if (hasRequiredRecursiveRef) return recursiveRef;
  hasRequiredRecursiveRef = 1;
  Object.defineProperty(recursiveRef, "__esModule", { value: true });
  const dynamicRef_1 = requireDynamicRef();
  const def = {
    keyword: "$recursiveRef",
    schemaType: "string",
    code: (cxt) => (0, dynamicRef_1.dynamicRef)(cxt, cxt.schema)
  };
  recursiveRef.default = def;
  return recursiveRef;
}
var hasRequiredDynamic;
function requireDynamic() {
  if (hasRequiredDynamic) return dynamic;
  hasRequiredDynamic = 1;
  Object.defineProperty(dynamic, "__esModule", { value: true });
  const dynamicAnchor_1 = requireDynamicAnchor();
  const dynamicRef_1 = requireDynamicRef();
  const recursiveAnchor_1 = requireRecursiveAnchor();
  const recursiveRef_1 = requireRecursiveRef();
  const dynamic$1 = [dynamicAnchor_1.default, dynamicRef_1.default, recursiveAnchor_1.default, recursiveRef_1.default];
  dynamic.default = dynamic$1;
  return dynamic;
}
var next = {};
var dependentRequired = {};
var hasRequiredDependentRequired;
function requireDependentRequired() {
  if (hasRequiredDependentRequired) return dependentRequired;
  hasRequiredDependentRequired = 1;
  Object.defineProperty(dependentRequired, "__esModule", { value: true });
  const dependencies_1 = requireDependencies();
  const def = {
    keyword: "dependentRequired",
    type: "object",
    schemaType: "object",
    error: dependencies_1.error,
    code: (cxt) => (0, dependencies_1.validatePropertyDeps)(cxt)
  };
  dependentRequired.default = def;
  return dependentRequired;
}
var dependentSchemas = {};
var hasRequiredDependentSchemas;
function requireDependentSchemas() {
  if (hasRequiredDependentSchemas) return dependentSchemas;
  hasRequiredDependentSchemas = 1;
  Object.defineProperty(dependentSchemas, "__esModule", { value: true });
  const dependencies_1 = requireDependencies();
  const def = {
    keyword: "dependentSchemas",
    type: "object",
    schemaType: "object",
    code: (cxt) => (0, dependencies_1.validateSchemaDeps)(cxt)
  };
  dependentSchemas.default = def;
  return dependentSchemas;
}
var limitContains = {};
var hasRequiredLimitContains;
function requireLimitContains() {
  if (hasRequiredLimitContains) return limitContains;
  hasRequiredLimitContains = 1;
  Object.defineProperty(limitContains, "__esModule", { value: true });
  const util_1 = requireUtil();
  const def = {
    keyword: ["maxContains", "minContains"],
    type: "array",
    schemaType: "number",
    code({ keyword: keyword2, parentSchema, it }) {
      if (parentSchema.contains === void 0) {
        (0, util_1.checkStrictMode)(it, `"${keyword2}" without "contains" is ignored`);
      }
    }
  };
  limitContains.default = def;
  return limitContains;
}
var hasRequiredNext;
function requireNext() {
  if (hasRequiredNext) return next;
  hasRequiredNext = 1;
  Object.defineProperty(next, "__esModule", { value: true });
  const dependentRequired_1 = requireDependentRequired();
  const dependentSchemas_1 = requireDependentSchemas();
  const limitContains_1 = requireLimitContains();
  const next$1 = [dependentRequired_1.default, dependentSchemas_1.default, limitContains_1.default];
  next.default = next$1;
  return next;
}
var unevaluated = {};
var unevaluatedProperties = {};
var hasRequiredUnevaluatedProperties;
function requireUnevaluatedProperties() {
  if (hasRequiredUnevaluatedProperties) return unevaluatedProperties;
  hasRequiredUnevaluatedProperties = 1;
  Object.defineProperty(unevaluatedProperties, "__esModule", { value: true });
  const codegen_1 = requireCodegen();
  const util_1 = requireUtil();
  const names_1 = requireNames();
  const error = {
    message: "must NOT have unevaluated properties",
    params: ({ params }) => (0, codegen_1._)`{unevaluatedProperty: ${params.unevaluatedProperty}}`
  };
  const def = {
    keyword: "unevaluatedProperties",
    type: "object",
    schemaType: ["boolean", "object"],
    trackErrors: true,
    error,
    code(cxt) {
      const { gen, schema, data: data2, errsCount, it } = cxt;
      if (!errsCount)
        throw new Error("ajv implementation error");
      const { allErrors, props } = it;
      if (props instanceof codegen_1.Name) {
        gen.if((0, codegen_1._)`${props} !== true`, () => gen.forIn("key", data2, (key) => gen.if(unevaluatedDynamic(props, key), () => unevaluatedPropCode(key))));
      } else if (props !== true) {
        gen.forIn("key", data2, (key) => props === void 0 ? unevaluatedPropCode(key) : gen.if(unevaluatedStatic(props, key), () => unevaluatedPropCode(key)));
      }
      it.props = true;
      cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
      function unevaluatedPropCode(key) {
        if (schema === false) {
          cxt.setParams({ unevaluatedProperty: key });
          cxt.error();
          if (!allErrors)
            gen.break();
          return;
        }
        if (!(0, util_1.alwaysValidSchema)(it, schema)) {
          const valid = gen.name("valid");
          cxt.subschema({
            keyword: "unevaluatedProperties",
            dataProp: key,
            dataPropType: util_1.Type.Str
          }, valid);
          if (!allErrors)
            gen.if((0, codegen_1.not)(valid), () => gen.break());
        }
      }
      function unevaluatedDynamic(evaluatedProps, key) {
        return (0, codegen_1._)`!${evaluatedProps} || !${evaluatedProps}[${key}]`;
      }
      function unevaluatedStatic(evaluatedProps, key) {
        const ps = [];
        for (const p in evaluatedProps) {
          if (evaluatedProps[p] === true)
            ps.push((0, codegen_1._)`${key} !== ${p}`);
        }
        return (0, codegen_1.and)(...ps);
      }
    }
  };
  unevaluatedProperties.default = def;
  return unevaluatedProperties;
}
var unevaluatedItems = {};
var hasRequiredUnevaluatedItems;
function requireUnevaluatedItems() {
  if (hasRequiredUnevaluatedItems) return unevaluatedItems;
  hasRequiredUnevaluatedItems = 1;
  Object.defineProperty(unevaluatedItems, "__esModule", { value: true });
  const codegen_1 = requireCodegen();
  const util_1 = requireUtil();
  const error = {
    message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
    params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
  };
  const def = {
    keyword: "unevaluatedItems",
    type: "array",
    schemaType: ["boolean", "object"],
    error,
    code(cxt) {
      const { gen, schema, data: data2, it } = cxt;
      const items2 = it.items || 0;
      if (items2 === true)
        return;
      const len = gen.const("len", (0, codegen_1._)`${data2}.length`);
      if (schema === false) {
        cxt.setParams({ len: items2 });
        cxt.fail((0, codegen_1._)`${len} > ${items2}`);
      } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
        const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items2}`);
        gen.if((0, codegen_1.not)(valid), () => validateItems2(valid, items2));
        cxt.ok(valid);
      }
      it.items = true;
      function validateItems2(valid, from) {
        gen.forRange("i", from, len, (i) => {
          cxt.subschema({ keyword: "unevaluatedItems", dataProp: i, dataPropType: util_1.Type.Num }, valid);
          if (!it.allErrors)
            gen.if((0, codegen_1.not)(valid), () => gen.break());
        });
      }
    }
  };
  unevaluatedItems.default = def;
  return unevaluatedItems;
}
var hasRequiredUnevaluated;
function requireUnevaluated() {
  if (hasRequiredUnevaluated) return unevaluated;
  hasRequiredUnevaluated = 1;
  Object.defineProperty(unevaluated, "__esModule", { value: true });
  const unevaluatedProperties_1 = requireUnevaluatedProperties();
  const unevaluatedItems_1 = requireUnevaluatedItems();
  const unevaluated$1 = [unevaluatedProperties_1.default, unevaluatedItems_1.default];
  unevaluated.default = unevaluated$1;
  return unevaluated;
}
var format$1 = {};
var format = {};
var hasRequiredFormat$1;
function requireFormat$1() {
  if (hasRequiredFormat$1) return format;
  hasRequiredFormat$1 = 1;
  Object.defineProperty(format, "__esModule", { value: true });
  const codegen_1 = requireCodegen();
  const error = {
    message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
    params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
  };
  const def = {
    keyword: "format",
    type: ["number", "string"],
    schemaType: "string",
    $data: true,
    error,
    code(cxt, ruleType) {
      const { gen, data: data2, $data, schema, schemaCode, it } = cxt;
      const { opts, errSchemaPath, schemaEnv, self: self2 } = it;
      if (!opts.validateFormats)
        return;
      if ($data)
        validate$DataFormat();
      else
        validateFormat();
      function validate$DataFormat() {
        const fmts = gen.scopeValue("formats", {
          ref: self2.formats,
          code: opts.code.formats
        });
        const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
        const fType = gen.let("fType");
        const format2 = gen.let("format");
        gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format2, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format2, fDef));
        cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
        function unknownFmt() {
          if (opts.strictSchema === false)
            return codegen_1.nil;
          return (0, codegen_1._)`${schemaCode} && !${format2}`;
        }
        function invalidFmt() {
          const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format2}(${data2}) : ${format2}(${data2}))` : (0, codegen_1._)`${format2}(${data2})`;
          const validData = (0, codegen_1._)`(typeof ${format2} == "function" ? ${callFormat} : ${format2}.test(${data2}))`;
          return (0, codegen_1._)`${format2} && ${format2} !== true && ${fType} === ${ruleType} && !${validData}`;
        }
      }
      function validateFormat() {
        const formatDef = self2.formats[schema];
        if (!formatDef) {
          unknownFormat();
          return;
        }
        if (formatDef === true)
          return;
        const [fmtType, format2, fmtRef] = getFormat(formatDef);
        if (fmtType === ruleType)
          cxt.pass(validCondition());
        function unknownFormat() {
          if (opts.strictSchema === false) {
            self2.logger.warn(unknownMsg());
            return;
          }
          throw new Error(unknownMsg());
          function unknownMsg() {
            return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
          }
        }
        function getFormat(fmtDef) {
          const code2 = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0;
          const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code: code2 });
          if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
            return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
          }
          return ["string", fmtDef, fmt];
        }
        function validCondition() {
          if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
            if (!schemaEnv.$async)
              throw new Error("async format in sync schema");
            return (0, codegen_1._)`await ${fmtRef}(${data2})`;
          }
          return typeof format2 == "function" ? (0, codegen_1._)`${fmtRef}(${data2})` : (0, codegen_1._)`${fmtRef}.test(${data2})`;
        }
      }
    }
  };
  format.default = def;
  return format;
}
var hasRequiredFormat;
function requireFormat() {
  if (hasRequiredFormat) return format$1;
  hasRequiredFormat = 1;
  Object.defineProperty(format$1, "__esModule", { value: true });
  const format_1 = requireFormat$1();
  const format2 = [format_1.default];
  format$1.default = format2;
  return format$1;
}
var metadata = {};
var hasRequiredMetadata;
function requireMetadata() {
  if (hasRequiredMetadata) return metadata;
  hasRequiredMetadata = 1;
  Object.defineProperty(metadata, "__esModule", { value: true });
  metadata.contentVocabulary = metadata.metadataVocabulary = void 0;
  metadata.metadataVocabulary = [
    "title",
    "description",
    "default",
    "deprecated",
    "readOnly",
    "writeOnly",
    "examples"
  ];
  metadata.contentVocabulary = [
    "contentMediaType",
    "contentEncoding",
    "contentSchema"
  ];
  return metadata;
}
var hasRequiredDraft2020;
function requireDraft2020() {
  if (hasRequiredDraft2020) return draft2020;
  hasRequiredDraft2020 = 1;
  Object.defineProperty(draft2020, "__esModule", { value: true });
  const core_1 = requireCore();
  const validation_1 = requireValidation();
  const applicator_1 = requireApplicator();
  const dynamic_1 = requireDynamic();
  const next_1 = requireNext();
  const unevaluated_1 = requireUnevaluated();
  const format_1 = requireFormat();
  const metadata_1 = requireMetadata();
  const draft2020Vocabularies = [
    dynamic_1.default,
    core_1.default,
    validation_1.default,
    (0, applicator_1.default)(true),
    format_1.default,
    metadata_1.metadataVocabulary,
    metadata_1.contentVocabulary,
    next_1.default,
    unevaluated_1.default
  ];
  draft2020.default = draft2020Vocabularies;
  return draft2020;
}
var discriminator = {};
var types = {};
var hasRequiredTypes;
function requireTypes() {
  if (hasRequiredTypes) return types;
  hasRequiredTypes = 1;
  Object.defineProperty(types, "__esModule", { value: true });
  types.DiscrError = void 0;
  var DiscrError;
  (function(DiscrError2) {
    DiscrError2["Tag"] = "tag";
    DiscrError2["Mapping"] = "mapping";
  })(DiscrError || (types.DiscrError = DiscrError = {}));
  return types;
}
var hasRequiredDiscriminator;
function requireDiscriminator() {
  if (hasRequiredDiscriminator) return discriminator;
  hasRequiredDiscriminator = 1;
  Object.defineProperty(discriminator, "__esModule", { value: true });
  const codegen_1 = requireCodegen();
  const types_1 = requireTypes();
  const compile_1 = requireCompile();
  const ref_error_1 = requireRef_error();
  const util_1 = requireUtil();
  const error = {
    message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
    params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
  };
  const def = {
    keyword: "discriminator",
    type: "object",
    schemaType: "object",
    error,
    code(cxt) {
      const { gen, data: data2, schema, parentSchema, it } = cxt;
      const { oneOf: oneOf2 } = parentSchema;
      if (!it.opts.discriminator) {
        throw new Error("discriminator: requires discriminator option");
      }
      const tagName = schema.propertyName;
      if (typeof tagName != "string")
        throw new Error("discriminator: requires propertyName");
      if (schema.mapping)
        throw new Error("discriminator: mapping is not supported");
      if (!oneOf2)
        throw new Error("discriminator: requires oneOf keyword");
      const valid = gen.let("valid", false);
      const tag = gen.const("tag", (0, codegen_1._)`${data2}${(0, codegen_1.getProperty)(tagName)}`);
      gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
      cxt.ok(valid);
      function validateMapping() {
        const mapping = getMapping();
        gen.if(false);
        for (const tagValue in mapping) {
          gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
          gen.assign(valid, applyTagSchema(mapping[tagValue]));
        }
        gen.else();
        cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
        gen.endIf();
      }
      function applyTagSchema(schemaProp) {
        const _valid = gen.name("valid");
        const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
        cxt.mergeEvaluated(schCxt, codegen_1.Name);
        return _valid;
      }
      function getMapping() {
        var _a;
        const oneOfMapping = {};
        const topRequired = hasRequired(parentSchema);
        let tagRequired = true;
        for (let i = 0; i < oneOf2.length; i++) {
          let sch = oneOf2[i];
          if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
            const ref2 = sch.$ref;
            sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref2);
            if (sch instanceof compile_1.SchemaEnv)
              sch = sch.schema;
            if (sch === void 0)
              throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref2);
          }
          const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
          if (typeof propSch != "object") {
            throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
          }
          tagRequired = tagRequired && (topRequired || hasRequired(sch));
          addMappings(propSch, i);
        }
        if (!tagRequired)
          throw new Error(`discriminator: "${tagName}" must be required`);
        return oneOfMapping;
        function hasRequired({ required: required2 }) {
          return Array.isArray(required2) && required2.includes(tagName);
        }
        function addMappings(sch, i) {
          if (sch.const) {
            addMapping(sch.const, i);
          } else if (sch.enum) {
            for (const tagValue of sch.enum) {
              addMapping(tagValue, i);
            }
          } else {
            throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
          }
        }
        function addMapping(tagValue, i) {
          if (typeof tagValue != "string" || tagValue in oneOfMapping) {
            throw new Error(`discriminator: "${tagName}" values must be unique strings`);
          }
          oneOfMapping[tagValue] = i;
        }
      }
    }
  };
  discriminator.default = def;
  return discriminator;
}
var jsonSchema202012 = {};
const $schema$8 = "https://json-schema.org/draft/2020-12/schema";
const $id$8 = "https://json-schema.org/draft/2020-12/schema";
const $vocabulary$7 = { "https://json-schema.org/draft/2020-12/vocab/core": true, "https://json-schema.org/draft/2020-12/vocab/applicator": true, "https://json-schema.org/draft/2020-12/vocab/unevaluated": true, "https://json-schema.org/draft/2020-12/vocab/validation": true, "https://json-schema.org/draft/2020-12/vocab/meta-data": true, "https://json-schema.org/draft/2020-12/vocab/format-annotation": true, "https://json-schema.org/draft/2020-12/vocab/content": true };
const $dynamicAnchor$7 = "meta";
const title$8 = "Core and Validation specifications meta-schema";
const allOf = [{ "$ref": "meta/core" }, { "$ref": "meta/applicator" }, { "$ref": "meta/unevaluated" }, { "$ref": "meta/validation" }, { "$ref": "meta/meta-data" }, { "$ref": "meta/format-annotation" }, { "$ref": "meta/content" }];
const type$8 = ["object", "boolean"];
const $comment = "This meta-schema also defines keywords that have appeared in previous drafts in order to prevent incompatible extensions as they remain in common use.";
const properties$8 = { "definitions": { "$comment": '"definitions" has been replaced by "$defs".', "type": "object", "additionalProperties": { "$dynamicRef": "#meta" }, "deprecated": true, "default": {} }, "dependencies": { "$comment": '"dependencies" has been split and replaced by "dependentSchemas" and "dependentRequired" in order to serve their differing semantics.', "type": "object", "additionalProperties": { "anyOf": [{ "$dynamicRef": "#meta" }, { "$ref": "meta/validation#/$defs/stringArray" }] }, "deprecated": true, "default": {} }, "$recursiveAnchor": { "$comment": '"$recursiveAnchor" has been replaced by "$dynamicAnchor".', "$ref": "meta/core#/$defs/anchorString", "deprecated": true }, "$recursiveRef": { "$comment": '"$recursiveRef" has been replaced by "$dynamicRef".', "$ref": "meta/core#/$defs/uriReferenceString", "deprecated": true } };
const require$$0 = {
  $schema: $schema$8,
  $id: $id$8,
  $vocabulary: $vocabulary$7,
  $dynamicAnchor: $dynamicAnchor$7,
  title: title$8,
  allOf,
  type: type$8,
  $comment,
  properties: properties$8
};
const $schema$7 = "https://json-schema.org/draft/2020-12/schema";
const $id$7 = "https://json-schema.org/draft/2020-12/meta/applicator";
const $vocabulary$6 = { "https://json-schema.org/draft/2020-12/vocab/applicator": true };
const $dynamicAnchor$6 = "meta";
const title$7 = "Applicator vocabulary meta-schema";
const type$7 = ["object", "boolean"];
const properties$7 = { "prefixItems": { "$ref": "#/$defs/schemaArray" }, "items": { "$dynamicRef": "#meta" }, "contains": { "$dynamicRef": "#meta" }, "additionalProperties": { "$dynamicRef": "#meta" }, "properties": { "type": "object", "additionalProperties": { "$dynamicRef": "#meta" }, "default": {} }, "patternProperties": { "type": "object", "additionalProperties": { "$dynamicRef": "#meta" }, "propertyNames": { "format": "regex" }, "default": {} }, "dependentSchemas": { "type": "object", "additionalProperties": { "$dynamicRef": "#meta" }, "default": {} }, "propertyNames": { "$dynamicRef": "#meta" }, "if": { "$dynamicRef": "#meta" }, "then": { "$dynamicRef": "#meta" }, "else": { "$dynamicRef": "#meta" }, "allOf": { "$ref": "#/$defs/schemaArray" }, "anyOf": { "$ref": "#/$defs/schemaArray" }, "oneOf": { "$ref": "#/$defs/schemaArray" }, "not": { "$dynamicRef": "#meta" } };
const $defs$2 = { "schemaArray": { "type": "array", "minItems": 1, "items": { "$dynamicRef": "#meta" } } };
const require$$1 = {
  $schema: $schema$7,
  $id: $id$7,
  $vocabulary: $vocabulary$6,
  $dynamicAnchor: $dynamicAnchor$6,
  title: title$7,
  type: type$7,
  properties: properties$7,
  $defs: $defs$2
};
const $schema$6 = "https://json-schema.org/draft/2020-12/schema";
const $id$6 = "https://json-schema.org/draft/2020-12/meta/unevaluated";
const $vocabulary$5 = { "https://json-schema.org/draft/2020-12/vocab/unevaluated": true };
const $dynamicAnchor$5 = "meta";
const title$6 = "Unevaluated applicator vocabulary meta-schema";
const type$6 = ["object", "boolean"];
const properties$6 = { "unevaluatedItems": { "$dynamicRef": "#meta" }, "unevaluatedProperties": { "$dynamicRef": "#meta" } };
const require$$2 = {
  $schema: $schema$6,
  $id: $id$6,
  $vocabulary: $vocabulary$5,
  $dynamicAnchor: $dynamicAnchor$5,
  title: title$6,
  type: type$6,
  properties: properties$6
};
const $schema$5 = "https://json-schema.org/draft/2020-12/schema";
const $id$5 = "https://json-schema.org/draft/2020-12/meta/content";
const $vocabulary$4 = { "https://json-schema.org/draft/2020-12/vocab/content": true };
const $dynamicAnchor$4 = "meta";
const title$5 = "Content vocabulary meta-schema";
const type$5 = ["object", "boolean"];
const properties$5 = { "contentEncoding": { "type": "string" }, "contentMediaType": { "type": "string" }, "contentSchema": { "$dynamicRef": "#meta" } };
const require$$3$1 = {
  $schema: $schema$5,
  $id: $id$5,
  $vocabulary: $vocabulary$4,
  $dynamicAnchor: $dynamicAnchor$4,
  title: title$5,
  type: type$5,
  properties: properties$5
};
const $schema$4 = "https://json-schema.org/draft/2020-12/schema";
const $id$4 = "https://json-schema.org/draft/2020-12/meta/core";
const $vocabulary$3 = { "https://json-schema.org/draft/2020-12/vocab/core": true };
const $dynamicAnchor$3 = "meta";
const title$4 = "Core vocabulary meta-schema";
const type$4 = ["object", "boolean"];
const properties$4 = { "$id": { "$ref": "#/$defs/uriReferenceString", "$comment": "Non-empty fragments not allowed.", "pattern": "^[^#]*#?$" }, "$schema": { "$ref": "#/$defs/uriString" }, "$ref": { "$ref": "#/$defs/uriReferenceString" }, "$anchor": { "$ref": "#/$defs/anchorString" }, "$dynamicRef": { "$ref": "#/$defs/uriReferenceString" }, "$dynamicAnchor": { "$ref": "#/$defs/anchorString" }, "$vocabulary": { "type": "object", "propertyNames": { "$ref": "#/$defs/uriString" }, "additionalProperties": { "type": "boolean" } }, "$comment": { "type": "string" }, "$defs": { "type": "object", "additionalProperties": { "$dynamicRef": "#meta" } } };
const $defs$1 = { "anchorString": { "type": "string", "pattern": "^[A-Za-z_][-A-Za-z0-9._]*$" }, "uriString": { "type": "string", "format": "uri" }, "uriReferenceString": { "type": "string", "format": "uri-reference" } };
const require$$4 = {
  $schema: $schema$4,
  $id: $id$4,
  $vocabulary: $vocabulary$3,
  $dynamicAnchor: $dynamicAnchor$3,
  title: title$4,
  type: type$4,
  properties: properties$4,
  $defs: $defs$1
};
const $schema$3 = "https://json-schema.org/draft/2020-12/schema";
const $id$3 = "https://json-schema.org/draft/2020-12/meta/format-annotation";
const $vocabulary$2 = { "https://json-schema.org/draft/2020-12/vocab/format-annotation": true };
const $dynamicAnchor$2 = "meta";
const title$3 = "Format vocabulary meta-schema for annotation results";
const type$3 = ["object", "boolean"];
const properties$3 = { "format": { "type": "string" } };
const require$$5 = {
  $schema: $schema$3,
  $id: $id$3,
  $vocabulary: $vocabulary$2,
  $dynamicAnchor: $dynamicAnchor$2,
  title: title$3,
  type: type$3,
  properties: properties$3
};
const $schema$2 = "https://json-schema.org/draft/2020-12/schema";
const $id$2 = "https://json-schema.org/draft/2020-12/meta/meta-data";
const $vocabulary$1 = { "https://json-schema.org/draft/2020-12/vocab/meta-data": true };
const $dynamicAnchor$1 = "meta";
const title$2 = "Meta-data vocabulary meta-schema";
const type$2 = ["object", "boolean"];
const properties$2 = { "title": { "type": "string" }, "description": { "type": "string" }, "default": true, "deprecated": { "type": "boolean", "default": false }, "readOnly": { "type": "boolean", "default": false }, "writeOnly": { "type": "boolean", "default": false }, "examples": { "type": "array", "items": true } };
const require$$6 = {
  $schema: $schema$2,
  $id: $id$2,
  $vocabulary: $vocabulary$1,
  $dynamicAnchor: $dynamicAnchor$1,
  title: title$2,
  type: type$2,
  properties: properties$2
};
const $schema$1 = "https://json-schema.org/draft/2020-12/schema";
const $id$1 = "https://json-schema.org/draft/2020-12/meta/validation";
const $vocabulary = { "https://json-schema.org/draft/2020-12/vocab/validation": true };
const $dynamicAnchor = "meta";
const title$1 = "Validation vocabulary meta-schema";
const type$1 = ["object", "boolean"];
const properties$1 = { "type": { "anyOf": [{ "$ref": "#/$defs/simpleTypes" }, { "type": "array", "items": { "$ref": "#/$defs/simpleTypes" }, "minItems": 1, "uniqueItems": true }] }, "const": true, "enum": { "type": "array", "items": true }, "multipleOf": { "type": "number", "exclusiveMinimum": 0 }, "maximum": { "type": "number" }, "exclusiveMaximum": { "type": "number" }, "minimum": { "type": "number" }, "exclusiveMinimum": { "type": "number" }, "maxLength": { "$ref": "#/$defs/nonNegativeInteger" }, "minLength": { "$ref": "#/$defs/nonNegativeIntegerDefault0" }, "pattern": { "type": "string", "format": "regex" }, "maxItems": { "$ref": "#/$defs/nonNegativeInteger" }, "minItems": { "$ref": "#/$defs/nonNegativeIntegerDefault0" }, "uniqueItems": { "type": "boolean", "default": false }, "maxContains": { "$ref": "#/$defs/nonNegativeInteger" }, "minContains": { "$ref": "#/$defs/nonNegativeInteger", "default": 1 }, "maxProperties": { "$ref": "#/$defs/nonNegativeInteger" }, "minProperties": { "$ref": "#/$defs/nonNegativeIntegerDefault0" }, "required": { "$ref": "#/$defs/stringArray" }, "dependentRequired": { "type": "object", "additionalProperties": { "$ref": "#/$defs/stringArray" } } };
const $defs = { "nonNegativeInteger": { "type": "integer", "minimum": 0 }, "nonNegativeIntegerDefault0": { "$ref": "#/$defs/nonNegativeInteger", "default": 0 }, "simpleTypes": { "enum": ["array", "boolean", "integer", "null", "number", "object", "string"] }, "stringArray": { "type": "array", "items": { "type": "string" }, "uniqueItems": true, "default": [] } };
const require$$7 = {
  $schema: $schema$1,
  $id: $id$1,
  $vocabulary,
  $dynamicAnchor,
  title: title$1,
  type: type$1,
  properties: properties$1,
  $defs
};
var hasRequiredJsonSchema202012;
function requireJsonSchema202012() {
  if (hasRequiredJsonSchema202012) return jsonSchema202012;
  hasRequiredJsonSchema202012 = 1;
  Object.defineProperty(jsonSchema202012, "__esModule", { value: true });
  const metaSchema = require$$0;
  const applicator2 = require$$1;
  const unevaluated2 = require$$2;
  const content = require$$3$1;
  const core2 = require$$4;
  const format2 = require$$5;
  const metadata2 = require$$6;
  const validation2 = require$$7;
  const META_SUPPORT_DATA = ["/properties"];
  function addMetaSchema2020($data) {
    [
      metaSchema,
      applicator2,
      unevaluated2,
      content,
      core2,
      with$data(this, format2),
      metadata2,
      with$data(this, validation2)
    ].forEach((sch) => this.addMetaSchema(sch, void 0, false));
    return this;
    function with$data(ajv2, sch) {
      return $data ? ajv2.$dataMetaSchema(sch, META_SUPPORT_DATA) : sch;
    }
  }
  jsonSchema202012.default = addMetaSchema2020;
  return jsonSchema202012;
}
var hasRequired_2020;
function require_2020() {
  if (hasRequired_2020) return _2020$2.exports;
  hasRequired_2020 = 1;
  (function(module2, exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.MissingRefError = exports$1.ValidationError = exports$1.CodeGen = exports$1.Name = exports$1.nil = exports$1.stringify = exports$1.str = exports$1._ = exports$1.KeywordCxt = exports$1.Ajv2020 = void 0;
    const core_1 = requireCore$1();
    const draft2020_1 = requireDraft2020();
    const discriminator_1 = requireDiscriminator();
    const json_schema_2020_12_1 = requireJsonSchema202012();
    const META_SCHEMA_ID = "https://json-schema.org/draft/2020-12/schema";
    class Ajv2020 extends core_1.default {
      constructor(opts = {}) {
        super({
          ...opts,
          dynamicRef: true,
          next: true,
          unevaluated: true
        });
      }
      _addVocabularies() {
        super._addVocabularies();
        draft2020_1.default.forEach((v) => this.addVocabulary(v));
        if (this.opts.discriminator)
          this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        const { $data, meta } = this.opts;
        if (!meta)
          return;
        json_schema_2020_12_1.default.call(this, $data);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    }
    exports$1.Ajv2020 = Ajv2020;
    module2.exports = exports$1 = Ajv2020;
    module2.exports.Ajv2020 = Ajv2020;
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.default = Ajv2020;
    var validate_1 = requireValidate();
    Object.defineProperty(exports$1, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = requireCodegen();
    Object.defineProperty(exports$1, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports$1, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports$1, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports$1, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports$1, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports$1, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = requireValidation_error();
    Object.defineProperty(exports$1, "ValidationError", { enumerable: true, get: function() {
      return validation_error_1.default;
    } });
    var ref_error_1 = requireRef_error();
    Object.defineProperty(exports$1, "MissingRefError", { enumerable: true, get: function() {
      return ref_error_1.default;
    } });
  })(_2020$2, _2020$2.exports);
  return _2020$2.exports;
}
var _2020Exports = require_2020();
const _2020 = /* @__PURE__ */ getDefaultExportFromCjs(_2020Exports);
const _2020$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: _2020
}, [_2020Exports]);
var ajv$2 = { exports: {} };
var draft7 = {};
var hasRequiredDraft7;
function requireDraft7() {
  if (hasRequiredDraft7) return draft7;
  hasRequiredDraft7 = 1;
  Object.defineProperty(draft7, "__esModule", { value: true });
  const core_1 = requireCore();
  const validation_1 = requireValidation();
  const applicator_1 = requireApplicator();
  const format_1 = requireFormat();
  const metadata_1 = requireMetadata();
  const draft7Vocabularies = [
    core_1.default,
    validation_1.default,
    (0, applicator_1.default)(),
    format_1.default,
    metadata_1.metadataVocabulary,
    metadata_1.contentVocabulary
  ];
  draft7.default = draft7Vocabularies;
  return draft7;
}
const $schema = "http://json-schema.org/draft-07/schema#";
const $id = "http://json-schema.org/draft-07/schema#";
const title = "Core schema meta-schema";
const definitions = { "schemaArray": { "type": "array", "minItems": 1, "items": { "$ref": "#" } }, "nonNegativeInteger": { "type": "integer", "minimum": 0 }, "nonNegativeIntegerDefault0": { "allOf": [{ "$ref": "#/definitions/nonNegativeInteger" }, { "default": 0 }] }, "simpleTypes": { "enum": ["array", "boolean", "integer", "null", "number", "object", "string"] }, "stringArray": { "type": "array", "items": { "type": "string" }, "uniqueItems": true, "default": [] } };
const type = ["object", "boolean"];
const properties = { "$id": { "type": "string", "format": "uri-reference" }, "$schema": { "type": "string", "format": "uri" }, "$ref": { "type": "string", "format": "uri-reference" }, "$comment": { "type": "string" }, "title": { "type": "string" }, "description": { "type": "string" }, "default": true, "readOnly": { "type": "boolean", "default": false }, "examples": { "type": "array", "items": true }, "multipleOf": { "type": "number", "exclusiveMinimum": 0 }, "maximum": { "type": "number" }, "exclusiveMaximum": { "type": "number" }, "minimum": { "type": "number" }, "exclusiveMinimum": { "type": "number" }, "maxLength": { "$ref": "#/definitions/nonNegativeInteger" }, "minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "pattern": { "type": "string", "format": "regex" }, "additionalItems": { "$ref": "#" }, "items": { "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/schemaArray" }], "default": true }, "maxItems": { "$ref": "#/definitions/nonNegativeInteger" }, "minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "uniqueItems": { "type": "boolean", "default": false }, "contains": { "$ref": "#" }, "maxProperties": { "$ref": "#/definitions/nonNegativeInteger" }, "minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "required": { "$ref": "#/definitions/stringArray" }, "additionalProperties": { "$ref": "#" }, "definitions": { "type": "object", "additionalProperties": { "$ref": "#" }, "default": {} }, "properties": { "type": "object", "additionalProperties": { "$ref": "#" }, "default": {} }, "patternProperties": { "type": "object", "additionalProperties": { "$ref": "#" }, "propertyNames": { "format": "regex" }, "default": {} }, "dependencies": { "type": "object", "additionalProperties": { "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/stringArray" }] } }, "propertyNames": { "$ref": "#" }, "const": true, "enum": { "type": "array", "items": true, "minItems": 1, "uniqueItems": true }, "type": { "anyOf": [{ "$ref": "#/definitions/simpleTypes" }, { "type": "array", "items": { "$ref": "#/definitions/simpleTypes" }, "minItems": 1, "uniqueItems": true }] }, "format": { "type": "string" }, "contentMediaType": { "type": "string" }, "contentEncoding": { "type": "string" }, "if": { "$ref": "#" }, "then": { "$ref": "#" }, "else": { "$ref": "#" }, "allOf": { "$ref": "#/definitions/schemaArray" }, "anyOf": { "$ref": "#/definitions/schemaArray" }, "oneOf": { "$ref": "#/definitions/schemaArray" }, "not": { "$ref": "#" } };
const require$$3 = {
  $schema,
  $id,
  title,
  definitions,
  type,
  properties,
  "default": true
};
var hasRequiredAjv;
function requireAjv() {
  if (hasRequiredAjv) return ajv$2.exports;
  hasRequiredAjv = 1;
  (function(module2, exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.MissingRefError = exports$1.ValidationError = exports$1.CodeGen = exports$1.Name = exports$1.nil = exports$1.stringify = exports$1.str = exports$1._ = exports$1.KeywordCxt = exports$1.Ajv = void 0;
    const core_1 = requireCore$1();
    const draft7_1 = requireDraft7();
    const discriminator_1 = requireDiscriminator();
    const draft7MetaSchema = require$$3;
    const META_SUPPORT_DATA = ["/properties"];
    const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    class Ajv extends core_1.default {
      _addVocabularies() {
        super._addVocabularies();
        draft7_1.default.forEach((v) => this.addVocabulary(v));
        if (this.opts.discriminator)
          this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta)
          return;
        const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    }
    exports$1.Ajv = Ajv;
    module2.exports = exports$1 = Ajv;
    module2.exports.Ajv = Ajv;
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.default = Ajv;
    var validate_1 = requireValidate();
    Object.defineProperty(exports$1, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = requireCodegen();
    Object.defineProperty(exports$1, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports$1, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports$1, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports$1, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports$1, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports$1, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = requireValidation_error();
    Object.defineProperty(exports$1, "ValidationError", { enumerable: true, get: function() {
      return validation_error_1.default;
    } });
    var ref_error_1 = requireRef_error();
    Object.defineProperty(exports$1, "MissingRefError", { enumerable: true, get: function() {
      return ref_error_1.default;
    } });
  })(ajv$2, ajv$2.exports);
  return ajv$2.exports;
}
var ajvExports = requireAjv();
const ajv = /* @__PURE__ */ getDefaultExportFromCjs(ajvExports);
const ajv$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: ajv
}, Symbol.toStringTag, { value: "Module" }));
export {
  MaiaOS,
  createCoJSONAPI,
  getSchemaIndexColistId,
  isPRFSupported,
  signInWithPasskey,
  signUpWithPasskey,
  subscribeSyncState
};
//# sourceMappingURL=maia-kernel.es.js.map
