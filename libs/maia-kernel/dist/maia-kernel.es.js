function tC(i, A) {
  for (var e = 0; e < A.length; e++) {
    const t = A[e];
    if (typeof t != "string" && !Array.isArray(t)) {
      for (const o in t)
        if (o !== "default" && !(o in i)) {
          const r = Object.getOwnPropertyDescriptor(t, o);
          r && Object.defineProperty(i, o, r.get ? r : {
            enumerable: !0,
            get: () => t[o]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(i, Symbol.toStringTag, { value: "Module" }));
}
const iC = new TextEncoder(), oC = new TextDecoder();
function ur(i) {
  i = i.replace(/=/g, "");
  const A = i.length, e = A % 4, t = e && e - 1, o = (A >> 2) * 3 + t, r = new Uint8Array(A + 3);
  iC.encodeInto(i + "===", r);
  for (let s = 0, g = 0; s < A; s += 4, g += 3) {
    const n = (_e[r[s]] << 18) + (_e[r[s + 1]] << 12) + (_e[r[s + 2]] << 6) + _e[r[s + 3]];
    r[g] = n >> 16, r[g + 1] = n >> 8 & 255, r[g + 2] = n & 255;
  }
  return new Uint8Array(r.buffer, 0, o);
}
function dr(i) {
  const A = i.length, e = A % 3, t = Math.floor(A / 3) * 4 + (e && e + 1), o = Math.ceil(A / 3) * 4, r = new Uint8Array(o);
  for (let g = 0, n = 0; n < A; g += 4, n += 3) {
    const a = (i[n] << 16) + (i[n + 1] << 8) + (i[n + 2] | 0);
    r[g] = wt[a >> 18], r[g + 1] = wt[a >> 12 & 63], r[g + 2] = wt[a >> 6 & 63], r[g + 3] = wt[a & 63];
  }
  let s = oC.decode(new Uint8Array(r.buffer, 0, t));
  return e === 1 && (s += "=="), e === 2 && (s += "="), s;
}
const oa = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", _e = new Uint8Array(128);
for (const [i, A] of Array.from(oa).entries())
  _e[A.charCodeAt(0)] = i;
_e[61] = 0;
const wt = new Uint8Array(64);
for (const [i, A] of Array.from(oa).entries())
  wt[i] = A.charCodeAt(0);
var rC = typeof globalThis == "object" ? globalThis : typeof self == "object" ? self : typeof window == "object" ? window : typeof globalThis == "object" ? globalThis : {}, Ne = "1.9.0", js = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
function sC(i) {
  var A = /* @__PURE__ */ new Set([i]), e = /* @__PURE__ */ new Set(), t = i.match(js);
  if (!t)
    return function() {
      return !1;
    };
  var o = {
    major: +t[1],
    minor: +t[2],
    patch: +t[3],
    prerelease: t[4]
  };
  if (o.prerelease != null)
    return function(n) {
      return n === i;
    };
  function r(g) {
    return e.add(g), !1;
  }
  function s(g) {
    return A.add(g), !0;
  }
  return function(n) {
    if (A.has(n))
      return !0;
    if (e.has(n))
      return !1;
    var a = n.match(js);
    if (!a)
      return r(n);
    var I = {
      major: +a[1],
      minor: +a[2],
      patch: +a[3],
      prerelease: a[4]
    };
    return I.prerelease != null || o.major !== I.major ? r(n) : o.major === 0 ? o.minor === I.minor && o.patch <= I.patch ? s(n) : r(n) : o.minor <= I.minor ? s(n) : r(n);
  };
}
var gC = sC(Ne), nC = Ne.split(".")[0], Kt = /* @__PURE__ */ Symbol.for("opentelemetry.js.api." + nC), Yt = rC;
function Lt(i, A, e, t) {
  var o;
  t === void 0 && (t = !1);
  var r = Yt[Kt] = (o = Yt[Kt]) !== null && o !== void 0 ? o : {
    version: Ne
  };
  if (!t && r[i]) {
    var s = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + i);
    return e.error(s.stack || s.message), !1;
  }
  if (r.version !== Ne) {
    var s = new Error("@opentelemetry/api: Registration of version v" + r.version + " for " + i + " does not match previously registered API v" + Ne);
    return e.error(s.stack || s.message), !1;
  }
  return r[i] = A, e.debug("@opentelemetry/api: Registered a global for " + i + " v" + Ne + "."), !0;
}
function be(i) {
  var A, e, t = (A = Yt[Kt]) === null || A === void 0 ? void 0 : A.version;
  if (!(!t || !gC(t)))
    return (e = Yt[Kt]) === null || e === void 0 ? void 0 : e[i];
}
function xt(i, A) {
  A.debug("@opentelemetry/api: Unregistering a global for " + i + " v" + Ne + ".");
  var e = Yt[Kt];
  e && delete e[i];
}
var aC = function(i, A) {
  var e = typeof Symbol == "function" && i[Symbol.iterator];
  if (!e) return i;
  var t = e.call(i), o, r = [], s;
  try {
    for (; (A === void 0 || A-- > 0) && !(o = t.next()).done; ) r.push(o.value);
  } catch (g) {
    s = { error: g };
  } finally {
    try {
      o && !o.done && (e = t.return) && e.call(t);
    } finally {
      if (s) throw s.error;
    }
  }
  return r;
}, IC = function(i, A, e) {
  if (arguments.length === 2) for (var t = 0, o = A.length, r; t < o; t++)
    (r || !(t in A)) && (r || (r = Array.prototype.slice.call(A, 0, t)), r[t] = A[t]);
  return i.concat(r || Array.prototype.slice.call(A));
}, CC = (
  /** @class */
  (function() {
    function i(A) {
      this._namespace = A.namespace || "DiagComponentLogger";
    }
    return i.prototype.debug = function() {
      for (var A = [], e = 0; e < arguments.length; e++)
        A[e] = arguments[e];
      return Ct("debug", this._namespace, A);
    }, i.prototype.error = function() {
      for (var A = [], e = 0; e < arguments.length; e++)
        A[e] = arguments[e];
      return Ct("error", this._namespace, A);
    }, i.prototype.info = function() {
      for (var A = [], e = 0; e < arguments.length; e++)
        A[e] = arguments[e];
      return Ct("info", this._namespace, A);
    }, i.prototype.warn = function() {
      for (var A = [], e = 0; e < arguments.length; e++)
        A[e] = arguments[e];
      return Ct("warn", this._namespace, A);
    }, i.prototype.verbose = function() {
      for (var A = [], e = 0; e < arguments.length; e++)
        A[e] = arguments[e];
      return Ct("verbose", this._namespace, A);
    }, i;
  })()
);
function Ct(i, A, e) {
  var t = be("diag");
  if (t)
    return e.unshift(A), t[i].apply(t, IC([], aC(e), !1));
}
var vA;
(function(i) {
  i[i.NONE = 0] = "NONE", i[i.ERROR = 30] = "ERROR", i[i.WARN = 50] = "WARN", i[i.INFO = 60] = "INFO", i[i.DEBUG = 70] = "DEBUG", i[i.VERBOSE = 80] = "VERBOSE", i[i.ALL = 9999] = "ALL";
})(vA || (vA = {}));
function cC(i, A) {
  i < vA.NONE ? i = vA.NONE : i > vA.ALL && (i = vA.ALL), A = A || {};
  function e(t, o) {
    var r = A[t];
    return typeof r == "function" && i >= o ? r.bind(A) : function() {
    };
  }
  return {
    error: e("error", vA.ERROR),
    warn: e("warn", vA.WARN),
    info: e("info", vA.INFO),
    debug: e("debug", vA.DEBUG),
    verbose: e("verbose", vA.VERBOSE)
  };
}
var BC = function(i, A) {
  var e = typeof Symbol == "function" && i[Symbol.iterator];
  if (!e) return i;
  var t = e.call(i), o, r = [], s;
  try {
    for (; (A === void 0 || A-- > 0) && !(o = t.next()).done; ) r.push(o.value);
  } catch (g) {
    s = { error: g };
  } finally {
    try {
      o && !o.done && (e = t.return) && e.call(t);
    } finally {
      if (s) throw s.error;
    }
  }
  return r;
}, QC = function(i, A, e) {
  if (arguments.length === 2) for (var t = 0, o = A.length, r; t < o; t++)
    (r || !(t in A)) && (r || (r = Array.prototype.slice.call(A, 0, t)), r[t] = A[t]);
  return i.concat(r || Array.prototype.slice.call(A));
}, EC = "diag", te = (
  /** @class */
  (function() {
    function i() {
      function A(o) {
        return function() {
          for (var r = [], s = 0; s < arguments.length; s++)
            r[s] = arguments[s];
          var g = be("diag");
          if (g)
            return g[o].apply(g, QC([], BC(r), !1));
        };
      }
      var e = this, t = function(o, r) {
        var s, g, n;
        if (r === void 0 && (r = { logLevel: vA.INFO }), o === e) {
          var a = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
          return e.error((s = a.stack) !== null && s !== void 0 ? s : a.message), !1;
        }
        typeof r == "number" && (r = {
          logLevel: r
        });
        var I = be("diag"), C = cC((g = r.logLevel) !== null && g !== void 0 ? g : vA.INFO, o);
        if (I && !r.suppressOverrideMessage) {
          var c = (n = new Error().stack) !== null && n !== void 0 ? n : "<failed to generate stacktrace>";
          I.warn("Current logger will be overwritten from " + c), C.warn("Current logger will overwrite one already registered from " + c);
        }
        return Lt("diag", C, e, !0);
      };
      e.setLogger = t, e.disable = function() {
        xt(EC, e);
      }, e.createComponentLogger = function(o) {
        return new CC(o);
      }, e.verbose = A("verbose"), e.debug = A("debug"), e.info = A("info"), e.warn = A("warn"), e.error = A("error");
    }
    return i.instance = function() {
      return this._instance || (this._instance = new i()), this._instance;
    }, i;
  })()
), lC = function(i, A) {
  var e = typeof Symbol == "function" && i[Symbol.iterator];
  if (!e) return i;
  var t = e.call(i), o, r = [], s;
  try {
    for (; (A === void 0 || A-- > 0) && !(o = t.next()).done; ) r.push(o.value);
  } catch (g) {
    s = { error: g };
  } finally {
    try {
      o && !o.done && (e = t.return) && e.call(t);
    } finally {
      if (s) throw s.error;
    }
  }
  return r;
}, uC = function(i) {
  var A = typeof Symbol == "function" && Symbol.iterator, e = A && i[A], t = 0;
  if (e) return e.call(i);
  if (i && typeof i.length == "number") return {
    next: function() {
      return i && t >= i.length && (i = void 0), { value: i && i[t++], done: !i };
    }
  };
  throw new TypeError(A ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, dC = (
  /** @class */
  (function() {
    function i(A) {
      this._entries = A ? new Map(A) : /* @__PURE__ */ new Map();
    }
    return i.prototype.getEntry = function(A) {
      var e = this._entries.get(A);
      if (e)
        return Object.assign({}, e);
    }, i.prototype.getAllEntries = function() {
      return Array.from(this._entries.entries()).map(function(A) {
        var e = lC(A, 2), t = e[0], o = e[1];
        return [t, o];
      });
    }, i.prototype.setEntry = function(A, e) {
      var t = new i(this._entries);
      return t._entries.set(A, e), t;
    }, i.prototype.removeEntry = function(A) {
      var e = new i(this._entries);
      return e._entries.delete(A), e;
    }, i.prototype.removeEntries = function() {
      for (var A, e, t = [], o = 0; o < arguments.length; o++)
        t[o] = arguments[o];
      var r = new i(this._entries);
      try {
        for (var s = uC(t), g = s.next(); !g.done; g = s.next()) {
          var n = g.value;
          r._entries.delete(n);
        }
      } catch (a) {
        A = { error: a };
      } finally {
        try {
          g && !g.done && (e = s.return) && e.call(s);
        } finally {
          if (A) throw A.error;
        }
      }
      return r;
    }, i.prototype.clear = function() {
      return new i();
    }, i;
  })()
);
te.instance();
function hC(i) {
  return i === void 0 && (i = {}), new dC(new Map(Object.entries(i)));
}
function ra(i) {
  return Symbol.for(i);
}
var fC = (
  /** @class */
  /* @__PURE__ */ (function() {
    function i(A) {
      var e = this;
      e._currentContext = A ? new Map(A) : /* @__PURE__ */ new Map(), e.getValue = function(t) {
        return e._currentContext.get(t);
      }, e.setValue = function(t, o) {
        var r = new i(e._currentContext);
        return r._currentContext.set(t, o), r;
      }, e.deleteValue = function(t) {
        var o = new i(e._currentContext);
        return o._currentContext.delete(t), o;
      };
    }
    return i;
  })()
), wC = new fC(), Ue = /* @__PURE__ */ (function() {
  var i = function(A, e) {
    return i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, o) {
      t.__proto__ = o;
    } || function(t, o) {
      for (var r in o) Object.prototype.hasOwnProperty.call(o, r) && (t[r] = o[r]);
    }, i(A, e);
  };
  return function(A, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
    i(A, e);
    function t() {
      this.constructor = A;
    }
    A.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
  };
})(), pC = (
  /** @class */
  (function() {
    function i() {
    }
    return i.prototype.createGauge = function(A, e) {
      return RC;
    }, i.prototype.createHistogram = function(A, e) {
      return bC;
    }, i.prototype.createCounter = function(A, e) {
      return FC;
    }, i.prototype.createUpDownCounter = function(A, e) {
      return KC;
    }, i.prototype.createObservableGauge = function(A, e) {
      return UC;
    }, i.prototype.createObservableCounter = function(A, e) {
      return YC;
    }, i.prototype.createObservableUpDownCounter = function(A, e) {
      return vC;
    }, i.prototype.addBatchObservableCallback = function(A, e) {
    }, i.prototype.removeBatchObservableCallback = function(A) {
    }, i;
  })()
), lo = (
  /** @class */
  /* @__PURE__ */ (function() {
    function i() {
    }
    return i;
  })()
), yC = (
  /** @class */
  (function(i) {
    Ue(A, i);
    function A() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return A.prototype.add = function(e, t) {
    }, A;
  })(lo)
), DC = (
  /** @class */
  (function(i) {
    Ue(A, i);
    function A() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return A.prototype.add = function(e, t) {
    }, A;
  })(lo)
), mC = (
  /** @class */
  (function(i) {
    Ue(A, i);
    function A() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return A.prototype.record = function(e, t) {
    }, A;
  })(lo)
), SC = (
  /** @class */
  (function(i) {
    Ue(A, i);
    function A() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return A.prototype.record = function(e, t) {
    }, A;
  })(lo)
), Wr = (
  /** @class */
  (function() {
    function i() {
    }
    return i.prototype.addCallback = function(A) {
    }, i.prototype.removeCallback = function(A) {
    }, i;
  })()
), NC = (
  /** @class */
  (function(i) {
    Ue(A, i);
    function A() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return A;
  })(Wr)
), MC = (
  /** @class */
  (function(i) {
    Ue(A, i);
    function A() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return A;
  })(Wr)
), kC = (
  /** @class */
  (function(i) {
    Ue(A, i);
    function A() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return A;
  })(Wr)
), GC = new pC(), FC = new yC(), RC = new mC(), bC = new SC(), KC = new DC(), YC = new NC(), UC = new MC(), vC = new kC(), WA;
(function(i) {
  i[i.INT = 0] = "INT", i[i.DOUBLE = 1] = "DOUBLE";
})(WA || (WA = {}));
var JC = {
  get: function(i, A) {
    if (i != null)
      return i[A];
  },
  keys: function(i) {
    return i == null ? [] : Object.keys(i);
  }
}, HC = {
  set: function(i, A, e) {
    i != null && (i[A] = e);
  }
}, qC = function(i, A) {
  var e = typeof Symbol == "function" && i[Symbol.iterator];
  if (!e) return i;
  var t = e.call(i), o, r = [], s;
  try {
    for (; (A === void 0 || A-- > 0) && !(o = t.next()).done; ) r.push(o.value);
  } catch (g) {
    s = { error: g };
  } finally {
    try {
      o && !o.done && (e = t.return) && e.call(t);
    } finally {
      if (s) throw s.error;
    }
  }
  return r;
}, LC = function(i, A, e) {
  if (e || arguments.length === 2) for (var t = 0, o = A.length, r; t < o; t++)
    (r || !(t in A)) && (r || (r = Array.prototype.slice.call(A, 0, t)), r[t] = A[t]);
  return i.concat(r || Array.prototype.slice.call(A));
}, xC = (
  /** @class */
  (function() {
    function i() {
    }
    return i.prototype.active = function() {
      return wC;
    }, i.prototype.with = function(A, e, t) {
      for (var o = [], r = 3; r < arguments.length; r++)
        o[r - 3] = arguments[r];
      return e.call.apply(e, LC([t], qC(o), !1));
    }, i.prototype.bind = function(A, e) {
      return e;
    }, i.prototype.enable = function() {
      return this;
    }, i.prototype.disable = function() {
      return this;
    }, i;
  })()
), OC = function(i, A) {
  var e = typeof Symbol == "function" && i[Symbol.iterator];
  if (!e) return i;
  var t = e.call(i), o, r = [], s;
  try {
    for (; (A === void 0 || A-- > 0) && !(o = t.next()).done; ) r.push(o.value);
  } catch (g) {
    s = { error: g };
  } finally {
    try {
      o && !o.done && (e = t.return) && e.call(t);
    } finally {
      if (s) throw s.error;
    }
  }
  return r;
}, TC = function(i, A, e) {
  if (arguments.length === 2) for (var t = 0, o = A.length, r; t < o; t++)
    (r || !(t in A)) && (r || (r = Array.prototype.slice.call(A, 0, t)), r[t] = A[t]);
  return i.concat(r || Array.prototype.slice.call(A));
}, qo = "context", PC = new xC(), uo = (
  /** @class */
  (function() {
    function i() {
    }
    return i.getInstance = function() {
      return this._instance || (this._instance = new i()), this._instance;
    }, i.prototype.setGlobalContextManager = function(A) {
      return Lt(qo, A, te.instance());
    }, i.prototype.active = function() {
      return this._getContextManager().active();
    }, i.prototype.with = function(A, e, t) {
      for (var o, r = [], s = 3; s < arguments.length; s++)
        r[s - 3] = arguments[s];
      return (o = this._getContextManager()).with.apply(o, TC([A, e, t], OC(r), !1));
    }, i.prototype.bind = function(A, e) {
      return this._getContextManager().bind(A, e);
    }, i.prototype._getContextManager = function() {
      return be(qo) || PC;
    }, i.prototype.disable = function() {
      this._getContextManager().disable(), xt(qo, te.instance());
    }, i;
  })()
), hr;
(function(i) {
  i[i.NONE = 0] = "NONE", i[i.SAMPLED = 1] = "SAMPLED";
})(hr || (hr = {}));
var sa = "0000000000000000", ga = "00000000000000000000000000000000", jC = {
  traceId: ga,
  spanId: sa,
  traceFlags: hr.NONE
}, Mt = (
  /** @class */
  (function() {
    function i(A) {
      A === void 0 && (A = jC), this._spanContext = A;
    }
    return i.prototype.spanContext = function() {
      return this._spanContext;
    }, i.prototype.setAttribute = function(A, e) {
      return this;
    }, i.prototype.setAttributes = function(A) {
      return this;
    }, i.prototype.addEvent = function(A, e) {
      return this;
    }, i.prototype.addLink = function(A) {
      return this;
    }, i.prototype.addLinks = function(A) {
      return this;
    }, i.prototype.setStatus = function(A) {
      return this;
    }, i.prototype.updateName = function(A) {
      return this;
    }, i.prototype.end = function(A) {
    }, i.prototype.isRecording = function() {
      return !1;
    }, i.prototype.recordException = function(A, e) {
    }, i;
  })()
), zr = ra("OpenTelemetry Context Key SPAN");
function Zr(i) {
  return i.getValue(zr) || void 0;
}
function VC() {
  return Zr(uo.getInstance().active());
}
function _r(i, A) {
  return i.setValue(zr, A);
}
function WC(i) {
  return i.deleteValue(zr);
}
function zC(i, A) {
  return _r(i, new Mt(A));
}
function na(i) {
  var A;
  return (A = Zr(i)) === null || A === void 0 ? void 0 : A.spanContext();
}
var ZC = /^([0-9a-f]{32})$/i, _C = /^[0-9a-f]{16}$/i;
function $C(i) {
  return ZC.test(i) && i !== ga;
}
function XC(i) {
  return _C.test(i) && i !== sa;
}
function aa(i) {
  return $C(i.traceId) && XC(i.spanId);
}
function Ac(i) {
  return new Mt(i);
}
var Lo = uo.getInstance(), Ia = (
  /** @class */
  (function() {
    function i() {
    }
    return i.prototype.startSpan = function(A, e, t) {
      t === void 0 && (t = Lo.active());
      var o = !!e?.root;
      if (o)
        return new Mt();
      var r = t && na(t);
      return ec(r) && aa(r) ? new Mt(r) : new Mt();
    }, i.prototype.startActiveSpan = function(A, e, t, o) {
      var r, s, g;
      if (!(arguments.length < 2)) {
        arguments.length === 2 ? g = e : arguments.length === 3 ? (r = e, g = t) : (r = e, s = t, g = o);
        var n = s ?? Lo.active(), a = this.startSpan(A, r, n), I = _r(n, a);
        return Lo.with(I, g, void 0, a);
      }
    }, i;
  })()
);
function ec(i) {
  return typeof i == "object" && typeof i.spanId == "string" && typeof i.traceId == "string" && typeof i.traceFlags == "number";
}
var tc = new Ia(), ic = (
  /** @class */
  (function() {
    function i(A, e, t, o) {
      this._provider = A, this.name = e, this.version = t, this.options = o;
    }
    return i.prototype.startSpan = function(A, e, t) {
      return this._getTracer().startSpan(A, e, t);
    }, i.prototype.startActiveSpan = function(A, e, t, o) {
      var r = this._getTracer();
      return Reflect.apply(r.startActiveSpan, r, arguments);
    }, i.prototype._getTracer = function() {
      if (this._delegate)
        return this._delegate;
      var A = this._provider.getDelegateTracer(this.name, this.version, this.options);
      return A ? (this._delegate = A, this._delegate) : tc;
    }, i;
  })()
), oc = (
  /** @class */
  (function() {
    function i() {
    }
    return i.prototype.getTracer = function(A, e, t) {
      return new Ia();
    }, i;
  })()
), rc = new oc(), Vs = (
  /** @class */
  (function() {
    function i() {
    }
    return i.prototype.getTracer = function(A, e, t) {
      var o;
      return (o = this.getDelegateTracer(A, e, t)) !== null && o !== void 0 ? o : new ic(this, A, e, t);
    }, i.prototype.getDelegate = function() {
      var A;
      return (A = this._delegate) !== null && A !== void 0 ? A : rc;
    }, i.prototype.setDelegate = function(A) {
      this._delegate = A;
    }, i.prototype.getDelegateTracer = function(A, e, t) {
      var o;
      return (o = this._delegate) === null || o === void 0 ? void 0 : o.getTracer(A, e, t);
    }, i;
  })()
);
uo.getInstance();
te.instance();
var sc = (
  /** @class */
  (function() {
    function i() {
    }
    return i.prototype.getMeter = function(A, e, t) {
      return GC;
    }, i;
  })()
), gc = new sc(), xo = "metrics", nc = (
  /** @class */
  (function() {
    function i() {
    }
    return i.getInstance = function() {
      return this._instance || (this._instance = new i()), this._instance;
    }, i.prototype.setGlobalMeterProvider = function(A) {
      return Lt(xo, A, te.instance());
    }, i.prototype.getMeterProvider = function() {
      return be(xo) || gc;
    }, i.prototype.getMeter = function(A, e, t) {
      return this.getMeterProvider().getMeter(A, e, t);
    }, i.prototype.disable = function() {
      xt(xo, te.instance());
    }, i;
  })()
), ae = nc.getInstance(), ac = (
  /** @class */
  (function() {
    function i() {
    }
    return i.prototype.inject = function(A, e) {
    }, i.prototype.extract = function(A, e) {
      return A;
    }, i.prototype.fields = function() {
      return [];
    }, i;
  })()
), $r = ra("OpenTelemetry Baggage Key");
function Ca(i) {
  return i.getValue($r) || void 0;
}
function Ic() {
  return Ca(uo.getInstance().active());
}
function Cc(i, A) {
  return i.setValue($r, A);
}
function cc(i) {
  return i.deleteValue($r);
}
var Oo = "propagation", Bc = new ac(), Qc = (
  /** @class */
  (function() {
    function i() {
      this.createBaggage = hC, this.getBaggage = Ca, this.getActiveBaggage = Ic, this.setBaggage = Cc, this.deleteBaggage = cc;
    }
    return i.getInstance = function() {
      return this._instance || (this._instance = new i()), this._instance;
    }, i.prototype.setGlobalPropagator = function(A) {
      return Lt(Oo, A, te.instance());
    }, i.prototype.inject = function(A, e, t) {
      return t === void 0 && (t = HC), this._getGlobalPropagator().inject(A, e, t);
    }, i.prototype.extract = function(A, e, t) {
      return t === void 0 && (t = JC), this._getGlobalPropagator().extract(A, e, t);
    }, i.prototype.fields = function() {
      return this._getGlobalPropagator().fields();
    }, i.prototype.disable = function() {
      xt(Oo, te.instance());
    }, i.prototype._getGlobalPropagator = function() {
      return be(Oo) || Bc;
    }, i;
  })()
);
Qc.getInstance();
var To = "trace", Ec = (
  /** @class */
  (function() {
    function i() {
      this._proxyTracerProvider = new Vs(), this.wrapSpanContext = Ac, this.isSpanContextValid = aa, this.deleteSpan = WC, this.getSpan = Zr, this.getActiveSpan = VC, this.getSpanContext = na, this.setSpan = _r, this.setSpanContext = zC;
    }
    return i.getInstance = function() {
      return this._instance || (this._instance = new i()), this._instance;
    }, i.prototype.setGlobalTracerProvider = function(A) {
      var e = Lt(To, this._proxyTracerProvider, te.instance());
      return e && this._proxyTracerProvider.setDelegate(A), e;
    }, i.prototype.getTracerProvider = function() {
      return be(To) || this._proxyTracerProvider;
    }, i.prototype.getTracer = function(A, e) {
      return this.getTracerProvider().getTracer(A, e);
    }, i.prototype.disable = function() {
      xt(To, te.instance()), this._proxyTracerProvider = new Vs();
    }, i;
  })()
);
Ec.getInstance();
class lc {
  constructor(A) {
    this.totalValidTransactions = 0, this.version = 0, this.id = A.id, this.core = A;
  }
  get type() {
    return this.core.verified.header.type;
  }
  get headerMeta() {
    return this.core.verified.header.meta;
  }
  /** @category 6. Meta */
  get group() {
    return this.core.getGroup();
  }
  toJSON() {
    return {};
  }
  atTime() {
    return this;
  }
  subscribe(A) {
    return this.core.subscribe((e) => {
      A(e.getCurrentContent());
    });
  }
  processNewTransactions() {
  }
  rebuildFromCore() {
  }
}
function uc(i) {
  return i instanceof Uint8Array || ArrayBuffer.isView(i) && i.constructor.name === "Uint8Array";
}
function ca(i, A) {
  return Array.isArray(A) ? A.length === 0 ? !0 : i ? A.every((e) => typeof e == "string") : A.every((e) => Number.isSafeInteger(e)) : !1;
}
function fr(i, A) {
  if (typeof A != "string")
    throw new Error(`${i}: string expected`);
  return !0;
}
function Ba(i) {
  if (!Number.isSafeInteger(i))
    throw new Error(`invalid integer: ${i}`);
}
function wr(i) {
  if (!Array.isArray(i))
    throw new Error("array expected");
}
function Qa(i, A) {
  if (!ca(!0, A))
    throw new Error(`${i}: array of strings expected`);
}
function dc(i, A) {
  if (!ca(!1, A))
    throw new Error(`${i}: array of numbers expected`);
}
// @__NO_SIDE_EFFECTS__
function hc(...i) {
  const A = (r) => r, e = (r, s) => (g) => r(s(g)), t = i.map((r) => r.encode).reduceRight(e, A), o = i.map((r) => r.decode).reduce(e, A);
  return { encode: t, decode: o };
}
// @__NO_SIDE_EFFECTS__
function fc(i) {
  const A = typeof i == "string" ? i.split("") : i, e = A.length;
  Qa("alphabet", A);
  const t = new Map(A.map((o, r) => [o, r]));
  return {
    encode: (o) => (wr(o), o.map((r) => {
      if (!Number.isSafeInteger(r) || r < 0 || r >= e)
        throw new Error(`alphabet.encode: digit index outside alphabet "${r}". Allowed: ${i}`);
      return A[r];
    })),
    decode: (o) => (wr(o), o.map((r) => {
      fr("alphabet.decode", r);
      const s = t.get(r);
      if (s === void 0)
        throw new Error(`Unknown letter: "${r}". Allowed: ${i}`);
      return s;
    }))
  };
}
// @__NO_SIDE_EFFECTS__
function wc(i = "") {
  return fr("join", i), {
    encode: (A) => (Qa("join.decode", A), A.join(i)),
    decode: (A) => (fr("join.decode", A), A.split(i))
  };
}
function Ws(i, A, e) {
  if (A < 2)
    throw new Error(`convertRadix: invalid from=${A}, base cannot be less than 2`);
  if (e < 2)
    throw new Error(`convertRadix: invalid to=${e}, base cannot be less than 2`);
  if (wr(i), !i.length)
    return [];
  let t = 0;
  const o = [], r = Array.from(i, (g) => {
    if (Ba(g), g < 0 || g >= A)
      throw new Error(`invalid integer: ${g}`);
    return g;
  }), s = r.length;
  for (; ; ) {
    let g = 0, n = !0;
    for (let a = t; a < s; a++) {
      const I = r[a], C = A * g, c = C + I;
      if (!Number.isSafeInteger(c) || C / A !== g || c - I !== C)
        throw new Error("convertRadix: carry overflow");
      const B = c / e;
      g = c % e;
      const Q = Math.floor(B);
      if (r[a] = Q, !Number.isSafeInteger(Q) || Q * e + g !== c)
        throw new Error("convertRadix: carry overflow");
      if (n)
        Q ? n = !1 : t = a;
      else continue;
    }
    if (o.push(g), n)
      break;
  }
  for (let g = 0; g < i.length - 1 && i[g] === 0; g++)
    o.push(0);
  return o.reverse();
}
// @__NO_SIDE_EFFECTS__
function pc(i) {
  Ba(i);
  const A = 2 ** 8;
  return {
    encode: (e) => {
      if (!uc(e))
        throw new Error("radix.encode input should be Uint8Array");
      return Ws(Array.from(e), A, i);
    },
    decode: (e) => (dc("radix.decode", e), Uint8Array.from(Ws(e, i, A)))
  };
}
const yc = /* @__NO_SIDE_EFFECTS__ */ (i) => /* @__PURE__ */ hc(/* @__PURE__ */ pc(58), /* @__PURE__ */ fc(i), /* @__PURE__ */ wc("")), UA = /* @__PURE__ */ yc("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
function xA(i) {
  const A = [];
  let e = i;
  if (e && e.toJSON && typeof e.toJSON == "function" && (e = e.toJSON()), e === void 0)
    return;
  if (typeof e == "number")
    return isFinite(e) ? "" + e : "null";
  if (typeof e != "object")
    return typeof e == "string" && (e.startsWith("encrypted_U") || e.startsWith("binary_U")) ? `"${e}"` : JSON.stringify(e);
  let t, o;
  if (Array.isArray(e)) {
    for (o = "[", t = 0; t < e.length; t++)
      t && (o += ","), o += xA(e[t]) || "null";
    return o + "]";
  }
  if (e === null)
    return "null";
  if (A.indexOf(e) !== -1)
    throw new TypeError("Converting circular structure to JSON");
  const r = A.push(e) - 1, s = Object.keys(e).sort();
  for (o = "", t = 0; t < s.length; t++) {
    const g = s[t], n = xA(e[g]);
    n && (o && (o += ","), o += JSON.stringify(g) + ":" + n);
  }
  return A.splice(r, 1), "{" + o + "}";
}
function no(i) {
  return JSON.parse(i);
}
function pr(i) {
  try {
    return JSON.parse(i);
  } catch {
    return;
  }
}
const ct = {
  DEBUG: 0,
  INFO: 1,
  WARN: 2,
  ERROR: 3
};
class Dc {
  debug(A, e) {
    console.debug(A, e);
  }
  info(A, e) {
    console.info(A, e);
  }
  warn(A, e) {
    console.warn(A, e);
  }
  error(A, e) {
    console.error(A, e);
  }
}
class mc {
  constructor(A = ct.INFO, e = new Dc()) {
    this.level = A, this.logSystem = e;
  }
  setLevel(A) {
    this.level = A;
  }
  setLogSystem(A) {
    this.logSystem = A;
  }
  debug(A, e) {
    this.level <= ct.DEBUG && this.logSystem.debug(A, e);
  }
  info(A, e) {
    this.level <= ct.INFO && this.logSystem.info(A, e);
  }
  warn(A, e) {
    this.level <= ct.WARN && this.logSystem.warn(A, e);
  }
  error(A, e) {
    this.level <= ct.ERROR && this.logSystem.error(A, e);
  }
}
const AA = new mc();
function Sc(i = 32) {
  return crypto.getRandomValues(new Uint8Array(i));
}
const SA = new TextEncoder(), zs = new TextDecoder();
class Nc {
  constructor() {
    this.agentIdCache = /* @__PURE__ */ new Map();
  }
  randomBytes(A) {
    return Sc(A);
  }
  newRandomSigner() {
    return `signerSecret_z${UA.encode(this.newEd25519SigningKey())}`;
  }
  newRandomSealer() {
    return `sealerSecret_z${UA.encode(this.newX25519StaticSecret())}`;
  }
  newRandomAgentSecret() {
    return `${this.newRandomSealer()}/${this.newRandomSigner()}`;
  }
  getAgentID(A) {
    const e = A;
    let t = this.agentIdCache.get(e);
    if (!t) {
      const [o, r] = A.split("/");
      t = `${this.getSealerID(o)}/${this.getSignerID(r)}`, this.agentIdCache.set(e, t);
    }
    return t;
  }
  getAgentSignerID(A) {
    return A.split("/")[1];
  }
  getAgentSignerSecret(A) {
    return A.split("/")[1];
  }
  getAgentSealerID(A) {
    return A.split("/")[0];
  }
  getAgentSealerSecret(A) {
    return A.split("/")[0];
  }
  secureHash(A) {
    return `hash_z${UA.encode(this.blake3HashOnce(SA.encode(xA(A))))}`;
  }
  shortHash(A) {
    return `shortHash_z${UA.encode(this.blake3HashOnce(SA.encode(xA(A))).slice(0, Mc))}`;
  }
  decrypt(A, e, t) {
    try {
      return no(this.decryptRaw(A, e, t));
    } catch (o) {
      AA.error("Decryption error", { err: o });
      return;
    }
  }
  newRandomKeySecret() {
    return {
      secret: `keySecret_z${UA.encode(this.randomBytes(32))}`,
      id: `key_z${UA.encode(this.randomBytes(12))}`
    };
  }
  encryptKeySecret(A) {
    const e = {
      encryptedID: A.toEncrypt.id,
      encryptingID: A.encrypting.id
    };
    return {
      encryptedID: A.toEncrypt.id,
      encryptingID: A.encrypting.id,
      encrypted: this.encrypt(A.toEncrypt.secret, A.encrypting.secret, e)
    };
  }
  decryptKeySecret(A, e) {
    const t = {
      encryptedID: A.encryptedID,
      encryptingID: A.encryptingID
    };
    return this.decrypt(A.encrypted, e, t);
  }
  uniquenessForHeader() {
    return `z${UA.encode(this.randomBytes(12))}`;
  }
  createdNowUnique() {
    return {
      createdAt: (/* @__PURE__ */ new Date()).toISOString(),
      uniqueness: this.uniquenessForHeader()
    };
  }
  newRandomSecretSeed() {
    return this.randomBytes(Po);
  }
  agentSecretFromSecretSeed(A) {
    if (A.length !== Po)
      throw new Error(`Secret seed needs to be ${Po} bytes long`);
    return `sealerSecret_z${UA.encode(this.blake3HashOnceWithContext(A, {
      context: SA.encode("seal")
    }))}/signerSecret_z${UA.encode(this.blake3HashOnceWithContext(A, {
      context: SA.encode("sign")
    }))}`;
  }
  newRandomSessionID(A) {
    const e = UA.encode(this.randomBytes(8));
    return `${A}_session_z${e}`;
  }
  newDeleteSessionID(A) {
    const e = UA.encode(this.randomBytes(7));
    return `${A}_session_d${e}$`;
  }
}
const Mc = 19, Po = 32;
function Ea(i) {
  return typeof i == "string" && i.startsWith("co_z");
}
function $e(i) {
  return typeof i == "string" && i.startsWith("sealer_") && i.includes("/signer_");
}
const kc = 36;
function Ke(i) {
  return i.charCodeAt(i.length - 1) === kc;
}
function la(i) {
  return i.startsWith("parent_");
}
function ua(i) {
  return i.slice(7);
}
function Gc(i) {
  if (typeof i == "string") {
    if (la(i))
      return ua(i);
    if (i.startsWith("co_"))
      return i;
  }
}
function TA(i) {
  const A = i.indexOf("_session");
  return i.slice(0, A);
}
class Ot {
  resetInternalState() {
    this.afterStart = [], this.beforeEnd = [], this.insertions = {}, this.deletionsByInsertion = {}, this._cachedEntries = void 0, this.knownTransactions = { [this.core.id]: 0 }, this.lastValidTransaction = void 0, this.totalValidTransactions = 0;
  }
  /** @internal */
  constructor(A, e) {
    this.type = "colist", this.afterStart = [], this.beforeEnd = [], this.insertions = {}, this.deletionsByInsertion = {}, this.atTimeFilter = void 0, this.knownTransactions = {}, this.version = 0, this.totalValidTransactions = 0, this.id = A.id, this.core = A, this.insertions = {}, this.deletionsByInsertion = {}, this.afterStart = [], this.beforeEnd = [], this.knownTransactions = { [A.id]: 0 }, this.atTimeFilter = e, this._processNewTransactions();
  }
  getInsertionsEntry(A) {
    const e = Xt(A), t = this.insertions[e];
    if (!t)
      return;
    const o = t[A.txIndex];
    if (o)
      return o[A.changeIdx];
  }
  createInsertionsEntry(A, e) {
    const t = Xt(A);
    let o = this.insertions[t];
    o || (o = {}, this.insertions[t] = o);
    let r = o[A.txIndex];
    return r || (r = {}, o[A.txIndex] = r), r[A.changeIdx] ? !1 : (r[A.changeIdx] = e, !0);
  }
  isDeleted(A) {
    const e = Xt(A), t = this.deletionsByInsertion[e];
    if (!t)
      return !1;
    const o = t[A.txIndex];
    return o ? !!o[A.changeIdx]?.length : !1;
  }
  pushDeletionsByInsertionEntry(A, e) {
    const t = Xt(A);
    let o = this.deletionsByInsertion[t];
    o || (o = {}, this.deletionsByInsertion[t] = o);
    let r = o[A.txIndex];
    r || (r = {}, o[A.txIndex] = r);
    let s = r[A.changeIdx];
    s || (s = [], r[A.changeIdx] = s), s.push(e);
  }
  processNewTransactions() {
    if (this.isTimeTravelEntity())
      throw new Error("Cannot process transactions on a time travel entity");
    this._processNewTransactions();
  }
  _processNewTransactions() {
    const A = this.core.getValidSortedTransactions({
      ignorePrivateTransactions: !1,
      knownTransactions: this.knownTransactions
    });
    if (A.length === 0)
      return;
    let e, t;
    this._cachedEntries = void 0;
    for (const { txID: o, changes: r, madeAt: s } of A)
      if (!this.isFilteredOut(s)) {
        e = Math.max(e ?? 0, s), t = Math.min(t ?? 1 / 0, s);
        for (const [g, n] of r.entries()) {
          const a = n, I = {
            sessionID: o.sessionID,
            txIndex: o.txIndex,
            branch: o.branch,
            changeIdx: g
          };
          if (a.op === "pre" || a.op === "app") {
            if (!this.createInsertionsEntry(I, {
              madeAt: s,
              predecessors: [],
              successors: [],
              change: a
            }))
              continue;
            if (a.op === "pre")
              if (a.before === "end")
                this.beforeEnd.push(I);
              else {
                const c = this.getInsertionsEntry(a.before);
                if (!c)
                  continue;
                c.predecessors.push(I);
              }
            else if (a.after === "start")
              this.afterStart.push(I);
            else {
              const c = this.getInsertionsEntry(a.after);
              if (!c)
                continue;
              c.successors.push(I);
            }
          } else if (a.op === "del")
            this.pushDeletionsByInsertionEntry(a.insertion, {
              madeAt: s,
              deletionID: I,
              change: a
            });
          else
            throw new Error("Unknown list operation " + a.op);
        }
      }
    this.lastValidTransaction && t && t < this.lastValidTransaction ? this.rebuildFromCore() : this.lastValidTransaction = e, this.totalValidTransactions += A.length;
  }
  rebuildFromCore() {
    this.version += 1, this.resetInternalState(), this.processNewTransactions();
  }
  isTimeTravelEntity() {
    return !!this.atTimeFilter;
  }
  isFilteredOut(A) {
    return this.atTimeFilter === void 0 ? !1 : A > this.atTimeFilter;
  }
  /** @category 6. Meta */
  get headerMeta() {
    return this.core.verified.header.meta;
  }
  /** @category 6. Meta */
  get group() {
    return this.core.getGroup();
  }
  /**
   * Not yet implemented
   *
   * @category 4. Time travel
   */
  atTime(A) {
    return new Ot(this.core, A);
  }
  /**
   * Get the item currently at `idx`.
   *
   * @category 1. Reading
   */
  get(A) {
    const e = this.entries()[A];
    if (e)
      return e.value;
  }
  /**
   * Returns the current items in the CoList as an array.
   *
   * @category 1. Reading
   **/
  asArray() {
    return this.entries().map((A) => A.value);
  }
  /** @internal */
  entries() {
    if (this._cachedEntries)
      return this._cachedEntries;
    const A = this.entriesUncached();
    return this._cachedEntries = A, A;
  }
  length() {
    return this.entries().length;
  }
  /** @internal */
  entriesUncached() {
    const A = [];
    for (const e of this.afterStart)
      this.fillArrayFromOpID(e, A);
    for (const e of this.beforeEnd)
      this.fillArrayFromOpID(e, A);
    return A;
  }
  /** @internal */
  fillArrayFromOpID(A, e) {
    const t = [A], o = /* @__PURE__ */ new Set();
    for (; t.length > 0; ) {
      const r = t[t.length - 1], s = this.getInsertionsEntry(r);
      if (!s)
        throw new Error("Missing op " + r);
      if (s.predecessors.length > 0 && !o.has(r)) {
        for (const n of s.predecessors)
          t.push(n);
        o.add(r);
      } else {
        t.pop(), this.isDeleted(r) || e.push({
          value: s.change.value,
          madeAt: s.madeAt,
          opID: r
        });
        for (const a of s.successors)
          t.push(a);
      }
    }
  }
  /**
   * Returns the current items in the CoList as an array. (alias of `asArray`)
   *
   * @category 1. Reading
   */
  toJSON() {
    return this.asArray();
  }
  /** @category 5. Edit history */
  editAt(A) {
    const e = this.entries()[A];
    if (!e)
      return;
    const t = new Date(e.madeAt), o = TA(e.opID.sessionID), r = e.value;
    return {
      by: o,
      tx: {
        sessionID: e.opID.sessionID,
        txIndex: e.opID.txIndex
      },
      at: t,
      value: r
    };
  }
  /** @category 5. Edit history */
  deletionEdits() {
    const A = [];
    for (const e in this.deletionsByInsertion) {
      const t = this.deletionsByInsertion[e];
      for (const o in t) {
        const r = t[Number(o)];
        for (const s in r) {
          const g = r[Number(s)];
          for (const n of g || []) {
            const a = new Date(n.madeAt), I = TA(n.deletionID.sessionID);
            A.push({
              by: I,
              tx: n.deletionID,
              at: a
            });
          }
        }
      }
    }
    return A;
  }
  /** @category 3. Subscription */
  subscribe(A) {
    return this.core.subscribe((e) => {
      A(e.getCurrentContent());
    });
  }
  /** Appends `item` after the item currently at index `after`.
   *
   * If `privacy` is `"private"` **(default)**, `item` is encrypted in the transaction, only readable by other members of the group this `CoList` belongs to. Not even sync servers can see the content in plaintext.
   *
   * If `privacy` is `"trusting"`, `item` is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
   *
   * @category 2. Editing
   **/
  append(A, e, t = "private") {
    this.appendItems([A], e, t);
  }
  /**
   * Appends `items` to the list at index `after`. If `after` is negative, it is treated as `0`.
   *
   * If `privacy` is `"private"` **(default)**, `items` are encrypted in the transaction, only readable by other members of the group this `CoList` belongs to. Not even sync servers can see the content in plaintext.
   *
   * If `privacy` is `"trusting"`, `items` are stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
   *
   * @category 2. Editing
   */
  appendItems(A, e, t = "private") {
    const o = this.entries();
    e = e === void 0 ? o.length > 0 ? o.length - 1 : 0 : Math.max(0, e);
    let r;
    if (o.length > 0) {
      const g = o[e];
      if (!g)
        throw new Error("Invalid index " + e);
      r = g.opID;
    } else {
      if (e !== 0)
        throw new Error("Invalid index " + e);
      r = "start";
    }
    const s = A.map((g) => ({
      op: "app",
      value: At(g) ? g.id : g,
      after: r
    }));
    r !== "start" && s.reverse(), this.core.makeTransaction(s, t), this.processNewTransactions();
  }
  /**
   * Prepends `item` before the item currently at index `before`.
   *
   * If `privacy` is `"private"` **(default)**, `item` is encrypted in the transaction, only readable by other members of the group this `CoList` belongs to. Not even sync servers can see the content in plaintext.
   *
   * If `privacy` is `"trusting"`, `item` is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
   *
   * @category 2. Editing
   */
  prepend(A, e, t = "private") {
    const o = this.entries();
    e = e === void 0 ? 0 : e;
    let r;
    if (o.length > 0) {
      const s = o[e];
      if (s)
        r = s.opID;
      else {
        if (e !== o.length)
          throw new Error("Invalid index " + e);
        r = "end";
      }
    } else {
      if (e !== 0)
        throw new Error("Invalid index " + e);
      r = "end";
    }
    this.core.makeTransaction([
      {
        op: "pre",
        value: At(A) ? A.id : A,
        before: r
      }
    ], t), this.processNewTransactions();
  }
  /** Deletes the item at index `at`.
   *
   * If `privacy` is `"private"` **(default)**, the fact of this deletion is encrypted in the transaction, only readable by other members of the group this `CoList` belongs to. Not even sync servers can see the content in plaintext.
   *
   * If `privacy` is `"trusting"`, the fact of this deletion is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
   *
   * @category 2. Editing
   **/
  delete(A, e = "private") {
    const o = this.entries()[A];
    if (!o)
      throw new Error("Invalid index " + A);
    this.core.makeTransaction([
      {
        op: "del",
        insertion: o.opID
      }
    ], e), this.processNewTransactions();
  }
  replace(A, e, t = "private") {
    const r = this.entries()[A];
    if (!r)
      throw new Error("Invalid index " + A);
    this.core.makeTransaction([
      {
        op: "app",
        value: At(e) ? e.id : e,
        after: r.opID
      },
      {
        op: "del",
        insertion: r.opID
      }
    ], t), this.processNewTransactions();
  }
}
function Xt(i) {
  return i.branch ? `${i.sessionID}_branch_${i.branch}` : i.sessionID;
}
function Xr(i) {
  return i.startsWith("co_");
}
class da {
  resetInternalState() {
    this.items = {}, this.knownTransactions = { [this.core.id]: 0 }, this.totalValidTransactions = 0;
  }
  constructor(A) {
    this.type = "costream", this.totalValidTransactions = 0, this.version = 0, this.id = A.id, this.core = A, this.items = {}, this.knownTransactions = { [A.id]: 0 }, this.processNewTransactions();
  }
  rebuildFromCore() {
    this.version++, this.resetInternalState(), this.processNewTransactions();
  }
  get headerMeta() {
    return this.core.verified.header.meta;
  }
  get group() {
    return this.core.getGroup();
  }
  /** Not yet implemented */
  atTime(A) {
    throw new Error("Not yet implemented");
  }
  /** @internal */
  compareStreamItems(A, e) {
    return A.madeAt - e.madeAt || (A.tx.sessionID === e.tx.sessionID ? 0 : A.tx.sessionID < e.tx.sessionID ? -1 : 1) || A.tx.txIndex - e.tx.txIndex;
  }
  /** @internal */
  processNewTransactions() {
    const A = /* @__PURE__ */ new Set(), e = this.core.getValidTransactions({
      ignorePrivateTransactions: !1,
      knownTransactions: this.knownTransactions
    });
    if (e.length !== 0) {
      for (const { txID: t, madeAt: o, changes: r } of e)
        for (const s of r) {
          const g = s;
          let n = this.items[t.sessionID];
          n || (n = [], this.items[t.sessionID] = n), n.push({ value: g, madeAt: o, tx: t }), A.add(n);
        }
      for (const t of A)
        t.sort(this.compareStreamItems);
      this.totalValidTransactions += e.length;
    }
  }
  getSingleStream() {
    const A = Object.values(this.items), e = A[0];
    if (e) {
      if (A.length > 1)
        throw new Error("CoStream.getSingleStream() can only be called when there is exactly one stream");
      return e.map((t) => t.value);
    }
  }
  sessions() {
    return Object.keys(this.items);
  }
  accounts() {
    return new Set(this.sessions().map(TA).filter(Xr));
  }
  nthItemIn(A, e) {
    const t = this.items[A];
    if (!t)
      return;
    const o = t[e];
    if (o)
      return {
        by: TA(A),
        tx: o.tx,
        at: new Date(o.madeAt),
        value: o.value
      };
  }
  lastItemIn(A) {
    const e = this.items[A];
    if (e)
      return this.nthItemIn(A, e.length - 1);
  }
  *itemsIn(A) {
    const e = this.items[A];
    if (e)
      for (const t of e)
        yield {
          by: TA(A),
          tx: t.tx,
          at: new Date(t.madeAt),
          value: t.value
        };
  }
  lastItemBy(A) {
    let e;
    for (const t of Object.keys(this.items))
      if (t.startsWith(A)) {
        const o = this.lastItemIn(t);
        if (!o)
          continue;
        (!e || o.at > e.at) && (e = {
          by: o.by,
          tx: o.tx,
          at: o.at,
          value: o.value
        });
      }
    return e;
  }
  *itemsBy(A) {
    const e = [
      ...Object.keys(this.items).flatMap((t) => t.startsWith(A) ? [...this.itemsIn(t)].map((o) => ({
        in: t,
        ...o
      })) : [])
    ];
    e.sort((t, o) => t.at.getTime() - o.at.getTime());
    for (const t of e)
      yield t;
  }
  toJSON() {
    return Object.fromEntries(Object.entries(this.items).map(([A, e]) => [
      A,
      e.map((t) => t.value)
    ]));
  }
  subscribe(A) {
    return this.core.subscribe((e) => {
      A(e.getCurrentContent());
    });
  }
}
class ha extends da {
  push(A, e = "private") {
    this.core.makeTransaction([At(A) ? A.id : A], e), this.processNewTransactions();
  }
}
const Fc = 8;
class Rc extends da {
  isBinaryStreamEnded() {
    const A = this.getSingleStream();
    return !A || A.length === 0 ? !1 : A[A.length - 1]?.type === "end";
  }
  getBinaryStreamInfo() {
    const A = this.getSingleStream();
    if (!A)
      return;
    const e = A[0];
    if (e?.type !== "start") {
      AA.error("Invalid binary stream start", e);
      return;
    }
    return {
      mimeType: e.mimeType,
      fileName: e.fileName,
      totalSizeBytes: e.totalSizeBytes
    };
  }
  getBinaryChunks(A) {
    const e = this.getSingleStream();
    if (!e)
      return;
    const t = this.getBinaryStreamInfo();
    if (!t || e[e.length - 1]?.type !== "end" && !A)
      return;
    const r = [];
    let s = !1;
    for (const g of e.slice(1)) {
      if (g.type === "end") {
        s = !0;
        break;
      }
      if (g.type !== "chunk") {
        AA.error("Invalid binary stream chunk", g);
        return;
      }
      const n = ur(g.chunk.slice(Fc));
      r.push(n);
    }
    return {
      ...t,
      chunks: r,
      finished: s
    };
  }
}
class fa extends Rc {
  /** @internal */
  push(A, e = "private", t = !0) {
    this.core.makeTransaction([A], e), t && this.processNewTransactions();
  }
  startBinaryStream(A, e = "private") {
    this.push({
      type: "start",
      ...A
    }, e, !1);
  }
  pushBinaryStreamChunk(A, e = "private") {
    this.push({
      type: "chunk",
      chunk: `binary_U${dr(A)}`
    }, e, !1);
  }
  endBinaryStream(A = "private") {
    this.push({
      type: "end"
    }, A, !0);
  }
}
function At(i) {
  return i instanceof As || i instanceof Ot || i instanceof ha || i instanceof fa;
}
class As {
  /** @internal */
  get latestTxMadeAt() {
    return this.core.latestTxMadeAt;
  }
  /** @internal */
  get earliestTxMadeAt() {
    return this.core.earliestTxMadeAt;
  }
  resetInternalState() {
    this.ops = {}, this.latest = {}, this.knownTransactions = { [this.core.id]: 0 }, this.totalValidTransactions = 0;
  }
  /** @internal */
  constructor(A, e) {
    this.type = "comap", this.ops = {}, this.latest = {}, this.knownTransactions = {}, this.totalValidTransactions = 0, this.version = 0, this.atTimeFilter = void 0, this.id = A.id, this.core = A, this.ignorePrivateTransactions = e?.ignorePrivateTransactions ?? !1, this.processNewTransactions();
  }
  processNewTransactions() {
    if (this.isTimeTravelEntity())
      throw new Error("Cannot process transactions on a time travel entity");
    const A = this.core.getValidTransactions({
      ignorePrivateTransactions: this.ignorePrivateTransactions,
      knownTransactions: this.knownTransactions
    });
    if (A.length === 0)
      return;
    const { ops: e } = this, t = /* @__PURE__ */ new Map();
    for (const o of A) {
      const { txID: r, changes: s, madeAt: g, tx: n } = o;
      for (let a = 0; a < s.length; a++) {
        const I = s[a], C = {
          txID: r,
          madeAt: g,
          changeIdx: a,
          change: I,
          trusting: n.privacy === "trusting"
        }, c = e[I.key];
        if (c)
          c.push(C), t.set(I.key, c);
        else {
          const B = [C];
          e[I.key] = B, t.set(I.key, B);
        }
      }
      this.handleNewTransaction(o);
    }
    for (const o of t.values())
      o.sort(this.core.compareTransactions);
    for (const [o, r] of t.entries())
      this.latest[o] = r[r.length - 1];
    this.totalValidTransactions += A.length;
  }
  handleNewTransaction(A) {
  }
  rebuildFromCore() {
    this.version += 1, this.resetInternalState(), this.processNewTransactions();
  }
  isTimeTravelEntity() {
    return !!this.atTimeFilter;
  }
  /** @category 6. Meta */
  get headerMeta() {
    return this.core.verified.header.meta;
  }
  /** @category 6. Meta */
  get group() {
    return this.core.getGroup();
  }
  /** @category 4. Time travel */
  atTime(A) {
    const e = Object.create(this);
    return e.atTimeFilter = A, e.latest = {}, e;
  }
  /** @internal */
  timeFilteredOps(A) {
    if (A === "constructor")
      return;
    const e = this.atTimeFilter;
    return e ? this.ops[A]?.filter((t) => t.madeAt <= e) : this.ops[A];
  }
  /**
   * Get all keys currently in the map.
   *
   * @category 1. Reading */
  keys() {
    return Object.keys(this.ops).filter((A) => {
      const e = this.getRaw(A);
      return !(e === void 0 || e.change.op === "del");
    });
  }
  getRaw(A) {
    let e = this.latest[A];
    if (e === void 0) {
      const t = this.ops[A];
      if (t && !(A in this.latest)) {
        const o = this.atTimeFilter;
        o ? e = t.findLast((r) => r.madeAt <= o) : e = t[t.length - 1], this.latest[A] = e;
      }
      if (e === void 0)
        return;
    }
    return e;
  }
  /**
   * Returns the current value for the given key.
   *
   * @category 1. Reading
   **/
  get(A) {
    const e = this.getRaw(A);
    if (e?.change !== void 0 && e.change.op !== "del")
      return e.change.value;
  }
  /** @category 1. Reading */
  asObject() {
    const A = {};
    for (const e of Object.keys(this.ops)) {
      const t = this.get(e);
      t !== void 0 && (A[e] = t);
    }
    return A;
  }
  /** @category 1. Reading */
  toJSON() {
    return this.asObject();
  }
  /** @category 5. Edit history */
  nthEditAt(A, e) {
    const t = this.ops[A], o = this.atTimeFilter, r = t?.[e];
    if (r && !(o && r.madeAt > o))
      return jo(r);
  }
  /** @category 5. Edit history */
  lastEditAt(A) {
    const e = this.getRaw(A);
    if (e)
      return jo(e);
  }
  /** @category 5. Edit history */
  *editsAt(A) {
    const e = this.ops[A];
    if (!e)
      return;
    const t = this.atTimeFilter;
    for (const o of e) {
      if (t && o.madeAt > t)
        return;
      yield jo(o);
    }
  }
  /** @category 3. Subscription */
  subscribe(A) {
    return this.core.subscribe((e) => {
      A(e.getCurrentContent());
    });
  }
  /** Set a new value for the given key.
   *
   * If `privacy` is `"private"` **(default)**, both `key` and `value` are encrypted in the transaction, only readable by other members of the group this `CoMap` belongs to. Not even sync servers can see the content in plaintext.
   *
   * If `privacy` is `"trusting"`, both `key` and `value` are stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
   *
   * @category 2. Editing
   **/
  set(A, e, t = "private") {
    if (this.isTimeTravelEntity())
      throw new Error("Cannot set value on a time travel entity");
    this.core.makeTransaction([
      {
        op: "set",
        key: A,
        value: At(e) ? e.id : e
      }
    ], t), this.processNewTransactions();
  }
  assign(A, e = "private") {
    if (this.isTimeTravelEntity())
      throw new Error("Cannot set value on a time travel entity");
    this.core.makeTransaction(Object.entries(A).map(([t, o]) => ({
      op: "set",
      key: t,
      value: At(o) ? o.id : o
    })), e), this.processNewTransactions();
  }
  /** Delete the given key (setting it to undefined).
   *
   * If `privacy` is `"private"` **(default)**, `key` is encrypted in the transaction, only readable by other members of the group this `CoMap` belongs to. Not even sync servers can see the content in plaintext.
   *
   * If `privacy` is `"trusting"`, `key` is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
   *
   * @category 2. Editing
   **/
  delete(A, e = "private") {
    if (this.isTimeTravelEntity())
      throw new Error("Cannot delete value on a time travel entity");
    this.core.makeTransaction([
      {
        op: "del",
        key: A
      }
    ], e), this.processNewTransactions();
  }
}
function jo(i) {
  return {
    by: TA(i.txID.sessionID),
    tx: i.txID,
    at: new Date(i.madeAt),
    value: i.change.op === "del" ? void 0 : i.change.value
  };
}
function FA(i) {
  if (i.type !== "comap")
    throw new Error("Expected group");
  if (i.core.verified.header.ruleset.type !== "group")
    throw new Error("Expected group ruleset in group");
  if (!(i instanceof es))
    throw new Error("Expected group");
  return i;
}
function Zs(i) {
  return i === "manager" || i === "admin" || i === "writer" || i === "reader" || i === "writeOnly";
}
function Bt(i) {
  return i === "admin" || i === "manager";
}
function bc(i) {
  if (!i.isAvailable())
    throw new Error("determineValidTransactions CoValue is not available");
  if (i.verified.header.ruleset.type === "group") {
    const A = i.verified.header.ruleset.initialAdmin;
    if (!A)
      throw new Error("Group must have initialAdmin");
    Uc(i, A);
    return;
  }
  if (i.verified.header.ruleset.type === "ownedByGroup") {
    const A = FA(i.node.expectCoValueLoaded(i.verified.header.ruleset.group, "Determining valid transaction in owned object but its group wasn't loaded").getCurrentContent());
    if (A.type !== "comap")
      throw new Error("Group must be a map");
    for (const e of i.toValidateTransactions) {
      const t = A.atTime(e.currentMadeAt), o = vc(e.author, t);
      if (!o) {
        e.markInvalid("Transactor not found in group", {
          transactor: e.author,
          group: t.toJSON()
        });
        continue;
      }
      const r = t.roleOfInternal(o);
      if (r === "reader" && e.meta?.branch && e.meta?.ownerId) {
        e.meta = {
          branch: e.meta.branch,
          ownerId: e.meta.ownerId
        }, e.changes = [], e.markValid();
        continue;
      }
      if (r !== "admin" && r !== "manager" && r !== "writer" && r !== "writeOnly") {
        e.markInvalid("Transactor has no write permissions", {
          transactor: e.author,
          transactorRole: r ?? "undefined"
        });
        continue;
      }
      e.markValid();
    }
    return;
  }
  if (i.verified.header.ruleset.type === "unsafeAllowAll") {
    for (const A of i.toValidateTransactions)
      A.markValid();
    return;
  }
  throw new Error("Unknown ruleset type " + i.verified.header.ruleset.type);
}
function Kc(i, A) {
  return i === void 0 || i === "revoked" ? !1 : A === void 0 || A === "revoked" ? !0 : A === "admin" ? !1 : i === "admin" ? !0 : A === "manager" ? !1 : i === "manager" ? !0 : i === "writer" && A === "reader";
}
class Yc {
  constructor() {
    this.parentGroups = /* @__PURE__ */ new Map(), this.memberRoles = /* @__PURE__ */ new Map();
  }
  setDirectRole(A, e) {
    this.memberRoles.set(A, e);
  }
  removeMember(A) {
    this.memberRoles.delete(A);
  }
  addParentGroup(A, e) {
    this.parentGroups.set(A, e);
  }
  removeParentGroup(A) {
    this.parentGroups.delete(A);
  }
  getDirectRole(A) {
    return this.memberRoles.get(A);
  }
  getRoleAtTime(A, e) {
    let t = this.memberRoles.get(A);
    for (const [o, r] of this.parentGroups.entries()) {
      const s = o.atTime(e).roleOfInternal(A);
      if (!s || !pa(s))
        continue;
      const g = r === "extend" ? s : r;
      Kc(g, t) && (t = g);
    }
    return t;
  }
}
function Uc(i, A) {
  i.verifiedTransactions.sort(i.compareTransactions);
  const e = {}, t = /* @__PURE__ */ new Set(), o = new Yc(), r = i.isGroup();
  for (const s of i.verifiedTransactions) {
    let Q = function(l) {
      if (l.op !== "set")
        throw new Error("Expected set operation");
      o.setDirectRole(l.key, l.value), s.markValid();
    };
    const g = s.author, n = o.getRoleAtTime(g, s.currentMadeAt);
    if (s.tx.privacy === "private") {
      if (r) {
        s.markInvalid("Can't make private transactions in groups");
        continue;
      }
      if (n === "admin") {
        s.markValid();
        continue;
      } else {
        s.markInvalid("Only admins can make private transactions in groups");
        continue;
      }
    }
    const I = s.changes;
    if (!I)
      continue;
    const C = I[0];
    if (I.length !== 1) {
      s.markInvalid("Group transaction must have exactly one change");
      continue;
    }
    if (C.op !== "set") {
      s.markInvalid("Group transaction must set a role or readKey");
      continue;
    }
    if (C.key === "readKey") {
      if (!Bt(n)) {
        s.markInvalid("Only admins can set readKeys");
        continue;
      }
      s.markValid();
      continue;
    } else if (C.key === "profile") {
      if (!Bt(n)) {
        s.markInvalid("Only admins can set profile");
        continue;
      }
      s.markValid();
      continue;
    } else if (C.key === "root") {
      if (!Bt(n)) {
        s.markInvalid("Only admins can set root");
        continue;
      }
      s.markValid();
      continue;
    } else if (wa(C.key) || qc(C.key)) {
      if (n !== "admin" && n !== "adminInvite" && n !== "manager" && n !== "managerInvite" && n !== "writerInvite" && n !== "readerInvite" && n !== "writeOnlyInvite" && !Oc(C.key, g, e)) {
        s.markInvalid("Only admins and managers can reveal keys");
        continue;
      }
      s.markValid();
      continue;
    } else if (Lc(C.key)) {
      if (!Bt(n)) {
        s.markInvalid("Only admins and managers can set parent extensions");
        continue;
      }
      const l = ua(C.key), d = i.node.expectCoValueLoaded(l, "Expected parent group to be loaded");
      if (!d.isGroup()) {
        s.markInvalid("Parent group is not a group");
        continue;
      }
      const u = FA(d.getCurrentContent());
      if (ya(i, u)) {
        s.markInvalid("Parent group is a circular dependency");
        continue;
      }
      const h = C.value;
      h === "revoked" ? o.removeParentGroup(u) : o.addParentGroup(u, h), s.markValid();
      continue;
    } else if (xc(C.key)) {
      s.markInvalid("Child extensions are not allowed anymore");
      continue;
    } else if (Jc(C.key)) {
      const l = Hc(C.key);
      if (n !== "admin" && n !== "manager" && n !== "writeOnlyInvite" && l !== g) {
        s.markInvalid("Only admins and managers can set writeKeys");
        continue;
      }
      if (e[l] = C.value, t.has(C.key) && !Bt(n)) {
        s.markInvalid("Write key already exists and can't be overridden by invite");
        continue;
      }
      t.add(C.key), s.markValid();
      continue;
    }
    const c = C.key, B = C.value;
    if (B !== "admin" && B !== "manager" && B !== "writer" && B !== "reader" && B !== "writeOnly" && B !== "revoked" && B !== "managerInvite" && B !== "adminInvite" && B !== "writerInvite" && B !== "readerInvite" && B !== "writeOnlyInvite") {
      s.markInvalid("Group transaction must set a valid role");
      continue;
    }
    if (c === XA && !(B === "reader" || B === "writer" || B === "writeOnly" || B === "revoked")) {
      s.markInvalid("Everyone can only be set to reader, writer, writeOnly or revoked");
      continue;
    }
    if (n === void 0 && g === A && c === g && B === "admin") {
      Q(C);
      continue;
    }
    if (g === C.key && C.value === "revoked") {
      Q(C);
      continue;
    }
    const f = o.getRoleAtTime(c, s.currentMadeAt);
    if (n === "admin") {
      if (f === "admin" && B !== "admin" && c !== g) {
        s.markInvalid("Admins can't demote admins.");
        continue;
      }
      Q(C);
      continue;
    }
    if (n === "manager") {
      if (f === "admin") {
        s.markInvalid("Managers can't demote admins.");
        continue;
      }
      if (C.value === "admin") {
        s.markInvalid("Managers can't promote to admin.");
        continue;
      }
      if (C.value === "adminInvite") {
        s.markInvalid("Managers can't invite admins.");
        continue;
      }
      if (C.value === "managerInvite") {
        s.markInvalid("Managers can't invite managers.");
        continue;
      }
      Q(C);
      continue;
    }
    if (n === "adminInvite") {
      if (C.value !== "admin") {
        s.markInvalid("AdminInvites can only create admins.");
        continue;
      }
    } else if (n === "managerInvite") {
      if (C.value !== "manager") {
        s.markInvalid("managerInvite can only create managers.");
        continue;
      }
    } else if (n === "writerInvite") {
      if (C.value !== "writer") {
        s.markInvalid("WriterInvites can only create writers.");
        continue;
      }
    } else if (n === "readerInvite") {
      if (C.value !== "reader") {
        s.markInvalid("ReaderInvites can only create reader.");
        continue;
      }
    } else if (n === "writeOnlyInvite") {
      if (C.value !== "writeOnly") {
        s.markInvalid("WriteOnlyInvites can only create writeOnly.");
        continue;
      }
    } else {
      s.markInvalid("Group transaction must be made by current admin, manager, or invite");
      continue;
    }
    o.setDirectRole(c, C.value), s.markValid();
  }
}
function vc(i, A) {
  return i === A.id && A instanceof ts ? A.currentAgentID() : i;
}
function Jc(i) {
  return i.startsWith("writeKeyFor_");
}
function Hc(i) {
  return i.slice(12);
}
function wa(i) {
  return i.startsWith("key_") && i.includes("_for_key");
}
function qc(i) {
  return i.startsWith("key_") && (i.includes("_for_sealer") || i.includes("_for_co")) || i.includes("_for_everyone");
}
function Lc(i) {
  return i.startsWith("parent_");
}
function xc(i) {
  return i.startsWith("child_");
}
function Oc(i, A, e) {
  if (Object.keys(e).length === 0)
    return !1;
  const t = i.slice(0, i.indexOf("_for_"));
  return e[A] === t;
}
const XA = "everyone";
function Tc(i) {
  const A = i.get("readKey");
  if (!A || !ao(i, XA) || i.get(`${A}_for_${XA}`))
    return;
  if (ao(i, i.core.node.getCurrentAgent().id)) {
    const r = i.getReadKey(A);
    r && i.set(`${A}_for_${XA}`, r, "trusting");
    return;
  }
  const t = i.keys().filter((r) => r.startsWith("key_") && r.endsWith("_for_everyone"));
  let o = t[0];
  for (const r of t) {
    if (!o) {
      o = r;
      continue;
    }
    const s = i.getRaw(r), g = i.getRaw(o);
    s && g && s.madeAt > g.madeAt && (o = r);
  }
  o && (i._lastReadableKeyId = o.replace("_for_everyone", ""));
}
class Pc {
  constructor() {
    this.changes = [];
  }
  addChange(A, e) {
    const t = this.changes, o = { madeAt: A, value: e };
    let r = t.length;
    for (; r > 0 && t[r - 1].madeAt > A; )
      r--;
    r === t.length ? t.push(o) : t.splice(r, 0, o);
  }
  getLatest() {
    return this.changes[this.changes.length - 1]?.value;
  }
  getAtTime(A) {
    return A === void 0 ? this.getLatest() : this.changes.findLast((e) => e.madeAt <= A)?.value;
  }
}
class es extends As {
  resetInternalState() {
    super.resetInternalState(), this.parentGroupsChanges = /* @__PURE__ */ new Map(), this.keyRevelations = /* @__PURE__ */ new Map(), this._lastReadableKeyId = void 0;
  }
  constructor(A, e) {
    super(A, e), this.crypto = A.node.crypto, this.migrate();
  }
  // We override the handleNewTransaction hook from CoMap to build the parent group cache
  // and key revelations cache
  handleNewTransaction(A) {
    this.parentGroupsChanges || (this.parentGroupsChanges = /* @__PURE__ */ new Map()), this.keyRevelations || (this.keyRevelations = /* @__PURE__ */ new Map());
    for (const e of A.changes) {
      const t = e;
      t.op === "set" && (la(t.key) ? this.updateParentGroupCache(t.key, t.value, A.madeAt) : wa(t.key) && this.updateKeyRevelationsCache(t.key));
    }
  }
  updateKeyRevelationsCache(A) {
    const e = A.split("_for_");
    if (e.length === 2) {
      const t = e[0], o = e[1];
      let r = this.keyRevelations.get(t);
      r || (r = /* @__PURE__ */ new Set(), this.keyRevelations.set(t, r)), r.add(o);
    }
  }
  updateParentGroupCache(A, e, t) {
    const o = A.substring(7);
    let r = this.parentGroupsChanges.get(o);
    r || (r = new Pc(), this.parentGroupsChanges.set(o, r)), r.addChange(t, e);
  }
  migrate() {
    if (!this.core.isGroup())
      return;
    const A = () => {
      Tc(this);
    };
    this.core.isCompletelyDownloaded() ? A() : this.core.waitFor({
      predicate: (e) => e.isCompletelyDownloaded(),
      onSuccess: A
    });
  }
  /**
   * Returns the current role of a given account.
   *
   * @category 1. Role reading
   */
  roleOf(A) {
    return this.roleOfInternal(A);
  }
  /**
   *  This is a performance-critical function, micro-optimizing it is important
   *
   *  Avoid to add objects/array allocations in this function
   */
  /** @internal */
  roleOfInternal(A) {
    let e = this.get(A);
    e === "revoked" && (e = void 0);
    let t = e;
    for (const [o, r] of this.parentGroupsChanges.entries()) {
      const s = r.getAtTime(this.atTimeFilter);
      if (!s || s === "revoked")
        continue;
      const n = this.getParentGroup(o, this.atTimeFilter).roleOfInternal(A);
      if (!pa(n))
        continue;
      const a = s !== "extend" ? s : n;
      jc(a, t) && (t = a);
    }
    if (!t && A !== "everyone") {
      const o = this.get("everyone");
      if (o && o !== "revoked")
        return o;
    }
    return t;
  }
  getParentGroup(A, e) {
    const t = this.core.node.expectCoValueLoaded(A, "Expected parent group to be loaded"), o = FA(t.getCurrentContent());
    return e ? o.atTime(e) : o;
  }
  getParentGroups() {
    const A = [];
    for (const [e, t] of this.parentGroupsChanges.entries()) {
      const o = t.getAtTime(this.atTimeFilter);
      !o || o === "revoked" || A.push(this.getParentGroup(e, this.atTimeFilter));
    }
    return A;
  }
  forEachChildGroup(A) {
    for (const e of this.core.dependant) {
      const t = this.core.node.getCoValue(e);
      if (!t.isGroup())
        continue;
      const o = FA(t.getCurrentContent()), r = o.get(`parent_${this.id}`);
      r && r !== "revoked" && A(o);
    }
  }
  /**
   * Returns the role of the current account in the group.
   *
   * @category 1. Role reading
   */
  myRole() {
    return this.roleOfInternal(this.core.node.getCurrentAccountOrAgentID());
  }
  /**
   * Directly grants a new member a role in the group. The current account must be an
   * admin to be able to do so. Throws otherwise.
   *
   * @category 2. Role changing
   */
  addMember(A, e) {
    this.addMemberInternal(A, e);
  }
  /** @internal */
  addMemberInternal(A, e) {
    const t = typeof A == "string" ? A : A.id, o = this.get(t);
    if (o === e)
      return;
    if (t === XA) {
      if (!(e === "reader" || e === "writer" || e === "writeOnly"))
        throw new Error("Can't make everyone something other than reader, writer or writeOnly");
      const s = this.getCurrentReadKey();
      if (!s.secret)
        throw new Error("Can't add member without read key secret");
      const g = this.get(t);
      if (this.set(t, e, "trusting"), this.get(t) !== e)
        throw new Error(`Failed to set role ${e} to ${t} (role of current account is ${this.myRole()})`);
      e === "writeOnly" ? ((g === "reader" || g === "writer") && this.rotateReadKey("everyone"), this.delete(`${s.id}_for_${XA}`)) : this.set(`${s.id}_for_${XA}`, s.secret, "trusting");
      return;
    }
    const r = typeof A == "string" ? A : A.currentAgentID();
    if (r === XA)
      throw new Error("Agent should not be everyone");
    if (e === "writeOnly" || e === "writeOnlyInvite") {
      if ((o === "reader" || o === "writer" || o === "manager" || o === "admin") && this.rotateReadKey(t), this.set(t, e, "trusting"), this.get(t) !== e)
        throw new Error(`Failed to set role ${e} to ${t} (role of current account is ${this.myRole()})`);
      this.internalCreateWriteOnlyKeyForMember(t, r);
    } else {
      const s = this.getCurrentReadKey();
      if (!s.secret)
        throw new Error("Can't add member without read key secret");
      if (this.set(t, e, "trusting"), this.get(t) !== e)
        throw new Error(`Failed to set role ${e} to ${t} (role of current account is ${this.myRole()})`);
      this.storeKeyRevelationForMember(t, r, s.id, s.secret);
      for (const g of this.getWriteOnlyKeys()) {
        const n = this.core.getReadKey(g);
        if (!n) {
          AA.error("Can't find key " + g);
          continue;
        }
        this.storeKeyRevelationForMember(t, r, g, n);
      }
    }
  }
  internalCreateWriteOnlyKeyForMember(A, e) {
    const t = this.crypto.newRandomKeySecret();
    this.set(`writeKeyFor_${A}`, t.id, "trusting"), this.storeKeyRevelationForMember(A, e, t.id, t.secret);
    for (const o of this.getMemberKeys()) {
      const r = this.get(o);
      if (r === "reader" || r === "writer" || r === "admin" || r === "manager" || r === "readerInvite" || r === "writerInvite" || r === "adminInvite") {
        const s = this.core.node.resolveAccountAgent(o, "Expected member agent to be loaded").value;
        if (!s)
          throw new Error("Expected member agent to be loaded");
        this.storeKeyRevelationForMember(o, s, t.id, t.secret);
      }
    }
    for (const o of this.getParentGroups())
      this.revealReadKeyToParentGroup(o, t.id, t.secret, { revealAllWriteOnlyKeys: !1 });
    return t.id;
  }
  storeKeyRevelationForMember(A, e, t, o) {
    this.set(`${t}_for_${A}`, this.crypto.seal({
      message: o,
      from: this.core.node.getCurrentAgent().currentSealerSecret(),
      to: this.crypto.getAgentSealerID(e),
      nOnceMaterial: {
        in: this.id,
        tx: this.core.nextTransactionID()
      }
    }), "trusting");
  }
  storeKeyRevelationForParentGroup(A, e, t, o) {
    this.set(`${t}_for_${A}`, this.crypto.encryptKeySecret({
      encrypting: {
        id: A,
        secret: e
      },
      toEncrypt: {
        id: t,
        secret: o
      }
    }).encrypted, "trusting");
  }
  getWriteOnlyKeys() {
    const A = [];
    for (const e of this.keys())
      e.startsWith("writeKeyFor_") && A.push(this.get(e));
    return A;
  }
  getCurrentReadKeyId() {
    if (this._lastReadableKeyId)
      return this._lastReadableKeyId;
    const A = this.myRole();
    if (A === "writeOnly") {
      const e = this.core.node.getCurrentAgent().id, t = this.get(`writeKeyFor_${e}`);
      return !t && this.get("everyone") === "writeOnly" ? (this.internalCreateWriteOnlyKeyForMember(e, this.core.node.getCurrentAgent().currentAgentID()), this.get(`writeKeyFor_${e}`)) : t;
    }
    if (!A) {
      const e = this.core.node.getCurrentAgent().id, t = this.get(`writeKeyFor_${e}`);
      if (t)
        return t;
    }
    return this.get("readKey");
  }
  getMemberKeys() {
    return this.keys().filter((A) => A.startsWith("co_") || $e(A));
  }
  getAllMemberKeysSet() {
    const A = new Set(this.getMemberKeys());
    for (const e of this.getParentGroups())
      for (const t of e.getAllMemberKeysSet())
        A.add(t);
    return A;
  }
  getReadKey(A) {
    const e = this.core.readKeyCache;
    let t = e.get(A);
    return t || (t = this.getUncachedReadKey(A), t && e.set(A, t)), t;
  }
  getUncachedReadKey(A) {
    const e = this.core, t = this.get(`${A}_for_everyone`);
    if (t)
      return t;
    const o = TA(e.node.currentSessionID), r = Xr(o) && e.id === o ? e.node.crypto.getAgentID(e.node.agentSecret) : o, s = this.lastEditAt(`${A}_for_${r}`);
    if (s?.value) {
      const n = s.by, a = e.node.resolveAccountAgent(n, "Expected to know revealer").value;
      if (!a)
        throw new Error("Expected to know revealer");
      const I = this.crypto.unseal(
        s.value,
        this.crypto.getAgentSealerSecret(e.node.agentSecret),
        // being careful here to avoid recursion
        this.crypto.getAgentSealerID(a),
        {
          in: this.id,
          tx: s.tx
        }
      );
      if (I)
        return I;
    }
    const g = this.keyRevelations.get(A);
    if (g)
      for (const n of g) {
        const a = this.getReadKey(n);
        if (!a)
          continue;
        const I = this.get(`${A}_for_${n}`), C = this.crypto.decryptKeySecret({
          encryptedID: A,
          encryptingID: n,
          encrypted: I
        }, a);
        if (C)
          return C;
        AA.warn(`Encrypting ${n} key didn't decrypt ${A}`);
      }
    for (const n of this.parentGroupsChanges.keys()) {
      const a = e.node.expectCoValueLoaded(n, "Expected parent group to be loaded"), I = this.findValidParentKeys(A, a);
      for (const C of I) {
        const c = this.get(`${A}_for_${C.id}`);
        if (c) {
          const B = a.node.crypto.decryptKeySecret({
            encryptedID: A,
            encryptingID: C.id,
            encrypted: c
          }, C.secret);
          if (B)
            return B;
          AA.warn(`Encrypting parent ${C.id} key didn't decrypt ${A}`);
        }
      }
    }
  }
  findValidParentKeys(A, e) {
    const t = [], o = this.keyRevelations.get(A);
    if (o)
      for (const r of o) {
        const s = e.getReadKey(r);
        s && t.push({
          id: r,
          secret: s
        });
      }
    return t;
  }
  /** @internal */
  rotateReadKey(A) {
    if (A !== XA && ao(this, XA))
      return;
    const e = this.getMemberKeys().filter((a) => a !== A), t = e.filter((a) => ao(this, a)), o = e.filter((a) => {
      const I = this.get(a);
      return I === "writeOnly" || I === "writeOnlyInvite";
    }), r = this.getParentGroups(), s = this.getCurrentReadKey();
    if (!s.secret)
      throw new _s("Can't rotate read key secret we don't have access to");
    const g = {
      id: s.id,
      secret: s.secret
    }, n = this.crypto.newRandomKeySecret();
    for (const a of t) {
      const I = this.core.node.resolveAccountAgent(a, "Expected to know currently permitted reader").value;
      if (!I)
        throw new Error("Expected to know currently permitted reader");
      this.storeKeyRevelationForMember(a, I, n.id, n.secret);
    }
    for (const a of o) {
      const I = this.core.node.resolveAccountAgent(a, "Expected to know writeOnly member").value;
      if (!I)
        throw new Error("Expected to know writeOnly member");
      const C = this.crypto.newRandomKeySecret();
      this.storeKeyRevelationForMember(a, I, C.id, C.secret), this.set(`writeKeyFor_${a}`, C.id, "trusting");
      for (const c of t) {
        const B = this.core.node.resolveAccountAgent(c, "Expected to know currently permitted reader").value;
        if (!B)
          throw new Error("Expected to know currently permitted reader");
        this.storeKeyRevelationForMember(c, B, C.id, C.secret);
      }
      for (const c of this.getParentGroups())
        this.revealReadKeyToParentGroup(c, C.id, C.secret, { revealAllWriteOnlyKeys: !1 });
    }
    this.set(`${g.id}_for_${n.id}`, this.crypto.encryptKeySecret({
      encrypting: n,
      toEncrypt: g
    }).encrypted, "trusting"), this.set("readKey", n.id, "trusting");
    for (const a of r) {
      const { id: I, secret: C } = a.getCurrentReadKey();
      if (!C) {
        AA.warn("Can't reveal new child key to parent where we don't have access to the parent read key");
        continue;
      }
      this.storeKeyRevelationForParentGroup(I, C, n.id, n.secret);
    }
    this.forEachChildGroup((a) => {
      if (!a.isSelfExtension(this))
        try {
          a.rotateReadKey(A);
        } catch (I) {
          if (I instanceof _s)
            AA.warn(`Can't rotate read key on child ${a.id} because we don't have access to the read key`);
          else
            throw I;
        }
    });
  }
  /** Detect circular references in group inheritance */
  isSelfExtension(A) {
    return ya(this.core, A);
  }
  getCurrentReadKey() {
    const A = this.getCurrentReadKeyId();
    if (!A)
      throw new Error("No readKey set");
    return {
      secret: this.getReadKey(A),
      id: A
    };
  }
  extend(A, e = "inherit") {
    if (this.isSelfExtension(A))
      return;
    if (this.myRole() !== "admin")
      throw new Error("To extend a group, the current account must be an admin in the child group");
    const t = e === "inherit" ? "extend" : e;
    this.set(`parent_${A.id}`, t, "trusting");
    const { id: o, secret: r } = this.getCurrentReadKey();
    if (r === void 0)
      throw new Error("Can't extend group without child read key secret");
    this.revealReadKeyToParentGroup(A, o, r, { revealAllWriteOnlyKeys: !0 });
  }
  revealReadKeyToParentGroup(A, e, t, { revealAllWriteOnlyKeys: o }) {
    let r;
    Zs(A.myRole()) || (r = A.internalCreateWriteOnlyKeyForMember(this.core.node.getCurrentAgent().id, this.core.node.getCurrentAgent().currentAgentID()));
    let { id: s, secret: g } = A.getCurrentReadKey();
    if (!g)
      throw new Error("Can't extend group without parent read key secret");
    if (this.storeKeyRevelationForParentGroup(s, g, e, t), o)
      for (const n of this.getWriteOnlyKeys()) {
        if (n === r)
          continue;
        const a = this.core.getReadKey(n);
        if (!a) {
          AA.error("Can't find key " + n);
          continue;
        }
        this.storeKeyRevelationForParentGroup(s, g, n, a);
      }
  }
  revokeExtend(A) {
    if (this.myRole() !== "admin")
      throw new Error("To unextend a group, the current account must be an admin in the child group");
    if (!Zs(A.myRole()))
      throw new Error("To unextend a group, the current account must be a member of the parent group");
    !this.get(`parent_${A.id}`) || this.get(`parent_${A.id}`) === "revoked" || (this.set(`parent_${A.id}`, "revoked", "trusting"), A.get(`child_${this.id}`) && A.set(`child_${this.id}`, "revoked", "trusting"), this.rotateReadKey());
  }
  /**
   * Strips the specified member of all roles (preventing future writes in
   *  the group and owned values) and rotates the read encryption key for that group
   * (preventing reads of new content in the group and owned values)
   *
   * @category 2. Role changing
   */
  removeMember(A) {
    const e = typeof A == "string" ? A : A.id;
    if ((this.myRole() === "admin" || this.myRole() === "manager") && this.rotateReadKey(e), this.set(e, "revoked", "trusting"), this.get(e) !== "revoked")
      throw new Error(`Failed to revoke role to ${e} (role of current account is ${this.myRole()})`);
  }
  /**
   * Creates an invite for new members to indirectly join the group,
   * allowing them to grant themselves the specified role with the InviteSecret
   * (a string starting with "inviteSecret_") - use `LocalNode.acceptInvite()` for this purpose.
   *
   * @category 2. Role changing
   */
  createInvite(A) {
    const e = this.crypto.newRandomSecretSeed(), t = this.crypto.agentSecretFromSecretSeed(e), o = this.crypto.getAgentID(t);
    return this.addMemberInternal(o, `${A}Invite`), Vc(e);
  }
  /**
   * Creates a new `CoMap` within this group, with the specified specialized
   * `CoMap` type `M` and optional static metadata.
   *
   * @category 3. Value creation
   */
  createMap(A, e, t = "private", o = this.crypto.createdNowUnique()) {
    const r = this.core.node.createCoValue({
      type: "comap",
      ruleset: {
        type: "ownedByGroup",
        group: this.id
      },
      meta: e || null,
      ...o.createdAt !== void 0 ? { createdAt: o.createdAt } : {},
      uniqueness: o.uniqueness
    }).getCurrentContent();
    return A ? r.assign(A, t) : o.createdAt || r.core.makeTransaction([], "trusting"), r;
  }
  /**
   * Creates a new `CoList` within this group, with the specified specialized
   * `CoList` type `L` and optional static metadata.
   *
   * @category 3. Value creation
   */
  createList(A, e, t = "private", o = this.crypto.createdNowUnique()) {
    const r = this.core.node.createCoValue({
      type: "colist",
      ruleset: {
        type: "ownedByGroup",
        group: this.id
      },
      meta: e || null,
      ...o.createdAt !== void 0 ? { createdAt: o.createdAt } : {},
      uniqueness: o.uniqueness
    }).getCurrentContent();
    return A?.length ? r.appendItems(A, void 0, t) : o.createdAt || r.core.makeTransaction([], "trusting"), r;
  }
  /**
   * Creates a new `CoPlainText` within this group, with the specified specialized
   * `CoPlainText` type `T` and optional static metadata.
   *
   * @category 3. Value creation
   */
  createPlainText(A, e, t = "private") {
    const o = this.core.node.createCoValue({
      type: "coplaintext",
      ruleset: {
        type: "ownedByGroup",
        group: this.id
      },
      meta: e || null,
      ...this.crypto.createdNowUnique()
    }).getCurrentContent();
    return A && o.insertAfter(0, A, t), o;
  }
  /** @category 3. Value creation */
  createStream(A, e = this.crypto.createdNowUnique()) {
    const t = this.core.node.createCoValue({
      type: "costream",
      ruleset: {
        type: "ownedByGroup",
        group: this.id
      },
      meta: A || null,
      ...e.createdAt !== void 0 ? { createdAt: e.createdAt } : {},
      uniqueness: e.uniqueness
    }).getCurrentContent();
    return e.createdAt || t.core.makeTransaction([], "trusting"), t;
  }
  /** @category 3. Value creation */
  createBinaryStream(A = { type: "binary" }, e = this.crypto.createdNowUnique()) {
    return this.core.node.createCoValue({
      type: "costream",
      ruleset: {
        type: "ownedByGroup",
        group: this.id
      },
      meta: A,
      ...e.createdAt !== void 0 ? { createdAt: e.createdAt } : {},
      uniqueness: e.uniqueness
    }).getCurrentContent();
  }
}
function pa(i) {
  return i === "revoked" || i === "admin" || i === "manager" || i === "writer" || i === "reader";
}
function jc(i, A) {
  return i === "revoked" ? !0 : i === "manager" ? !A || A !== "manager" && A !== "admin" : i === "admin" ? !A || A !== "admin" : i === "writer" ? !A || A === "reader" || A === "writeOnly" : i === "reader" ? !A : !1;
}
function Vc(i) {
  return `inviteSecret_z${UA.encode(i)}`;
}
function Wc(i) {
  if (!i.startsWith("inviteSecret_z"))
    throw new Error("Invalid invite secret");
  return UA.decode(i.slice(14));
}
const ao = (i, A) => {
  const e = i.get(A);
  return e === "admin" || e === "manager" || e === "writer" || e === "reader" || e === "adminInvite" || e === "writerInvite" || e === "readerInvite";
};
class _s extends Error {
  constructor(A) {
    super(A), this.name = "NoReadKeyAccessError";
  }
}
function ya(i, A) {
  const e = /* @__PURE__ */ new Set(), t = [A];
  for (; ; ) {
    const o = t.pop();
    if (!o)
      return !1;
    if (o.id === i.id)
      return !0;
    e.add(o.id);
    const r = o.getParentGroups();
    for (const s of r)
      e.has(s.id) || t.push(s);
  }
}
function Da(i, A) {
  return {
    type: "comap",
    ruleset: { type: "group", initialAdmin: A.getAgentID(i) },
    meta: {
      type: "account"
    },
    createdAt: null,
    uniqueness: null
  };
}
class ts extends es {
  currentAgentID() {
    if (this._cachedCurrentAgentID)
      return this._cachedCurrentAgentID;
    const A = this.core.verified.header;
    if (A.ruleset.type !== "group")
      throw new Error("You can't get an agent id from a non-group value");
    const e = A.ruleset.initialAdmin;
    if (!$e(e))
      throw new Error("You can read agent ids only from account values");
    return this._cachedCurrentAgentID = e, e;
  }
  createInvite(A) {
    throw new Error("Cannot create invite from an account");
  }
  roleOfInternal(A) {
    return A === this.id ? "admin" : super.roleOfInternal(A);
  }
  addMember(A, e) {
    throw new Error("Cannot add a member to an account");
  }
  removeMember(A) {
    throw new Error("Cannot remove a member from an account");
  }
  extend(A, e = "inherit") {
    throw new Error("Cannot extend an account");
  }
  revokeExtend(A) {
    throw new Error("Cannot unextend an account");
  }
}
class zc {
  constructor(A, e) {
    this.account = A, this.agentSecret = e, this.crypto = A.core.node.crypto;
  }
  get id() {
    return this.account.id;
  }
  currentAgentID() {
    return this.crypto.getAgentID(this.agentSecret);
  }
  currentSignerID() {
    return this.crypto.getAgentSignerID(this.currentAgentID());
  }
  currentSignerSecret() {
    return this.crypto.getAgentSignerSecret(this.agentSecret);
  }
  currentSealerID() {
    return this.crypto.getAgentSealerID(this.currentAgentID());
  }
  currentSealerSecret() {
    return this.crypto.getAgentSealerSecret(this.agentSecret);
  }
}
class $s {
  constructor(A, e) {
    this.agentSecret = A, this.crypto = e;
  }
  get id() {
    return this.crypto.getAgentID(this.agentSecret);
  }
  currentAgentID() {
    return this.crypto.getAgentID(this.agentSecret);
  }
  currentSignerID() {
    return this.crypto.getAgentSignerID(this.currentAgentID());
  }
  currentSignerSecret() {
    return this.crypto.getAgentSignerSecret(this.agentSecret);
  }
  currentSealerID() {
    return this.crypto.getAgentSealerID(this.currentAgentID());
  }
  currentSealerSecret() {
    return this.crypto.getAgentSealerSecret(this.agentSecret);
  }
}
function Xs(i) {
  if (!(i instanceof ts))
    throw new Error("Expected an account");
  return i;
}
function ma(i, A = "") {
  let e = (
    /** @type {Array<CategorizedUnicodeRange<T>>} */
    []
  ), t = i.split(",").map((r) => r ? parseInt(r, 36) : 0), o = 0;
  for (let r = 0; r < t.length; r++)
    r % 2 ? e.push([
      o,
      o + t[r],
      /** @type {T} */
      A ? parseInt(A[r >> 1], 36) : 0
    ]) : o = t[r];
  return e;
}
function Sa(i, A) {
  let e = 0, t = A.length - 1;
  for (; e <= t; ) {
    let o = e + t >> 1, r = A[o], s = r[0], g = r[1];
    if (s <= i && i <= g) return o;
    i > g ? e = o + 1 : t = o - 1;
  }
  return -1;
}
function Zc(i) {
  return i <= 65535;
}
const Ag = ma(
  /** @type {UnicodeDataEncoding} */
  ",9,a,,b,1,d,,e,h,3j,w,4p,,4t,,4u,,lc,33,w3,6,13l,18,14v,,14x,1,150,1,153,,16o,5,174,a,17g,,18r,k,19s,,1cm,6,1ct,,1cv,5,1d3,1,1d6,3,1e7,,1e9,,1f4,q,1ie,a,1kb,8,1kt,,1li,3,1ln,8,1lx,2,1m1,4,1nd,2,1ow,1,1p3,8,1qi,n,1r6,,1r7,v,1s3,,1tm,,1tn,,1to,,1tq,2,1tt,7,1u1,3,1u5,,1u6,1,1u9,6,1uq,1,1vl,,1vm,1,1x8,,1xa,,1xb,1,1xd,3,1xj,1,1xn,1,1xp,,1xz,,1ya,1,1z2,,1z5,1,1z7,,20s,,20u,2,20x,1,213,1,217,2,21d,,228,1,22d,,22p,1,22r,,24c,,24e,2,24h,4,24n,1,24p,,24r,1,24t,,25e,1,262,5,269,,26a,1,27w,,27y,1,280,,281,3,287,1,28b,1,28d,,28l,2,28y,1,29u,,2bi,,2bj,,2bk,,2bl,1,2bq,2,2bu,2,2bx,,2c7,,2dc,,2dd,2,2dg,,2f0,,2f2,2,2f5,3,2fa,2,2fe,3,2fp,1,2g2,1,2gx,,2gy,1,2ik,,2im,,2in,1,2ip,,2iq,,2ir,1,2iu,2,2iy,3,2j9,1,2jm,1,2k3,,2kg,1,2ki,1,2m3,1,2m6,,2m7,1,2m9,3,2me,2,2mi,2,2ml,,2mm,,2mv,,2n6,1,2o1,,2o2,1,2q2,,2q7,,2q8,1,2qa,2,2qe,,2qg,6,2qn,,2r6,1,2sx,,2sz,,2t0,6,2tj,7,2wh,,2wj,,2wk,8,2x4,6,2zc,1,305,,307,,309,,30e,1,31t,d,327,,328,4,32e,1,32l,a,32x,z,346,,371,3,375,,376,5,37d,1,37f,1,37h,1,386,1,388,1,38e,2,38x,3,39e,,39g,,39h,1,39p,,3a5,,3cw,2n,3fk,1z,3hk,2f,3tp,2,4k2,3,4ky,2,4lu,1,4mq,1,4ok,1,4om,,4on,6,4ou,7,4p2,,4p3,1,4p5,a,4pp,,4qz,2,4r2,,4r3,,4ud,1,4vd,,4yo,2,4yr,3,4yv,1,4yx,2,4z4,1,4z6,,4z7,5,4zd,2,55j,1,55l,1,55n,,579,,57a,,57b,,57c,6,57k,,57m,,57p,7,57x,5,583,9,58f,,59s,u,5c0,3,5c4,,5dg,9,5dq,3,5du,2,5ez,8,5fk,1,5fm,,5gh,,5gi,3,5gm,1,5go,5,5ie,,5if,,5ig,1,5ii,2,5il,,5im,,5in,4,5k4,7,5kc,7,5kk,1,5km,1,5ow,2,5p0,c,5pd,,5pe,6,5pp,,5pw,,5pz,,5q0,1,5vk,1r,6bv,,6bw,,6bx,,6by,1,6co,6,6d8,,6dl,,6e8,f,6hc,w,6jm,,6k9,,6ms,5,6nd,1,6xm,1,6y0,,70o,,72n,,73d,a,73s,2,79e,,7fu,1,7g6,,7gg,,7i3,3,7i8,5,7if,b,7is,35,7m8,39,7pk,a,7pw,,7py,,7q5,,7q9,,7qg,,7qr,1,7r8,,7rb,,7rg,,7ri,,7rn,2,7rr,,7s3,4,7th,2,7tt,,7u8,,7un,,850,1,8hx,2,8ij,1,8k0,,8k5,,8vj,2,8zj,,928,v,9ii,5,9io,,9j1,,9ll,1,9zr,,9zt,,wvj,3,wvo,9,wwu,1,wz4,1,x6q,,x6u,,x6z,,x7n,1,x7p,1,x7r,,x7w,,xa8,1,xbo,f,xc4,1,xcw,h,xdr,,xeu,7,xfr,a,xg2,,xg3,,xgg,s,xhc,2,xhf,,xir,,xis,1,xiu,3,xiy,1,xj0,1,xj2,1,xj4,,xk5,,xm1,5,xm7,1,xm9,1,xmb,1,xmd,1,xmr,,xn0,,xn1,,xoc,,xps,,xpu,2,xpz,1,xq6,1,xq9,,xrf,,xrg,1,xri,1,xrp,,xrq,,xyb,1,xyd,,xye,1,xyg,,xyh,1,xyk,,xyl,,xz4,,xz5,q,xzw,,xzx,q,y0o,,y0p,q,y1g,,y1h,q,y28,,y29,q,y30,,y31,q,y3s,,y3t,q,y4k,,y4l,q,y5c,,y5d,q,y64,,y65,q,y6w,,y6x,q,y7o,,y7p,q,y8g,,y8h,q,y98,,y99,q,ya0,,ya1,q,yas,,yat,q,ybk,,ybl,q,ycc,,ycd,q,yd4,,yd5,q,ydw,,ydx,q,yeo,,yep,q,yfg,,yfh,q,yg8,,yg9,q,yh0,,yh1,q,yhs,,yht,q,yik,,yil,q,yjc,,yjd,q,yk4,,yk5,q,ykw,,ykx,q,ylo,,ylp,q,ymg,,ymh,q,yn8,,yn9,q,yo0,,yo1,q,yos,,yot,q,ypk,,ypl,q,yqc,,yqd,q,yr4,,yr5,q,yrw,,yrx,q,yso,,ysp,q,ytg,,yth,q,yu8,,yu9,q,yv0,,yv1,q,yvs,,yvt,q,ywk,,ywl,q,yxc,,yxd,q,yy4,,yy5,q,yyw,,yyx,q,yzo,,yzp,q,z0g,,z0h,q,z18,,z19,q,z20,,z21,q,z2s,,z2t,q,z3k,,z3l,q,z4c,,z4d,q,z54,,z55,q,z5w,,z5x,q,z6o,,z6p,q,z7g,,z7h,q,z88,,z89,q,z90,,z91,q,z9s,,z9t,q,zak,,zal,q,zbc,,zbd,q,zc4,,zc5,q,zcw,,zcx,q,zdo,,zdp,q,zeg,,zeh,q,zf8,,zf9,q,zg0,,zg1,q,zgs,,zgt,q,zhk,,zhl,q,zic,,zid,q,zj4,,zj5,q,zjw,,zjx,q,zko,,zkp,q,zlg,,zlh,q,zm8,,zm9,q,zn0,,zn1,q,zns,,znt,q,zok,,zol,q,zpc,,zpd,q,zq4,,zq5,q,zqw,,zqx,q,zro,,zrp,q,zsg,,zsh,q,zt8,,zt9,q,zu0,,zu1,q,zus,,zut,q,zvk,,zvl,q,zwc,,zwd,q,zx4,,zx5,q,zxw,,zxx,q,zyo,,zyp,q,zzg,,zzh,q,1008,,1009,q,1010,,1011,q,101s,,101t,q,102k,,102l,q,103c,,103d,q,1044,,1045,q,104w,,104x,q,105o,,105p,q,106g,,106h,q,1078,,1079,q,1080,,1081,q,108s,,108t,q,109k,,109l,q,10ac,,10ad,q,10b4,,10b5,q,10bw,,10bx,q,10co,,10cp,q,10dg,,10dh,q,10e8,,10e9,q,10f0,,10f1,q,10fs,,10ft,q,10gk,,10gl,q,10hc,,10hd,q,10i4,,10i5,q,10iw,,10ix,q,10jo,,10jp,q,10kg,,10kh,q,10l8,,10l9,q,10m0,,10m1,q,10ms,,10mt,q,10nk,,10nl,q,10oc,,10od,q,10p4,,10p5,q,10pw,,10px,q,10qo,,10qp,q,10rg,,10rh,q,10s8,,10s9,q,10t0,,10t1,q,10ts,,10tt,q,10uk,,10ul,q,10vc,,10vd,q,10w4,,10w5,q,10ww,,10wx,q,10xo,,10xp,q,10yg,,10yh,q,10z8,,10z9,q,1100,,1101,q,110s,,110t,q,111k,,111l,q,112c,,112d,q,1134,,1135,q,113w,,113x,q,114o,,114p,q,115g,,115h,q,1168,,1169,q,1170,,1171,q,117s,,117t,q,118k,,118l,q,119c,,119d,q,11a4,,11a5,q,11aw,,11ax,q,11bo,,11bp,q,11cg,,11ch,q,11d8,,11d9,q,11e0,,11e1,q,11es,,11et,q,11fk,,11fl,q,11gc,,11gd,q,11h4,,11h5,q,11hw,,11hx,q,11io,,11ip,q,11jg,,11jh,q,11k8,,11k9,q,11l0,,11l1,q,11ls,,11lt,q,11mk,,11ml,q,11nc,,11nd,q,11o4,,11o5,q,11ow,,11ox,q,11po,,11pp,q,11qg,,11qh,q,11r8,,11r9,q,11s0,,11s1,q,11ss,,11st,q,11tk,,11tl,q,11uc,,11ud,q,11v4,,11v5,q,11vw,,11vx,q,11wo,,11wp,q,11xg,,11xh,q,11y8,,11y9,q,11z0,,11z1,q,11zs,,11zt,q,120k,,120l,q,121c,,121d,q,1224,,1225,q,122w,,122x,q,123o,,123p,q,124g,,124h,q,1258,,1259,q,1260,,1261,q,126s,,126t,q,127k,,127l,q,128c,,128d,q,1294,,1295,q,129w,,129x,q,12ao,,12ap,q,12bg,,12bh,q,12c8,,12c9,q,12d0,,12d1,q,12ds,,12dt,q,12ek,,12el,q,12fc,,12fd,q,12g4,,12g5,q,12gw,,12gx,q,12ho,,12hp,q,12ig,,12ih,q,12j8,,12j9,q,12k0,,12k1,q,12ks,,12kt,q,12lk,,12ll,q,12mc,,12md,q,12n4,,12n5,q,12nw,,12nx,q,12oo,,12op,q,12pg,,12ph,q,12q8,,12q9,q,12r0,,12r1,q,12rs,,12rt,q,12sk,,12sl,q,12tc,,12td,q,12u4,,12u5,q,12uw,,12ux,q,12vo,,12vp,q,12wg,,12wh,q,12x8,,12x9,q,12y0,,12y1,q,12ys,,12yt,q,12zk,,12zl,q,130c,,130d,q,1314,,1315,q,131w,,131x,q,132o,,132p,q,133g,,133h,q,1348,,1349,q,1350,,1351,q,135s,,135t,q,136k,,136l,q,137c,,137d,q,1384,,1385,q,138w,,138x,q,139o,,139p,q,13ag,,13ah,q,13b8,,13b9,q,13c0,,13c1,q,13cs,,13ct,q,13dk,,13dl,q,13ec,,13ed,q,13f4,,13f5,q,13fw,,13fx,q,13go,,13gp,q,13hg,,13hh,q,13i8,,13i9,q,13j0,,13j1,q,13js,,13jt,q,13kk,,13kl,q,13lc,,13ld,q,13m4,,13m5,q,13mw,,13mx,q,13no,,13np,q,13og,,13oh,q,13p8,,13p9,q,13q0,,13q1,q,13qs,,13qt,q,13rk,,13rl,q,13sc,,13sd,q,13t4,,13t5,q,13tw,,13tx,q,13uo,,13up,q,13vg,,13vh,q,13w8,,13w9,q,13x0,,13x1,q,13xs,,13xt,q,13yk,,13yl,q,13zc,,13zd,q,1404,,1405,q,140w,,140x,q,141o,,141p,q,142g,,142h,q,1438,,1439,q,1440,,1441,q,144s,,144t,q,145k,,145l,q,146c,,146d,q,1474,,1475,q,147w,,147x,q,148o,,148p,q,149g,,149h,q,14a8,,14a9,q,14b0,,14b1,q,14bs,,14bt,q,14ck,,14cl,q,14dc,,14dd,q,14e4,,14e5,q,14ew,,14ex,q,14fo,,14fp,q,14gg,,14gh,q,14h8,,14h9,q,14i0,,14i1,q,14is,,14it,q,14jk,,14jl,q,14kc,,14kd,q,14l4,,14l5,q,14lw,,14lx,q,14mo,,14mp,q,14ng,,14nh,q,14o8,,14o9,q,14p0,,14p1,q,14ps,,14pt,q,14qk,,14ql,q,14rc,,14rd,q,14s4,,14s5,q,14sw,,14sx,q,14to,,14tp,q,14ug,,14uh,q,14v8,,14v9,q,14w0,,14w1,q,14ws,,14wt,q,14xk,,14xl,q,14yc,,14yd,q,14z4,,14z5,q,14zw,,14zx,q,150o,,150p,q,151g,,151h,q,1528,,1529,q,1530,,1531,q,153s,,153t,q,154k,,154l,q,155c,,155d,q,1564,,1565,q,156w,,156x,q,157o,,157p,q,158g,,158h,q,1598,,1599,q,15a0,,15a1,q,15as,,15at,q,15bk,,15bl,q,15cc,,15cd,q,15d4,,15d5,q,15dw,,15dx,q,15eo,,15ep,q,15fg,,15fh,q,15g8,,15g9,q,15h0,,15h1,q,15hs,,15ht,q,15ik,,15il,q,15jc,,15jd,q,15k4,,15k5,q,15kw,,15kx,q,15lo,,15lp,q,15mg,,15mh,q,15n8,,15n9,q,15o0,,15o1,q,15os,,15ot,q,15pk,,15pl,q,15qc,,15qd,q,15r4,,15r5,q,15rw,,15rx,q,15so,,15sp,q,15tg,,15th,q,15u8,,15u9,q,15v0,,15v1,q,15vs,,15vt,q,15wk,,15wl,q,15xc,,15xd,q,15y4,,15y5,q,15yw,,15yx,q,15zo,,15zp,q,160g,,160h,q,1618,,1619,q,1620,,1621,q,162s,,162t,q,163k,,163l,q,164c,,164d,q,1654,,1655,q,165w,,165x,q,166o,,166p,q,167g,,167h,q,1688,,1689,q,1690,,1691,q,169s,,169t,q,16ak,,16al,q,16bc,,16bd,q,16c4,,16c5,q,16cw,,16cx,q,16do,,16dp,q,16eg,,16eh,q,16f8,,16f9,q,16g0,,16g1,q,16gs,,16gt,q,16hk,,16hl,q,16ic,,16id,q,16j4,,16j5,q,16jw,,16jx,q,16ko,,16kp,q,16ls,m,16mj,1c,1dlq,,1e68,f,1e74,f,1edb,,1ehq,1,1ek0,b,1eyl,,1f4w,,1f92,4,1gjl,2,1gjp,1,1gjw,3,1gl4,2,1glb,,1gpx,1,1h5w,3,1h7t,4,1hgr,1,1hj0,3,1hl2,a,1hmq,3,1hq8,,1hq9,,1hqa,,1hrs,e,1htc,,1htf,1,1htr,2,1htu,,1hv4,2,1hv7,3,1hvb,1,1hvd,1,1hvh,,1hvm,,1hvx,,1hxc,2,1hyf,4,1hyk,,1hyl,7,1hz9,1,1i0j,,1i0w,1,1i0y,,1i2b,2,1i2e,8,1i2n,,1i2o,,1i2q,1,1i2x,3,1i32,,1i33,,1i5o,2,1i5r,2,1i5u,1,1i5w,3,1i66,,1i69,,1ian,,1iao,2,1iar,7,1ibk,1,1ibm,1,1id7,1,1ida,,1idb,,1idc,,1idd,3,1idj,1,1idn,1,1idp,,1idz,,1iea,1,1iee,6,1ieo,4,1igo,,1igp,1,1igr,5,1igy,,1ih1,,1ih3,2,1ih6,,1ih8,1,1iha,2,1ihd,,1ihe,,1iht,1,1ik5,2,1ik8,7,1ikg,1,1iki,2,1ikl,,1ikm,,1ila,,1ink,,1inl,1,1inn,5,1int,,1inu,,1inv,1,1inx,,1iny,,1inz,1,1io1,,1io2,1,1iun,,1iuo,1,1iuq,3,1iuw,3,1iv0,1,1iv2,,1iv3,1,1ivw,1,1iy8,2,1iyb,7,1iyj,1,1iyl,,1iym,,1iyn,1,1j1n,,1j1o,,1j1p,,1j1q,1,1j1s,7,1j4t,,1j4u,,1j4v,,1j4y,3,1j52,,1j53,4,1jcc,2,1jcf,8,1jco,,1jcp,1,1jjk,,1jjl,4,1jjr,1,1jjv,3,1jjz,,1jk0,,1jk1,,1jk2,,1jk3,,1jo1,2,1jo4,3,1joa,1,1joc,3,1jog,,1jok,,1jpd,9,1jqr,5,1jqx,,1jqy,,1jqz,3,1jrb,,1jrl,5,1jrr,1,1jrt,2,1jt0,5,1jt6,c,1jtj,,1jtk,1,1k4v,,1k4w,6,1k54,5,1k5a,,1k5b,,1k7m,l,1k89,,1k8a,6,1k8h,,1k8i,1,1k8k,,1k8l,1,1kc1,5,1kca,,1kcc,1,1kcf,6,1kcm,,1kcn,,1kei,4,1keo,1,1ker,1,1ket,,1keu,,1kev,,1koj,1,1kol,1,1kow,1,1koy,,1koz,,1kqc,1,1kqe,4,1kqm,1,1kqo,2,1kre,,1ovk,f,1ow0,,1ow7,e,1xr2,b,1xre,2,1xrh,2,1zow,4,1zqo,6,206b,,206f,3,20jz,,20k1,1i,20lr,3,20o4,,20og,1,2ftp,1,2fts,3,2jgg,19,2jhs,m,2jxh,4,2jxp,5,2jxv,7,2jy3,7,2jyd,6,2jze,3,2k3m,2,2lmo,1i,2lob,1d,2lpx,,2lqc,,2lqz,4,2lr5,e,2mtc,6,2mtk,g,2mu3,6,2mub,1,2mue,4,2mxb,,2n1s,6,2nce,,2ne4,3,2nsc,3,2nzi,1,2ok0,6,2on8,6,2pz4,73,2q6l,2,2q7j,,2q98,5,2q9q,1,2qa6,,2qa9,9,2qb1,1k,2qcm,p,2qdd,e,2qe2,,2qen,,2qeq,8,2qf0,3,2qfd,c1,2qrf,4,2qrk,8t,2r0m,7d,2r9c,3j,2rg4,b,2rit,16,2rkc,3,2rm0,7,2rmi,5,2rns,7,2rou,29,2rrg,1a,2rss,9,2rt3,c8,2scg,sd,jny8,v,jnz4,2n,jo1s,3j,jo5c,6n,joc0,2rz",
  "262122424333333393233393339333333333393393b3b3b3b3b333b33b3bb33333b3b3333333b3b33bb3333b33b3bb33333b3bbb333b333b33333b3b3b3b3333b3b33b3bb39333b33b33b3b3b333b333333b3b333333b33b3b3333b3335dc333333b3b3b33323333b3bb3b33b3b3b3333b3333b3b333bb3b33b3b3b3b3b333b333b3323e2244234444444444444444444444444444444444444444443333443443333333b3b3bb33333b353b3b3b3b333b3b333b333333b3bb3b3b3bb3787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878dc333232333333333333333b3b3333bb3b393933b3b33bb3b393b3b3b3333b33b33b3bbb33b333b3333bb3933b3b3b333b3b3b3b3b33b3b3b33b3b3b33b3b33b33b3b3b33bb39b9b3b33b3b33b9333b393b3b33b33b3b3b3333393b3b3b33b39bb3b332333b333dd3b33332333323333333333333333333333344444444a44444434444444444444423232"
), _c = ma(
  /** @type {UnicodeDataEncoding} */
  "1sl,10,1ug,7,1vc,7,1w5,j,1wq,6,1wy,,1x2,3,1y4,1,1y7,,1yo,1,239,j,23u,6,242,1,245,4,261,,26t,j,27e,6,27m,1,27p,4,28s,1,28v,,29d,,2dx,j,2ei,f,2fs,2,2l1,11"
);
function* $c(i) {
  if (i === "")
    return;
  let A = 0, e = i.length, t = null, o = null, r = null, s = [
    0,
    0,
    2
    /* GC_Control */
  ], g = 0, n = !1, a = !1, I = !1, C = !1, c = (
    /** @type number */
    i.codePointAt(A)
  ), B = 0, Q = "";
  for (; ; ) {
    if (Q += i[A++], Zc(c) || (Q += i[A++]), t = o, t === null && (t = eg(c, s), r = t), !a && t === 0 ? a = tg(c) : t === 3 && (I = Xc(c)), A < e)
      c = /** @type {number} */
      i.codePointAt(A), o = eg(c, s);
    else {
      yield {
        segment: Q,
        index: B,
        input: i,
        _catBegin: (
          /** @type {typeof catBefore} */
          r
        ),
        _catEnd: t
      };
      return;
    }
    t === 10 ? g += 1 : (g = 0, o === 14 && (t === 3 || t === 4) ? n = !0 : o === 0 && (C = a && I && (a = tg(c)), I = I && !a)), AB(t, o, g, n, C) && (yield {
      segment: Q,
      index: B,
      input: i,
      _catBegin: (
        /** @type {typeof catBefore} */
        r
      ),
      _catEnd: t
    }, B = A, Q = "", n = !1, C = !1, r = o);
  }
}
function* Vo(i) {
  for (let A of $c(i)) yield A.segment;
}
function eg(i, A) {
  if (i < 127)
    return i >= 32 ? 0 : i === 10 ? 6 : i === 13 ? 1 : 2;
  if (i < A[0] || i > A[1]) {
    let e = Sa(i, Ag);
    if (e < 0)
      return 0;
    let t = Ag[e];
    A[0] = t[0], A[1] = t[1], A[2] = t[2];
  }
  return A[2];
}
function tg(i) {
  return Sa(i, _c) >= 0;
}
function Xc(i) {
  return i === 2381 || i === 2509 || i === 2765 || i === 2893 || i === 3149 || i === 3405;
}
function AB(i, A, e, t, o) {
  return i === 1 && A === 6 ? !1 : i === 1 || i === 2 || i === 6 || A === 1 || A === 2 || A === 6 ? !0 : i === 5 && (A === 5 || A === 7 || A === 8 || A === 13) || (i === 7 || i === 13) && (A === 12 || A === 13) || A === 12 && (i === 8 || i === 12) || A === 3 || A === 14 || A === 11 || i === 9 || A === 0 && o ? !1 : i === 14 && A === 4 ? !t : i === 10 && A === 10 ? e % 2 === 0 : !0;
}
const yr = {
  MAX_RECOMMENDED_TX_SIZE: 100 * 1024
}, Xe = {
  MAX_RETRIES: 1,
  TIMEOUT: 6e4,
  RETRY_DELAY: 3e3,
  MAX_IN_FLIGHT_LOADS_PER_PEER: 1e3
}, eB = {
  INCOMING_MESSAGES_TIME_BUDGET: 50
}, ig = {
  MAX_AGE: 1e3 * 60 * 10,
  // 10 minutes
  INTERVAL: 1e3 * 60 * 5
  // 5 minutes
}, tB = {
  MAX_OUTGOING_MESSAGES_CHUNK_BYTES: 25e3
};
function og(i) {
  return `${i.sessionID}:${i.txIndex}:${i.changeIdx}`;
}
class is extends Ot {
  constructor(A, e) {
    super(A, e), this.type = "coplaintext", this._cachedMapping = /* @__PURE__ */ new WeakMap();
  }
  get mapping() {
    const A = this.entries();
    let e = this._cachedMapping.get(A);
    if (e)
      return e;
    e = {
      opIDbeforeIdx: [],
      opIDafterIdx: [],
      idxAfterOpID: {},
      idxBeforeOpID: {}
    };
    let t = 0;
    for (const o of A) {
      const r = t + 1;
      e.opIDafterIdx[t] = o.opID, e.opIDbeforeIdx[r] = o.opID, e.idxAfterOpID[og(o.opID)] = r, e.idxBeforeOpID[og(o.opID)] = t, t = r;
    }
    return this._cachedMapping.set(A, e), e;
  }
  toString() {
    return this.entries().map((A) => A.value).join("");
  }
  atTime(A) {
    return new is(this.core, A);
  }
  /**
   * Inserts `text` before the character at index `idx`.
   * If idx is 0, inserts at the start of the text.
   *
   * @param idx - The index of the character to insert before
   * @param text - The text to insert
   * @param privacy - Whether the operation should be private or trusting
   * @category 2. Editing
   */
  insertBefore(A, e, t = "private") {
    const o = Array.from(Vo(e));
    if (A === 0) {
      const r = o[0];
      r && this.prepend(r, 0, t), o.length > 1 && this.appendChars(o.slice(1), 0, t);
    } else
      this.appendChars(o, A - 1, t);
  }
  appendChars(A, e, t = "private") {
    const o = iB(A);
    for (const r of o)
      this.appendItems(r, e, t), e += r.length;
  }
  /**
   * Inserts `text` after the character at index `idx`.
   *
   * @param idx - The index of the character to insert after
   * @param text - The text to insert
   * @param privacy - Whether the operation should be private or trusting
   * @category 2. Editing
   */
  insertAfter(A, e, t = "private") {
    const o = Array.from(Vo(e));
    A >= this.entries().length ? this.appendChars(o, A - 1, t) : this.appendChars(o, A, t);
  }
  deleteRange({ from: A, to: e }, t = "private") {
    const o = [];
    for (let r = A; r < e; ) {
      const s = this.mapping.opIDafterIdx[r];
      if (!s)
        throw new Error("Invalid idx to delete " + r);
      o.push({
        op: "del",
        insertion: s
      });
      let g = r + 1;
      for (; !this.mapping.opIDbeforeIdx[g] && g < e; )
        g++;
      r = g;
    }
    this.core.makeTransaction(o, t), this.processNewTransactions();
  }
  /** @internal Helper method to split text into graphemes */
  toGraphemes(A) {
    return [...Vo(A)];
  }
  /** @internal Helper method to join graphemes into a string */
  fromGraphemes(A) {
    return A.join("");
  }
}
function iB(i) {
  const A = Math.ceil(yr.MAX_RECOMMENDED_TX_SIZE / 200), e = [];
  for (let t = 0; t < i.length; t += A)
    e.push(i.slice(t, t + A));
  return e;
}
function oB(i, A) {
  return i.verified.header.type === "comap" ? i.verified.header.ruleset.type === "group" ? i.verified.header.meta?.type === "account" && !A?.ignorePrivateTransactions ? new ts(i) : new es(i, A) : new As(i) : i.verified.header.type === "coplaintext" ? new is(i) : i.verified.header.type === "colist" ? new Ot(i) : i.verified.header.type === "costream" ? i.verified.header.meta && i.verified.header.meta.type === "binary" ? new fa(i) : new ha(i) : new lc(i);
}
function os(i, A = /* @__PURE__ */ new Set()) {
  return i.ruleset.type === "ownedByGroup" && A.add(i.ruleset.group), i.meta?.source && A.add(i.meta.source), A;
}
function Na(i, A) {
  for (const e of i) {
    const t = TA(e);
    Xr(t) && A.add(t);
  }
}
function rs(i, A = /* @__PURE__ */ new Set()) {
  for (const e of i) {
    if (e.privacy !== "trusting")
      continue;
    const t = gB(e.changes);
    for (const o of t)
      if (o && typeof o == "object" && "op" in o && o.op === "set" && "key" in o && o.key) {
        const r = Gc(o.key);
        r && A.add(r);
      }
  }
  return A;
}
function rB(i, A, e, t) {
  const o = /* @__PURE__ */ new Set();
  if (os(A, o), Na(e, o), A.ruleset.type === "group")
    for (const r of t)
      rs(r, o);
  return o.delete(i), o;
}
function sB(i, A) {
  const e = /* @__PURE__ */ new Set();
  A.header && os(A.header, e);
  const t = Object.keys(A.new);
  if (Na(t, e), (i.verified?.header ?? A.header)?.ruleset.type === "group")
    for (const { newTransactions: r } of Object.values(A.new))
      rs(r, e);
  return e.delete(i.id), e;
}
function gB(i) {
  try {
    return no(i);
  } catch {
    return [];
  }
}
function ve(i) {
  return {
    id: i,
    header: !1,
    sessions: {}
  };
}
function Wo(i) {
  return {
    id: i.id,
    header: i.header,
    sessions: i.sessions
  };
}
function zo(i, A) {
  return it(i.sessions, A.sessions), A.header && !i.header && (i.header = !0), i;
}
function it(i, A) {
  for (const [e, t] of Object.entries(A)) {
    const o = i[e] || 0;
    t > o && (i[e] = t);
  }
  return i;
}
function Zo(i, A, e) {
  i[A] = e;
}
function rg(i, A, e) {
  i[A] = Math.max(i[A] || 0, e);
}
function Se(i) {
  return {
    id: i.id,
    header: i.header,
    sessions: { ...i.sessions }
  };
}
function Ma(i, A) {
  for (const [e, t] of Object.entries(i)) {
    const o = A[e] ?? 0;
    if (t !== o)
      return !1;
  }
  return !0;
}
function Dr(i, A) {
  for (const [e, t] of Object.entries(i)) {
    const o = A[e] ?? 0;
    if (t > o)
      return !1;
  }
  return !0;
}
function nB(i, A) {
  return !A || !A.header && i.header ? !1 : Dr(i.sessions, A.sessions);
}
function ka(i, A) {
  const e = {};
  for (const [t, o] of Object.entries(i)) {
    const r = A[t] ?? 0;
    o > r && (e[t] = o);
  }
  return e;
}
const OA = {
  HIGH: 0,
  MEDIUM: 3,
  LOW: 6
};
function aB(i) {
  return typeof i == "boolean" || !i ? OA.MEDIUM : i.meta?.type === "account" || i.ruleset.type === "group" ? OA.HIGH : i.type === "costream" && i.meta?.type === "binary" ? OA.LOW : OA.MEDIUM;
}
function kt(i, A, e = !0) {
  return {
    action: "content",
    id: i,
    header: e ? A : void 0,
    priority: aB(A),
    new: {}
  };
}
function _o(i, A, e, t, o) {
  const r = i.new[e];
  r ? (r.newTransactions.push(A), r.lastSignature = t) : i.new[e] = {
    after: o,
    newTransactions: [A],
    lastSignature: t
  };
}
function ho(i) {
  return i.privacy === "private" ? i.encryptedChanges.length : i.changes.length;
}
function Io(i, A) {
  return A === void 0 ? i > yr.MAX_RECOMMENDED_TX_SIZE : i + A > yr.MAX_RECOMMENDED_TX_SIZE;
}
function Ai(i) {
  const A = ve(i.id);
  A.header = !!i.header;
  for (const [e, t] of Object.entries(i.new))
    A.sessions[e] = t.after + t.newTransactions.length;
  return A;
}
function IB(i) {
  return Object.values(i.new).reduce((A, e) => A + e.newTransactions.reduce((t, o) => t + ho(o), 0), 0);
}
function $o(i) {
  return Object.entries(i.new).map(([A, e]) => `Session: ${A} After: ${e.after} New: ${e.newTransactions.length}`);
}
function CB(i, A, e) {
  const t = A.sessions[e] ?? 0, o = i.after;
  if (t < o)
    return;
  const r = t - o;
  return i.newTransactions.slice(r);
}
function cB(i) {
  return Object.entries(i.new);
}
class fo {
  constructor(A, e, t) {
    this.id = A, this.crypto = e, this.isDeleted = !1, this.sessions = /* @__PURE__ */ new Map(), this.knownState = { id: this.id, header: !0, sessions: {} }, t && (this.streamingKnownState = { ...t }, this.knownStateWithStreaming = {
      id: this.id,
      header: !0,
      sessions: { ...t }
    });
  }
  markAsDeleted() {
    this.isDeleted = !0, this.knownState = { id: this.id, header: !0, sessions: {} }, this.knownStateWithStreaming = void 0, this.streamingKnownState = void 0, this.invalidateKnownStateCache();
    for (const [A, e] of this.sessions.entries())
      Ke(A) && (this.knownState.sessions[A] = e.transactions.length);
  }
  setStreamingKnownState(A) {
    if (this.isDeleted || Dr(A, this.knownState.sessions))
      return;
    const e = ka(A, this.knownState.sessions);
    this.streamingKnownState ? it(this.streamingKnownState, e) : this.streamingKnownState = e, this.knownStateWithStreaming || (this.knownStateWithStreaming = Se(this.knownState)), it(this.knownStateWithStreaming.sessions, e);
  }
  invalidateKnownStateCache() {
    this.immutableKnownState = void 0, this.immutableKnownStateWithStreaming = void 0;
  }
  getImmutableKnownState() {
    return this.immutableKnownState || (this.immutableKnownState = Se(this.knownState)), this.immutableKnownState;
  }
  getImmutableKnownStateWithStreaming() {
    return this.knownStateWithStreaming ? (this.immutableKnownStateWithStreaming || (this.immutableKnownStateWithStreaming = Se(this.knownStateWithStreaming)), this.immutableKnownStateWithStreaming) : this.getImmutableKnownState();
  }
  get(A) {
    return this.sessions.get(A);
  }
  getOrCreateSessionLog(A, e) {
    let t = this.sessions.get(A);
    return t || (t = {
      signerID: e,
      impl: this.crypto.createSessionLog(this.id, A, e),
      transactions: [],
      lastSignature: void 0,
      signatureAfter: {},
      txSizeSinceLastInbetweenSignature: 0,
      sessionID: A
    }, this.sessions.set(A, t)), t;
  }
  addTransaction(A, e, t, o, r = !1) {
    if (this.isDeleted && !Ke(A))
      throw new Error("Cannot add transactions to a deleted coValue");
    const s = this.getOrCreateSessionLog(A, e);
    s.impl.tryAdd(t, o, r), this.addTransactionsToJsLog(s, t, o);
  }
  makeNewPrivateTransaction(A, e, t, o, r, s, g) {
    if (this.isDeleted)
      throw new Error("Cannot make new private transaction on a deleted coValue");
    const n = this.getOrCreateSessionLog(A, e.currentSignerID()), a = n.impl.addNewPrivateTransaction(e, t, o, r, g, s);
    return this.addTransactionsToJsLog(n, [a.transaction], a.signature), a;
  }
  makeNewTrustingTransaction(A, e, t, o, r) {
    if (this.isDeleted)
      throw new Error("Cannot make new trusting transaction on a deleted coValue");
    const s = this.getOrCreateSessionLog(A, e.currentSignerID()), g = s.impl.addNewTrustingTransaction(e, t, r, o);
    return this.addTransactionsToJsLog(s, [g.transaction], g.signature), g;
  }
  addTransactionsToJsLog(A, e, t) {
    for (const r of e)
      A.transactions.push(r);
    A.lastSignature = t, A.txSizeSinceLastInbetweenSignature += e.reduce((r, s) => r + (s.privacy === "private" ? s.encryptedChanges.length : s.changes.length), 0);
    const o = A.transactions.length;
    Io(A.txSizeSinceLastInbetweenSignature) && (A.signatureAfter[o - 1] = t, A.txSizeSinceLastInbetweenSignature = 0), rg(this.knownState.sessions, A.sessionID, o), this.streamingKnownState && Dr(this.streamingKnownState, this.knownState.sessions) && (this.streamingKnownState = void 0, this.knownStateWithStreaming = void 0), this.knownStateWithStreaming && rg(this.knownStateWithStreaming.sessions, A.sessionID, o), this.invalidateKnownStateCache();
  }
  decryptTransaction(A, e, t) {
    const o = this.sessions.get(A);
    if (!o)
      return;
    const r = o.impl.decryptNextTransactionChangesJson(e, t);
    if (r)
      return no(r);
  }
  decryptTransactionMeta(A, e, t) {
    const o = this.sessions.get(A);
    if (!o?.transactions[e]?.meta)
      return;
    const r = o.impl.decryptNextTransactionMetaJson(e, t);
    if (r)
      return no(r);
  }
  get size() {
    return this.sessions.size;
  }
  entries() {
    return this.sessions.entries();
  }
  values() {
    return this.sessions.values();
  }
  keys() {
    return this.sessions.keys();
  }
  clone() {
    const A = new fo(this.id, this.crypto);
    for (const [e, t] of this.sessions)
      A.sessions.set(e, {
        impl: t.impl.clone(),
        transactions: t.transactions.slice(),
        lastSignature: t.lastSignature,
        signatureAfter: { ...t.signatureAfter },
        txSizeSinceLastInbetweenSignature: t.txSizeSinceLastInbetweenSignature,
        signerID: t.signerID,
        sessionID: e
      });
    return A.streamingKnownState = this.streamingKnownState ? { ...this.streamingKnownState } : void 0, A.knownState = Se(this.knownState), A.knownStateWithStreaming = this.knownStateWithStreaming ? Se(this.knownStateWithStreaming) : void 0, A;
  }
}
class ss {
  constructor(A, e, t, o) {
    this.isDeleted = !1, this.id = A, this.crypto = e, this.header = t, this.sessions = o ?? new fo(A, e), this.branchSourceId = t.meta?.source, this.branchName = t.meta?.branch;
  }
  clone() {
    return new ss(this.id, this.crypto, this.header, this.sessions.clone());
  }
  markAsDeleted() {
    this.isDeleted = !0, this.sessions.markAsDeleted();
  }
  tryAddTransactions(A, e, t, o, r = !1) {
    this.sessions.addTransaction(A, e, t, o, r);
  }
  makeNewTrustingTransaction(A, e, t, o, r) {
    return this.sessions.makeNewTrustingTransaction(A, e, t, o, r);
  }
  makeNewPrivateTransaction(A, e, t, o, r, s, g) {
    return this.sessions.makeNewPrivateTransaction(A, e, t, o, r, s, g);
  }
  getLastSignatureCheckpoint(A) {
    const e = this.sessions.get(A);
    return e?.signatureAfter ? Object.keys(e.signatureAfter).reduce((t, o) => Math.max(t, parseInt(o)), -1) : -1;
  }
  setStreamingKnownState(A) {
    this.sessions.setStreamingKnownState(A);
  }
  newContentSince(A) {
    let e = kt(this.id, this.header, !1);
    const t = [e];
    let o = 0;
    const r = () => {
      e = kt(this.id, this.header, !1), t.push(e), o = 0;
    }, s = (C) => {
      const c = e.new[C];
      if (!c)
        throw new Error("Session content not found", {
          cause: {
            sessionID: C,
            currentPiece: e
          }
        });
      delete e.new[C];
      const B = kt(this.id, this.header, !1);
      B.new[C] = c, t.splice(t.length - 1, 0, B);
    }, g = A?.sessions;
    for (const [C, c] of this.sessions.sessions) {
      if (this.isDeleted && !Ke(C))
        continue;
      const B = g?.[C] ?? 0;
      let Q = 0;
      for (let f = B; f < c.transactions.length; f++) {
        const l = f === c.transactions.length - 1, d = c.transactions[f];
        Q += ho(d);
        const u = c.signatureAfter[f];
        if (u)
          _o(e, d, C, u, f), s(C), Q = 0;
        else if (l) {
          if (!c.lastSignature)
            throw new Error("All the SessionLogs sent must have a lastSignature", {
              cause: c
            });
          _o(e, d, C, c.lastSignature, f), Io(Q) ? (Xo(C, e), s(C)) : Io(o, Q) ? (Xo(C, e), r()) : o += Q;
        } else
          _o(e, d, C, void 0, f);
      }
      Xo(C, e);
    }
    const n = t[0];
    if (!n)
      throw new Error("First piece not found", {
        cause: t
      });
    !A?.header && (n.header = this.header);
    const I = t.filter((C) => C.header || Object.keys(C.new).length > 0);
    if ((I.length > 1 || this.isStreaming()) && (A ? n.expectContentUntil = ka(this.knownStateWithStreaming().sessions, A.sessions) : n.expectContentUntil = {
      ...this.knownStateWithStreaming().sessions
    }), I.length !== 0)
      return I;
  }
  knownState() {
    return this.sessions.knownState;
  }
  knownStateWithStreaming() {
    return this.sessions.knownStateWithStreaming ?? this.knownState();
  }
  immutableKnownState() {
    return this.sessions.getImmutableKnownState();
  }
  immutableKnownStateWithStreaming() {
    return this.sessions.getImmutableKnownStateWithStreaming();
  }
  isStreaming() {
    return !!this.sessions.knownStateWithStreaming;
  }
  decryptTransaction(A, e, t) {
    return this.sessions.decryptTransaction(A, e, t);
  }
  decryptTransactionMeta(A, e, t) {
    return this.sessions.decryptTransactionMeta(A, e, t);
  }
}
function Xo(i, A) {
  if (A.new[i] && !A.new[i].lastSignature)
    throw new Error("The SessionContent sent must have a lastSignature", {
      cause: A.new[i]
    });
}
function Ga({ type: i, branchName: A, ownerId: e, sourceId: t }) {
  return {
    type: i,
    // Branch name and source id are stored in the meta field
    // and used to generate the unique id for the branch
    meta: {
      branch: A,
      source: t
    },
    ruleset: {
      type: "ownedByGroup",
      // The owner is part of the id generation, making it possible to have multiple branches with the same name
      // but different owners
      group: e
    },
    // The meta is enough to have reproducible unique id for the branch
    uniqueness: ""
  };
}
function Fa(i) {
  return i.verified?.header.ruleset.type === "ownedByGroup";
}
function BB(i, A, e) {
  if (!i.verified)
    throw new Error("CoValueCore: getBranchId called on coValue without verified state");
  const t = e ?? gs(i);
  if (!t)
    return i.id;
  const o = Ga({
    type: i.verified.header.type,
    branchName: A,
    ownerId: t,
    sourceId: i.id
  });
  return Ut(o, i.node.crypto);
}
function gs(i) {
  if (!i.verified)
    throw new Error("CoValueCore: getBranchOwnerId called on coValue without verified state");
  const A = i.verified.header;
  if (A.ruleset.type === "ownedByGroup")
    return A.ruleset.group;
}
function QB(i, A, e) {
  if (!i.verified)
    throw new Error("CoValueCore: createBranch called on coValue without verified state");
  const t = e ?? gs(i);
  if (!t)
    return i;
  const o = i.safeGetGroup()?.myRole();
  if (!o || o === "reader" && !e)
    return AA.warn("Trying to create a branch without enough access rights, returning the source coValue"), i;
  const r = o === "reader" ? "trusting" : "private", s = Ga({
    type: i.verified.header.type,
    branchName: A,
    ownerId: t,
    sourceId: i.id
  }), g = i.node.createCoValue(s), n = { ...i.knownState().sessions };
  return g.makeTransaction([], "private", {
    from: n
  }), i.makeTransaction([], r, {
    branch: A,
    ownerId: e
  }), g;
}
function Ra(i) {
  if (!i.verified)
    return;
  const A = i.getCurrentBranchSourceId();
  if (!A)
    return;
  const e = i.node.getCoValue(A);
  if (e.isAvailable())
    return e;
}
function EB(i) {
  if (!i.verified)
    throw new Error("CoValueCore: mergeBranch called on coValue without verified state");
  if (!Fa(i))
    return i;
  const A = Ra(i);
  if (!A)
    throw new Error("CoValueCore: unable to find source branch");
  let e = {};
  for (const C of A.getMergeCommits())
    C.branch === i.id && it(e, C.merged);
  const t = i.getValidTransactions({
    from: e,
    ignorePrivateTransactions: !1,
    skipBranchSource: !0
  }).filter((C) => C.changes.length > 0);
  if (t.length === 0)
    return A;
  let o, r, s = 0;
  const g = Date.now();
  for (const C of t) {
    const c = {
      mi: C.txID.txIndex
    };
    C.madeAt !== s && (c.t = g - C.madeAt), o !== C.txID.sessionID && (c.s = C.txID.sessionID), r !== C.txID.branch && (c.b = C.txID.branch), A.makeTransaction(C.changes, C.tx.privacy, c, g), o = C.txID.sessionID, r = C.txID.branch, s = C.madeAt;
  }
  const n = i.knownState().sessions, a = e, I = {};
  for (const [C, c] of Object.entries(n))
    (a[C] ?? 0) < c && (I[C] = c);
  return A.makeTransaction([], "private", {
    merged: I,
    branch: i.id
  }), A;
}
function lB(i, A) {
  if (!A.isValid || A.tx.privacy === "trusting")
    return;
  const e = !A.changes, t = !A.meta && A.tx.meta;
  if (!e && !t)
    return;
  const o = i.getReadKey(A.tx.keyUsed);
  if (o) {
    if (e) {
      const r = i.verified.decryptTransaction(A.txID.sessionID, A.txID.txIndex, o);
      r && (A.changes = r);
    }
    if (t) {
      const r = i.verified.decryptTransactionMeta(A.txID.sessionID, A.txID.txIndex, o);
      r && (A.meta = r);
    }
  }
}
var LA = function(i, A, e, t) {
  if (e === "a" && !t) throw new TypeError("Private accessor was defined without a getter");
  if (typeof A == "function" ? i !== A || !t : !A.has(i)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return e === "m" ? t : e === "a" ? t.call(i) : t ? t.value : A.get(i);
}, qA = function(i, A, e, t, o) {
  if (t === "m") throw new TypeError("Private method is not writable");
  if (t === "a" && !o) throw new TypeError("Private accessor was defined without a setter");
  if (typeof A == "function" ? i !== A || !o : !A.has(i)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return t === "a" ? o.call(i, e) : o ? o.value = e : A.set(i, e), e;
}, Me, pe, ye, ba, mr, sg, gg, pt, yt, Dt;
function uB(i) {
  if (typeof i == "number" && !Number.isInteger(i))
    return {
      isOk: !1,
      message: "Uniqueness cannot be a non-integer number, got " + i
    };
  if (Array.isArray(i))
    return {
      isOk: !1,
      message: "Uniqueness cannot be an array, got " + i
    };
  if (typeof i == "object" && i !== null) {
    for (let [A, e] of Object.entries(i))
      if (typeof e != "string")
        return {
          isOk: !1,
          message: "Uniqueness object values must be a string, got " + e + " for key " + A
        };
  }
  return { isOk: !0 };
}
function Ut(i, A) {
  return `co_z${A.shortHash(i).slice(11)}`;
}
class dB {
  constructor(A, e, t, o, r, s, g, n) {
    this.isValidated = !1, this.isValid = !1, this.validationErrorMessage = void 0, this.dispatchTransaction = n, this.author = TA(e);
    const a = r ? {
      sessionID: e,
      txIndex: t,
      branch: r
    } : {
      sessionID: e,
      txIndex: t
    };
    this.coValueId = A, this.currentTxID = a, this.sourceTxID = void 0, this.tx = o, this.currentMadeAt = o.madeAt, this.sourceTxMadeAt = void 0, this.previous = g, s ? (this.changes = s.changes, this.meta = s.meta) : this.tx.privacy === "trusting" && (this.changes = pr(this.tx.changes), this.tx.meta && (this.meta = pr(this.tx.meta)));
  }
  // The TxID that refers to the current position in the session map
  // If this is a merged transaction, the txID is the TxID of the merged transaction
  get txID() {
    return this.sourceTxID ?? this.currentTxID;
  }
  // The madeAt that refers to the time when the transaction was made
  // If this is a merged transaction, the madeAt is the time when the transaction has been made in the branch
  get madeAt() {
    return this.sourceTxMadeAt ?? this.currentMadeAt;
  }
  isValidTransactionWithChanges() {
    return !!(this.isValid && this.changes);
  }
  markValid() {
    this.isValid = !0, this.validationErrorMessage = void 0, this.isValidated || (this.isValidated = !0, this.dispatchTransaction(this));
  }
  markInvalid(A, e) {
    this.isValidated = !0, this.isValid = !1, this.validationErrorMessage = A;
  }
}
class ng {
  /** Holds the fundamental syncable content of a CoValue,
   * consisting of the header (verified by hash -> RawCoID)
   * and the sessions (verified by signature).
   *
   * It does not do any *validation* or *decryption* and as such doesn't
   * depend on other CoValues or the LocalNode.
   *
   * `CoValueCore.verified` may be null when a CoValue is requested to be
   * loaded but no content has been received from storage or peers yet.
   * In this case, it acts as a centralised entry to keep track of peer loading
   * state and to subscribe to its content when it does become available. */
  get verified() {
    return this._verified;
  }
  constructor(A, e) {
    Me.add(this), this.isDeleted = !1, this.loadingStatuses = /* @__PURE__ */ new Map(), pe.set(this, void 0), ye.set(this, void 0), this.listeners = /* @__PURE__ */ new Set(), this.missingDependencies = /* @__PURE__ */ new Set(), this.newContentQueue = [], pt.set(this, !1), yt.set(this, !1), Dt.set(this, !1), this.mergeCommits = [], this.branches = [], this.earliestTxMadeAt = Number.MAX_SAFE_INTEGER, this.latestTxMadeAt = 0, this.verifiedTransactions = [], this.toValidateTransactions = [], this.toDecryptTransactions = [], this.toParseMetaTransactions = [], this.toProcessTransactions = [], this.verifiedTransactionsKnownSessions = {}, this.lastVerifiedTransactionBySessionID = {}, this.parsingCache = /* @__PURE__ */ new Map(), this.dispatchTransaction = (t) => {
      if (!t.isValidated) {
        this.toValidateTransactions.push(t);
        return;
      }
      t.changes ? this.toProcessTransactions.push(t) : this.toDecryptTransactions.push(t), t.meta && this.toParseMetaTransactions.push(t);
    }, this.dependencies = /* @__PURE__ */ new Set(), this.incompleteDependencies = /* @__PURE__ */ new Set(), this.dependant = /* @__PURE__ */ new Set(), this.readKeyCache = /* @__PURE__ */ new Map(), this.crypto = e.crypto, this.id = A, this._verified = null, this.node = e, this.counter = ae.getMeter("cojson").createUpDownCounter("jazz.covalues.loaded", {
      description: "The number of covalues in the system",
      unit: "covalue",
      valueType: WA.INT
    }), this.updateCounter(null);
  }
  get loadingState() {
    if (this.verified)
      return "available";
    for (const A of this.loadingStatuses.values())
      if (A.type === "pending")
        return "loading";
    if (LA(this, pe, "f"))
      return LA(this, pe, "f");
    if (this.loadingStatuses.size === 0)
      return "unknown";
    for (const A of this.loadingStatuses.values())
      if (A.type === "unknown")
        return "unknown";
    return "unavailable";
  }
  hasMissingDependencies() {
    return this.missingDependencies.size > 0;
  }
  isAvailable() {
    return this.hasVerifiedContent();
  }
  isCompletelyDownloaded() {
    return !(!this.hasVerifiedContent() || this.isStreaming() || this.incompleteDependencies.size > 0);
  }
  isStreaming() {
    return this.verified?.isStreaming() ?? !1;
  }
  hasVerifiedContent() {
    return !!this.verified;
  }
  /**
   * Returns the CoValue data as NewContentMessage objects, excluding the transactions that are part of the given known state.
   *
   * Used to serialize the CoValue data to send it to peers and storage.
   */
  newContentSince(A) {
    return this.verified?.newContentSince(A);
  }
  isErroredInPeer(A) {
    return this.getLoadingStateForPeer(A) === "errored";
  }
  getErroredInPeerError(A) {
    const e = this.loadingStatuses.get(A);
    if (e?.type === "errored")
      return e.error;
  }
  waitFor(A) {
    const { predicate: e, onSuccess: t } = A;
    this.subscribe((o, r) => {
      e(o) && (r(), t(o));
    }, !0);
  }
  waitForAsync(A) {
    return new Promise((e) => {
      this.waitFor({ predicate: A, onSuccess: e });
    });
  }
  waitForAvailableOrUnavailable() {
    return this.waitForAsync((A) => A.isAvailable() || A.loadingState === "unavailable");
  }
  waitForAvailable() {
    return this.waitForAsync((A) => A.isAvailable());
  }
  waitForFullStreaming() {
    return this.waitForAsync((A) => A.isAvailable() && !A.isStreaming());
  }
  getLoadingStateForPeer(A) {
    return this.loadingStatuses.get(A)?.type ?? "unknown";
  }
  updateCounter(A) {
    const e = this.loadingState;
    A !== e && (A && this.counter.add(-1, { state: A }), this.counter.add(1, { state: e }));
  }
  /**
   * Removes the CoValue content from memory but keeps a shell with cached knownState.
   * This enables accurate LOAD requests during peer reconciliation.
   *
   * @returns true if the coValue was successfully unmounted, false otherwise
   */
  unmount() {
    return this.node.internalUnmountCoValue(this.id);
  }
  /**
   * Decrements the counter for the current loading state.
   * Used during unmount to properly track state transitions.
   * @internal
   */
  decrementLoadingStateCounter() {
    this.counter.add(-1, { state: this.loadingState });
  }
  markNotFoundInPeer(A) {
    const e = this.loadingState;
    this.loadingStatuses.set(A, { type: "unavailable" }), this.updateCounter(e), this.scheduleNotifyUpdate();
  }
  markFoundInPeer(A, e) {
    this.loadingStatuses.set(A, { type: "available" }), this.updateCounter(e), this.scheduleNotifyUpdate();
  }
  /**
   * Clean up cached state when CoValue becomes available.
   * Called after the CoValue transitions from garbageCollected/onlyKnownState to available.
   */
  cleanupLastKnownState() {
    qA(this, pe, void 0, "f"), qA(this, ye, void 0, "f");
  }
  /**
   * Initialize this CoValueCore as a garbageCollected shell.
   * Called when creating a replacement CoValueCore after unmounting.
   */
  setGarbageCollectedState(A) {
    if (!this.node.storage)
      return;
    const e = this.loadingState;
    qA(this, pe, "garbageCollected", "f"), qA(this, ye, A, "f"), this.updateCounter(e);
  }
  isCircularDependency(A) {
    if (A.id === this.id)
      return !0;
    const e = /* @__PURE__ */ new Set(), t = [A];
    for (; t.length > 0; ) {
      const o = t.pop();
      if (!o)
        return !1;
      e.add(o.id);
      for (const r of o.dependencies) {
        if (r === this.id)
          return !0;
        e.has(r) || t.push(this.node.getCoValue(r));
      }
    }
    return !1;
  }
  /**
   * Add a new content to the queue and handle it when the dependencies are available
   */
  addNewContentToQueue(A, e) {
    const t = this.newContentQueue.length > 0;
    this.newContentQueue.push({ msg: A, from: e }), !t && this.waitFor({
      predicate: (o) => !o.hasMissingDependencies(),
      onSuccess: () => {
        const o = this.newContentQueue;
        this.newContentQueue = [];
        for (const { msg: r, from: s } of o)
          this.node.syncManager.handleNewContent(r, s);
      }
    });
  }
  addDependencyFromHeader(A) {
    for (const e of os(A))
      this.addDependency(e);
  }
  provideHeader(A, e, t) {
    if (!t) {
      const o = uB(A.uniqueness);
      if (!o.isOk)
        return AA.error("Invalid uniqueness", {
          header: A,
          errorMessage: o.message
        }), !1;
      const r = Ut(A, this.node.crypto);
      if (this.id !== r)
        return !1;
    }
    if (this.addDependencyFromHeader(A), this._verified?.sessions.size)
      throw new Error("CoValueCore: provideHeader called on coValue with verified sessions present!");
    return this._verified = new ss(this.id, this.node.crypto, A, new fo(this.id, this.node.crypto, e)), this.isAvailable() && this.cleanupLastKnownState(), !0;
  }
  markErrored(A, e) {
    const t = this.loadingState;
    this.loadingStatuses.set(A, { type: "errored", error: e }), this.updateCounter(t), this.scheduleNotifyUpdate();
  }
  markPending(A) {
    const e = this.loadingState;
    this.loadingStatuses.set(A, { type: "pending" }), this.updateCounter(e), this.scheduleNotifyUpdate();
  }
  contentInClonedNodeWithDifferentAccount(A) {
    return this.node.loadCoValueAsDifferentAgent(this.id, A.agentSecret, A.id).then((e) => e.getCurrentContent());
  }
  /**
   * Returns the known state considering the known state of the streaming source
   *
   * Used to correctly manage the content & subscriptions during the content streaming process
   */
  knownStateWithStreaming() {
    return this.verified ? this.verified.immutableKnownStateWithStreaming() : this.knownState();
  }
  /**
   * Returns the known state of the CoValue
   *
   * The return value identity is going to be stable as long as the CoValue is not modified.
   *
   * On change the knownState is invalidated and a new object is returned.
   *
   * For garbageCollected/onlyKnownState CoValues, returns the cached knownState.
   */
  knownState() {
    return this.verified ? this.verified.immutableKnownState() : LA(this, ye, "f") ? LA(this, ye, "f") : ve(this.id);
  }
  /**
   * Returns a known state message to signal to the peer that the coValue doesn't need to be synced anymore
   *
   * Implemented to be backward compatible with clients that don't support deleted coValues
   */
  stopSyncingKnownStateMessage(A) {
    if (!A)
      return {
        action: "known",
        ...this.knownState()
      };
    const e = Se(this.knownState());
    return it(e.sessions, A.sessions), {
      action: "known",
      ...e
    };
  }
  get meta() {
    return this.verified?.header.meta ?? null;
  }
  nextTransactionID() {
    if (!this.verified)
      throw new Error("CoValueCore: nextTransactionID called on coValue without verified state");
    const A = this.verified.header.meta?.type === "account" ? this.node.currentSessionID.replace(this.node.getCurrentAgent().id, this.node.getCurrentAgent().currentAgentID()) : this.node.currentSessionID;
    return {
      sessionID: A,
      txIndex: this.verified.sessions.get(A)?.transactions.length || 0
    };
  }
  addDependenciesFromContentMessage(A) {
    const e = sB(this, A);
    for (const t of e)
      this.addDependency(t);
  }
  /**
   * Apply new transactions that were not generated by the current node to the CoValue
   */
  tryAddTransactions(A, e, t, o = !1) {
    if (e.length === 0)
      return;
    let r;
    if (this.isDeleted && !Ke(A))
      return {
        type: "CoValueDeleted",
        id: this.id,
        error: new Error("Cannot add transactions to a deleted coValue")
      };
    if (!o) {
      const g = this.node.resolveAccountAgent(TA(A), "Expected to know signer of transaction");
      if (g.error || !g.value)
        return {
          type: "ResolveAccountAgentError",
          id: this.id,
          error: g.error
        };
      r = this.crypto.getAgentSignerID(g.value);
    }
    if (!this.verified)
      return {
        type: "TriedToAddTransactionsWithoutVerifiedState",
        id: this.id,
        error: void 0
      };
    const s = LA(this, Me, "m", ba).call(this, A, e, o);
    if (s.err)
      return s.err;
    try {
      this.verified.tryAddTransactions(A, r, e, t, o), s.value && LA(this, Me, "m", mr).call(this), this.processNewTransactions(), this.scheduleNotifyUpdate(), this.invalidateDependants();
    } catch (g) {
      return { type: "InvalidSignature", id: this.id, error: g };
    }
  }
  notifyDependants() {
    if (this.isGroup())
      for (const A of this.dependant)
        this.node.getCoValue(A).scheduleNotifyUpdate(), this.node.getCoValue(A).notifyDependants();
  }
  invalidateDependants() {
    if (this.isGroup())
      for (const A of this.dependant)
        this.node.getCoValue(A).resetParsedTransactions(), this.node.getCoValue(A).invalidateDependants();
  }
  processNewTransactions() {
    this._cachedContent && this._cachedContent.processNewTransactions();
  }
  scheduleNotifyUpdate() {
    this.listeners.size !== 0 && (qA(this, yt, !0, "f"), LA(this, pt, "f") || (qA(this, pt, !0, "f"), queueMicrotask(() => {
      qA(this, pt, !1, "f"), LA(this, yt, "f") && this.notifyUpdate();
    })));
  }
  pauseNotifyUpdate() {
    qA(this, Dt, !0, "f");
  }
  resumeNotifyUpdate() {
    qA(this, Dt, !1, "f"), this.notifyUpdate();
  }
  notifyUpdate() {
    if (!(this.listeners.size === 0 || LA(this, Dt, "f"))) {
      qA(this, yt, !1, "f");
      for (const A of this.listeners)
        try {
          A(this, () => {
            this.listeners.delete(A);
          });
        } catch (e) {
          AA.error("Error in listener for coValue " + this.id, { err: e });
        }
    }
  }
  subscribe(A, e = !0) {
    return this.listeners.add(A), e && A(this, () => {
      this.listeners.delete(A);
    }), () => {
      this.listeners.delete(A);
    };
  }
  validateDeletePermissions() {
    if (!this.verified)
      return {
        ok: !1,
        reason: "CannotVerifyPermissions",
        message: "Cannot verify delete permissions without verified state"
      };
    if (this.isGroupOrAccount())
      return {
        ok: !1,
        reason: "CoValueNotDeletable",
        message: "Cannot delete Group or Account coValues"
      };
    const A = this.safeGetGroup();
    return A ? A.myRole() !== "admin" ? {
      ok: !1,
      reason: "NotAdmin",
      message: "The current account lacks admin permissions to delete this coValue"
    } : { ok: !0 } : {
      ok: !1,
      reason: "CannotVerifyPermissions",
      message: "Cannot verify delete permissions for coValues not owned by a group"
    };
  }
  /**
   * Creates a delete marker transaction for this CoValue and sets the coValue as deleted
   *
   * Constraints:
   * - Account and Group CoValues cannot be deleted.
   * - Only admins can delete a coValue.
   */
  deleteCoValue() {
    if (this.isDeleted)
      return;
    const A = this.validateDeletePermissions();
    if (!A.ok)
      throw new Error(A.message);
    this.makeTransaction(
      [],
      // Empty changes array
      "trusting",
      // Unencrypted
      { deleted: this.id }
    );
  }
  /**
   * Creates a new transaction with local changes and syncs it to all peers
   */
  makeTransaction(A, e, t, o) {
    if (!this.verified)
      throw new Error("CoValueCore: makeTransaction called on coValue without verified state");
    const r = !!t?.deleted;
    if (this.isDeleted && !r)
      return AA.error("Cannot make transaction on a deleted coValue", {
        id: this.id
      }), !1;
    let s = this.verified.header.meta?.type === "account" ? this.node.currentSessionID.replace(this.node.getCurrentAgent().id, this.node.getCurrentAgent().currentAgentID()) : this.node.currentSessionID;
    r && (s = this.crypto.newDeleteSessionID(this.node.getCurrentAccountOrAgentID()));
    const g = this.node.getCurrentAgent();
    let n;
    const a = this.knownState();
    if (e === "private") {
      const { secret: C, id: c } = this.getCurrentReadKey();
      if (!C)
        throw new Error("Can't make transaction without read key secret");
      n = this.verified.makeNewPrivateTransaction(s, g, A, c, C, t, o ?? Date.now());
    } else
      n = this.verified.makeNewTrustingTransaction(s, g, A, t, o ?? Date.now());
    r && LA(this, Me, "m", mr).call(this);
    const { transaction: I } = n;
    return this.parsingCache.set(I, { changes: A, meta: t }), this.node.syncManager.recordTransactionsSize([I], "local"), this.processNewTransactions(), this.addDependenciesFromNewTransaction(I), this.notifyUpdate(), this.node.syncManager.syncLocalTransaction(this.verified, a), o === void 0 ? this.notifyDependants() : this.invalidateDependants(), !0;
  }
  addDependenciesFromNewTransaction(A) {
    if (this.verified?.header.ruleset.type === "group")
      for (const e of rs([
        A
      ]))
        this.addDependency(e);
  }
  getCurrentContent(A) {
    if (!this.verified)
      throw new Error("CoValueCore: getCurrentContent called on coValue without verified state");
    if (!A?.ignorePrivateTransactions && this._cachedContent)
      return this._cachedContent;
    const e = oB(this, A);
    return A?.ignorePrivateTransactions || (this._cachedContent = e), e;
  }
  // Reset the parsed transactions and branches, to validate them again from scratch when the group is updated
  resetParsedTransactions() {
    const A = this.verifiedTransactions;
    if (A.length === 0)
      return;
    this.branchStart = void 0, this.mergeCommits = [];
    const e = new Array(A.length);
    this.verifiedTransactions.forEach((o, r) => {
      o.isValidated = !1, e[r] = o.isValidTransactionWithChanges();
    }), this.toValidateTransactions = A.slice(), this.toProcessTransactions = [], this.toDecryptTransactions = [], this.toParseMetaTransactions = [], this.parseNewTransactions(!1), e.every((o, r) => o === A[r]?.isValidTransactionWithChanges()) || this._cachedContent?.rebuildFromCore(), this.scheduleNotifyUpdate();
  }
  /**
     * Loads the new transaction from the SessionMap into verifiedTransactions as a VerifiedTransaction.
     *
     * If the transaction is already loaded from the SessionMap in the past, it will not be loaded again.
     *
     * Used to have a fast way to iterate over the CoValue transactions, and track their validation/decoding state.
  
    * @internal
     * */
  loadVerifiedTransactionsFromLogs() {
    if (!this.verified)
      return;
    const A = this.isBranched();
    for (const [e, t] of this.verified.sessions.entries()) {
      const o = this.verifiedTransactionsKnownSessions[e] ?? 0;
      for (let r = o; r < t.transactions.length; r++) {
        const s = t.transactions[r];
        if (!s)
          continue;
        const g = this.parsingCache.get(s);
        g && this.parsingCache.delete(s);
        const n = new dB(this.id, e, r, s, A ? this.id : void 0, g, this.lastVerifiedTransactionBySessionID[e], this.dispatchTransaction);
        n.madeAt > this.latestTxMadeAt && (this.latestTxMadeAt = n.madeAt), n.madeAt < this.earliestTxMadeAt && (this.earliestTxMadeAt = n.madeAt), this.verifiedTransactions.push(n), this.dispatchTransaction(n), this.lastVerifiedTransactionBySessionID[e] = n;
      }
      this.verifiedTransactionsKnownSessions[e] = t.transactions.length;
    }
  }
  /**
   * Iterates over the verifiedTransactions and marks them as valid or invalid, based on the group membership of the authors of the transactions  .
   */
  determineValidTransactions() {
    bc(this), this.toValidateTransactions = [];
  }
  /**
   * Parses the meta information of a transaction, and set the branchStart and mergeCommits.
   */
  parseMetaInformation(A) {
    if (A.meta) {
      if (this.isBranched() && "from" in A.meta) {
        const e = A.meta;
        this.branchStart ? this.branchStart = it(this.branchStart, e.from) : this.branchStart = e.from;
      }
      if ("branch" in A.meta) {
        const e = A.meta;
        this.branches.push(e);
      }
      if ("merged" in A.meta) {
        const e = A.meta;
        this.mergeCommits.push(e);
      }
      if ("mi" in A.meta) {
        const e = A.meta, t = A.previous, o = e.s ?? t?.txID.sessionID;
        e.t ? A.sourceTxMadeAt = A.currentMadeAt - e.t : t && (A.sourceTxMadeAt = t.madeAt), A.sourceTxMadeAt && A.sourceTxMadeAt > A.currentMadeAt && A.markInvalid("Transaction sourceMadeAt is after the currentMadeAt", {
          sourceTxMadeAt: A.sourceTxMadeAt,
          currentMadeAt: A.currentMadeAt
        }), o ? A.sourceTxID = {
          sessionID: o,
          txIndex: e.mi,
          branch: e.b ?? t?.txID.branch
        } : AA.error("Merge commit without session ID", {
          txID: A.txID,
          prevTxID: t?.txID ?? null
        });
      }
    }
  }
  /**
   * Loads the new transactions from SessionMap and:
   * - Validates each transaction based on the group membership of the authors
   * - Decodes the changes & meta for each transaction
   * - Parses the meta information of the transaction
   */
  parseNewTransactions(A) {
    if (!this.isAvailable())
      return;
    if (this.loadVerifiedTransactionsFromLogs(), this.determineValidTransactions(), !A) {
      const t = this.toDecryptTransactions;
      this.toDecryptTransactions = [];
      for (const o of t)
        lB(this, o), this.dispatchTransaction(o);
    }
    const e = this.toParseMetaTransactions;
    this.toParseMetaTransactions = [];
    for (const t of e)
      this.parseMetaInformation(t);
  }
  /**
   * Returns the valid transactions matching the criteria specified in the options
   */
  getValidTransactions(A) {
    if (!this.verified)
      return [];
    this.parseNewTransactions(A?.ignorePrivateTransactions ?? !1);
    const e = [], t = Ra(this), o = A?.from, r = A?.to, s = A?.knownTransactions?.[this.id] ?? 0;
    for (let g = s; g < this.toProcessTransactions.length; g++) {
      const n = this.toProcessTransactions[g];
      if (!n.isValidTransactionWithChanges())
        continue;
      const a = n.currentTxID, I = o?.[a.sessionID] ?? -1, C = r?.[a.sessionID] ?? 1 / 0;
      I > a.txIndex || C < a.txIndex || e.push(n);
    }
    if (A?.knownTransactions !== void 0 && (A.knownTransactions[this.id] = this.toProcessTransactions.length), t && this.branchStart && !A?.skipBranchSource) {
      const g = t.getValidTransactions({
        knownTransactions: A?.knownTransactions,
        to: this.branchStart,
        ignorePrivateTransactions: A?.ignorePrivateTransactions ?? !1
      });
      for (const n of g)
        e.push(n);
    }
    return e;
  }
  addDependency(A) {
    const e = this.node.getCoValue(A);
    this.isCircularDependency(e) || this.dependencies.has(A) || (this.dependencies.add(A), e.addDependant(this.id), e.isCompletelyDownloaded() || (this.incompleteDependencies.add(e.id), e.waitFor({
      predicate: (t) => t.isCompletelyDownloaded(),
      onSuccess: () => {
        this.incompleteDependencies.delete(e.id), this.incompleteDependencies.size === 0 && this.notifyUpdate();
      }
    })), e.isAvailable() || (this.missingDependencies.add(e.id), e.waitFor({
      predicate: (t) => t.isAvailable(),
      onSuccess: () => {
        this.missingDependencies.delete(e.id), this.missingDependencies.size === 0 && this.notifyUpdate();
      }
    })));
  }
  addDependant(A) {
    this.dependant.add(A);
  }
  isGroupOrAccount() {
    return this.verified ? this.verified.header.ruleset.type === "group" : !1;
  }
  isGroup() {
    return !(!this.verified || this.verified.header.ruleset.type !== "group" || this.verified.header.meta?.type === "account");
  }
  createBranch(A, e) {
    return QB(this, A, e);
  }
  mergeBranch() {
    return EB(this);
  }
  getBranch(A, e) {
    return this.node.getCoValue(BB(this, A, e));
  }
  getCurrentBranchName() {
    return this.verified?.branchName;
  }
  getCurrentBranchSourceId() {
    return this.verified?.branchSourceId;
  }
  isBranched() {
    return !!this.verified?.branchSourceId;
  }
  hasBranch(A, e) {
    this.parseNewTransactions(!1);
    const t = gs(this);
    return this.branches.some((o) => {
      if (o.branch !== A)
        return !1;
      if (o.ownerId === e)
        return !0;
      if (!e)
        return o.ownerId === t;
      if (!o.ownerId)
        return e === t;
    });
  }
  getMergeCommits() {
    return this.mergeCommits;
  }
  getValidSortedTransactions(A) {
    const e = this.getValidTransactions(A);
    return e.sort(this.compareTransactions), e;
  }
  compareTransactions(A, e) {
    return A.madeAt !== e.madeAt ? A.madeAt - e.madeAt : A.txID.sessionID === e.txID.sessionID ? A.txID.txIndex - e.txID.txIndex : 0;
  }
  getCurrentReadKey() {
    if (!this.verified)
      throw new Error("CoValueCore: getCurrentReadKey called on coValue without verified state");
    if (this.isGroupOrAccount())
      return FA(this.getCurrentContent()).getCurrentReadKey();
    if (this.verified.header.ruleset.type === "ownedByGroup")
      return this.node.expectCoValueLoaded(this.verified.header.ruleset.group).getCurrentReadKey();
    throw new Error("Only groups or values owned by groups have read secrets");
  }
  getReadKey(A) {
    const e = this.readKeyCache.get(A);
    if (e)
      return e;
    if (!this.verified)
      throw new Error("CoValueCore: getUncachedReadKey called on coValue without verified state");
    if (this.isGroup())
      return FA(
        // Private transactions are not considered valid in groups, so we don't need to pass
        // ignorePrivateTransactions: true to safely load the content
        this.getCurrentContent()
      ).getReadKey(A);
    if (this.isGroupOrAccount())
      return FA(
        // Old accounts might have private transactions, because we were encrypting the root id in the past
        // So we need to load the account without private transactions, because we can't decrypt them without the read key
        this.getCurrentContent({ ignorePrivateTransactions: !0 })
      ).getReadKey(A);
    if (this.verified.header.ruleset.type === "ownedByGroup")
      return FA(this.node.expectCoValueLoaded(this.verified.header.ruleset.group).getCurrentContent()).getReadKey(A);
    throw new Error("Only groups or values owned by groups have read secrets");
  }
  safeGetGroup() {
    if (!this.verified)
      throw new Error("CoValueCore: getGroup called on coValue without verified state");
    if (this.verified.header.ruleset.type === "ownedByGroup")
      return FA(this.node.expectCoValueLoaded(this.verified.header.ruleset.group).getCurrentContent());
  }
  getGroup() {
    const A = this.safeGetGroup();
    if (!A)
      throw new Error("Only values owned by groups have groups");
    return A;
  }
  getTx(A) {
    return this.verified?.sessions.get(A.sessionID)?.transactions[A.txIndex];
  }
  getDependedOnCoValues() {
    return this.dependencies;
  }
  waitForSync(A) {
    return this.node.syncManager.waitForSync(this.id, A?.timeout);
  }
  load(A, e) {
    this.loadFromStorage((t) => {
      t || this.loadFromPeers(A, e);
    });
  }
  loadFromStorage(A) {
    const e = this.node;
    if (!e.storage) {
      A?.(!1);
      return;
    }
    const t = this.getLoadingStateForPeer("storage");
    if (t === "pending") {
      if (!A)
        return;
      this.subscribe((r, s) => {
        const g = r.getLoadingStateForPeer("storage");
        g === "available" || r.isAvailable() ? (s(), A(!0)) : (g === "errored" || g === "unavailable") && (s(), A(!1));
      });
      return;
    }
    const o = this.loadingState;
    if (t !== "unknown" && o !== "garbageCollected" && o !== "onlyKnownState") {
      A?.(t === "available");
      return;
    }
    this.markPending("storage"), e.storage.load(this.id, (r) => {
      e.syncManager.handleNewContent(r, "storage");
    }, (r) => {
      A?.(r), r || this.markNotFoundInPeer("storage");
    });
  }
  /**
   * Lazily load only the knownState from storage without loading full transaction data.
   * This is useful for checking if a peer needs new content before committing to a full load.
   *
   * If found in storage, marks the CoValue as onlyKnownState and caches the knownState.
   * This enables accurate LOAD requests during peer reconciliation.
   *
   * @param done - Callback with the storage knownState, or undefined if not found in storage
   */
  getKnownStateFromStorage(A) {
    if (!this.node.storage) {
      A(void 0);
      return;
    }
    const e = this.knownState();
    if (e.header) {
      A(e);
      return;
    }
    this.node.storage.loadKnownState(this.id, (t) => {
      if (t && !this.isAvailable()) {
        const o = this.loadingState;
        qA(this, pe, "onlyKnownState", "f"), qA(this, ye, t, "f"), this.updateCounter(o);
      }
      A(t);
    });
  }
  loadFromPeers(A, e) {
    if (A.length !== 0)
      for (const t of A) {
        const o = this.getLoadingStateForPeer(t.id);
        (o === "unknown" || o === "unavailable") && (this.markPending(t.id), this.internalLoadFromPeer(t, e));
      }
  }
  internalLoadFromPeer(A, e) {
    if (A.closed && !A.persistent) {
      this.markNotFoundInPeer(A.id);
      return;
    }
    const t = () => {
      this.getLoadingStateForPeer(A.id) === "pending" && (AA.warn("Timeout waiting for peer to load coValue", {
        id: this.id,
        peerID: A.id
      }), this.markNotFoundInPeer(A.id));
    }, o = A.persistent ? void 0 : A.addCloseListener(t);
    A.closed || A.sendLoadRequest(this, e), this.subscribe((r, s) => {
      const g = r.getLoadingStateForPeer(A.id);
      (r.isAvailable() || // might have become available from another peer e.g. through handleNewContent
      g === "available" || g === "errored" || g === "unavailable") && (s(), o?.());
    }, !0);
  }
}
pe = /* @__PURE__ */ new WeakMap(), ye = /* @__PURE__ */ new WeakMap(), pt = /* @__PURE__ */ new WeakMap(), yt = /* @__PURE__ */ new WeakMap(), Dt = /* @__PURE__ */ new WeakMap(), Me = /* @__PURE__ */ new WeakSet(), ba = function(A, e, t) {
  if (!this.verified)
    return {
      value: !1
    };
  let o;
  if (Ke(A)) {
    if ((this.verified.sessions.get(A)?.transactions.length ?? 0) > 0 || e.length > 1)
      return {
        value: !0,
        err: {
          type: "DeleteTransactionRejected",
          id: this.id,
          sessionID: A,
          reason: "InvalidDeleteTransaction",
          error: new Error("Delete transaction must be the only transaction in the session")
        }
      };
    const s = e[0], g = s && LA(this, Me, "m", sg).call(this, s);
    if (g && (o = s, g.deleted !== this.id))
      return {
        value: !0,
        err: {
          type: "DeleteTransactionRejected",
          id: this.id,
          sessionID: A,
          reason: "InvalidDeleteTransaction",
          error: new Error(`Delete transaction ID mismatch: expected ${this.id}, got ${g.deleted}`)
        }
      };
    if (this.isGroupOrAccount())
      return {
        value: !0,
        err: {
          type: "DeleteTransactionRejected",
          id: this.id,
          sessionID: A,
          reason: "CoValueNotDeletable",
          error: new Error("Cannot delete Group or Account coValues")
        }
      };
  }
  if (!t && o) {
    const r = TA(A), s = LA(this, Me, "m", gg).call(this, r, o.madeAt);
    if (!s.ok)
      return {
        value: !0,
        err: {
          type: "DeleteTransactionRejected",
          id: this.id,
          sessionID: A,
          author: r,
          reason: s.reason,
          error: new Error(s.message)
        }
      };
  }
  return {
    value: !!o
  };
}, mr = function() {
  this.isDeleted = !0, this.verified?.markAsDeleted();
}, sg = function(A) {
  if (A.privacy !== "trusting" || !A.meta)
    return;
  const e = pr(A.meta);
  return e && typeof e.deleted == "string" ? e : void 0;
}, gg = function(A, e) {
  if (!this.verified)
    return {
      ok: !1,
      reason: "CannotVerifyPermissions",
      message: "Cannot verify delete permissions without verified state"
    };
  if (this.isGroupOrAccount())
    return {
      ok: !1,
      reason: "CoValueNotDeletable",
      message: "Cannot delete Group or Account coValues"
    };
  const t = this.safeGetGroup();
  return t ? t.atTime(e).roleOfInternal(A) !== "admin" ? {
    ok: !1,
    reason: "NotAdmin",
    message: "Delete transaction rejected: author is not an admin"
  } : { ok: !0 } : {
    ok: !1,
    reason: "CannotVerifyPermissions",
    message: "Cannot verify delete permissions for coValues not owned by a group"
  };
};
class hB {
  constructor(A) {
    this.node = A, this.interval = setInterval(() => {
      this.collect();
    }, ig.INTERVAL);
  }
  getCurrentTime() {
    return performance.now();
  }
  trackCoValueAccess({ verified: A }) {
    A && (A.lastAccessed = this.getCurrentTime());
  }
  collect() {
    const A = this.getCurrentTime();
    for (const e of this.node.allCoValues()) {
      const { verified: t } = e;
      if (!t?.lastAccessed)
        continue;
      A - t.lastAccessed > ig.MAX_AGE && this.node.internalUnmountCoValue(e.id);
    }
  }
  stop() {
    clearInterval(this.interval);
  }
}
class ns {
  constructor(A, e) {
    this.id = A, this.peerId = e, this.knownState = ve(A);
  }
  cloneWithoutOptimistic() {
    const A = new ns(this.id, this.peerId);
    return A.set(this.knownState), A;
  }
  updateHeader(A) {
    this.knownState.header = A, this.optimisticKnownState && (this.optimisticKnownState.header = A);
  }
  combineWith(A) {
    zo(this.knownState, A), this.optimisticKnownState && zo(this.optimisticKnownState, A);
  }
  combineOptimisticWith(A) {
    this.optimisticKnownState || (this.optimisticKnownState = Se(this.knownState)), zo(this.optimisticKnownState, A);
  }
  /**
   * Aligns the CoValue known state with the defined payload
   */
  set(A) {
    A === "empty" ? (this.knownState.header = !1, this.knownState.sessions = {}) : (this.knownState.header = A.header, this.knownState.sessions = { ...A.sessions }), this.optimisticKnownState = void 0;
  }
  value() {
    return this.knownState;
  }
  optimisticValue() {
    return this.optimisticKnownState ?? this.knownState;
  }
}
class wo {
  constructor(A) {
    this.meter = A, this.head = void 0, this.tail = void 0, this.length = 0;
  }
  push(A) {
    const e = { value: A, prev: void 0, next: void 0 };
    if (this.head === void 0)
      this.head = e, this.tail = e;
    else if (this.tail)
      e.prev = this.tail, this.tail.next = e, this.tail = e;
    else
      throw new Error("LinkedList is corrupted");
    return this.length++, this.meter?.push(), e;
  }
  shift() {
    if (!this.head)
      return;
    const A = this.head, e = A.value;
    return this.head = A.next, A.next = void 0, this.head === void 0 ? this.tail = void 0 : this.head.prev = void 0, this.length--, this.meter?.pull(), e;
  }
  /**
   * Remove a specific node from the list in O(1) time.
   * The node must be a valid node that was returned by push().
   */
  remove(A) {
    A.prev ? A.prev.next = A.next : this.head = A.next, A.next ? A.next.prev = A.prev : this.tail = A.prev, A.prev = void 0, A.next = void 0, this.length--, this.meter?.pull();
  }
  isEmpty() {
    return this.head === void 0;
  }
}
class fB {
  constructor(A, e) {
    this.attrs = e, this.pullCounter = ae.getMeter("cojson").createCounter(`${A}.pulled`, {
      description: "Number of messages pulled from the queue",
      valueType: WA.INT,
      unit: "1"
    }), this.pushCounter = ae.getMeter("cojson").createCounter(`${A}.pushed`, {
      description: "Number of messages pushed to the queue",
      valueType: WA.INT,
      unit: "1"
    }), this.pullCounter.add(0, this.attrs), this.pushCounter.add(0, this.attrs);
  }
  pull() {
    this.pullCounter.add(1, this.attrs);
  }
  push() {
    this.pushCounter.add(1, this.attrs);
  }
}
function Gt(i, A) {
  return new wo(new fB("jazz.messagequeue." + i, A));
}
class wB {
  constructor(A) {
    this.peerId = A, this.inFlightLoads = /* @__PURE__ */ new Map(), this.highPriorityPending = Gt("load-requests-queue", { priority: "high" }), this.lowPriorityPending = Gt("load-requests-queue", { priority: "low" }), this.lowPriorityNodes = /* @__PURE__ */ new Map(), this.highPriorityNodes = /* @__PURE__ */ new Map(), this.timeoutHandle = null, this.processing = !1;
  }
  /**
   * Check if we can send another load request.
   */
  canSend() {
    return this.inFlightLoads.size < Xe.MAX_IN_FLIGHT_LOADS_PER_PEER;
  }
  /**
   * Track that a load request has been sent.
   */
  trackSent(A) {
    const e = performance.now();
    this.inFlightLoads.set(A, e), this.scheduleTimeoutCheck(Xe.TIMEOUT);
  }
  /**
   * Schedule a timeout check if not already scheduled.
   * Uses a single timer to check all in-flight loads.
   */
  scheduleTimeoutCheck(A) {
    this.timeoutHandle === null && (this.timeoutHandle = setTimeout(() => {
      this.timeoutHandle = null, this.checkTimeouts();
    }, A));
  }
  /**
   * Check all in-flight loads for timeouts and handle them.
   */
  checkTimeouts() {
    const A = performance.now();
    let e;
    for (const [t, o] of this.inFlightLoads.entries()) {
      const r = o + Xe.TIMEOUT;
      A >= r ? (t.isAvailable() ? t.isStreaming() && AA.warn("Content streaming is taking more than " + Xe.TIMEOUT / 1e3 + "s", {
        id: t.id,
        peerId: this.peerId,
        knownState: t.knownState().sessions,
        streamingTarget: t.knownStateWithStreaming().sessions
      }) : (AA.warn("Load request timed out", {
        id: t.id,
        peerId: this.peerId
      }), t.markNotFoundInPeer(this.peerId)), this.inFlightLoads.delete(t), this.processQueue()) : e = Math.min(e ?? 1 / 0, r - A);
    }
    e && this.scheduleTimeoutCheck(e);
  }
  trackUpdate(A) {
    this.inFlightLoads.has(A) && this.inFlightLoads.set(A, performance.now());
  }
  /**
   * Track that a load request has completed.
   * Triggers processing of pending requests.
   */
  trackComplete(A) {
    this.inFlightLoads.has(A) && (A.isStreaming() || (this.inFlightLoads.delete(A), this.processQueue()));
  }
  /**
   * Enqueue a load request.
   * Immediately processes the queue to send requests if capacity is available.
   * Skips CoValues that are already in-flight or pending.
   *
   * @param coValue - The CoValue to load
   * @param sendCallback - Callback to send the request when ready
   * @param mode - Optional mode: "low-priority" for background loads, "immediate" to bypass queue
   */
  enqueue(A, e, t = "high-priority") {
    if (this.inFlightLoads.has(A))
      return;
    const o = this.lowPriorityNodes.get(A.id), r = this.highPriorityNodes.get(A.id);
    switch (t) {
      case "immediate":
        o && (this.lowPriorityPending.remove(o), this.lowPriorityNodes.delete(A.id)), r && (this.highPriorityPending.remove(r), this.highPriorityNodes.delete(A.id)), this.trackSent(A), e();
        break;
      case "high-priority":
        if (r)
          return;
        o && (this.lowPriorityPending.remove(o), this.lowPriorityNodes.delete(A.id)), this.highPriorityNodes.set(A.id, this.highPriorityPending.push({ value: A, sendCallback: e })), this.processQueue();
        break;
      case "low-priority":
        if (o || r)
          return;
        this.lowPriorityNodes.set(A.id, this.lowPriorityPending.push({ value: A, sendCallback: e })), this.processQueue();
        break;
    }
  }
  /**
   * Process all pending load requests while capacity is available.
   * High-priority requests are processed first, then low-priority.
   */
  processQueue() {
    if (!(this.processing || !this.canSend())) {
      for (this.processing = !0; this.canSend(); ) {
        let A = this.highPriorityPending.shift();
        if (A ? this.highPriorityNodes.delete(A.value.id) : (A = this.lowPriorityPending.shift(), A && this.lowPriorityNodes.delete(A.value.id)), !A)
          break;
        this.trackSent(A.value), A.sendCallback();
      }
      this.processing = !1;
    }
  }
  /**
   * Clear all state. Called on disconnect.
   * Clears the timeout and all pending/in-flight loads.
   */
  clear() {
    for (this.timeoutHandle !== null && (clearTimeout(this.timeoutHandle), this.timeoutHandle = null), this.inFlightLoads.clear(); this.highPriorityPending.shift(); )
      ;
    for (; this.lowPriorityPending.shift(); )
      ;
    this.highPriorityNodes.clear(), this.lowPriorityNodes.clear();
  }
  /**
   * Get the number of in-flight loads (for testing/debugging).
   */
  get inFlightCount() {
    return this.inFlightLoads.size;
  }
  /**
   * Get the number of pending loads (for testing/debugging).
   */
  get pendingCount() {
    return this.highPriorityPending.length + this.lowPriorityPending.length;
  }
  /**
   * Get the number of high-priority pending loads (for testing/debugging).
   */
  get highPriorityPendingCount() {
    return this.highPriorityPending.length;
  }
  /**
   * Get the number of low-priority pending loads (for testing/debugging).
   */
  get lowPriorityPendingCount() {
    return this.lowPriorityPending.length;
  }
}
class as {
  constructor(A, e) {
    this.peer = A, this.toldKnownState = /* @__PURE__ */ new Set(), this.loadRequestSent = /* @__PURE__ */ new Set(), this.listeners = /* @__PURE__ */ new Set(), this.closed = !1, this.closeListeners = /* @__PURE__ */ new Set(), this._knownStates = e ?? /* @__PURE__ */ new Map(), this.loadQueue = new wB(A.id);
  }
  getKnownState(A) {
    return this._knownStates.get(A)?.value();
  }
  getOptimisticKnownState(A) {
    return this._knownStates.get(A)?.optimisticValue();
  }
  isCoValueSubscribedToPeer(A) {
    return this._knownStates.has(A);
  }
  /**
   * Closes the current peer state and creates a new one from a given peer,
   * keeping the same known states.
   *
   * This is used to create a new peer state when a peer reconnects.
   */
  newPeerStateFrom(A) {
    this.closed || this.gracefulShutdown();
    const e = /* @__PURE__ */ new Map();
    for (const t of this._knownStates.values())
      e.set(t.id, t.cloneWithoutOptimistic());
    return new as(A, e);
  }
  sendLoadRequest(A, e) {
    this.toldKnownState.add(A.id), this.loadRequestSent.add(A.id), this.loadQueue.enqueue(A, () => {
      this.pushOutgoingMessage({
        action: "load",
        ...A.knownStateWithStreaming()
      });
    }, e);
  }
  trackLoadRequestUpdate(A) {
    this.loadQueue.trackUpdate(A);
  }
  trackLoadRequestComplete(A) {
    this.loadQueue.trackComplete(A);
  }
  trackToldKnownState(A) {
    this.toldKnownState.add(A);
  }
  getOrCreateKnownState(A) {
    let e = this._knownStates.get(A);
    return e || (e = new ns(A, this.peer.id), this._knownStates.set(A, e)), e;
  }
  updateHeader(A, e) {
    const t = this.getOrCreateKnownState(A);
    t.updateHeader(e), this.triggerUpdate(A, t);
  }
  combineWith(A, e) {
    const t = this.getOrCreateKnownState(A);
    t.combineWith(e), this.triggerUpdate(A, t);
  }
  combineOptimisticWith(A, e) {
    const t = this.getOrCreateKnownState(A);
    t.combineOptimisticWith(e), this.triggerUpdate(A, t);
  }
  setKnownState(A, e) {
    const t = this.getOrCreateKnownState(A);
    t.set(e), this.triggerUpdate(A, t);
  }
  /**
   * Emit a change event for a given coValue.
   *
   * This is used to notify subscribers that the known state of a coValue has changed,
   * but the known state of the peer has not.
   */
  emitCoValueChange(A) {
    if (this.peer.role === "client" && !this.isCoValueSubscribedToPeer(A))
      return;
    const e = this.getOrCreateKnownState(A);
    this.triggerUpdate(A, e);
  }
  triggerUpdate(A, e) {
    for (const t of this.listeners)
      t(A, e);
  }
  subscribeToKnownStatesUpdates(A) {
    return this.listeners.add(A), () => {
      this.listeners.delete(A);
    };
  }
  get id() {
    return this.peer.id;
  }
  get role() {
    return this.peer.role;
  }
  get priority() {
    return this.peer.priority;
  }
  get incoming() {
    return this.peer.incoming;
  }
  get persistent() {
    return this.peer.persistent;
  }
  pushOutgoingMessage(A) {
    this.peer.outgoing.push(A);
  }
  addCloseListener(A) {
    return this.closed ? (A(), () => {
    }) : (this.closeListeners.add(A), () => {
      this.closeListeners.delete(A);
    });
  }
  emitClose() {
    for (const A of this.closeListeners)
      A();
    this.closeListeners.clear();
  }
  gracefulShutdown() {
    this.closed || (AA.debug("Gracefully closing", {
      peerId: this.id,
      peerRole: this.role
    }), this.closed = !0, this.loadQueue.clear(), this.peer.outgoing.push("Disconnected"), this.peer.outgoing.close(), this.peer.incoming.close(), this.emitClose());
  }
}
class pB {
  constructor(A) {
    this.syncManager = A, this.listeners = /* @__PURE__ */ new Set(), this.listenersByCoValues = /* @__PURE__ */ new Map(), this.listenersByPeersAndCoValues = /* @__PURE__ */ new Map();
  }
  subscribeToUpdates(A) {
    return this.listeners.add(A), () => {
      this.listeners.delete(A);
    };
  }
  subscribeToCoValueUpdates(A, e) {
    let t = this.listenersByCoValues.get(A);
    return t || (t = /* @__PURE__ */ new Set(), this.listenersByCoValues.set(A, t)), t.add(e), () => {
      t.delete(e), t.size === 0 && this.listenersByCoValues.delete(A);
    };
  }
  subscribeToPeerUpdates(A, e, t) {
    let o = this.listenersByPeersAndCoValues.get(A);
    o || (o = /* @__PURE__ */ new Map(), this.listenersByPeersAndCoValues.set(A, o));
    let r = o.get(e);
    return r || (r = /* @__PURE__ */ new Set(), o.set(e, r)), r.add(t), () => {
      r.delete(t), r.size === 0 && (o.delete(e), o.size === 0 && this.listenersByPeersAndCoValues.delete(A));
    };
  }
  triggerUpdate(A, e, t) {
    const o = this.listeners, r = this.listenersByCoValues.get(e), g = this.listenersByPeersAndCoValues.get(A.id)?.get(e);
    if (!o.size && !r?.size && !g?.size)
      return;
    const n = {
      uploaded: this.getIsCoValueFullyUploadedIntoPeer(t, e)
    };
    for (const a of this.listeners)
      a(A, t, n);
    if (r)
      for (const a of r)
        a(A, t, n);
    if (g)
      for (const a of g)
        a(t, n);
  }
  isSynced(A, e) {
    const t = A.getKnownState(e);
    return t ? this.getIsCoValueFullyUploadedIntoPeer(t, e) : !1;
  }
  getIsCoValueFullyUploadedIntoPeer(A, e) {
    const t = this.syncManager.local.getCoValue(e);
    if (!t.hasVerifiedContent())
      return !1;
    const o = t.verified.knownState();
    return Ma(o.sessions, A.sessions);
  }
}
const ag = "any";
let yB = 200;
class DB {
  constructor() {
    this.unsynced = /* @__PURE__ */ new Map(), this.coValueListeners = /* @__PURE__ */ new Map(), this.globalListeners = /* @__PURE__ */ new Set(), this.pendingUpdates = [];
  }
  /**
   * Add a CoValue as unsynced to a specific peer.
   * Triggers persistence if storage is available.
   * @returns true if the CoValue was already tracked, false otherwise.
   */
  add(A, e = ag) {
    this.unsynced.has(A) || this.unsynced.set(A, /* @__PURE__ */ new Set());
    const t = this.unsynced.get(A), o = t.has(e);
    return o || (t.add(e), this.schedulePersist(A, e, !1), this.notifyCoValueListeners(A, !1), this.notifyGlobalListeners(!1)), o;
  }
  /**
   * Remove a CoValue from being unsynced to a specific peer.
   * Triggers persistence if storage is available.
   */
  remove(A, e = ag) {
    const t = this.unsynced.get(A);
    if (!t || !t.has(e))
      return;
    t.delete(e), t.size === 0 && this.unsynced.delete(A), this.schedulePersist(A, e, !0);
    const o = !this.unsynced.has(A);
    this.notifyCoValueListeners(A, o), this.notifyGlobalListeners(this.isAllSynced());
  }
  /**
   * Remove all tracking for a CoValue (all peers).
   * Triggers persistence if storage is available.
   */
  removeAll(A) {
    const e = this.unsynced.get(A);
    if (!e)
      return;
    const t = Array.from(e);
    for (const o of t)
      this.remove(A, o);
  }
  forcePersist() {
    return this.flush();
  }
  schedulePersist(A, e, t) {
    this.storage && (this.pendingUpdates.push({ id: A, peerId: e, synced: t }), this.flushTimer || (this.flushTimer = setTimeout(() => {
      this.flush();
    }, yB)));
  }
  /**
   * Flush all pending persistence updates in a batch
   */
  flush() {
    if (this.flushTimer && (clearTimeout(this.flushTimer), this.flushTimer = void 0), this.pendingUpdates.length === 0)
      return;
    const A = this.storage;
    if (!A)
      return;
    const e = this.simplifyPendingUpdates(this.pendingUpdates);
    return this.pendingUpdates = [], new Promise((t) => {
      try {
        A.trackCoValuesSyncState(e, () => t());
      } catch (o) {
        AA.warn("Failed to persist batched unsynced CoValue tracking", {
          err: o
        }), t();
      }
    });
  }
  /**
   * Get all CoValue IDs that have at least one unsynced peer.
   */
  getAll() {
    return Array.from(this.unsynced.keys());
  }
  /**
   * Check if all CoValues are synced
   */
  isAllSynced() {
    return this.unsynced.size === 0;
  }
  /**
   * Check if a specific CoValue is tracked as unsynced.
   */
  has(A) {
    return this.unsynced.has(A);
  }
  subscribe(A, e) {
    if (typeof A == "string" && e) {
      const o = A;
      this.coValueListeners.has(o) || this.coValueListeners.set(o, /* @__PURE__ */ new Set()), this.coValueListeners.get(o).add(e);
      const r = !this.unsynced.has(o);
      return e(r), () => {
        const s = this.coValueListeners.get(o);
        s && (s.delete(e), s.size === 0 && this.coValueListeners.delete(o));
      };
    }
    const t = A;
    return this.globalListeners.add(t), t(this.isAllSynced()), () => {
      this.globalListeners.delete(t);
    };
  }
  setStorage(A) {
    this.storage = A;
  }
  removeStorage() {
    this.storage = void 0;
  }
  /**
   * Notify all listeners for a specific CoValue about sync status change.
   */
  notifyCoValueListeners(A, e) {
    const t = this.coValueListeners.get(A);
    if (t)
      for (const o of t)
        o(e);
  }
  /**
   * Notify all global listeners about "all synced" status change.
   */
  notifyGlobalListeners(A) {
    for (const e of this.globalListeners)
      e(A);
  }
  /**
   * Keep only the last update for each (id, peerId) combination
   */
  simplifyPendingUpdates(A) {
    const e = /* @__PURE__ */ new Map();
    for (const t of A)
      e.set(`${t.id}|${t.peerId}`, t);
    return Array.from(e.values());
  }
}
class mB {
  constructor(A) {
    this.processQueues = A, this.currentQueue = 0, this.pullCounter = ae.getMeter("cojson").createCounter("jazz.messagequeue.incoming.pulled", {
      description: "Number of messages pulled from the queue",
      valueType: WA.INT,
      unit: "1"
    }), this.pushCounter = ae.getMeter("cojson").createCounter("jazz.messagequeue.incoming.pushed", {
      description: "Number of messages pushed to the queue",
      valueType: WA.INT,
      unit: "1"
    }), this.pullCounter.add(0, {
      peerRole: "client"
    }), this.pushCounter.add(0, {
      peerRole: "client"
    }), this.pullCounter.add(0, {
      peerRole: "server"
    }), this.pushCounter.add(0, {
      peerRole: "server"
    }), this.queues = [], this.peerToQueue = /* @__PURE__ */ new WeakMap();
  }
  push(A, e) {
    const t = this.peerToQueue.get(e);
    if (t)
      t.push(A);
    else {
      const o = new wo();
      this.peerToQueue.set(e, o), this.queues.push([o, e]), o.push(A);
    }
    this.pushCounter.add(1, {
      peerRole: e.role
    }), this.processQueues();
  }
  pull() {
    const A = this.queues[this.currentQueue];
    if (!A)
      return;
    const [e, t] = A, o = e.shift();
    if (e.isEmpty() ? (this.queues.splice(this.currentQueue, 1), this.peerToQueue.delete(t)) : this.currentQueue++, this.currentQueue >= this.queues.length && (this.currentQueue = 0), o)
      return this.pullCounter.add(1, {
        peerRole: t.role
      }), { msg: o, peer: t };
  }
}
class SB {
  constructor(A) {
    this.sync = A, this.batch = [], this.syncTransaction = (e, t) => {
      const o = this.lastUpdatedValue, r = this.lastUpdatedValueKnownState;
      if (o && r) {
        if (o.id === e.id)
          return;
        this.addContentToBatch(o, r);
      }
      this.lastUpdatedValue = e, this.lastUpdatedValueKnownState = t;
      for (const s of this.dirtyCoValuesTrackingSets)
        s.add(e.id);
      this.scheduleNextBatch();
    }, this.nextBatchScheduled = !1, this.dirtyCoValuesTrackingSets = /* @__PURE__ */ new Set(), this.trackDirtyCoValues = () => {
      const e = /* @__PURE__ */ new Set();
      return this.dirtyCoValuesTrackingSets.add(e), {
        done: () => (this.dirtyCoValuesTrackingSets.delete(e), e)
      };
    };
  }
  addContentToBatch(A, e) {
    const t = A.newContentSince(e);
    if (t)
      for (const o of t)
        this.batch.push(o);
  }
  scheduleNextBatch() {
    this.nextBatchScheduled || (this.nextBatchScheduled = !0, queueMicrotask(() => {
      this.lastUpdatedValue && this.lastUpdatedValueKnownState && this.addContentToBatch(this.lastUpdatedValue, this.lastUpdatedValueKnownState);
      const A = this.batch;
      this.lastUpdatedValue = void 0, this.lastUpdatedValueKnownState = void 0, this.batch = [], this.nextBatchScheduled = !1;
      for (const e of A)
        this.sync(e);
    }));
  }
}
function Ig(i) {
  return i.role === "server" && (i.persistent ?? !1);
}
class NB {
  ignoreUnknownCoValuesFromServers() {
    this._ignoreUnknownCoValuesFromServers = !0;
  }
  constructor(A) {
    this.peers = {}, this.skipVerify = !1, this._ignoreUnknownCoValuesFromServers = !1, this.peersCounter = ae.getMeter("cojson").createUpDownCounter("jazz.peers", {
      description: "Amount of connected peers",
      valueType: WA.INT,
      unit: "peer"
    }), this.messagesQueue = new mB(() => this.processQueues()), this.processing = !1, this.syncQueue = new SB((e) => this.syncContent(e)), this.syncLocalTransaction = this.syncQueue.syncTransaction, this.trackDirtyCoValues = this.syncQueue.trackDirtyCoValues, this.local = A, this.syncState = new pB(this), this.unsyncedTracker = new DB(), this.transactionsSizeHistogram = ae.getMeter("cojson").createHistogram("jazz.transactions.size", {
      description: "The size of transactions in a covalue",
      unit: "bytes",
      valueType: WA.INT
    });
  }
  disableTransactionVerification() {
    this.skipVerify = !0;
  }
  getPeers(A) {
    return this.getServerPeers(A).concat(this.getClientPeers());
  }
  getClientPeers() {
    return Object.values(this.peers).filter((A) => A.role === "client");
  }
  getServerPeers(A, e) {
    const t = Object.values(this.peers).filter((o) => o.role === "server" && o.id !== e);
    return this.serverPeerSelector ? this.serverPeerSelector(A, t) : t;
  }
  getPersistentServerPeers(A) {
    return this.getServerPeers(A).filter((e) => e.persistent);
  }
  handleSyncMessage(A, e) {
    if (!Ea(A.id)) {
      const t = A.id ? "invalid" : "undefined";
      AA.warn(`Received sync message with ${t} id`, {
        msg: A
      });
      return;
    }
    if (e.role === "server" && this._ignoreUnknownCoValuesFromServers && !this.local.hasCoValue(A.id)) {
      AA.warn(`Ignoring message ${A.action} on unknown coValue ${A.id} from peer ${e.id}`);
      return;
    }
    if (this.local.getCoValue(A.id).isErroredInPeer(e.id)) {
      AA.warn(`Skipping message ${A.action} on errored coValue ${A.id} from peer ${e.id}`);
      return;
    }
    switch (A.action) {
      case "load":
        return this.handleLoad(A, e);
      case "known":
        return A.isCorrection ? this.handleCorrection(A, e) : this.handleKnownState(A, e);
      case "content":
        return this.handleNewContent(A, e);
      case "done":
        return;
      default:
        throw new Error(`Unknown message type ${A.action}`);
    }
  }
  sendNewContent(A, e, t = /* @__PURE__ */ new Set()) {
    if (t.has(A))
      return;
    t.add(A);
    const o = this.local.getCoValue(A);
    if (!o.isAvailable())
      return;
    if (e.role !== "server")
      for (const g of o.getDependedOnCoValues())
        this.sendNewContent(g, e, t);
    const s = o.newContentSince(e.getOptimisticKnownState(A));
    if (s) {
      for (const g of s)
        this.trySendToPeer(e, g);
      e.combineOptimisticWith(A, o.knownState());
    } else e.toldKnownState.has(A) || (o.isDeleted ? this.trySendToPeer(e, o.stopSyncingKnownStateMessage(e.getKnownState(A))) : this.trySendToPeer(e, {
      action: "known",
      ...o.knownStateWithStreaming()
    }));
    e.trackToldKnownState(A);
  }
  reconcileServerPeers() {
    const A = Object.values(this.peers).filter((e) => e.role === "server");
    for (const e of A)
      this.startPeerReconciliation(e);
  }
  async resumeUnsyncedCoValues() {
    this.local.storage && await new Promise((A, e) => {
      this.local.storage?.getUnsyncedCoValueIDs((t) => {
        const o = t.filter((n) => !this.local.hasCoValue(n));
        if (o.length === 0) {
          A();
          return;
        }
        const r = 10;
        let s = 0;
        const g = async () => {
          const n = o.slice(s, s + r);
          await Promise.all(n.map(async (a) => new Promise((I) => {
            try {
              this.local.storage?.stopTrackingSyncState(a), this.trackSyncState(a), this.local.getCoValue(a).loadFromStorage((c) => {
                c || this.unsyncedTracker.removeAll(a), I();
              });
            } catch (C) {
              AA.warn(`Failed to resume sync for CoValue ${a}:`, {
                err: C,
                coValueId: a
              }), this.unsyncedTracker.removeAll(a), I();
            }
          }))), s += n.length, s < o.length ? g().catch(e) : A();
        };
        g().catch(e);
      });
    });
  }
  startPeerReconciliation(A) {
    Ig(A) && this.resumeUnsyncedCoValues().catch((r) => {
      AA.warn("Failed to resume unsynced CoValues:", r);
    });
    const e = [], t = /* @__PURE__ */ new Set(), o = (r) => {
      if (!t.has(r.id) && (t.add(r.id), this.getServerPeers(r.id).find((s) => s.id === A.id) !== void 0)) {
        for (const s of r.getDependedOnCoValues()) {
          const g = this.local.getCoValue(s);
          g.isAvailable() && o(g);
        }
        e.push(r);
      }
    };
    for (const r of this.local.allCoValues()) {
      if (r.isAvailable())
        o(r);
      else {
        if (r.loadingState === "unknown")
          continue;
        A.loadRequestSent.has(r.id) || A.sendLoadRequest(r, "low-priority");
      }
      A.getKnownState(r.id) || A.setKnownState(r.id, "empty");
    }
    for (const r of e)
      A.sendLoadRequest(r, "low-priority");
  }
  pushMessage(A, e) {
    this.messagesQueue.push(A, e);
  }
  /**
   * Get the storage streaming queue if available.
   * Returns undefined if storage doesn't have a streaming queue.
   */
  getStorageStreamingQueue() {
    const A = this.local.storage;
    if (A && "streamingQueue" in A)
      return A.streamingQueue;
  }
  /**
   * Unified queue processing that coordinates both incoming messages
   * and storage streaming entries.
   *
   * Processes items from both queues with priority ordering:
   * - Incoming messages are processed via round-robin across peers
   * - Storage streaming entries are processed by priority (MEDIUM before LOW)
   *
   * Implements time budget scheduling to avoid blocking the main thread.
   */
  async processQueues() {
    if (this.processing)
      return;
    this.processing = !0;
    let A = performance.now();
    const e = this.getStorageStreamingQueue();
    for (; ; ) {
      const t = this.messagesQueue.pull();
      if (t)
        try {
          this.handleSyncMessage(t.msg, t.peer);
        } catch (s) {
          AA.error("Error processing message", { err: s });
        }
      const o = e?.pull();
      if (o)
        try {
          o();
        } catch (s) {
          AA.error("Error processing storage streaming entry", {
            err: s
          });
        }
      if (!t && !o)
        break;
      performance.now() - A > eB.INCOMING_MESSAGES_TIME_BUDGET && (await Ka(), A = performance.now());
    }
    this.processing = !1;
  }
  addPeer(A, e = !1) {
    const t = this.peers[A.id], o = t ? t.newPeerStateFrom(A) : new as(A, void 0);
    this.peers[A.id] = o, this.peersCounter.add(1, { role: A.role });
    const r = o.subscribeToKnownStatesUpdates((s, g) => {
      this.syncState.triggerUpdate(A, s, g.value());
    });
    !e && o.role === "server" && this.startPeerReconciliation(o), o.incoming.onMessage((s) => {
      if (s === "Disconnected") {
        o.gracefulShutdown();
        return;
      }
      this.pushMessage(s, o);
    }), o.addCloseListener(() => {
      r(), this.peersCounter.add(-1, { role: A.role }), !A.persistent && this.peers[A.id] === o && this.removePeer(A.id);
    });
  }
  removePeer(A) {
    const e = this.peers[A];
    e && (e.closed || e.gracefulShutdown(), delete this.peers[e.id]);
  }
  trySendToPeer(A, e) {
    return A.pushOutgoingMessage(e);
  }
  /**
   * Handles the load message from a peer.
   *
   * Differences with the known state message:
   * - The load message triggers the CoValue loading process on the other peer
   * - The peer known state is stored as-is instead of being merged
   * - The load message always replies with a known state message
   */
  handleLoad(A, e) {
    e.setKnownState(A.id, Wo(A));
    const t = this.local.getCoValue(A.id);
    if (t.isAvailable()) {
      this.sendNewContent(A.id, e);
      return;
    }
    const o = e.getOptimisticKnownState(A.id);
    if (!o?.header) {
      this.loadFromStorageAndRespond(A.id, e, t);
      return;
    }
    t.getKnownStateFromStorage((r) => {
      if (t.isAvailable()) {
        this.sendNewContent(A.id, e);
        return;
      }
      if (!r) {
        this.loadFromPeersAndRespond(A.id, e, t);
        return;
      }
      if (nB(r, o)) {
        e.trackToldKnownState(A.id), this.trySendToPeer(e, {
          action: "known",
          ...r
        });
        return;
      }
      this.loadFromStorageAndRespond(A.id, e, t);
    });
  }
  /**
   * Helper to load from storage and respond appropriately.
   * Falls back to peers if not found in storage.
   */
  loadFromStorageAndRespond(A, e, t) {
    t.loadFromStorage((o) => {
      o && t.isAvailable() ? this.sendNewContent(A, e) : this.loadFromPeersAndRespond(A, e, t);
    });
  }
  /**
   * Helper to load from peers and respond appropriately.
   */
  loadFromPeersAndRespond(A, e, t) {
    const o = this.getServerPeers(A, e.id);
    t.loadFromPeers(o);
    const r = () => {
      if (t.isAvailable()) {
        this.sendNewContent(A, e);
        return;
      }
      this.handleLoadNotFound(A, e);
    };
    o.length > 0 ? t.waitForAvailableOrUnavailable().then(r) : r();
  }
  /**
   * Handle case when CoValue is not found.
   */
  handleLoadNotFound(A, e) {
    e.trackToldKnownState(A), this.trySendToPeer(e, {
      action: "known",
      id: A,
      header: !1,
      sessions: {}
    });
  }
  /**
   * Request full content from a peer when we don't have the CoValue.
   */
  requestFullContent(A, e) {
    e ? this.trySendToPeer(e, {
      action: "known",
      isCorrection: !0,
      id: A,
      header: !1,
      sessions: {}
    }) : AA.error("Received new content with no header on a missing CoValue", {
      id: A
    });
  }
  handleKnownState(A, e) {
    const t = this.local.getCoValue(A.id);
    e.combineWith(A.id, Wo(A)), e.getOptimisticKnownState(A.id)?.header || t.markNotFoundInPeer(e.id), t.isAvailable() && this.sendNewContent(A.id, e), e.trackLoadRequestComplete(t);
  }
  recordTransactionsSize(A, e) {
    for (const t of A) {
      const o = ho(t);
      this.transactionsSizeHistogram.record(o, {
        source: e
      });
    }
  }
  handleNewContent(A, e) {
    const t = this.local.getCoValue(A.id), o = e === "storage" || e === "import" ? void 0 : e, r = e === "storage" ? "storage" : e === "import" ? "import" : o?.role;
    if (o?.role === "client" && A.expectContentUntil && (A = {
      ...A,
      expectContentUntil: void 0
    }), o?.trackLoadRequestUpdate(t), t.addDependenciesFromContentMessage(A), !this.skipVerify && t.hasMissingDependencies()) {
      t.addNewContentToQueue(A, e);
      for (const I of t.missingDependencies) {
        const C = this.local.getCoValue(I);
        if (!C.hasVerifiedContent()) {
          const c = this.getServerPeers(I);
          o?.role === "client" && c.push(o), C.load(c, "immediate");
        }
      }
      return;
    }
    if (t.hasVerifiedContent())
      A.expectContentUntil && t.verified.setStreamingKnownState(A.expectContentUntil);
    else {
      if (!A.header) {
        if (e === "storage") {
          AA.warn("Received content from storage without header - CoValue may have been garbage collected mid-stream", {
            id: A.id,
            from: e
          });
          return;
        }
        t.loadFromStorage((c) => {
          c ? this.handleNewContent(A, e) : this.requestFullContent(A.id, o);
        });
        return;
      }
      const I = t.loadingState;
      if (!t.provideHeader(A.header, A.expectContentUntil, this.skipVerify)) {
        AA.error("Failed to provide header", {
          id: A.id,
          header: A.header
        });
        return;
      }
      t.markFoundInPeer(o?.id ?? "storage", I), o?.updateHeader(A.id, !0), A.expectContentUntil && o?.combineWith(A.id, {
        id: A.id,
        header: !0,
        sessions: A.expectContentUntil
      });
    }
    if (!t.hasVerifiedContent())
      throw new Error("Unreachable: CoValue should always have a verified state at this point");
    let s = !1;
    const g = {
      action: "content",
      id: A.id,
      priority: A.priority,
      header: A.header,
      new: {}
    };
    let n = t.isDeleted;
    for (const [I, C] of cB(A)) {
      if (n && !Ke(I))
        continue;
      const c = CB(C, t.knownState(), I);
      if (c === void 0) {
        s = !0;
        continue;
      }
      if (c.length === 0)
        continue;
      const B = t.tryAddTransactions(I, c, C.lastSignature, this.skipVerify);
      if (B) {
        o ? (AA.error("Failed to add transactions", {
          peerId: o.id,
          peerRole: o.role,
          id: A.id,
          errorType: B.type,
          err: B.error,
          sessionID: I,
          msgKnownState: Ai(A).sessions,
          msgSummary: $o(A),
          knownState: t.knownState().sessions
        }), t.markErrored(o.id, B)) : AA.error("Failed to add transactions from storage", {
          id: A.id,
          err: B.error,
          sessionID: I,
          errorType: B.type
        });
        continue;
      }
      r && r !== "import" && this.recordTransactionsSize(c, r), !n && t.isDeleted && (n = !0, g.new = {}), g.new[I] = C;
    }
    o && (t.isDeleted ? o.combineWith(A.id, Ai(A)) : o.combineWith(A.id, Ai(g))), s ? o ? (this.trySendToPeer(o, {
      action: "known",
      isCorrection: !0,
      ...t.knownState()
    }), o.trackToldKnownState(A.id)) : AA.error("Invalid state assumed when handling new content from storage", {
      id: A.id,
      content: $o(A),
      knownState: t.knownState()
    }) : o && (t.isDeleted ? this.trySendToPeer(o, t.stopSyncingKnownStateMessage(o.getKnownState(A.id))) : this.trySendToPeer(o, {
      action: "known",
      ...t.knownState()
    }), o.trackToldKnownState(A.id));
    const a = g.header || Object.keys(g.new).length > 0;
    e !== "storage" && a && (this.storeContent(g), e === "import" && this.trackSyncState(t.id)), o?.trackLoadRequestComplete(t);
    for (const I of this.getPeers(t.id)) {
      if (I.closed || t.isErroredInPeer(I.id)) {
        I.emitCoValueChange(t.id);
        continue;
      }
      I.isCoValueSubscribedToPeer(t.id) ? this.sendNewContent(t.id, I) : I.role === "server" && I.sendLoadRequest(t);
    }
  }
  handleCorrection(A, e) {
    return e.setKnownState(A.id, Wo(A)), this.sendNewContent(A.id, e);
  }
  syncContent(A) {
    const e = this.local.getCoValue(A.id);
    this.storeContent(A), this.trackSyncState(e.id);
    const t = Ai(A);
    for (const o of this.getPeers(e.id))
      if (!(o.role === "client" && !o.isCoValueSubscribedToPeer(e.id))) {
        if (o.closed || e.isErroredInPeer(o.id)) {
          o.emitCoValueChange(A.id);
          continue;
        }
        this.trySendToPeer(o, A), o.combineOptimisticWith(e.id, t), o.trackToldKnownState(e.id);
      }
  }
  trackSyncState(A) {
    const e = this.getPersistentServerPeers(A);
    if (this.local.syncWhen !== "never" && e.length === 0) {
      this.unsyncedTracker.add(A);
      const o = this.syncState.subscribeToCoValueUpdates(A, (r, s, g) => {
        Ig(r) && g.uploaded && (this.unsyncedTracker.remove(A), o());
      });
      return;
    }
    for (const o of e) {
      if (this.syncState.isSynced(o, A) || this.unsyncedTracker.add(A, o.id))
        continue;
      const s = this.syncState.subscribeToPeerUpdates(o.id, A, (g, n) => {
        n.uploaded && (this.unsyncedTracker.remove(A, o.id), s());
      });
    }
  }
  storeContent(A) {
    const e = this.local.storage;
    if (!e)
      return;
    const t = this.local.getCoValue(A.id);
    t.isDeleted && e.markDeleteAsValid(t.id), e.store(A, (o) => {
      if (!t.verified) {
        AA.error("Correction requested for a CoValue with no verified content", {
          id: A.id,
          content: $o(A),
          correction: o,
          state: t.loadingState
        });
        return;
      }
      return t.newContentSince(o);
    });
  }
  /**
   * Returns true if the local CoValue changes have been synced to all persistent server peers.
   *
   * Used during garbage collection to determine if the coValue is pending sync.
   */
  isSyncedToServerPeers(A) {
    return this.getPersistentServerPeers(A).every((e) => this.syncState.isSynced(e, A));
  }
  waitForSyncWithPeer(A, e, t) {
    const o = this.peers[A];
    if (o) {
      if (o.isCoValueSubscribedToPeer(e)) {
        if (this.syncState.isSynced(o, e))
          return;
      } else if (o.role === "client")
        return;
      return new Promise((r, s) => {
        const g = this.syncState.subscribeToPeerUpdates(A, e, (a, I) => {
          I.uploaded && (r(!0), g?.(), clearTimeout(n));
        }), n = setTimeout(() => {
          const a = this.local.getCoValue(e), I = a.getErroredInPeerError(A), C = a.knownState().sessions, c = o.getKnownState(e)?.sessions ?? {};
          let B = `Timeout on waiting for sync with peer ${A} for coValue ${e}:
  Known state: ${JSON.stringify(C)}
  Peer state: ${JSON.stringify(c)}
`;
          I && (B += `
Marked as errored: "${I}"`), s(new Error(B)), g?.();
        }, t);
      });
    }
  }
  waitForStorageSync(A) {
    return this.local.storage?.waitForSync(A, this.local.getCoValue(A));
  }
  waitForSync(A, e = 6e4) {
    const t = this.getPeers(A);
    return Promise.all(t.map((o) => this.waitForSyncWithPeer(o.id, A, e)).concat(this.waitForStorageSync(A)));
  }
  waitForAllCoValuesSync(A = 6e4) {
    const e = this.local.allCoValues(), t = Array.from(e).filter((o) => o.loadingState === "available" || o.loadingState === "loading");
    return Promise.all(t.map((o) => this.waitForSync(o.id, A)));
  }
  setStorage(A) {
    this.unsyncedTracker.setStorage(A);
    const e = this.getStorageStreamingQueue();
    e && e.setListener(() => {
      this.processQueues();
    });
  }
  removeStorage() {
    this.unsyncedTracker.removeStorage();
  }
  /**
   * Closes all the peer connections and ensures the list of unsynced coValues is persisted to storage.
   * @returns Promise of the current pending store operation, if any.
   */
  gracefulShutdown() {
    for (const A of Object.values(this.peers))
      A.gracefulShutdown();
    return this.unsyncedTracker.forcePersist();
  }
}
let Ka = () => new Promise((i) => queueMicrotask(i));
typeof setImmediate == "function" && (Ka = () => new Promise((i) => setImmediate(i)));
function MB(i, A, { peer1role: e = "client", peer2role: t = "client", persistent: o = !1 } = {}) {
  const r = new Sr(), s = new Sr();
  return [{
    id: i,
    incoming: r,
    outgoing: s,
    role: e,
    persistent: o
  }, {
    id: A,
    incoming: s,
    outgoing: r,
    role: t,
    persistent: o
  }];
}
let Sr = class {
  constructor() {
    this.buffer = [], this.listeners = /* @__PURE__ */ new Set(), this.closed = !1, this.closeListeners = /* @__PURE__ */ new Set();
  }
  push(A) {
    if (!this.listeners.size) {
      this.buffer.push(A);
      return;
    }
    for (const e of this.listeners)
      e(A);
  }
  close() {
    this.closed = !0;
    for (const A of this.closeListeners)
      A();
    this.closeListeners.clear(), this.listeners.clear();
  }
  onMessage(A) {
    if (this.buffer.length) {
      for (const e of this.buffer)
        A(e);
      this.buffer = [];
    }
    this.listeners.add(A);
  }
  onClose(A) {
    this.closeListeners.add(A);
  }
};
class ke {
  /** @category 3. Low-level */
  constructor(A, e, t, o) {
    this.syncWhen = o, this.coValues = /* @__PURE__ */ new Map(), this.syncManager = new NB(this), this.garbageCollector = void 0, this.crashed = void 0, this.agentSecret = A, this.currentSessionID = e, this.crypto = t;
  }
  enableGarbageCollector() {
    this.garbageCollector || (this.garbageCollector = new hB(this));
  }
  setStorage(A) {
    this.storage = A, this.syncManager.setStorage(A);
  }
  removeStorage() {
    this.storage?.close(), this.storage = void 0, this.syncManager.removeStorage();
  }
  /**
   * Enable background erasure of deleted coValues (space reclamation).
   *
   * Deleted coValues are immediately blocked from syncing via tombstones; this feature
   * only reclaims local storage space by deleting historical content while preserving
   * the tombstone (header + delete session).
   *
   * This is opt-in and affects only the currently configured storage (if any)
   *
   * @category 3. Low-level
   */
  enableDeletedCoValuesErasure() {
    this.storage?.enableDeletedCoValuesErasure();
  }
  hasCoValue(A) {
    const e = this.coValues.get(A);
    if (!e)
      return !1;
    const t = e.loadingState;
    return t !== "unknown" && t !== "garbageCollected" && t !== "onlyKnownState";
  }
  getCoValue(A) {
    let e = this.coValues.get(A);
    return e || (e = new ng(A, this), this.coValues.set(A, e)), this.garbageCollector?.trackCoValueAccess(e), e;
  }
  allCoValues() {
    return this.coValues.values();
  }
  /**
   * Simple delete of a CoValue from memory.
   * Used for testing and forced cleanup scenarios.
   * @internal
   */
  internalDeleteCoValue(A) {
    this.coValues.delete(A), this.storage?.onCoValueUnmounted(A);
  }
  /**
   * Unmount a CoValue from memory, keeping a shell with cached knownState.
   * This enables accurate LOAD requests during peer reconciliation.
   *
   * @returns true if the coValue was successfully unmounted, false otherwise
   */
  internalUnmountCoValue(A) {
    const e = this.coValues.get(A);
    if (!e || e.listeners.size > 0)
      return !1;
    for (const r of e.dependant)
      if (this.hasCoValue(r))
        return !1;
    if (!this.syncManager.isSyncedToServerPeers(A))
      return !1;
    const t = e.knownState();
    e.decrementLoadingStateCounter();
    const o = new ng(A, this);
    return o.setGarbageCollectedState(t), this.coValues.set(A, o), this.storage?.onCoValueUnmounted(A), !0;
  }
  getCurrentAccountOrAgentID() {
    return TA(this.currentSessionID);
  }
  getCurrentAgent() {
    if (!this._cachedCurrentAgent) {
      const A = this.getCurrentAccountOrAgentID();
      $e(A) ? this._cachedCurrentAgent = new $s(this.agentSecret, this.crypto) : this._cachedCurrentAgent = new zc(Xs(this.expectCoValueLoaded(A).getCurrentContent()), this.agentSecret);
    }
    return this._cachedCurrentAgent;
  }
  expectCurrentAccountID(A) {
    const e = this.getCurrentAccountOrAgentID();
    if ($e(e))
      throw new Error("Current account is an agent, but expected an account: " + A);
    return e;
  }
  expectCurrentAccount(A) {
    const e = this.expectCurrentAccountID(A);
    return Xs(this.expectCoValueLoaded(e).getCurrentContent());
  }
  static internalCreateAccount(A) {
    const { crypto: e, initialAgentSecret: t = e.newRandomAgentSecret(), peers: o = [], syncWhen: r } = A, s = Da(t, e), g = Ut(s, e), n = new ke(t, e.newRandomSessionID(g), e, r);
    A.storage && n.setStorage(A.storage);
    for (const B of o)
      n.syncManager.addPeer(B);
    const a = e.getAgentID(t), I = FA(n.createCoValue(s).getCurrentContent());
    I.set(a, "admin", "trusting");
    const C = e.newRandomKeySecret(), c = e.seal({
      message: C.secret,
      from: e.getAgentSealerSecret(t),
      to: e.getAgentSealerID(a),
      nOnceMaterial: {
        in: I.id,
        tx: I.core.nextTransactionID()
      }
    });
    return I.set(`${C.id}_for_${a}`, c, "trusting"), I.set("readKey", C.id, "trusting"), n.expectCurrentAccount("after creation");
  }
  /** @category 2. Node Creation */
  static async withNewlyCreatedAccount({ creationProps: A, peers: e, syncWhen: t, migration: o, crypto: r, initialAgentSecret: s = r.newRandomAgentSecret(), storage: g }) {
    const n = ke.internalCreateAccount({
      crypto: r,
      initialAgentSecret: s,
      peers: e,
      syncWhen: t,
      storage: g
    }), a = n.core.node;
    if (o)
      await o(n, a, A);
    else {
      const C = a.createGroup();
      C.addMember("everyone", "reader");
      const c = C.createMap({
        name: A.name
      });
      n.set("profile", c.id, "trusting");
    }
    const I = n.get("profile");
    if (!I)
      throw new Error("Must set account profile in initial migration");
    return a.storage && await Promise.all([
      a.syncManager.waitForStorageSync(n.id),
      a.syncManager.waitForStorageSync(I)
    ]), {
      node: a,
      accountID: n.id,
      accountSecret: s,
      sessionID: a.currentSessionID
    };
  }
  /** @category 2. Node Creation */
  static async withLoadedAccount({ accountID: A, accountSecret: e, sessionID: t, peers: o, syncWhen: r, crypto: s, migration: g, storage: n }) {
    try {
      const a = s.getAgentID(e), I = new ke(e, t || s.newRandomSessionID(A), s, r);
      n && I.setStorage(n);
      for (const Q of o)
        I.syncManager.addPeer(Q);
      const C = await I.load(A);
      if (C === "unavailable")
        throw new Error("Account unavailable from all peers");
      if (C.currentAgentID() !== a)
        throw new Error("Account secret does not match expected agent ID in account");
      const c = C.get("profile");
      if (!c)
        throw new Error("Account has no profile");
      const B = C.get("root");
      return B && (C.getRaw("root")?.trusting || C.set("root", B, "trusting")), await I.load(c), g && await g(C, I), I;
    } catch (a) {
      throw AA.error("Error withLoadedAccount", { err: a }), a;
    }
  }
  /** @internal */
  createCoValue(A) {
    if (this.crashed)
      throw new Error("Trying to create CoValue after node has crashed", {
        cause: this.crashed
      });
    const e = Ut(A, this.crypto), t = this.getCoValue(e);
    if (t.provideHeader(A), !t.hasVerifiedContent())
      throw new Error("CoValue not available after providing header");
    return this.garbageCollector?.trackCoValueAccess(t), this.syncManager.syncLocalTransaction(t.verified, ve(e)), t;
  }
  /** @internal */
  async loadCoValueCore(A, e, t) {
    if (!Ea(A))
      throw new TypeError(`Trying to load CoValue with invalid id ${Array.isArray(A) ? JSON.stringify(A) : A}`);
    if (this.crashed)
      throw new Error("Trying to load CoValue after node has crashed", {
        cause: this.crashed
      });
    let o = 0;
    for (; ; ) {
      const r = this.getCoValue(A);
      if (r.isAvailable())
        return r;
      if (r.loadingState === "unknown" || r.loadingState === "unavailable" || r.loadingState === "garbageCollected" || r.loadingState === "onlyKnownState") {
        const g = this.syncManager.getServerPeers(A, e);
        if (!this.storage && g.length === 0)
          return r.markNotFoundInPeer("storage"), r;
        r.load(g);
      }
      const s = await r.waitForAvailableOrUnavailable();
      if (s.isAvailable() || t || o >= Xe.MAX_RETRIES)
        return s;
      await Promise.race([
        new Promise((g) => setTimeout(g, Xe.RETRY_DELAY)),
        r.waitForAvailable()
        // Stop waiting if the coValue becomes available
      ]), o++;
    }
  }
  /**
   * Loads a CoValue's content, syncing from peers as necessary and resolving the returned
   * promise once a first version has been loaded. See `coValue.subscribe()` and `node.useTelepathicData()`
   * for listening to subsequent updates to the CoValue.
   *
   * @category 3. Low-level
   */
  async load(A, e) {
    const t = await this.loadCoValueCore(A, void 0, e);
    return t.isAvailable() ? t.getCurrentContent() : "unavailable";
  }
  /**
   * Loads a branch from a group coValue, creating a new one if it doesn't exist.
   *
   * Returns "unavailable" in case of errors or missing source.
   */
  async checkoutBranch(A, e, t) {
    const o = await this.loadCoValueCore(A);
    if (!o.isAvailable())
      return "unavailable";
    if (!Fa(o))
      return o.getCurrentContent();
    const r = o.getBranch(e, t);
    return r.isAvailable() ? r.getCurrentContent() : !o.hasBranch(e, t) || (await this.loadCoValueCore(r.id), !r.isAvailable()) ? o.createBranch(e, t).getCurrentContent() : r.getCurrentContent();
  }
  getLoaded(A) {
    const e = this.getCoValue(A);
    if (e.isAvailable())
      return e.getCurrentContent();
  }
  /** @category 3. Low-level */
  subscribe(A, e, t) {
    let o = !1, r;
    return this.load(A, t).then((s) => {
      if (!o) {
        if (s === "unavailable") {
          e("unavailable");
          return;
        }
        r = s.subscribe(e);
      }
    }).catch((s) => {
      AA.error("Subscription error", {
        id: A,
        err: s
      });
    }), () => {
      o = !0, r?.();
    };
  }
  async acceptInvite(A, e) {
    const t = await this.load(A);
    if (t === "unavailable")
      throw new Error("Trying to accept invite: Group/owned value unavailable from all peers");
    const o = t.core.verified.header.ruleset;
    let r;
    if (o.type === "unsafeAllowAll")
      throw new Error("Can only accept invites to values owned by groups");
    if (o.type === "ownedByGroup") {
      const Q = await this.load(o.group);
      if (Q === "unavailable")
        throw new Error("Trying to accept invite: CoValue owner unavailable from all peers");
      r = FA(Q);
    } else
      r = FA(t);
    if (r.core.verified.header.meta?.type === "account")
      throw new Error("Can't accept invites to values owned by accounts");
    const s = this.crypto.agentSecretFromSecretSeed(Wc(e)), g = this.crypto.getAgentID(s), n = await new Promise((Q, f) => {
      r.subscribe((l) => {
        const d = l.get(g);
        d && Q(d);
      }), setTimeout(() => f(new Error("Couldn't find invite before timeout")), 2e3);
    });
    if (!n)
      throw new Error("No invite found");
    const a = this.getCurrentAgent(), I = r.get(a.id);
    if (I === "admin" || I === "writer" && n === "writerInvite" || I === "writer" && n === "reader" || I === "reader" && n === "readerInvite" || I && n === "writeOnlyInvite") {
      AA.debug("Not accepting invite that would replace or downgrade role");
      return;
    }
    const C = await this.loadCoValueAsDifferentAgent(r.id, s), c = FA(C.getCurrentContent());
    c.addMemberInternal(a, n === "adminInvite" ? "admin" : n === "managerInvite" ? "manager" : n === "writerInvite" ? "writer" : n === "writeOnlyInvite" ? "writeOnly" : "reader");
    const B = c.core.newContentSince(r.core.knownState()) ?? [];
    for (const Q of B)
      this.syncManager.handleNewContent(Q, "import");
  }
  /** @internal */
  expectCoValueLoaded(A, e) {
    const t = this.getCoValue(A);
    if (!t.isAvailable())
      throw new Error(`${e ? e + ": " : ""}CoValue ${A} not yet loaded.`);
    return t;
  }
  /** @internal */
  expectProfileLoaded(A, e) {
    const t = this.expectCoValueLoaded(A, e), o = FA(t.getCurrentContent()).get("profile");
    if (!o)
      throw new Error(`${e ? e + ": " : ""}Account ${A} has no profile`);
    return this.expectCoValueLoaded(o, e).getCurrentContent();
  }
  /** @internal */
  resolveAccountAgent(A, e) {
    if ($e(A))
      return { value: A, error: void 0 };
    let t;
    try {
      t = this.expectCoValueLoaded(A, e);
    } catch (r) {
      return { value: void 0, error: r };
    }
    if (t.verified.header.type !== "comap" || t.verified.header.ruleset.type !== "group" || !t.verified.header.meta || !("type" in t.verified.header.meta) || t.verified.header.meta.type !== "account")
      return {
        value: void 0,
        error: new Error(`Unexpectedly not account: ${e}`)
      };
    const o = t.verified.header.ruleset.initialAdmin;
    return $e(o) ? { value: o, error: void 0 } : {
      value: void 0,
      error: new Error(`Unexpectedly not account: ${e}`)
    };
  }
  createGroup(A = this.crypto.createdNowUnique()) {
    const e = this.getCurrentAgent(), t = this.createCoValue({
      type: "comap",
      ruleset: { type: "group", initialAdmin: e.id },
      meta: null,
      ...A.createdAt !== void 0 ? { createdAt: A.createdAt } : {},
      uniqueness: A.uniqueness
    }), o = FA(t.getCurrentContent());
    o.set(e.id, "admin", "trusting");
    const r = this.crypto.newRandomKeySecret();
    return o.set(`${r.id}_for_${e.id}`, this.crypto.seal({
      message: r.secret,
      from: e.currentSealerSecret(),
      to: e.currentSealerID(),
      nOnceMaterial: {
        in: t.id,
        tx: t.nextTransactionID()
      }
    }), "trusting"), o.set("readKey", r.id, "trusting"), o;
  }
  async loadCoValueAsDifferentAgent(A, e, t) {
    const o = new $s(e, this.crypto), r = new ke(e, this.crypto.newRandomSessionID(t || o.id), this.crypto);
    return await r.loadVerifiedStateFrom(this, A), r.expectCoValueLoaded(A);
  }
  /** @internal */
  async loadVerifiedStateFrom(A, e) {
    const t = MB("source-" + e, "target-" + e, {
      peer1role: "server",
      peer2role: "client"
    });
    this.syncManager.addPeer(t[0], !0), A.syncManager.addPeer(t[1], !0);
    const o = this.getCoValue(e), r = this.syncManager.peers[t[0].id];
    if (!r)
      throw new Error("Peer state not found");
    o.loadFromPeers([r]), await o.waitForAvailable(), r.gracefulShutdown();
  }
  /**
   * Closes all the peer connections, drains all the queues and closes the storage.
   *
   * @returns Promise of the current pending store operation, if any.
   */
  async gracefulShutdown() {
    return this.garbageCollector?.stop(), await this.syncManager.gracefulShutdown(), this.storage?.close();
  }
}
function kB({ newTxsInSession: i, contentMessage: A, sessionRow: e, firstNewTxIdx: t, signature: o }) {
  let r = A.new[e.sessionID];
  r ? r.lastSignature = o : (r = {
    after: t,
    lastSignature: o,
    newTransactions: []
  }, A.new[e.sessionID] = r);
  for (const s of i)
    r.newTransactions.push(s.tx);
}
function GB(i, A) {
  const e = A.id, t = Object.keys(A.new), o = Object.values(A.new).map((r) => r.newTransactions);
  return rB(e, i, t, o);
}
function FB(i) {
  return i.reduce((A, e) => A + ho(e), 0);
}
const RB = {
  [OA.HIGH]: 0,
  [OA.MEDIUM]: 1,
  [OA.LOW]: 2
};
class bB {
  constructor(A, e, t) {
    this.defaultPriority = A, this.queues = [
      Gt(e, { priority: OA.HIGH, ...t }),
      Gt(e, { priority: OA.MEDIUM, ...t }),
      Gt(e, { priority: OA.LOW, ...t })
    ];
  }
  getQueue(A) {
    return this.queues[RB[A]];
  }
  push(A) {
    const e = "priority" in A ? A.priority : this.defaultPriority;
    this.getQueue(e).push(A);
  }
  pull() {
    const A = this.queues.findIndex((e) => e.length > 0);
    return this.queues[A]?.shift();
  }
}
var vt;
(function(i) {
  i[i.Pending = 0] = "Pending", i[i.Done = 1] = "Done";
})(vt || (vt = {}));
class KB {
  constructor() {
    this.knownStates = /* @__PURE__ */ new Map(), this.waitForSyncRequests = /* @__PURE__ */ new Map();
  }
  getKnownState(A) {
    const e = this.knownStates.get(A);
    if (!e) {
      const t = ve(A);
      return this.knownStates.set(A, t), t;
    }
    return e;
  }
  /**
   * Get a cached knownState if it exists and has a header.
   * Unlike getKnownState, this doesn't create an empty state if one doesn't exist.
   */
  getCachedKnownState(A) {
    const e = this.knownStates.get(A);
    if (e?.header)
      return e;
  }
  setKnownState(A, e) {
    this.knownStates.set(A, e);
  }
  handleUpdate(A, e) {
    const t = this.waitForSyncRequests.get(A);
    if (t)
      for (const o of t)
        Cg(o.knownState, e) && (o.resolve(), t.delete(o));
  }
  waitForSync(A, e) {
    const t = e.knownState();
    if (Cg(t, this.getKnownState(A)))
      return Promise.resolve();
    const o = this.waitForSyncRequests.get(A) || /* @__PURE__ */ new Set();
    return this.waitForSyncRequests.set(A, o), new Promise((r) => {
      const s = e.subscribe((a) => {
        n.knownState = a.knownState(), this.handleUpdate(A, this.getKnownState(A));
      }, !1), n = { knownState: t, resolve: () => {
        r(), s();
      } };
      o.add(n);
    });
  }
}
function Cg(i, A) {
  return !A.header && i.header ? !1 : Ma(i.sessions, A.sessions);
}
const YB = {
  throttleMs: 6e4,
  startupDelayMs: 1e3,
  followUpDelayMs: 1e3
};
class UB {
  isDisposed() {
    return this.state === "disposed";
  }
  constructor({ run: A, opts: e }) {
    this.state = "idle", this.runCallback = A, this.opts = e || YB;
  }
  scheduleStartupDrain() {
    this.isDisposed() || this.state === "idle" && this.scheduleTimer("startup_scheduled", this.opts.startupDelayMs);
  }
  onEnqueueDeletedCoValue() {
    this.isDisposed() || this.state === "idle" && this.scheduleTimer("throttle_scheduled", this.opts.throttleMs);
  }
  dispose() {
    this.isDisposed() || (this.state = "disposed", this.scheduledTimeout && clearTimeout(this.scheduledTimeout), this.scheduledTimeout = void 0);
  }
  scheduleTimer(A, e) {
    this.isDisposed() || this.scheduledTimeout || (this.state = A, this.scheduledTimeout = setTimeout(() => {
      this.scheduledTimeout = void 0, this.run();
    }, e));
  }
  async run() {
    if (this.isDisposed())
      return;
    this.state = "running";
    let A;
    try {
      A = await this.runCallback();
    } catch (e) {
      AA.error("Error running deleted co values eraser scheduler", {
        err: e
      }), this.isDisposed() || (this.state = "idle");
      return;
    }
    if (!this.isDisposed()) {
      if (A.hasMore) {
        this.scheduleTimer("followup_scheduled", this.opts.followUpDelayMs);
        return;
      }
      this.state = "idle";
    }
  }
}
class vB {
  constructor() {
    this.backlog = new wo(), this.processing = !1;
  }
  async schedule(A, e) {
    if (this.backlog.push({ queue: A, callback: e }), !this.processing) {
      for (this.processing = !0; this.backlog.head; )
        await this.backlog.head.value.callback(), this.backlog.shift();
      this.processing = !1;
    }
  }
}
class po {
  constructor() {
    this.queue = new wo(), this.closed = !1, this.processing = !1;
  }
  push(A, e) {
    this.closed || this.queue.push({ data: A, correctionCallback: e });
  }
  pull() {
    return this.queue.shift();
  }
  processQueue(A) {
    if (!this.processing)
      return this.processing = !0, po.manager.schedule(this, async () => {
        let e;
        for (; e = this.pull(); ) {
          const { data: t, correctionCallback: o } = e;
          try {
            this.lastCallback = A(t, o), await this.lastCallback;
          } catch (r) {
            AA.error("Error processing message in store queue", { err: r });
          }
        }
        this.lastCallback = void 0, this.processing = !1;
      });
  }
  close() {
    for (this.closed = !0; this.pull(); )
      ;
    return this.lastCallback;
  }
}
po.manager = new vB();
class Ya {
  constructor(A) {
    this.inMemoryCoValues = /* @__PURE__ */ new Set(), this.pendingKnownStateLoads = /* @__PURE__ */ new Map(), this.knownStates = new KB(), this.storeQueue = new po(), this.deletedValues = /* @__PURE__ */ new Set(), this.dbClient = A;
  }
  getKnownState(A) {
    return this.knownStates.getKnownState(A);
  }
  loadKnownState(A, e) {
    const t = this.knownStates.getCachedKnownState(A);
    if (t) {
      e(t);
      return;
    }
    const o = this.pendingKnownStateLoads.get(A);
    if (o) {
      o.then(e, () => e(void 0));
      return;
    }
    const r = this.dbClient.getCoValueKnownState(A).then((s) => (s && this.knownStates.setKnownState(A, s), s)).catch((s) => {
      AA.warn("Failed to load knownState from storage", { id: A, err: s });
    }).finally(() => {
      this.pendingKnownStateLoads.delete(A);
    });
    this.pendingKnownStateLoads.set(A, r), r.then(e);
  }
  async load(A, e, t) {
    await this.loadCoValue(A, e, t);
  }
  async loadCoValue(A, e, t) {
    this.interruptEraser("load");
    const o = await this.dbClient.getCoValue(A);
    if (!o) {
      t?.(!1);
      return;
    }
    const r = await this.dbClient.getCoValueSessions(o.rowID), s = /* @__PURE__ */ new Map();
    let g = !1;
    await Promise.all(r.map(async (C) => {
      const c = await this.dbClient.getSignatures(C.rowID, 0);
      c.length > 0 && (g = !0, s.set(C.sessionID, c));
    }));
    const n = this.knownStates.getKnownState(o.id);
    n.header = !0;
    for (const C of r)
      Zo(n.sessions, C.sessionID, C.lastIdx);
    this.inMemoryCoValues.add(o.id);
    let a = kt(o.id, o.header);
    g && (a.expectContentUntil = n.sessions);
    for (const C of r) {
      const c = s.get(C.sessionID) || [];
      let B = 0;
      c[c.length - 1]?.signature !== C.lastSignature && c.push({
        idx: C.lastIdx,
        signature: C.lastSignature
      });
      for (const f of c) {
        const l = await this.dbClient.getNewTransactionInSession(C.rowID, B, f.idx);
        kB({
          newTxsInSession: l,
          contentMessage: a,
          sessionRow: C,
          firstNewTxIdx: B,
          signature: f.signature
        }), B = f.idx + 1, c.length > 1 && (await this.pushContentWithDependencies(o, a, e), a = kt(o.id, o.header));
      }
    }
    (Object.keys(a.new).length > 0 || !g) && await this.pushContentWithDependencies(o, a, e), this.knownStates.handleUpdate(o.id, n), t?.(!0);
  }
  async pushContentWithDependencies(A, e, t) {
    const o = GB(A.header, e), r = [];
    for (const s of o)
      this.inMemoryCoValues.has(s) || r.push(new Promise((g) => {
        this.loadCoValue(s, t, g);
      }));
    await Promise.all(r), t(e);
  }
  async store(A, e) {
    this.storeQueue.push(A, e), this.storeQueue.processQueue(async (t, o) => (this.interruptEraser("store"), this.storeSingle(t, o)));
  }
  interruptEraser(A) {
    this.eraserController && (this.eraserController.abort(A), this.eraserController = void 0);
  }
  async eraseAllDeletedCoValues() {
    const A = await this.dbClient.getAllCoValuesWaitingForDelete();
    this.eraserController = new AbortController();
    const e = this.eraserController.signal;
    for (const t of A) {
      if (e.aborted)
        return;
      await this.dbClient.eraseCoValueButKeepTombstone(t);
    }
  }
  /**
   * This function is called when the storage lacks the information required to store the incoming content.
   *
   * It triggers a `correctionCallback` to ask the syncManager to provide the missing information.
   *
   * The correction is applied immediately, to ensure that, when applicable, the dependent content in the queue won't require additional corrections.
   */
  async handleCorrection(A, e) {
    const t = e(A);
    if (!t)
      return AA.error("Correction callback returned undefined", {
        knownState: A,
        correction: t ?? null
      }), !1;
    for (const o of t)
      if (!await this.storeSingle(o, (s) => {
        AA.error("Double correction requested", {
          msg: o,
          knownState: s
        });
      }))
        return !1;
    return !0;
  }
  async storeSingle(A, e) {
    if (this.interruptEraser("store"), this.storeQueue.closed)
      return !1;
    const t = A.id, o = await this.dbClient.upsertCoValue(t, A.header);
    if (!o) {
      const g = ve(t);
      return this.knownStates.setKnownState(t, g), this.handleCorrection(g, e);
    }
    const r = this.knownStates.getKnownState(t);
    r.header = !0;
    let s = !1;
    for (const g of Object.keys(A.new))
      await this.dbClient.transaction(async (n) => {
        const a = await n.getSingleCoValueSession(o, g);
        this.deletedValues.has(t) && Ke(g) && await n.markCoValueAsDeleted(t), a && Zo(r.sessions, a.sessionID, a.lastIdx);
        const I = a?.lastIdx || 0, C = A.new[g]?.after || 0;
        if (I < C)
          s = !0;
        else {
          const c = await this.putNewTxs(n, A, g, a, o);
          Zo(r.sessions, g, c);
        }
      });
    return this.inMemoryCoValues.add(t), this.knownStates.handleUpdate(t, r), s ? this.handleCorrection(r, e) : !0;
  }
  async putNewTxs(A, e, t, o, r) {
    const s = e.new[t]?.newTransactions || [], g = o?.lastIdx || 0, n = g - (e.new[t]?.after || 0), a = s.slice(n);
    if (a.length === 0)
      return g;
    let I = o?.bytesSinceLastSignature || 0;
    const C = FB(a), c = g + a.length;
    let B = !1;
    Io(I, C) ? (B = !0, I = 0) : I += C;
    const Q = g;
    if (!e.new[t])
      throw new Error("Session ID not found");
    const f = {
      coValue: r,
      sessionID: t,
      lastIdx: c,
      lastSignature: e.new[t].lastSignature,
      bytesSinceLastSignature: I
    }, l = await A.addSessionUpdate({
      sessionUpdate: f,
      sessionRow: o
    });
    return B && await A.addSignatureAfter({
      sessionRowID: l,
      idx: c - 1,
      signature: e.new[t].lastSignature
    }), await Promise.all(a.map((d, u) => A.addTransaction(l, Q + u, d))), c;
  }
  markDeleteAsValid(A) {
    this.deletedValues.add(A), this.deletedCoValuesEraserScheduler && this.deletedCoValuesEraserScheduler.onEnqueueDeletedCoValue();
  }
  enableDeletedCoValuesErasure() {
    this.deletedCoValuesEraserScheduler || (this.deletedCoValuesEraserScheduler = new UB({
      run: async () => (await this.eraseAllDeletedCoValues(), { hasMore: (await this.dbClient.getAllCoValuesWaitingForDelete()).length > 0 })
    }), this.deletedCoValuesEraserScheduler.scheduleStartupDrain());
  }
  waitForSync(A, e) {
    return this.knownStates.waitForSync(A, e);
  }
  trackCoValuesSyncState(A, e) {
    this.dbClient.trackCoValuesSyncState(A).then(() => e?.());
  }
  getUnsyncedCoValueIDs(A) {
    this.dbClient.getUnsyncedCoValueIDs().then(A);
  }
  stopTrackingSyncState(A) {
    this.dbClient.stopTrackingSyncState(A);
  }
  onCoValueUnmounted(A) {
    this.inMemoryCoValues.delete(A);
  }
  close() {
    return this.deletedCoValuesEraserScheduler?.dispose(), this.inMemoryCoValues.clear(), this.storeQueue.close();
  }
}
const Is = {
  accountHeaderForInitialAgentSecret: Da,
  idforHeader: Ut,
  CO_VALUE_PRIORITY: OA,
  ConnectedPeerChannel: Sr,
  getContentMessageSize: IB,
  WEBSOCKET_CONFIG: tB
};
let v, tA = 0, mt = null;
function et() {
  return (mt === null || mt.byteLength === 0) && (mt = new Uint8Array(v.memory.buffer)), mt;
}
const io = typeof TextEncoder < "u" ? new TextEncoder("utf-8") : { encode: () => {
  throw Error("TextEncoder not available");
} }, JB = typeof io.encodeInto == "function" ? function(i, A) {
  return io.encodeInto(i, A);
} : function(i, A) {
  const e = io.encode(i);
  return A.set(e), {
    read: i.length,
    written: e.length
  };
};
function cA(i, A, e) {
  if (e === void 0) {
    const g = io.encode(i), n = A(g.length, 1) >>> 0;
    return et().subarray(n, n + g.length).set(g), tA = g.length, n;
  }
  let t = i.length, o = A(t, 1) >>> 0;
  const r = et();
  let s = 0;
  for (; s < t; s++) {
    const g = i.charCodeAt(s);
    if (g > 127) break;
    r[o + s] = g;
  }
  if (s !== t) {
    s !== 0 && (i = i.slice(s)), o = e(o, t, t = s + i.length * 3, 1) >>> 0;
    const g = et().subarray(o + s, o + t), n = JB(i, g);
    s += n.written, o = e(o, t, s, 1) >>> 0;
  }
  return tA = s, o;
}
let De = null;
function ei() {
  return (De === null || De.buffer.detached === !0 || De.buffer.detached === void 0 && De.buffer !== v.memory.buffer) && (De = new DataView(v.memory.buffer)), De;
}
function St(i) {
  const A = v.__externref_table_alloc();
  return v.__wbindgen_export_4.set(A, i), A;
}
function Qt(i, A) {
  try {
    return i.apply(this, A);
  } catch (e) {
    const t = St(e);
    v.__wbindgen_exn_store(t);
  }
}
const Ua = typeof TextDecoder < "u" ? new TextDecoder("utf-8", { ignoreBOM: !0, fatal: !0 }) : { decode: () => {
  throw Error("TextDecoder not available");
} };
typeof TextDecoder < "u" && Ua.decode();
function VA(i, A) {
  return i = i >>> 0, Ua.decode(et().subarray(i, i + A));
}
function ne(i) {
  return i == null;
}
function Nr(i) {
  const A = typeof i;
  if (A == "number" || A == "boolean" || i == null)
    return `${i}`;
  if (A == "string")
    return `"${i}"`;
  if (A == "symbol") {
    const o = i.description;
    return o == null ? "Symbol" : `Symbol(${o})`;
  }
  if (A == "function") {
    const o = i.name;
    return typeof o == "string" && o.length > 0 ? `Function(${o})` : "Function";
  }
  if (Array.isArray(i)) {
    const o = i.length;
    let r = "[";
    o > 0 && (r += Nr(i[0]));
    for (let s = 1; s < o; s++)
      r += ", " + Nr(i[s]);
    return r += "]", r;
  }
  const e = /\[object ([^\]]+)\]/.exec(toString.call(i));
  let t;
  if (e && e.length > 1)
    t = e[1];
  else
    return toString.call(i);
  if (t == "Object")
    try {
      return "Object(" + JSON.stringify(i) + ")";
    } catch {
      return "Object";
    }
  return i instanceof Error ? `${i.name}: ${i.message}
${i.stack}` : t;
}
function GA(i) {
  const A = v.__wbindgen_export_4.get(i);
  return v.__externref_table_dealloc(i), A;
}
function DA(i, A) {
  const e = A(i.length * 1, 1) >>> 0;
  return et().set(i, e / 1), tA = i.length, e;
}
function le(i, A) {
  return i = i >>> 0, et().subarray(i / 1, i / 1 + A);
}
function HB() {
  const i = v.newEd25519SigningKey();
  var A = le(i[0], i[1]).slice();
  return v.__wbindgen_free(i[0], i[1] * 1, 1), A;
}
function qB(i) {
  let A, e;
  try {
    const r = DA(i, v.__wbindgen_malloc), s = tA, g = v.getSignerId(r, s);
    var t = g[0], o = g[1];
    if (g[3])
      throw t = 0, o = 0, GA(g[2]);
    return A = t, e = o, VA(t, o);
  } finally {
    v.__wbindgen_free(A, e, 1);
  }
}
function LB(i, A) {
  let e, t;
  try {
    const s = DA(i, v.__wbindgen_malloc), g = tA, n = DA(A, v.__wbindgen_malloc), a = tA, I = v.sign(s, g, n, a);
    var o = I[0], r = I[1];
    if (I[3])
      throw o = 0, r = 0, GA(I[2]);
    return e = o, t = r, VA(o, r);
  } finally {
    v.__wbindgen_free(e, t, 1);
  }
}
function xB(i, A, e) {
  const t = DA(i, v.__wbindgen_malloc), o = tA, r = DA(A, v.__wbindgen_malloc), s = tA, g = DA(e, v.__wbindgen_malloc), n = tA, a = v.verify(t, o, r, s, g, n);
  if (a[2])
    throw GA(a[1]);
  return a[0] !== 0;
}
function OB(i) {
  const A = DA(i, v.__wbindgen_malloc), e = tA, t = v.blake3HashOnce(A, e);
  var o = le(t[0], t[1]).slice();
  return v.__wbindgen_free(t[0], t[1] * 1, 1), o;
}
function TB(i, A) {
  const e = DA(i, v.__wbindgen_malloc), t = tA, o = DA(A, v.__wbindgen_malloc), r = tA, s = v.blake3HashOnceWithContext(e, t, o, r);
  var g = le(s[0], s[1]).slice();
  return v.__wbindgen_free(s[0], s[1] * 1, 1), g;
}
function PB(i, A, e, t) {
  const o = DA(i, v.__wbindgen_malloc), r = tA, s = cA(A, v.__wbindgen_malloc, v.__wbindgen_realloc), g = tA, n = cA(e, v.__wbindgen_malloc, v.__wbindgen_realloc), a = tA, I = DA(t, v.__wbindgen_malloc), C = tA, c = v.unseal(o, r, s, g, n, a, I, C);
  if (c[3])
    throw GA(c[2]);
  var B = le(c[0], c[1]).slice();
  return v.__wbindgen_free(c[0], c[1] * 1, 1), B;
}
function jB(i, A, e, t) {
  const o = DA(i, v.__wbindgen_malloc), r = tA, s = cA(A, v.__wbindgen_malloc, v.__wbindgen_realloc), g = tA, n = cA(e, v.__wbindgen_malloc, v.__wbindgen_realloc), a = tA, I = DA(t, v.__wbindgen_malloc), C = tA, c = v.seal(o, r, s, g, n, a, I, C);
  if (c[3])
    throw GA(c[2]);
  var B = le(c[0], c[1]).slice();
  return v.__wbindgen_free(c[0], c[1] * 1, 1), B;
}
function VB(i, A, e) {
  const t = DA(i, v.__wbindgen_malloc), o = tA, r = cA(A, v.__wbindgen_malloc, v.__wbindgen_realloc), s = tA, g = DA(e, v.__wbindgen_malloc), n = tA, a = v.encrypt(t, o, r, s, g, n);
  if (a[3])
    throw GA(a[2]);
  var I = le(a[0], a[1]).slice();
  return v.__wbindgen_free(a[0], a[1] * 1, 1), I;
}
function WB(i, A, e) {
  const t = DA(i, v.__wbindgen_malloc), o = tA, r = cA(A, v.__wbindgen_malloc, v.__wbindgen_realloc), s = tA, g = DA(e, v.__wbindgen_malloc), n = tA, a = v.decrypt(t, o, r, s, g, n);
  if (a[3])
    throw GA(a[2]);
  var I = le(a[0], a[1]).slice();
  return v.__wbindgen_free(a[0], a[1] * 1, 1), I;
}
function zB(i) {
  let A, e;
  try {
    const r = DA(i, v.__wbindgen_malloc), s = tA, g = v.getSealerId(r, s);
    var t = g[0], o = g[1];
    if (g[3])
      throw t = 0, o = 0, GA(g[2]);
    return A = t, e = o, VA(t, o);
  } finally {
    v.__wbindgen_free(A, e, 1);
  }
}
function ZB() {
  const i = v.newX25519PrivateKey();
  var A = le(i[0], i[1]).slice();
  return v.__wbindgen_free(i[0], i[1] * 1, 1), A;
}
typeof FinalizationRegistry > "u" || new FinalizationRegistry((i) => v.__wbg_blake3hasher_free(i >>> 0, 1));
const Ar = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((i) => v.__wbg_sessionlog_free(i >>> 0, 1));
class Co {
  static __wrap(A) {
    A = A >>> 0;
    const e = Object.create(Co.prototype);
    return e.__wbg_ptr = A, Ar.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const A = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Ar.unregister(this), A;
  }
  free() {
    const A = this.__destroy_into_raw();
    v.__wbg_sessionlog_free(A, 0);
  }
  /**
   * Commit pending transactions to the main state.
   * If skip_validate is false, validates the signature first.
   * If skip_validate is true, commits without validation.
   * @param {string} new_signature_str
   * @param {boolean} skip_validate
   */
  commitTransactions(A, e) {
    const t = cA(A, v.__wbindgen_malloc, v.__wbindgen_realloc), o = tA, r = v.sessionlog_commitTransactions(this.__wbg_ptr, t, o, e);
    if (r[1])
      throw GA(r[0]);
  }
  /**
   * @param {string} changes_json
   * @param {string} signer_secret
   * @param {string} encryption_key
   * @param {string} key_id
   * @param {number} made_at
   * @param {string | null} [meta]
   * @returns {string}
   */
  addNewPrivateTransaction(A, e, t, o, r, s) {
    let g, n;
    try {
      const B = cA(A, v.__wbindgen_malloc, v.__wbindgen_realloc), Q = tA, f = cA(e, v.__wbindgen_malloc, v.__wbindgen_realloc), l = tA, d = cA(t, v.__wbindgen_malloc, v.__wbindgen_realloc), u = tA, h = cA(o, v.__wbindgen_malloc, v.__wbindgen_realloc), w = tA;
      var a = ne(s) ? 0 : cA(s, v.__wbindgen_malloc, v.__wbindgen_realloc), I = tA;
      const E = v.sessionlog_addNewPrivateTransaction(this.__wbg_ptr, B, Q, f, l, d, u, h, w, r, a, I);
      var C = E[0], c = E[1];
      if (E[3])
        throw C = 0, c = 0, GA(E[2]);
      return g = C, n = c, VA(C, c);
    } finally {
      v.__wbindgen_free(g, n, 1);
    }
  }
  /**
   * @param {string} changes_json
   * @param {string} signer_secret
   * @param {number} made_at
   * @param {string | null} [meta]
   * @returns {string}
   */
  addNewTrustingTransaction(A, e, t, o) {
    let r, s;
    try {
      const C = cA(A, v.__wbindgen_malloc, v.__wbindgen_realloc), c = tA, B = cA(e, v.__wbindgen_malloc, v.__wbindgen_realloc), Q = tA;
      var g = ne(o) ? 0 : cA(o, v.__wbindgen_malloc, v.__wbindgen_realloc), n = tA;
      const f = v.sessionlog_addNewTrustingTransaction(this.__wbg_ptr, C, c, B, Q, t, g, n);
      var a = f[0], I = f[1];
      if (f[3])
        throw a = 0, I = 0, GA(f[2]);
      return r = a, s = I, VA(a, I);
    } finally {
      v.__wbindgen_free(r, s, 1);
    }
  }
  /**
   * Add an existing private transaction to the staging area.
   * The transaction is NOT committed until commitTransactions() succeeds.
   * Note: made_at uses f64 because JavaScript's number type is f64.
   * @param {string} encrypted_changes
   * @param {string} key_used
   * @param {number} made_at
   * @param {string | null} [meta]
   */
  addExistingPrivateTransaction(A, e, t, o) {
    const r = cA(A, v.__wbindgen_malloc, v.__wbindgen_realloc), s = tA, g = cA(e, v.__wbindgen_malloc, v.__wbindgen_realloc), n = tA;
    var a = ne(o) ? 0 : cA(o, v.__wbindgen_malloc, v.__wbindgen_realloc), I = tA;
    const C = v.sessionlog_addExistingPrivateTransaction(this.__wbg_ptr, r, s, g, n, t, a, I);
    if (C[1])
      throw GA(C[0]);
  }
  /**
   * Add an existing trusting transaction to the staging area.
   * The transaction is NOT committed until commitTransactions() succeeds.
   * Note: made_at uses f64 because JavaScript's number type is f64.
   * @param {string} changes
   * @param {number} made_at
   * @param {string | null} [meta]
   */
  addExistingTrustingTransaction(A, e, t) {
    const o = cA(A, v.__wbindgen_malloc, v.__wbindgen_realloc), r = tA;
    var s = ne(t) ? 0 : cA(t, v.__wbindgen_malloc, v.__wbindgen_realloc), g = tA;
    const n = v.sessionlog_addExistingTrustingTransaction(this.__wbg_ptr, o, r, e, s, g);
    if (n[1])
      throw GA(n[0]);
  }
  /**
   * @param {number} tx_index
   * @param {string} encryption_key
   * @returns {string | undefined}
   */
  decryptNextTransactionMetaJson(A, e) {
    const t = cA(e, v.__wbindgen_malloc, v.__wbindgen_realloc), o = tA, r = v.sessionlog_decryptNextTransactionMetaJson(this.__wbg_ptr, A, t, o);
    if (r[3])
      throw GA(r[2]);
    let s;
    return r[0] !== 0 && (s = VA(r[0], r[1]).slice(), v.__wbindgen_free(r[0], r[1] * 1, 1)), s;
  }
  /**
   * @param {number} tx_index
   * @param {string} encryption_key
   * @returns {string}
   */
  decryptNextTransactionChangesJson(A, e) {
    let t, o;
    try {
      const g = cA(e, v.__wbindgen_malloc, v.__wbindgen_realloc), n = tA, a = v.sessionlog_decryptNextTransactionChangesJson(this.__wbg_ptr, A, g, n);
      var r = a[0], s = a[1];
      if (a[3])
        throw r = 0, s = 0, GA(a[2]);
      return t = r, o = s, VA(r, s);
    } finally {
      v.__wbindgen_free(t, o, 1);
    }
  }
  /**
   * @param {string} co_id
   * @param {string} session_id
   * @param {string | null} [signer_id]
   */
  constructor(A, e, t) {
    const o = cA(A, v.__wbindgen_malloc, v.__wbindgen_realloc), r = tA, s = cA(e, v.__wbindgen_malloc, v.__wbindgen_realloc), g = tA;
    var n = ne(t) ? 0 : cA(t, v.__wbindgen_malloc, v.__wbindgen_realloc), a = tA;
    const I = v.sessionlog_new(o, r, s, g, n, a);
    return this.__wbg_ptr = I >>> 0, Ar.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * @returns {SessionLog}
   */
  clone() {
    const A = v.sessionlog_clone(this.__wbg_ptr);
    return Co.__wrap(A);
  }
}
async function _B(i, A) {
  if (typeof Response == "function" && i instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming == "function")
      try {
        return await WebAssembly.instantiateStreaming(i, A);
      } catch (t) {
        if (i.headers.get("Content-Type") != "application/wasm")
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", t);
        else
          throw t;
      }
    const e = await i.arrayBuffer();
    return await WebAssembly.instantiate(e, A);
  } else {
    const e = await WebAssembly.instantiate(i, A);
    return e instanceof WebAssembly.Instance ? { instance: e, module: i } : e;
  }
}
function va() {
  const i = {};
  return i.wbg = {}, i.wbg.__wbg_String_8f0eb39a4a4c2f66 = function(A, e) {
    const t = String(e), o = cA(t, v.__wbindgen_malloc, v.__wbindgen_realloc), r = tA;
    ei().setInt32(A + 4, r, !0), ei().setInt32(A + 0, o, !0);
  }, i.wbg.__wbg_buffer_609cc3eee51ed158 = function(A) {
    return A.buffer;
  }, i.wbg.__wbg_call_672a4d21634d4a24 = function() {
    return Qt(function(A, e) {
      return A.call(e);
    }, arguments);
  }, i.wbg.__wbg_call_7cccdd69e0791ae2 = function() {
    return Qt(function(A, e, t) {
      return A.call(e, t);
    }, arguments);
  }, i.wbg.__wbg_crypto_574e78ad8b13b65f = function(A) {
    return A.crypto;
  }, i.wbg.__wbg_getRandomValues_b8f5dbd5f3995a9e = function() {
    return Qt(function(A, e) {
      A.getRandomValues(e);
    }, arguments);
  }, i.wbg.__wbg_msCrypto_a61aeb35a24c1329 = function(A) {
    return A.msCrypto;
  }, i.wbg.__wbg_new_a12002a7f91c75be = function(A) {
    return new Uint8Array(A);
  }, i.wbg.__wbg_newnoargs_105ed471475aaf50 = function(A, e) {
    return new Function(VA(A, e));
  }, i.wbg.__wbg_newwithbyteoffsetandlength_d97e637ebe145a9a = function(A, e, t) {
    return new Uint8Array(A, e >>> 0, t >>> 0);
  }, i.wbg.__wbg_newwithlength_a381634e90c276d4 = function(A) {
    return new Uint8Array(A >>> 0);
  }, i.wbg.__wbg_node_905d3e251edff8a2 = function(A) {
    return A.node;
  }, i.wbg.__wbg_process_dc0fbacc7c1c06f7 = function(A) {
    return A.process;
  }, i.wbg.__wbg_randomFillSync_ac0988aba3254290 = function() {
    return Qt(function(A, e) {
      A.randomFillSync(e);
    }, arguments);
  }, i.wbg.__wbg_require_60cc747a6bc5215a = function() {
    return Qt(function() {
      return module.require;
    }, arguments);
  }, i.wbg.__wbg_set_65595bdd868b3009 = function(A, e, t) {
    A.set(e, t >>> 0);
  }, i.wbg.__wbg_static_accessor_GLOBAL_88a902d13a557d07 = function() {
    const A = typeof globalThis > "u" ? null : globalThis;
    return ne(A) ? 0 : St(A);
  }, i.wbg.__wbg_static_accessor_GLOBAL_THIS_56578be7e9f832b0 = function() {
    const A = typeof globalThis > "u" ? null : globalThis;
    return ne(A) ? 0 : St(A);
  }, i.wbg.__wbg_static_accessor_SELF_37c5d418e4bf5819 = function() {
    const A = typeof self > "u" ? null : self;
    return ne(A) ? 0 : St(A);
  }, i.wbg.__wbg_static_accessor_WINDOW_5de37043a91a9c40 = function() {
    const A = typeof window > "u" ? null : window;
    return ne(A) ? 0 : St(A);
  }, i.wbg.__wbg_subarray_aa9065fa9dc5df96 = function(A, e, t) {
    return A.subarray(e >>> 0, t >>> 0);
  }, i.wbg.__wbg_versions_c01dfd4722a88165 = function(A) {
    return A.versions;
  }, i.wbg.__wbindgen_debug_string = function(A, e) {
    const t = Nr(e), o = cA(t, v.__wbindgen_malloc, v.__wbindgen_realloc), r = tA;
    ei().setInt32(A + 4, r, !0), ei().setInt32(A + 0, o, !0);
  }, i.wbg.__wbindgen_error_new = function(A, e) {
    return new Error(VA(A, e));
  }, i.wbg.__wbindgen_init_externref_table = function() {
    const A = v.__wbindgen_export_4, e = A.grow(4);
    A.set(0, void 0), A.set(e + 0, void 0), A.set(e + 1, null), A.set(e + 2, !0), A.set(e + 3, !1);
  }, i.wbg.__wbindgen_is_function = function(A) {
    return typeof A == "function";
  }, i.wbg.__wbindgen_is_object = function(A) {
    const e = A;
    return typeof e == "object" && e !== null;
  }, i.wbg.__wbindgen_is_string = function(A) {
    return typeof A == "string";
  }, i.wbg.__wbindgen_is_undefined = function(A) {
    return A === void 0;
  }, i.wbg.__wbindgen_memory = function() {
    return v.memory;
  }, i.wbg.__wbindgen_string_new = function(A, e) {
    return VA(A, e);
  }, i.wbg.__wbindgen_throw = function(A, e) {
    throw new Error(VA(A, e));
  }, i;
}
function Ja(i, A) {
  return v = i.exports, Ha.__wbindgen_wasm_module = A, De = null, mt = null, v.__wbindgen_start(), v;
}
function $B(i) {
  if (v !== void 0) return v;
  typeof i < "u" && (Object.getPrototypeOf(i) === Object.prototype ? { module: i } = i : console.warn("using deprecated parameters for `initSync()`; pass a single object instead"));
  const A = va();
  i instanceof WebAssembly.Module || (i = new WebAssembly.Module(i));
  const e = new WebAssembly.Instance(i, A);
  return Ja(e, i);
}
async function Ha(i) {
  if (v !== void 0) return v;
  if (typeof i < "u" && (Object.getPrototypeOf(i) === Object.prototype ? { module_or_path: i } = i : console.warn("using deprecated parameters for the initialization function; pass a single object instead")), typeof i > "u")
    throw new Error();
  const A = va();
  (typeof i == "string" || typeof Request == "function" && i instanceof Request || typeof URL == "function" && i instanceof URL) && (i = fetch(i));
  const { instance: e, module: t } = await _B(await i, A);
  return Ja(e, t);
}
const qa = "data:application/wasm;base64,AGFzbQEAAAAB4wM9YAJ/fwF/YAN/f38Bf2ACf38AYAN/f38AYAF/AGAABH9/f39gAX8Bf2AFf39/f38AYAACf39gAAF/YAR/f39/AGACf38Ef39/f2ABbwFvYAAAYAV/f39+fwBgB39/f39/f38AYAV/f39/fwF/YAR/f39/AX9gBH9/f38Ef39/f2ABbwF/YAZ/f39/f38Bf2AAA39/f2ACf38Bb2AGf39/f39/AGACf28AYAABb2ACb28AYANvf38Bb2ACf34AYAh/f39/f39/fwR/f39/YAZ/f39/f38Ef39/f2AGf39/f39/A39/f2AEf39/fwJ/f2ACf38Cf39gA29vfwBgAX8Bb2ACb28Bb2ADb29vAW9gBn9/f39+fwBgCH9/f39/f35/AGACfH8Bf2AHf39/fn9/fwF/YAR/f39+AGAJf39/f39/fn5+AGACfn8AYAd/f39/f39/AX9gC39/f39/f39/f39/AX9gA39+fgBgAAF+YAR/fn5/AGAMf39/f39/f39/fH9/BH9/f39gCH9/f39/fH9/BH9/f39gCH9/f39/fH9/An9/YAZ/f398f38Cf39gAX8Cf39gBX9/fH9/AGAEf3x/fwBgBX9/fn9/AGAEf35/fwBgBX9/fX9/AGAEf31/fwACogkgA3diZxVfX3diaW5kZ2VuX3N0cmluZ19uZXcAFgN3YmcUX193YmluZGdlbl9lcnJvcl9uZXcAFgN3YmcUX193YmluZGdlbl9pc19vYmplY3QAEwN3YmcdX193YmdfU3RyaW5nXzhmMGViMzlhNGE0YzJmNjYAGAN3YmcdX193YmdfY3J5cHRvXzU3NGU3OGFkOGIxM2I2NWYADAN3YmceX193YmdfcHJvY2Vzc19kYzBmYmFjYzdjMWMwNmY3AAwDd2JnH19fd2JnX3ZlcnNpb25zX2MwMWRmZDQ3MjJhODgxNjUADAN3YmcbX193Ymdfbm9kZV85MDVkM2UyNTFlZGZmOGEyAAwDd2JnFF9fd2JpbmRnZW5faXNfc3RyaW5nABMDd2JnHl9fd2JnX3JlcXVpcmVfNjBjYzc0N2E2YmM1MjE1YQAZA3diZxZfX3diaW5kZ2VuX2lzX2Z1bmN0aW9uABMDd2JnH19fd2JnX21zQ3J5cHRvX2E2MWFlYjM1YTI0YzEzMjkADAN3YmclX193YmdfcmFuZG9tRmlsbFN5bmNfYWMwOTg4YWJhMzI1NDI5MAAaA3diZyZfX3diZ19nZXRSYW5kb21WYWx1ZXNfYjhmNWRiZDVmMzk5NWE5ZQAaA3diZyBfX3diZ19uZXdub2FyZ3NfMTA1ZWQ0NzE0NzVhYWY1MAAWA3diZxpfX3diZ19uZXdfYTEyMDAyYTdmOTFjNzViZQAMA3diZx1fX3diZ19idWZmZXJfNjA5Y2MzZWVlNTFlZDE1OAAMA3diZzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9kOTdlNjM3ZWJlMTQ1YTlhABsDd2JnGl9fd2JnX3NldF82NTU5NWJkZDg2OGIzMDA5ACIDd2JnJF9fd2JnX25ld3dpdGhsZW5ndGhfYTM4MTYzNGU5MGMyNzZkNAAjA3diZx9fX3diZ19zdWJhcnJheV9hYTkwNjVmYTlkYzVkZjk2ABsDd2JnMl9fd2JnX3N0YXRpY19hY2Nlc3Nvcl9HTE9CQUxfVEhJU181NjU3OGJlN2U5ZjgzMmIwAAkDd2JnF19fd2JpbmRnZW5faXNfdW5kZWZpbmVkABMDd2JnG19fd2JnX2NhbGxfNjcyYTRkMjE2MzRkNGEyNAAkA3diZytfX3diZ19zdGF0aWNfYWNjZXNzb3JfU0VMRl8zN2M1ZDQxOGU0YmY1ODE5AAkDd2JnLV9fd2JnX3N0YXRpY19hY2Nlc3Nvcl9HTE9CQUxfODhhOTAyZDEzYTU1N2QwNwAJA3diZy1fX3diZ19zdGF0aWNfYWNjZXNzb3JfV0lORE9XXzVkZTM3MDQzYTkxYTljNDAACQN3YmcbX193YmdfY2FsbF83Y2NjZGQ2OWUwNzkxYWUyACUDd2JnEV9fd2JpbmRnZW5fbWVtb3J5ABkDd2JnEF9fd2JpbmRnZW5fdGhyb3cAAgN3YmcXX193YmluZGdlbl9kZWJ1Z19zdHJpbmcAGAN3YmcfX193YmluZGdlbl9pbml0X2V4dGVybnJlZl90YWJsZQANA4kDhwMDJg4GJwAKAigDAgMCAAYDAgMHAgICAykDAgIDAgMDDwMAARwEAgYDKgMDFAMEDgMCDwMBAQICAwIAAxwCAAoBAQIDAAAPAQoDFAMKAwMDAgoDDw8CAgMHDgIDBAIrAQIsBwAELQQCCQMDAxcAAgMJAgQDAAACAgAEAAMABwIBEBEOAAAGAAIEBAQEAAYAAAkQAAYAAgAADQ0UAAABEQACBAMEBAcCFwcuBwQGAwcXAgADAwQABAABAAMABAIEAAoBAC8EAwIHAAAOAgMAAAICAgQDBAAAMDEDBAACAAAABAIBAQECBgEAAAADAwMyAAAAAAEAAgQCAgoDBAQAMx0dAAACEB4eBgoAAAQ0EhISHxIfEjULCwsLCwsLCwAJAgIgIAEhIRE2FAgIBxA3OTsECgAAAQAEAAICAgICAAQEBAQEAAAGAAAGAwEABwARAAACAAIEAAACAAAGAwQEAAAAAAAAAAAAAAAAAAAAAAAAAg0NAgAAAAACAAACAQAAAAAAAgQNBgkDBAsCcAG1AbUBbwCAAQUDAQASBgkBfwFBgIDAAAsH+AgxBm1lbW9yeQIAFV9fd2JnX3Nlc3Npb25sb2dfZnJlZQBYKHNlc3Npb25sb2dfYWRkRXhpc3RpbmdQcml2YXRlVHJhbnNhY3Rpb24AqwIpc2Vzc2lvbmxvZ19hZGRFeGlzdGluZ1RydXN0aW5nVHJhbnNhY3Rpb24AswIjc2Vzc2lvbmxvZ19hZGROZXdQcml2YXRlVHJhbnNhY3Rpb24AjQIkc2Vzc2lvbmxvZ19hZGROZXdUcnVzdGluZ1RyYW5zYWN0aW9uAJ0CEHNlc3Npb25sb2dfY2xvbmUArAEdc2Vzc2lvbmxvZ19jb21taXRUcmFuc2FjdGlvbnMAwAIsc2Vzc2lvbmxvZ19kZWNyeXB0TmV4dFRyYW5zYWN0aW9uQ2hhbmdlc0pzb24ArQIpc2Vzc2lvbmxvZ19kZWNyeXB0TmV4dFRyYW5zYWN0aW9uTWV0YUpzb24ArAIOc2Vzc2lvbmxvZ19uZXcAuQELZWQyNTUxOVNpZ24ArgIZZWQyNTUxOVNpZ25hdHVyZUZyb21CeXRlcwC2AhplZDI1NTE5U2lnbmluZ0tleUZyb21CeXRlcwC1AhllZDI1NTE5U2lnbmluZ0tleVRvUHVibGljALQCDWVkMjU1MTlWZXJpZnkArwITZWQyNTUxOVZlcmlmeWluZ0tleQC3AhxlZDI1NTE5VmVyaWZ5aW5nS2V5RnJvbUJ5dGVzALgCFG5ld0VkMjU1MTlTaWduaW5nS2V5AMgCFWVkMjU1MTlTaWduaW5nS2V5U2lnbgCuAgtnZXRTaWduZXJJZAC5AgRzaWduALACBnZlcmlmeQCxAhdfX3diZ19ibGFrZTNoYXNoZXJfZnJlZQDPAQ5ibGFrZTNIYXNoT25jZQDEAhlibGFrZTNIYXNoT25jZVdpdGhDb250ZXh0AMECEmJsYWtlM2hhc2hlcl9jbG9uZQBGFWJsYWtlM2hhc2hlcl9maW5hbGl6ZQDGAhBibGFrZTNoYXNoZXJfbmV3AIcBE2JsYWtlM2hhc2hlcl91cGRhdGUAzAEPZGVjcnlwdFhzYWxzYTIwAKQCD2VuY3J5cHRYc2Fsc2EyMACkAg1nZW5lcmF0ZU5vbmNlAMMCB2RlY3J5cHQApQIHZW5jcnlwdAClAgRzZWFsAJ8CBnVuc2VhbACeAgtnZXRTZWFsZXJJZAC7AhNuZXdYMjU1MTlQcml2YXRlS2V5AMkCE3gyNTUxOURpZmZpZUhlbGxtYW4AsgIPeDI1NTE5UHVibGljS2V5ALoCEV9fd2JpbmRnZW5fbWFsbG9jALwCEl9fd2JpbmRnZW5fcmVhbGxvYwDFAhRfX3diaW5kZ2VuX2V4bl9zdG9yZQDzAhdfX2V4dGVybnJlZl90YWJsZV9hbGxvYwCPARNfX3diaW5kZ2VuX2V4cG9ydF80AQEZX19leHRlcm5yZWZfdGFibGVfZGVhbGxvYwD/AQ9fX3diaW5kZ2VuX2ZyZWUA6AIQX193YmluZGdlbl9zdGFydAAfCe0CAQBBAQu0Af4C1QKBAqIB/wL9Ao4CqAL9AaACjwLVAoECogGAA6gC7gKFA90BsQGbAtQB+QGMAaEC0AGIAo0D0gKoAqEC1gGfA4QDggODA/UC7AHdAYYDjgPlAuYChwPVAoECogGKA4gDiQObAu4C1QKBAqIBiwPtAYkC1QKQAtUCgQKiAYwDqAKgAu4C7wLsApsBjgPYAdUC1QKRAqADqAL+AZkB7wL6AfoB0wG7AdoBoQPXAvACoQOmA/ECoQLvAvwB6gK2AboBoQPYAvICpgOUAagC8QKpAssCzgHKAs4CzQLKAswCygLQAssCxwLTAt0C3gLfAuACrwHhAu4C1gL0ApcB7AKrAe8C1QKBAqIBlAOTA9UCgQKiAdECkwG+Aa0B8QKTArwB1AKVA/AB7gLvAtUCggKjAZYD9QKXAvYClwPPAt4BpgHFAaED2gLZApkD1QKG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IgkgA3NBGHciAyAmczYAPCAAICUgAiANIBRzQRh3IiYgDmoiCCASc0EZdyINIB4gJGpqIiRqIBUgJHNBEHciAiARaiIVIA1zQRR3IiRqIh4gAnNBGHciAnM2ADggACAnIAEgCyAfaiIfIBhzQRl3IhggIiAjamoiImogBSAic0EQdyIBIAhqIiMgGHNBFHciGGoiESABc0EYdyIBczYANCAAICggISAXIBxzQRl3IgUgDyAgamoiIGogBSAgICZzQRB3IgUgH2oiIHNBFHciF2oiHyAFc0EYdyIFczYAMCAAICsgBSAgaiIgczYALCAAICwgAyAHaiIiczYAKCAAICkgAiAVaiIVczYAJCAAICogASAjaiIcczYAICAAIB4gIHM2AAwgACARICJzNgAIIAAgFSAfczYABCAAIAkgHHM2AAAgACAYIBxzQRl3IANzNgAcIAAgFyAgc0EZdyACczYAGCAAIAogInNBGXcgAXM2ABQgACAVICRzQRl3IAVzNgAQC4kbASB/IAAgACgCGCIdIAEoABAiJCAAKAIIamoiGyABKAAUIhVqIB0gGyACQf8BcXNBEHciAkHy5rvjA2oiHXNBFHciG2oiIiACc0EYdyIJIB1qIhwgG3NBGXciDyAAKAIUIhsgASgACCICIAAoAgRqaiIZIAEoAAwiHWogGSADQiCIp3NBEHciHkH7ouGkBGsiICAbc0EUdyIGaiIKIAEoACgiG2pqIiMgASgALCIZaiAPICMgACgCECIhIAEoAAAiDyAAKAIAamoiCCABKAAEIh9qICEgCCADp3NBEHciIUHnzKfQBmoiCHNBFHciB2oiDiAhc0EYdyINc0EQdyILIAAoAhwiBSABKAAYIiMgACgCDGpqIgwgASgAHCIhaiAFIAwgBEH/AXFzQRB3IgRBxpXA1QVrIgVzQRR3IgxqIhEgBHNBGHciECAFaiIFaiISc0EUdyIUaiITIB1qIAYgICAKIB5zQRh3IiBqIgZzQRl3IgogDiABKAAgIgRqaiIOIAEoACQiHmogCiAcIA4gEHNBEHciHGoiCnNBFHciDmoiECAcc0EYdyIWIApqIgogDnNBGXciHGoiDiAbaiAcIA4gBSAMc0EZdyIFICIgASgAMCIcamoiDCABKAA0IiJqIAwgIHNBEHciICAIIA1qIghqIg0gBXNBFHciBWoi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jOjEACABNgIAC0GQ6MQAQf8fNgIAQdzlxAAgBzYCAEHU5cQAIAQ2AgBB0OXEACABNgIAQezlxABB4OXEADYCAEH05cQAQejlxAA2AgBB6OXEAEHg5cQANgIAQfzlxABB8OXEADYCAEHw5cQAQejlxAA2AgBBhObEAEH45cQANgIAQfjlxABB8OXEADYCAEGM5sQAQYDmxAA2AgBBgObEAEH45cQANgIAQZTmxABBiObEADYCAEGI5sQAQYDmxAA2AgBBnObEAEGQ5sQANgIAQZDmxABBiObEADYCAEGk5sQAQZjmxAA2AgBBmObEAEGQ5sQANgIAQazmxABBoObEADYCAEGg5sQAQZjmxAA2AgBBqObEAEGg5sQANgIAQbTmxABBqObEADYCAEGw5sQAQajmxAA2AgBBvObEAEGw5sQANgIAQbjmxABBsObEADYCAEHE5sQAQbjmxAA2AgBBwObEAEG45sQANgIAQczmxABBwObEADYCAEHI5sQAQcDmxAA2AgBB1ObEAEHI5sQANgIAQdDmxABByObEADYCAEHc5sQAQdDmxAA2AgBB2ObEAEHQ5sQANgIAQeTmxABB2ObEADYCAEHg5sQAQdjmxAA2AgBB7ObEAEHg5sQANgIAQfTmxABB6ObEADYCAEHo5sQAQeDmxAA2AgBB/ObEAEHw5sQANgIAQfDmxABB6ObEADYCAEGE58QAQfjmxAA2AgBB+ObEAEHw5sQANgIAQYznxABBgOfEADYCAEGA58QAQfjmxAA2AgBBlOfEAEGI58QANgIAQYjnxABBgOfEADYCAEGc58QAQZDnxAA2AgBBkOfEAEGI58QANgIAQaTnxABBmOfEADYCAEGY58QAQZDnxAA2AgBBrOfEAEGg58QANgIAQaDnxABBmOfEADYCAEG058QAQajnxAA2AgBBqOfEAEGg58QANgIAQbznxABBsOfEADYCAEGw58QAQajnxAA2AgBBxOfEAEG458QANgIAQbjnxABBsOfEADYCAEHM58QAQcDnxAA2AgBBwOfEAEG458QANgIAQdTnxABByOfEADYCAEHI58QAQcDnxAA2AgBB3OfEAEHQ58QANgIAQdDnxABByOfEADYCAEHk58QAQdjnxAA2AgBB2OfEAEHQ58QANgIAQfznxAAgAUEPakF4cSIAQQhrIgI2AgBB4OfEAEHY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akEJdyAMcyIMIAVqQQ13IA9zIg8gDGpBEncgCHMhCCAQIBQgFWpBEncgB3MiB2pBB3cgCXMiCSAHakEJdyANcyINIAlqQQ13IBBzIhAgDWpBEncgB3MhByATQQFrIhMNAAsgACkCICEpIAAoAgAhEyAAKAIEIRIgACgCCCERIAAoAgwhFCAAKAIQIRUgACgCFCEcIAAoAhghGiAAKAIcIR0gACgCICEeIAAoAiQhHyAAKAIoISAgACgCLCEhIAAoAjAhIiAAKAI0ISMgACgCOCEkIAAgACgCPCABajYCfCAAIBYgJGo2AnggACAOICNqNgJ0IAAgBiAiajYCcCAAIAIgIWo2AmwgACAEICBqNgJoIAAgFyAfajYCZCAAIAsgHmo2AmAgACAMIB1qNgJcIAAgBSAaajYCWCAAIAggHGo2AlQgACAPIBVqNgJQIAAgECAUajYCTCAAIA0gEWo2AkggACAJIBJqNgJEIAAgByATajYCQCAAIClCAXwiKT4CICAAIClCIIg+AiQgCkEBcSECQQAhASAbQQFGDQEgCkE+cSEKA0AgASAZaiIGIAAgAWoiBEFAay0AACABIBhqIgUtAABzOgAAIAZBAWogBEHBAGotAAAgBUEBai0AAHM6AAAgCiABQQJqIgFHDQALDAELAkAgCkUNACABKAIEIQAgASgCACECQQAhASAKQQFHBEAgCkF+cSEGA0AgACABaiIFIAEgCGoiB0FAay0AACABIAJqIg4tAABzOgAAIAVBAWogB0HBAGotAAAgDkEBai0AAHM6AAAgBiABQQJqIgFHDQALCyAKQQFxRQ0AIAAgAWogASAJai0AACABIAJqLQAAczoAAAsgBCAKaiEbDAELIAJFDQAgASAZaiAAQUBrIAFqLQAAIAEgGGotAABzOgAACyAlIBs6AABBAAsgA0HAAWokAAuQMQITfyR+IwBB4AVrIgQkACAEQeAAaiIFQQBB4AD8CwAgBEHYAGoiByABQdgBaikCADcDACAEQdAAaiIGIAFB0AFqKQIANwMAIARBkANqIghBsN/AACkDADcDACAEQZgDaiIJQbjfwAApAwA3AwAgBEGgA2pBwN/AACkDADcDACAEQagDakHI38AAKQMANwMAIARBsANqQdDfwAApAwA3AwAgBEG4A2pB2N/AACkDADcDACAEIAFByAFqKQIANwNIIAQgASkCwAE3A0AgBEGg38AAKQMANwOAAyAEQajfwAApAwA3A4gDIARCADcDyAMgBEIANwPAAyAEQdADaiINIARBQGsiCkGAAfwKAAAgBEGoBWoiDkIANwMAIARBsAVqIg9CADcDACAEQbgFaiILQgA3AwAgBEHABWoiDEIANwMAIARByAVqIhBCADcDACAEQdAFaiIRQgA3AwAgBEHYBWoiEkIANwMAIARBIDoA0AQgBEIANwOgBSAEQYADaiITIA0gBEGgBWoQOCAJIAspAwA3AwAgCCAPKQMANwMAIARBiANqIA4pAwA3AwAgBCAEKQOgBSIXNwOAAyAEIBenQfgBcToAgAMgBCAELQCfA0E/cUHAAHI6AJ8DIAQgExD7ASAEQThqIgggEikDADcAACAEQTBqIgkgESkDADcAACAEQShqIg0gECkDADcAACAEIAwpAwA3ACAgBEH4AGpB6N3AACkDADcDACAEQfAAakHg3cAAKQMANwMAIARB6ABqQdjdwAApAwA3AwAgBUHQ3cAAKQMANwMAIAdByN3AACkDADcDACAGQcDdwAApAwA3AwAgBEIANwOIASAEQgA3A4ABIARBuN3AACkDADcDSCAEQbDdwAApAwA3A0AgBEGwAWoiBUEAQeAA/AsAIARBqAFqIAgpAAA3AwAgBEGgAWogCSkAADcDACAEQZgBaiANKQAANwMAIARBIDoAkAIgBCAEKQAgNwOQASAEQZABaiEHAkAgA0HgAE8EQCAFIAJB4AD8CgAAIARCADcDiAEgBEIBNwOAASAKIAdBARAgIAJB4ABqIQggA0HgAGsiBkH/AHEhBSAGQYABTwRAIAQgBCkDgAEiFyAGQQd2IgmtfCIYNwOAASAEIAQpA4gBIBcgGFatfDcDiAEgCiAIIAkQIAsgBUUNASAHIAggBkGAf3FqIAX8CgAADAELIAMEQCAEQbABaiACIAP8CgAACyADQSBqIQULIAQgBToAkAIgBEGAA2oiBSAEQUBrQeAB/AoAACAEQdgFaiIGQgA3AwAgBEHQBWoiCkIANwMAIARByAVqIghCADcDACAEQcAFaiIJQgA3AwAgBEG4BWoiDUIANwMAIARBsAVqIg5CADcDACAEQagFaiIPQgA3AwAgBEIANwOgBSAFIARB0ANqIARBoAVqEDggBEGYBWogBikDADcD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//8BcTYCbCABIAEoAkwgASgCKCACQR12amoiAkH/////AXE2AnAgASABKAJQIAEoAiwgAkEddmpqIgJB/////wFxNgJ0IAEgASgCVCABKAIwIAJBHXZqaiICQf////8BcTYCeCABIAEoAlggASgCNCACQR12amoiAkH/////AXE2AnwgASABKAJcIAEoAjggAkEddmpqIgJB/////wFxNgKAASABIAEoAmAgASgCPCACQR12amoiAkH/////AXE2AoQBIAEgASgCZCABKAJAIAJBHXZqaiICQf////8BcTYCiAEgASABKAJoIAEoAkQgAkEddmpqQf////8BcTYCjAEgASABQewAakHg4cAAEGggBEGgA2oiAiABEH8gAUGQAWokACAPIARByAJqKQAAIhc3AwAgDiAEQdACaikAACIYNwMAIA0gBEHYAmopAAAiGzcDACAAIAQpAMACIhw3AAEgAEEJaiAXNwAAIABBEWogGDcAACAAQRlqIBs3AAAgAEEhaiACKQMANwAAIABBKWogBEGoA2opAwA3AAAgAEExaiAEQbADaikDADcAACAAQTlqIARBuANqKQMANwAAIAQgHDcDgAMgAEEAOgAAIAQQwgEgBEEAOgAgIARBADoAISAEQQA6ACIgBEEAOgAjIARBADoAJCAEQQA6ACUgBEEAOgAmIARBADoAJyAEQQA6ACggBEEAOgApIARBADoAKiAEQQA6ACsgBEEAOgAsIARBADoALSAEQQA6AC4gBEEAOgAvIARBADoAMCAEQQA6ADEgBEEAOgAyIARBADoAMyAEQQA6ADQgBEEAOgA1IARBADoANiAEQQA6ADcgBEEAOgA4IARBADoAOSAEQQA6ADogBEEAOgA7IARBADoAPCAEQQA6AD0gBEEAOgA+IARBADoAPyAEQeAFaiQAC/QZAhl/BH4jAEGwB2siAiQAIwBBIGsiBCQAIAIgAS0AACIDQQR2OgABIAIgA0EPcSIGOgAAIAIgAS0AASIDQQR2OgADIAIgA0EPcToAAiACIAEtAAIiA0EEdjoABSACIANBD3E6AAQgAiABLQADIgNBBHY6AAcgAiADQQ9xOgAGIAIgAS0ABCIDQQR2OgAJIAIgA0EPcToACCACIAEtAAUiA0EEdjoACyACIANBD3E6AAogAiABLQAGIgNBBHY6AA0gAiADQQ9xOgAMIAIgAS0AByIDQQR2OgAPIAIgA0EPcToADiACIAEtAAgiA0EEdjoAESACIANBD3E6ABAgAiABLQAJIgNBBHY6ABMgAiADQQ9xOgASIAIgAS0ACiIDQQR2OgAVIAIgA0EPcToAFCACIAEtAAsiA0EEdjoAFyACIANBD3E6ABYgAiABLQAMIgNBBHY6ABkgAiADQQ9xOgAYIAIgAS0ADSIDQQR2OgAbIAIgA0EPcToAGiACIAEtAA4iA0EEdjoAHSACIANBD3E6ABwgAiABLQAPIgNBBHY6AB8gAiADQQ9xOgAeIAIgAS0AECIDQQR2OgAhIAIgA0EPcToAICACIAEtABEiA0EPcToAIiACIANBBHY6ACMgAiABLQASIgNBBHY6ACUgAiADQQ9xOgAkIAIgAS0AEyIDQQR2OgAnIAIgA0EPcToAJiACIAEtABQiA0EEdjoAKSACIANBD3E6ACggAiABLQAVIgNBBHY6ACsgAiADQQ9xOgAqIAIgAS0AFiIDQQR2OgAtIAIgA0EPcToALCACIAEtABciA0EEdjoALyACIANBD3E6AC4gAiABLQAYIgNBBHY6ADEgAiADQQ9xOgAwIAIgAS0AGSIDQQR2OgAzIAIgA0EPcToAMiACIAEtABoiA0EEdjoANSACIANBD3E6ADQgAiABLQAbIgNBBHY6ADcgAiADQQ9xOgA2IAIgAS0AHCIDQQR2OgA5IAIgA0EPcToAOCACIAEtAB0iA0EEdjoAOyACIANBD3E6ADogAiABLQAeIgNBBHY6AD0gAiADQQ9xOgA8IAIgAS0AHyIBQQR2OgA/IAIgAUEPcToAPgNAIAIgBWoiCCAGIAZBCGoiAUHwAXFrOgAAIAhBAWoiAyADLQAAIAHAQQR1aiIBOgAAIAVBPkcEQCADIAEgAUEIaiIDQfABcWs6AAAgCEECaiIBIAEtAAAgA8BBBHVqIgY6AAAgBUECaiEFDAELCyAEQSBqJAAgAkHgAGpCADcDACACQdgAakIANwMAIAJB0ABqQgA3AwAgAkHIAGpCADcDAEEAIQEgAkHwAGpBoOPAACkCACIcNwMAIAJB+ABqQajjwAApAgAiHTcDACACQYABakGw48AAKQIAIh43AwAgAkGIAWpBuOPAACkCACIbNwMAIAJBmAFqIBw3AwAgAkGgAWogHTcDACACQagBaiAeNwMAIAJBsAFqIBs3AwAgAkIANwNAIAJBmOPAACkCACIbNwNoIAIgGzcDkAEgAkHYAWpCADcDACACQdABakIANwMAIAJByAFqQgA3AwAgAkHAAWpCADcDACACQgA3A7gBIAJB+ANqIQwgAkHQA2ohDSACQagDaiEOIAJB6AVqIQsgAkHABWohBSACQZAGaiEGIAJBkAFqIQ8gAkHoAGohEANAAkACQCABQcAARwRAIAFBAXENAQwCCyACQegEaiAQQSBqKQIANwMAIAJB4ARqIBBBGGopAgA3AwAgAkHYBGogEEEQaikCADcDACACQdAEaiAQQQhqKQIANwMAIAJB+ARqIA9BCGopAgA3AwAgAkGABWogD0EQaikCADcDACACQYgFaiAPQRhqKQIANwMAIAJBkAVqIA9BIGopAgA3AwAgAiAQKQIANwPIBCACIA8pAgA3A/AEIAJBwARqIAJB4ABqKQMANwMAIAJBuARqIAJB2ABqKQMANwMAIAJBsARqIAJB0ABqKQMANwMAIAJBqARqIAJByABqKQMANwMAIAIgAikDQDcDoAQgAkGYBWoiAyACQaAEahAsQQAiAUUEQCACQYADaiADQaAB/AoAAAsgAkGYBWoiByACQYADaiITIAJB+ANqIgkQNiACQYgHaiIVIAJBqANqIhEgAkHQA2oiChA2IAJB4AFqIhQgCiAJEDYgAkHgBWoiGiACQagHaiIWKQIANwIAIAJB2AVqIgwgAkGgB2oiFykCADcCACACQdAFaiINIAJBmAdqIhgpAgA3AgAgAkHIBWoiDiACQZAHaiIZKQIANwIAIAJB8AVqIg8gAkHoAWoiECkCADcCACACQfgFaiILIAJB8AFqIgUpAgA3AgAgAkGABmoiBiACQfgBaiIIKQIANwIAIAJBiAZqIgQgAkGAAmoiAykCADcCACACIAIpAogHNwLABSACIAIpAuABNwLoBSACQaAEaiISIAdB+AD8CgAAIAcgEhAsIBMgB0GgAfwKAAAgByATIAkQNiAVIBEgChA2IBQgCiAJEDYgGiAWKQIANwIAIAwgFykCADcCACANIBgpAgA3AgAgDiAZKQIANwIAIA8gECkCADcCACALIAUpAgA3AgAgBiAIKQIANwIAIAQgAykCADcCACACIAIpAogHNwLABSACIAIpAuABNwLoBSASIAdB+AD8CgAAIAcgEhAsIBMgB0GgAfwKAAAgByATIAkQNiAVIBEgChA2IBQgCiAJEDYgGiAWKQIANwIAIAwgFykCADcCACANIBgpAgA3AgAgDiAZKQIANwIAIA8gECkCADcCACALIAUpAgA3AgAgBiAIKQIANwIAIAQgAykCADcCACACIAIpAogHNwLABSACIAIpAuABNwLoBSASIAdB+AD8CgAAIAcgEhAsIBQgByACQZAGaiILEDYgAkG4BmogAkHABWoiBSACQegFaiIGEDYgAkHgBmogBiALEDYgFSAHIAUQNiACQagCaiACQdgGaikCADcCACACQaACaiACQdAGaikCADcCACACQZgCaiACQcgGaikCADcCACACQZACaiACQcAGaikCADcCACACQbgCaiACQegGaikCADcCACACQcACaiACQfAGaikCADcCACACQcgCaiACQfgGaikCADcCACACQdACaiACQYAHaikCADcCACACIAIpArgGNwKIAiACIAIpAuAGNwKwAiACQfgCaiAWKQIANwIAIAJB8AJqIBcpAgA3AgAgAkHoAmogGCkCADcCACACQeACaiAZKQIANwIAIAIgAikCiAc3AtgCIAJBQGsgFEGgAfwKAAADQAJAAkAgAUHAAEcEQCABQQFxRQ0BDAILIAAgAkFAa0GgAfwKAAAgAkGwB2okAA8LIAFBAXYhBCABQcAASQRAIAJB4AFqIgMgBEHAB2xBuKHBAGogASACai0AABBiIAJBmAVqIgggAkFAayIEIAMQQCACQYADaiIDIAggCxA2IAJB4AZqIAUgBhA2IAJBiAdqIAYgCxA2IAJBoARqIAggBRA2IBFBIGogAkGAB2opAgA3AgAgEUEYaiACQfgGaikCADcCACARQRBqIAJB8AZqKQIANwIAIBFBCGogAkHoBmopAgA3AgAgESACKQLgBjcCACAKIAIpAogHNwIAIApBCGogAkGQB2opAgA3AgAgCkEQaiACQZgHaikCADcCACAKQRhqIAJBoAdqKQIANwIAIApBIGogAkGoB2opAgA3AgAgCUEgaiACQcAEaikCADcCACAJQRhqIAJBuARqKQIANwIAIAlBEGogAkGwBGopAgA3AgAgCUEIaiACQagEaikCADcCACAJIAIpAqAENwIAIAQgA0GgAfwKAAAgAUEBaiEBDAILIARBIEHA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ASASQgA3AwAgE0IANwMAIBRCADcDACAVQgA3AwAgF0IANwMAIBhCADcDACAZQgA3AwAgDiAAQQhqKQMANwMAIBAgAEEQaikDADcDACARIABBGGopAwA3AwAgA0IANwOAASADIAApAwA3A8ABIAApA4ABIRsgBSAaQeAA/AoAACAAQQA7AYgBIAAgG0IBfDcDgAEgASAKaiEBCyACQYEITwRAIABBnAFqIQ8gACkDgAEhGyADQdAAaiEMIANBwAFqIQkgA0GgAWohCgNAIBtCCoYhHEF/IAJBAXZndkEBaiEEA0AgBCIFQQF2IQQgHCAFQQFrrYNCAFINAAsgBUEKdq0hHAJAAkAgBUGBCE8EQCACIAVPDQFBACAFIAJB7NrAABCYAgALIANBiAFqQgA3AwAgA0GQAWpCADcDACADQZgBakIANwMAIApCADcDACADQagBakIANwMAIANBsAFqQgA3AwAgA0G4AWpCADcDACAJIAApAwA3AwAgCUEIaiIHIABBCGopAwA3AwAgCUEQaiIGIABBEGopAwA3AwAgCUEYaiIIIABBGGopAwA3AwAgA0IANwOAASADQQA7AegBIAMgGzcD4AEgAyAALQCKAToA6gEgA0GAAWogASAFEH4hBCAMIAkpAwA3AwAgDEEIaiAHKQMANwMAIAxBEGogBikDADcDACAMQRhqIAgpAwA3AwAgA0EYaiAEQQhqKQMANwMAIANBIGogBEEQaikDADcDACADQShqIARBGGopAwA3AwAgA0EwaiAEQSBqKQMANwMAIANBOGogBEEoaikDADcDACADQUBrIARBMGopAwA3AwAgA0HIAGogBEE4aikDADcDACADIAQpAwA3AxAgAy0A6gEhBCADLQDpASELIAMgAy0A6AEiDToAeCADIAMpA+ABIhs3A3AgAyAEIAtFckECciIEOgB5IANBiAJqIgsgCCkCADcDACADQYACaiIIIAYpAgA3AwAgA0H4AWoiDiAHKQIANwMAIAMgCSkCADcD8AEgA0HwAWogA0EQaiANIBsgBBAiIAsoAgAhByAIKAIAIQYgDigCACEIIAMoAowCIQsgAygChAIhDSADKAL8ASEOIAMoAvQBIRAgAygC8AEhESAAIAApA4ABEEMgACgCmAEiBEE3Tw0HIAAgBEEBajYCmAEgDyAEQQV0aiIEIAs2Ahwg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KAKYAygCmAMoApgDKAKYAygCmAMoApgDKAKYAygCmAMhBSAEQQhrIgQNAAsLIAUhBEEAIQULAkAgBC8BkgMgCUsEQCAEIQEMAQsDQCAEKAKIAiIBRQ0NIAVBAWohBSAELwGQAyEJIAkgASIELwGSA08NAAsLIAlBAWohBwJAIAVFBEAgASEEDAELIAEgB0ECdGpBmANqIQICQCAFQQdxIgdFBEAgBSEGDAELIAUhBgNAIAZBAWshBiACKAIAIgRBmANqIQIgB0EBayIHDQALC0EAIQcgBUEISQ0AA0AgAigCACgCmAMoApgDKAKYAygCmAMoApgDKAKYAygCmAMiBEGYA2ohAiAGQQhrIgYNAAsLAn8gASAJQQxsakGMAmohBiABIAlBGGxqIQUjAEEQayILJAAgA0HID2oiCS0AAEEBRwRAIAYoAgghAiAGKAIEIQEgCSgCBCENIAktAAFBAUcEQCANKAIAIgwoAgAgDCgCCCIGRgRAIAwgBkEBQQFBARDJASAMKAIIIQYLIAwgBkEBajYCCCAMKAIEIAZqQSw6AAALIAlBAjoAASALIA0gASACEGcCfyALLQAAQQRHBEAgCyALKQMANwMIIAtBCGoQpgIMAQsgDSgCACICKAIAIAIoAggiAUYEQCACIAFBAUEBQQEQyQEgAigCCCEBCyACIAFBAWo2AgggAigCBCABakE6OgAAIAUgDRAtCyALQRBqJAAMAQtB3dTAAEEoQYjVwAAQmQIACyIFDQNBACEFIA5BAWsiDg0ACyADKALIDyIBQQFxDQkgAUGA/gNxRQ0BIAMoAswPBSABCygCACIBKAIAIAEoAggiBUYEQCABIAVBAUEBQQEQyQEgASgCCCEFCyABIAVBAWo2AgggASgCBCAFakH9ADoAAAsgAygCNCEFIAMoAjAiD0GAgICAeEYNASADKAI4IQQgA0GAEGpCADcDACADQfgPakIANwMAIANB8A9qQgA3AwAgA0HoD2pCADcDACADQeAPakIANwMAIANB2A9qQgA3AwAgA0HQD2pCADcDACADQZAQakHotsAAKQIAIhM3AwAgA0GYEGpB8LbAACkCACISNwMAIANBoBBqQfi2wAApAgAiETcDACADQThqIBM3AwAgA0FAayASNwMAIANByABqIBE3AwAgA0IANwPIDyADQeC2wAApAgAiETcDiBAgAyARNwMwIANB0ABqIANByA9qIgJB4AD8CgAAIANBtwFqQQA2AAAgA0EANgLIASADQgA3A8ABIANCADcDsAEgA0EwaiIBIAUgBBApIANBwA9qIgtCADcDACADQbgPaiIMQgA3AwAgA0IANwOwDyMAQSBrIgQkAAJAIAEpA5ABUARAIAIgARAwIAJBADoAcCAEQSBqJAAMAQsgBEIANwIUIARCgYCAgMAANwIMIARBzNnAADYCCCABQZABakGI18AAIARBCGpB1NnAABCnAgALIANBsA9qIQFBGCEKIwBBQGoiCCQAAkACQCACIgQtAHAiAgR/IAggBEFAayAEIAQtAGggBCkDYCIRIAQtAGlBCHIQISACQcAASw0BQRhBwAAgAmsiBiAGQRhPGyIGBEAgASACIAhqIAb8CgAACyAEIAIgBmoiAjoAcCABIAZqIQFBGCAGayEKIAJB/wFxQcAARgR/IARBADoAcCAEIBFCAXw3A2BBAAUgAgsFQQALIQ0gCkE/SwRAIARBQGshDkEAIApBQHEiCWshECAELQBpQQhyIQcgBC0AaCEGIAQpA2AiESESIAEhAgNAIAggDiAEIAYgEiAHECEgAkE4aiAIQThqKQAANwAAIAJBMGogCEEwaikAADcAACACQShqIAhBKGopAAA3AAAgAkEgaiAIQSBqKQAANwAAIAJBGGogCEEYaikAADcAACACQRBqIAhBEGopAAA3AAAgAkEIaiAIQQhqKQAANwAAIAIgCCkAADcAACASQgF8IRIgAkFAayECIBBBQGsiEA0ACyAEIBEgCkEGdq18NwNgIApBP3EhCiABIAlqIQELAkAgCkUNACAIIARBQGsgBCAELQBoIAQpA2AgBC0AaUEIchAhIA1B/wFxIgJBwABNBEBBwAAgAmsiBiAKIAYgCkkbIgYEQCABIAIgCGogBvwKAAALIAQgBC0AcCAGaiIBOgBwIAFB/wFxQcAARw0BIARBADoAcCAEIAQpA2BCAXw3A2AMAQsMAQsgCEFAayQADAELIAJBwABBwABBpNfAABCYAgALIABBEGogCykDADcAACAAQQhqIAwpAwA3AAAgACADKQOwDzcAACAPBEAgBSAPQQEQ+gILIANBBHIQRCADQcAQaiQADwsgAygCMCIARQ0AIAMoAjQgAEEBEPoCCyADIAU2AjBBkLfAAEErIANBMGpBgLfAAEG8t8AAEOYBAAtBAUECENsCAAtBAUEJENsCAAtBAUEHENsCAAtBAUECENsCAAtBAUGAARDbAgALQfC4wABBKEGYucAAEJkCAAtB/LfAABD8AgALow8CKH8IfiMAQfACayICJAAgAkGgAmoiAyABEFAgAiACKQPoAiACKQPgAiACKQPYAiACKQPQAiACKQPIAiACKQPAAiIqQhqIfCIsQhmIfCIrQhqIfCIvQhmIfCIwQhqIfCItQhmIQhN+IAIpA6ACIi5C////H4N8IjGnQf///x9xIgQ2AgggAiACKQOoAiAuQhqIfCIuQv///w+DIDFCGoh8pyIINgIMIAIgLEL///8PgyAqQv///x+DIAIpA7gCIAIpA7ACIC5CGYh8IipCGoh8IixCGYh8Ii5CGoh8pyIJNgIcIAIgLqdB////H3EiBTYCGCACICynQf///w9xIgo2AhQgAiAvp0H///8PcSILNgIkIAIgLadB////D3EiDDYCLCACICqnQf///x9xIg02AhAgAiArp0H///8fcSIGNgIgIAIgMKdB////H3EiBzYCKCADIAFBKGoQUCACIAIpA+gCIAIpA+ACIAIpA9gCIAIpA9ACIAIpA8gCIAIpA8ACIipCGoh8IixCGYh8IitCGoh8Ii9CGYh8IjBCGoh8Ii1CGYhCE34gAikDoAIiLkL///8fg3wiMadB////H3EiDjYCMCACIAIpA6gCIC5CGoh8Ii5C////D4MgMUIaiHynIg82AjQgAiAsQv///w+DICpC////H4MgAikDuAIgAikDsAIgLkIZiHwiKkIaiHwiLEIZiHwiLkIaiHynIhA2AkQgAiAup0H///8fcSIRNgJAIAIgLKdB////D3EiEjYCPCACIC+nQf///w9xIhM2AkwgAiAtp0H///8PcSIUNgJUIAIgKqdB////H3EiFTYCOCACICunQf///x9xIhY2AkggAiAwp0H///8fcSIXNgJQIAMgAUHQAGoQUCACIAIpA9ACQgGGIAIpA8gCQgGGIAIpA8ACQgGGIipCGoh8IixCGYh8IiunQf///x9xNgJwIAIgAikDsAJCAYYgAikDqAJCAYYgAikDoAJCAYYiL0IaiHwiMEIZiHwiLadB////H3E2AmAgAiACKQPYAkIBhiArQhqIfCIrp0H///8PcTYCdCACIAIpA7gCQgGGIC1CGoh8Ii2nQf///w9xNgJkIAIgAikD4AJCAYYgK0IZiHwiK6dB////H3E2AnggAiAsQv///w+DICpC/v//H4MgLUIZiHwiKkIaiHw+AmwgAiAqp0H///8fcTYCaCACIAIpA+gCQgGGICtCGoh8IiqnQf///w9xNgJ8IAIgMEL///8PgyAqQhmIQhN+IC9C/v//H4N8IipCGoh8PgJcIAIgKqdB////H3E2AlggASgCKCEYIAEoAgAhGSABKAIsIRogASgCBCEbIAEoAjAhHCABKAIIIR0gASgCNCEeIAEoAgwhHyABKAI4ISAgASgCECEhIAEoAjwhIiABKAIUISMgASgCQCEkIAEoAhghJSABKAJEISYgASgCHCEnIAEoAkghKCABKAIgISkgAiABKAJMIAEoAiRqNgKkASACICggKWo2AqABIAIgJiAnajYCnAEgAiAkICVqNgKYASACICIgI2o2ApQBIAIgICAhajYCkAEgAiAeIB9qNgKMASACIBwgHWo2AogBIAIgGiAbajYChAEgAiAYIBlqNgKAASADIAJBgAFqEFAgAiACKQPQAiACKQPIAiACKQPAAiIqQhqIfCIsQhmIfCIrp0H///8fcTYCwAEgAiACKQOwAiACKQOoAiACKQOgAiIvQhqIfCIwQhmIfCItp0H///8fcTYCsAEgAiACKQPYAiArQhqIfCIrp0H///8PcTYCxAEgAiACKQO4AiAtQhqIfCItp0H///8PcTYCtAEgAiACKQPgAiArQhmIfCIrp0H///8fcTYCyAEgAiAsQv///w+DICpC////H4MgLUIZiHwiKkIaiHw+ArwBIAIgKqdB////H3E2ArgBIAIgAikD6AIgK0IaiHwiKqdB////D3E2AswBIAIgMEL///8PgyAqQhmIQhN+IC9C////H4N8IipCGoh8PgKsASACICqnQf///x9xNgKoASACQfABaiIBIAcgF2o2AgAgAkHoAWoiByAGIBZqNgIAIAJB4AFqIgYgBSARajYCACACQdgBaiIFIA0gFWo2AgAgAiAMIBRqNgL0ASACIAsgE2o2AuwBIAIgCSAQajYC5AEgAiAKIBJqNgLcASACIAggD2o2AtQBIAIgBCAOajYC0AEgAkH4AWoiBCACQTBqIAJBCGoQeiAAIAJBqAFqIAJB0AFqEHogAyACQdgAaiAEEHogAEHIAGogASkCADcCACAAQUBrIAcpAgA3AgAgAEE4aiAGKQIANwIAIABBMGogBSkCADcCACAAIAIpAtABNwIoIAAgAikC+AE3AlAgAEHYAGogAkGAAmopAgA3AgAgAEHgAGogAkGIAmopAgA3AgAgAEHoAGogAkGQAmopAgA3AgAgAEHwAGogAkGYAmopAgA3AgAgAEGYAWogAkHAAmopAgA3AgAgAEGQAWogAkG4AmopAgA3AgAgAEGIAWogAkGwAmopAgA3AgAgAEGAAWogAkGoAmopAgA3AgAgACACKQKgAjcCeCACQfACaiQAC50OAQp/IwBBEGsiCCQAAkACQAJAAkACQAJAAkACQCAALQAAQQFrDgUBAgMEBQALIAEoAgAiACgCACAAKAIIIgJrQQNNBEAgACACQQRBAUEBEMkBIAAoAgghAgsgACACQQRqNgIIIAAoAgQgAmpB7uqx4wY2AAAMBQsgASgCACEBIAAtAAFFBEAgASgCACABKAIIIgBrQQRNBEAgASAAQQVBAUEBEMkBIAEoAgghAAsgASAAQQVqNgIIIAEoAgQgAGoiAEGw0sAAKAAANgAAIABBBGpBtNLAAC0AADoAAAwGCyABKAIAIAEoAggiAGtBA00EQCABIABBBEEBQQEQyQEgASgCCCEACyABIABBBGo2AgggASgCBCAAakH05NWrBjYAAAwECyAAQQhqIAEQPAwDCyAIIAEgACgCCCAAKAIMEGcgCC0AAEEERg0DIAggCCkDADcDCCAIQQhqEKYCIQIMAwsgACgCDCEEIAAoAgghByABKAIAIgAoAgAgACgCCCICRgRAIAAgAkEBQQFBARDJASAAKAIIIQILIAAgAkEBajYCCCAAKAIEIAJqQdsAOgAAAkAgBEUNACAHIAEQLSICDQMgBEEBRg0AIARBGGxBGGshBiAHQRhqIQMDQCAAKAIIIgIgACgCAEYEQCAAIAJBAUEBQQEQyQEgACgCCCECCyAAIAJBAWo2AgggACgCBCACakEsOgAAIAMgARAtIgINBCADQRhqIQMgBkEYayIGDQALCyAAKAIIIgIgACgCAEYEQCAAIAJBAUEBQQEQyQEgACgCCCECCyAAIAJBAWo2AgggACgCBCACakHdADoAAAwBCyAAKAIMIQogASgCACIFKAIAIAUo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CyAGIBN6p0EDdiACaiAKcSICaiwAAEEATgRAIAYpAwBCgIGChIiQoMCAf4N6p0EDdiECCyACIAdrIAUgB2tzIApxQQhPBEAgAiAGaiIHLQAAIAcgEEEZdiIHOgAAIAkgAkEIayAKcWogBzoAACAGIAJBA3RrQQhrIQJB/wFGDQIgAigAACEHIAIgBCgAADYAACAEIAc2AAAgBCgABCEHIAQgAigABDYABCACIAc2AAQMAQsLIA8gEEEZdiICOgAAIAkgBUEIayAKcWogAjoAAAwBCyAPQf8BOgAAIAkgBUEIayAKcWpB/wE6AAAgAiAEKQAANwAACyAIIAggDEkiAmohBCACDQALCyABIA4gDWs2AghBgYCAgHghCQwBCwwBCyAAIA42AgQgACAJNgIAIANBQGskAA8LIANBADYCECADQQE2AgQgA0G4wMAANgIAIANCBDcCCCADQcDAwAAQvwIAC8cMAhJ/BH4jAEHQAWsiAiQAAkAgASgCmAEiBEUEQCAAIAEpA2A3A0AgACABKQMgNwMAIABByABqIAFB6ABqKQMANwMAIABB0ABqIAFB8ABqKQMANwMAIABB2ABqIAFB+ABqKQMANwMAIABBCGogAUEoaikDADcDACAAQRBqIAFBMGopAwA3AwAgAEEYaiABQThqKQMANwMAIABBIGogAUFAaykDADcDACAAQShqIAFByABqKQMANwMAIABBMGogAUHQAGopAwA3AwAgAEE4aiABQdgAaikDADcDACABLQCKASEEIAEtAIkBIQMgACABLQCIAToAaCAAIAEpA4ABNwNgIAAgBCADRXJBAnI6AGkMAQsCQAJAAkACQCABLQCIASIHIAEtAIkBIgZyBEAgAkG4AWogAUHoAGopAwA3AwAgAkHAAWogAUHwAGopAwA3AwAgAkHIAWogAUH4AGopAwA3AwAgAkH4AGogAUEoaikDADcDACACQYABaiABQTBqKQMANwMAIAJBiAFqIAFBOGopAwA3AwAgAkGQAWogAUFAaykDADcDACACQZgBaiABQcgAaikDADcDACACQaABaiABQdAAaikDADcDACACQagBaiABQdgAaikDADcDACACIAEpA2A3A7ABIAIgASkDIDcDcCABLQCKASEDIAEpA4ABIRQgAiACQfAAakHgAPwKAAAgAiADIAZFckECciIFOgBp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IQVBACEJAkAgB0EESQRAQQAhCAwBCyAHQXxxIQpBACEIA0BCASADIAhqIgZBA2oxAACGQgEgBjEAAIYgD4RCASAGQQFqMQAAhoRCASAGQQJqMQAAhoSEIQ8gCiAIQQRqIghHDQALCyAFRQ0AIAMgCGohBgNAQgEgBjEAAIYgD4QhDyAGQQFqIQYgBUEBayIFDQALCyAECyEGIAAgBDYCPCAAIAM2AjggACACNgI0IAAgATYCMCAAIAY2AiggACAJNgIkIAAgAjYCICAAQQA2AhwgACAHNgIYIAAgDDYCFCAAIA02AhAgACAPNwMIIABBATYCAA8LIAUgBEHg0MQAEPIBAAsgBSAEQeDQxAAQ8gEAC0EAIA0gBEGg0cQAEJgCAAsgByAFIARBkNHEABCYAgALIAUgBEHw0MQAEPIBAAsgCyAEQYDRxAAQ8gEACyAFIARB8NDEABDyAQALIAggBEGA0cQAEPIBAAuHDAIGfwZ+IwBBoAZrIgIkACACQdAFaiIFIAEQUCACIAIpA4AGIAIpA/gFIAIpA/AFIghCGoh8IgtCGYh8IgmnQf///x9xNgIYIAIgAikD4AUgAikD2AUgAikD0AUiDEIaiHwiDUIZiHwiCqdB////H3E2AgggAiACKQOIBiAJQhqIfCIJp0H///8PcTYCHCACIAIpA+gFIApCGoh8IgqnQf///w9xNgIMIAIgAikDkAYgCUIZiHwiCadB////H3E2AiAgAiALQv///w+DIAhC////H4MgCkIZiHwiCEIaiHw+AhQgAiAIp0H///8fcTYCECACIAIpA5gGIAlCGoh8IginQf///w9xNgIkIAIgDUL///8PgyAIQhmIQhN+IAxC////H4N8IghCGoh8PgIEIAIgCKdB////H3E2AgAgBSACEFAgAiACKQOABiACKQP4BSACKQPwBSIIQhqIfCILQhmIfCIJp0H///8fcTYCwAUgAiACKQPgBSACKQPYBSACKQPQBSIMQhqIfCINQhmIfCIKp0H///8fcTYCsAUgAiACKQOIBiAJQhqIfCIJp0H///8PcTYCxAUgAiACKQPoBSAKQhqIfCIKp0H///8PcTYCtAUgAiACKQOQBiAJQhmIfCIJp0H///8fcTYCyAUgAiALQv///w+DIAhC////H4MgCkIZiHwiCEIaiHw+ArwFIAIgCKdB////H3E2ArgFIAIgAikDmAYgCUIaiHwiCKdB////D3E2AswFIAIgDUL///8PgyAIQhmIQhN+IAxC////H4N8IghCGoh8PgKsBSACIAinQf///x9xNgKoBSAFIAJBqAVqIgYQUCACIAIpA4AGIAIpA/gFIAIpA/AFIghCGoh8IgtCGYh8IgmnQf///x9xNgJAIAIgAikD4AUgAikD2AUgAikD0AUiDEIaiHwiDUIZiHwiCqdB////H3E2AjAgAiACKQOIBiAJQhqIfCIJp0H///8PcTYCRCACIAIpA+gFIApCGoh8IgqnQf///w9xNgI0IAIgAikDkAYgCUIZiHwiCadB////H3E2AkggAiALQv///w+DIAhC////H4MgCkIZiHwiCEIaiHw+AjwgAiAIp0H///8fcTYCOCACIAIpA5gGIAlCGoh8IginQf///w9xNgJMIAIgDUL///8PgyAIQhmIQhN+IAxC////H4N8IghCGoh8PgIsIAIgCKdB////H3E2AiggAkHQAGoiBCABIAJBKGoQNiACQfgAaiIBIAIgBBA2IAUgARBQIAIgAikDgAYgAikD+AUgAikD8AUiCEIaiHwiC0IZiHwiCadB////H3E2ArgBIAIgAikD4AUgAikD2AUgAikD0AUiDEIaiHwiDUIZiHwiCqdB////H3E2AqgBIAIgAikDiAYgCUIaiHwiCadB////D3E2ArwBIAIgAikD6AUgCkIaiHwiCqdB////D3E2AqwBIAIgAikDkAYgCUIZiHwiCadB////H3E2AsABIAIgC0L///8PgyAIQv///x+DIApCGYh8IghCGoh8PgK0ASACIAinQf///x9xNgKwASACIAIpA5gGIAlCGoh8IginQf///w9xNgLEASACIA1C////D4MgCEIZiEITfiAMQv///x+DfCIIQhqIfD4CpAEgAiAIp0H///8fcTYCoAEgAkHIAWoiAyAEIAJBoAFqEDYgAkHwAWoiBCADQQUQTCACQZgCaiIBIAQgAxA2IAJBwAJqIgMgAUEKEEwgAkHoAmoiBCADIAEQNiACQZADaiIDIARBFBBMIAJBuANqIgcgAyAEEDYgAkHgA2oiAyAHQQoQTCACQYgEaiIEIAMgARA2IAJBsARqIgMgBEEyEEwgAkHYBGoiASADIAQQNiACQYAFaiIDIAFB5AAQTCAGIAMg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fnwgECAafnwgGyAgfnwgAyAOfnwgCSAYfnwgBiALfnwgBSAHfnwgCCAMfnwgCiAdfnwgJUIaiHwiBKdB////D3E2AgwgACASIBR+IBEgE358IA4gFX58IAsgFn58IAMgAa0iDH58IAUgF358IAYgHn58IAcgD358IAggDX58IAkgCn58IB9CGYh8IgWnQf///x9xNgIgIAAgI0L///8PgyAiQv///x+DIARCGYh8IgRCGoh8PgIUIAAgBKdB////H3E2AhAgACAYIB5+IAwgGX58IA8gHH58IA0gGn58IAMgLa1+fCAJIBt+fCAGIBF+fCAHIBR+fCAIIA5+fCAKIAt+fCAFQhqIfCIDp0H///8PcTYCJCAAICRC////D4MgA0IZiEITfiAhQv///x+DfCIDQhqIfD4CBCAAIAOnQf///x9xNgIAC90MAg1/AX4jAEGgAmsiByQAAkACQAJAAkACQCABQYAITQRAIAdBADYCiAEgASABQQAgAUGACEcbIgxrIg5BgAhPBEAgB0EBNgKIASAHIAA2AowBQQEhCgsgB0GMAWohCyADIRQgBSEBIwBBIGsiCCQAIAZBBXYiCSAKIAkgCkkbIg0EQCAEQQJyIQ8gBEEBciEQA0AgCygCACEJIAhBGGoiESACQRhqKQIANwMAIAhBEGoiEiACQRBqKQIANwMAIAhBCGoiEyACQQhqKQIANwMAIAggAikCADcDACAIIAlBwAAgFCAQECIgCCAJQUBrQcAAIBQgBBAiIAggCUGAAWpBwAAgFCAEECIgCCAJQcABakHAACAUIAQQIiAIIAlBgAJqQcAAIBQgBBAiIAggCUHAAmpBwAAgFCAEECIgCCAJQYADakHAACAUIAQQIiAIIAlBwANqQcAAIBQgBBAiIAggCUGABGpBwAAgFCAEECIgCCAJQcAEakHAACAUIAQQIiAIIAlBgAVqQcAAIBQgBBAiIAggCUHABWpBwAAgFCAEECIgCCAJQYAGakHAACAUIAQQIiAIIAlBwAZqQcAAIBQgBBAiIAggCUGAB2pBwAAgFCAEECIgCCAJQcAHakHAACAUIA8QIiABQRhqIBEpAwA3AAAgAUEQaiASKQMANwAAIAFBCGogEykDADcAACABIAgpAwA3AAAgC0EEaiELIAFBIGohASAUQgF8IRQgDUEBayINDQALCyAIQSBq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BjcDCCAAIAZCP4g3AwAMEgsgACABMgEEIgY3AwggACAGQj+INwMADBELIAAgATQCBCIGNwMIIAAgBkI/iDcDAAwQCyAAIAEpAwgiBjcDCCAAIAZCP4g3AwAMDwsgASoCBLsiB71C////////////AINCgICAgICAgPj/AFoEQCAAQbXSwABBERDhATYCCCAAQgM3AwAMDwsgACAHOQMIIABCAjcDAAwOCyABKwMIIge9Qv///////////wCDQoCAgICAgID4/wBaBEAgAEG10sAAQREQ4QE2AgggAEIDNwMADA4LIAAgBzkDCCAAQgI3AwAMDQsgASgCBCEBIAJBADYCBCABQYABSQ0KIAFBP3FBgH9yIQMgAUEGdiEEIAFBgBBJBEAgAiADOgAFIAIgBEHAAXI6AARBAgwMCyABQQx2IQUgBEE/cUGAf3IhBCABQf//A00EQCACIAM6AAYgAiAEOgAFIAIgBUHgAXI6AARBAwwMCyACIAM6AAcgAiAEOgAGIAIgBUE/cUGAf3I6AAUgAiABQRJ2QXByOgAEQQQMCwsgASkDCCEGIAJBBToACCACIAY3AgwgAkEIaiACQR9qQaDSwAAQ1wEhASAAQgM3AwAgACABNgIIDAsLIAEpAgQhBiACQQU6AAggAiAGNwIMIAJBCGogAkEfakGg0sAAENcBIQEgAEIDNwMAIAAgATYCCAwKCyABKQMIIQYgAkEGOgAIIAIgBjcCDCACQQhqIAJBH2pBoNLAABDXASEBIABCAzcDACAAIAE2AggMCQsgASkCBCEGIAJBBjoACCACIAY3AgwgAkEIaiACQR9qQaDSwAAQ1wEhASAAQgM3AwAgACABNgIIDAgLIAJBCDoACCACQQhqIAJBH2pBoNLAABDXASEBIABCAzcDACAAIAE2AggMBwsgAkEIOgAIIAJBCGogAkEfakGg0sAAENcBIQEgAEIDNwMAIAAgATYCCAwGCyACQQc6AAggAkEIaiACQR9qQaDSwAAQ1wEhASAAQgM3AwAgACABNgIIDAULIAJBCToACCACQQhqIAJBH2pBoNLAABDXASEBIABCAzcDACAAIAE2AggMBAsgAkEKOgAIIAJBCGogAkEfakGg0sAAENcBIQEgAEIDNwMAIAAgATYCCAwDCyACQQs6AAggAkEIaiACQR9qQaDSwAAQ1wEhASAAQgM3AwAgACABNgIIDAILIAIgAToABEEBCzYCECACQQU6AAggAiACQQRqNgIMIAJBCGogAkEfakGg0sAAENcBIQEgAEIDNwMAIAAgATYCCAsgAkEgaiQAC5oHAQ1/IwBBoAFrIgMkACADQQA2AgwgA0KAgICAEDcCBCADQRBqIAEgAkGtq8AAQQEQMiADQYgBaiADQcgAaikDADcDACADQYABaiADQUBrKQMANwMAIANB+ABqIANBOGopAwA3AwAgA0HwAGogA0EwaikDADcDACADQegAaiADQShqKQMANwMAIANB4ABqIANBIGopAwA3AwAgA0HYAGoiDyADQRhqKQMANwMAIAMgAykDEDcDUEEBIQsCQANAAkACQAJAAkACQCADKAJQQQFGBEAgAygCjAEhBSADKAKIASEEIAMoAoQBIQcgAygCgAEhCCADKAJ0QX9GDQEgA0GUAWogDyAIIAcgBCAFQQAQcgwFCyADLQBeRQRAIAMtAFwhDCADKAKEASEEIAMoAoABIQgCQCADKAJUIgVFDQAgBCAFTQRAIAQgBUYNAQwJCyAFIAhqLAAAQUBIDQgLIAQgBUcEQAJ/IAUgCGoiDSwAACIHQQBIBEAgDS0AAUE/cSEKIAdBH3EhDiAOQQZ0IApyIAdBYEkNARogDS0AAkE/cSAKQQZ0ciEKIAogDkEMdHIgB0FwSQ0BGiAOQRJ0QYCA8ABxIA0tAANBP3EgCkEGdHJyDAELIAdB/wFxCyEHIAxBAXENAwJAAn9BASAHQYABSQ0AGkECIAdBgBBJDQAaQQNBBCAHQYCABEkbCyAFaiIFRQ0AIAQgBU0EQCAEIAVHDQoMAQsgBSAIaiwAAEFASA0JCyAEIAVGDQQgBSAIaiwAABoMAwsgAyAMQX9zQQFxOgBcIAUhBCAMQQFxDQQgA0EBOgBeCyADQQA2ApQBDAQLIANBlAFqIA8gCCAHIAQgBUEBEHIMAwsgBSEECyADQQA6AFwgAyAENgJUCyADIAQ2ApwBIAMgBDYCmAEgA0EBNgKUAQsgAygClAFBAUYEQCADKAKcASADKAKYASAJayIEIAMoAgQgBmtLBEAgA0EEaiAGIARBAUEBEMkBIAMoAgghCyADKAIMIQYLIAQEQCAGIAtqIAEgCWogBPwKAAALIAMgBCAGaiIGNgIMIQkMAQsLIAIgCWsiAiADKAIEIAZrSwRAIANBBGogBiACQQFBARDJASADKAIIIQsgAygCDCEGCyACBEAgBiALaiABIAlqIAL8CgAACyAAQQhqIAIgBmo2AgAgACADKQIENwIAIANBoAFqJAAPCyAIIAQgBSAEQfSxwAAQ6wIAC9QHAwR/A34BfCMAQTBrIgMkACABKAIAIQICQAJAAkACQAJAAkAgACgCAEEBaw4CAQIAC0EUIQEgACkDCCIHQpDOAFQEQCAHIQYMBAsDQCADQQhqIAFqIgBBBGsgByAHQpDOAIAiBkKQzgB+faciBEH//wNxQeQAbiIFQQF0LwDG0kA7AAAgAEECayAEIAVB5ABsa0H//wNxQQF0LwDG0kA7AAAgAUEEayEBIAdC/8HXL1YgBiEHDQALDAMLQRQhASAAKQMIIgggCEI/hyIGhSAGfSIHQpDOAFQEQCAHIQYMAgsDQCADQQhqIAFqIgBBBGsgByAHQpDOAIAiBkKQzgB+faciBEH//wNxQeQAbiIFQQF0LwDG0kA7AAAgAEECayAEIAVB5ABsa0H//wNxQQF0LwDG0kA7AAAgAUEEayEBIAdC/8HXL1YgBiEHDQALDAELIAArAwgiCb1C////////////AINCgICAgICAgPj/AFoEQCACKAIAIAIoAggiAWtBA00EQCACIAFBBEEBQQEQyQEgAigCCCEBCyACIAFBBGo2AgggAigCBCABakHu6rHjBjYAAAwDCyAJIANBCGoQKCIBIAIoAgAgAigCCCIAa0sEQCACIAAgAUEBQQEQyQEgAigCCCEACyABBEAgAigCBCAAaiADQQhqIAH8CgAACyACIAAgAWo2AggMAgsgBkLjAFYEQCABQQJrIgEgA0EIamogBqciACAAQf//A3FB5ABuIgBB5ABsa0H//wNxQQF0LwDG0kA7AAAgAK0hBgsCQCAGQgpaBEAgAUECayIAIANBCGpqIAanQQF0LwDG0kA7AAAMAQsgAUEBayIAIANBCGpqIAanQTByOgAACyAIQgBTBEAgAEEBayIAIANBCGpqQS06AAALQRQgAGsiBCACKAIAIAIoAggiAWtLBEAgAiABIARBAUEBEMkBIAIoAgghAQsgBARAIAIoAgQgAWogA0EIaiAAaiAE/AoAAAsgAiABIARqNgIIDAELIAZC4wBWBEAgAUECayIBIANBCGpqIAan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KALoAUEBdCIMNgKQAiADIAMoAuwBQQF0Ig02ApQCIAAgBSAGEHogAygCxAEhBSADKAJ4IQYgAygCUCEOIAMoAnwhDyADKAJUIRAgAygCgAEhESADKAJYIRIgAygChAEhEyADKAJcIRQgAygCiAEhFSADKAJgIRcgAygCjAEhGCADKAJkIRkgAygCkAEhGiADKAJoIRsgAygClAEhHCADKAJsIR0gAygCmAEhHiADKAJwIR8gAygCnAEhICADKAJ0ISEgAygCoAEhIiADKAKkASEjIAMoAqgBISQgAygCrAEhJSADKAKwASEmIAMoArQBIScgAygCuAEhKCADKAK8ASEpIAMoAsABISogA0GYAmogA0HwAWogFhB6IAAgBSANajYCdCAAIAwgKmo2AnAgACALIClqNgJsIAAgCiAoajYCaCAAIAkgJ2o2AmQgACAIICZqNgJgIAAgByAlajYCXCAAIAQgJGo2AlggACACICNqNgJUIAAgASAiajYCUCAAICAgIWo2AkwgACAeIB9qNgJIIAAgHCAdajYCRCAAIBogG2o2AkAgACAYIBlqNgI8IAAgFSAXajYCOCAAIBMgFGo2AjQgACARIBJqNgIwIAAgDyAQajYCLCAAIAYgDmo2AiggAEGYAWogA0G4AmopAgA3AgAgAEGQAWogA0GwAmopAgA3AgAgAEGIAWogA0GoAmopAgA3AgAgAEGAAWogA0GgAmopAgA3AgAgACADKQKYAjcCeCADQcACaiQAC9kIAgd/AX4jAEHAA2siByQAAkACQCACQSBGBEAgAUECai0AACELIAEoAAMhCSABKAAHIQIgASgACyEMIAEpAA8hDiABLwAAIQ0gB0HrAWogAUEfai0AADoAACAHIAs6AM4BIAcgDTsBzAEgByAONwDbASAHIAw2ANcBIAcgAjYA0wEgByAJNgDPASAHIAEpABc3AOMBIAdBmAJqIgggB0HMAWoiChBWIAcoApgCRQRAIAdBADYCmAIgByAIEJQCIAcoAgAhAiAHIAcoAgQiAzYCkAIgByACNgKMAiAHQQA2AtQBIAdCgICAgBA3AswBIAdB4LzAADYCnAIgB0KggICADjcCoAIgByAKNgKYAiAHQYwCaiEEIwBBMGsiASQAAn9BASAIQdKewwBBDxDpAg0AGkEAIAQoAgBFDQAaIAEgBDYCDCABQQE2AhQgAUHknsMANgIQIAFCATcCHCABIAFBDGqtQoCAgIDQD4Q3AyggASABQShqNgIYIAgoAgAgCCgCBCABQRBqEGALIAFBMGokAA0CIAcvAdABIAdB0gFqLQAAQRB0ciEBIActANcBIQQgBygA0wEhBSAHKALMASEGAkAgAkUNACADKAIAIggEQCACIAgRBAALIAMoAgQiCEUNACACIAggAygCCBD6AgsgACABOwEIIAAgBDoADyAAIAU2AAsgACAGNgIEIABBBDYCACAAQQpqIAFBEHY6AAAMAwsgB0E4aiAHQagCaigCADYCACAHIAcpAqACNwIwIAcoApwCIQggB0E8aiAHQawCakGQAfwKAAAgB0EraiABQRdqIgFBCGotAAA6AAAgB0EWaiACQRh2OgAAIAcgDjwAGyAHIA5CKIinIgo7ASAgB0EiaiAKQRB2OgAAIAcgASkAADcAIyAHIAJBCHY7ARQgByAINgIsIAcgDDYAFyAHIAJBGHQgCUEIdnI2AhAgByANIAtBEHRyIAlBGHRyNgIMIAcgDkIIiD4CHCAGQcAARgRAIAdBzgFqIAVBAmotAAA6AAAgB0HrAWogBUEfaikAADcAACAHQfMBaiAFQSdqKQAANwAAIAdB+wFqIAVBL2opAAA3AAAgB0GDAmogBUE3aikAADcAACAHQYsCaiAFQT9qLQAAOgAAIAcgBS8AADsBzAEgByAFKQAXNwDjASAFKAADIQEgB0HbAWogBUEPaikAADcAACAHIAE2AM8BIAcgBSkABzcA0wEgB0GYAmoiASAHQcwBahDqASAHQYwCaiAHQQxqIAMgBCABEIEBIABBCjYCACAAIAcoAowCIgBBAXM6AAQgAEUNAyAHKAKQAiIARQ0DIAcoApQCIgEoAgAiAgRAIAAgAhEEAAsgASgCBCICRQ0DIAAgAiABKAIIEPoCDAMLIABBAzYCAAwCCyAAIAI2AgggAEKAgICAgAQ3AgAMAQtBiL3AAEE3IAdBvwNqQfi8wABBwL3AABDmAQALIAdBwANqJAAL/wcBKH8jAEGgAmsiAyQAIAEoAgAhBCABKAIoIQcgASgCBCEIIAEoAiwhCSABKAIIIQogASgCMCELIAEoAgwhDCABKAI0IQ0gASgCECEFIAEoAjghBiABKAIUIQ4gASgCPCEPIAEoAhghECABKAJAIREgASgCHCESIAEoAkQhEyABKAIgIRQgASgCSCEVIAMgASgCJCABKAJMajYCLCADIBQgFWo2AiggAyASIBNqNgIkIAMgECARajYCICADIA4gD2o2AhwgAyAFIAZqNgIYIAMgDCANajYCFCADIAogC2o2AhAgAyAIIAlqNgIMIAMgBCAHajYCCCADQTBqIgQgAUEoaiABEHogA0HYAGoiBSADQQhqIAIQNiADQYABaiIGIAQgAkEoahA2IANBqAFqIhYgAUH4AGogAkHQAGoQNiADIAEoAlBBAXQiAjYC0AEgAyABKAJUQQF0IgQ2AtQBIAMgASgCWEEBdCIHNgLYASADIAEoAlxBAXQiCDYC3AEgAyABKAJgQQF0Igk2AuABIAMgASgCZEEBdCIKNgLkASADIAEoAmhBAXQiCzYC6AEgAyABKAJsQQF0Igw2AuwBIAMgASgCcEEBdCINNgLwASADIAEoAnRBAXQiATYC9AEgACAFIAYQeiADKALMASEFIAMoAoABIQYgAygCWCEOIAMoAoQBIQ8gAygCXCEQIAMoAogBIREgAygCYCESIAMoAowBIRMgAygCZCEUIAMoApABIRUgAygCaCEXIAMoApQBIRggAygCbCEZIAMoApgBIRogAygCcCEbIAMoApwBIRwgAygCdCEdIAMoAqABIR4gAygCeCEfIAMoAqQBISAgAygCfCEhIAMoAqgBISIgAygCrAEhIyADKAKwASEkIAMoArQBISUgAygCuAEhJiADKAK8ASEnIAMoAsABISggAygCxAEhKSADKALIASEqIANB+AFqIANB0AFqIBYQeiAAIAEgBWo2AnQgACANICpqNgJwIAAgDCApajYCbCAAIAsgKGo2AmggACAKICdqNgJkIAAgCSAmajYCYCAAIAggJWo2AlwgACAHICRqNgJYIAAgBCAjajYCVCAAIAIgImo2AlAgACAgICFqNgJMIAAgHiAfajYCSCAAIBwgHWo2AkQgACAaIBtqNgJAIAAgGCAZajYCPCAAIBUgF2o2AjggACATIBRqNgI0IAAgESASajYCMCAAIA8gEGo2AiwgACAGIA5qNgIoIABBmAFqIANBmAJqKQIANwIAIABBkAFqIANBkAJqKQIANwIAIABBiAFqIANBiAJqKQIANwIAIABBgAFqIANBgAJqKQIANwIAIAAgAykC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B0ECa0E3SSEWA0AgACAINgKYASAQIAAgDmoiA0GEAWopAAA3AwAgESADQYwBaikAADcDACASIANBlAFqKQAANwMAIAIgA0H8AGopAAA3AwAgCEUNAiAAIAhBAWsiBzYCmAEgAkGoAWoiBCADQfQAaiIXKQAANwMAIAJBoAFqIgUgA0HsAGoiGCkAADcDACACQZgBaiIGIANB5ABqIhkpAAA3AwAgAiADQdwAaiIaKQAANwOQASAJQRhqIBIpAwA3AAAgCUEQaiARKQMANwAAIAlBCGogECkDADcAACAJIAIpAwA3AAAgCiAAKQMANwMAIApBCGogAEEIaiILKQMANwMAIApBEGogAEEQaiIMKQMANwMAIApBGGogAEEYaiINKQMANwMAIAJBKGogBikDADcDACACQTBqIAUpAwA3AwAgAkE4aiAEKQMANwMAIAJBQGsgCSkDADcDACACQcgAaiACQbgBaikDADcDACACQdAAaiACQcABaikDADcDACACQdgAaiACQcgBaikDADcDACACIAIpA5ABNwMgIAJBwAA6AIgBIAIgDzoAiQEgAkIANwOAASAEIA0pAgA3AwAgBSAMKQIANwMAIAYgCykCADcDACACIAApAgA3A5ABIAJBkAFqIAJBIGpBwABCACAPECIgBCgCACEEIAUoAgAhBSAGKAIAIQYgAigCrAEhCyACKAKkASEMIAIoApwBIQ0gAigClAEhEyACKAKQASEUIBZFDQMgGiAUNgIAIANB+ABqIAs2AgAgFyAENgIAIANB8ABqIAw2AgAgGCAFNgIAIANB6ABqIA02AgAgGSAGNgIAIANB4ABqIBM2AgAgACAINgKYASAOQSBrIQ4gByIIIBVPDQALCyACQdABaiQADwtB5NnAABD8AgALIAIgCzYCrAEgAiAENgKoASACIAw2AqQBIAIgBTYCoAEgAiANNgKcASACIAY2ApgBIAIgEzYClAEgAiAUNgKQAUGs28AAQSsgAkGQAWpBnNzAAEH02cAAEOYBAAvuBgEHfyAAKAIAIgEEQCAAKAIEIQICQCAAKAIIIgcEfwNAAkAgBARAIAEhACAEIQEMAQtBACEAAkAgAkUNACACIQUgAkEHcSIDBEADQCAFQQFrIQUgASgCmAMhASADQQFrIgMNAAsLIAJBCEkNAANAIAEoApgDKAKYAygCmAMo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IAEgBGo2AhAgA0EEaiADQRBqEJ0BIAMoAgRBgICAgHhGBEAgACADKQIINwIEIABBiICAgHg2AgAMAQsgACADKQIENwIEIABBDGogA0EMaigCADYCACAAQYqAgIB4NgIACyADQdAAaiQADwsgCCAFIAQgBUHgzsAAEOsCAAvdBQEBfyAAQQAgAkH/AXFrIgIgACgCACIDIAEoAgBzcSADczYCACAAIAAoAgQiAyABKAIEcyACcSADczYCBCAAIAAoAggiAyABKAIIcyACcSADczYCCCAAIAAoAgwiAyABKAIMcyACcSADczYCDCAAIAAoAhAiAyABKAIQcyACcSADczYCECAAIAAoAhQiAyABKAIUcyACcSADczYCFCAAIAAoAhgiAyABKAIYcyACcSADczYCGCAAIAAoAhwiAyABKAIccyACcSADczYCHCAAIAAoAiAiAyABKAIgcyACcSADczYCICAAIAAoAiQiAyABKAIkcyACcSADczYCJCAAIAAoAigiAyABKAIocyACcSADczYCKCAAIAAoAiwiAyABKAIscyACcSADczYCLCAAIAAoAjAiAyABKAIwcyACcSADczYCMCAAIAAoAjQiAyABKAI0cyACcSADczYCNCAAIAAoAjgiAyABKAI4cyACcSADczYCOCAAIAAoAjwiAyABKAI8cyACcSADczYCPCAAIAAoAkAiAyABKAJAcyACcSADczYCQCAAIAAoAkQiAyABKAJEcyACcSADczYCRCAAIAAoAkgiAyABKAJIcyACcSADczYCSCAAIAAoAkwiAyABKAJMcyACcSADczYCTCAAIAAoAlAiAyABKAJQcyACcSADczYCUCAAIAAoAlQiAyABKAJUcyACcSADczYCVCAAIAAoAlgiAyABKAJYcyACcSADczYCWCAAIAAoAlwiAyABKAJccyACcSADczYCXCAAIAAoAmAiAyABKAJgcyACcSADczYCYCAAIAAoAmQiAyABKAJkcyACcSADczYCZCAAIAAoAmgiAyABKAJocyACcSADczYCaCAAIAAoAmwiAyABKAJscyACcSADczYCbCAAIAAoAnAiAyABKAJwcyACcSADczYCcCAAIAAoAnQiACABKAJ0cyACcSAAczYCdAvaBQIHfwF+An8gAUUEQCAAKAIIIQdBLSELIAVBAWoMAQtBK0GAgMQAIAAoAggiB0GAgIABcSIBGyELIAFBFXYgBWoLIQkCQCAHQYCAgARxRQRAQQAhAgwBCwJAIANBEE8EQCACIAMQQSEBDAELIANFBEBBACEBDAELIANBA3EhCgJAIANBBEkEQEEAIQEMAQsgA0EMcSEMQQAhAQNAIAEgAiAIaiIGLAAAQb9/SmogBkEBaiwAAEG/f0pqIAZBAmosAABBv39KaiAGQQNqLAAAQb9/SmohASAMIAhBBGoiCEcNAAsLIApFDQAgAiAIaiEGA0AgASAGLAAAQb9/SmohASAGQQFqIQYgCkEBayIKDQALCyABIAlqIQkLAkAgAC8BDCIIIAlLBEACQAJAIAdBgICACHFFBEAgCCAJayEIQQAhAUEAIQkCQAJAAkAgB0EddkEDcUEBaw4DAAEAAgsgCCEJDAELIAhB/v8DcUEBdiEJCyAHQf///wBxIQogACgCBCEHIAAoAgAhAANAIAFB//8DcSAJQf//A3FPDQJBASEGIAFBAWohASAAIAogBygCEBEAAEUNAAsMBAsgACAAKQIIIg2nQYCAgP95cUGwgICAAnI2AghBASEGIAAoAgAiByAAKAIEIgogCyACIAMQowINA0EAIQEgCCAJa0H//wNxIQIDQCABQf//A3EgAk8NAiABQQFqIQEgB0EwIAooAhARAABFDQALDAMLQQEhBiAAIAcgCyACIAMQowINAiAAIAQgBSAHKAIMEQEADQJBACEBIAggCWtB//8DcSECA0AgAUH//wNxIgMgAkkhBiACIANNDQMgAUEBaiEBIAAgCiAHKAIQEQAARQ0ACwwCCyAHIAQgBSAKKAIMEQEADQEgACANNwIIQQAPC0EBIQYgACgCACIBIAAoAgQiACALIAIgAxCjAg0AIAEgBCAFIAAoAgwRAQAhBgsgBgvABQIBfwZ+IwBBgAFrIgMkACADQTBqIAEQUCADIAMpA2AgAykDWCADKQNQIgRCGoh8IgdCGYh8IgWnQf///x9xNgIgIAMgAykDQCADKQM4IAMpAzAiCEIaiHwiCUIZiHwiBqdB////H3E2AhAgAyADKQNoIAVCGoh8IgWnQf///w9xNgIkIAMgAykDSCAGQhqIfCIGp0H///8PcTYCFCADIAMpA3AgBUIZiHwiBadB////H3E2AiggAyAHQv///w+DIARC////H4MgBkIZiHwiBEIaiHw+AhwgAyAEp0H///8fcTYCGCADIAMpA3ggBUIaiHwiBKdB////D3E2AiwgAyAJQv///w+DIARCGYhCE34gCEL///8fg3wiBEIaiHw+AgwgAyAEp0H///8fcTYCCCACQQJPBEAgAkEBayECA0AgA0EwaiADQQhqEFAgAyADKQNgIAMpA1ggAykDUCIEQhqIfCIHQhmIfCIFp0H///8fcTYCICADIAMpA0AgAykDOCADKQMwIghCGoh8IglCGYh8IganQf///x9xNgIQIAMgAykDaCAFQhqIfCIFp0H///8PcTYCJCADIAMpA0ggBkIaiHwiBqdB////D3E2AhQgAyADKQNwIAVCGYh8IgWnQf///x9xNgIoIAMgB0L///8PgyAEQv///x+DIAZCGYh8IgRCGoh8PgIcIAMgBKdB////H3E2AhggAyADKQN4IAVCGoh8IgSnQf///w9xNgIsIAMgCUL///8PgyAEQhmIQhN+IAhC////H4N8IgRCGoh8PgIMIAMgBKdB////H3E2AgggAkEBayICDQALCyAAIAMpAgg3AgAgAEEgaiADQShqKQIANwIAIABBGGogA0EgaikCADcCACAAQRBqIANBGGopAgA3AgAgAEEIaiADQRBqKQIANwIAIANBgAFqJAALlwYBBX8gAEEIayIBIABBBGsoAgAiA0F4cSIAaiECAkACQCADQQFxDQAgA0ECcUUNASABKAIAIgMgAGohACABIANrIgFB+OfEACgCAEYEQCACKAIEQQNxQQNHDQFB8OfEACAANgIAIAIgAigCBEF+cTYCBCABIABBAXI2AgQgAiAANgIADwsgASADEIYBCwJAAkACQAJAAkAgAigCBCIDQQJxRQRAIAJB/OfEACgCAEYNAiACQfjnxAAoAgBGDQMgAiADQXhxIgIQhgEgASAAIAJqIgBBAXI2AgQgACABaiAANgIAIAFB+OfEACgCAEcNAUHw58QAIAA2AgAPCyACIANBfnE2AgQgASAAQQFyNgIEIAAgAWogADYCAAsgAEGAAkkNAiABIAAQlQFBACEBQZDoxABBkOjEACgCAEEBayIANgIAIAANBEHY5cQAKAIAIgAEQANAIAFBAWohASAAKAIIIgANAAsLQZDoxABB/x8gASABQf8fTRs2AgAPC0H858QAIAE2AgBB9OfEAEH058QAKAIAIABqIgA2AgAgASAAQQFyNgIEQfjnxAAoAgAgAUYEQEHw58QAQQA2AgBB+OfEAEEANgIACyAAQYjoxAAoAgAiA00NA0H858QAKAIAIgJFDQNBACEAQfTnxAAoAgAiBEEpSQ0CQdDlxAAhAQNAIAIgASgCACIFTwRAIAIgBSABKAIEakkNBAsgASgCCCEBDAALAAtB+OfEACABNgIAQfDnxABB8OfEACgCACAAaiIANgIAIAEgAEEBcjYCBCAAIAFqIAA2AgAPCwJAQejnxAAoAgAiAkEBIABBA3Z0IgNxRQRAQejnxAAgAiADcjYCACAAQfgBcUHg5cQAaiIAIQIMAQsgAEH4AXEiAEHg5cQAaiECIABB6OXEAGooAgAhAAsgAiABNgIIIAAgATYCDCABIAI2AgwgASAANgIIDwtB2OXEACgCACIBBEADQCAAQQFqIQAgASgCCCIBDQALC0GQ6MQAQf8fIAAgAEH/H00bNgIAIAMgBE8NAEGI6MQAQX82AgALC8IFAgh/AnwjAEEwayIFJABBASEJIAEgASgCFCIHQQFqIgY2AhQgAUEMaiEIAkAgBiABKAIQIgpPDQACQAJAIAgoAgAgBmotAABBK2sOAwECAAILQQAhCQsgASAHQQJqIgY2AhQLAkACQCAGIApJBEAgASAGQQFqIgc2AhQgASgCDCIMIAZqLQAAQTBrQf8BcSIGQQpPBEAgBUENNgIkIAVBEGogCBCWAiAFQSRqIAUoAhAgBSgCFBCSAiEBIABBATYCACAAIAE2AgQMAwsgByAKTw0BA0AgByAMai0AAEEwa0H/AXEiC0EKTw0CIAEgB0EBaiIHNgIUIAZBzJmz5gBHIAtBB0tyIAZBy5mz5gBKcUUEQCAGQQpsIAtqIQYgByAKRw0BDAMLCyAAIAEgAiADUCAJEMcBDAILIAVBBTYCJCAFQRhqIAgQlgIgBUEkaiAFKAIYIAUoAhwQkgIhASAAQQE2AgAgACABNgIEDAELIAO6IQ0gAAJ/AkACQAJAAkACfyAJRQRAIAQgBmsiAUEfdUGAgICAeHMgASABIARIIAZBAEpzGwwBCyAEIAZqIgFBH3VBgICAgHhzIAEgBkEASCABIARIcxsLIgdBH3UiASAHcyABayIGQbUCTwRAA0AgDUQAAAAAAAAAAGENBSAHQQBODQIgDUSgyOuF88zhf6MhDSAHQbQCaiIHIAdBH3UiAXMgAWsiBkG1Ak8NAAsLIAZBA3QrA6ChQyEOIAdBAE4NASANIA6jIQ0MAwsgBUEONgIkIAVBCGogCBCWAiAAIAVBJGogBSgCCCAFKAIMEJICNgIEDAELIA0gDqIiDZlEAAAAAAAA8H9iDQEgBUEONgIkIAUgCBCWAiAAIAVBJGogBSgCACAFKAIEEJICNgIEC0EBDAELIAAgDSANmiACGzkDCEEACzYCAAsgBUEwaiQAC8wFAgZ/An4CQCACRQ0AIAJBB2siA0EAIAIgA08bIQcgAUEDakF8cSABayEIQQAhAwNAAkACQAJAIAEgA2otAAAiBcAiBkEATgRAIAggA2tBA3ENASADIAdPDQIDQCABIANqIgRBBGooAgAgBCgCAHJBgIGChHhxDQMgA0EIaiIDIAdJDQALDAILQoCAgICAICEKQoCAgIAQIQkCQAJAAn4CQAJAAkACQAJAAkACQAJAAkAgBS0AgM1EQQJrDgMAAQIKCyADQQFqIgQgAkkNAkIAIQpCACEJDAkLQgAhCiADQQFqIgQgAkkNAkIAIQkMCAtCACEKIANBAWoiBCACSQ0CQgAhCQwHCyABIARqLAAAQb9/Sg0GDAcLIAEgBGosAAAhBAJAAkAgBUHgAWsiBQRAIAVBDUYEQAwCBQwDCwALIARBYHFBoH9GDQQMAwsgBEGff0oNAgwDCyAGQR9qQf8BcUEMTwRAIAZBfnFBbkcNAiAEQUBIDQMMAgsgBEFASA0CDAELIAEgBGosAAAhBAJAAkACQAJAIAVB8AFrDgUBAAAAAgALIAZBD2pB/wFxQQJLIARBQE5yDQMMAgsgBEHwAGpB/wFxQTBPDQIMAQsgBEGPf0oNAQsgAiADQQJqIgRNBEBCACEJDAULIAEgBGosAABBv39KDQJCACEJIANBA2oiBCACTw0EIAEgBGosAABBQEgNBUKAgICAgOAADAMLQoCAgICAIAwCC0IAIQkgA0ECaiIEIAJPDQIgASAEaiwAAEG/f0wNAwtCgICAgIDAAAshCkKAgICAECEJCyAAIAogA62EIAmENwIEIABBATYCAA8LIARBAWohAwwCCyADQQFqIQMMAQsgAiADTQ0AA0AgASADaiwAAEEASA0BIAIgA0EBaiIDRw0ACwwCCyACIANLDQALCyAAIAI2AgggACABNgIEIABBADYCAAutBAIUfgl/IAAgASgCDCIYrSIPIAEoAgAiGUEBdK0iAn4gASgCBCIaQQF0rSIDIAEoAggiG60iB358IAEoAiAiHEETbK0iCCABKAIUIhZBAXStIgp+fCABKAIkIh1BE2ytIgQgASgCECIerSIFfiABKAIcIhdBE2ytIgwgASgCGCIBrSIJfnxCAYZ8NwMYIAAgAUETbK0iECAKfiACIBqtIhR+fCAIIBhBAXStIgZ+fCAEIAd+IAUgDH58QgGGfDcDCCAAIAYgCX4gHkEBdK0iESAWrSINfnwgF60iEiAbQQF0rSILfnwgHK0iDiADfnwgHa0iFSACfnw3A0ggACALIA1+IAUgBn58IAMgCX58IAIgEn58IAQgDn5CAYZ8NwM4IAAgAyAFfiALIA9+fCACIA1+fCAIIBdBAXStIhN+fCAEIAl+QgGGfDcDKCAAIAMgBn4gByAHfnwgAiAFfnwgCCABQQF0rX58IAQgCn4gDCASfnxCAYZ8NwMgIAAgAiAHfiADIBR+fCAJIBB+fCAIIBF+fCAEIAZ+IAogDH58QgGGfDcDECAAIBAgEX4gGa0iByAHfnwgCCALfnwgBiAMfiAWQRNsrSANfnwgAyAEfnxCAYZ8NwMAIAAgCSALfiAFIAV+fCAGIAp+fCADIBN+fCACIA5+fCAEIBV+QgGGfDcDQCAAIAYgD34gBSALfnwgAyAKfnwgAiAJfnwgCCAOfnwgBCATfkIBhnw3AzAL7wUCAn8CfiMAQeABayIHJAACQAJAAkACQCACQSBHBH9BAAUgBEEYRg0BQQELIQEgACACNgIIIABBIDYCBCAAIAE2AgAMAQsgASkAAyEJIAEoAAshAiABKQAPIQogB0EiaiADQQJqLQAAOgAAIAcgAy8AADsBICADLQAXIQQgAygAAyEIIAdBAmogAUECai0AADoAACAHQR9qIAFBH2otAAA6AAAgByAKNwAPIAcgAjYACyAHIAk3AAMgByABLwAAOwEAIAcgASkAFzcAFyAHIAg2ACMgB0EvaiADQQ9qKQAANwAAIAcgAykABzcAJyAHIAQ6ADcgB0G8AWogByAHQSBqEFcgB0GAAWpCADcCACAHQYgBakIANwIAIAdBkAFqQgA3AgAgB0GYAWpCADcCACAHQaABakIANwIAIAdBqAFqQgA3AgAgB0GwAWpCADcCACAHQgA3AnggB0HuyIGZAzYCTCAHQbLaiMsHNgJgQQAhASAHQQA6ALgBIAdB9MqB2QY2AnQgB0IANwJYIAcgBykBMCIJPgJQIAcgBykC1AE3AmwgByAHKQLMATcCZCAHIAcpAsQBNwJEIAcgBykCvAE3AjwgByAJQiCIPgJUIAdB5fDBiwY2AjggBkEASA0BAkAgBkUEQEEBIQIMAQtBASEBIAZBARCBAyICRQ0CCyAGBEAgAiAFIAb8CgAACyAHIAY2AsQBIAcgAjYCwAEgByACNgK8ASAHQThqIgEgB0G8AWoQJQ0CIAAgBjYCCCAAIAI2AgQgAEEKNgIAIAEQgwEgB0EANgI4IAdBADYCPCAHQQA2AkAgB0EANgJEIAdBADYCSCAHQQA2AkwgB0EANgJQIAdBADYCVCAHQQA2AlggB0EANgJcIAdBADYCYCAHQQA2AmQgB0EANgJoIAdBADYCbCAHQQA2AnAgB0EANgJ0CyAHQeABaiQADwsgASAGENsCAAtBuLnAAEErIAdB3wFqQai5wABB5LnAABDmAQALug4BCH8jAEEgayIGJAAgAAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABDigCAQEBAQEBAQEDBQEBBAEBAQEBAQEBAQEBAQEBAQEBAQEBCAEBAQEHAAsgAUHcAEYNBQsgAkEBcUUgAUH/BU1yDQdBEEEAIAFBq50ETxsiAiACQQhyIgMgAUELdCICIANBAnQoAvTTREELdEkbIgMgA0EEciIDIANBAnQoAvTTREELdCACSxsiAyADQQJyIgMgA0ECdCgC9NNEQQt0IAJLGyIDIANBAWoiAyADQQJ0KAL000RBC3QgAksbIgMgA0EBaiIDIANBAnQoAvTTREELdCACSxsiA0ECdCgC9NNEQQt0IgcgAkYgAiAHS2ogA2oiB0ECdCICQfTTxABqIQUgAigC9NNEQRV2IQJB/wUhAwJAIAdBH00EQCAFKAIEQRV2IQMgB0UNAQsgBUEEaygCAEH///8AcSEECwJAIAMgAkF/c2pFDQAgASAEayEEIANBAWshB0EAIQMDQCADIAJB8K3EAGotAABqIgMgBEsNASAHIAJBAWoiAkcNAAsLIAJBAXFFDQcgBkEOakEAOgAAIAZBADsBDCAGIAFBFHYtAPG1RDoADyAGIAFBBHZBD3EtAPG1RDoAEyAGIAFBCHZBD3EtAPG1RDoAEiAGIAFBDHZBD3EtAPG1RDoAESAGIAFBEHZBD3EtAPG1RDoAECABQQFyZ0ECdiICIAZBDGoiA2oiBEH7ADoAACAEQQFrQfUAOgAAIAMgAkECayICakHcADoAACAGQRRqIgMgAUEPcS0A8bVEOgAAIAAgBikBDDcAACAGQf0AOgAVDAgLIABCADcBAiAAQdzgADsBAAwKCyAAQgA3AQIgAEHc6AE7AQAMCQsgAEIANwECIABB3OQBOwEADAgLIABCADcBAiAAQdzcATsBAAwHCyAAQgA3AQIgAEHcuAE7AQAMBgsgAkGAAnFFDQEgAEIANwECIABB3M4AOwEADAULIAJB////B3FBgIAETw0DC0EAIQQCQAJAAkAgASIFQSBJDQAgAUH/AEkEQEEBIQMMAwsCQCAFQYCABE8EQCAFQYCACEkNASAFQf7//wBxIgJBrp0LRyAFQeD//wBxQeDNCkcgAkGe8ApHcXEgBUHw1wtrQXFJcSAFQYDwC2tB3mxJcSAFQYCADGtBnnRJcSAFQdCmDGtBe0lxIAVBgII4a0H65lRJcSAFQfCDOElxIQMMBAtBoNvEACECQaLbxAAhAyAFQQh2Qf8BcSEJA0ACQCADIQcgBCACLQABIgNqIQgCQCAJIAItAAAiAkcEQCACIAlLDQIMAQsgBCAISyAIQZwCS3JFBEAgBEHs28QAaiECA0AgA0UNAiADQQFrIQMgAi0AACACQQFqIQIgBUH/AXFHDQALDAULIAQgCEGcAkG84MQAEJgCAAsgB0ECQQAgB0Hs28QARxtqIQMgCCEEIAciAkHs28QARw0BCwtBASEDQQAhAgNAIAJBAWohBwJAIAIsAIjeRCIEQQBOBEAgByECDAELIAdBpAJHBEAgAkGJ3sQAai0AACAEQf8AcUEIdHIhBCACQQJqIQIMAQtBrODEABD8AgALIAUgBGsiBUEASA0EIANBAXMhAyACQaQCRw0ACwwDC0H41MQAIQJB+tTEACEDIAVBCHZB/wFxIQkDQCADIQcgBCACLQABIgNqIQgCQCAJIAItAAAiAkcEQCACIAlNDQEMBAsgBCAISyAIQdQBS3JFBEAgBEHU1cQAaiECA0AgA0UNAiADQQFrIQMgAi0AACACQQFqIQIgBUH/AXFHDQALDAMLIAQgCEHUAUG84MQAEJgCAAsgB0EAQQIgB0HU1cQARiIKG2ohAyAIIQQgByECIApFDQALDAELQQAhAwwBCyAFQf//A3EhBEEBIQNBACECA0AgAkEBaiEHAkAgAiwAqNdEIgVBAE4EQCAHIQIMAQsgB0H4A0cEQCACQanXxABqLQAAIAVB/wBxQQh0ciEFIAJBAmohAgwBC0Gs4MQAEPwCAAsgBCAFayIEQQBIDQEgA0EBcyEDIAJB+ANHDQALCyADQQFxDQEgBkEYakEAOgAAIAZBADsBFiAGIAFBFHYtAPG1RDoAGSAGIAFBBHZBD3EtAPG1RDoAHSAGIAFBCHZBD3EtAPG1RDoAHCAGIAFBDHZBD3EtAPG1RDoAGyAGIAFBEHZBD3EtAPG1RDoAGiABQQFyZ0ECdiICIAZBFmoiA2oiBEH7ADoAACAEQQFrQfUAOgAAIAMgAkECayICakHcADoAACAGQR5qIgMgAUEPcS0A8bVEOgAAIAAgBikBFjcAACAGQf0AOgAfCyAAQQhqIAMvAQA7AABBCgwDCyAAIAE2AgBBgAEhAkGBAQwCCyAAQgA3AQIgAEHcxAA7AQALQQAhAkECCzoADSAAIAI6AAwgBkEgaiQAC98EAQZ/AkACQCAAKAIIIgdBgICAwAFxRQ0AAkACQAJAAkAgB0GAgICAAXEEQCAALwEOIgMNAUEAIQIMAgsgAkEQTwRAIAEgAhBBIQMMBAsgAkUEQEEAIQIMBAsgAkEDcSEGAkAgAkEESQRADAELIAJBDHEhCANAIAMgASAFaiIELAAAQb9/SmogBEEBaiwAAEG/f0pqIARBAmosAABBv39KaiAEQQNqLAAAQb9/SmohAyAIIAVBBGoiBUcNAAsLIAZFDQMgASAFaiEEA0AgAyAELAAAQb9/SmohAyAEQQFqIQQgBkEBayIGDQALDAMLIAEgAmohCEEAIQIgASEEIAMhBQNAIAQiBiAIRg0CAn8gBkEBaiAGLAAAIgRBAE4NABogBkECaiAEQWBJDQAaIAZBA2ogBEFwSQ0AGiAGQQRqCyIEIAZrIAJqIQIgBUEBayIFDQALC0EAIQULIAMgBWshAwsgAyAALwEMIgRPDQAgBCADayEGQQAhA0EAIQUCQAJAAkAgB0EddkEDcUEBaw4CAAECCyAGIQUMAQsgBkH+/wNxQQF2IQULIAdB////AHEhCCAAKAIEIQcgACgCACEAA0AgA0H//wNxIAVB//8DcUkEQEEBIQQgA0EBaiEDIAAgCCAHKAIQEQAARQ0BDAMLC0EBIQQgACABIAIgBygCDBEBAA0BQQAhAyAGIAVrQf//A3EhAQNAIANB//8DcSICIAFJIQQgASACTQ0CIANBAWohAyAAIAggBygCEBEAAEUNAAsMAQsgACgCACABIAIgACgCBCgCDBEBACEECyAEC+wEAQh/IwBBEGsiBSQAAkACQCACKAIEIgNFDQAgACACKAIAIAMgASgCDBEBAEUNAEEBIQIMAQsgAigCDCIDRQRAQQAhAgwBCyACKAIIIgYgA0EMbGohCCAGQQxqIQMgBUEMaiEJA0AgBiECIAMhBgJAAkACQAJAIAIvAQBBAWsOAgIBAAsCQCACKAIEIgJBwQBPBEAgAUEMaigCACEDA0AgAEHBtsQAQcAAIAMRAQAEQEEBIQIMCAsgAkFAaiICQcAASw0ACwwBCyACRQ0DCyAAQcG2xAAgAiABQQxqKAIAEQEARQ0CQQEhAgwECyAAIAIoAgQgAigCCCABQQxqKAIAEQEARQ0BQQEhAgwDCyACLwECIQMgCUEAOgAAIAVBADYCCAJAAkACfwJAAkACQAJAIAIvAQBBAWsOAgECAAsgAigCBAwDCyACLwECIgINAUEBIQQMAwsgAigCCAwBCyACQfb/F2ogAkGc/x9qcSACQZj4N2ogAkHwsR9qcXNBEXZBAWoLIgRBBk8EQEEAIARBBUGEt8QAEJgCAAsgBA0AQQAhBAwBCyAFQQhqIARqIQIgBEEBcQRAIAJBAWsiAiADIANBCm4iA0EKbGtBMHI6AAALIARBAUYNACACQQJrIQIDQCACIANB//8DcSIHQQpuIgpBCnBBMHI6AAAgAkEBaiADIApBCmxrQTByOgAAIAdB5ABuIQMgAiAFQQhqRyACQQJrIQINAAsLIAAgBUEIaiAEIAFBDGooAgARAQBFDQBBASECDAILQQAhAiAGQQBBDCAGIAhGIgQbaiEDIARFDQALCyAFQRBqJAAgAgvsBAEJfyMAQdAAayICJAAgASgCACIHLwGSAyEIAkACQAJAQcgDQQgQgQMiBgRAIAZBADYCiAIgBiAHLwGSAyABKAIIIgVBf3NqIgQ7AZIDIAJBMGogB0GMAmoiCiAFQQxsaiIJQQhqKAIANgIAIAJBQGsgByAFQRhsaiIDQQhqKQMANwMAIAJByABqIANBEGopAwA3AwAgAiAJKQIANwMoIAIgAykDADcDOCAEQQxPDQEgBUEBaiEDIARBDGwiCQRAIAZBjAJqIAogA0EMbGogCfwKAAALIARBGGwiBARAIAYgByADQRhsaiAE/AoAAAsgByAFOwGSAyACQQhqIAJBMGooAgA2AgAgAkEYaiACQUBrKQMANwMAIAJBIGogAkHIAGopAwA3AwAgAiACKQMoNwMAIAIgAikDODcDECAGLwGSAyIEQQFqIQMgBEEMTw0CIAggBWsgA0cNAyAGQZgDaiEIIANBAnQiAwRAIAggByAFQQJ0akGcA2ogA/wKAAALIAEoAgQhBUEAIQEDQAJAIAggAUECdGooAgAiAyABOwGQAyADIAY2AogCIAEgBE8NACABIAEgBElqIgEgBE0NAQsLIAAgBTYCLCAAIAc2AiggACACKQMANwMAIAAgBTYCNCAAIAY2AjAgAEEIaiACQQhqKQMANwMAIABBEGogAkEQaikDADcDACAAQRhqIAJBGGopAwA3AwAgAEEgaiACQSBqKQMANwMAIAJB0ABqJAAPC0EIQcgDEJoDAAtBACAEQQtB6LXAABCYAgALQQAgA0EMQfi1wAAQmAIAC0GwtcAAQShB2LXAABCZAgALuCACFX8IfiMAQaADayIEJAAgBEGoAWoiAiABEG8gBEHwAWpBkOXAACkCADcDACAEQegBakGI5cAAKQIANwMAIARB4AFqQYDlwAApAgA3AwAgBEHYAWpB+OTAACkCADcDACAEQfDkwAApAgA3A9ABIwBB0ABrIgMkACADIAIQUCAEQfwBaiICIAMpAzAgAykDKCADKQMgIhdCGoh8IhtCGYh8IhinQf///x9xNgIYIAIgAykDECADKQMIIAMpAwAiHEIaiHwiGkIZiHwiGadB////H3E2AgggAiADKQM4IBhCGoh8IhinQf///w9xNgIcIAIgAykDGCAZQhqIfCIZp0H///8PcTYCDCACIAMpA0AgGEIZiHwiGKdB////H3E2AiAgAiAbQv///w+DIBdC////H4MgGUIZiHwiF0IaiHw+AhQgAiAXp0H///8fcTYCECACIAMpA0ggGEIaiHwiF6dB////D3E2AiQgAiAaQv///w+DIBdCGYhCE34gHEL///8fg3wiF0IaiHw+AgQgAiAXp0H///8fcTYCACADQdAAaiQAIARBpAJqIgMgAiAEQdABahB6IARB2ABqIAJByOTAABA2IAQgBCgCfDYC8AIgBCAEKQJ0NwLoAiAEIAQpAmw3AuACIAQgBCkCZDcC2AIgBCAEKQJcNwLQAiAEIAQoAlhBAWo2AswCIARB9AJqIQkjAEHwAmsiAiQAIAJBoAJqIgUgBEHMAmoiCBBQIAIgAikD0AIgAikDyAIgAikDwAIiF0IaiHwiG0IZiHwiGKdB////H3E2ApACIAIgAikDsAIgAikDqAIgAikDoAIiHEIaiHwiGkIZiHwiGadB////H3E2AoACIAIgAikD2AIgGEIaiHwiGKdB////D3E2ApQCIAIgAikDuAIgGUIaiHwiGadB////D3E2AoQCIAIgAikD4AIgGEIZiHwiGKdB////H3E2ApgCIAIgG0L///8PgyAXQv///x+DIBlCGYh8IhdCGoh8PgKMAiACIBenQf///x9xNgKIAiACIAIpA+gCIBhCGoh8IhenQf///w9xNgKcAiACIBpC////D4MgF0IZiEITfiAcQv///x+DfCIXQhqIfD4C/AEgAiAXp0H///8fcTYC+AEgAkEIaiIHIAJB+AFqIgYgCBA2IAUgBxBQIAIgAikD0AIgAikDyAIgAikDwAIiF0IaiHwiG0IZiHwiGKdB////H3E2ApACIAIgAikDsAIgAikDqAIgAikDoAIiHEIaiHwiGkIZiHwiGadB////H3E2AoACIAIgAikD2AIgGEIaiHwiGKdB////D3E2ApQCIAIgAikDuAIgGUIaiHwiGadB////D3E2AoQCIAIgAikD4AIgGEIZiHwiGKdB////H3E2ApgCIAIgG0L///8PgyAXQv///x+DIBlCGYh8IhdCGoh8PgKMAiACIBenQf///x9xNgKIAiACIAIpA+gCIBhCGoh8IhenQf///w9xNgKcAiACIBpC////D4MgF0IZiEITfiAcQv///x+DfCIXQhqIfD4C/AEgAiAXp0H///8fcTYC+AEgAkEwaiIKIAYgCBA2IAJBgAFqIgsgAyAHEDYgAkHQAWoiByADIAoQNiAFIAcQMyACQZgCaiACQcACaikCADcDACACQZACaiACQbgCaikCADcDACACQYgCaiACQbACaikCADcDACACQYACaiACQagCaikCADcDACACIAIpAqACNwP4ASAFIAZBAhBMIAJBqAFqIgogByAFEDYgAkHYAGoiDCALIAoQNiAFIAwQUCACIAIpA9ACIAIpA8gCIAIpA8ACIhdCGoh8IhtCGYh8IhinQf///x9xNgKQAiACIAIpA7ACIAIpA6gCIAIpA6ACIhxCGoh8IhpCGYh8IhmnQf///x9xNgKAAiACIAIpA9gCIBhCGoh8IhinQf///w9xNgKUAiACIAIpA7gCIBlCGoh8IhmnQf///w9xNgKEAiACIAIpA+ACIBhCGYh8IhinQf///x9xNgKYAiACIBtC////D4MgF0L///8fgyAZQhmIfCIXQhqIfD4CjAIgAiAXp0H///8fcTYCiAIgAiACKQPoAiAYQhqIfCIXp0H///8PcTYCnAIgAiAaQv///w+DIBdCGYhCE34gHEL///8fg3wiF0IaiHw+AvwBIAIgF6dB////H3E2AvgBIAcgCCAGEDYgBiAHEEUgBSADEEVBACEFQQEhBgNAIAJB+AFqIgcgBWotAAAgAkGgAmoiCCAFai0AAEYQ5wIgBnEhBiAFQQFqIgVBIEcNAAsgBhDnAiEVIAJB8P///wMgAygCGGutQfD///8BIAMoAhRrrUHw////AyADKAIQa60iF0IaiHwiG0IZiHwiGKdB////H3EiCjYCuAIgAkHw////AyADKAIIa61B8P///wEgAygCBGutQdD9//8DIAMoAgBrrSIcQhqIfCIaQhmIfCIZp0H///8fcSILNgKoAiACQfD///8BIAMoAhxrrSAYQhqIfCIYp0H///8PcSIMNgK8AiACQfD///8BIAMoAgxrrSAZQhqIfCIZp0H///8PcSINNgKsAiACQfD///8DIAMoAiBrrSAYQhmIfCIYp0H///8fcSIONgLAAiACIBdC////H4MgGUIZiHwiF6dB////H3EiDzYCsAIgAiAbQv///w+DIBdCGoh8pyIQNgK0AiACQfD///8BIAMoAiRrrSAYQhqIfCIXp0H///8PcSITNgLEAiACIBdCGYhCE34gHEL///8fg3wiF6dB////H3EiETYCoAIgAiAaQv///w+DIBdCGoh8pyISNgKkAiACQagBaiACQdABahBFIAcgCBBFQQAhBUEBIQYDQCACQagBaiIHIAVqLQAAIAJB+AFqIgMgBWotAABGEOcCIAZxIQYgBUEBaiIFQSBHDQALIAYQ5wIhFCACIBM2AsQCIAIgDjYCwAIgAiAMNgK8AiACIAo2ArgCIAIgEDYCtAIgAiAPNgKwAiACIA02AqwCIAIgCzYCqAIgAiASNgKkAiACIBE2AqACIAMgAkGgAmpB+OPAABA2IAJBgAFqIAJB0AFqEEUgByADEEVBACEFQQEhBgNAIAJBgAFqIAVqLQAAIAJBqAFqIAVqLQAARhDnAiAGcSEGIAVBAWoiBUEgRw0ACyAGEOcCIQMgAkGgAmpB+OPAACACQdgAaiIWEDYgAkHgAGoiBUEAIAMgFHIQ5wJB/wFxayIDIAUoAgAiBiACKAKoAnNxIAZzIgY2AgAgAkHoAGoiByAHKAIAIgggAigCsAJzIANxIAhzIgg2AgAgAkHwAGoiCiAKKAIAIgsgAigCuAJzIANxIAtzIgs2AgAgAiACKAJkIgwgAigCrAJzIANxIAxzIgw2AmQgAiACKAJcIg0gAigCpAJzIANxIA1zIg02AlwgAiACKAJYIg4gAigCoAJzIANxIA5zIg42AlggAiACKAJsIg8gAigCtAJzIANxIA9zIg82AmwgAiACKAJ0IhAgAigCvAJzIANxIBBzIhA2AnQgAkH4AGoiEyATKAIAIhEgAigCwAJzIANxIBFzIhE2AgAgAiADIAIoAnwiEiACKALEAnNxIBJzIhI2AnwgAkH4AWogFhBFIBNBACACLQD4AUEBcRDnAkH/AXFrIgNB8P///wMgEWutQfD///8BIBBrrUHw////AyALa61B8P///wEgD2utQfD///8DIAhrrSIXQhqIfCIbQhmIfCIYQhqIfCIcQhmIfCIap0H///8fcSARc3EgEXM2AgAgCiAYp0H///8fcSALcyADcSALczYCACAHIBdC////H4NB8P///wEgDGutQfD///8DIAZrrUHw////ASANa61B0P3//wMgDmutIhdCGoh8IhhCGYh8IhlCGoh8Ih1CGYh8Ih6nQf///x9xIAhzIANxIAhzNgIAIAUgGadB////H3EgBnMgA3EgBnM2AgAgAkHw////ASASa60gGkIaiHwiGqdB////D3EgEnMgA3EgEnM2AnwgAiAcp0H///8PcSAQcyADcSAQczYCdCACIA8gG0L///8PgyAeQhqIfKdzIANxIA9zNgJsIAIgHadB////D3EgDHMgA3EgDHM2AmQgAiAaQhmIQhN+IBdC////H4N8IhenQf///x9xIA5zIANxIA5zNgJYIAIgDSAYQv///w+DIBdCGoh8p3MgA3EgDXM2AlwgCSAUIBVyEOcCOgAAIAkgAikCWDcCBCAJQQxqIAUpAgA3AgAgCUEUaiAHKQIANwIAIAlBHGogCikCADcCACAJQSRqIBMpAgA3AgAgAkHwAmokACAEQeAAaiIDIARBgANqKQIANwMAIARB6ABqIgIgBEGIA2opAgA3AwAgBEHwAGoiBSAEQZADaikCADcDACAEQfgAaiIGIARBmANqKQIANwMAIARBiAFqIgkgBEGwAWopAgA3AwAgBEGQAWoiByAEQbgBaikCADcDACAEQZgBaiIIIARBwAFqKQIANwMAIARBoAFqIgogBEHIAWopAgA3AwAgBCAEKQL4AjcDWCAEIAQpAqgBNwOAASAELQD0AiELIARBKGogBikDADcDACAEQSBqIAUpAwA3AwAgBEEYaiACKQMANwMAIARBEGogAykDADcDACAEIAQpA1g3AwggBEHQAGogCikDADcDACAEQcgAaiAIKQMANwMAIARBQGsgBykDADcDACAEQThqIAkpAwA3AwAgBCAEKQOAATcDMCAAIAsEfyMAQTBrIgMkACABLQAfQQd2EOcCIQIgA0EIaiAEQQhqIgEQkAEgAUEAIAJB/wFxayICIAEoAgAiBSADKAIIc3EgBXM2AgAgASABKAIEIgUgAygCDHMgAnEgBXM2AgQgAUEIaiIFIAUoAgAiBiADKAIQcyACcSAGczYCACABIAEoAgwiBiADKAIUcyACcSAGczYCDCABQRBqIgYgBigCACIJIAMoAhhzIAJxIAlzNgIAIAEgASgCFCIJIAMoAhxzIAJxIAlzNgIUIAFBGGoiCSAJKAIAIgcgAygCIHMgAnEgB3M2AgAgASABKAIcIgcgAygCJHMgAnEgB3M2AhwgAUEgaiIHIAcoAgAiCCADKAIocyACcSAIczYCACABIAIgASgCJCIIIAMoAixzcSAIczYCJCAAQQRqIgBBIGogBykCADcCACAAQRhqIAkpAgA3AgAgAEEQaiAGKQIANwIAIABBCGogBSkCADcCACAAIAEpAgA3AgAgAEH4AGogASAE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EGoiDSAHNgIAIAIgAzYCHCACQRhqIgcgETYCACACIA42AiQgAkEgaiIDIA82AgAgAiALNgIsIAJBKGoiCyAWNgIAIAIgDDYCNCACQTBqIgwgFzYCACACIAk2AjwgAkE4aiIJIAo2AgAgAiAjNwMAIARBEGogEykDADcDACAEQRhqIA0pAwA3AwAgBEEgaiAHKQMANwMAIARBKGogAykDADcDACAEQTBqIAspAwA3AwAgBEE4aiAMKQMANwMAIARBQGsgCSkDADcDACAEICM3AwggBkEFRg0JIARBBTYCTCAGQfv///8AakH/////AHFBBWogBEHMAGpBwLTAABDgASEGIAJCAzcDACACIAY2AgggASgCECIGBEAgASgCFCAGQQEQ+gILIAEoAhwiBgRAIAEoAiAgBkEBEPoCCyABKAI0IgZBgICAgHhGIAZFckUEQCABKAI4IAZBARD6AgsgASgCKCIGBEAgASgCLCAGQQEQ+gILDAkLQQJB7LPAAEH0s8AAEOABCyEBIAJCAzcDACACIAE2AggMBAtBA0Hss8AAQfSzwAAQ4AEhCgsgAkIDNwMAIAIgCjYCCAwCC0EEQeyzwABB9LPAABDgAQshASACQgM3AwAgAiABNgIIIAxBgICAgHhyQYCAgIB4Rg0AIAogDEEBEPoCCyADRQ0AIA8gA0EBEPoCCyAHRQ0BIA0gB0EBEPoCDAELAkACQAJAAn8CfwJAIAUoAggiAUUEQEGBgICAeCENQYCAgIB4IQoMAQsgAUEFdCEgIAUoAgQhIUGBgICAeCENQYCAgIB4IQpBgICAgHghDEIDISMDQCABIQYCQAJAAkACQAJAAkACQAJAQRUgDyAhaiIDKAIAIg5BgICAgHhzIA5BAE4bQQFrDg8BAAACAAAAAAAAAAMEBQYACyADIARBzABqQYizwAAQwgIhDiAEQQE6AAggBCAONgIMDAYLIARBADoACCAEQQUgA0EEai0AACIOIA5BBU8bOgAJDAULIARBADoACCAEQgUgA0EIaikDACIkICRCBVobPAAJDAQLIARBCGogA0EIaigCACADQQxqKAIAEOQBDAMLIARBCGogA0EEaigCACADQQhqKAIAEOQBDAILIARBCGogA0EIaigCACADQQxqKAIAEHYMAQsgBEEIaiADQQRqKAIAIANBCGooAgAQdgsCQAJA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/////wFxIAZB/////wFxIAVB/////wFxIAJB/////wFxIAxB7afX5wFxIARB/////wFxaiICQR12aiANQdKxzARxaiIDQR12aiAOQZbrnO8BcWoiBEEddmogD0HF+s7vAXFqIgVBHXZqIBBBzQJxaiIGQR12aiIHQR12aiIIQR12aiIJQf////8BcTYCHCAAIAhB/////wFxNgIYIAAgB0H/////AXE2AhQgACAGQf////8BcTYCECAAIAVB/////wFxNgIMIAAgBEH/////AXE2AgggACADQf////8BcTYCBCAAIAJB/////wFxNgIAIAAgCUEddiALaiABQYCAwABxakH/////AXE2AiAL0QQBCn8jAEEwayIGJAACQCABQcABcSIKRQ0AIAZBCGogADYCACAKQcAARgRAQQEhBwwBCyAGIABBQGs2AgwgCkGAAUYEQEECIQcMAQsgBiAAQYABajYCEEGs28AAQSsgBkEQakGM3MAAQbjYwAAQ5gEACyAFQQV2IgkgByAHIAlLGyIIBEAgBkEIaiEJIANBBHIhCyAIQQV0IQxBACEDA0AgCSgCACEIIAZBKGoiDSACQRhqKQIANwMAIAZBIGoiDiACQRBqKQIANwMAIAZBGGoiDyACQQhqKQIANwMAIAYgAikCADcDECAGQRBqIAhBwABCACALECIgAyAEaiIIQRhqIA0pAwA3AAAgCEEQaiAOKQMANwAAIAhBCGogDykDADcAACAIIAYpAxA3AAAgCUEEaiEJIAwgA0EgaiIDRw0ACwsCQAJAAkAgAUE/cSICBEAgBSAHQQV0IgFJDQEgBSABayIDQR9NDQIgAkEgRw0DIAEgBGoiASAAIApqIgApAAA3AAAgAUEYaiAAQRhqKQAANwAAIAFBEGogAEEQaikAADcAACABQQhqIABBCGopAAA3AAAgB0EBaiEHCyAGQTBqJAAgBw8LIAEgBSAFQajYwAAQmAIAC0EAQSAgA0GI2MAAEJgCAAsjAEEwayIAJAAgAEEgNgIEIAAgAjYCACAAQQM2AgwgAEGE0sQANgIIIABCAjcCFCAAIABBBGqtQoCAgIDgCIQ3AyggACAArUKAgICA4AiENwMgIAAgAEEgajYCECAAQQhqQZjYwAAQvwIAC4cEAQV/IAAoAggiBCAAKAIARgRAIAAgBEEBQQFBARDJASAA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IAAoAjRBAEGAgIAIIAIbaiABKAAMQQh2aq0iCCAAKAIcIgJBBWytIgl+fCAAKAIwIAEoAAlBBnZqrSIKIAAoAiAiAUEFbK0iBH58IAMgB34gBSALfnwgBCAGfnwgCCARQQVsrSIMfnwgCSAKfnwgAyAEfiAFIAd+fCAGIAl+fCAIIBBBBWytfnwgCiAMfnwiCUIaiEL/////D4N8IgxCGohC/////w+DfCIOp0H///8fcTYCLCAAIAMgDX4gBSACrSIPfnwgBiALfnwgBCAIfnwgByAKfnwgDkIaiEL/////D4N8IgSnQf///x9xNgIwIAAgAyAPfiAFIAGtfnwgBiANfnwgByAIfnwgCiALfnwgBEIaiEL/////D4N8IgOnQf///x9xNgI0IAAgA0IaiKdBBWwgCadB////H3FqIgFB////H3E2AiQgACAMp0H///8fcSABQRp2ajYCKAvlAwIYfgF/IAExAAghCCABMQAHIQkgATEACSECIAExAAshCiABMQAKIQsgATEAFSEMIAExABQhDSABMQAWIQMgATEAGCEOIAExABchDyABMQAZIQQgATEAGyEQIAExABohESABMQAGIQUgATEABSESIAExAAQhEyABMQAPIRQgATEADiEVIAExAA0hFiABMQAMIQYgATEAHyEXIAExAB4hGCABMQAdIRkgATEAHCEHIAEoAAAhGiAAIAEoABAiAUH///8PcTYCFCAAIBpB////H3E2AgAgACAXQhKGQoCA8A+DIBlCAoYgB0IGiIQgGEIKhoSEPgIkIAAgFkIChiAGQgaIhCAVQgqGhCAUQhKGhD4CECAAIAVCFoZCgICADoMgGkEadq0gE0IGhoQgEkIOhoSEPgIEIAAgEEIMhiARQgSGhCAEQgSIhCAHQhSGhKdB////H3E2AiAgACAOQg2GIA9CBYaEIANCA4iEIARCFYaEp0H///8PcTYCHCAAIAFBGXatIAxCD4YgDUIHhoSEIANCF4aEp0H///8fcTYCGCAAIApCC4YgC0IDhoQgAkIFiIQgBkIThoSnQf///w9xNgIMIAAgCEINhiAJQgWGhCAFQgOIhCACQhWGhKdB////H3E2AggLqyQCE38CfiMAQTBrIhAkAAJAAkACQAJ/IAEoAgAiDQRAIAIoAgghCyACKAIEIQkgASgCBCEFAkADQCANQYwC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eHMgBiAFQQBKIAQgBkpzGwwBCyAEIAVqIgZBH3VBgICAgHhzIAYgBUEASCAEIAZKcxsLEKEBCyAHQSBqJAALsgMBB38jAEEwayIEJAACQAJAAkACQCABKAIEIgIEQCABKAIAIQYgAkEDcSEFAkAgAkEESQRAQQAhAgwBCyAGQRxqIQMgAkF8cSEIQQAhAgNAIAMoAgAgA0EIaygCACADQRBrKAIAIANBGGsoAgAgAmpqamohAiADQSBqIQMgCCAHQQRqIgdHDQALCyAFBEAgB0EDdCAGakEEaiEDA0AgAygCACACaiECIANBCGohAyAFQQFrIgUNAAsLIAEoAgxFDQIgAkEPSw0BIAYoAgQNAQwDC0EAIQIgASgCDEUNAgsgAkEAIAJBAEobQQF0IQILQQAhAyACQQBOBEAgAkUNAUEBIQMgAkEBEIEDIgUNAgsgAyACENsCAAtBASEFQQAhAgsgBEEANgIMIAQgBTYCCCAEIAI2AgQgBEEgaiABQRBqKQIANwMAIARBGGogAUEIaikCADcDACAEIAEpAgA3AxAgBEEEakHYrcQAIARBEGoQYEUEQCAAIAQpAgQ3AgAgAEEIaiAEQQxqKAIANgIAIARBMGokAA8LQcSsxABB1gAgBEEvakG0rMQAQZytxAAQ5gEAC+EDAgZ+Dn8gAigCJCEJIAEoAiQhCiACKAIgIQsgASgCICEMIAIoAgwhDSABKAIMIQ4gAigCHCEPIAEoAhwhECACKAIIIREgASgCCCESIAIoAgQhEyABKAIEIRQgAigCACEVIAEoAgAhFiAAIAEoAhggAigCGGtB8P///wNqrSABKAIUIAIoAhRrQfD///8Baq0gASgCECACKAIQa0Hw////A2qtIgNCGoh8IgZCGYh8IgSnQf///x9xNgIYIAAgEiARa0Hw////A2qtIBQgE2tB8P///wFqrSAWIBVrQdD9//8Daq0iB0IaiHwiCEIZiHwiBadB////H3E2AgggACAQIA9rQfD///8Baq0gBEIaiHwiBKdB////D3E2AhwgACAOIA1rQfD///8Baq0gBUIaiHwiBadB////D3E2AgwgACAMIAtrQfD///8Daq0gBEIZiHwiBKdB////H3E2AiAgACAGQv///w+DIANC////H4MgBUIZiHwiA0IaiHw+AhQgACADp0H///8fcTYCECAAIAogCWtB8P///wFqrSAEQhqIfCIDp0H///8PcTYCJCAAIAhC////D4MgA0IZiEITfiAHQv///x+DfCIDQhqIfD4CBCAAIAOnQf///x9xNgIAC8kDAQN/IAAoAgAiASgCqAEEQCABQQA2AqgBCyABKAKcECICBEAgASgCmBAhAANAIAAoAgAiAwRAIABBBGooAgAgA0EBEPoCCyAAQQxqIQAgAkEBayICDQALCyABKAKUECIABEAgASgCmBAgAEEMbEEEEPoCCyABKAKIECIAQYCAgIB4RiAARXJFBEAgASgCjBAgAEEBEPoCCyABKALwDyIABEAgASgC9A8gAEEBEPoCCyABKAL8DyIABEAgASgCgBAgAEEBEPoCCyABQZgPaiICEJEBAkAgASgCnA8iAEUNACAAIABBA3RBD2pBeHEiA2pBCWoiAEUNACACKAIAIANrIABBCBD6AgsgAUHID2oiAhCFAQJAIAEoAswPIgBFDQAgACAAQQN0QQ9qQXhxIgNqQQlqIgBFDQAgAigCACADayAAQQgQ+gILIAEoAqgQIgIEQCABKAKkECEAA0AgACgCACIDBEAgAEEEaigCACADQQEQ+gILIABBDGohACACQQFrIgINAAsLIAEoAqAQIgAEQCABKAKkECAAQQxsQQQQ+gILAkAgAUF/Rg0AIAEgASgCBEEBayIANgIEIAANACABQfARQQgQ+gILC+cCAQV/IwBB8AFrIgIkACACQaABaiIDIAFB0ABqEDMgAkHwAGogAkHAAWopAgA3AwAgAkHoAGogAkG4AWopAgA3AwAgAkHgAGogAkGwAWopAgA3AwAgAkHYAGogAkGoAWopAgA3AwAgAiACKQKgATcDUCACQZgBaiACQegBaikCADcDACACQZABaiACQeABaikCADcDACACQYgBaiACQdgBaikCADcDACACQYABaiACQdABaikCADcDACACIAIpAsgBNwN4IAMgAkHQAGoiBkEFEEwgAkEIaiIEIAMgAkH4AGoiBRA2IAUgASAEEDYgAyABQShqIAQQNiACQTBqIAMQRSAGIAUQRSACLQBQQQFxEOcCIQEgACACKQAwNwAAIABBCGogAkE4aikAADcAACAAQRBqIAJBQGspAAA3AAAgAiACLQBPIAFBB3RzOgBPIABBGGogAkHIAGopAAA3AAAgAkHwAWokAAuWAwEEfwJAAkACQAJAAkACQCAHIAhWBEAgByAIfSAIWA0DIAYgByAGfVQgByAGQgGGfSAIQgGGWnENAiAGIAhYDQYgByAGIAh9IgZ9IAZWDQYgAiADTw0BQQAgAyACQcDExAAQmAIACyAAQQA2AgAPCyABIANqIQwgASEKAkACQAJAA0AgAyAJRg0BIAlBAWohCSAKQQFrIgogA2oiCy0AAEE5Rg0ACyALIAstAABBAWo6AAAgAyAJa0EBaiIFIANNDQEgBSADIANB/LnEABCYAgALAkAgA0UEQEExIQkMAQsgAUExOgAAQTAhCSADQQFrIgpFDQAgAUEBakEwIAr8CwALIARBAWrBIgQgBcFMIAIgA01yDQEgDCAJOgAAIANBAWohAwwBCyAJQQFrIgVFDQAgC0EBakEwIAX8CwALIAIgA0kNAgwDCyACIANPDQJBACADIAJB0MTEABCYAgALIABBADYCAA8LQQAgAyACQbDExAAQmAIACyAAIAQ7AQggACADNgIEIAAgATYCAA8LIABBADYCAAuZAwECfwJAAkACQCAALQBoIgMEQCADQcEATw0DIAJBwAAgA2siBCACIARJGyIEBEAgACADaiABIAT8CgAACyAAIAAtAGggBGoiAzoAaCABIARqIQEgAiAEayICRQRAQQAhAgwCCyAAQUBrIABBwAAgACkDYCAALQBqIAAtAGlFchAiIABCADcDACAAQQA6AGggAEEIakIANwMAIABBEGpCADcDACAAQRhqQgA3AwAgAEEgakIANwMAIABBKGpCADcDACAAQTBqQgA3AwAgAEE4akIANwMAIAAgAC0AaUEBajoAaQtBACEDIAJBwQBJDQEgAEFAayEEIAAtAGkhAwNAIAQgAUHAACAAKQNgIAAtAGogA0H/AXFFchAiIAAgAC0AaUEBaiIDOgBpIAFBQGshASACQUBqIgJBwABLDQALIAAtAGghAwsgA0H/AXEiA0HBAE8NAQsgAkHAACADayIEIAIgBEkbIgIEQCAAIANqIAEgAvwKAAALIAAgAC0AaCACajoAaCAADwsgA0HAAEHAAEGU18AAEJgCAAuVAwEHfyAAIAEoAiAiAjoAHSAAIAEoAgAiBToAACAAIAJBEHY6AB8gACACQQh2OgAeIAAgASgCHCIGQRV2OgAcIAAgBkENdjoAGyAAIAZB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KAI8ISIgBigCHCEYIAYoAkQhGSABIAYoAiQgBigCTGo2AowOIAEgFSAXajYCiA4gASAYIBlqNgKEDiABIA0gEmo2AoAOIAEgISAiajYC/A0gASAKIAxqNgL4DSABIB8gIGo2AvQNIAEgAyAHajYC8A0gASAeICVqNgLsDSABIBYgHWo2AugNIAFBkA5qIgcgBkEoaiAGEHogAUHYDmogBkHwAGoiFSkCADcCACABQdAOaiAGQegAaiIXKQIANwIAIAFByA5qIAZB4ABqIhIpAgA3AgAgAUHADmogBkHYAGoiFikCADcCACABIAYpAlA3ArgOIAFBCGoiSiIDIAZB+ABqQdDjwAAQNiABQYAPaiABQShqKQIANwIAIAFB+A5qIAFBIGopAgA3AgAgAUHwDmogAUEYaikCADcCACABQegOaiABQRBqKQIANwIAIAEgASkCCDcC4A4gAyABQegNaiIDQaAB/AoAACABQagBaiInIANBoAH8CgAAIAFByAJqIjggA0GgAfwKAAAgAUHoA2oiQSADQaAB/AoAACABQYgFaiJFIANBoAH8CgAAIAFBqAZqIkcgA0GgAfwKAAAgAUHIB2oiSyADQaAB/AoAACABQegIaiJNIANBoAH8CgAAIAFBkA1qIgogECkCADcDACABQYgNaiIMIBQpAgA3AwAgAUGADWoiDSARKQIANwMAIAFB+AxqIhEgEykCADcDACABQaANaiITIBYpAgA3AwAgAUGoDWoiFCASKQIANwMAIAFBsA1qIhIgFykCADcDACABQbgNaiIXIBUpAgA3AwAgASAGKQIoNwPwDCABIAYpAlA3A5gNIAFB6AxqIA8pAgA3AwAgAUHgDGogDikCADcDACABQdgMaiAaKQIANwMAIAFB0AxqIAkpAgA3AwAgASAGKQIANwPIDCADIAFByAxqIhoQLCABQYgKaiIdIAMgAUHgDmoiBhA2IAFBsA9qIh4gByABQbgOaiIJEDYgAUHYD2oiDiAJIAYQNiABQagLaiIlIAMgBxA2IAFB0ApqIAFB0A9qIh8pAgA3AgAgAUHICmogAUHID2oiICkCADcCACABQcAKaiABQcAPaiIhKQIANwIAIAFBuApqIAFBuA9qIiIpAgA3AgAgAUHgCmogAUHgD2oiDykCADcCACABQegKaiABQegPaiIQKQIANwIAIAFB8ApqIAFB8A9qIhUpAgA3AgAgAUH4CmogAUH4D2oiFikCADcCACABIAEpArAPNwKwCiABIAEpAtgPNwLYCiABQaALaiABQcgLaikCADcCACABQZgLaiABQcALaikCADcCACABQZALaiABQbgLaikCADcCACABQYgLaiABQbALaikCADcCACABIAEpAqgLNwKACyADIB0gShA+IBogAyAGEDYgAUGID2oiGCAHIAkQNiAeIAkgBhA2IA4gAyAHEDYgCiABQagPaiIZKQIANwIAIAwgAUGgD2oiGykCADcCACANIAFBmA9qIhwpAgA3AgAgESABQZAPaiIjKQIANwIAIBMgIikCADcCACAUICEpAgA3AgAgEiAgKQIANwIAIBcgHykCADcCACABIAEpAogPNwLwDCABIAEpArAPNwKYDSABQeANaiIkIBYpAgA3AgAgAUHYDWoiJiAVKQIANwIAIAFB0A1qIjkgECkCADcCACABQcgNaiI6IA8pAgA3AgAgASABKQLYDzcCwA0gESgCACEoIA0oAgAhKSAMKAIAISogCigCACErIAEoAsgMISwgASgC8AwhLSABKALMDCEuIAEoAvQMIS8gASgC0AwhMCABKALUDCFCIAEoAvwMIUMgASgC2AwhMSABKALcDCEyIAEoAoQNITMgASgC4AwhNCABKALkDCE1IAEoAowNITYgASgC6AwhNyABIAEoAuwMIAEoApQNajYCzAsgASArIDdqNgLICyABIDUgNmo2AsQLIAEgKiA0ajYCwAsgASAyIDNqNgK8CyABICkgMWo2ArgLIAEgQiBDajYCtAsgASAoIDBqNgKwCyABIC4gL2o2AqwLIAEgLCAtajYCqAsgAUHQC2oiKCABQfAMaiIpIBoQeiABQZgMaiIqIBcpAgA3AgAgAUGQDGoiKyASKQIANwIAIAFBiAxqIiwgFCkCADcCACABQYAMaiItIBMpAgA3AgAgASABKQKYDTcC+AsgDiABQcANaiIuQdDjwAAQNiABQcAMaiIvIBYpAgA3AgAgAUG4DGoiMCAVKQIANwIAIAFBsAxqIkIgECkCADcCACABQagMaiJDIA8pAgA3AgAgASABKQLYDzcCoAwgJyAlQaAB/AoAACADIB0gJxA+IBogAyAGEDYgGCAHIAkQNiAeIAkgBhA2IA4gAyAHEDYgCiAZKQIANwIAIAwgGykCADcCACANIBwpAgA3AgAgESAjKQIANwIAIBMgIikCADcCACAUICEpAgA3AgAgEiAgKQIANwIAIBcgHykCADcCACABIAEpAogPNwLwDCABIAEpArAPNwKYDSAkIBYpAgA3AgAgJiAVKQIANwIAIDkgECkCADcCACA6IA8pAgA3AgAgASABKQLYDzcCwA0gESgCACEnIA0oAgAhMSAMKAIAITIgCigCACEzIAEoAsgMITQgASgC8AwhNSABKALMDCE2IAEoAvQMITcgASgC0AwhOyABKALUDCE8IAEoAvwMIT0gASgC2AwhPiABKALcDCE/IAEoAoQNIUAgASgC4AwhRCABKALkDCFGIAEoAowNIUggASgC6AwhTiABIAEoAuwMIAEoApQNajYCzAsgASAzIE5qNgLICyABIEYgSGo2AsQLIAEgMiBEajYCwAsgASA/IEBqNgK8CyABIDEgPmo2ArgLIAEgPCA9ajYCtAsgASAnIDtqNgKwCyABIDYgN2o2AqwLIAEgNCA1ajYCqAsgKCApIBoQeiAqIBcpAgA3AgAgKyASKQIANwIAICwgFCkCADcCACAtIBMpAgA3AgAgASABKQKYDTcC+AsgDiAuQdDjwAAQNiAvIBYpAgA3AgAgMCAVKQIANwIAIEIgECkCADcCACBDIA8pAgA3AgAgASABKQLYDzcCoAwgOCAlQaAB/AoAACADIB0gOBA+IBogAyAGEDYgGCAHIAkQNiAeIAkgBhA2IA4gAyAHEDYgCiAZKQIANwIAIAwgGykCADcCACANIBwpAgA3AgAgESAjKQIANwIAIBMgIikCADcCACAUICEpAgA3AgAgEiAgKQIANwIAIBcgHykCADcCACABIAEpAogPNwLwDCABIAEpArAPNwKYDSAkIBYpAgA3AgAgJiAVKQIANwIAIDkgECkCADcCACA6IA8pAgA3AgAgASABKQLYDzcCwA0gESgCACEnIA0oAgAhOCAMKAIAITEgCigCACEyIAEoAsgMITMgASgC8AwhNCABKALMDCE1IAEoAvQMITYgASgC0AwhNyABKALUDCE7IAEoAvwMITwgASgC2AwhPSABKALcDCE+IAEoAoQNIT8gASgC4AwhQCABKALkDCFEIAEoAowNIUYgASgC6AwhSCABIAEoAuwMIAEoApQNajYCzAsgASAyIEhqNgLICyABIEQgRmo2AsQLIAEgMSBAajYCwAsgASA+ID9qNgK8CyABIDggPWo2ArgLIAEgOyA8ajYCtAsgASAnIDdqNgKwCyABIDUgNmo2AqwLIAEgMyA0ajYCqAsgKCApIBoQeiAqIBcpAgA3AgAgKyASKQIANwIAICwgFCkCADcCACAtIBMpAgA3AgAgASABKQKYDTcC+AsgDiAuQdDjwAAQNiAvIBYpAgA3AgAgMCAVKQIANwIAIEIgECkCADcCACBDIA8pAgA3AgAgASABKQLYDzcCoAwgQSAlQaAB/AoAACADIB0gQRA+IBogAyAGEDYgGCAHIAkQNiAeIAkgBhA2IA4gAyAHEDYgCiAZKQIANwIAIAwgGykCADcCACANIBwpAgA3AgAgESAjKQIANwIAIBMgIikCADcCACAUICEpAgA3AgAgEiAgKQIANwIAIBcgHykCADcCACABIAEpAogPNwLwDCABIAEpArAPNwKYDSAkIBYpAgA3AgAgJiAVKQIANwIAIDkgECkCADcCACA6IA8pAgA3AgAgASABKQLYDzcCwA0gESgCACEnIA0oAgAhOCAMKAIAIUEgCigCACExIAEoAsgMITIgASgC8AwhMyABKALMDCE0IAEoAvQMITUgASgC0AwhNiABKALUDCE3IAEoAvwMITsgASgC2AwhPCABKALcDCE9IAEoAoQNIT4gASgC4AwhPyABKALkDCFAIAEoAowNIUQgASgC6AwhRiABIAEoAuwMIAEoApQNajYCzAsgASAxIEZqNgLICyABIEAgRGo2AsQLIAEgPyBBajYCwAsgASA9ID5qNgK8CyABIDggPGo2ArgLIAEgNyA7ajYCtAsgASAnIDZqNgKwCyABIDQgNWo2AqwLIAEgMiAzajYCqAsgKCApIBoQeiAqIBcpAgA3AgAgKyASKQIANwIAICwgFCkCADcCACAtIBMpAgA3AgAgASABKQKYDTcC+AsgDiAuQdDjwAAQNiAvIBYpAgA3AgAgMCAVKQIANwIAIEIgECkCADcCACBDIA8pAgA3AgAgASABKQLYDzcCoAwgRSAlQaAB/AoAACADIB0gRRA+IBogAyAGEDYgGCAHIAkQNiAeIAkgBhA2IA4gAyAHEDYgCiAZKQIANwIAIAwgGykCADcCACANIBwpAgA3AgAgESAjKQIANwIAIBMgIikCADcCACAUICEpAgA3AgAgEiAgKQIANwIAIBcgHykCADcCACABIAEpAogPNwLwDCABIAEpArAPNwKYDSAkIBYpAgA3AgAgJiAVKQIANwIAIDkgECkCADcCACA6IA8pAgA3AgAgASABKQLYDzcCwA0gESgCACEnIA0oAgAhOCAMKAIAIUEgCigCACFFIAEoAsgMITEgASgC8AwhMiABKALMDCEzIAEoAvQMITQgASgC0AwhNSABKALUDCE2IAEoAvwMITcgASgC2AwhOyABKALcDCE8IAEoAoQNIT0gASgC4AwhPiABKALkDCE/IAEoAowNIUAgASgC6AwhRCABIAEoAuwMIAEoApQNajYCzAsgASBEIEVqNgLICyABID8gQGo2AsQLIAEgPiBBajYCwAsgASA8ID1qNgK8CyABIDggO2o2ArgLIAEgNiA3ajYCtAsgASAnIDVqNgKwCyABIDMgNGo2AqwLIAEgMSAyajYCqAsgKCApIBoQeiAqIBcpAgA3AgAgKyASKQIANwIAICwgFCkCADcCACAtIBMpAgA3AgAgASABKQKYDTcC+AsgDiAuQdDjwAAQNiAvIBYpAgA3AgAgMCAVKQIANwIAIEIgECkCADcCACBDIA8pAgA3AgAgASABKQLYDzcCoAwgRyAlQaAB/AoAACADIB0gRxA+IBogAyAGEDYgGCAHIAkQNiAeIAkgBhA2IA4gAyAHEDYgCiAZKQIANwIAIAwgGykCADcCACANIBwpAgA3AgAgESAjKQIANwIAIBMgIikCADcCACAUICEpAgA3AgAgEiAgKQIANwIAIBcgHykCADcCACABIAEpAogPNwLwDCABIAEpArAPNwKYDSAkIBYpAgA3AgAgJiAVKQIANwIAIDkgECkCADcCACA6IA8pAgA3AgAgASABKQLYDzcCwA0gESgCACEnIA0oAgAhOCAMKAIAIUEgCigCACFFIAEoAsgMIUcgASgC8AwhMSABKALMDCEyIAEoAvQMITMgASgC0AwhNCABKALUDCE1IAEoAvwMITYgASgC2AwhNyABKALcDCE7IAEoAoQNITwgASgC4AwhPSABKALkDCE+IAEoAowNIT8gASgC6AwhQCABIAEoAuwMIAEoApQNajYCzAsgASBAIEVqNgLICyABID4gP2o2AsQLIAEgPSBBajYCwAsgASA7IDxqNgK8CyABIDcgOGo2ArgLIAEgNSA2ajYCtAsgASAnIDRqNgKwCyABIDIgM2o2AqwLIAEgMSBHajYCqAsgKCApIBoQeiAqIBcpAgA3AgAgKyASKQIANwIAICwgFCkCADcCACAtIBMpAgA3AgAgASABKQKYDTcC+AsgDiAuQdDjwAAQNiAvIBYpAgA3AgAgMCAVKQIANwIAIEIgECkCADcCACBDIA8pAgA3AgAgASABKQLYDzcCoAwgSyAlQaAB/AoAACADIB0gSxA+IBogAyAGEDYgGCAHIAkQNiAeIAkgBhA2IA4gAyAHEDYgCiAZKQIANwIAIAwgGykCADcCACANIBwpAgA3AgAgESAjKQIANwIAIBMgIikCADcCACAUICEpAgA3AgAgEiAgKQIANwIAIBcgHykCADcCACABIAEpAogPNwLwDCABIAEpArAPNwKYDSAkIBYpAgA3AgAgJiAVKQIANwIAIDkgECkCADcCACA6IA8pAgA3AgAgASABKQLYDzcCwA0gESgCACEDIA0oAgAhBiAMKAIAIQcgCigCACEJIAEoAsgMIQogASgC8AwhDCABKALMDCENIAEoAvQMIREgASgC0AwhHSABKALUDCEeIAEoAvwMIR8gASgC2AwhICABKALcDCEhIAEoAoQNISIgASgC4AwhGCABKALkDCEZIAEoAowNIRsgASgC6AwhHCABIAEoAuwMIAEoApQNajYCzAsgASAJIBxqNgLICyABIBkgG2o2AsQLIAEgByAYajYCwAsgASAhICJqNgK8CyABIAYgIGo2ArgLIAEgHiAfajYCtAsgASADIB1qNgKwCyABIA0gEWo2AqwLIAEgCiAMajYCqAsgKCApIBoQeiAqIBcpAgA3AgAgKyASKQIANwIAICwgFCkCADcCACAtIBMpAgA3AgAgASABKQKYDTcC+AsgDiAuQdDjwAAQNiAvIBYpAgA3AgAgMCAVKQIANwIAIEIgECkCADcCACBDIA8pAgA3AgAgASABKQLYDzcCoAwgTSAlQaAB/AoAACAEQYAEaiBKQYAK/AoAACABQYAQaiQAIARBoA5qQgA3AwAgBEGYDmpCADcDACAEQZAOakIANwMAIARBiA5qQgA3AwAgBEGwDmpB+OTAACkCACJPNwMAIARBuA5qQYDlwAApAgAiUDcDACAEQcAOakGI5cAAKQIA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KAKwASEZIAMoArQBIRsgAygCuAEhHCADKAK8ASEjIAMoAsABISQgAygCxAEhJiABQfAAaiADQbgCaikCADcCACABQegAaiADQbACaikCADcCACABQeAAaiADQagCaikCADcCACABQdgAaiADQaACaikCADcCACABIAMpApgCNwJQIAEgIiAmajYCnAEgASAhICRqNgKYASABICAgI2o2ApQBIAEgHCAfajYCkAEgASAbICVqNgKMASABIBkgHmo2AogBIAEgGCAdajYChAEgASAQIBZqNgKAASABIA8gFWo2AnwgASAGIA5qNgJ4IANBwAJqJAAgBEH4DmogAUGgAfwKAAALAkACQAJAAkAgBEGAAmogAmosAAAiAUEASiABQQBIa0H/AXEOAgMBAAsgBEHYEmogBEH4DmoiAyAUEDYgBEH4E2ogEiATEDYgBEGYEGogEyAUEDYgBEG4EWogAyASEDYgCUEgaiAEQZgUaikCADcCACAJQRhqIARBkBRqKQIANwIAIAlBEGogBEGIFGopAgA3AgAgCUEIaiAEQYAUaikCADcCACAJIAQpAvgTNwIAIAcgBCkCmBA3AgAgB0EIaiAEQaAQaikCADcCACAHQRBqIARBqBBqKQIANwIAIAdBGGogBEGwEGopAgA3AgAgB0EgaiAEQbgQaikCADcCACAKQSBqIARB2BFqKQIANwIAIApBGGogBEHQEWopAgA3AgAgCkEQaiAEQcgRaikCADcCACAKQQhqIARBwBFqKQIANwIAIAogBCkCuBE3AgBBACABa8AiA0EBdiEBIANBAE4NASABQcAAQaihwQAQ8gEACyAEQdgSaiAEQfgOaiIDIBQQNiAEQfgTaiASIBMQNiAEQZgQaiATIBQQNiAEQbgRaiADIBIQNiAJQSBqIARBmBRqKQIANwIAIAlBGGogBEGQFGopAgA3AgAgCUEQaiAEQYgUaikCADcCACAJQQhqIARBgBRqKQIANwIAIAkgBCkC+BM3AgAgByAEKQKYEDcCACAHQQhqIARBoBBqKQIANwIAIAdBEGogBEGoEGopAgA3AgAgB0EYaiAEQbAQaikCADcCACAHQSBqIARBuBBqKQIANwIAIApBIGogBEHYEWopAgA3AgAgCkEYaiAEQdARaikCADcCACAKQRBqIARByBFqKQIANwIAIApBCGogBEHAEWopAgA3AgAgCiAEKQK4ETcCACABQQF2IQMgAUEASARAIANBwABBqKHBABDyAQALIARBmBBqIgEgA0H4AGxBmOXAAGpB+AD8CgAAIARBuBFqIgMgBEHYEmogARBAIARB+A5qIANBoAH8CgAADAELIARBmBBqIgYgAUH4AGxBmOXAAGpB+AD8CgAAIwBBoAJrIgEkACAEQdgSaiIDKAIAIQ4gAygCKCEPIAMoAgQhECADKAIsIRUgAygCCCEWIAMoAjAhHSADKAIMIR4gAygCNCElIAMoAhAhHyADKAI4ISAgAygCFCEhIAMoAjwhIiADKAIYIRggAygCQCEZIAMoAhwhGyADKAJEIRwgAygCICEjIAMoAkghJCABIAMoAiQgAygCTGo2AiwgASAjICRqNgIoIAEgGyAcajYCJCABIBggGWo2AiAgASAhICJqNgIcIAEgHyAgajYCGCABIB4gJWo2AhQgASAWIB1qNgIQIAEgECAVajYCDCABIA4gD2o2AgggAUEwaiIOIANBKGogAxB6IAFB2ABqIg8gAUEIaiAGQShqEDYgAUGAAWoiECAOIAYQNiABQagBaiIOIANB+ABqIAZB0ABqEDYgASADKAJQQQF0IgY2AtABIAEgAygCVEEBdCIVNgLUASABIAMoAlhBAXQiFjYC2AEgASADKAJcQQF0Ih02AtwBIAEgAygCYEEBdCIeNgLgASABIAMoAmRBAXQiJTYC5AEgASADKAJoQQF0Ih82AugBIAEgAygCbEEBdCIgNgLsASABIAMoAnBBAXQiITYC8AEgASADKAJ0QQF0IiI2AvQBIARBuBFqIgMgDyAQEHogASgCfCEPIAEoAqQBIRAgASgCgAEhGCABKAJYIRkgASgChAEhGyABKAJcIRwgASgCiAEhIyABKAJgISQgASgCjAEhJiABKAJkITkgASgCkAEhOiABKAJoISggASgClAEhKSABKAJsISogASgCmAEhKyABKAJwISwgASgCnAEhLSABKAJ0IS4gASgCoAEhLyABKAJ4ITAgAUH4AWogAUHQAWogDhB6IAMgDyAQajYCTCADIC8gMGo2AkggAyAtIC5qNgJEIAMgKyAsajYCQCADICkgKmo2AjwgAyAoIDpqNgI4IAMgJiA5ajYCNCADICMgJGo2AjAgAyAbIBxqNgIsIAMgGCAZajYCKCABKAKoASEOIAEoAqwBIQ8gASgCsAEhECABKAK0ASEYIAEoArgBIRkgASgCvAEhGyABKALAASEcIAEoAsQBISMgASgCyAEhJCABKALMASEmIANB8ABqIAFBmAJqKQIANwIAIANB6ABqIAFBkAJqKQIANwIAIANB4ABqIAFBiAJqKQIANwIAIANB2ABqIAFBgAJqKQIANwIAIAMgASkC+AE3AlAgAyAiICZqNgKcASADICEgJGo2ApgBIAMgICAjajYClAEgAyAcIB9qNgKQASADIBsgJWo2AowBIAMgGSAeajYCiAEgAyAYIB1qNgKEASADIBAgFmo2AoABIAMgDyAVajYCfCADIAYgDmo2AnggAUGgAmokACAEQfgOaiADQaAB/AoAAAsgBEHYEmoiASAEQfgOaiAUEDYgBEGYEGogEiATEDYgBEG4EWogEyAUEDYgCUEgaiAEQbgQaikCADcCACAJQRhqIARBsBBqKQIANwIAIAlBEGogBEGoEGopAgA3AgAgCUEIaiAEQaAQaikCADcCACAJIAQpApgQNwIAIAcgBCkCuBE3AgAgB0EIaiAEQcARaikCADcCACAHQRBqIARByBFqKQIANwIAIAdBGGogBEHQEWopAgA3AgAgB0EgaiAEQdgRaikCADcCACAEQYAOaiABQfgA/AoAACACBEAgAkEBayECDAELCyAIIARBgA5qIgEgFxA2IARBuBFqIBogFxA2IARB2BJqIgIgFxBQIAQpA6ATIVIgBCkDmBMhUSAEKQPwEiFTIAQpA5ATIVQgBCkD6BIhVSAEKQPgEiFWIAQpA9gSIU8gBCkDiBMhVyAEKQOAEyFYIAQpA/gSIVAgAiABIBoQNiAIQcgAaiAEQdgRaikCADcCACAIQUBrIARB0BFqKQIANwIAIAhBOGogBEHIEWopAgA3AgAgCEEwaiAEQcARaikCADcCACAIIAQpArgRNwIoIAggVyBYIFBCGoh8IlhCGYh8IlenQf///x9xNgJoIAggVSBWIE9CGoh8IlZCGYh8IlWnQf///x9xNgJYIAggVCBXQhqIfCJUp0H///8PcTYCbCAIIFMgVUIaiHwiU6dB////D3E2AlwgCCBRIFRCGYh8IlGnQf///x9xNgJwIAggWEL///8PgyBQQv///x+DIFNCGYh8IlBCGoh8PgJkIAggUKdB////H3E2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IQUDQCABIARqLQAAQS5GBEAgBCEDDAMLIAIgBEEBaiIERw0ACwtBACEFCyAHIAM2AgQgByAFNgIAIAYoAghBAUYhAwwBCyABLQAAQS5GIgMgAkEBRnINACABLQABQS5GIgMgAkECRnINACABLQACQS5GIgMgAkEDRnINACABLQADQS5GIgMgAkEERnINACABLQAEQS5GIgMgAkEFRnINACABLQAFQS5GIgMgAkEGRnINACABLQAGQS5GIQMLIAAgAyAALQAEcjoABCAAKAIAIAEgAhDpAiAGQRBqJAAL3wEBA38gAC0AAEEBRwRAIAAoAgQhBiAALQABQQFHBEAgBigCACIEKAIAIAQoAggiBUYEQCAEIAVBAUEBQQEQyQEgBCgCCCEFCyAEIAVBAWo2AgggBCgCBCAFakEsOgAACyAAQQI6AAEgBigCACABIAIQaiADKAIIIQEgAygCBCECIAYoAgAiACgCACAAKAIIIgNGBEAgACADQQFBAUEBEMkBIAAoAgghAwsgACADQQFqNgIIIAAoAgQgA2pBOjoAACAGKAIAIAIgARBqQQAPC0GkpMAAQShBzKTAABCZAgAL8gEBAn8jAEEwayICJAACQCAAKQMAQv///////////wCDQoCAgICAgID4/wBaBEAgAkEBNgIUIAJBsKDEADYCECACQgE3AhwgAiAArUKAgICAgBKENwMoIAIgAkEoajYCGCABKAIAIAEoAgQgAkEQahBgIQMMAQsgAkEAOgAMIAIgATYCCEEBIQMgAkEBNgIUIAJBsKDEADYCECACQgE3AhwgAiAArUKAgICAgBKENwMoIAIgAkEoajYCGCACQQhqQbygxAAgAkEQahBgDQAgAi0ADEUEQCABQbigxABBAhDpAg0BC0EAIQMLIAJBMGokACADC+EBAQN/IwBBkAFrIgIkACABKQOQAVAEQCACIAEQMCACQYgBaiIBIAJB2ABqKQMANwMAIAJBgAFqIgMgAkHQAGopAwA3AwAgAkH4AGoiBCACQcgAaikDADcDACACIAIpA0A3A3AgAkHwAGogAiACLQBoQgAgAi0AaUEIchAiIAAgASkDADcAGCAAIAMpAwA3ABAgACAEKQMANwAIIAAgAikDcDcAACACQZABaiQADwsgAkIANwIMIAJCgYCAgMAANwIEIAJBzNnAADYCACABQZABakGI18AAIAJBnNvAABCnAgAL5wEAIAAQwgEgAEEAOgAgIABBADoAISAAQQA6ACIgAEEAOgAjIABBADoAJCAAQQA6ACUgAEEAOgAmIABBADoAJyAAQQA6ACggAEEAOgApIABBADoAKiAAQQA6ACsgAEEAOgAsIABBADoALSAAQQA6AC4gAEEAOgAvIABBADoAMCAAQQA6ADEgAEEAOgAyIABBADoAMyAAQQA6ADQgAEEAOgA1IABBADoANiAAQQA6ADcgAEEAOgA4IABBADoAOSAAQQA6ADogAEEAOgA7IABBADoAPCAAQQA6AD0gAEEAOgA+IABBADoAPwvOAgEDfyMAQTBrIgMkACADQQxqIAEgAhBPAkACQCADKAIMQQFGBEAgAyACNgIgIAMgATYCHCADQQY6ABgjAEFAaiIBJAAgAUHguMAANgIEIAEgA0EvajYCACABQShqIANBGGoiAkEIaikDADcDACABIAIpAwA3AyAgAUECNgIMIAFBmLjDADYCCCABQgI3AhQgASABrUKAgICAgBCENwM4IAEgAUEgaq1CgICAgJAQhDcDMCABIAFBMGo2AhAgAUEIahCyASECIAFBQGskACAAQYCAgIB4NgIAIAAgAjYCBAwBC0EAIQEgAygCFCICQQBIDQEgAygCECEFAkAgAkUEQEEBIQQMAQtBASEBIAJBARCBAyIERQ0CCyACBEAgBCAFIAL8CgAACyAAIAI2AgggACAENgIEIAAgAjYCAAsgA0EwaiQADwsgASACENsCAAviAQAgAEEAOgAAIABBADoAASAAQQA6AAIgAEEAOgADIABBADoABCAAQQA6AAUgAEEAOgAGIABBADoAByAAQQA6AAggAEEAOgAJIABBADoACiAAQQA6AAsgAEEAOgAMIABBADoADSAAQQA6AA4gAEEAOgAPIABBADoAECAAQQA6ABEgAEEAOgASIABBADoAEyAAQQA6ABQgAEEAOgAVIABBADoAFiAAQQA6ABcgAEEAOgAYIABBADoAGSAAQQA6ABogAEEAOgAbIABBADoAHCAAQQA6AB0gAEEAOgAeIABBADoAHwuCAgAgAEEAOgDAASAAQQA6AMEBIABBADoAwgEgAEEAOgDDASAAQQA6AMQBIABBADoAxQEgAEEAOgDGASAAQQA6AMcBIABBADoAyAEgAEEAOgDJASAA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aikAADcDACAUQTBqIAFBEGopAAA3AwAgFEEoaiABQQhqKQAANwMAIBQgASkAADcDICMAQSBrIi0kACAUQSBqIgEgAS0AH0E/cUHAAHI6AB8gASABLQAAQfgBcToAACAtQQhqIAFBCGopAAA3AwAgLUEQaiABQRBqKQAANwMAIC1BGGogAUEYaikAADcDACAtIAEpAAA3AwAgACECQQAhASMAQaADayIDJAAgA0EIaiAUEG8gA0HQAGpB2JHDACkCACI3NwMAIANByABqQdCRwwApAgAiOTcDACADQUBrQciRwwApAgAiODcDACADQThqQcCRwwApAgAiOjcDACADQeAAakIANwMAIANB6ABqQgA3AwAgA0HwAGpCADcDACADQfgAakIANwMAIANBuJHDACkCACI7NwMwIANCADcDWCADQaABaiADQShqKQIANwMAIANBmAFqIANBIGopAgA3AwAgA0GQAWogA0EYaikCADcDACADQYgBaiADQRBqKQIANwMAIANBsAFqIDo3AwAgA0G4AWogODcDACADQcABaiA5NwMAIANByAFqIDc3AwAgAyADKQIINwOAASADIDs3A6gBIANBADoA1wEgA0EBNgLcAiADQoCAgICAIDcC1AIgAyAtNgLQAiADQdgAaiEvQQEhBgJAAkADQAJAAkAgBkUEQCADKALYAiIAIAMoAtQCTQ0CIAMgAEEBayIENgLYAiAEQQN2IQUgAEGBAk8NBCADKALQAiAFai0AACAEQQdxdkEBcSEADAELIANBADYC3AICf0EAIQAgA0HQAmoiBCgCBCIHIAQoAggiBSAFIAdLGyAFayEVAkACQAJAA0BBAiEIIAAgFUYNASAEIAAgBWoiE0EBazYCCCATQYECTw0CIAYgAEEBayIAag0ACyAHIAAgBWoiAE8NACAEIABBAWsiBTYCCCAFQQN2IQYgAEGBAk8NAiAEKAIAIAZqLQAAIAVBB3F2QQFxIQgLIAgMAgsgE0EBa0EDdkEgQYiSwwAQ8gEACyAGQSBBiJLDABDyAQALQf8BcSIAQQJGDQELIAAgAXMQ5wIhASADKAKAASEEIAMoAjAhBSADKAKEASEGIAMoAjQhByADKAKIASEIIAMoAjghEyADKAKMASEVIAMoAjwhICADKAKQASEhIAMoAkAhIiADKAKUASEWIAMoAkQhIyAD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KQOIBSA9QhqIfCI9Qv///w+DID5CGoh8pyILNgLMASABIDdC////H4MgASkDmAUgASkDkAUgPUIZiHwiN0IaiHwiPUIZiHwiPqdB////H3EiDDYC2AEgASA5Qv///w+DID5CGoh8pyINNgLcASABIDenQf///x9xIg42AtABIAEgPadB////D3EiDzYC1AEgASA4p0H///8fcSIQNgLgASABIDqnQf///w9xIhE2AuQBIAEgO6dB////H3EiEjYC6AEgASA8p0H///8PcSIaNgLsASABQfABaiIIIAFBoAFqIhsgAUHIAWoiHBB6IAFBmAJqIh0gASAJEDYgAUHAAmoiCSAHIAFB0ABqEDYgASgCmAIhByABKALAAiEeIAEoApwCIR8gASgCxAIhJiABKAKgAiEnIAEoAsgCISggASgCpAIhKSABKALMAiEqIAEoAqgCISsgASgC0AIhLCABKAKsAiEuIAEoAtQCITAgASgCsAIhMSABKALYAiEyIAEoArQCITMgASgC3AIhNCABKAK4AiE1IAEoAuACITYgASABKALkAiABKAK8Amo2AowDIAEgNSA2ajYCiAMgASAzIDRqNgKEAyABIDEgMmo2AoADIAEgLiAwajYC/AIgASArICxqNgL4AiABICkgKmo2AvQCIAEgJyAoajYC8AIgASAfICZqNgLsAiABIAcgHmo2AugCIAFBkANqIgcgHSAJEHogBiABQegCahBQIAEpA5gFITggASkDkAUhOiABKQOIBSE7IAEpA4AFITcgASkDyAUhPCABKQPABSE9IAEpA7gFIT4gASkDsAUhQSABKQOoBSFCIAEpA6AFITkgBiAHEFAgASABKQOwBSABKQOoBSABKQOgBSI/QhqIfCJEQhmIfCJAp0H///8fcTYC0AMgASABKQOQBSABKQOIBSABKQOABSJFQhqIfCJGQhmIfCJDp0H///8fcTYCwAMgASABKQO4BSBAQhqIfCJAp0H///8PcTYC1AMgASABKQOYBSBDQhqIfCJDp0H///8PcTYCxAMgASABKQPABSBAQhmIfCJAp0H///8fcTYC2AMgASBEQv///w+DID9C////H4MgQ0IZiHwiP0IaiHw+AswDIAEgP6dB////H3E2AsgDIAEgASkDyAUgQEIaiHwiP6dB////D3E2AtwDIAEgRkL///8PgyA/QhmIQhN+IEVC////H4N8Ij9CGoh8PgK8AyABID+nQf///x9xNgK4AyABQeADakHgkcMAIAgQNiABQYgEaiAbIBwQNiABIAEoAoQEIBpqNgKkBSABIAEoAoAEIBJqNgKgBSABIAEoAvwDIBFqNgKcBSABIAEoAvgDIBBqNgKYBSABIAEoAvQDIA1qNgKUBSABIAEoAvADIAxqNgKQBSABIAEoAuwDIA9qNgKMBSABIAEoAugDIA5qNgKIBSABIAEoAuQDIAtqNgKEBSABIAEoAuADIApqNgKABSABQbAEaiAIIAYQNiABQdgEaiADQQhqIAFBuANqEDYgJSABQagEaikCADcCACAjIAFBoARqKQIANwIAICEgAUGYBGopAgA3AgAgFSABQZAEaikCADcCACAFIAEpAogENwIAIAUgASkCsAQ3AiggEyABQbgEaikCADcCACAgIAFBwARqKQIANwIAICIgAUHIBGopAgA3AgAgJCABQdAEaikCADcCACAEIDwgPSA+IEEgQiA5QhqIfCJCQhmIfCJBQhqIfCI+QhmIfCI9QhqIfCI8p0H///8PcTYCJCAEID2nQf///x9xNgIgIAQgPqdB////D3E2AhwgBCBBp0H///8fcTYCGCAEIEJC////D4MgOUL///8fgyA4IDogOyA3QhqIfCI5QhmIfCI6QhqIfCI4QhmIfCI7QhqIfD4CFCAEIDunQf///x9xNgIQIAQgOKdB////D3E2AgwgBCA6p0H///8fcTYCCCAEIDlC////D4MgPEIZiEITfiA3Qv///x+DfCI3QhqIfD4CBCAEIDenQf///x9xNgIAIAQgASkC2AQ3AiggFiABQeAEaikCADcCACAXIAFB6ARqKQIANwIAIBggAUHwBGopAgA3AgAgGSABQfgEaikCADcCACABQdAFaiQAIAMgADoA1wEgAygC3AIhBiAAIQEMAQsLIAEQ5wIhACADKAKAASEBIAMoAjAhBCADKAKEASEFIAMoAjQhBiADKAKIASEHIAMoAjghCCADKAKMASETIAMoAjwhFSADKAKQASEgIAMoAkAhISADKAKUASEiIAMoAkQhFiADKAKYASEjIAMoAkghFyADKAKcASEkIAMoAkwhGCADKAKgASElIAMoAlAhCSADKAKkASEZIAMoAlQhCiADKAKoASELIAMoAlghDCADKAKsASENIAMoAlwhDiADKAKwASEPIAMoAmAhECADKAK0ASERIAMoAmQhEiADKAK4ASEaIAMoAmghGyADKAK8ASEcIAMoAmwhHSADKALAASEeIAMoAnAhHyADKALEASEmIAMoAnQhJyADKALIASEoIAMoAnghKSADQQAgAEH/AXFrIgAgAygCzAEiKiADKAJ8IitzcSIsICtzNgJ8IAMgKSAoIClzIABxIitzNgJ4IAMgJyAmICdzIABxIilzNgJ0IAMgHyAeIB9zIABxIidzNgJwIAMgHSAcIB1zIABxIh9zNgJsIAMgGyAaIBtzIABxIh1zNgJoIAMgEiARIBJzIABxIhtzNgJkIAMgECAPIBBzIABxIhJzNgJgIAMgDiANIA5zIABxIhBzNgJcIAMgDCALIAxzIABxIg5zNgJYIAMgCiAKIBlzIABxIgxzNgJUIAMgCSAJICVzIABxIgpzNgJQIAMgGCAYICRzIABxIglzNgJMIAMgFyAXICNzIABxIhhzNgJIIAMgFiAWICJzIABxIhdzNgJEIAMgISAgICFzIABxIhZzNgJAIAMgFSATIBVzIABxIiFzNgI8IAMgCCAHIAhzIABxIhVzNgI4IAMgBiAFIAZzIABxIghzNgI0IAMgBCABIARzIABxIgBzNgIwIAMgKiAsczYCzAEgAyAoICtzNgLIASADICYgKXM2AsQBIAMgHiAnczYCwAEgAyAcIB9zNgK8ASADIBogHXM2ArgBIAMgESAbczYCtAEgAyAPIBJzNgKwASADIA0gEHM2AqwBIAMgCyAOczYCqAEgAyAMIBlzNgKkASADIAogJXM2AqABIAMgCSAkczYCnAEgAyAYICNzNgKYASADIBcgInM2ApQBIAMgFiAgczYCkAEgAyATICFzNgKMASADIAcgFXM2AogBIAMgBSAIczYChAEgAyAAIAFzNgKAASADQQA6ANcBIANB0AJqIgAgLxAzIANBoAJqIANB8AJqKQIANwMAIANBmAJqIANB6AJqKQIANwMAIANBkAJqIANB4AJqKQIANwMAIANBiAJqIANB2AJqKQIANwMAIAMgAykC0AI3A4ACIANByAJqIANBmANqKQIANwMAIANBwAJqIANBkANqKQIANwMAIANBuAJqIANBiANqKQIANwMAIANBsAJqIANBgANqKQIANwMAIAMgAykC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AEEIaikDADcDACADIAApAwA3AyAgA0ECNgIMIANB+LfDADYCCCADQgI3AhQgAyADrUKAgICAgBCENwM4IAMgA0Egaq1CgICAgJAQhDcDMCADIANBMGo2AhAgA0EIahCyASADQUBrJAALjQEBBH8jAEEQayICJAACf0EBIAEoAgAiA0EnIAEoAgQiBSgCECIBEQAADQAaIAIgACgCAEGBAhBSAkAgAi0ADSIAQYEBTwRAIAMgAigCACABEQAARQ0BQQEMAgsgAyACIAItAAwiBGogACAEayAFKAIMEQEARQ0AQQEMAQsgA0EnIAERAAALIAJBEGokAAuGAQEBfyMAQRBrIgMkACACIAEgAmoiAUsEQEEAQQAQ2wIACyADQQRqIAAoAgAiAiAAKAIEQQggASACQQF0IgIgASACSxsiASABQQhNGyIBEN8BIAMoAgRBAUYEQCADKAIIIAMoAgwQ2wIACyADKAIIIQIgACABNgIAIAAgAjYCBCADQRBqJAALpQEBAX8jAEEQayICJAACfwJAAkACQAJAAkAgACgCAEEBaw4EAQIDBAALIAFBqN7AAEESEOkCDAQLIAFBut7AAEEMEOkCDAMLIAIgAEEEajYCDCABQejewABBC0Hz3sAAQQQgAEEIakHI3sAAQffewABBBiACQQxqQdjewAAQyAEMAgsgAUH93sAAQQYQ6QIMAQsgAUGD38AAQREQ6QILIAJBEGokAAuHAQEEfyAAKAIEIQIgACgCCCIDBEAgAkEEaiEBA0ACQAJAAkACQCABQQRrLQAADgUDAwMBAgALIAEQRAwCCyABKAIAIgRFDQEgAUEEaigCACAEQQEQ+gIMAQsgARDbAQsgAUEYaiEBIANBAWsiAw0ACwsgACgCACIABEAgAiAAQRhsQQgQ+gILC3kAIAAgASkAADcAACAAQSBqIAEpACA3AAAgAEEIaiABQQhqKQAANwAAIABBEGogAUEQaikAADcAACAAQRhqIAFBGGopAAA3AAAgAEEoaiABQShqKQAANwAAIABBMGogAUEwaikAADcAACAAQThqIAFBOGopAAA3AAALiwEBBH8CQAJAAkAgACgCACIAKAIADgIAAQILIAAoAggiAUUNASAAKAIEIAFBARD6AgwBCyAALQAEQQNHDQAgACgCCCIBKAIAIQMgAUEEaigCACIEKAIAIgIE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AQsgAkECNgIEIAJBqJ7EADYCACACQgE3AgwgAiAArUKAgICA4AiENwMYIAIgAkEYajYCCCABKAIAIAEoAgQgAhBgCyACQSBqJAALvQMBB38jAEEQayIDJAAgACgCCCEFIAAoAgQhACABKAIAQb+2xABBASABKAIEKAIMEQEAIQQgA0EEaiICQQA6AAUgAiAEOgAEIAIgATYCACAFBEADQCADIAA2AgwgA0EMaiEHIwBBIGsiASQAQQEhBgJAIANBBGoiBC0ABA0AIAQtAAUhCAJAIAQoAgAiAi0ACkGAAXFFBEAgCEEBcUUNASACKAIAQZG2xABBAiACKAIEKAIMEQEARQ0BDAILIAhBAXFFBEAgAigCAEGTtsQAQQEgAigCBCgCDBEBAA0CCyABQQE6AA8gAUGctsQANgIUIAEgAikCADcCACABIAIpAgg3AhggASABQQ9qNgIIIAEgATYCECAHIAFBEGpBiNLAACgCABEAAA0BIAEoAhBBlLbEAEECIAEoAhQoAgwRAQAhBgwBCyAHIAJBiNLAACgCABEAACEGCyAEQQE6AAUgBCAGOgAEIAFBIGokACAAQQFqIQAgBUEBayIFDQALC0EBIQAgA0EEaiIBLQAERQRAIAEoAgAiACgCAEHAtsQAQQEgACgCBCgCDBEBACEACyABIAA6AAQgA0EQaiQAIAALugUBE38jAEHAAWsiAyQAIANBuAFqIAFBGGopAAA3AwAgA0GwAWogAUEQaikAADcDACADQagBaiABQQhqKQAANwMAIAMgASkAADcDoAEjAEEgayIBJAAgA0GgAWoiBCAELQAfQT9xQcAAcjoAHyAEIAQtAABB+AFxOgAAIAFBCGogBEEIaikAADcDACABQRBqIARBEGopAAA3AwAgAUEYaiAEQRhqKQAANwMAIAEgBCkAADcDACADIAEQJyABQSBqJAAjAEGgAmsiAiQAIAMoAighBSADKAJQIQYgAygCLCEHIAMoAlQhCCADKAIwIQkgAygCWCEKIAMoAjQhCyADKAJcIQwgAygCOCENIAMoAmAhDiADKAI8IQ8gAygCZCEQIAMoAkAhESADKAJoIRIgAygCRCETIAMoAmwhFCADKAJIIQQgAygCcCEBIAIgAygCTCADKAJ0ajYCLCACIAEgBGo2AiggAiATIBRqNgIkIAIgESASajYCICAC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AgggAygCDBCSAiEBIABBATsBACAAIAE2AgQgA0EQaiQAC0kBAX8jAEEQayIDJAAgA0EIaiABKAIAIAEoAgQgASgCCBBeIAIgAygCCCADKAIMEJICIQEgAEECNgIAIAAgATYCBCADQRBqJAALvw8CBn8CfiMAQRBrIg0kACMAQeAAayIMJAACQAJAAkACQCAABEAgAEEIayIPIA8oAgBBAWoiDjYCACAORQ0BIAAoAgANAiAAQX82AgAgDCAPNgJQIAwgADYCTCAMIAQ2AgwgDCADNgIIIAwgBDYCBCAMIAY2AhggDCAFNgIUIAwgBjYCECAMIAg2AiQgDCAHNgIgIAwgCDYCHCAMIABBCGoiBDYCSAJAIApFBEBBgICAgHghCwwBCyAMIAs2AjAgDCAKNgIsCyAMIAs2AiggDEE0aiEFIwBB0AFrIgMkACADQQhqIAxBHGoiBkEIaigCADYCACADQRRqIAxBEGoiB0EIaigCADYCACADIAYpAgA3AwAgAyAHKQIANwIMIANByAFqIAxBBGoiBkEIaigCADYCACADIAYpAgA3A8ABIANB8ABqIAQgASACIAMgA0HAAWogCfwHIAxBKGoQJAJAIAMpA4ABIhJCBFEEQCADQcgAaiADQZABaikDACISNwMAIANB0ABqIANBmAFqKAIAIgQ2AgAgAyADKQOIASITNwNAIAVBEGogBDYCACAFQQhqIBI3AgAgBSATNwIAIAMoAsABIgRFDQEgAygCxAEgBEEBEPoCDAELIANB4ABqIgQgA0GQAWopAwA3AwAgA0HoAGoiByADQZgBaigCADYCACADIAMpA4gBNwNYIAMoAnghCCADKAJ0IQogAygCcCEGIANBPGogA0G8AWooAgA2AgAgA0E0aiADQbQBaikCADcCACADQSxqIANBrAFqKQIANwIAIANBJGogA0GkAWopAgA3AgAgAyADKQKcATcCHCADQdAAaiILIAcoAgA2AgAgA0HIAGoiByAEKQMANwMAIAMgAykDWDcDQCADQRhqIAsoAgA2AgAgA0EQaiAHKQMANwMAIAMgAykDQDcDCCADIBI3AwAgAygCwAEiBARAIAMoAsQBIARBARD6AgsCQCASQgNSBEAgA0GEAWogA0EYaigCADYCACADIAg2AnggAyAKNgJ0IAMgBjYCcCADIAMpAxA3AnwgAyAD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KCACIAKtQoCAgIDgCIQ3AyAgAiACQSBqNgIQIAJBCGogAxC/AgALIwBBMGsiASQAIAEgAjYCBCABIAA2AgAgAUECNgIMIAFBqNPEADYCCCABQgI3AhQgASABQQRqrUKAgICA4AiENwMoIAEgAa1CgICAgOAIhDcDICABIAFBIGo2AhAgAUEIaiADEL8CAAsjAEEwayIAJAAgACACNgIEIAAgATYCACAAQQI2AgwgAEHQ0sQANgIIIABCAjcCFCAAIABBBGqtQoCAgIDgCIQ3AyggACAArUKAgICA4AiENwMgIAAgAEEgajYCECAAQQhqIAMQvwIAC0IBAX8jAEEgayIDJAAgA0EANgIQIANBATYCBCADQgQ3AgggAyABNgIcIAMgADYCGCADIANBGGo2AgAgAyACEL8CAAtBAQF/IAAoAgAiACgCqAEEQCAAQQA2AqgBCwJAIABBf0YNACAAIAAoAgRBAWsiATYCBCABDQAgAEGQD0EIEPoCCws9AQJ/AkAgACgCACICRQ0AIAAoAgQiACgCACIBBEAgAiABEQQACyAAKAIEIgFFDQAgAiABIAAoAggQ+gILCzkBAX8jAEEQayICJAAgAkEIaiAAKAIAIAAoAgQgACgCCBBeIAEgAigCCCACKAIMEJICIAJBEGokAAvfBwIEfwJ+IwBBEGsiCSQAIwBB0ABrIggkAAJAAkACQAJAIAAEQCAAQQhrIgsgCygCAEEBaiIKNgIAIApFDQEgACgCAA0CIABBfzYCACAIIAs2AkAgCCAANgI8IAggBDYCFCAIIAM2AhAgCCAENgIMIAggAEEIaiIKNgI4AkAgBkUEQEGAgICAeCEHDAELIAggBzYCICAIIAY2AhwLIAggBzYCGCAIQSRqIQQjAEGAAmsiAyQAIANBgICAgHg2AtgBIANB+AFqIAhBDGoiBkEIaigCADYCACADIAYpAgA3A/ABIANBiAFqIAogASACIANB2AFqIANB8AFqIAX8ByAIQRhqECQCQCADKQOYASINQgRRBEAgA0HgAGogA0GoAWopAwAiDTcDACADQegAaiADQbABaigCACIGNgIAIAMgAykDoAEiDDcDWCAEQRBqIAY2AgAgBEEIaiANNwIAIAQgDDcCACADKALwASIERQ0BIAMoAvQBIARBARD6AgwBCyADQRBqIgYgA0GQAWopAwA3AwAgA0H4AGoiByADQagBaikDADcDACADQYABaiIKIANBsAFqKAIANgIAIANBPGogA0G8AWopAgA3AgAgA0HEAGogA0HEAWopAgA3AgAgA0HMAGogA0HMAWopAgA3AgAgA0HUAGogA0HUAWooAgA2AgAgAyADKQOIATcDCCADIAMpA6ABNwNwIAMgAykCtAE3AjQgA0HgAGogBykDACIMNwMAIANB6ABqIAooAgAiBzYCACADQShqIAw3AwAgA0EwaiAHNgIAIAMgAykDcCIMNwNYIAQgAykDCDcCBCAEQQxqIAYoAgA2AgAgAyANNwMYIAMgDDcDICADQRhqEMoBIAMoAvABIgYEQCADKAL0ASAGQQEQ+gILIARBjYCAgHg2AgALIANBgAJqJAAgAgRAIAEgAkEBEPoCCyAAQQA2AgAgCyALKAIAQQFrIgA2AgAgAEUEQCAIQUBrEHsLIAkCfyAIKAIkQY2AgIB4RwRAIAhByABqIAhBNGooAgA2AgAgCEFAayAIQSxqKQIANwMAIAggCCkCJDcDOEEAIQAgCEE4ahCkASEHQQAhAkEBDAELIAgoAiwhAQJAIAgoAigiAyAIKAIwIgJNBEAgASEADAELIAJFBEBBASEAIAEgA0EBEPoCDAELIAEgA0EBIAIQ7QIiAEUNBQtBACEHQQALNgIMIAkgBzYCCCAJIAI2AgQgCSAANgIAIAhB0ABqJAAMBAsQkAMLAAsQkQMAC0EBIAIQ2wIACyAJKAIAIAkoAgQgCSgCCCAJKAIMIAlBEGokAAucHgIifwR+IwBBEGsiESQAIwBBIGsiECQAIBBBDGohDSMAQbAQayIJJAACQAJAAkACQAJAAkACQAJAAkACQCADQQ5JDQBBnMXAACACQQ4QgwINACAJQbfFwAA2AjggCSADQQ5rNgI0IAkgAkEOajYCMCAJQZAQaiILIAlBMGoiChCdASAJKAKQECIWQYCAgIB4Rg0BIAkoApQQIRIgBUEISQ0CIAQpAABC88qF49bM3K/6AFINAiAJKAKYECEIIAlBt8XAADYCOCAJIAVBCGs2AjQgCSAEQQhqNgIwIAsgChCdASAJKAKQECIXQYCAgIB4Rg0DIAkoApgQIQsgCSgClBAhEyAJQegPakIANwMAIAlB4A9qQgA3AwAgCUHYD2pCADcDACAJQdAPakIANwMAIAlByA9qQgA3AwAgCUHAD2oiDkIANwMAIAlBuA9qIgxCADcDACAJQfgPakHAy8AAKQIAIio3AwAgCUGAEGpByMvAACkCACIrNwMAIAlBiBBqQdDLwAApAgAiLDcDACAJQThqICo3AwAgCUFAayArNwMAIAlByABqICw3AwAgCUIANwOwDyAJQbjLwAApAgAiKjcD8A8gCSAqNwMwIAlB0ABqIAlBsA9qIg9B4AD8CgAAIAlBtwFqQQA2AAAgCUEANgLIASAJQgA3A8ABIAlCADcDsAEgCiAGIAcQKSAPIAoQvwFBGEEBEIEDIg9FDQUgDyAJKQCwDzcAACAPQRBqIA4pAAA3AAAgD0EIaiAMKQAANwAAIAhBIEYEQCALIghBIEYNBQsgDSAINgIIIA1CgICAgIAENwIAIA9BGEEBEPoCIBdFDQYgEyAXQQEQ+gIMBgsgDUEONgIQIA1BnMXAADYCDCANQQ02AgggDUGqxcAANgIEIA1BCDYCAAwGCyAJIAkpApQQNwMAIAlBADYCuA8gCUKAgICAEDcCsA8gCUGEx8AANgI0IAlCoICAgA43AjggCSAJQbAPajYCMCAJIAlBMGoQrgENBiAJKQKwDyEqIA0gCSgCuA82AgwgDSAqNwIEIA1BCTYCAAwFCyANQQg2AhAgDUHxxsAANgIMIA1BCTYCCCANQfnGwAA2AgQgDUEINgIADAMLIAkgCSkClBA3AwAgCUEANgK4DyAJQoCAgIAQNwKwDyAJQYTHwAA2AjQgCUKggICADjcCOCAJIAlBsA9qNgIwIAkgCUEwahCuAQ0EIAkpArAPISogDSAJKAK4DzYCDCANICo3AgQgDUEJNgIADAILIBIpAAMhKiASKAALIQggEikADyErIAlBsg9qIBNBAmotAAA6AAAgEykAAyEsIBMoAAshCyATKQAPIS0gEy8AACEKIAlBzw9qIBNBH2otAAA6AAAgCSAKOwGwDyAJIBMpABc3AMcPIAlBkhBqIBJBAmotAAA6AAAgEi8AACEKIAlBrxBqIBJBH2otAAA6AAAgCSAKOwGQECAJICs3AJ8QIAkgCDYAmxAgCSAqNwCTECAJIBIpABc3AKcQIAkgLTcAvw8gCSALNgC7DyAJICw3ALMPIAlBMGoiCCAJQZAQaiILIAlBsA9qENEBIAlBAmoiDiAJQTJqLQAAOgAAIAlBKGoiCiAJQc8Aai0AADoAACAJIAkvADA7AQAgCSAJKQBHNwMgIAkpADMhKiAJKAA7IQwgCSkAPyErIAsQwgEgCBDCASAJQR9qIgggCi0AADoAACAJICs3AA8gCSAMNgALIAkgKjcAAyAJIAkpAyA3ABcjAEHQAGsiCiQAIAkpAAMhKiAJKAALIQsgCSkADyErIApBOmogD0ECai0AADoAACAKQccAaiAPQQ9qKQAANwAAIAogDy8AADsBOCAKIA8pAAc3AD8gDygAAyEMIA8tABchFCAKQQ5qIA4tAAA6AAAgCkEraiAILQAAOgAAIAogKzcAGyAKIAs2ABcgCiAqNwAPIAogCS8AADsBDCAKIAkpABc3ACMgCiAUOgBPIAogDDYAOyAKQSxqIQ4gCkEMaiEVIApBOGohDEEAIRQjAEHAA2siCCQAAkACQCABQQBIDQACQAJAAkAgAQRAQQEhFCABQQEQgQMiC0UNBCABBEAgCyAAIAH8CgAACyABQRBJDQIgCy0ADyEYIAstAA4hGSALLQANIRogCy0ADCEbIAstAAshHCALLQAKIR0gCy0ACSEeIAstAAghHyALLQAHISAgCy0ABiEhIAstAAUhIiALLQAEISMgCy0AAyEkIAstAAIhJSALLQABISYgCy0AACEnIAhB/AFqIBUgDBBXIAhB9MqB2QY2AtgCIAggCCkClAI3AtACIAggCCkCjAI3AsgCIAhBstqIywc2AsQCIAhCADcCvAIgCEHuyIGZAzYCsAIgCCAIKQKEAjcCqAIgCCAIKQL8ATcCoAIgCEHl8MGLBjYCnAIgCCAMKQAQNwK0AiAIQdwCakEAQcEA/AsAIAhBuANqIhVCADcDACAIQbADaiIoQgA3AwAgCEGoA2oiKUIANwMAIAhCADcDoAMgCEGcAmoiFCAIQaADaiIMQSAQPSAIQcQBaiAMEOUBIAhBQGsiDCAUQYQB/AoAACAIQQA6AKADIAhBADoAoQMgCEEAOgCiAyAIQQA6AKMDIAhBADoApAMgCEEAOgClAyAIQQA6AKYDIAhBADoApwMgKUEAOgAAIAhBADoAqQMgCEEAOgCqAyAIQQA6AKsDIAhBADoArAMgCEEAOgCtAyAIQQA6AK4DIAhBADoArwMgKEEAOgAAIAhBADoAsQMgCEEAOgCyAyAIQQA6ALMDIAhBADoAtAMgCEEAOgC1AyAIQQA6ALYDIAhBADoAtwMgFUEAOgAAIAhBADoAuQMgCEEAOgC6AyAIQQA6ALsDIAhBADoAvAMgCEEAOgC9AyAIQQA6AL4DIAhBADoAvwMgCEEAOgD8ASAIQQA6AP0BIAhBADoA/gEgCEEAOgD/ASAIQQA6AIACIAhBADoAgQIgCEEAOgCCAiAIQQA6AIMCIAhBADoAhAIgCEEAOgCFAiAIQQA6AIYCIAhBADoAhwIgCEEAOgCIAiAIQQA6AIkCIAhBADoAigIgCEEAOgCLAiAIQQA6AIwCIAhBADoAjQIgCEEAOgCOAiAIQQA6AI8CIAhBADoAkAIgCEEAOgCRAiAIQQA6AJICIAhBADoAkwIgCEEAOgCUAiAIQQA6AJUCIAhBADoAlgIgCEEAOgCXAiAIQQA6AJgCIAhBADoAmQIgCEEAOgCaAiAIQQA6AJsCIBQgDEGEAfwKAAAgCEE4aiAIQfQBaikCADcDACAIQTBqIAhB7AFqKQIANwMAIAhBKGogCEHkAWopAgA3AwAgCEEgaiAIQdwBaikCADcDACAIQRhqIAhB1AFqKQIANwMAIAhBEGogCEHMAWopAgA3AwAgCCAIKQLEATcDCCAMIAhBCGogC0EQaiIVIAFBEGsiDBBrIAgtAEAgJ0YQ5wIgCC0AQSAmRhDnAnEgCC0AQiAlRhDnAnEgCC0AQyAkRhDnAnEgCC0ARCAjRhDnAnEgCC0ARSAiRhDnAnEgCC0ARiAhRhDnAnEgCC0ARyAgRhDnAnEgCC0ASCAfRhDnAnEgCC0ASSAeRhDnAnEgCC0ASiAdRhDnAnEgCC0ASyAcRhDnAnEgCC0ATCAbRhDnAnEgCC0ATSAaRhDnAnEgCC0ATiAZRhDnAnEgCC0ATyAYRhDnAnFBAXEQ5wJB/wFxRQ0BIBQgFSAMED0gFBCDASAIQQA2ApwCIAhBADYCoAIgCEEANgKkAiAIQQA2AqgCIAhBADYCrAIgCEEANgKwAiAIQQA2ArQCIAhBADYCuAIgCEEANgK8AiAIQQA2AsACIAhBADYCxAIgCEEANgLIAiAIQQA2AswCIAhBADYC0AIgCEEANgLUAiAIQQA2AtgCIAwEQCALIBUgDPwKAAALIA4gDCABIAEgDEsbNgIIIA4gCzYCBCAOIAE2AgAMAwsgAQRAQQEgACAB/AoAAAsgDkGAgICAeDYCAAwCCyAIQZwCahCDASAIQQA2ApwCIAhBADYCoAIgCEEANgKkAiAIQQA2AqgCIAhBADYCrAIgCEEANgKwAiAIQQA2ArQCIAhBADYCuAIgCEEANgK8AiAIQQA2AsACIAhBADYCxAIgCEEANgLIAiAIQQA2AswCIAhBADYC0AIgCEEANgLUAiAIQQA2AtgCCyAOQYCAgIB4NgIAIAsgAUEBEPoCCyAIQcADaiQADAELIBQgARDbAgALAkACQCANIAooAiwiDEGAgICAeEYEf0EGBSAKKAIwIQgCQCAKKAI0Ig4gDE8EQCAIIQsMAQsgDkUEQEEBIQsgCCAMQQEQ+gIMAQsgCCAMQQEgDhDtAiILRQ0CCyANIA42AgggDSALNgIEQQoLNgIAIApBADoADCAKQQA6AA0gCkEAOgAOIApBADoADyAKQQA6ABAgCkEAOgARIApBADoAEiAKQQA6ABMgCkEAOgAUIApBADoAFSAKQQA6ABYgCkEAOgAXIApBADoAGCAKQQA6ABkgCkEAOgAaIApBADoAGyAKQQA6ABwgCkEAOgAdIApBADoAHiAKQQA6AB8gCkEAOgAgIApBADoAISAKQQA6ACIgCkEAOgAjIApBADoAJCAKQQA6ACUgCkEAOgAmIApBADoAJyAKQQA6ACggCkEAOgApIApBADoAKiAKQQA6ACsMAQtBASAOENsCAAsgCkHQAGokACAPQRhBARD6AiAXBEAgEyAXQQEQ+gILIBZFDQIgEiAWQQEQ+gIMAgtBAUEYENsCAAsgFkUNACASIBZBARD6AgsgCUGwEGokAAwBC0Gsx8AAQTcgCUEgakGcx8AAQeTHwAAQ5gEACyAQKAIUIQggECgCECELIBAoAgwiCUEKRwRAIBAgECkCGDcCGCAQIAg2AhQgECALNgIQIBAgCTYCDEEAIQsgDRDLASEICyAHBEAgBiAHQQEQ+gILIAUEQCAEIAVBARD6AgsgAwRAIAIgA0EBEPoCCyABBEAgACABQQEQ+gILIBECfyALRQRAQQAhC0EAIQBBAQwBCyAIIQBBACEIQQALNgIMIBEgCDYCCCARIAA2AgQgESALNgIAIBBBIGokACARKAIAIBEoAgQgESgCCCARKAIMIBFBEGokAAvGHgIWfwR+IwBBEGsiEyQAIwBBIGsiESQAIBFBDGohDiMAQbAQayIJJAACQAJAAkACQAJAAkACQAJAAkACQCADQQ5JDQBBnMXAACACQQ4QgwINACAJQbfFwAA2AjggCSADQQ5rNgI0IAkgAkEOajYCMCAJQZAQaiILIAlBMGoiChCdASAJKAKQECIYQYCAgIB4Rg0BIAkoApQQIRQgBUEISQ0CIAQpAABC88qF49bM3K/6AFINAiAJKAKYECEIIAlBt8XAADYCOCAJIAVBCGs2AjQgCSAEQQhqNgIwIAsgChCdASAJKAKQECIZQYCAgIB4Rg0DIAkoApgQIQsgCSgClBAhFSAJQegPakIANwMAIAlB4A9qQgA3AwAgCUHYD2pCADcDACAJQdAPakIANwMAIAlByA9qQgA3AwAgCUHAD2oiDEIANwMAIAlBuA9qIg1CADcDACAJQfgPakHAy8AAKQIAIh43AwAgCUGAEGpByMvAACkCACIfNwMAIAlBiBBqQdDLwAApAgAiIDcDACAJQThqIB43AwAgCUFAayAfNwMAIAlByABqICA3AwAgCUIANwOwDyAJQbjLwAApAgAiHjcD8A8gCSAeNwMwIAlB0ABqIAlBsA9qIg9B4AD8CgAAIAlBtwFqQQA2AAAgCUEANgLIASAJQgA3A8ABIAlCADcDsAEgCiAGIAcQKSAPIAoQvwFBGEEBEIEDIg9FDQUgDyAJKQCwDzcAACAPQRBqIAwpAAA3AAAgD0EIaiANKQAANwAAIAhBIEYEQCALIghBIEYNBQsgDiAINgIIIA5CgICAgIAENwIAIA9BGEEBEPoCIBlFDQYgFSAZQQEQ+gIMBgsgDkEONgIQIA5BnMXAADYCDCAOQQ02AgggDkGqxcAANgIEIA5BCDYCAAwGCyAJIAkpApQQNwMAIAlBADYCuA8gCUKAgICAEDcCsA8gCUGEx8AANgI0IAlCoICAgA43AjggCSAJQbAPajYCMCAJIAlBMGoQrgENBiAJKQKwDyEeIA4gCSgCuA82AgwgDiAeNwIEIA5BCTYCAAwFCyAOQQg2AhAgDkHxxsAANgIMIA5BCTYCCCAOQfnGwAA2AgQgDkEINgIADAMLIAkgCSkClBA3AwAgCUEANgK4DyAJQoCAgIAQNwKwDyAJQYTHwAA2AjQgCUKggICADjcCOCAJIAlBsA9qNgIwIAkgCUEwahCuAQ0EIAkpArAPIR4gDiAJKAK4DzYCDCAOIB43AgQgDkEJNgIADAILIBQpAAMhHiAUKAALIQggFCkADyEfIAlBsg9qIBVBAmotAAA6AAAgFSkAAyEgIBUoAAshCyAVKQAPISEgFS8AACEKIAlBzw9qIBVBH2otAAA6AAAgCSAKOwGwDyAJIBUpABc3AMcPIAlBkhBqIBRBAmotAAA6AAAgFC8AACEKIAlBrxBqIBRBH2otAAA6AAAgCSAKOwGQECAJIB83AJ8QIAkgCDYAmxAgCSAeNwCTECAJIBQpABc3AKcQIAkgITcAvw8gCSALNgC7DyAJICA3ALMPIAlBMGoiCCAJQZAQaiILIAlBsA9qENEBIAlBAmoiDCAJQTJqLQAAOgAAIAlBKGoiCiAJQc8Aai0AADoAACAJIAkvADA7AQAgCSAJKQBHNwMgIAkpADMhHiAJKAA7IQ0gCSkAPyEfIAsQwgEgCBDCASAJQR9qIgggCi0AADoAACAJIB83AA8gCSANNgALIAkgHjcAAyAJIAkpAyA3ABcjAEHQAGsiCiQAIAkpAAMhHiAJKAALIQsgCSkADyEfIApBOmogD0ECai0AADoAACAKQccAaiAPQQ9qKQAANwAAIAogDy8AADsBOCAKIA8pAAc3AD8gDygAAyENIA8tABchEiAKQQ5qIAwtAAA6AAAgCkEraiAILQAAOgAAIAogHzcAGyAKIAs2ABcgCiAeNwAPIAogCS8AADsBDCAKIAkpABc3ACMgCiASOgBPIAogDTYAOyAKQSxqIRsgCkEMaiEaIApBOGohF0EAIQ0jAEGwA2siCCQAAkACQAJAAkAgAUEQaiILQQBIDQACfwJAIAtFBEAgCEEANgIMIAhCgICAgBA3AgQMAQtBASENIAtBARCBAyIMRQ0CIAhBADYCDCAIIAw2AgggCCALNgIEQQAgAUFwSQ0BGgsgCEEEakEAIAFBAUEBEMkBIAgoAgghDCAIKAIMCyELIAEEQCALIAxqIAAgAfwKAAALIAggASALaiISNgIMIAhB0ABqQgA3AwAgCEIANwNIIAhBBGoiCygCACALKAIIIgxrQRBJBEAjAEEQayINJAAgDEEQaiIQQRBJBEBBAEEAENsCAAsgDUEEaiEMIAsoAgQhHAJAQQggECALKAIAIhZBAXQiHSAQIB1LGyIQIBBBCE0bIhBBAEgEQCAMQQA2AgQgDEEBNgIADAELAn8gFgRAIBwgFkEBIBAQ7QIMAQsgEEEBEIEDCyIWRQRAIAwgEDYCCCAMQQE2AgQgDEEBNgIADAELIAwgEDYCCCAMIBY2AgQgDEEANgIACyANKAIEQQFGBEAgDSgCCCANKAIMENsCAAsgDSgCCCEMIAsgEDYCACALIAw2AgQgDUEQaiQAIAsoAgghDAsgCygCBCAMaiAIQcgAakEQ/AoAACALIAxBEGo2AgggCCgCDCIMIBJJDQEgDCASa0EPTQ0CIAgoAggiC0EQaiENIBIEQCANIAsgEvwKAAALIAhBiAJqIBogFxBXIAhB9MqB2QY2AugCIAggCCkCoAI3AuACIAggCCkCmAI3AtgCIAhBstqIywc2AtQCIAhCADcCzAIgCEHuyIGZAzYCwAIgCCAIKQKQAjcCuAIgCCAIKQKIAjcCsAIgCEHl8MGLBjYCrAIgCCAXKQAQNwLEAiAIQewCakEAQcEA/AsAIAhBKGoiEkIANwMAIAhBIGoiEEIANwMAIAhBGGoiF0IANwMAIAhCADcDECAIQawCaiILIAhBEGoiFkEgED0gCEHMAWogFhDlASAIQcgAaiIaIAtBhAH8CgAAIAhBADoAECAIQQA6ABEgCEEAOgASIAhBADoAEyAIQQA6ABQgCEEAOgAVIAhBADoAFiAIQQA6ABcgF0EAOgAAIAhBADoAGSAIQQA6ABogCEEAOgAbIAhBADoAHCAIQQA6AB0gCEEAOgAeIAhBADoAHyAQQQA6AAAgCEEAOgAhIAhBADoAIiAIQQA6ACMgCEEAOgAkIAhBADoAJSAIQQA6ACYgCEEAOgAnIBJBADoAACAIQQA6ACkgCEEAOgAqIAhBADoAKyAIQQA6ACwgCEEAOgAtIAhBADoALiAIQQA6AC8gCEEAOgCIAiAIQQA6AIkCIAhBADoAigIgCEEAOgCLAiAIQQA6AIwCIAhBADoAjQIgCEEAOgCOAiAIQQA6AI8CIAhBADoAkAIgCEEAOgCRAiAIQQA6AJICIAhBADoAkwIgCEEAOgCUAiAIQQA6AJUCIAhBADoAlgIgCEEAOgCXAiAIQQA6AJgCIAhBADoAmQIgCEEAOgCaAiAIQQA6AJsCIAhBADoAnAIgCEEAOgCdAiAIQQA6AJ4CIAhBADoAnwIgCEEAOgCgAiAIQQA6AKECIAhBADoAogIgCEEAOgCjAiAIQQA6AKQCIAhBADoApQIgCEEAOgCmAiAIQQA6AKcCIAsgGkGEAfwKAAAgCEFAayAIQfwBaikCADcDACAIQThqIAhB9AFqKQIANwMAIAhBMGogCEHsAWopAgA3AwAgEiAIQeQBaikCADcDACAQIAhB3AFqKQIANwMAIBcgCEHUAWopAgA3AwAgCCAIKQLMATcDECALIA0gDEEQayIMED0gCEHJAGogFiANIAwQayALEIMBIAhBkAJqIAhB0QBqKQAANwMAIAhBADYCrAIgCEEANgKwAiAIQQA2ArQCIAhBADYCuAIgCEEANgK8AiAIQQA2AsACIAhBADYCxAIgCEEANgLIAiAIQQA2AswCIAhBADYC0AIgCEEANgLUAiAIQQA2AtgCIAhBADYC3AIgCEEANgLgAiAIQQA2AuQCIAhBADYC6AIgCCAIKQBJNwOIAiAIKAIMIgtBD00EQEEAQRAgC0HQuMAAEJgCAAsgCCgCCCILIAgpA4gCNwAAIAtBCGogCEGQAmopAwA3AAAgG0EIaiAIQQxqKAIANgIAIBsgCCkCBDcCACAIQbADaiQADAMLIA0gCxDbAgALQQAgEiAMQcC4wAAQmAIACyAIQQA2AlggCEEBNgJMIAhB9LfAADYCSCAIQgQ3AlAgCEHIAGpBwLjAABC/AgALAkACQCAOIAooAiwiDUGAgICAeEYEf0EGBSAKKAIwIQgCQCAKKAI0IgwgDU8EQCAIIQsMAQsgDEUEQEEBIQsgCCANQQEQ+gIMAQsgCCANQQEgDBDtAiILRQ0CCyAOIAw2AgggDiALNgIEQQoLNgIAIApBADoADCAKQQA6AA0gCkEAOgAOIApBADoADyAKQQA6ABAgCkEAOgARIApBADoAEiAKQQA6ABMgCkEAOgAUIApBADoAFSAKQQA6ABYgCkEAOgAXIApBADoAGCAKQQA6ABkgCkEAOgAaIApBADoAGyAKQQA6ABwgCkEAOgAdIApBADoAHiAKQQA6AB8gCkEAOgAgIApBADoAISAKQQA6ACIgCkEAOgAjIApBADoAJCAKQQA6ACUgCkEAOgAmIApBADoAJyAKQQA6ACggCkEAOgApIApBADoAKiAKQQA6ACsMAQtBASAMENsCAAsgCkHQAGokACAPQRhBARD6AiAZBEAgFSAZQQEQ+gILIBhFDQIgFCAYQQEQ+gIMAgtBAUEYENsCAAsgGEUNACAUIBhBARD6AgsgCUGwEGokAAwBC0Gsx8AAQTcgCUEgakGcx8AAQeTHwAAQ5gEACyARKAIUIQggESgCECELIBEoAgwiCUEKRwRAIBEgESkCGDcCGCARIAg2AhQgESALNgIQIBEgCTYCDEEAIQsgDhDLASEICyAHBEAgBiAHQQEQ+gILIAUEQCAEIAVBARD6AgsgAwRAIAIgA0EBEPoCCyABBEAgACABQQEQ+gILIBMCfyALRQRAQQAhC0EAIQBBAQwBCyAIIQBBACEIQQALNgIMIBMgCDYCCCATIAA2AgQgEyALNgIAIBFBIGokACATKAIAIBMoAgQgEygCCCATKAIMIBNBEGokAAv/AgEDfyAAKAIAIQIgASgCCCIAQYCAgBBxRQRAIABBgICAIHFFBEAjAEEQayIEJABBAyEAIAItAAAiAiEDIAJBCk8EQCAEIAIgAkHkAG4iA0HkAGxrQf8BcUEBdC8ApbREOwAOQQEhAAtBACACIAMbRQRAIABBAWsiACAEQQ1qaiADQQF0LQCmtEQ6AAALIAFBAUEBQQAgBEENaiAAakEDIABrEEsgBEEQaiQADwsjAEEQayIDJAAgAi0AACEAQQAhAgNAIAIgA2pBD2ogAEEPcUGBtsQAai0AADoAACACQQFrIQIgACIEQQR2IQAgBEEPSw0ACyABQQFB+LPEAEECIAIgA2pBEGpBACACaxBLIANBEGokAA8LIwBBEGsiAyQAIAItAAAhAEEAIQIDQCACIANqQQ9qIABBD3FB8bXEAGotAAA6AAAgAkEBayECIAAiBEEEdiEAIARBD0sNAAsgAUEBQfizxABBAiACIANqQRBqQQAgAmsQSyADQRBqJAALPwEBfyAAKAIAIQAgASgCCCICQYCAgBBxRQRAIAJBgICAIHFFBEAgACABEJsBDwsgACABEOgBDwsgACABEOcBCzEBAX8jAEGgAWsiAiQAIAIgARCPAyAAIAIQfCAAQSBqIAJBoAH8CgAAIAJBoAFqJAALOAACQCACQYCAxABGDQAgACACIAEoAhARAABFDQBBAQ8LIANFBEBBAA8LIAAgAyAEIAEoAgwRAQALlgIBCH8jAEEQayIHJAAjAEEgayIGJAAgBiACIAMQiQEgBkEMaiILIAAgASAGKAIAIgwgBigCBCIKIAQgBRBRIAYoAhQhCCAGKAIQIQkgBigCDCINQQpHBEAgBiAGKQIYNwIYIAYgCDYCFCAGIAk2AhAgBiANNgIMQQAhCSALEMsBIQgLIAoEQCAMIApBARD6AgsgBQRAIAQgBUEBEPoCCyADBEAgAiADQQEQ+gILIAEEQCAAIAFBARD6AgsgBwJ/IAlFBEBBACEJQQAhAEEBDAELIAghAEEAIQhBAAs2AgwgByAINgIIIAcgADYCBCAHIAk2AgAgBkEgaiQAIAcoAgAgBygCBCAHKAIIIAcoAgwgB0EQaiQAC44HAgt/A34jAEEQayIKJAAjAEEgayIIJAAgCEEMaiEJIwBBgBBrIgYkAAJAAkACQAJAIANBC0kNAEG4wsAAIAJBCxCDAg0AIAZB68DAADYCICAGIANBC2s2AhwgBiACQQtqNgIYIAZBBGogBkEYaiINEJ0BIAYoAgQiDkGAgICAeEYNASAGKAIMIRAgBigCCCEPIAZB0A9qQgA3AwAgBkHID2pCADcDACAGQcAPakIANwMAIAZBuA9qQgA3AwAgBkGwD2pCADcDACAGQagPaiILQgA3AwAgBkGgD2oiDEIANwMAIAZB4A9qQcDLwAApAgAiEjcDACAGQegPakHIy8AAKQIAIhM3AwAgBkHwD2pB0MvAACkCACIRNwMAIAZBIGogEjcDACAGQShqIBM3AwAgBkEwaiARNwMAIAZCADcDmA8gBkG4y8AAKQIAIhE3A9gPIAYgETcDGCAGQThqIAZBmA9qIgdB4AD8CgAAIAZBnwFqQQA2AAAgBkEANgKwASAGQgA3A6gBIAZCADcDmAEgDSAEIAUQKSAHIA0QvwFBGEEBEIEDIgdFDQIgByAGKQCYDzcAACAHQRBqIAspAAA3AAAgB0EIaiAMKQAANwAAIAkgDyAQIAdBGCAAIAEQUSAHQRhBARD6AiAORQ0DIA8gDkEBEPoCDAMLIAlBCzYCECAJQbjCwAA2AgwgCUEKNgIIIAlBw8LAADYCBCAJQQg2AgAMAgsgBiAGKQIINwMQIAZBADYCoA8gBkKAgICAEDcCmA8gBkGgw8AANgIcIAZCoICAgA43AiAgBiAGQZgPajYCGCAGQRBqIAZBGGoQrgFFBEAgBikCmA8hESAJIAYoAqAPNgIMIAkgETcCBCAJQQk2AgAMAgtByMPAAEE3IAZB/w9qQbjDwABBgMTAABDmAQALQQFBGBDbAgALIAZBgBBqJAAgCCgCFCEHIAgoAhAhCyAIKAIMIgxBCkcEQCAIIAgpAhg3AhggCCAHNgIUIAggCzYCECAIIAw2AgxBACELIAkQywEhBwsgBQRAIAQgBUEBEPoCCyADBEAgAiADQQEQ+gILIAEEQCAAIAFBARD6AgsgCgJ/IAtFBEBBACELQQAhAEEBDAELIAchAEEAIQdBAAs2AgwgCiAHNgIIIAogADYCBCAKIAs2AgAgCEEgaiQAIAooAgAgCigCBCAKKAIIIAooAgwgCkEQaiQACzcBAX4gACkCACEBQRRBBBCBAyIARQRAQQRBFBCaAwALIABCADcCDCAAIAE3AgQgAEEBNgIAIAAL1gIBAX8jAEEQayIEJAAgBCABNgIMIAQgADYCCCMAQfAAayIAJAAgAEHw4MQANgIMIAAgBEEIajYCCCAAQfDgxAA2AhQgACAEQQxqNgIQIABBoOPEACgCADYCHCAAQZTjxAAoAgA2AhgCQCACKAIABEAgAEEwaiACQRBqKQIANwMAIABBKGogAkEIaikCADcDACAAIAIpAgA3AyAgAEEENgJcIABBtOLEADYCWCAAQgQ3AmQgACAAQRBqrUKAgICA8BWENwNQIAAgAEEIaq1CgICAgPAVhDcDSCAAIABBIGqtQoCAgICAFoQ3A0AMAQsgAEEDNgJcIABBgOLEADYCWCAAQgM3AmQgACAAQRBqrUKAgICA8BWENwNIIAAgAEEIaq1CgICAgPAVhDcDQAsgACAAQRhqrUKAgICAsBWENwM4IAAgAEE4ajYCYCAAQdgAaiADEL8CAAs4AQF/IAEoAggiAkGAgIAQcUUEQCACQYCAgCBxRQRAIAAgARCbAQ8LIAAgARDoAQ8LIAAgARDnAQs4AQF/IAEoAggiAkGAgIAQcUUEQCACQYCAgCBxRQRAIAAgARCUAQ8LIAAgARDoAQ8LIAAgARDnAQs3AQF/IwBBIGsiASQAIAFBADYCGCABQQE2AgwgAUHo4MQANgIIIAFCBDcCECABQQhqIAAQvwIAC8gGAgV/An4jAEEQayIJJAAjAEHgAGsiCCQAAkACQAJAIAAEQCAAQQhrIgsgCygCAEEBaiIKNgIAIApFDQEgACgCAA0CIABBfzYCACAIIAs2AhAgCCAANgIMIAggAjYCHCAIIAE2AhggCCACNgIUIAggBDYCKCAIIAM2AiQgCCAENgIgIAggAEEIaiIBNgIIAkAgBkUEQEGAgICAeCEHDAELIAggBzYCNCAIIAY2AjALIAggBzYCLCAIQcwAaiEDIAhBFGohBiAIQSBqIQcgBfwHIQ0jAEHQAGsiAiQAIAhBLGoiBCkCBCEOIAQoAgAhCgJAQQdBARCBAyIEBEAgBEEDakGbqcAAKAAANgAAIARBmKnAACgAADYAACACQRhqIAZBCGooAgA2AgAgAkEkaiAHQQhqKAIANgIAIAIgDTcDCCACQgA3AwAgAiAONwM4IAIgCjYCNCACQQc2AjAgAiAENgIsIAJBBzYCKCACIAYpAgA3AxAgAiAHKQIANwIcIAJBxABqIAIQYSACKAJIIQYCQCACKAJEIgpBgICAgHhGBEAgASgCmBAhBCABQQA2ApgQIAQEQCABKAKUECEBA0AgASgCACIHBEAgAUEEaigCACAHQQEQ+gILIAFBDGohASAEQQFrIgQNAAsLIAMgBjYCBCADQYSAgIB4NgIADAELIAIoAkwhDCABKAKYECIEIAEoApAQRgRAIAFBkBBqEJUCCyABKAKUECAEQQxsaiIHIAw2AgggByAGNgIEIAcgCjYCACADQYqAgIB4NgIAIAEgBEEBajYCmBALIAIQygEgAkHQAGokAAwBC0EBQQcQ2wIAC0GNgICAeCEBIAgoAkwiAkGKgICAeEcEQCAIQUBrIAhB2ABqKQIANwMAIAggCCkCUDcDOCACIQELQQAhByAAQQA2AgAgCyALKAIAQQFrIgA2AgAgAEUEQCAIQRBqEHsLIAFBjYCAgHhHBEAgCEHYAGogCEFAaykDADcCACAIIAE2AkwgCCAIKQM4NwJQQQEhByAIQcwAahCkASEACyAJIAc2AgQgCSAAQQAgBxs2AgAgCEHgAGokAAwDCxCQAwsACxCRAwALIAkoAgAgCSgCBCAJQRBqJAALpAwCEH8CfiMAQRBrIggkACMAQTBrIgQkAAJAAkACQAJAIAAEQCAAQQhrIg0gDSgCAEEBaiIFNgIAIAVFDQEgACgCACIFQX9GDQIgACAFQQFqNgIAIAQgDTYCDCAEIAA2AgggBCAAQQhqIgY2AgQgBCADNgIsIAQgAjYCKCAEIAM2AiQgBEEQaiEDIARBJGohDiMAQeABayICJAACQCAGKAKMECABTQRAIAMgATYCBCADQYCAgIB4NgIADAELIAYoAogQIAFBDGxqIgcoAgQhBSACIAcoAggiBzYCTCACIAU2AkggAkIANwJAIAIgBzYCPCACIAU2AjggAkHYAGogAkE4ahBcIAIpA1giFUIEUQRAIAMgAigCYDYCBCADQYSAgIB4NgIADAELIAIoAowBIQcgAigCgAEhCiACKAJ0IQsgAikDkAEiFKchBSAVQgNRBEAgAigCiAEhCSACKAJ8IQEgAigCcCEGIAMgBTYCDCADIAc2AgggAyAJNgIEIANBioCAgHg2AgAgBgRAIAsgBkEBEPoCCyABRQ0BIAogAUEBEPoCDAELIAIoAoQBIRAgAigCeCERIAIoAmwhEiACKAJoIQkCQAJAAkAgB0GAgICAeEcEQCACIAZB4A9qIAEQKwJAAkACQCAUQoCAgICwAVoEQEGFqcAAIAVBCxCDAkUNAQsgA0GBgICAeDYCAAwBCyAUQiCIpyEBIBRCgICAgMABWgRAIAUsAAtBQEgNBAsgAkHYAGogBUELaiABQQtrEI4BIAIpAlwhFCACKAJYIgFBgICAgHhGBEAgAyAUNwIEIANBgoCAgHg2AgAMAQsgAigCXCEMIAJB2ABqIAZBgA9qIA4QWiACLQBYQQFGBEAgAkHLAGogAkHsAGooAgAiBjYAACACQcMAaiACQeQAaikCACIUNwAAIAIgAikCXCIVNwA7IANBEGogBjYAACADQQhqIBQ3AAAgAyAVNwAAIAFFDQEgDCABQQEQ+gIMAQsgAkEgaiACQeEAaikAADcDACACQShqIAJB6QBqKQAANwMAIAJBMGogAkHxAGopAAA3AwAgAiACKQBZNwMYIAJByABqIAJBEGopAAA3AwAgAkFAayACQQhqKQAANwMAIAIgAikAADcDOCACQdgAaiIMIAJBGGogAkE4aiITEOsBIAJBmAFqQQBBwQD8CwAgAiAUQiCIpyIPNgJAIAIgFKciBjYCPCACIAY2AjggDCATECUNBCATIAYgDxBPIAIoAjhBAUcNASADIAIpAjwiFEIgiD4CECADIBQ+AgwgAyAPNgIIIAMgBjYCBCADIAE2AgAgDBCDASAMEPMBCyAHBEAgBSAHQQEQ+gILIAkEQCASIAlBARD6AgsgCwRAIBEgC0EBEPoCCyAKRQ0FIBAgCkEBEPoCDAULIAMgDzYCDCADIAY2AgggAyABNgIEIANBioCAgHg2AgAgAkHYAGoiARCDASABEPMBIAdFDQMgBSAHQQEQ+gIMAwsgA0KKgICAiICAgIB/NwIADAILIAUgAUELIAFB4KvAABDrAgALQbCpwABBKyACQd8BakGgqcAAQdypwAAQ5gEACyAJBEAgEiAJQQEQ+gILIAsEQCARIAtBARD6AgsgCkUNACAQIApBARD6AgsgDigCACIBBEAgDigCBCABQQEQ+gILIAJB4AFqJAAgBCgCECEFIAQoAhQhAyAEKAIYIQEgBCgCHCECIAQpAhghFCAEKAIgIQcgACAAKAIAQQFrNgIAIA0gDSgCAEEBayIANgIAIABFBEAgBEEMahB7CyAIAn8gBUGKgICAeEYEQEEAIQAgA0GAgICAeEYEQEEAIQFBACECQQAMAgsgAiADSQRAIAJFBEAgASADQQEQ+gJBASEBQQAMAwsgASADQQEgAhDtAiIBRQ0GC0EADAELIAQgBzYCICAEIBQ3AhggBCADNgIUIAQgBTYCEEEAIQEgBEEQahCkASEAQQAhAkEBCzYCDCAIIAA2AgggCCACNgIEIAggATYCACAEQTBqJAAMBAsQkAMLAAsQkQMAC0EBIAIQ2wIACyAIKAIAIAgoAgQgCCgCCCAIKAIMIAhBEGokAAuKDAIQfwJ+IwBBEGsiCCQAIwBBMGsiBSQAAkACQAJAAkAgAARAIABBCGsiDCAMKAIAQQFqIgQ2AgAgBEUNASAAKAIAIgRBf0YNAiAAIARBAWo2AgAgBSAMNgIMIAUgADYCCCAFIABBCGoiBzYCBCAFIAM2AiwgBSACNgIoIAUgAzYCJCAFQRBqIQMgBUEkaiEOIwBB4AFrIgIkAAJAAkACQAJAIAcoAowQIAFNBEAgAyABNgIEIANBgICAgHg2AgAMAQsgBygCiBAgAUEMbGoiBigCBCEEIAIgBigCCCIGNgJMIAIgBDYCSCACQgA3AkAgAiAGNgI8IAIgBDYCOCACQdgAaiACQThqEFwgAikDWCIUQgRRBEAgAyACKAJgNgIEIANBhICAgHg2AgAMAQsgAigCjAEhCSACKAKAASEKIAIoAnghDyACKAJ0IQsgAigCcCEEIBRCA1EEQCACKAKIASEBIAIoAnwhBiADIA82AgwgAyALNgIIIAMgBDYCBCADQYqAgIB4NgIAIAFBgICAgHhyQYCAgIB4RwRAIAkgAUEBEPoCCyAGRQ0BIAogBkEBEPoCDAELIAIoApABIREgAigChAEhEiACKAJsIQYgAigCaCENIAIgB0HgD2ogARArAkACQAJAIARBC08EQEGFqcAAIAZBCxCDAkUNAQsgA0GBgICAeDYCAAwBCyAEQQtHBEAgBiwAC0FASA0ECyACQdgAaiAGQQtqIARBC2sQjgEgAikCXCEUIAIoAlgiAUGAgICAeEYEQCADIBQ3AgQgA0GCgICAeDYCAAwBCyACKAJcIQQgAkHYAGogB0GAD2ogDhBaIAItAFhBAUYEQCACQcsAaiACQewAaigCACIHNgAAIAJBwwBqIAJB5ABqKQIAIhQ3AAAgAiACKQJcIhU3ADsgA0EQaiAHNgAAIANBCGogFDcAACADIBU3AAAgAUUNASAEIAFBARD6AgwBCyACQSBqIAJB4QBqKQAANwMAIAJBKGogAkHpAGopAAA3AwAgAkEwaiACQfEAaikAADcDACACIAIpAFk3AxggAkHIAGogAkEQaikAADcDACACQUBrIAJBCGopAAA3AwAgAiACKQAANwM4IAJB2ABqIgcgAkEYaiACQThqIhMQ6wEgAkGYAWpBAEHBAPwLACACIBRCIIinIhA2AkAgAiAUpyIENgI8IAIgBDYCOCAHIBMQJQ0EIBMgBCAQEE8gAigCOEEBRw0BIAMgAikCPCIUQiCIPgIQIAMgFD4CDCADIBA2AgggAyAENgIEIAMgATYCACAHEIMBIAcQ8wELIA0EQCAGIA1BARD6AgsgCwRAIA8gC0EBEPoCCyAJQYCAgIB4ckGAgICAeEcEQCARIAlBARD6AgsgCkUNASASIApBARD6AgwBCyADIBA2AgwgAyAENgIIIAMgATYCBCADQYqAgIB4NgIAIAJB2ABqIgEQgwEgARDzASANBEAgBiANQQEQ+gILIAsEQCAPIAtBARD6AgsgCUGAgICAeHJBgICAgHhHBEAgESAJQQEQ+gILIApFDQAgEiAKQQEQ+gILIA4oAgAiAQRAIA4oAgQgAUEBEPoCCyACQeABaiQADAILIAYgBEELIARB8KvAABDrAgALQbCpwABBKyACQd8BakGgqcAAQdypwAAQ5gEACyAFKAIQIQQgBSgCFCEDIAUoAhghASAFKAIcIQIgBSgCICEGIAAgACgCAEEBazYCACAMIAwoAgBBAWsiADYCACAARQRAIAVBDGoQewsgCAJ/IARBioCAgHhHBEAgBSAGNgIgIAUgAjYCHCAFIAE2AhggBSADNgIUIAUgBDYCEEEAIQAgBUEQahCkASEBQQAhAkEBDAELAkAgAiADTwRAIAEhAAwBCyACRQRAQQEhACABIANBARD6AgwBCyABIANBASACEO0CIgBFDQULQQAhAUEACzYCDCAIIAE2AgggCCACNgIEIAggADYCACAFQTBqJAAMBAsQkAMLAAsQkQMAC0EBIAIQ2wIACyAIKAIAIAgoAgQgCCgCCCAIKAIMIAhBEGokAAugBAILfwJ+IwBBEGsiBiQAIwBBkAFrIgQkACAEQcgAaiIIIAAgASACIAMQdwJAAkACQCAELQBIQQFGBEAgBEEbaiAEQdwAaigCACIHNgAAIARBE2ogBEHUAGopAgAiDzcAACAEIAQpAkwiEDcACyAEQdgAaiAHNgIAIARB0ABqIA83AwAgBCAQNwNIIAgQywEhBwwBCyAEQUBrIgkgBEGBAWopAAA3AwAgBEE4aiIKIARB+QBqKQAANwMAIARBMGoiCyAEQfEAaikAADcDACAEQShqIgwgBEHpAGopAAA3AwAgBEEgaiINIARB4QBqKQAANwMAIARBGGoiDiAEQdkAaikAADcDACAEQRBqIgggBEHRAGopAAA3AwAgBCAEKQBJNwMIQcAAIQdBwABBARCBAyIFRQ0BIAUgBCkDCDcAACAFQThqIAkpAwA3AAAgBUEwaiAKKQMANwAAIAVBKGogCykDADcAACAFQSBqIAwpAwA3AAAgBUEYaiANKQMANwAAIAVBEGogDikDADcAACAFQQhqIAgpAwA3AAALIAMEQCACIANBARD6AgsgAQRAIAAgAUEBEPoCCyAGAn8gBUUEQEEAIQVBACEAQQEMAQsgByEAQQAhB0EACzYCDCAGIAc2AgggBiAANgIEIAYgBTYCACAEQZABaiQADAELQQFBwAAQmgMACyAGKAIAIAYoAgQgBigCCCAGKAIMIAZBEGokAAvZAQEFfyMAQRBrIgckACMAQTBrIgYkACAGQQhqIAAgASACIAMgBCAFED8gBi0ADCEIAn8gBigCCCIJQQpHBEAgBkEoaiAGQRRqKQAANwAAIAYgBikADTcAISAGIAg6ACAgBiAJNgIcQQAhCCAGQRxqEMsBDAELQQALIQogBQRAIAQgBUEBEPoCCyADBEAgAiADQQEQ+gILIAEEQCAAIAFBARD6AgsgByAKNgIEIAcgCDYCACAHIAlBCkc2AgggBkEwaiQAIAcoAgAgBygCBCAHKAIIIAdBEGokAAvqDAIKfwF+IwBBEGsiCSQAIwBBEGsiCiQAIApBBGohCyMAQdAAayIFJAAgBUEMaiACIAMQTwJAIAUoAgxBAUYEQCAFIAUpAhA3AxggBSAFQRhqrUKAgICA8ACENwMwIAVCATcCRCAFQQE2AjwgBUGUosAANgI4IAUgBUEwajYCQCAFQSBqIAVBOGoQeSAFKAIkIgQgBSgCKBDjAiEGIAUoAiAiCARAIAQgCEEBEPoCCyALQYCAgIB4NgIAIAsgBjYCBAwBCyAFQThqIQYgBSgCECEIIAUoAhQhByMAQeABayIEJAACQAJAAkACQAJAIAdBDkkNAEHNwsAAIAhBDhCDAg0AIARB68DAADYCaCAEIAdBDms2AmQgBCAIQQ5qNgJgIARBuAFqIARB4ABqIgcQnQEgBCgCuAEiCEGAgICAeEYEQCAEIAQpArwBNwOoASAEQQA2AtABIARCgICAgBA3AsgBIARBoMPAADYCZCAEQqCAgIAONwJoIAQgBEHIAWo2AmAgBEGoAWogBxCuAQ0EIAQpAsgBIQ4gBiAEKALQATYCDCAGIA43AgQgBkEJNgIADAMLIARBEGogBCgCvAEiDSAEKALAASAAIAEQdyAELQAQQQFGBEAgBEHwAGogBEEkaigCADYCACAEQegAaiAEQRxqKQIANwMAIAQgBCkCFDcDYCAEQQA2AsABIARCgICAgBA3ArgBIARBoMPAADYCzAEgBEKggICADjcC0AEgBCAEQbgBajYCyAEgBEHgAGogBEHIAWoQWQ0EIARBFGohByAEQbABaiAEQcABaigCADYCACAEIAQpArgBNwOoAQJAIAQoAmAiDEEITUEAQQEgDHRBzwNxGw0AIAQoAmQiDEUNACAEKAJoIAxBARD6AgsgBEEgaiAEQbABaigCADYCACAEQQQ2AhQgBCAEKQOoATcCGCAGQRBqIAdBEGooAgA2AgAgBkEIaiAHQQhqKQIANwIAIAYgBykCADcCACAIRQ0DIA0gCEEBEPoCDAMLIARBnAFqIARByQBqKQAANwIAIARBlAFqIARBwQBqKQAANwIAIARBjAFqIARBOWopAAA3AgAgBEGEAWogBEExaikAADcCACAEQfwAaiAEQSlqKQAANwIAIARB9ABqIARBIWopAAA3AgAgBEHsAGogBEEZaikAADcCACAEIAQpABE3AmQgBEHrwMAANgJgIARBADYC0AEgBEKAgICAEDcCyAEgBEHAADYCvAEgBCAEQeQAajYCuAEgBCAEQcgBaiIHNgKoASAEQQhqIARBqAFqQeAAIARBuAFqIgxB68DAABCcASAEKAIIQQFxDQEgBEHAAWogBEHQAWooAgA2AgAgBCAEKQLIATcDuAEgBCAMrUKAgICAwAaENwPIASAEQgE3AmwgBEEBNgJkIARBhMPAADYCYCAEIAc2AmggBEHUAGogBEHgAGoQeSAEKAK4ASIHBEAgBCgCvAEgB0EBEPoCCyAGIAQpAlQ3AgQgBkEKNgIAIAZBDGogBEHcAGooAgA2AgAgCEUNAiANIAhBARD6AgwCCyAGQQ42AhAgBkHNwsAANgIMIAZBDTYCCCAGQdvCwAA2AgQgBkEINgIADAELQci+wABBKyAEQd8BakG4vsAAQfS+wAAQ5gEACyAEQeABaiQADAELQcjDwABBNyAEQd8BakG4w8AAQYDEwAAQ5gEACyAFQShqIgQgBUHEAGoiCCgCADYCACAFIAUpAjw3AyAgBSgCOCIHQQpHBEAgBSgCSCENIAggBCgCADYCACAFIAUpAyA3AjwgBSANNgJIIAUgBzYCOCAGEMsBIQQgC0GAgICAeDYCACALIAQ2AgQMAQsgCyAFKQMgNwIAIAtBCGogBCgCADYCAAsgBUHQAGokACADBEAgAiADQQEQ+gILIAEEQCAAIAFBARD6AgsCQAJAAn8gCigCBCICQYCAgIB4RgRAQQEhAkEAIQFBACEDIAooAggMAQsgCigCCCEAAkAgCigCDCIDIAJPBEAgACEBDAELIANFBEBBASEBIAAgAkEBEPoCDAELIAAgAkEBIAMQ7QIiAUUNAgtBACECQQALIQAgCSACNgIMIAkgADYCCCAJIAM2AgQgCSABNgIAIApBEGokAAwBC0EBIAMQ2wIACyAJKAIAIAkoAgQgCSgCCCAJKAIMIAlBEGokAAucCwINfwF+IwBBEGsiDSQAIwBBEGsiDiQAIA5BCGohCiMAQdAAayIHJAAgB0EIaiAAIAEQTwJAIAcoAghBAUYEQCAHIAcpAgw3AyggByAHQShqrUKAgICA8ACENwMwIAdCATcCRCAHQQE2AjwgB0G4osAANgI4IAcgB0EwajYCQCAHQRRqIAdBOGoQeSAHKAIYIgYgBygCHBDjAiEIIAcoAhQiCQRAIAYgCUEBEPoCCyAKQQE6AAAgCiAINgIEDAELIAcoAhAhCSAHKAIMIQsgB0EIaiAEIAUQTyAHKAIIQQFGBEAgByAHKQIMNwMoIAcgB0Eoaq1CgICAgPAAhDcDMCAHQgE3AkQgB0EBNgI8IAdB2KLAADYCOCAHIAdBMGo2AkAgB0EUaiAHQThqEHkgBygCGCIGIAcoAhwQ4wIhCCAHKAIUIgkEQCAGIAlBARD6AgsgCkEBOgAAIAogCDYCBAwBCyAHQRRqIQggBygCDCEPIAcoAhAhDCMAQdAAayIGJAACQAJAAkACQAJAIAlBC0kNAEH4wsAAIAtBCxCDAg0AIAZB68DAADYCICAGIAlBC2s2AhwgBiALQQtqNgIYIAZBMGogBkEYaiILEJ0BIAYoAjAiCUGAgICAeEYEQCAGIAYpAjQ3AwggBkEANgJEIAZCgICAgBA3AjwgBkGgw8AANgIcIAZCoICAgA43AiAgBiAGQTxqNgIYIAZBCGogCxCuAQ0EIAYpAjwhEyAIIAYoAkQ2AgwgCCATNwIEIAhBCTYCAAwDCyAGKAI0IQsCQAJAIAxBCEkNACAPKQAAQvPSnfPWzNyv+gBSDQAgBigCOCEQIAZB68DAADYCICAGIAxBCGs2AhwgBiAPQQhqNgIYIAZBMGoiDCAGQRhqIhEQnQEgBigCMCIPQYCAgIB4Rg0BIAggBigCNCISIAYoAjggAiADIAsgEBA/IAgoAgBBCkcEQCAGQShqIAhBEGooAgA2AgAgBkEgaiAIQQhqKQIANwMAIAYgCCkCADcDGCAGQQA2AjggBkKAgICAEDcCMCAGQaDDwAA2AkAgBkKggICADjcCRCAGIAw2AjwgESAGQTxqEFkNBiAGQRBqIAZBOGooAgA2AgAgBiAGKQIwNwMIAkAgBigCGCIMQQhNQQBBASAMdEHPA3EbDQAgBigCHCIMRQ0AIAYoAiAgDEEBEPoCCyAIQQQ2AgAgCCAGKQMINwIEIAhBDGogBkEQaigCADYCAAsgDwRAIBIgD0EBEPoCCyAJRQ0EIAsgCUEBEPoCDAQLIAhBCTYCECAIQZXDwAA2AgwgCEEINgIIIAhB6MLAADYCBCAIQQg2AgAMAgsgBiAGKQI0NwMIIAZBADYCRCAGQoCAgIAQNwI8IAZBoMPAADYCHCAGQqCAgIAONwIgIAYgBkE8ajYCGCAGQQhqIAZBGGoQrgENAyAGKQI8IRMgCCAGKAJENgIMIAggEzcCBCAIQQk2AgAMAQsgCEEJNgIQIAhBjMPAADYCDCAIQQs2AgggCEH4wsAANgIEIAhBCDYCAAwBCyAJRQ0AIAsgCUEBEPoCCyAGQdAAaiQADAELQcjDwABBNyAGQc8AakG4w8AAQYDEwAAQ5gEACyAHLQAYIQYgBygCFCIIQQpHBEAgB0HEAGogB0EgaikAADcAACAHIAcpABk3AD0gByAGOgA8IAcgCDYCOCAHQThqEMsBIQYgCkEBOgAAIAogBjYCBAwBCyAKQQA6AAAgCiAGOgABCyAHQdAAaiQAIAUEQCAEIAVBARD6AgsgAwRAIAIgA0EBEPoCCyABBEAgACABQQEQ+gILIA0gDi0ACCIANgIIIA0gDigCDEEAIAAbNgIEIA1BACAOLQAJIAAbNgIAIA5BEGokACANKAIAIA0oAgQgDSgCCCANQRBqJAALiwYCB38EfiMAQRBrIgckACMAQdAAayIFJAAgBUEoaiEGIwBB4ABrIgQkAAJAIAEiCEEgRgRAIANBIEYEQCAAKQADIQsgACgACyEBIAApAA8hDCAEQSJqIAJBAmotAAA6AAAgBEE/aiACQR9qLQAAOgAAIAQgAi8AADsBICAEIAIpABc3ADcgAikAAyENIAIoAAshCSACKQAPIQ4gBEECaiAAQQJqLQAAOgAAIARBH2ogAEEfai0AADoAACAEIAw3AA8gBCABNgALIAQgCzcAAyAEIAAvAAA7AQAgBCAAKQAXNwAXIAQgDjcALyAEIAk2ACsgBCANNwAjIARBQGsiASAEIARBIGoQ0QEgBkEAOgAAIAZBGWogBEHYAGopAAA3AAAgBkERaiAEQdAAaikAADcAACAGQQlqIARByABqKQAANwAAIAYgBCkAQDcAASAEEMIBIAEQwgEMAgsgBiADNgIMIAZCgICAgIAENwIEIAZBAToAAAwBCyAGIAg2AgwgBkKAgICAgAQ3AgQgBkEBOgAACyAEQeAAaiQAAkACQAJAIAUtACgiBEEBRgRAIAVBG2ogBUE8aigCACIBNgAAIAVBE2ogBUE0aikCACILNwAAIAUgBSkCLCIMNwALIAVBOGogATYCACAFQTBqIAs3AwAgBSAMNwMoIAYQywEhAQwBCyAFQSBqIgYgBUHBAGopAAA3AwAgBUEYaiIJIAVBOWopAAA3AwAgBUEQaiIKIAVBMWopAAA3AwAgBSAFKQApNwMIQSBBARCBAyIBRQ0BIAEgBSkDCDcAACABQRhqIAYpAwA3AAAgAUEQaiAJKQMANwAAIAFBCGogCikDADcAAAsgAwRAIAIgA0EBEPoCCyAIBEAgACAIQQEQ+gILAn8gBARAQQEhAkEAIQBBAAwBC0EAIQIgASEAQQAhAUEgCyEDIAcgAjYCDCAHIAE2AgggByADNgIEIAcgADYCACAFQdAAaiQADAELQQFBIBCaAwALIAcoAgAgBygCBCAHKAIIIAcoAgwgB0EQaiQAC4oGAgd/AX4jAEEQayIJJAAjAEHQAGsiBiQAAkACQAJAIAAEQCAAQQhrIgogCigCAEEBaiIHNgIAIAdFDQEgACgCAA0CIABBfzYCACAGIAo2AgwgBiAANgIIIAYgAjYCGCAGIAE2AhQgBiACNgIQIAYgAEEIaiICNgIEAkAgBEUEQEGAgICAeCEFDAELIAYgBTYCJCAGIAQ2AiALIAYgBTYCHCAGQTxqIQQgBkEQaiEFIAP8ByENIAZBHGohByMAQdAAayIBJAACQEEIQQEQgQMiCARAIAhC9OTVm8eumrfnADcAACABQSBqIAVBCGooAgA2AgAgAUE4aiAHQQhqKAIANgIAIAFBCDYCLCABIAg2AiggAUEINgIkIAEgDTcDECABQgA3AwggAUIDNwMAIAEgBSkCADcDGCABIAcpAgA3AzAgAUHEAGogARBhIAEoAkghBwJAIAEoAkQiC0GAgICAeEYEQCACKAKYECEFIAJBADYCmBAgBQRAIAIoApQQIQIDQCACKAIAIggEQCACQQRqKAIAIAhBARD6AgsgAkEMaiECIAVBAWsiBQ0ACwsgBCAHNgIEIARBhICAgHg2AgAMAQsgASgCTCEMIAIoApgQIgUgAigCkBBGBEAgAkGQEGoQlQILIAIoApQQIAVBDGxqIgggDDYCCCAIIAc2AgQgCCALNgIAIARBioCAgHg2AgAgAiAFQQFqNgKYEAsgARDKASABQdAAaiQADAELQQFBCBDbAgALQY2AgIB4IQEgBigCPCICQYqAgIB4RwRAIAZBMGogBkHIAGopAgA3AwAgBiAGKQJANwMoIAIhAQtBACEFIABBADYCACAKIAooAgBBAWsiADYCACAARQRAIAZBDGoQewsgAUGNgICAeEcEQCAGQcgAaiAGQTBqKQMANwIAIAYgATYCPCAGIAYpAyg3AkBBASEFIAZBPGoQpAEhAAsgCSAFNgIEIAkgAEEAIAUbNgIAIAZB0ABqJAAMAwsQkAMLAAsQkQMACyAJKAIAIAkoAgQgCUEQaiQAC9IBAQZ/IwBBEGsiAyQAIwBBIGsiAiQAIAJBDGoiBiAAIAEQigEgAigCFCEEIAIoAhAhBSACKAIMIgdBCkcEQCACIAIpAhg3AhggAiAENgIUIAIgBTYCECACIAc2AgxBACEFIAYQywEhBAsgAQRAIAAgAUEBEPoCCyADAn8gBUUEQEEAIQVBACEAQQEMAQsgBCEAQQAhBEEACzYCDCADIAQ2AgggAyAANgIEIAMgBTYCACACQSBqJAAgAygCACADKAIEIAMoAgggAygCDCADQRBqJAAL+QEBBH8jAEEQayICJAACfwJAIAFBIEYEQCAAKAADIQFBIEEBEIEDIgMNAUEBQSAQmgMAC0HLoMAAQRoQ4wIhBEEBIQVBACABRQ0BGiAAIAFBARD6AkEADAELIAMgAC8AADsAACADQQJqIABBAmotAAA6AAAgAyABNgADIAMgACkABzcAByADQQ9qIABBD2opAAA3AAAgA0EXaiAAQRdqKQAANwAAIANBH2ogAEEfai0AADoAACAAQSBBARD6AkEgCyEAIAIgBTYCDCACIAQ2AgggAiAANgIEIAIgAzYCACACKAIAIAIoAgQgAigCCCACKAIMIAJBEGokAAu+AgEEfyMAQRBrIgMkAAJ/AkAgAUHAAEYEQCAAKAADIQFBwABBARCBAyICDQFBAUHAABCaAwALQbOgwABBGBDjAiEEQQEhBUEAIAFFDQEaIAAgAUEBEPoCQQAMAQsgAiAALwAAOwAAIAJBAmogAEECai0AADoAACACIAE2AAMgAiAAKQAHNwAHIAJBD2ogAEEPaikAADcAACACQRdqIABBF2opAAA3AAAgAkEfaiAAQR9qKQAANwAAIAJBJ2ogAEEnaikAADcAACACQS9qIABBL2opAAA3AAAgAkE3aiAAQTdqKQAANwAAIAJBP2ogAEE/ai0AADoAACAAQcAAQQEQ+gJBwAALIQAgAyAFNgIMIAMgBDYCCCADIAA2AgQgAyACNgIAIAMoAgAgAygCBCADKAIIIAMoAgwgA0EQaiQAC7oDAQh/IwBBEGsiAyQAIwBBEGsiBSQAIAVBCGohBiMAQdAAayICJAAgAkEEaiAAIAEQigECQAJAAkAgAigCBEEKRwRAIAJBKGogAkEUaigCADYCACACQSBqIAJBDGopAgA3AwAgAiACKQIENwMYIAJBADYCOCACQoCAgIAQNwIwIAJBhKHAADYCQCACQqCAgIAONwJEIAIgAkEwajYCPCACQRhqIAJBPGoQWQ0CIAIoAjAhBCACKAI0IgggAigCOBDjAiEJIAQEQCAIIARBARD6AgsCQCACKAIYIgRBCE1BAEEBIAR0Qc8DcRsNACACKAIcIgRFDQAgAigCICAEQQEQ+gILIAZBADYCACAGIAk2AgQMAQsgBiACKQIINwIACyACQdAAaiQADAELQayhwABBNyACQc8AakGcocAAQeShwAAQ5gEACyABBEAgACABQQEQ+gILIAMCfyAFKAIIIgBFBEBBACEAIAUoAgwhAUEBDAELQQAhASAFKAIMIQdBAAs2AgwgAyABNgIIIAMgBzYCBCADIAA2AgAgBUEQaiQAIAMoAgAgAygCBCADKAIIIAMoAgwgA0EQaiQAC/kBAQR/IwBBEGsiAiQAAn8CQCABQSBGBEAgACgAAyEBQSBBARCBAyIDDQFBAUEgEJoDAAtB5aDAAEEcEOMCIQRBASEFQQAgAUUNARogACABQQEQ+gJBAAwBCyADIAAvAAA7AAAgA0ECaiAAQQJqLQAAOgAAIAMgATYAAyADIAApAAc3AAcgA0EPaiAAQQ9qKQAANwAAIANBF2ogAEEXaikAADcAACADQR9qIABBH2otAAA6AAAgAEEgQQEQ+gJBIAshACACIAU2AgwgAiAENgIIIAIgADYCBCACIAM2AgAgAigCACACKAIEIAIoAgggAigCDCACQRBqJAALpwsCDH8BfiMAQRBrIgYkACMAQRBrIggkACAIQQRqIQkjAEHQAGsiAyQAIANBDGogACABEE8CQCADKAIMQQFGBEAgAyADKQIQNwMYIAMgA0EYaq1CgICAgPAAhDcDMCADQgE3AkQgA0EBNgI8IANBlKLAADYCOCADIANBMGo2AkAgA0EgaiADQThqEHkgAygCJCICIAMoAigQ4wIhBSADKAIgIgQEQCACIARBARD6AgsgCUGAgICAeDYCACAJIAU2AgQMAQsgA0E4aiEFIAMoAhAhBCADKAIUIQcjAEGAAWsiAiQAAkACQAJAAkACQCAHQQ5JDQBBzcLAACAEQQ4QgwINACACQevAwAA2AmggAiAHQQ5rNgJkIAIgBEEOajYCYCACQUBrIAJB4ABqIgQQnQEgAigCQCIHQYCAgIB4RgRAIAIgAikCRDcDMCACQQA2AlggAkKAgICAEDcCUCACQaDDwAA2AmQgAkKggICADjcCaCACIAJB0ABqNgJgIAJBMGogBBCuAQ0EIAIpAlAhDiAFIAIoAlg2AgwgBSAONwIEIAVBCTYCAAwDCyACQRBqIAIoAkQiCiACKAJIEIoBIAIoAhBBCkcEQCACQfAAaiACQSBqKAIANgIAIAJB6ABqIAJBGGopAgA3AwAgAiACKQIQNwNgIAJBADYCSCACQoCAgIAQNwJAIAJBoMPAADYCVCACQqCAgIAONwJYIAIgAkFAazYCUCACQeAAaiACQdAAahBZDQQgAkE4aiACQcgAaigCADYCACACIAIpAkA3AzACQCACKAJgIgRBCE1BAEEBIAR0Qc8DcRsNACACKAJkIgRFDQAgAigCaCAEQQEQ+gILIAJBHGoiBCACQThqKAIANgIAIAIgAikDMCIONwIUIAUgBCkCADcCDCAFIA43AgQgBUEENgIAIAdFDQMgCiAHQQEQ+gIMAwsgAigCFCEMIAIoAhghBCACQQA2AmggAkKAgICAEDcCYCACIAQ2AlQgAiAMNgJQIAIgAkHgAGo2AkAgAkEIaiACQUBrIAQgBEEBakEBdmogAkHQAGpB68DAABCcASACKAIIIAQEQCAMIARBARD6AgtBAXENASACQdgAaiACQegAaigCADYCACACIAIpAmA3A1AgAiACQdAAaq1CgICAgMAGhDcDQCACQgE3AmwgAkEBNgJkIAJB8MLAADYCYCACIAJBQGs2AmggAkEkaiACQeAAahB5IAIoAlAiBARAIAIoAlQgBEEBEPoCCyAFIAIpAiQ3AgQgBUEKNgIAIAVBDGogAkEsaigCADYCACAHRQ0CIAogB0EBEPoCDAILIAVBDTYCECAFQdvCwAA2AgwgBUEONgIIIAVBzcLAADYCBCAFQQg2AgAMAQtByL7AAEErIAJB/wBqQbi+wABB9L7AABDmAQALIAJBgAFqJAAMAQtByMPAAEE3IAJB/wBqQbjDwABBgMTAABDmAQALIANBKGoiAiADQcQAaiIEKAIANgIAIAMgAykCPDcDICADKAI4IgdBCkcEQCADKAJIIQogBCACKAIANgIAIAMgAykDIDcCPCADIAo2AkggAyAHNgI4IAUQywEhAiAJQYCAgIB4NgIAIAkgAjYCBAwBCyAJIAMpAyA3AgAgCUEIaiACKAIANgIACyADQdAAaiQAIAEEQCAAIAFBARD6AgsCQAJAIAYCfyAIKAIEIgJBgICAgHhGBEBBACEBIAgoAgghAEEBDAELIAgoAgghAAJAIAgoAgwiCyACTwRAIAAhAQwBCyALRQRAQQEhASAAIAJBARD6AgwBCyAAIAJBASALEO0CIgFFDQILQQAhAEEACzYCDCAGIAA2AgggBiALNgIEIAYgATYCACAIQRBqJAAMAQtBASALENsCAAsgBigCACAGKAIEIAYoAgggBigCDCAGQRBqJAALlwQCB38CfiMAQRBrIgQkACMAQdAAayICJAAjAEEgayIDJAAgAkEoaiIFAn8gAUEgRgRAIANBAmogAEECai0AADoAACADQR9qIABBH2otAAA6AAAgAyAALwAAOwEAIAMgACkAFzcAFyADIAApAA83AA8gAyAAKAALNgALIAMgACkAAzcAAyAFQQFqIAMQ7gEgAxDCAUEADAELIAUgATYCDCAFQoCAgICABDcCBEEBCzoAACADQSBqJAACQAJAAkAgAi0AKCIGQQFGBEAgAkEbaiACQTxqKAIAIgM2AAAgAkETaiACQTRqKQIAIgk3AAAgAiACKQIsIgo3AAsgAkE4aiADNgIAIAJBMGogCTcDACACIAo3AyggBRDLASEDDAELIAJBIGoiByACQcEAaikAADcDACACQRhqIgggAkE5aikAADcDACACQRBqIgUgAkExaikAADcDACACIAIpACk3AwhBIEEBEIEDIgNFDQEgAyACKQMINwAAIANBGGogBykDADcAACADQRBqIAgpAwA3AAAgA0EIaiAF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IAAgARDcAkUNACAABEAgACABEIEDIgFFDQELIAEPCwALJwECfyMAQRBrIgAkACAAQQo2AgQgAEEEakEAQQAQkgIgAEEQaiQAC6QJAhJ/An4jAEEwayIPJAAgD0EMaiEQIwBBsAFrIgIkACACQThqQgA3AwAgAkEwakIANwMAIAJBKGpCADcDACACQSBqQgA3AwAgAkEYakIANwMAIAJBEGpCADcDACACQQhqQgA3AwAgAkIANwMAQQEhBwNAIAIgBWoiAyADKAIAIAEgBWoiAy0AAHIgA0EBai0AAEEIdHIgA0ECai0AAEEQdHIgA0EDai0AAEEYdHI2AgAgBUEEaiEFIAdBEEkgB0EBaiEHDQALIAJByABqIgEgAigCCCIKQQZ0IAIoAgQiBkEadnJB/////wFxNgIAIAJB0ABqIgUgAigCECILQQx0IAIoAgwiDEEUdnJB/////wFxNgIAIAJB2ABqIgcgAigCGCIEQRJ0IAIoAhQiDUEOdnJB/////wFxNgIAIAJB4ABqIgMgAigCICIOQRh0IAIoAhwiCEEIdnJB/////wFxNgIAIAIgAigCACIJQf////8BcTYCQCACIAZBA3QgCUEddnJB/////wFxNgJEIAIgDEEJdCAKQRd2ckH/////AXE2AkwgAiANQQ90IAtBEXZyQf////8BcTYCVCACIAhBFXQgBEELdnJB/////wFxNgJcIAJBiAFqIgogAigCPCIEQQ12NgIAIAJB8ABqIg0gAigCKCIIQQF0IAIoAiQiBkEfdnJB/////wFxNgIAIAJB+ABqIgsgAigCMCIJQQd0IAIoAiwiEUEZdnJB/////wFxNgIAIAJBgAFqIgwgAigCOCISQQ10IAIoAjQiE0ETdnJB/////wFxNgIAIAIgBkECdkH/////AXE2AmwgAiAGQRt0IA5BBXZyQf////8BcTYCaCACIBFBBHQgCEEcdnJB/////wFxNgJ0IAIgE0EKdCAJQRZ2ckH/////AXE2AnwgAiAEQRB0IBJBEHZyQf////8BcTYChAEgAkGMAWoiBiACQUBrQbzhwAAQMSADIAJBrAFqIgQoAgA2AgAgByACQaQBaiIOKQIANwMAIAUgAkGcAWoiCCkCADcDACABIAJBlAFqIgkpAgA3AwAgAiACKQKMATcDQCAGIAJB6ABqQZjhwAAQMSAKIAQoAgA2AgAgDCAOKQIANwMAIAsgCCkCADcDACANIAkpAgAiFDcDACACIAIpAowBIhU3A2ggAiACKAJAIBWnaiIEQf////8BcTYCjAEgAiACKAJEIAIoAmwgBEEddmpqIgRB/////wFxNgKQASACIAEoAgAgFKcgBEEddmpqIgFB/////wFxNgKUASACIAIoAkwgAigCdCABQR12amoiAUH/////AXE2ApgBIAIgBSgCACALKAIAIAFBHXZqaiIBQf////8BcTYCnAEgAiACKAJUIAIoAnwgAUEddmpqIgFB/////wFxNgKgASACIAcoAgAgDCgCACABQR12amoiAUH/////AXE2AqQBIAIgAigCXCACKAKEASABQR12amoiAUH/////AXE2AqgBIAIgAygCACAKKAIAIAFBHXZqakH/////AXE2AqwBIBAgBkHg4cAAEGggAkGwAWokACAAIBAQfyAPQTBqJAAL/AECAn8BfiMAQRBrIgIkACACQQE7AQwgAiABNgIIIAIgADYCBCMAQRBrIgEkACACQQRqIgApAgAhBCABIAA2AgwgASAENwIEIwBBEGsiACQAIAFBBGoiASgCACICKAIMIQMCQAJAAkACQCACKAIEDgIAAQILIAMNAUEBIQJBACEDDAILIAMNACACKAIAIgIoAgQhAyACKAIAIQIMAQsgAEGAgICAeDYCACAAIAE2AgwgAEH8p8QAIAEoAgQgASgCCCIALQAIIAAtAAkQxAEACyAAIAM2AgQgACACNgIAIABB4KfEACABKAIEIAEoAggiAC0ACCAALQAJEMQBAAu3FwIYfwd+IwBBEGsiEiQAIAEhFyMAQUBqIggkAAJAAkACQCAABEAgAEEIayITIBMoAgBBAWoiBDYCACAERQ0BIAAoAgANAiAAQX82AgAgCCATNgIMIAggADYCCCAIIABBCGoiBDYCBCAIIAI2AiggCCABNgIkIAggAjYCICAIQSxqIQ0gBCEBIAhBIGohFCMAQcAtayIEJAACQAJAIAMEQCABKAKUECEMIAEoApgQIQoMAQsgASgCmBAhCiABKAKUECEMIARBkBBqIAFBGGopAwA3AwAgBEGIEGogAUEQaikDADcDACAEQYAQaiABQQhqKQMANwMAIAQgASkDADcD+A8gBEHQH2ogAUH4AGopAwA3AwAgBEHIH2og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BjoAAAwHCyADQQc6AAAMBgsgA0EJOgAADAULIANBCjoAAAwEC0ELIQQLIAMgBDoAAAwCCyADQQE6AAAMAQsgA0ECOgAACyADIAEgAhDXASADQRBqJAALZAEEfyMAQRBrIgIkACMAQRBrIgMkACADQQhqIAAgARCJASADKAIMIQQgAygCCCEFIAEEQCAAIAFBARD6AgsgAiAFNgIAIAIgBDYCBCADQRBqJAAgAigCACACKAIEIAJBEGokAAvkAwIFfwN+IwBBEGsiBCQAIwBBEGsiBSQAIAVBCGohBiMAQYAQayICJAAgAkE4akIANwMAIAJBMGpCADcDACACQShqQgA3AwAgAkEgakIANwMAIAJBGGpCADcDACACQRBqQgA3AwAgAkEIakIANwMAIAJByABqQcDLwAApAgAiBzcDACACQdAAakHIy8AAKQIAIgg3AwAgAkHYAGpB0MvAACkCACIJNwMAIAJBiA9qIAc3AwAgAkGQD2ogCDcDACACQZgPaiAJNwMAIAJCADcDACACQbjLwAApAgAiBzcDQCACIAc3A4APIAJBoA9qIAJB4AD8CgAAIAIgAkGAD2oiA0GAAfwKAAAgAkGHAWpBADYAACACQQA2ApgBIAJCADcDkAEgAkIANwOAASACIAAgARApIAMgAhC/AUEgQQEQgQMiA0UEQEEBQSAQ2wIACyADIAIpAIAPNwAAIANBGGogAkGYD2opAAA3AAAgA0EQaiACQZAPaikAADcAACADQQhqIAJBiA9qKQAANwAAIAZBIDYCBCAGIAM2AgAgAkGAEGokACAFKAIMIQIgBSgCCCEDIAEEQCAAIAFBARD6AgsgBCADNgIAIAQgAjYCBCAFQRBqJAAgBCgCACAEKAIEIARBEGokAAshAAJAIAEgAxDcAgRAIAAgASADIAIQ7QIiAA0BCwALIAALogIBBH8jAEEQayIDJAAjAEEwayICJAACQAJAAkACQCAABEAgAEEIayIEIAQoAgBBAWoiATYCACABRQ0BIAAoAgAiAUF/Rg0CIAAgAUEBajYCACACIAQ2AgwgAiAANgIIIAIgAEEIaiIBNgIEIAJBEGogARC/AUEgQQEQgQMiAUUNAyABIAIpABA3AAAgAUEYaiACQShqKQAANwAAIAFBEGogAkEgaikAADcAACABQQhqIAJBGGopAAA3AAAgACAAKAIAQQFrNgIAIAQgBCgCAEEBayIANgIAIABFBEAgAkEMahCaAgsgA0EgNgIEIAMgATYCACACQTBqJAAMBAsQkAMLAAsQkQMAC0EBQSAQ2wIACyADKAIAIAMoAgQgA0EQaiQACyUAIABFBEBB9JvDAEEyEJIDAAsgACACIAMgBCAFIAEoAhAREAALxwIBCX8jAEEQayIDJAAjAEEQayIEJAAgBEEIaiEFIwBB0AJrIgAkACAAQYACaiICQgA3AwAgAEH4AWoiBkIANwMAIABB8AFqIgdCADcDACAAQgA3A+gBIABB6AFqIggQ1QEgAEGPAmoiASAIEDkgAEEIaiABEKICIAEQwAEgAEHQAWogBykDADcCACAAQdgBaiAGKQMANwIAIABB4AFqIAIpAwA3AgAgACAAKQPoATcCyAFBIEEBEIEDIgFFBEBBAUEgEJoDAAsgASAAQcgBaiICKQAANwAAIAFBGGogAkEYaikAADcAACABQRBqIAJBEGopAAA3AAAgAUEIaiACQQhqKQAANwAAIABBCGoQwwEgBUEgNgIEIAUgATYCACAAQdACaiQAIAMgBCkDCDcCACAEQRBqJAAgAygCACADKAIEIANBEGokAAulAgEIfyMAQRBrIgIkACMAQRBrIgMkACADQQhqIQQjAEEgayIBJAAjAEEwayIAJAAgAEEgaiIFQgA3AwAgAEEYaiIGQgA3AwAgAEEQaiIHQgA3AwAgAEIANwMIIABBCGoQ1QEgAUEYaiAFKQMANwAAIAFBEGogBikDADcAACABQQhqIAcpAwA3AAAgASAAKQMINwAAIABBMGokAEEgQQEQgQMiAEUEQEEBQSAQmgMACyAAIAEpAAA3AAAgAEEYaiABQRhqKQAANwAAIABBEGogAUEQaikAADcAACAAQQhqIAFBCGopAAA3AAAgARDCASAEQSA2AgQgBCAANgIAIAFBIGokACACIAMpAwg3AgAgA0EQaiQAIAIoAgAgAigCBCACQRBqJAALIwAgAEUEQEH0m8MAQTIQkgMACyAAIAIgAyAEIAEoAhARCgALIwAgAEUEQEH0m8MAQTIQkgMACyAAIAIgAyAEIAEoAhAREQALIwAgAEUEQEH0m8MAQTIQkgMACyAAIAIgAyAEIAEoAhAROAALIwAgAEUEQEH0m8MAQTIQkgMACyAAIAIgAyAEIAEoAhAROgALIwAgAEUEQEH0m8MAQTIQkgMACyAAIAIgAyAEIAEoAhARPAALKAEBfyAAKAIAIgFBgICAgHhyQYCAgIB4RwRAIAAoAgQgAUEBEPoCCwshACAARQRAQfSbwwBBMhCSAwALIAAgAiADIAEoAhARAwALIgAgAC0AAEUEQCABQZy0xABBBRBTDwsgAUGhtMQAQQQQUwsbACAAKAIAIgBBBGooAgAgAEEIaigCACABEEILHwAgAEUEQEH0m8MAQTIQkgMACyAAIAIgASgCEBEAAAscACAAIAAtAAQgAUEuRnI6AAQgACgCACABEOoCCxoBAX8gACgCACIBBEAgACgCBCABQQEQ+gILCxwAIAAoAgAiACgCACABIABBBGooAgAoAhARAAALHwAgAEEIakGg3sAAKQIANwIAIABBmN7AACkCADcCAAsfACAAQQhqQciSwwApAgA3AgAgAEHAksMAKQIANwIACx8AIABBCGpB5KDEACkCADcCACAAQdygxAApAgA3AgALHwAgAEEIakH0oMQAKQIANwIAIABB7KDEACkCADcCAAtFACAABEAgACABEJoDAAsjAEEgayIAJAAgAEEANgIYIABBATYCDCAAQcCtxAA2AgggAEIENwIQIABBCGpByK3EABC/AgALFQAgAWlBAUYgAEGAgICAeCABa01xCxcBAX8gABAVIgE2AgQgACABQQBHNgIACxcBAX8gABAYIgE2AgQgACABQQBHNgIACxcBAX8gABAZIgE2AgQgACABQQBHNgIACxcBAX8gABAaIgE2AgQgACABQQBHNgIACxwAIABBADYCECAAQgA3AgggAEKAgICAwAA3AgALFwEBbyAAIAEQACECEI8BIgAgAiYBIAALFwEBbyAAIAEQASECEI8BIgAgAiYBIAALFwEBbyAAJQEQECEBEI8BIgAgASYBIAALFgAgACgCACIAKAIEIAAoAgggARCbAwsWACAAKAIAIgAoAgAgACgCBCABEJsDCxUBAX8jAEEQayIBIAA6AA8gAS0ADwsQACABBEAgACABIAIQ+gILCxYAIAAoAgAgASACIAAoAgQoAgwRAQALFAAgACgCACABIAAoAgQoAhARAAALnAcBA38jAEHwAGsiBSQAIAUgAzYCDCAFIAI2AggCfwJAAkAgAUGBAk8EQEH9ASEGA0ACQCAAIAZq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ARCbAwsTACAAQSg2AgQgAEHw3cAANgIACxAAIAAoAgAgACgCBCABEEILEwAgAEEoNgIEIABBmJLDADYCAAsWAEHM5MQAIAA2AgBByOTEAEEBNgIACxAAIAAoAgQgACgCCCABEEILEQAgASAAKAIAIAAoAgQQ6QILEwAgAEG8qMQANgIEIAAgATYCAAsQACABIAAoAgAgACgCBBBTCxAAIAEoAgAgASgCBCAAEGALEQEBfxCPASIBIAAlASYBIAELYQEBfwJAAkAgAEEEaygCACICQXhxIgNBBEEIIAJBA3EiAhsgAWpPBEAgAkEAIAMgAUEnaksbDQEgABBNDAILQcyoxABBLkH8qMQAEJkCAAtBjKnEAEEuQbypxAAQmQIACwsPAEGs3MAAQS8gABCZAgALDwBBuNPEAEErIAAQmQIACw4AIAFB9KHAAEEFEOkCC6gBAQJ/IAAoAgAjAEEwayIAJAAoAgAhAiAAQgA3AyggAEEoaiIDIAIlARAeIAAgACgCLCICNgIkIAAgACgCKDYCICAAIAI2AhwgAEECNgIIIABBiJ7DADYCBCAAQgE3AhAgACAAQRxqrUKAgICAwA+ENwMoIAAgAzYCDCABKAIAIAEoAgQgAEEEahBgIAAoAhwiAgRAIAAoAiAgAkEBEPoCCyAAQTBqJAALDQAgAEGApcAAIAEQYAsOACABQfClwABBBRDpAgsaAAJ/IAFBCU8EQCABIAAQggEMAQsgABAjCwsOACABQc+uwABBGRDpAgsOACABQeiuwABBEBDpAgsOACABQfiuwABBGhDpAgsOACABQcSvwABBERDpAgsOACABQay4wABBERDpAgsOACABQfS5wABBERDpAgsOACABQdC9wABBBRDpAgsOACABQYS/wABBDhDpAgsNACAAQaDDwAAgARBgCw4AIAFBkMTAAEEFEOkCCw4AIAFB9MfAAEEFEOkCCwwAIAAoAgAgARCxAQsMACAAKAIAIAEQmwELCAAgACABECcLDQBBppzDAEEbEJIDAAsOAEHBnMMAQc8AEJIDAAsJACAAIAEQHQALDgAgAUHstsMAQQUQ6QILDQAgAEGsvcMAIAEQYAsNACAAQbygxAAgARBgCw0AIABByKfEACABEGALDAAgACABKQIANwMACw0AIABB2K3EACABEGALDgAgAUGsrMQAQQUQ6QILGgAgACABQZToxAAoAgAiAEGUASAAGxECAAALCgAgAiAAIAEQUwsNACAAQZy2xAAgARBgCw0AIAFB9uLEAEEYEFMLDQAgAUHU4sQAQSAQUwsOACABQdSgxABBCBDpAgsOACABQd7IwwBBDRDpAgsJACAAQQA2AgALTQEBfyMAQTBrIgEkACABQQE2AgwgAUHws8QANgIIIAFCATcCFCABIAFBL2qtQoCAgIDQFYQ3AyAgASABQSBqNgIQIAFBCGogABC/AgALUAEBfyMAQTBrIgAkACAAQQE2AgwgAEHws8QANgIIIABCATcCFCAAIABBL2qtQoCAgIDgFYQ3AyAgACAAQSBqNgIQIABBCGpB5J/AABC/AgALCAAgACUBEAILFQIBbwF/EBwhABCPASIBIAAmASABCwIACwur3wRAAEGAgMAAC4MfL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2FsbG9jL3NyYy9jb2xsZWN0aW9ucy9idHJlZS9tYXAvZW50cnkucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9iYXNlNjQtMC4yMi4xL3NyYy9lbmdpbmUvZ2VuZXJhbF9wdXJwb3NlL2RlY29kZV9zdWZmaXgucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9jdXJ2ZTI1NTE5LWRhbGVrLTQuMS4zL3NyYy93aW5kb3cucnMAbGlicmFyeS9jb3JlL3NyYy9udW0vZmx0MmRlYy9zdHJhdGVneS9ncmlzdS5ycwBsaWJyYXJ5L2FsbG9jL3NyYy9mbXQucnMAbGlicmFyeS9jb3JlL3NyYy9udW0vZGl5X2Zsb2F0LnJzAGNvanNvbi1jb3JlL3NyYy9jb3JlL2tleXMucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9yYW5kX2NvcmUtMC42LjQvc3JjL29zLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvY3VydmUyNTUxOS1kYWxlay00LjEuMy9zcmMvZWR3YXJkcy5ycwAvVXNlcnMvYW50b25pby5tdXNvbGluby8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvc3RkL3NyYy9zeXMvdGhyZWFkX2xvY2FsL25vX3RocmVhZHMucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9zZXJkZV9qc29uLTEuMC4xNDIvc3JjL2Vycm9yLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2Yvc2VyZGVfanNvbi0xLjAuMTQyL3NyYy9zZXIucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9zaWduYXR1cmUtMi4yLjAvc3JjL3NpZ25lci5ycwAvVXNlcnMvYW50b25pby5tdXNvbGluby8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL2N1cnZlMjU1MTktZGFsZWstNC4xLjMvc3JjL3NjYWxhci5ycwAvVXNlcnMvYW50b25pby5tdXNvbGluby8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvY29yZS9zcmMvc3RyL3BhdHRlcm4ucnMAbGlicmFyeS9jb3JlL3NyYy9udW0vZmx0MmRlYy9zdHJhdGVneS9kcmFnb24ucnMAbGlicmFyeS9jb3JlL3NyYy9udW0vYmlnbnVtLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvY2lwaGVyLTAuNC40L3NyYy9zdHJlYW0ucnMAY29qc29uLWNvcmUvc3JjL2NvcmUvc2Vzc2lvbl9sb2cucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2FsbG9jL3NyYy9zdHJpbmcucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2FsbG9jL3NyYy9jb2xsZWN0aW9ucy9idHJlZS9uYXZpZ2F0ZS5ycwBsaWJyYXJ5L2NvcmUvc3JjL3VuaWNvZGUvcHJpbnRhYmxlLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vL1dvcmtzcGFjZS9naXRodWIvamF6ei9jcmF0ZXMvY29qc29uLWNvcmUvc3JjL2NvcmUvY2FjaGUucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2FsbG9jL3NyYy9jb2xsZWN0aW9ucy9idHJlZS9ub2RlLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvYnM1OC0wLjUuMS9zcmMvZW5jb2RlLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvYmFzZTY0LTAuMjIuMS9zcmMvZW5jb2RlLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvYmFzZTY0LTAuMjIuMS9zcmMvZW5naW5lL2dlbmVyYWxfcHVycG9zZS9kZWNvZGUucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9iczU4LTAuNS4xL3NyYy9kZWNvZGUucnMAY29qc29uLWNvcmUvc3JjL2NvcmUvbm9uY2UucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9oYXNoYnJvd24tMC4xNS41L3NyYy9yYXcvbW9kLnJzAGxpYnJhcnkvY29yZS9zcmMvZm10L21vZC5ycwAvVXNlcnMvYW50b25pby5tdXNvbGluby8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL2Jhc2U2NC0wLjIyLjEvc3JjL2VuZ2luZS9nZW5lcmFsX3B1cnBvc2UvbW9kLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvYmFzZTY0LTAuMjIuMS9zcmMvZW5naW5lL21vZC5ycwBsaWJyYXJ5L2FsbG9jL3NyYy9yYXdfdmVjL21vZC5ycwBsaWJyYXJ5L2NvcmUvc3JjL251bS9mbHQyZGVjL21vZC5ycwAvVXNlcnMvYW50b25pby5tdXNvbGluby8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL3NlcmRlX2pzb24tMS4wLjE0Mi9zcmMvcmVhZC5ycwAvcnVzdC9kZXBzL2RsbWFsbG9jLTAuMi4xMC9zcmMvZGxtYWxsb2MucnMAbGlicmFyeS9zdGQvc3JjL2FsbG9jLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvYXJyYXl2ZWMtMC43LjYvc3JjL2FycmF5dmVjLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvZm9sZGhhc2gtMC4xLjUvc3JjL2xpYi5ycwAvVXNlcnMvYW50b25pby5tdXNvbGluby8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL29uY2VfY2VsbC0xLjIxLjMvc3JjL2xpYi5ycwAvVXNlcnMvYW50b25pby5tdXNvbGluby8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL2JsYWtlMy0xLjguMi9zcmMvbGliLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvbHJ1LTAuMTYuMS9zcmMvbGliLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvY3J5cHRvX3NlY3JldGJveC0wLjEuMS9zcmMvbGliLnJzAAAAAF8OEABiAAAAlAEAADYAAABIYXNoIHRhYmxlIGNhcGFjaXR5IG92ZXJmbG93RA8QABwAAABWChAAbAAAACUAAAAoAAAA//////////94DxAAQZCfwAALiQJ9RXhwZWN0ZWQgcHJpdmF0ZSB0cmFuc2FjdGlvbnNpZ25hdHVyZWVuY3J5cHRlZF9jaGFuZ2VzbWV0YUpzVmFsdWUgRXJyb3I6IAAAyw8QAA8AAACoBxAAUgAAAAgAAAARAAAAYXR0ZW1wdGVkIHRvIHRha2Ugb3duZXJzaGlwIG9mIFJ1c3QgdmFsdWUgd2hpbGUgaXQgd2FzIGJvcnJvd2VkSW52YWxpZCBzaWduYXR1cmUgbGVuZ3RoSW52YWxpZCBzaWduaW5nIGtleSBsZW5ndGhJbnZhbGlkIHZlcmlmeWluZyBrZXkgbGVuZ3RoAAAAAgAAAAwAAAAEAAAAAwAAAAQAAAAFAEGkocAAC/EDAQAAAAYAAABhIERpc3BsYXkgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3IgdW5leHBlY3RlZGx5AH4GEAB3AAAASwsAAA4AAABFcnJvckludmFsaWQgVVRGLTggaW4gc2VjcmV0OiAAAPkQEAAZAAAASW52YWxpZCBVVEYtOCBpbiBzaWduYXR1cmU6IBwREAAcAAAASW52YWxpZCBVVEYtOCBpbiBpZDogAAAAQBEQABUAAAAAAAAABAAAAAQAAAAIAAAAAAAAAAQAAAAEAAAACQAAAFV0ZjhFcnJvcnZhbGlkX3VwX3RvZXJyb3JfbGVuYXR0ZW1wdGVkIHRvIHRha2Ugb3duZXJzaGlwIG9mIFJ1c3QgdmFsdWUgd2hpbGUgaXQgd2FzIGJvcnJvd2VkZ+YJaoWuZ7ty8248OvVPpX9SDlGMaAWbq9mDHxnN4Fu+DBAAawAAAHsEAAAPAAAAAAAAAAQAAAAEAAAACgAAAE5vbmVTb21laW50ZXJuYWwgZXJyb3I6IGVudGVyZWQgdW5yZWFjaGFibGUgY29kZd8DEABqAAAAgQIAACoAAABJbnZhbGlkIFVURi04IGluIHNlY3JldDogAAAAXBIQABkAAAAMAAAADAAAAAQAAAANAAAADgAAAAUAQaClwAAL/wMBAAAADwAAAGEgRGlzcGxheSBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvciB1bmV4cGVjdGVkbHkAfgYQAHcAAABLCwAADgAAAEVycm9yAAAAAAAAAAQAAAAEAAAAEAAAAAAAAAAEAAAABAAAAAkAAABVdGY4RXJyb3J2YWxpZF91cF90b2Vycm9yX2xlblZlcmlmeWluZ0tleX0BAAFBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1f////////////////////////////////////////////////////////////Pv//NDU2Nzg5Ojs8Pf////////8AAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGf////8//xobHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIz/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////2VuY3J5cHRlZF9VhRQQAAsAAABwcml2YXRlAEGoqcAAC50JAQAAABIAAABjYWxsZWQgYFJlc3VsdDo6dW53cmFwKClgIG9uIGFuIGBFcnJgIHZhbHVlAPIFEABnAAAAeAAAACcAAAD/////////////////////////////////////////////////////////////////AAECAwQFBgcI/////////wkKCwwNDg8Q/xESExQV/xYXGBkaGxwdHh8g////////ISIjJCUmJygpKiv/LC0uLzAxMjM0NTY3ODn//////zEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXoiaGFzaF96IgAAphUQAAcAAACtFRAAAQAAABMAAAAEAAAABAAAABQAAABaBhAAIwAAANEAAAA2AAAAWgYQACMAAADAAQAAOAAAAFoGEAAjAAAAlQEAADQAAABn5glqha5nu3Lzbjw69U+lf1IOUYxoBZur2YMfGc3gWxUAAAAIAAAABAAAABYAAABJbnZhbGlkIHB1YmxpYyBrZXkAAFoGEAAjAAAAagAAABIAAAAXAAAAFAAAAAQAAAAYAAAAWgYQACMAAABnAAAAGgAAAFByaXZhdGVUcmFuc2FjdGlvbmVuY3J5cHRlZENoYW5nZXNrZXlVc2VkbWFkZUF0bWV0YXByaXZhY3kAAIYWEAAQAAAAlhYQAAcAAACdFhAABgAAAKMWEAAEAAAApxYQAAcAAABUcnVzdGluZ1RyYW5zYWN0aW9uY2hhbmdlcwAA6xYQAAcAAACdFhAABgAAAKMWEAAEAAAApxYQAAcAAABkYXRhIGRpZCBub3QgbWF0Y2ggYW55IHZhcmlhbnQgb2YgdW50YWdnZWQgZW51bSBUcmFuc2FjdGlvbnN0cnVjdCBQcml2YXRl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C7UBAQAAADEAAABhIERpc3BsYXkgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3IgdW5leHBlY3RlZGx5AH4GEAB3AAAASwsAAA4AAABFcnJvcgAAAN0HEAAdAAAAGQAAADEAAADdBxAAHQAAACcAAAA4AAAAgwgQAGUAAADRAQAAEAAAAIMIEABlAAAA0AEAABsAAACDCBAAZQAAAMwBAAAJAAAAgwgQAGUAAAC5AQAAIABBwL7AAAv1BAEAAAAyAAAAY2FsbGVkIGBSZXN1bHQ6OnVud3JhcCgpYCBvbiBhbiBgRXJyYCB2YWx1ZQCDCBAAZQAAAD0BAAAgAAAAQnVmZmVyVG9vU21hbGwAADMAAAAIAAAABAAAABYAAABzaWduYXR1cmUgb3BlcmF0aW9uIGZhaWxlZAAASgQQAGoAAAAQAAAAHAAAAHVzaXplIG92ZXJmbG93IHdoZW4gY2FsY3VsYXRpbmcgYjY0IGxlbmd0aAAA6QgQAGgAAABXAAAACgAAAOkIEABoAAAAUAAAADMAAABIYXNoIHRhYmxlIGNhcGFjaXR5IG92ZXJmbG93HCAQABwAAABWChAAbAAAACUAAAAoAAAAc2VhbGVyU2VjcmV0X3pzZWFsZXIgc2VjcmV0/////////////////////////////////////////////////////////////////wABAgMEBQYHCP////////8JCgsMDQ4PEP8REhMUFf8WFxgZGhscHR4fIP///////yEiIyQlJicoKSor/ywtLi8wMTIzNDU2Nzg5//////8xMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6c2VhbGVyX3oAAAAlIRAACAAAAGtleVNlY3JldF96a2V5IHNlY3JldHNpZ25lclNlY3JldF96c2lnbmVyIHNlY3JldHNpZ25lcl96aCEQAAgAAABzaWduYXR1cmVfegB4IRAACwAAAHNpZ25hdHVyZXNpZ25lciBJRAAANQAAAAwAAAAEAAAANgAAADcAAAAwAEHAw8AAC9kDAQAAADgAAABhIERpc3BsYXkgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3IgdW5leHBlY3RlZGx5AH4GEAB3AAAASwsAAA4AAABFcnJvcgAAADUAAAAMAAAABAAAADkAAAAAAAAABAAAAAQAAAA6AAAARnJvbVV0ZjhFcnJvcmJ5dGVzZXJyb3IAOwAAABQAAAAEAAAAPAAAAGNhbGxlZCBgUmVzdWx0Ojp1bndyYXAoKWAgb24gYW4gYEVycmAgdmFsdWUAgwgQAGUAAACTAAAAKwAAAHNlYWxlclNlY3JldF96c2VhbGVyIHNlY3JldP////////////////////////////////////////////////////////////////8AAQIDBAUGBwj/////////CQoLDA0ODxD/ERITFBX/FhcYGRobHB0eHyD///////8hIiMkJSYnKCkqK/8sLS4vMDEyMzQ1Njc4Of//////MTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5enNlYWxlcl96c2VhbGVyIElEAAA9AAAADAAAAAQAAAA+AAAAPwAAADAAQaTHwAAL4Q8BAAAAQAAAAGEgRGlzcGxheSBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvciB1bmV4cGVjdGVkbHkAfgYQAHcAAABLCwAADgAAAEVycm9yAAAAAAAAAAQAAAAEAAAAQQAAAAAAAAAEAAAABAAAAEIAAABJbnZhbGlkQnl0ZQAAAAAABAAAAAQAAAAfAAAASW52YWxpZExlbmd0aEludmFsaWRMYXN0U3ltYm9sSW52YWxpZFBhZGRpbmf/////////////////////////////////////////////////////////////////AAECAwQFBgcI/////////wkKCwwNDg8Q/xESExQV/xYXGBkaGxwdHh8g////////ISIjJCUmJygpKiv/LC0uLzAxMjM0NTY3ODn//////zEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpzaWduYXR1cmVfegAAAB4lEAALAAAAbWlzc2luZyBmaWVsZCBgYDQlEAAPAAAAQyUQAAEAAABpbnZhbGlkIGxlbmd0aCAsIGV4cGVjdGVkIAAAVCUQAA8AAABjJRAACwAAAGR1cGxpY2F0ZSBm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cmU6IFZ4V29ya3MgUk5HIG1vZHVsZSBpcyBub3QgaW5pdGlhbGl6ZWROb2RlLmpzIGNyeXB0byBDb21tb25KUyBtb2R1bGUgaXMgdW5hdmFpbGFibGVDYWxsaW5nIE5vZGUuanMgQVBJIGNyeXB0by5yYW5kb21GaWxsU3luYyBmYWlsZWROb2RlLmpzIEVTIG1vZHVsZXMgYXJlIG5vdCBkaXJlY3RseSBzdXBwb3J0ZWQsIHNlZSBodHRwczovL2RvY3MucnMvZ2V0cmFuZG9tI25vZGVqcy1lcy1tb2R1bGUtc3VwcG9ydAAAAAAAAAQAAAAEAAAAZwAAAGludGVybmFsX2NvZGUAAAAAAAAACAAAAAQAAABoAAAAZGVzY3JpcHRpb251bmtub3duX2NvZGUAAAAAAAQAAAAEAAAAaQAAAG9zX2Vycm9yVW5rbm93biBFcnJvcjogAMDMEAAPAAAAT1MgRXJyb3I6IAAA2MwQAAoAAABjcnlwdG8AABHKEAA4yhAAXsoQAHLKEACkyhAA0coQAADLEAAhyxAAPssQAEGgmsMACzFryxAAnMsQAMnLEAD5yxAAJwAAACYAAAAUAAAAMgAAAC0AAAAvAAAAIQAAAB0AAAAtAEHcmsMAC70GMQAAAC0AAAAwAAAAZQAAAKwxEQC4MREAxDERANAxEQByZXR1cm4gdGhpc0xhenkgaW5zdGFuY2UgaGFzIHByZXZpb3VzbHkgYmVlbiBwb2lzb25lZAAAAIfNEAAqAAAAkQ0QAGgAAAAIAwAAGQAAAHJlZW50cmFudCBpbml0AADMzRAADgAAAJENEABoAAAAegIAAA0AAABjbG9zdXJlIGludm9rZWQgcmVjdXJzaXZlbHkgb3IgYWZ0ZXIgYmVpbmcgZHJvcHBlZG51bGwgcG9pbnRlciBwYXNzZWQgdG8gcnVzdHJlY3Vyc2l2ZSB1c2Ugb2YgYW4gb2JqZWN0IGRldGVjdGVkIHdoaWNoIHdvdWxkIGxlYWQgdG8gdW5zYWZlIGFsaWFzaW5nIGluIHJ1c3RMYXp5IGluc3RhbmNlIGhhcyBwcmV2aW91c2x5IGJlZW4gcG9pc29uZWQAAJDOEAAqAAAAkQ0QAGgAAAAIAwAAGQAAAHJlZW50cmFudCBpbml0AADUzhAADgAAAJENEABoAAAAegIAAA0A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ZiByYW5nZWludmFsaWQgdW5pY29kZSBjb2RlIHBvaW50Y29udHJvbCBjaGFyYWN0ZXIgKFx1MDAwMC1cdTAwMUYpIGZvdW5kIHdoaWxlIHBhcnNpbmcgYSBzdHJpbmdrZXkgbXVzdCBiZSBhIHN0cmluZ2ludmFsaWQgdmFsdWU6IGV4cGVjdGVkIGtleSB0byBiZSBhIG51bWJlciBpbiBxdW90ZXNmbG9hdCBrZXkgbXVzdCBiZSBmaW5pdGUgKGdvdCBOYU4gb3IgKy8taW5mKWxvbmUgbGVhZGluZyBzdXJyb2dhdGUgaW4gaGV4IGVzY2FwZXRyYWlsaW5nIGNvbW1hdHJhaWxpbmcgY2hhcmFjdGVyc3VuZXhwZWN0ZWQgZW5kIG9mIGhleCBlc2NhcGVyZWN1cnNpb24gbGltaXQgZXhjZWVkZWQBAAAAAAAAAEjaEAAJAAAAdNoQAAgAAABmbG9hdGluZyBwb2ludCBgYAAAAHTeEAAQAAAAhN4QAAEAAABudWxsJwUQAHsAAAC9BAAAJAAAAIgAAAAMAAAABAAAAIkAAACKAAAAhgAAAP///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////wAAAQACAAMABAAFAAYABwAIAAkA//////////////////8KAAsADAANAA4ADwD/////////////////////////////////////////////////////////////////////CgALAAwADQAOAA8A////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////AAAQACAAMABAAFAAYABwAIAAkAD//////////////////6AAsADAANAA4ADwAP////////////////////////////////////////////////////////////////////+gALAAwADQAOAA8AD///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8ODBAAawAAALMBAAAaAAAADgwQAGsAAAAAAgAAEwAAAA4MEABrAAAABQIAADMAAAAODBAAawAAAAkCAAA+AAAADgwQAGsAAAAPAgAAOgAAAA4MEABrAAAAqwEAAD0AAAAODBAAawAAAKYBAABFAAAADgwQAGsAAABuAgAAGQAAAGluZi1pbmZOYU51dXV1dXV1dWJ0bnVmcnV1dXV1dXV1dXV1dXV1dXV1dQAAIgBBqsfDAAsBXABBzsjDAAvlATAxMjM0NTY3ODlhYmNkZWZhIEpTT04gbnVtYmVyMDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTkAQcfKwwALARAAQdfKwwALARQAQefKwwALARkAQfbKwwALAkAfAEGGy8MACwKIEwBBlsvDAAsCahgAQaXLwwALA4CEHgBBtcvDAAsD0BITAEHFy8MACwOE1xcAQdXLwwALA2XNHQBB5MvDAAsEIF+gEgBB9MvDAAsE6HZIFwBBhMzDAAsEopQaHQBBk8zDAAsFQOWcMBIAQaPMwwALBZAexLwWAEGzzMMACwU0JvVrHABBwszDAAsGgOA3ecMRAEHSzMMACwag2IVXNBYAQeLMwwALBshOZ23BGwBB8szDAAsGPZFg5FgRAEGBzcMACwdAjLV4Ha8VAEGRzcMACwdQ7+LW5BobAEGhzcMAC/glktVNBs/wEAAAAAAAAAAAgPZK4ccCLRUAAAAAAAAAACC0ndl5Q3gaAAAAAAAAAACUkAIoLCqLEAAAAAAAAAAAuTQDMrf0rRQAAAAAAAAAQOcBhP7kcdkZAAAAAAAAAIgwgRIfL+cnEAAAAAAAAACqfCHX5vrgMRQAAAAAAACA1NvpjKA5WT4ZAAAAAAAAoMlSJLAIiO+NHwAAAAAAAAS+sxZuBbW1uBMAAAAAAACFrWCcyUYi46YYAAAAAABA5th4A3zY6pvQHgAAAAAA6I+HK4JNx3JhQhMAAAAAAOJzabbiIHnP+RIYAAAAAIDa0ANkG2lXQ7gXHgAAAACQiGKCHrGhFirTzhIAAAAAtCr7ImYdSpz0h4IXAAAAAGH1uau/pFzD8SljHQAAAKBcOVTL9+YZGjf6XRIAAADIs0cpvrVgoODEePUWAAAAuqCZsy3jeMgY9tayHAAAQHQEQJD8jUt9z1nG7xEAAFCRBVC0e3GeXEPwt2sWAACk9QZkodoNxjNU7KUGHACAhlmE3qSoyFugtLMnhBEAIOhvJRbO0rpyyKGgMeUVACjiy66bgYdpjzrKCH5eGwBZbT9NAbH0oZlkfsUOGxFAr0iPoEHdcQrA/d120mEVENsaswiSVA4NMH2VFEe6GurI8G9F2/QoCD5u3WxstBAk++zLFhIyM4rNyRSIh+EU7TnofpyW/r/sQPwZaukZGjQkUc8hHv/3k6g9UOIxUBBBbSVDquX+9bgSTeRaPmQUksju0xSffjNnV2Cd8U19GbZ66gjaRl4AQW24BG6h3B+yjJJFSOw6oEhE88Lk5OkT3i/3VlqnSchaFbDzHV7kGNb7tOwwEVx6sRqccKV1HR9lHfGTvop57K6QYWaHaXITv2TtOG7tl6fa9Pk/6QNPGO+9KMfJ6H1REXL4j+PEYh61dnkcfrHu0kpH+zkOu/0SYtSXo91dqocdGXrI0Sm9F3vJfQxV9ZTpZJ+YOkZ0rB3tnc4nVRn9EZ9jn+SryIsSaEXCcapffNaGPMfd1rouF8LWMg6VdxuMqAs5lYxp+hw5xt8ovSqRV0mnQ933gRwSyLcXc2x1da0bkZTUdaKjFrql3Y/H0tKYYrW5SROLTByUh+q5vMODn10RFA7s1q8ReSll6Ku0ZAe1FZkRp8wbFtdzfuLW4T1JIlv/1dC/ohtmCI9NJq3GbfWYv4Xit0URgMry4G9YOMkyfy8n2yWXFSB9L9mLboZ7/1778FHv/Bo0rr1nFwU0rV8bnTaTFd4QwRmtQV0GgZg3YkQE+JoVFTJgGJL0R6F+xXpVBbYBWxofPE/b+Mwkb7tsVcMR4XgQJwsjEjcA7krqxyo0VhmXFPDNq9ZEgKnd5Hk1wavfvBm2YCsGK/CJCi9swVjLCxYQ5Di2xzVsLM06x/Euvo4bFB3HozlDh3eACTmuum1yIhnkuAwIFGmV4EvHWSkJD2sfjvMHhaxhXWyPHNi5ZemiE3LwSaYXunRHsyNOKL+jixiPbNyPnehRGaCsYfKujK4e2cPpeWIx0w/kC31X7RctE880ZBi7/ccT3U5crehd+BcDQn3eKf25WJRis9hidfYdQkkOKzo+dLecHXDHXQm6EpLb0bXITVHlAyVMObWLaBd3UkbjOqGl3kQun4eirkIdivMLzsSEJwvrfMOUJa1JEm3wjgH2ZfHNJVz0+W4Y3BaIrPKBc79tQS9zcbiKHpMc1as3MaiX5Ij950azFvPbEcqWhT2SvR3r/KEYYNzvUhZ9/ObM9izlJXzKHnjTq+cbzl0QQBo8r5eNPhMrZMtwEUJ1FNAgC5v9MA7YNT3+zBWSkhkE6c0BPb0RToPMPUAbm/uPorEgIUYWyxDSnyYIEYL6MwveaKnX2/2UxkcwShUj+QCOFcOTzVI9OrhZvJwatpvAeO1ZfMBTZiQTuPWhEKPC8NZocJuw6H/tFyZzyhRM86wMg0zC3OLf6J3vD/0ZDxjs59Fv+cnti7HC9Sk+EBMe52HGy3c86e5dM3O0TRSY5WD6t76Vi6NqNQCQIWEZ/h75+GUue25MxUIA9Gm5H1+zm7v//AzFT7spgDji0xM3oIKqPzxQtiMqNKDG2sgYREgjlU9L5KOsNEFIeBH7HisNNr0Rr27m68AoLevqXBN1kIMs1loK4CbxcvilJTQYk3Skt4vxDJhwrY92Dy9BHtzIxlL3FghfZswZqmm96BITe3gntRzK9n8/oBTE7KIX15lWceKjfPRfT8gZ9aeLHSYg1oZt5s34mzEdMPlIdxIwqIvoCGAB9wJ+JHw3GxUXPJKuIgu4wbSDnS1bBWLaHGUbrfUGE/lQcoL8WEN9CBI/YhizyFc35Q6jOy+UnIoWz3re37othZ7Siwo7uUMtHMEM68uUPBOjY5fmxFNKnBHxz+X+uQvYizw9ILboXAMW7kOffqgOzq6LTKjjIjSEG3WKI08pyUBN1y9JzpWgMhESbeyic/uQIM1720G7SH8VVoini1A6tWjAWlIS6hrfGja1SFdyRHFBuHhzS9JwyxCD4hrtjpXNUeZWUN4GTf4UJJthqPL6QOafbOSVSOA9GvcAPanXnOjv48OuXS2sZhA0QYyTDcTi69x0GrU4V4AUgVFv+BB12yYUEmHiBm2gGfGSRZsqKUmYTKt8TSREBBCt9xZCdXNbvh/W22AtVQUUmLWcklJQ8q2nyxK5eKoGGf/iQzdn5G6ZkX5X5xZVSB/fbYqCwE7l/xqvllAuNY0TVwkto3Ci3r/hWrzkeYJwGK1L+MsMS9YvmnHrXRijjB5ML3v/5+7lXQAnszrv5RcTH/tZ/6FqX3XA8F8Ja9/dF+d5MH9KRbeS8Oy3y0VX1R0wTH6PTouyWxb0Up+LVqUSPN9dMyIun/IbsSeHLqxOFwtXNcCq+UbvYp3xKDpXIh1nViG4ClyM1V0Cl1mEdjUSAawpZg1z70r1wvxvJdTCFgEXtL/QT6udsvP7yy6JcxxgjtB34hGLok94fT+9NcgR+bHEFVvWLYtj1lyPLEM6FnfeNdvxS/lt/As0s/fTyBsKqwEpd8+7xH2HANB6hF0RzRVC81TD6jVdqQCEmeW0FUCbEjAqdGWDtNMA5f8eIhsIoQtemmgf0lCEIO9fU/UQSomO9cBCpwZlpejqN6gyFZ0r8jJxE1FIvs6i5UVSfxpCW9e/Jqwy7TbBha9rk48QEjLNbzBXf6iEMWebRnizFJd+wIv8LJ/S5f1AQlhW4BkeT1jXHXyjo6+eaCn3NSwQ5mIuTSVbjIxbxsLzdEM3FJ/7eaDuca9v8nezMFIURRmHephIak6bC+9V4LxmWZYflExfbQIRQWe1NQw24Pe9E7oftwhDVRHBIkOPQ9h1rRio5+TKk6pVcesTc1RO09geyRDPXpyK1SZz7Mf0EIRHE/vUgnZD7Yrwj+f5MRVlGRg6iiNUlKit7HNheH5avh8eZDaWtFyJ7HPoPAuP+NbTEv3Du+Gzq+eQIgzOsrbMiBf9tCraoJYhNSuPgV/k/2odHrFaiCT+NAF7+bC77t9iEmVdcaqtPYLB2TedauqX+xa/tA0VGc3iMdCFRAXlfboc95AorS/ALR+i00ojr470ETW1cpg7MPmmiogd7FqycRaCYo9+Sny3UK3qJKfxHg4ckZ0Zj66tclKsEncIV9OIEfYE4DIaWQ9nV9eUyiwI6xUzBpi/YC/TQC0NOv03ymUb4AO/d5z9g0g8SET+Yp4fEdjErpUD/aRaS1rVvfuFZxUOdhp7RDxOMd6wSq16Z8EayYnwzKrl0N6Krk6srOC4EDusLIAVH4WWLVpi19cY5xRK1zfg2mYm/LjwOs0N3yAajuYizEgAmJ1z1kSgaItUEDKgK/9aAP6EEAxWyEKuaRQ+iPa+cYA9phSPa3rTGYQZTiq0Lo7gzM/ZcgZZSCDlH3CaMN1YDOAhyAekNy007xMNwXwUbw9YKroJjYU4AesYUPGb2UoT7rQoTPCmhsElH9J2AcgOzBRxmS9WKPSYdxOG1AF6Ev9ZzX+7azIxf1UYqEmCGNd+sMBfqgZ//d5qHgluUW9GT27Yeypkb17LAhOLySULGOOJzho1PQs2fsMX7jvvDd5bLIJhggyOw120HXWFtchquVvxfNHHOJq6kBLS5uJ6xaeyLdzF+cZA6TQXhqCb2bZRHzlTN7j4kCMCHVREAUgSk7MDlCJzmzpWIRJplQHa1negBDnrT0LJq6kWw/qBkMyVyEUH5uOSuxZUHLo8UdqfXZ2LxG/OOzWOtBHoi+XQB7WErrULworCsSEW4+4exUniJRqjjnItMx6qG01VMxturVfwJZln/N9SShGhKgCiyZhtbG9/gfuX55wVSTWACvz+iEdL32H6fSEEG04hkIZdn7UMjyt9vO6U4hChKTToNAfjz3J2nGsqOhsVCjRBIgLJ24MPlIMGtQhiGobAaFWhXWmyiTwSJHFFfRCn8MKqCbUDH6zLFm3NlpwU0axzFUyixCaXflzIgLzDGQNMaI1v5Tp4Hs85fdBVGhADX8Jwy55JFuZCiJxE6yAUxPbyTH4G3JufU6rDFSYpGXa0L+AdCNOCh+iUNJtvcx/J0B2sEuXDsVQR3QDBJagT/EQlV1feNN6pVRRBMS+SGDuW7iztFcJVFGtZkf26th7lHRU8tE2Ztezi13reNDITXmUaSyGh/+Kn240ZFsL+F7b+4J1pib/bkVLxn5ty/h0xn6wC4rVXKZvT9kOhB78S/sZXg1qjrfOBiPSUicluF724LSQxDJlwoqox+ut7Sh12k5y2nqdfhqUKX3xzjU4SVLhDZIaR9+dOzXZb0DDiFmmmVP3ndfWhooBUcgS9mhwB6FT+sGk5pWXQdMcituARAiLqPR3Ehw5/BFJ5q+NYFoKqZI0ktSnSnoWmV5Yc7xuR6l7YNhFaQ4MTyPbdcXURNqV2joSVMBRkGHp0Vc7SFYNOFLLlujwZfZ6Y0eqBRxsSsUyPz/TFLw5j/8IysQwRVt0fcwNyt7vRO79zf91PFazU50+ETqUqxgqvUN/Uoxrr5PCxElGn2rtmbZILZaYQJh5tXlclUdFqwAh3Tv7PFLBlCDatbqWFhfDKFOL9AxqOP8VBLGWHc1PW/kytfkIQcY82Unc+aVDoiz6gWB5TFE4zxCYVjoNk4i5OyO7lZxkiQHVwmnGk/Zq6YXpq38EfFUhJhgDHht6gFH2MoivZExqa26fAeCgWyVmcL4t2zxihgNLR8JayWztwg/stVAMfZJAjg1aeTxklJjK9nBRiE3507CPshaNfrq9+7MOZOhidkecsZ2eM95lbnuc0QEkeArsQfKDAtzpA+cIQIcjtEsPpFJvIsGVJkLfzVCk6qRczJNrB+hy/W3SlMKqziJMdoFYouRxyV7loZ15KcDV8EkhscuejTq3nQgH2XMxCGxdaB0/hTKKYoZOBM3R/E+IcmGTRDHBl/0T8MKCoL0wNEr69BRDMPj9WOz3IkjufkBYuLQcUfw7PK4pMencKxzQcPXyEbA9pYVvWb6yKZvygEUybpUdTwznyy4tXLYA7CRYfAo8ZKDTI7r5urThgiosbU2H5D5kgPVU3ZWwjfDY3Eai591O/aIwqhX5HLBsEhRUSqPUo74IvdSZeWfchReYaC4mZedWxPQnY2pc6NevPEE7r/9dKHo0LjtE9iQLmAxUi5v+N3WVwjvFFjSuD30Qa1e+/eKo/Bvm2Szj7sQtrEMrr7xaVz0e3pF4Gep7OhRS95qtcesMZ5U32hxhGQqcZNnDreSwaMK/w+VTPa4kIEENMZpi3IPzabDgqw8arChRU339+5Si7EYjG9HO4Vg0ZKtcf3h7zKRYq+PGQZqxQH3rm00rzN9pNGjuXGsBrkhMZ4Igd8MVQ4eAJPSGwBncYHxjrJGz3pBlZTIwpXMiUHhPvEpejGgewt6/3mTn9HBPYqtd8TOEInKWbdQCIPOQXjpUNnJ8ZCwOPApMAqkvdHXl9iMED8OZhmeFbQEpPqhLXnOqxBKxguv/ZctAc41QXDURl3gXX+Kh/kI8E5BsqHYhK/6pjhpvJT7rZgm5ROhIqHb+V/GcCvOMokCPK5cgWdOQuu/sBA6scM3SsPB97HMlO/VQ94eHq8Z/I64XzzBF7ojyqjFmaZe7HumZnMEAWGsvL1O/vAP/peWlAgTzQG/Be/+T1lWA/MuxByNAlYhGsNj9ec7s4zz5nUvpEr7oVVwTPNVDqBoMOAec4FlspG7ZioSFyUuQRqWCQ4+3Y+RBkuwmqDmddVtN4dFwpTzgVPSqMVNLA9CsIl5Gz82KGGmaa13SD+HgbZf46UNj9kxAAgQ1SpDZXYv69SWRO/bgUQOGQZk0E7fp9LVz9oTznGciMGmCwItS8bpxZPuWFMBD6LyF4XCsJbIoD8I1epzwU+HspljN2CwdtBGwxNtFLGfbas3vAU85IiAXHvYPFnh/aaFBNWPSALXVjnFZyO8MTEIOkYG4x4XhSfEPsTgq0GAEAQafzwwALijkgmpmZmZmZmZmZmZmZmZmZGRWuR+F6FK5H4XoUrkfhehTeJAaBlUOLbOf7qfHSTWIQltQJaCJseHqlLEMc6+I2GqtDboYb8PlhhPBo44i1+BQiNlg4SfPHtDaN7bWg98YQaiONwA5SpodXSK+8mvLXGohP12alQbif3zmMMOKOeRUHphIfUQEt5rKU1iboCy4RpAlRy4Forta3ur3X2d98G+o6p6I07fHeX5VkeeF//RW7yIXo9vAnfxkR6i2BmZcR+A3WQL60DGXCgXZJaMIlHJNx3jOYkHDqAZsroYabhBZDwX4p4KbzIZsVVueerwMSNzUxD83XhWkrvInYl7LSHPmQWj/X3zchiZbURkb1Dhf6c0jMReZf56CrQ9LRXXISXYYNejw9ZqU0rNK2T8mDHbGe15Rjlx5RXSNCkgyhnBfBS3ndgt9+2n1Pmw4KtOMSaKxbYtGYZCqW5V4XECA5HlPw4oGn4LbuRFGyEkCzLRipJk/OUk2SWGqnjqiZwlcTQaR+sLd7UCeq2H3a9dDyHjRQZcBfyaZSuxPLrsRAwhiQpuqZTNTrDskPPPI2ms4TgAoRw61TebFBGWBQvvawH2cIdAKL3C3BZ0ezpv5eWhlSoCk1b7AkNIafwuv+S0gU2xnukPJZHZCef2iJZdY5EF8psLQdw/tMlzKnqNUj9hmyulldsTWWPaxbH7p36cQUKGLhfSdeq5dWSUz7koedEA2daMnYyavy8A56+LellRo+F7o6eqG8W1pyLi2ThEQVy0X7Lsgayq+ujouKQp0DEUUJkrGm99yySuR4qp37OBsEoUHB65J99W6DLVWxL8cVA7RnZ4l1ZMRYnFd3JyZsEdLspdjbiG1t9MYl8gs94BvbI+tGFge+isM4Hiij/UwWSbZV0hFs/m6cYEtTTzHXEQ6K77ZPE5exYGdFhRiCixylob/4cg+sJxq5ajetAdYWHk6ZYMJyVrnhYFUsJM5EEpUWws0DHlf1Nc67E23jOh2rqwELAxisKivYL3aKT2IXVok0bwLgvLtVE/PEbgy1Eomo7bHQzMeS7x641Ep67h0HuleOQArT2/JLkxBv+/EXBsjfcQDVqHz1bw/aWPwnE9YMZukzu6f6u0yyKY5gph4R14SHKfxSlcmjjlQLGoUYDqzQ0rrJqKoHg9h2b66dE+OsGh5e3NrdpdHAV7KwYh9PikhLS7BIflFBmqyOwBsZ2aHT1dVZbcvazeFWpTMWFHuB3HcRe1c84tfnq+rCERAqz2BZgl7yxjYmpqyqBLYZu6WAR2gY9WvFUetWVZ2RFJaEAAbteSoj0aci3919dBBWBzSj4Y/d0YEM0TGW/FMaRWz26Bpz5Kc0Paf0RP0PFZ5W+FPiKB1TXZdSXWqX2RBiV425A9th6y7yUJUQv/Ua6EWkx89ITrxYW9rdpmWRFSBrg2zZ03FjreLhFx8eQRHNEZ+tKIYcn0gEA/NkY5sbC9sYvlNrsOUGnTWPHekVFqIVR8sPifPqa0qRcuQgqxE3vHF4TNu4REaqG4RtAUUcX2PBxtYVxwMFVUkDvpqdFhnpzWtF3jg2N3cHaf6uFxLBQRZGomPBVlhYcg6XsfIczmer0YEcAd95E/VxEo4oF6XsVUHOFjR/YdyQwQ7YhhJuR1Y1fSQgZQLH52jkjKQdJTl49zAdgOoBbLkgHde2F4T6LPnzsJm7NCNhTRes+BI590coU05cX1Q4aBXyrFoeLizTuXULfX9DYFNEW4pIGFgj3Mf31TCZzxmpNnw7bRMm0vlyjIm0jrKPDvH5KxUfuEEuj6MHKnIopgv0x7zdGPqavqVPObvBhh7WXAaX5BP29zAJGcJenNcw8PrWJNQf+F9aBxRo5Ul5jSYv34N2GWDm4QUQIFFuxwpSv+XPXhQahYHRDIDa8QVvDpmE2UsQ9dRoghQAxE/W5OP0oPUSGit37QGqmWnZEbcc97P32xS8xYoBiBTurXSSsMVc+a8QLAneaKbtfElU6oBvlCizGiTU5FO4V8o6EFWav3YgXBWDdh1DYHk7YnOqrv9egBYRnr3I0Wb1K524ELEyyzNXG39kbUFSxLx9YA30jqJc3xXMtopn22n9yuY9w9hOfX8R34p3csUPL6vXLwWO5C7/G4DVklsEc/KIrIxqPh2/ZRZmREJJ0Cj101Y9VZhK/+oRo6ADQk1BiLlXlbvzEDKrHOnmAmjXzTlheXf8wkBb7xZUUgIgeXFh5y35yWjNFVkShlCdmY61aKV8W3Z0FVZbHdKmSuE+kSBR/RXF9t1EfBcOH6Ia/0BNp8pEN5Kx0MkSSstp92TOrgsRblhQT7QPHjs87sVQ2Is8p/F5cz+QDBjJyfE32nkJyoX0x8IyQD0T20Lpv/bCqKlvugyet2bIHuObuswrz1MhJpVwfixSoBiCSZVwiXKpGrjdJmXwdLMTnXWIGg+EdfeMLz4I54eFHxdeoHtyNpFfCiaYBuyfNxnf5BmWW/hAGdWERgXwfywUTOpHq6/GAOEQNwXRjJkjEEfdP0VMpGfO5yTVtEeP0hkGscyd1ulS2B+33cOfcqgUOCcKS0Xu23kZLH5pGcKGEFnYqRGi418pj0YwD482cRp6E7ungRyzuqVr89jYXicVL6mV7JrjKGJRiY+t4EvsEBd17+D3OA6d6A5Mr5qsExt5Klkaky3YsFNy1iXiVqkVLlVHSA++eY3cwd63gUVUEXy7C9p+lo8VlJyXjM8IuhuXL9YU/xGmd3aw39ZybS4WeYzeQ/+nUfmR87J49b2+EY6t/dL+PxzCHOy3WiJjZBzYimRCMjOwARfwXxW1tbYWRqKDm47CWQGsWebdkMQrEqMDOV8XBPbOrMKj/BrUEh2DnC1MrGlecr2bHMpIQ0IXnOOK1olUGPX94hYIB2mbEsYFq70PVI3uL2vxDNh0xR0FayL+cnbXvowiwXBGKtEXBLxOyyjFEv/WTmeNa7sNE6D5fXh0O1HLJH7YexJffB5NYf75KckNCbcxrfxBf2MYCoHLlCHU16DFJyTKNMyCE3fOeFTPub9nbwxtQyGtNx/5cS3dpZTMH1lwis9NV/kYx/S9fVHd1n9686E/Pqz6EwvuL8noLr7/w7icMv159x/WJPOgIL8xZjb6FsL9x5IZeB1cGhrMJ7he+6sBy2x1FGDkfHuuCVOTGMm8Z6LwXRCZoJTFsELrHvR0lD9q5y8a4eZ2BCcCieVcKt0yiB/zFOfrK52FzqC3sO6wKKB/whDY399hb0oBWbRKTnQzzNAarUzm5yXVzeApoj6Qj9ZzFfHWUYZRd3FN7rTL2XJ4KRHoV+nW6L7oe7BUrI+EjXUbIBMh31MyuvxZ3YkMaqT3FYBC5xhDKMhjrkpucO7pkhFmatgnOA0NBhcRShoXQx4c6yGt7CykPWsSdG57Epx+FlZOV73wHP6I21xY/EHj/hEjSiVitJSWQV9hjWA2Bcsc6dQd6Cmqq2d/5z1N+NAIF4fdFyC7IVa5Mrlk1/lzbRKllYxmK2kjwurBOvLC7HsdHd7WHom6gs67NGJbAleWFxgY30sHYjWl/Pa04gGs3hJZ82R52JyIO5Txhzc2EzEe4fWDx0ZKbfzcWgbGkUInGBorAwafblcwF6+e0aebUhOQ3tE8y30lGiUYMRymkuoeQOWnMDz+HUi3eVrjhKi7GABRhsDJMUvTxceugp1TyRPNtKPNQukRUgmmF9HIhagfpJAcPgIh23QHuN9AOp5TGVANSssBtBX3BWAZZ/vkQhSnCggJmyne+DezelL8gzUQ190MqJFCMI5ZuCq3kznvGRNLCiAOAo0+4fnu+EJhvxQPPAiAPps9ZefHWPqbGpkQ5CwNAGT4yG6lDI6Q+ZCOGuojpJnp+dOLt6NxQGHaPhW7HFDhupSpPPmC9JkaFf8QK2Gzm8S6dceO0SDDXbsxG4kaKRZqlcTSCw7naLFiwRWhe7oRiHfQ228+H4cngmcRm5JdHEC/gCzmY5g+P9DYG0l15EkzzDO9UbZGZf8MRxbUXVBuj9aPyqdeBVHMcNIRU8mz40tXGUTZ/W5OreeDHKk69oIJeUcD4ZclpYrszxa6+8Ro1GBsz4B5hOpu8D8SKvkHDoc0euWa9dMQSxozHSKUOQtskC5R4ipD2ggVXBe1qcfVvKaL2oFVz+HTELAShw/ZIi5x35CcVeUCU4HmHWwMFE+LWkzaFt4dz6ia6xeKo6mlonujrnh+saUg4iITqQWpompf0n0nl7WimjaeHlTRIIKIf9uXH6z3ThWSfhh3p4DOBmZ8eUwjxtjddJgT8QsB5ApwLY+ta6MnllRaH1rWAFCiWSQMvu+1H3gQFRkVRZrZgRQdcP7y97L52RAUd2p7FJtDF8D+W8YoLnsNEPJDku3EBfLMyiwKDn0rrxnCnA6+0DdbCm+9oXHKIowUzuM+y3P5SAiMl7Qn1RtwELCfZHjsWw7arCVUDFX5TBrAf1Bg8K8+e723qdYQYQoVM2ZAgPO/y5WXLO7ecxrVEFJwzWZSZqzvWEewZLmQ7hrbWaS4DoUjJkds87b6posVSa62k9jQgh5sIylflYU8EXWwih/0Gp79rDio/u4IlBv3WdWyKa+xl72ThpglBxAWLHt39boljqyX3J4THmymERPFWCIrCX16vy3+uMl5PRx2aq1O76D9YcxXy2ChlJcWxe69C1ka/ucJEwnnTd0SEjqx/EVbXWOm3IQO2K/76hzIjTBrr0ochbDQPhPzYiIX1NcmvPJu49Am2st1wuiBEoaMpMbqF5+01ylGiZ2nnB1rcFAF798YKkbuBKEXhrAXifPZnSWz4FRri51NeZ7zEnRS9mJv682HeEUvfCiXUh5dqF6CvyIL08Zqv8mGEkIY5LlLaMwbPA+fiP860g5oE20peUB6LGAYmNqYkYPkDB8kIZQzyFazRhPiEw42HdcYtk1DKaB4jzjctNykkUrfE4qva6hmJ39aYCFhoYKqyx+iv++564UyFU20TbSbu28ZTpmMYYnRjqo9kKT24mJZFAzh1hqhp9juytm2K0+CRxBFmyRem3InfhH2it+xAwwaBEkdGEn1hf4N+DsZW2nWFNCgShPUXZ7LpPkvFHyHqxBNARFSU8lj3zpc5rn5C6wacWfadA+hHBkvsB77+m9WFcFSSCrZgLCtJcBLLy/zERE0UQ2qjjTnFQnNErJ+608bxA1x7j5dH6ttCg8oMonZFZ2kjYtlFxm8VwgMICjUehGUOnwSPPL0LFkN4MzZufcbQ5WW2/z0w/DgPbNw4cdfFgMREhaXXTZaGsv1JoE55hEE6BzwJPxWkJDeIgs1j6Mc0OzjjB0w39mmS4KiXT/pFtojgz2xWX/h66LOTrEyVBJcOTgvtcLLaHnRfeROhFMd4y1gv1011lOUp2RQcgN2FxyL5mWxKnipduy2po7PxBL6RNdvtaomD/ETi9d9sgceYmrfvyoiUj8nQ2+sZCgGGE6If5mITttlH5zyiVAgOBNKDcwodErFb2WT6g+0M8AeO6QJh/ahalmEDyJz9sKZGJa2B2z45+6tNtm09ZE1rhNWVwzg8z9+SST1uiKDIn0fRazWTPb/ZNTpkJXoaOgwGdGJeD34/4ND7nNE7VMgJxR0oZOXxsycz/GPA/EPTR8QUgK5JaRHYX8cswXof67LGQ81x7fp0k3MFlzR7P/xohTZkNJfIQ8LPRKw2iMzW4IQwedQmWhLq2FQsyoGhStqGme5QBS6oiJOQFxVa2q8IRVTlADdlOhOC81JRLzuyecQUe0AyIfaFxJIqdPGSnYMG9q9AKBsSEbbbIfca9WRoxWvZM1MvQYFSYqf4+/dp08RsTriesgKCKhD/zjmL6ayG/Qu6Ps5ojlTaf+THvOEKBZd8uwv+7THdYf/D7L1A7oRLupH5pEh2SI//3+2ItNcHPJUBoVBgXq1Zf//keiosBb1Qzg3AQFixLcyM9uG7SYS7p/z8QFoNjpZhOuRpBULHYsZ9iebuV774Gm8dFARPBfWel6G4vp+L+eHY11AdJYSVpH91tD3l+Vx2ThizYa9HavayngNk3mEwXot6D3SyhdWFW8tcUJh0JrIioYxqAgTIiIYr05qaE2R2qo9T0B0Hui0efI+iFOk2q6IZD8AXRiHXWEo/2zc6a5YbVDMmX0TpJVoDWWuYKnkjUgaelwvH4NE7T23vrO6g3GgrmGw8hg2nYoxLDL2LjbB5r7nWfUT8GF3ghMdveSJm9eXP/buH1pOLDWpfcqDoa/f3zL4ixkVpVb3IP6hnOfyskzC+W8Uqh0S+bMxG0q5KI9wm5RZEN2VtsHstV5D9Q3lgMXtKBpK3l4BV17lNcSkHWcEi+0U1bEYAax+t8RpHX5S0Ai+ECK2Wpt5lyWhDy8wt7OnyRqBXhVJYay3TdlY8/jCH24Vm0tEB4Ejxtet4PWTNeYkESus0z6bBT1ZSTRWhiI9bhu8idzLFZ794G3DEQWCyvEVY6HjbxEY/rMkaUE3mzuOEdGb0n+1WWOGB3U1JcXFFhwO4w4zkRTp0dKQ91A3nngWCxw/j9p2unR1DcZALBj6EXjGMeWQJPftu0ijZ+BZwxwtBVu3QB0si8nTtR9NrgIXJAR8X819Vm/UDyvmcItoEgZtxphIyfB+7bIRPU4SdB2fvZ7gBqHAmFfCp/2kDpAX5spLTdKAAEd5m+zKUKXZEqJEeUgdzgDYjsWtRIEIKR6C0C1tF9gzEz/RV52a0yAYzqYkJHlG9qhlp6xKFXZNE32kOqCOPb10b6V6d4hW4h5kUJXmPjFkXYy3+8UGErUYt6aq68uNtkpwLJbRaw7EE1ekqhITFiQRGkfw6BIXoB/f6e4O3ESD2hRs81NC30wZgCG/2HydAuJDIylDaH89FDOBMnr9fWhONhxUz7kyMRC4zlCQlclASr3GuUspUegZxgunpnfUMwgx0sdvh9q5FGsJ7B7GdimgjQ7Tv9KulBDf26xko1dCAEkXuP8dfocaGeMj6rXfAc2gEmCZsTE5Fa61HIiRTM5wTXXmrSeO+hDiVZSmta3jGq+7cEkMfSob6HdDhcRX6XvyYo0HPZe7FYf5NQRqeYfJjrUKBmTfYhFxwrwGEI+ldeSId9ZsZdEbJzXKa6alt/fp05Kr8B1BFh/EobweHsZf7g8PVo2xzRFl0wJhZGOj/xazsYlIT3wcUdybTVAc6TLfKI7UBtnJFg59SXFz4yCPsiDYdgUUOxJ8Lg+ChQWbfurNWfE7Uysdyr6lAZ43r8vu10f0L9xVF6GYhDRL+VgJv6xsw4wWqxIwLjAxIGVsZW1lbnQgaW4gc2VxdWVuY2UgZWxlbWVudHMgaW4gc2VxdWVuY2UAAAABAAAAAAAAABAPEQAVAAAAYGJvb2xlYW4gYAAAOQ8RAAkAAAA4DxEAAQAAAGludGVnZXIgYAAAAFQPEQAJAAAAOA8RAAEAAABmbG9hdGluZyBwb2ludCBgcA8RABAAAAA4DxEAAQAAAGNoYXJhY3RlciBgAJAPEQALAAAAOA8RAAEAAABzdHJpbmcgAKwPEQAHAAAAYnl0ZSBhcnJheXVuaXQgdmFsdWVPcHRpb24gdmFsdWVuZXd0eXBlIHN0cnVjdHNlcXVlbmNlbWFwZW51bXVuaXQgdmFyaWFudG5ld3R5cGUgdmFyaWFudHR1cGxlIHZhcmlhbnRzdHJ1Y3QgdmFyaWFudAABAAAAAAAAAC4wAAAAAAAACAAAAAQAAACRAAAAkgAAAJMAAABhIHN0cmluZ3z9izJX5lf5At9Ev+NI569tXcvWLFDrY3hBpldxG4u5AQAAAAAAAABlbnRpdHkgbm90IGZvdW5kcGVybWlzc2lvbiBkZW5pZWRjb25uZWN0aW9uIHJlZnVzZWRjb25uZWN0aW9uIHJlc2V0aG9zdCB1bnJlYWNoYWJsZW5ldHdvcmsgdW5yZWFjaGFibGVjb25uZWN0aW9uIGFib3J0ZWRub3QgY29ubmVjdGVkYWRkcmVzcyBpbiB1c2VhZGRyZXNzIG5vdCBhdmFpbGFibGVuZXR3b3JrIGRvd25icm9rZW4gcGlwZWVudGl0eSBhbHJlYWR5IGV4aXN0c29wZXJhdGlvbiB3b3VsZCBibG9ja25vdCBhIGRpcmVjdG9yeWlzIGEgZGlyZWN0b3J5ZGlyZWN0b3J5IG5vdCBlbXB0eXJlYWQtb25seSBmaWxlc3lzdGVtIG9yIHN0b3JhZ2UgbWVkaXVtZmlsZXN5c3RlbSBsb29wIG9yIGluZGlyZWN0aW9uIGxpbWl0IChlLmcuIHN5bWxpbmsgbG9vcClzdGFsZSBuZXR3b3JrIGZpbGUgaGFuZGxlaW52YWxpZCBpbnB1dCBwYXJhbWV0ZXJpbnZhbGlkIGRhdGF0aW1lZCBvdXR3cml0ZSB6ZXJvbm8gc3RvcmFnZSBzcGFjZXNlZWsgb24gdW5zZWVrYWJsZSBmaWxlcXVvdGEgZXhjZWVkZWRmaWxlIHRvbyBsYXJnZXJlc291cmNlIGJ1c3lleGVjdXRhYmxlIGZpbGUgYnVzeWRlYWRsb2NrY3Jvc3MtZGV2aWNlIGxpbmsgb3IgcmVuYW1ldG9vIG1hbnkgbGlua3NpbnZhbGlkIGZpbGVuYW1lYXJndW1lbnQgbGlzdCB0b28gbG9uZ29wZXJhdGlvbiBpbnRlcnJ1cHRlZHVuc3VwcG9ydGVkdW5leHBlY3RlZCBlbmQgb2YgZmlsZW91dCBvZiBtZW1vcnlpbiBwcm9ncmVzc290aGVyIGVycm9ydW5jYXRlZ29yaXplZCBlcnJvcm9wZXJhdGlvbiBzdWNjZXNzZnVsbWVtb3J5IGFsbG9jYXRpb24gb2YgIGJ5dGVzIGZhaWxlZACFExEAFQAAAJoTEQANAAAApQwQABgAAABkAQAACQAAAJcAAAAMAAAABAAAAJgAAACZAAAAmgAAAAAAAAAIAAAABAAAAJsAAACcAAAAnQAAAJ4AAACfAAAAEAAAAAQAAACgAAAAoQAAAKIAAACjAAAAIChvcyBlcnJvciApAQAAAAAAAAAYFBEACwAAACMUEQABAAAAAAAAAAgAAAAEAAAApAAAAGFzc2VydGlvbiBmYWlsZWQ6IHBzaXplID49IHNpemUgKyBtaW5fb3ZlcmhlYWQAAHoMEAAqAAAAsQQAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA8PSBzaXplICsgbWF4X292ZXJoZWFkAAB6DBAAKgAAALcEAAANAAAAlwAAAAwAAAAEAAAApQAAABAAAAARAAAAEgAAABAAAAAQAAAAEwAAABIAAAANAAAADgAAABUAAAAMAAAACwAAABUAAAAVAAAADwAAAA4AAAATAAAAJgAAADgAAAAZAAAAFwAAAAwAAAAJAAAACgAAABAAAAAXAAAADgAAAA4AAAANAAAAFAAAAAgAAAAbAAAADgAAABAAAAAWAAAAFQAAAAsAAAAWAAAADQAAAAsAAAALAAAAEwAAAIQQEQCUEBEApRARALcQEQDHEBEA1xARAOoQEQD8EBEACRERABcREQAsEREAOBERAEMREQBYEREAbRERAHwREQCKEREAnRERAMMREQD7EREAFBIRACsSEQA3EhEAQBIRAEoSEQBaEhEAcRIRAH8SEQCNEhEAmhIRAK4SEQC2EhEA0RIRAN8SEQDvEhEABRMRABoTEQAlExEAOxMRAEgTEQBTExEAXhMRAEVycm9yAEG8rMQAC8ASAQAAAKYAAABhIGZvcm1hdHRpbmcgdHJhaXQgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3Igd2hlbiB0aGUgdW5kZXJseWluZyBzdHJlYW0gZGlkIG5vdAAAtQEQABgAAACKAgAADgAAAGNhcGFjaXR5IG92ZXJmbG93AAAArBYRABEAAADJCxAAIAAAABwAAAAFAAAApwAAAAwAAAAEAAAAqAAAAKkAAACqAAAAAHAABwAtAQEBAgECAQFICzAVEAFlBwIGAgIBBCMBHhtbCzoJCQEYBAEJAQMBBSsDOwkqGAEgNwEBAQQIBAEDBwoCHQE6AQEBAgQIAQkBCgIaAQICOQEEAgQCAgMDAR4CAwELAjkBBAUBAgQBFAIWBgEBOgEBAgEECAEHAwoCHgE7AQEBDAEJASgBAwE3AQEDBQMBBAcCCwIdAToBAgIBAQMDAQQHAgsCHAI5AgEBAgQIAQkBCgIdAUgBBAECAwEBCAFRAQIHDAhiAQIJCwdJAhsBAQEBATcOAQUBAgULASQJAWYEAQYBAgICGQIEAxAEDQECAgYBDwEAAwAEHAMdAh4CQAIBBwgBAgsJAS0DAQF1AiIBdgMEAgkBBgPbAgIBOgEBBwEBAQECCAYKAgEwLgIMFAQwCgQDJgkMAiAEAgY4AQECAwEBBTgIAgKYAwENAQcEAQYBAwLGQAABwyEAA40BYCAABmkCAAQBCiACUAIAAQMBBAEZAgUBlwIaEg0BJggZCwEBLAMwAQIEAgICASQBQwYCAgICDAEIAS8BMwEBAwICBQIBASoCCAHuAQIBBAEAAQAQEBAAAgAB4gGVBQADAQIFBCgDBAGlAgAEQQUAAk0GRgsxBHsBNg8pAQICCgMxBAICBwE9AyQFAQg+AQwCNAkBAQgEAgFfAwIEBgECAZ0BAwgVAjkCAQEBAQwBCQEOBwMFQwECBgEBAgEBAwQDAQEOAlUIAgMBARcBUQECBgEBAgEBAgEC6wECBAYCAQIbAlUIAgEBAmoBAQECCGUBAQECBAEFAAkBAvUBCgQEAZAEAgIEASAKKAYCBAgBCQYCAy4NAQLGAQEDAQHJBwEGAQFSFgIHAQIBAnoGAwEBAgEHAQFIAgMBAQEAAgsCNAUFAxcBAAEGDwAMAwMABTsHAAE/BFEBCwIAAgAuAhcABQMGCAgCBx4ElAMANwQyCAEOARYFAQ8ABwERAgcBAgEFZAGgBwABPQQABP4C8wECAQcCBQEAB20HAGCA8AAAAQAAAAAAAAAweAAAwwoQABsAAACwCgAAJgAAAMMKEAAbAAAAuQoAABoAAABmYWxzZXRydWUwMDAxMDIwMzA0MDUwNjA3MDgwOTEwMTExMjEzMTQxNTE2MTcxODE5MjAyMTIyMjMyNDI1MjYyNzI4MjkzMDMxMzIzMzM0MzUzNjM3MzgzOTQwNDE0MjQzNDQ0NTQ2NDc0ODQ5NTA1MTUyNTM1NDU1NTY1NzU4NTk2MDYxNjI2MzY0NjU2NjY3Njg2OTcwNzE3MjczNzQ3NTc2Nzc3ODc5ODA4MTgyODM4NDg1ODY4Nzg4ODk5MDkxOTI5Mzk0OTU5Njk3OTg5OS0wLiswMTIzNDU2Nzg5YWJjZGVmMDEyMzQ1Njc4OUFCQ0RFRiwgCiwKKCgKKSwAAAAAAAwAAAAEAAAAsQAAALIAAACzAAAAIHsgOiAgewp9IH1bXTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAADDChAAGwAAADYHAAAfAAAAYXNzZXJ0aW9uIGZhaWxlZDogb3RoZXIgPiAwYXNzZXJ0aW9uIGZhaWxlZDogbm9ib3Jyb3cAAADTBRAAHgAAAIQBAAABAAAAYXNzZXJ0aW9uIGZhaWxlZDogZGlnaXRzIDwgNDBhc3NlcnRpb24gZmFpbGVkOiBwYXJ0cy5sZW4oKSA+PSA0YXNzZXJ0aW9uIGZhaWxlZDogYnVmLmxlbigpID49IE1BWF9TSUdfRElHSVRTTmFOaW5mMC5hc3NlcnRpb24gZmFpbGVkOiAhYnVmLmlzX2VtcHR5KCkAAADqCxAAIwAAALcAAAAFAAAAYXNzZXJ0aW9uIGZhaWxlZDogYnVmWzBdID4gYicwJwDqCxAAIwAAALgAAAAFAAAA6gsQACMAAAC5AAAABQAAAGFzc2VydGlvbiBmYWlsZWQ6IGJ1Zi5sZW4oKSA+PSBtYXhsZW4AAADqCxAAIwAAAHoCAAANAAAA6gsQACMAAACZAAAADgAAAAAAAADfRRo9A88a5sH7zP4AAAAAysaaxxf+cKvc+9T+AAAAAE/cvL78sXf/9vvc/gAAAAAM1mtB75FWvhH85P4AAAAAPPx/kK0f0I0s/Oz+AAAAAIOaVTEoXFHTRvz0/gAAAAC1yaatj6xxnWH8/P4AAAAAy4vuI3cinOp7/AT/AAAAAG1TeECRScyulvwM/wAAAABXzrZdeRI8grH8FP8AAAAAN1b7TTaUEMLL/Bz/AAAAAE+YSDhv6paQ5vwk/wAAAADHOoIly4V01wD9LP8AAAAA9Je/l83PhqAb/TT/AAAAAOWsKheYCjTvNf08/wAAAACOsjUq+2c4slD9RP8AAAAAOz/G0t/UyIRr/Uz/AAAAALrN0xonRN3Fhf1U/wAAAACWySW7zp9rk6D9XP8AAAAAhKVifSRsrNu6/WT/AAAAAPbaXw1YZquj1f1s/wAAAAAm8cPek/ji8+/9dP8AAAAAuID/qqittbUK/nz/AAAAAItKfGwFX2KHJf6E/wAAAABTMME0YP+8yT/+jP8AAAAAVSa6kYyFTpZa/pT/AAAAAL1+KXAkd/nfdP6c/wAAAACPuOW4n73fpo/+pP8AAAAAlH10iM9fqfip/qz/AAAAAM+bqI+TcES5xP60/wAAAABrFQ+/+PAIit/+vP8AAAAAtjExZVUlsM35/sT/AAAAAKx/e9DG4j+ZFP/M/wAAAAAGOysqxBBc5C7/1P8AAAAA05JzaZkkJKpJ/9z/AAAAAA7KAIPytYf9Y//k/wAAAADrGhGSZAjlvH7/7P8AAAAAzIhQbwnMvIyZ//T/AAAAACxlGeJYF7fRs//8/wBBhr/EAAsFQJzO/wQAQZS/xAAL7A4QpdTo6P8MAAAAAAAAAGKsxet4rQMAFAAAAAAAhAmU+Hg5P4EeABwAAAAAALMVB8l7zpfAOAAkAAAAAABwXOp7zjJ+j1MALAAAAAAAaIDpq6Q40tVtADQAAAAAAEUimhcmJ0+fiAA8AAAAAAAn+8TUMaJj7aIARAAAAAAAqK3IjDhl3rC9AEwAAAAAANtlqxqOCMeD2ABUAAAAAACaHXFC+R1dxPIAXAAAAAAAWOcbpixpTZINAWQAAAAAAOqNcBpk7gHaJwFsAAAAAABKd++amaNtokIBdAAAAAAAhWt9tHt4CfJcAXwAAAAAAHcY3Xmh5FS0dwGEAAAAAADCxZtbkoZbhpIBjAAAAAAAPV2WyMVTNcisAZQAAAAAALOgl/pctCqVxwGcAAAAAADjX6CZvZ9G3uEBpAAAAAAAJYw52zTCm6X8AawAAAAAAFyfmKNymsb2FgK0AAAAAADOvulUU7/ctzECvAAAAAAA4kEi8hfz/IhMAsQAAAAAAKV4XNObziDMZgLMAAAAAADfUyF781oWmIEC1AAAAAAAOjAfl9y1oOKbAtwAAAAAAJaz41xT0dmotgLkAAAAAAA8RKek2Xyb+9AC7AAAAAAAEESkp0xMdrvrAvQAAAAAABqcQLbvjquLBgP8AAAAAAAshFemEO8f0CADBAEAAAAAKTGR6eWkEJs7AwwBAAAAAJ0MnKH7mxDnVQMUAQAAAAAp9Dti2SAorHADHAEAAAAAhc+nel5LRICLAyQBAAAAAC3drANA5CG/pQMsAQAAAACP/0ReL5xnjsADNAEAAAAAQbiMnJ0XM9TaAzwBAAAAAKkb47SS2xme9QNEAQAAAADZd9+6br+W6w8ETAEAAAAAhgEQAC4AAAB9AAAAFQAAAIYBEAAuAAAA7wIAACYAAACGARAALgAAAOMCAAAmAAAAhgEQAC4AAADMAgAAJgAAAGFzc2VydGlvbiBmYWlsZWQ6IGQubWFudCA+IDCGARAALgAAANwBAAAFAAAAYXNzZXJ0aW9uIGZhaWxlZDogZC5tYW50IDwgKDEgPDwgNjEphgEQAC4AAADdAQAABQAAAIYBEAAuAAAA3gEAAAUAAACGARAALgAAADMCAAARAAAAhgEQAC4AAAA2AgAACQAAAIYBEAAuAAAAbAIAAAkAAACGARAALgAAAKkAAAAFAAAAYXNzZXJ0aW9uIGZhaWxlZDogZC5taW51cyA+IDAAAACGARAALgAAAKoAAAAFAAAAYXNzZXJ0aW9uIGZhaWxlZDogZC5wbHVzID4gMIYBEAAuAAAAqwAAAAUAAACGARAALgAAAK4AAAAFAAAAYXNzZXJ0aW9uIGZhaWxlZDogZC5tYW50ICsgZC5wbHVzIDwgKDEgPDwgNjEpAAAAhgEQAC4AAACvAAAABQAAAIYBEAAuAAAACgEAABEAAACGARAALgAAAA0BAAAJAAAAhgEQAC4AAABAAQAACQAAAGFzc2VydGlvbiBmYWlsZWQ6IGQubWFudC5jaGVja2VkX3N1YihkLm1pbnVzKS5pc19zb21lKCkAhgEQAC4AAACtAAAABQAAAGFzc2VydGlvbiBmYWlsZWQ6IGQubWFudC5jaGVja2VkX2FkZChkLnBsdXMpLmlzX3NvbWUoKQAAhgEQAC4AAACsAAAABQAAAKMFEAAvAAAACwEAAAUAAACjBRAALwAAAAwBAAAFAAAAowUQAC8AAAANAQAABQAAAKMFEAAvAAAAcgEAACQAAACjBRAALwAAAHcBAAAvAAAAowUQAC8AAACEAQAAEgAAAKMFEAAvAAAAZgEAAA0AAACjBRAALwAAAEwBAAAiAAAAowUQAC8AAAAPAQAABQAAAKMFEAAvAAAADgEAAAUAAACjBRAALwAAAHYAAAAFAAAAowUQAC8AAAB3AAAABQAAAKMFEAAvAAAAeAAAAAUAAACjBRAALwAAAHsAAAAFAAAAowUQAC8AAADCAAAACQAAAKMFEAAvAAAA+wAAAA0AAACjBRAALwAAAAIBAAASAAAAowUQAC8AAAB6AAAABQAAAKMFEAAvAAAAeQAAAAUAAAABAAAACgAAAGQAAADoAwAAECcAAKCGAQBAQg8AgJaYAADh9QUAypo7wW/yhiMAAACB76yFW0FtLe4EAAABH2q/ZO04bu2Xp9r0+T/pA08YAAE+lS4Jmd8D/TgVDy/kdCPs9c/TCNwExNqwzbwZfzOmAyYf6U4CAAABfC6YW4fTvnKf2diHLxUSxlDea3BuSs8P2JXVbnGyJrBmxq0kNhUdWtNCPA5U/2PAc1XMF+/5ZfIovFX3x9yA3O1u9M7v3F/3UwUAzgEQACEAAAAuAAAACQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAEHCzsQACzMCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAwMDAwMDAwMDAwMDAwMDBAQEBAQAQYDPxAALqRRbLi4uXWJlZ2luIDw9IGVuZCAoIDw9ICkgd2hlbiBzbGljaW5nIGBghScRAA4AAACTJxEABAAAAJcnEQAQAAAApycRAAEAAABieXRlIGluZGV4ICBpcyBub3QgYSBjaGFyIGJvdW5kYXJ5OyBpdCBpcyBpbnNpZGUgIChieXRlcyApIG9mIGAAyCcRAAsAAADTJxEAJgAAAPknEQAIAAAAASgRAAYAAACnJxEAAQAAACBpcyBvdXQgb2YgYm91bmRzIG9mIGAAAMgnEQALAAAAMCgRABYAAACnJxEAAQAAAIMFEAAfAAAAZwYAABUAAACDBRAAHwAAAJUGAAAVAAAAgwUQAB8AAACWBgAAFQAAAIMFEAAfAAAAdAUAACgAAACDBRAAHwAAAHQFAAASAAAAY29weV9mcm9tX3NsaWNlOiBzb3VyY2Ugc2xpY2UgbGVuZ3RoICgpIGRvZXMgbm90IG1hdGNoIGRlc3RpbmF0aW9uIHNsaWNlIGxlbmd0aCAoAAAAsCgRACYAAADWKBEAKwAAABkbEQABAAAAcmFuZ2UgZW5kIGluZGV4ICBvdXQgb2YgcmFuZ2UgZm9yIHNsaWNlIG9mIGxlbmd0aCAAABwpEQAQAAAALCkRACIAAABzbGljZSBpbmRleCBzdGFydHMgYXQgIGJ1dCBlbmRzIGF0IABgKREAFgAAAHYpEQANAAAAcmFuZ2Ugc3RhcnQgaW5kZXggAACUKREAEgAAACwpEQAiAAAAY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZQABAAAAAAAAADcbEQACAAAAAAMAAIMEIACRBWAAXROgABIXIB8MIGAf7yxgKyow4CtvpqAsAqggLR77IC4A/mA2nv+gNv0BITcBCmE3JA0hOKsOoTkvGCE68x4hS0A0oVMeYeFU8GphVU9v4VWdvGFWAM9hV2XRoVcA2iFYAOChWa7iIVvs5OFc0OhhXSAA7l7wAX9fAAYBAQMBBAIFBwcCCAgJAgoFCwIOBBABEQISBRMcFAEVAhcCGQ0cBR0IHwEkAWoEawJuAq8DsQK8As8C0QLUDNUJ1gLXAtoB4AXhAuYB5wToAu4g8AT4AvoF+wEMJzs+Tk+Pnp6fe4uTlqKyuoaxBgcJNj0+VvPQ0QQUGDY3Vld/qq6vvTXgEoeJjp4EDQ4REikxNDpFRklKTk9kZYqMjY+2wcPExsvWXLa3GxwHCAoLFBc2OTqoqdjZCTeQkagHCjs+ZmmPkhFvX7/u71piubr0/P9TVJqbLi8nKFWdoKGjpKeorbq8xAYLDBUdOj9FUaanzM2gBxkaIiU+P9/n7O//xcYEICMlJigzODpISkxQU1VWWFpcXmBjZWZrc3h9f4qkqq+wwNCur25vx93ek14iewUDBC0DZgMBLy6Agh0DMQ8cBCQJHgUrBUQEDiqAqgYkBCQEKAg0C04DNAyBNwkWCggYO0U5A2MICTAWBSEDGwUbJjgESwUvBAoHCQdAICcEDAk2AzoFGgcEDAdQSTczDTMHLggKBiYDHQgCgNBSEAYICSEuCCoWGiYcFBcJTgQkCUQNGQcKBkgIJwl1C0I+KgY7BQoGUQYBBRADBQtZCAIdYh5ICAqApl4iRQsKBg0TOgYKBhQcLAQXgLk8ZFMMSAkKRkUbSAhTDUkHClYIWCIOCgZGCh0DR0k3Aw4ICgY5BwoGLAQKgPYZBzsDHVUBDzINg5tmdQuAxIpMYw2EMBAWCo+bBYJHmrk6hsaCOQcqBFwGJgpGCigFE4GwOoDGWwU0LEsEOQcRQAULBwmc1ikgYXOh/YEzDwEdBg4ECIGMiQRrBQ0DCQcQj2CA/QOBtAYXDxEPRwl0PID2CnMIcBVGehQMFAxXCRmAh4FHA4VCDxWEUB8GBoDVKwU+IQFwLQMaBAKBQB8ROgUBgdAqgNYrBAGAwDYIAoDggPcpTAQKBAKDEURMPYDCPAYBBFUFGzQCgQ4sBGQMVgqArjgdDSwECQcCDgaAmoPZAxEDDQOA2gYMBAEPDAQ4CAoGKAgsBAIOCSeBWAgdAwsDOwQeBAoHgPuEBQABAwUFBgYCBwYIBwkRChwLGQwZDRAODA8EEAMSEhMJFgEXBBgBGQMaCRsBHAIfFiADKwItCy4BMAQxAjIBqQKqBKsI+gL7Bf4D/wmteHmLjaIwV1iLjJAc3Q4PS0z7/C4vP1xdX+KEjY6RkqmxurvFxsnK3uTl/wAEERIpMTQ3Ojs9SUpdhI6SqbG0urvGys7P5OUABA0OERIpMTQ6O0VGSUpeZGWEkZudyc7PDREpOjtFSVdbXl9kZY2RqbS6u8XJ3+Tl8A0RRUlkZYCEsry+v9XX8PGDhYukpr6/xcfP2ttImL3Nxs7PSU5PV1leX4mOj7G2t7/BxsfXERYXW1z29/7/gG1x3t8OH25vHB1ffX6ur97fTbu8FhceH0ZHTk9YWlxefn+1xdTV3PDx9XJzj3R1Ji4vp6+3v8fP19+aAECXmDCPH87/Tk9aWwcIDxAnL+7vbm83PT9CRVNndcjJ0NHY2ef+/wAgXyKC3wSCRAgbBAYRgawOgKsFIAeBHAMZCAEELwQ0BAcDAQcGBxEKUA8SB1UHAwQcCgkDCAMHAwIDAwMMBAUDCwYBDhUFTgcbB1cHAgUYDFAEQwMtAwEEEQYPDDoEHSVfIG0EaiWAyAWCsAMaBoL9A1kHFgkYCRQMFAxqBgoGGgZZBysFRgosBAwEAQMxCywEGgYLA4CsBgoGTBSA9Ag8Aw8DPgU4CCsFgv8RGAgvES0DIg4hD4CMBIKaFgsViJQFLwU7BwIOGAmAviJ0DIDWGoEQBYDhCfKeAzcJgVwUgLgIgN0UPAMKBjgIRggMBnQLHgNaBFkJgIMYHAoWCUwEgIoGq6QMFwQxoQSB2iYHDAUFgrMgKgZMBICNBIC+AxsDDw2CBxAAJQAAABoAAAA2AAAAggcQACUAAAAKAAAAKwAAAGF0dGVtcHQgdG8gZGl2aWRlIGJ5IHplcm8AAABMMBEAGQAAAAAAAAAEAAAABAAAALQAAABpbmRleCBvdXQgb2YgYm91bmRzOiB0aGUgbGVuIGlzICBidXQgdGhlIGluZGV4IGlzIAAAgDARACAAAACgMBEAEgAAAD09IT1tYXRjaGVzYXNzZXJ0aW9uIGBsZWZ0ICByaWdodGAgZmFpbGVkCiAgbGVmdDogCiByaWdodDogAM8wEQAQAAAA3zARABcAAAD2MBEACQAAACByaWdodGAgZmFpbGVkOiAKICBsZWZ0OiAAAADPMBEAEAAAABgxEQAQAAAAKDERAAkAAAD2MBEACQAAAFJlZkNlbGwgYWxyZWFkeSBtdXRhYmx5IGJvcnJvd2VkLi5SZWZDZWxsIGFscmVhZHkgYm9ycm93ZWQgICAgAADEMBEAxjARAMgwEQACAAAAAgAAAAcAQazjxAALMQIAAAAAAAAAdgAAAAIAAAAAAAAAdwAAAAIAAAAAAAAAeAAAAAIAAAAAAAAAeQAAAHoAQfjjxAALAXsAfAlwcm9kdWNlcnMCCGxhbmd1YWdlAQRSdXN0AAxwcm9jZXNzZWQtYnkDBXJ1c3RjHTEuOTIuMCAoZGVkNWMwNmNmIDIwMjUtMTItMDgpBndhbHJ1cwYwLjIzLjMMd2FzbS1iaW5kZ2VuEzAuMi4xMDAgKDI0MDVlYzJiNCkAaw90YXJnZXRfZmVhdHVyZXMGKw9tdXRhYmxlLWdsb2JhbHMrE25vbnRyYXBwaW5nLWZwdG9pbnQrC2J1bGstbWVtb3J5KwhzaWduLWV4dCsPcmVmZXJlbmNlLXR5cGVzKwptdWx0aXZhbHVl";
async function XB() {
  const A = await (await fetch(qa)).arrayBuffer();
  return await Ha({ module_or_path: A });
}
function AQ(i) {
  if (typeof Buffer < "u")
    return Buffer.from(i, "base64").buffer;
  if (typeof globalThis < "u" && typeof globalThis.atob == "function") {
    const A = globalThis.atob(i), e = new Uint8Array(A.length);
    for (let t = 0; t < A.length; t++) e[t] = A.charCodeAt(t);
    return e.buffer;
  }
  throw new Error("Unable to decode base64 WASM payload: no atob() or Buffer available.");
}
function eQ() {
  const i = qa.split(",")[1], A = AQ(i);
  return $B({ module: A });
}
function La() {
  return (
    // @ts-ignore
    !!(typeof navigator < "u" && // @ts-ignore
    navigator?.userAgent?.includes("Cloudflare"))
  );
}
const tQ = () => {
  if (La())
    return !1;
  try {
    const i = Function;
    return new i(""), !0;
  } catch {
    return !1;
  }
};
let xa = XB, cg = eQ;
const Oa = (i) => `Critical Error: Failed to load WASM module

${tQ() ? i.message : `You need to add \`import "jazz-tools/load-edge-wasm";\` on top of your entry module to make Jazz work with ${La() ? "Cloudflare workers" : "this runtime"}`}

A native crypto module is required for Jazz to work. See https://jazz.tools/docs/react/reference/performance#use-the-best-crypto-implementation-for-your-platform for possible alternatives.`;
async function iQ() {
  try {
    await xa();
  } catch (i) {
    throw new Error(Oa(i), { cause: i });
  }
}
class Ie extends Nc {
  constructor() {
    super();
  }
  static setInit(A) {
    xa = A;
  }
  static setInitSync(A) {
    cg = A;
  }
  static createSync() {
    try {
      cg();
    } catch (A) {
      throw new Error(Oa(A), { cause: A });
    }
    return new Ie();
  }
  // TODO: Remove this method and use createSync instead, this is not necessary since we can use createSync in the browser and in the worker.
  // @deprecated
  static async create() {
    return await iQ(), new Ie();
  }
  blake3HashOnce(A) {
    return OB(A);
  }
  blake3HashOnceWithContext(A, { context: e }) {
    return TB(A, e);
  }
  newEd25519SigningKey() {
    return HB();
  }
  getSignerID(A) {
    return qB(SA.encode(A));
  }
  sign(A, e) {
    return LB(SA.encode(xA(e)), SA.encode(A));
  }
  verify(A, e, t) {
    return xB(SA.encode(A), SA.encode(xA(e)), SA.encode(t));
  }
  newX25519StaticSecret() {
    return ZB();
  }
  getSealerID(A) {
    return zB(SA.encode(A));
  }
  encrypt(A, e, t) {
    return `encrypted_U${dr(VB(SA.encode(xA(A)), e, SA.encode(xA(t))))}`;
  }
  decryptRaw(A, e, t) {
    return zs.decode(WB(ur(A.substring(11)), e, SA.encode(xA(t))));
  }
  seal({ message: A, from: e, to: t, nOnceMaterial: o }) {
    return `sealed_U${dr(jB(SA.encode(xA(A)), e, t, SA.encode(xA(o))))}`;
  }
  unseal(A, e, t, o) {
    const r = zs.decode(PB(ur(A.substring(8)), e, t, SA.encode(xA(o))));
    try {
      return JSON.parse(r);
    } catch (s) {
      AA.error("Failed to decrypt/parse sealed message", { err: s });
      return;
    }
  }
  createSessionLog(A, e, t) {
    return new Cs(new Co(A, e, t));
  }
}
class Cs {
  constructor(A) {
    this.sessionLog = A;
  }
  tryAdd(A, e, t) {
    for (const o of A)
      o.privacy === "private" ? this.sessionLog.addExistingPrivateTransaction(o.encryptedChanges, o.keyUsed, o.madeAt, o.meta) : this.sessionLog.addExistingTrustingTransaction(o.changes, o.madeAt, o.meta);
    this.sessionLog.commitTransactions(e, t);
  }
  addNewPrivateTransaction(A, e, t, o, r, s) {
    const g = this.sessionLog.addNewPrivateTransaction(
      // We can avoid stableStringify because it will be encrypted.
      JSON.stringify(e),
      A.currentSignerSecret(),
      o,
      t,
      r,
      // We can avoid stableStringify because it will be encrypted.
      s ? JSON.stringify(s) : void 0
    ), n = JSON.parse(g), a = {
      privacy: "private",
      madeAt: r,
      encryptedChanges: n.encrypted_changes,
      keyUsed: t,
      meta: n.meta
    };
    return { signature: n.signature, transaction: a };
  }
  addNewTrustingTransaction(A, e, t, o) {
    const r = JSON.stringify(e), s = o ? JSON.stringify(o) : void 0;
    return { signature: this.sessionLog.addNewTrustingTransaction(r, A.currentSignerSecret(), t, s), transaction: {
      privacy: "trusting",
      madeAt: t,
      changes: r,
      meta: s
    } };
  }
  decryptNextTransactionChangesJson(A, e) {
    return this.sessionLog.decryptNextTransactionChangesJson(A, e);
  }
  decryptNextTransactionMetaJson(A, e) {
    return this.sessionLog.decryptNextTransactionMetaJson(A, e);
  }
  free() {
    this.sessionLog.free();
  }
  clone() {
    return new Cs(this.sessionLog.clone());
  }
}
const Ta = { comap: { description: "CoMap - CRDT-based collaborative map/object", type: "object", properties: {}, additionalProperties: { anyOf: [{ type: "string", description: "Standard string value" }, { type: "number", description: "Standard number value" }, { type: "integer", description: "Standard integer value" }, { type: "boolean", description: "Standard boolean value" }, { type: "null", description: "Null value" }, { type: "object", description: "Nested object value" }, { type: "array", description: "Array value" }, { type: "string", pattern: "^co_z[a-zA-Z0-9]+$", description: "Co-id reference to another CoValue" }, { type: "string", pattern: "^key_[a-zA-Z0-9_]+$", description: "Key reference" }, { type: "string", pattern: "^sealed_", description: "Sealed/encrypted value" }] } }, costream: { description: "CoStream - CRDT-based append-only stream", type: "array", items: { anyOf: [{ type: "object", description: "Stream item object" }, { type: "string", description: "Stream item string" }, { type: "number", description: "Stream item number" }, { type: "boolean", description: "Stream item boolean" }, { type: "null", description: "Stream item null" }] } }, colist: { description: "CoList - CRDT-based collaborative list/array", type: "array", items: { anyOf: [{ type: "object", description: "List item object" }, { type: "string", description: "List item string (can be co-id reference)" }, { type: "number", description: "List item number" }, { type: "integer", description: "List item integer" }, { type: "boolean", description: "List item boolean" }, { type: "null", description: "List item null" }, { type: "array", description: "Nested array" }] } } }, Tt = {
  $defs: Ta
}, oQ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  $defs: Ta,
  default: Tt
}, Symbol.toStringTag, { value: "Module" }));
let pA = class {
  constructor(A) {
    this._value = A, this._subscribers = /* @__PURE__ */ new Set(), this._unsubscribe = null;
  }
  /**
   * Get current value
   * @returns {any} Current store value
   */
  get value() {
    return this._value;
  }
  /**
   * Subscribe to value changes
   * Callback is called immediately with current value, then on every update
   * Automatically calls _unsubscribe() when the last subscriber unsubscribes
   * @param {Function} callback - Function called with new value
   * @param {Object} [options] - Subscription options
   * @param {boolean} [options.skipInitial=false] - If true, don't call callback immediately with current value
   * @returns {Function} Unsubscribe function
   */
  subscribe(A, e = {}) {
    return this._subscribers.add(A), e.skipInitial || A(this._value), () => {
      this._subscribers.delete(A), this._subscribers.size === 0 && this._unsubscribe && this._unsubscribe();
    };
  }
  /**
   * Internal method to update store value
   * Notifies all subscribers of the change
   * @param {any} newValue - New value to set
   * @private
   */
  _set(A) {
    this._value = A, this._subscribers.forEach((e) => e(A));
  }
};
async function cs(i, A) {
  const e = await eA(i, A, { returnType: "coId" });
  if (!e) return null;
  const { ensureIndexesCoMap: t, ensureSchemaIndexColist: o } = await Promise.resolve().then(() => pI), r = await t(i);
  if (!r) return null;
  let s = r.get(e);
  if (s && typeof s == "string" && s.startsWith("co_"))
    return s;
  try {
    return (await o(i, e))?.id ?? null;
  } catch {
    return null;
  }
}
async function Bs(i, A) {
  if (!A || typeof A != "string")
    return null;
  const e = /^@[a-zA-Z0-9_-]+\/schema\//.test(A);
  return !A.startsWith("co_z") && !e ? (process.env.DEBUG && console.warn(`[getCoListId] Invalid collection identifier: "${A}". Must be schema co-id or namekey (@domain/schema/...).`), null) : await cs(i, A);
}
async function aA(i, A, e = {}) {
  const { waitForAvailable: t = !1, timeoutMs: o = 2e3 } = e;
  if (!A || !A.startsWith("co_"))
    return null;
  const r = i.getCoValue(A);
  return r ? (r.isAvailable() || (i.node.loadCoValueCore(A).catch((s) => {
    process.env.DEBUG && console.error(`[CoJSONBackend] Failed to load CoValue ${A}:`, s);
  }), t && await new Promise((s, g) => {
    let n;
    const a = setTimeout(() => {
      process.env.DEBUG && console.warn(`[CoJSONBackend] Timeout waiting for CoValue ${A} to load`), n(), g(new Error(`Timeout waiting for CoValue ${A} to load after ${o}ms`));
    }, o);
    n = r.subscribe((I) => {
      I.isAvailable() && (clearTimeout(a), n(), s());
    });
  })), r) : null;
}
const rQ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ensureCoValueLoaded: aA,
  getCoListId: Bs,
  getSchemaIndexColistId: cs
}, Symbol.toStringTag, { value: "Module" }));
function Pa(i, A, e = null) {
  const t = i.getCurrentContent(A), o = i.getHeader(A), r = o?.meta || null, s = A.ruleset || o?.ruleset, g = t?.type || "unknown";
  let n = r?.$schema || null;
  if (e === "@group" || s && s.type === "group" ? n = "@group" : e === "@account" || r && r.type === "account" ? n = "@account" : (e === "@metaSchema" || n === "@metaSchema") && (n = "@metaSchema"), g === "colist" && t && t.toJSON)
    try {
      const a = t.toJSON();
      return {
        id: A.id,
        $schema: n,
        // Use $schema for consistency with headerMeta.$schema
        type: "colist",
        items: a
        // Items ARE the CoList content (not a property)
        // No properties array - CoLists don't have custom key-value properties, only items
      };
    } catch {
      return {
        id: A.id,
        $schema: n,
        // Use $schema for consistency with headerMeta.$schema
        type: "colist",
        items: []
      };
    }
  else if (g === "costream" && t)
    try {
      const a = t.toJSON(), I = [];
      if (a && typeof a == "object" && !(a instanceof Uint8Array))
        for (const C in a)
          Array.isArray(a[C]) && I.push(...a[C]);
      return {
        id: A.id,
        schema: n,
        type: "costream",
        items: I
        // Items ARE the CoStream content (not a property)
        // No properties array - CoStreams don't have custom key-value properties, only items
      };
    } catch (a) {
      return process.env.DEBUG && console.error(`[CoJSONBackend] Error reading CoStream ${A.id.substring(0, 12)}...:`, a), {
        id: A.id,
        $schema: n,
        // Use $schema for consistency with headerMeta.$schema
        type: "costream",
        items: []
      };
    }
  else if (t && t.get && typeof t.get == "function") {
    const a = r?.type || null, I = {
      id: A.id,
      // Always add id field (derived from co-id)
      $schema: n,
      // Use $schema for consistency with headerMeta.$schema
      type: g,
      // Add type for DB viewer
      displayName: a === "account" ? "Account" : n || "CoMap",
      // Display name for DB viewer
      properties: []
      // Properties array for DB viewer
    };
    a && (I.headerMeta = { type: a });
    const C = t.keys && typeof t.keys == "function" ? t.keys() : Object.keys(t);
    for (const c of C)
      try {
        const B = t.get && typeof t.get == "function" ? t.get(c) : t[c];
        let Q = typeof B, f = B;
        typeof B == "string" && B.startsWith("co_") ? Q = "co-id" : typeof B == "string" && B.startsWith("key_") ? Q = "key" : typeof B == "string" && B.startsWith("sealed_") ? (Q = "sealed", f = "sealed_***") : B === null ? Q = "null" : B === void 0 ? Q = "undefined" : typeof B == "object" && B !== null ? (Q = "object", f = JSON.stringify(B)) : Array.isArray(B) && (Q = "array", f = JSON.stringify(B)), I.properties.push({
          key: c,
          value: f,
          type: Q
        });
      } catch (B) {
        I.properties.push({
          key: c,
          value: `<error: ${B.message}>`,
          type: "error"
        });
      }
    return I;
  }
  return {
    id: A.id,
    type: g,
    $schema: n,
    headerMeta: r
  };
}
function Ft(i) {
  if (typeof i == "string" && (i.startsWith("{") || i.startsWith("[")))
    try {
      const A = JSON.parse(i);
      return Ft(A);
    } catch {
      return i;
    }
  else {
    if (Array.isArray(i))
      return i.map((A) => Ft(A));
    if (typeof i == "object" && i !== null) {
      const A = {};
      for (const [e, t] of Object.entries(i))
        A[e] = Ft(t);
      return A;
    }
  }
  return i;
}
function ee(i, A, e = null) {
  const t = i.getHeader(A), o = t?.meta || null;
  A.ruleset || t?.ruleset;
  const r = e === "@account" || o && o.type === "account" || i.account && i.account.id === A.id;
  if (r && i.account && i.account.id === A.id) {
    const c = (i.getHeader(A)?.meta || null)?.$schema || null, B = {
      id: i.account.id,
      type: "comap",
      // Accounts are CoMaps
      $schema: c
      // Include $schema for metadata lookup
    };
    try {
      const Q = i.account.keys && typeof i.account.keys == "function" ? i.account.keys() : Object.keys(i.account);
      for (const f of Q)
        try {
          B[f] = i.account.get(f);
        } catch (l) {
          console.warn(`[CoJSONBackend] Failed to read account key ${f}:`, l);
        }
    } catch (Q) {
      console.warn("[CoJSONBackend] Failed to extract account keys:", Q);
    }
    return B;
  }
  const s = i.getCurrentContent(A);
  if (!s) {
    if (r && i.account && i.account.id === A.id) {
      const f = (i.getHeader(A)?.meta || null)?.$schema || null, l = {
        id: i.account.id,
        type: "comap",
        $schema: f
      };
      try {
        const d = i.account.keys && typeof i.account.keys == "function" ? i.account.keys() : Object.keys(i.account);
        for (const u of d)
          l[u] = i.account.get(u);
      } catch {
      }
      return l;
    }
    const c = (i.getHeader(A)?.meta || null)?.$schema || null;
    return {
      id: A.id,
      type: "unknown",
      $schema: c
    };
  }
  const g = s?.type || "unknown", n = o?.$schema || null;
  if (g === "colist" && s && s.toJSON)
    try {
      const I = s.toJSON(), C = {
        id: A.id,
        cotype: "colist",
        type: "colist",
        $schema: n,
        items: I
      };
      try {
        if (typeof i.getGroupInfo == "function") {
          const c = i.getGroupInfo(A);
          c && (C.groupInfo = c);
        }
      } catch {
      }
      return C;
    } catch {
      const C = {
        id: A.id,
        cotype: "colist",
        type: "colist",
        $schema: n,
        items: []
      };
      try {
        if (typeof i.getGroupInfo == "function") {
          const c = i.getGroupInfo(A);
          c && (C.groupInfo = c);
        }
      } catch {
      }
      return C;
    }
  if (g === "costream" && s)
    try {
      const I = s.toJSON(), C = [];
      if (I && typeof I == "object" && !(I instanceof Uint8Array))
        for (const B in I)
          Array.isArray(I[B]) && C.push(...I[B]);
      const c = {
        id: A.id,
        cotype: "costream",
        type: "costream",
        $schema: n,
        items: C
      };
      try {
        if (typeof i.getGroupInfo == "function") {
          const B = i.getGroupInfo(A);
          B && (c.groupInfo = B);
        }
      } catch {
      }
      return c;
    } catch (I) {
      console.error(`[CoJSONBackend] Error extracting CoStream ${A.id.substring(0, 12)}...:`, I);
      const C = {
        id: A.id,
        cotype: "costream",
        type: "costream",
        $schema: n,
        items: []
      };
      try {
        if (typeof i.getGroupInfo == "function") {
          const c = i.getGroupInfo(A);
          c && (C.groupInfo = c);
        }
      } catch {
      }
      return C;
    }
  if (s && s.get && typeof s.get == "function") {
    const I = s.get("cotype") || g, C = {
      id: A.id,
      cotype: I === "comap" ? "comap" : I,
      type: g,
      // Keep for backward compat; DB viewer prefers cotype
      $schema: n
    }, c = s.keys && typeof s.keys == "function" ? s.keys() : Object.keys(s);
    for (const B of c) {
      let Q = s.get(B);
      (B === "allMessages" || n && n.includes("context")) && console.log(`[extractCoValueDataFlat]  Raw value for key "${B}":`, {
        type: typeof Q,
        isString: typeof Q == "string",
        isObject: typeof Q == "object" && Q !== null,
        startsWithBrace: typeof Q == "string" && Q.startsWith("{"),
        valueSample: typeof Q == "string" ? Q.substring(0, 200) : typeof Q == "object" ? JSON.stringify(Q).substring(0, 200) : Q,
        hasOptions: typeof Q == "object" && Q !== null ? "options" in Q : !1,
        optionsType: typeof Q == "object" && Q !== null && "options" in Q ? typeof Q.options : "N/A"
      });
      const f = ["error", "message", "content", "addAgentError"];
      if (typeof Q == "string" && (Q.startsWith("{") || Q.startsWith("[")) && !f.includes(B))
        try {
          const l = JSON.parse(Q);
          console.log(`[extractCoValueDataFlat]  Parsed JSON string for "${B}":`, {
            parsedType: typeof l,
            parsedKeys: typeof l == "object" && l !== null ? Object.keys(l) : [],
            hasOptions: typeof l == "object" && l !== null ? "options" in l : !1,
            optionsType: typeof l == "object" && l !== null && "options" in l ? typeof l.options : "N/A",
            parsedSample: JSON.stringify(l).substring(0, 300)
          }), Q = Ft(l), console.log(`[extractCoValueDataFlat]  After recursive parse for "${B}":`, {
            finalType: typeof Q,
            finalKeys: typeof Q == "object" && Q !== null ? Object.keys(Q) : [],
            hasOptions: typeof Q == "object" && Q !== null ? "options" in Q : !1,
            optionsKeys: typeof Q == "object" && Q !== null && "options" in Q && typeof Q.options == "object" ? Object.keys(Q.options) : [],
            hasMap: typeof Q == "object" && Q !== null && "options" in Q && typeof Q.options == "object" ? "map" in Q.options : !1,
            finalSample: JSON.stringify(Q).substring(0, 400)
          });
        } catch (l) {
          console.warn(`[extractCoValueDataFlat] Failed to parse JSON string for "${B}":`, l);
        }
      else if (typeof Q == "object" && Q !== null && !Array.isArray(Q)) {
        if (B === "allMessages" || n && n.includes("context")) {
          const u = "options" in Q, h = u ? typeof Q.options : "N/A", w = u && typeof Q.options == "string" && (Q.options.startsWith("{") || Q.options.startsWith("["));
          console.log(`[extractCoValueDataFlat]  Before recursive parse for "${B}":`, {
            hasOptions: u,
            optionsType: h,
            optionsIsString: w,
            optionsValue: u ? typeof Q.options == "string" ? Q.options.substring(0, 200) : JSON.stringify(Q.options).substring(0, 200) : "N/A",
            allKeys: Object.keys(Q)
          });
        }
        const l = JSON.stringify(Q).substring(0, 200);
        Q = Ft(Q);
        const d = JSON.stringify(Q).substring(0, 200);
        if (B === "allMessages" || n && n.includes("context")) {
          const u = "options" in Q, h = u ? typeof Q.options : "N/A", w = u && typeof Q.options == "object" && Q.options !== null ? "map" in Q.options : !1;
          console.log(`[extractCoValueDataFlat]  After recursive parse for "${B}":`, {
            hasOptions: u,
            optionsType: h,
            hasMap: w,
            optionsKeys: u && typeof Q.options == "object" && Q.options !== null ? Object.keys(Q.options) : [],
            mapKeys: w ? Object.keys(Q.options.map) : [],
            changed: l !== d,
            finalSample: JSON.stringify(Q).substring(0, 400)
          });
        }
      }
      C[B] = Q;
    }
    try {
      if (typeof i.getGroupInfo == "function") {
        const B = i.getGroupInfo(A);
        B && (C.groupInfo = B);
      }
    } catch (B) {
      console.warn("[extractCoValueDataFlat] Failed to get group info:", B);
    }
    return C;
  }
  const a = {
    id: A.id,
    type: g,
    $schema: n
  };
  try {
    if (typeof i.getGroupInfo == "function") {
      const I = i.getGroupInfo(A);
      I && (a.groupInfo = I);
    }
  } catch {
  }
  return a;
}
async function sQ(i, A, e = {}, t = /* @__PURE__ */ new Set()) {
  const { timeoutMs: o = 2e3 } = e;
  if (t.has(A)) return { id: A };
  t.add(A);
  try {
    await aA(i, A, { waitForAvailable: !0, timeoutMs: o });
    const r = i.getCoValue(A);
    if (!r || !i.isAvailable(r)) return { id: A };
    let s = ee(i, r);
    s = { ...s, id: s.id || A };
    const g = i.getHeader(r), n = r.ruleset || g?.ruleset;
    if (n && n.type === "group") {
      const a = i.getCurrentContent(r);
      if (a && typeof a.addMember == "function") {
        const { getGroupInfoFromGroup: I } = await Promise.resolve().then(() => ue), C = I(a);
        C && Object.assign(s, {
          accountMembers: C.accountMembers || [],
          groupMembers: C.groupMembers || [],
          id: C.groupId || s.id
        });
      }
    }
    return s;
  } catch {
    return { id: A };
  }
}
async function Jt(i, A, e = {}, t = /* @__PURE__ */ new Set(), o = 15, r = 0) {
  const { fields: s = null, schemas: g = null, timeoutMs: n = 2e3 } = e;
  if (r > o || A == null)
    return A;
  if (typeof A != "object")
    return typeof A == "string" && A.startsWith("co_z") ? await Bg(i, A, e, t, o, r) : A;
  if (Array.isArray(A))
    return Promise.all(A.map(
      (I) => Jt(i, I, e, t, o, r + 1)
    ));
  const a = {};
  for (const [I, C] of Object.entries(A)) {
    if (I === "id" || I === "$schema" || I === "type" || I === "loading" || I === "error") {
      a[I] = C;
      continue;
    }
    const c = s === null || s.includes(I);
    if (C == null) {
      a[I] = C;
      continue;
    }
    if (c && typeof C == "string" && C.startsWith("co_z")) {
      const B = await Bg(i, C, { ...e, timeoutMs: n, maxDepth: o, currentDepth: r }, t, o, r + 1);
      a[I] = B;
    } else
      a[I] = await Jt(i, C, e, t, o, r + 1);
  }
  return a;
}
async function Bg(i, A, e = {}, t = /* @__PURE__ */ new Set(), o = 15, r = 0) {
  const { schemas: s = null, timeoutMs: g = 2e3 } = e;
  if (t.has(A))
    return { id: A };
  const n = i.subscriptionCache, a = {
    deepResolve: !1,
    // We don't need deep resolution here
    resolveReferences: e,
    // Use the same resolution options
    map: null,
    // No map transform in resolveCoId
    maxDepth: o,
    timeoutMs: g
  }, I = n.getResolvedData(A, a);
  if (I) {
    if (s !== null && s.length > 0) {
      const C = I.$schema;
      if (!s.includes(C))
        return { id: A };
    }
    return I;
  }
  try {
    const { waitForStoreReady: C } = await Promise.resolve().then(() => CQ), c = await i.read(null, A, null, null, {
      deepResolve: !1,
      // Don't deep resolve here - we'll resolve nested refs ourselves
      timeoutMs: g
    });
    if (!c)
      return console.warn(`[resolveCoId] No store returned for ${A.substring(0, 12)}...`), { id: A };
    try {
      await C(c, A, g);
    } catch (d) {
      return console.warn(`[resolveCoId] Store not ready for ${A.substring(0, 12)}...:`, d.message), { id: A };
    }
    const B = c.value;
    if (!B)
      return console.warn(`[resolveCoId] No data in store for ${A.substring(0, 12)}...`), { id: A };
    if (B.error)
      return console.warn(`[resolveCoId] Store has error for ${A.substring(0, 12)}...:`, B.error), { id: A, error: B.error };
    if (typeof B != "object" || Array.isArray(B))
      return console.warn(`[resolveCoId] Invalid data type for ${A.substring(0, 12)}...:`, typeof B), { id: A };
    if (s !== null && s.length > 0) {
      const d = B.$schema;
      if (!s.includes(d))
        return { id: A };
    }
    t.add(A);
    const Q = await Jt(
      i,
      B,
      e,
      t,
      o,
      r + 1
    ), f = i.getCoValue(A);
    if (f) {
      const d = i.getHeader(f), u = f.ruleset || d?.ruleset;
      if (u && u.type === "group") {
        const h = i.getCurrentContent(f);
        if (h && typeof h.addMember == "function") {
          const { getGroupInfoFromGroup: w } = await Promise.resolve().then(() => ue), E = w(h);
          E && Object.assign(Q, {
            accountMembers: E.accountMembers || [],
            groupMembers: E.groupMembers || []
          });
        }
      }
    }
    const l = {
      ...Q,
      id: Q.id || B.id || A
    };
    return n.setResolvedData(A, a, l), l;
  } catch (C) {
    return console.error(`[resolveCoId]  Error resolving ${A.substring(0, 12)}...:`, C), { id: A };
  }
}
function gQ(i, A) {
  const e = i.getCurrentContent(A), o = i.getHeader(A)?.meta || null;
  if ((e?.type || "unknown") !== "costream" || !e)
    return null;
  if (e.items && typeof e.items == "object") {
    const s = {};
    for (const [g, n] of Object.entries(e.items))
      Array.isArray(n) && (s[g] = n.map((a) => typeof a.value == "string" && a.value.startsWith("co_z") ? {
        _coId: a.value,
        // Message CoMap co-id (native co-id)
        _sessionID: g,
        // Internal metadata: session ID
        _madeAt: a.madeAt,
        // Internal metadata: CRDT madeAt timestamp
        _tx: a.tx
        // Internal metadata: transaction ID
      } : {
        ...a.value,
        // Message data (type, payload, from, id)
        _sessionID: g,
        // Internal metadata: session ID
        _madeAt: a.madeAt,
        // Internal metadata: CRDT madeAt timestamp
        _tx: a.tx
        // Internal metadata: transaction ID
      }));
    return {
      id: A.id,
      type: "costream",
      $schema: o?.$schema || null,
      sessions: s
      // Preserve session structure: { sessionID: [messages...] }
    };
  }
  return {
    id: A.id,
    type: "costream",
    $schema: o?.$schema || null,
    sessions: {}
  };
}
function ja(i, A) {
  if (Array.isArray(i))
    return i.some((e) => {
      for (const [t, o] of Object.entries(A))
        if (e[t] !== o)
          return !1;
      return !0;
    });
  if (i && typeof i == "object") {
    for (const [e, t] of Object.entries(A))
      if (i[e] !== t)
        return !1;
    return !0;
  }
  return !1;
}
class Mr {
  /**
   * Create a new unified cache
   * 
   * @param {number} cleanupTimeout - Time in ms before cleaning up unused entries (default: 5000)
   */
  constructor(A = 5e3) {
    this.cache = /* @__PURE__ */ new Map(), this.cleanupTimeout = A, this.cleanupTimers = /* @__PURE__ */ new Map();
  }
  /**
   * Get existing entry or create new one (unified getOrCreate for all types)
   * 
   * @param {string} key - Cache key (MUST be namespaced: `subscription:${id}`, `store:${key}`, etc.)
   * @param {Function} factory - Function that creates new entry
   * @returns {any} Cached or newly created entry
   */
  getOrCreate(A, e) {
    const t = this.cache.get(A);
    if (t)
      return this.cancelCleanup(A), t;
    const o = e();
    return this._maybeWarnSubscriptionBuildup(), this.cache.set(A, o), o;
  }
  /**
   * Get existing subscription or create new one (backward compatibility)
   * 
   * @param {string} id - CoValue ID
   * @param {Function} factory - Function that creates new subscription
   * @returns {Object} Subscription object
   */
  getOrCreateSubscription(A, e) {
    return this.getOrCreate(`subscription:${A}`, e);
  }
  /**
   * Get existing store or create new one
   * 
   * @param {string} key - Store cache key (schema+filter+options)
   * @param {Function} factory - Function that creates new ReactiveStore
   * @returns {ReactiveStore} ReactiveStore instance
   */
  getOrCreateStore(A, e) {
    return this.getOrCreate(`store:${A}`, e);
  }
  /**
   * Get existing resolution promise or create new one
   * 
   * @param {string} coId - CoValue ID
   * @param {Function} factory - Function that creates resolution Promise
   * @returns {Promise|true} Resolution promise or true if already resolved
   */
  getOrCreateResolution(A, e) {
    const t = `resolution:${A}`, o = this.cache.get(t);
    if (o === !0)
      return !0;
    if (o && typeof o.then == "function")
      return o;
    const r = e();
    return this.cache.set(t, r), r;
  }
  /**
   * Mark resolution as completed
   * 
   * @param {string} coId - CoValue ID
   */
  markResolved(A) {
    this.cache.set(`resolution:${A}`, !0);
  }
  /**
   * Check if CoValue is already resolved or being resolved
   * 
   * @param {string} coId - CoValue ID
   * @returns {boolean} True if already resolved or being resolved
   */
  isResolved(A) {
    const e = this.cache.get(`resolution:${A}`);
    return e === !0 || e && typeof e.then == "function";
  }
  /**
   * Get cached resolved+mapped data
   * 
   * @param {string} coId - CoValue ID
   * @param {Object} options - Options object (for cache key)
   * @returns {any|null} Cached resolved data or null
   */
  getResolvedData(A, e) {
    const t = `resolved:${A}:${JSON.stringify(e || {})}`, o = this.cache.get(t);
    return o && typeof o.then == "function" ? null : o || null;
  }
  /**
   * Get or create resolved data (prevents concurrent processing)
   * 
   * @param {string} coId - CoValue ID
   * @param {Object} options - Options object (for cache key)
   * @param {Function} factory - Async function that creates/resolves the data
   * @returns {Promise<any>} Resolved data (from cache or factory)
   */
  async getOrCreateResolvedData(A, e, t) {
    const o = `resolved:${A}:${JSON.stringify(e || {})}`;
    let r = this.cache.get(o);
    if (r && typeof r.then != "function")
      return r;
    if (r && typeof r.then == "function")
      try {
        return await r;
      } catch {
        this.cache.delete(o);
      }
    const s = (async () => {
      try {
        const g = await t();
        return this.cache.set(o, g), g;
      } catch (g) {
        throw this.cache.delete(o), g;
      }
    })();
    return this.cache.set(o, s), s;
  }
  /**
   * Cache resolved+mapped data
   * 
   * @param {string} coId - CoValue ID
   * @param {Object} options - Options object (for cache key)
   * @param {any} data - Resolved+mapped data to cache
   */
  setResolvedData(A, e, t) {
    const o = `resolved:${A}:${JSON.stringify(e || {})}`;
    this.cache.set(o, t);
  }
  /**
   * Invalidate all cached resolved data for a CoValue
   * Used when CoValue changes to force re-processing
   * 
   * @param {string} coId - CoValue ID
   */
  invalidateResolvedData(A) {
    const e = `resolved:${A}:`, t = [];
    for (const o of this.cache.keys())
      o.startsWith(e) && t.push(o);
    for (const o of t)
      this.cache.delete(o);
  }
  /**
   * Schedule cleanup for unused entry
   * 
   * @param {string} key - Cache key (MUST be namespaced)
   */
  scheduleCleanup(A) {
    this.cancelCleanup(A);
    const e = setTimeout(() => {
      this.destroy(A), this._maybeLogStats();
    }, this.cleanupTimeout);
    this.cleanupTimers.set(A, e);
  }
  /**
   * Debug: Log cache stats when window._maiaDebugSubscriptions is true
   * Helps diagnose subscription buildup / vibe freeze issues
   * @private
   */
  _maybeLogStats() {
    if (typeof window < "u" && window._maiaDebugSubscriptions) {
      const A = Array.from(this.cache.keys()).filter((t) => t.startsWith("subscription:")), e = Array.from(this.cache.keys()).filter((t) => t.startsWith("store:"));
      console.debug("[CoCache]", {
        cacheSize: this.cache.size,
        subscriptions: A.length,
        stores: e.length,
        pendingCleanups: this.cleanupTimers.size
      });
    }
  }
  /**
   * Debug: Warn when subscription count exceeds threshold (indicates possible leak)
   * Set window._maiaDebugSubscriptions = true; threshold via window._maiaDebugSubscriptionThreshold (default 80)
   * Throttled to once per 10s to avoid spam.
   * @private
   */
  _maybeWarnSubscriptionBuildup() {
    if (typeof window > "u" || !window._maiaDebugSubscriptions) return;
    const A = Array.from(this.cache.keys()).filter((o) => o.startsWith("subscription:")), e = window._maiaDebugSubscriptionThreshold ?? 80;
    if (A.length < e) return;
    const t = Date.now();
    this._lastBuildupWarn && t - this._lastBuildupWarn < 1e4 || (this._lastBuildupWarn = t, console.warn(`[CoCache] Subscription buildup: ${A.length} active (threshold ${e}). May cause freeze on tab switch.`));
  }
  /**
   * Cancel scheduled cleanup
   * 
   * @param {string} key - Cache key (MUST be namespaced)
   */
  cancelCleanup(A) {
    const e = this.cleanupTimers.get(A);
    e && (clearTimeout(e), this.cleanupTimers.delete(A));
  }
  /**
   * Manually destroy entry and remove from cache
   * 
   * @param {string} key - Cache key (MUST be namespaced)
   */
  destroy(A) {
    const e = this.cache.get(A);
    if (e) {
      if (e && typeof e == "object") {
        if (e.unsubscribe && typeof e.unsubscribe == "function")
          try {
            e.unsubscribe();
          } catch {
          }
        if (e._unsubscribe && typeof e._unsubscribe == "function")
          try {
            e._unsubscribe();
          } catch {
          }
      }
      this.cache.delete(A), this.cancelCleanup(A);
    }
  }
  /**
   * Check if entry exists in cache
   * 
   * @param {string} key - Cache key (MUST be namespaced)
   * @returns {boolean}
   */
  has(A) {
    return this.cache.has(A);
  }
  /**
   * Get entry from cache without creating
   * 
   * @param {string} key - Cache key (MUST be namespaced)
   * @returns {any|null} Entry or null
   */
  get(A) {
    return this.cache.get(A) || null;
  }
  /**
   * Get cache size (number of active entries)
   * 
   * @returns {number}
   */
  get size() {
    return this.cache.size;
  }
  /**
   * Debug: Get cache stats for subscription/freeze investigation
   * Call via: maia.dbEngine.backend.subscriptionCache.getStats()
   * @returns {{ cacheSize: number, subscriptions: number, stores: number, pendingCleanups: number }}
   */
  getStats() {
    const A = Array.from(this.cache.keys());
    return {
      cacheSize: this.cache.size,
      subscriptions: A.filter((e) => e.startsWith("subscription:")).length,
      stores: A.filter((e) => e.startsWith("store:")).length,
      pendingCleanups: this.cleanupTimers.size
    };
  }
  /**
   * Clear all entries and timers
   * 
   * Useful for cleanup on app shutdown or context switch
   * CRITICAL: Properly unsubscribes from all entries before clearing
   */
  clear() {
    const A = Array.from(this.cache.keys());
    for (const e of A)
      this.destroy(e);
    this.cache.clear(), this.cleanupTimers.clear();
  }
}
let qe = null, er = null;
function Va(i, A) {
  if (!i)
    throw new Error("[getGlobalCoCache] node is required for node-aware caching");
  return er !== i ? (qe && qe.clear(), er = i, qe = new Mr(A)) : qe || (er = i, qe = new Mr(A)), qe;
}
function kr(i, A = /* @__PURE__ */ new Set(), e = 0, t = 15) {
  const o = /* @__PURE__ */ new Set();
  if (e > t || !i || typeof i != "object")
    return o;
  if (Array.isArray(i)) {
    for (const r of i)
      kr(r, A, e + 1, t).forEach((g) => {
        A.has(g) || o.add(g);
      });
    return o;
  }
  for (const [r, s] of Object.entries(i))
    r === "id" || r === "$schema" || r === "type" || r === "loading" || r === "error" || (typeof s == "string" && s.startsWith("co_") ? A.has(s) || o.add(s) : typeof s == "object" && s !== null && kr(s, A, e + 1, t).forEach((n) => {
      A.has(n) || o.add(n);
    }));
  return o;
}
async function tt(i, A, e = /* @__PURE__ */ new Set(), t = {}) {
  const {
    maxDepth: o = 15,
    // TODO: temporarily scaled up from 10 for @maia spark detail
    timeoutMs: r = 5e3,
    // Kept for API compatibility but not used in progressive mode
    currentDepth: s = 0
  } = t, g = `[DeepResolution:depth${s}]`;
  if (s > o) {
    console.warn(`${g}  Max depth ${o} reached, stopping recursion`);
    return;
  }
  const n = kr(A, e, s, o);
  if (n.size === 0)
    return;
  const a = Array.from(n).map(async (I) => {
    if (!e.has(I)) {
      e.add(I);
      try {
        const C = i.getCoValue(I);
        if (!C)
          return;
        if (!i.isAvailable(C)) {
          aA(i, I, { waitForAvailable: !1 }).catch((f) => {
          });
          const Q = C.subscribe(async (f) => {
            if (i.isAvailable(f))
              try {
                const l = ee(i, f);
                await tt(i, l, e, {
                  maxDepth: o,
                  timeoutMs: r,
                  currentDepth: s + 1
                });
                const d = f.subscribe(() => {
                });
                i.subscriptionCache.getOrCreate(`subscription:${I}`, () => ({ unsubscribe: d })), Q();
              } catch {
              }
          });
          return;
        }
        const c = ee(i, C);
        await tt(i, c, e, {
          maxDepth: o,
          timeoutMs: r,
          currentDepth: s + 1
        });
        const B = C.subscribe(async (Q) => {
          if (i.isAvailable(Q))
            try {
              const f = ee(i, Q);
              tt(i, f, e, {
                maxDepth: o,
                timeoutMs: r,
                currentDepth: s + 1
              }).catch((l) => {
              });
            } catch {
            }
        });
        i.subscriptionCache.getOrCreate(`subscription:${I}`, () => ({ unsubscribe: B }));
      } catch {
      }
    }
  });
  Promise.all(a).catch((I) => {
  });
}
async function nQ(i, A, e = {}) {
  const {
    deepResolve: t = !0,
    maxDepth: o = 15,
    // TODO: temporarily scaled up from 10 for @maia spark detail
    timeoutMs: r = 5e3
  } = e;
  if (`${A.substring(0, 12)}`, !t)
    return;
  const s = i.subscriptionCache;
  if (s.isResolved(A))
    return;
  const g = s.getOrCreateResolution(A, () => (async () => {
    try {
      const n = Date.now();
      await aA(i, A, { waitForAvailable: !0, timeoutMs: r });
      const a = i.getCoValue(A);
      if (!a || !i.isAvailable(a))
        throw new Error(`CoValue ${A} failed to load`);
      const I = ee(i, a);
      tt(i, I, /* @__PURE__ */ new Set([A]), {
        maxDepth: o,
        timeoutMs: r,
        currentDepth: 0
      }).catch((c) => {
      }), s.markResolved(A);
    } catch (n) {
      throw s.destroy(`resolution:${A}`), n;
    }
  })());
  g !== !0 && await g;
}
async function aQ(i, A, e = {}) {
  return await tt(i, A, /* @__PURE__ */ new Set(), e);
}
async function IQ(i, A, e, t, o = {}) {
  const r = e.split(".");
  let s = A;
  for (const g of r) {
    if (s == null) return;
    const n = /^\d+$/.test(g) ? parseInt(g, 10) : g;
    let a = s[n];
    for (; typeof a == "string" && a.startsWith("co_z"); ) {
      if (t.has(a)) return;
      a = await sQ(i, a, o, t);
    }
    s = a;
  }
  return s;
}
async function Wa(i, A, e, t = {}) {
  if (!e || typeof e != "object")
    return A;
  const { timeoutMs: o = 2e3 } = t, r = /* @__PURE__ */ new Set(), s = { ...A }, g = /* @__PURE__ */ new Set();
  for (const [n, a] of Object.entries(e))
    try {
      if (typeof a != "string" || !a.startsWith("$$"))
        throw new Error(`Map expression for "${n}" must use strict $$ syntax. Got: "${a}". Expected format: "$$property.path"`);
      const I = a.substring(2), C = I.split(".")[0];
      if (C && C in A) {
        const B = A[C];
        B && typeof B == "string" && B.startsWith("co_z") && g.add(C);
      }
      const c = await IQ(i, A, I, r, { timeoutMs: o });
      s[n] = c;
    } catch (I) {
      console.warn(`[applyMapTransform] Failed to evaluate expression "${a}" for field "${n}":`, I), s[n] = void 0;
    }
  for (const n of g)
    delete s[n];
  return s;
}
async function ot(i, A, e) {
  if (typeof i == "string" && i.startsWith("$"))
    return await A.evaluate(i, e);
  if (i === null || typeof i != "object")
    return i;
  if (Array.isArray(i))
    return Promise.all(i.map((r) => ot(r, A, e)));
  const t = Object.keys(i);
  if (t.length === 1 && t[0].startsWith("$"))
    return await A.evaluate(i, e);
  const o = {};
  for (const [r, s] of Object.entries(i))
    s && typeof s == "object" ? A.isDSLOperation(s) ? o[r] = await A.evaluate(s, e) : o[r] = await ot(s, A, e) : o[r] = await A.evaluate(s, e);
  return o;
}
function rt(i) {
  if (i == null)
    return !1;
  if (typeof i == "string")
    return !!(i.startsWith("$") || i.includes("?") && i.includes(":"));
  if (typeof i != "object")
    return !1;
  if (Array.isArray(i))
    return i.some((e) => rt(e));
  const A = Object.keys(i);
  if (A.length === 1 && A[0].startsWith("$"))
    return !0;
  for (const [e, t] of Object.entries(i))
    if (rt(t))
      return !0;
  return !1;
}
function tr(i, A) {
  return !i || i.loading || i.error ? !1 : i.hasProperties !== !1 || i.properties || typeof i == "object" && Object.keys(i).length > 0 && i.id;
}
async function uA(i, A, e = 5e3) {
  const t = i.value;
  if (!tr(t)) {
    if (t?.error) throw new Error(`CoValue error (co-id: ${A}): ${t.error}`);
    return new Promise((o, r) => {
      let s = !1, g;
      g = i.subscribe((a) => {
        if (!s) {
          if (a?.error) {
            s = !0, g(), r(new Error(`CoValue error (co-id: ${A}): ${a.error}`));
            return;
          }
          tr(a) && (s = !0, g(), o());
        }
      });
      const n = i.value;
      n?.error ? (s = !0, g(), r(new Error(`CoValue error (co-id: ${A}): ${n.error}`))) : tr(n) && (s = !0, g(), o()), setTimeout(() => {
        s || (s = !0, g(), r(new Error(`CoValue timeout loading (co-id: ${A}). Make sure the CoValue was seeded correctly.`)));
      }, e);
    });
  }
}
function Qe(i, A = {}) {
  const { timeoutMs: e = 1e4 } = A, t = i.value;
  return t?.loading ? new Promise((o, r) => {
    let s;
    const g = setTimeout(() => {
      s && s(), r(new Error(`Timeout waiting for reactive resolution after ${e}ms`));
    }, e);
    s = i.subscribe((n) => {
      n.loading || (clearTimeout(g), s && s(), n.error ? r(new Error(n.error)) : o(n));
    });
  }) : t?.error ? Promise.reject(new Error(t.error)) : Promise.resolve(t);
}
const CQ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  waitForReactiveResolution: Qe,
  waitForStoreReady: uA
}, Symbol.toStringTag, { value: "Module" }));
async function IA(i, A = null, e = null, t = null, o = null, r = {}) {
  const {
    deepResolve: s = !0,
    maxDepth: g = 15,
    // TODO: temporarily scaled up from 10 for @maia spark detail deep resolution
    timeoutMs: n = 5e3,
    resolveReferences: a = null,
    map: I = null,
    onChange: C = null
  } = r, c = { deepResolve: s, maxDepth: g, timeoutMs: n, resolveReferences: a, map: I, onChange: C };
  if (A)
    return await oo(i, A, o || e, c);
  if (e) {
    const B = await eA(i, "@maia/schema/data/spark", { returnType: "coId" }), Q = await eA(i, e, { returnType: "coId" });
    return B && Q === B ? await cQ(i, c) : await BQ(i, e, t, c);
  }
  return await QQ(i, t, { deepResolve: s, maxDepth: g, timeoutMs: n });
}
async function ir(i, A, e) {
  return !i || typeof i != "object" ? i : await ot(i, e, { context: A, item: {} });
}
async function ti(i, A, e = {}) {
  const t = new pA({}), o = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), g = /* @__PURE__ */ new Map(), { timeoutMs: n = 5e3, onChange: a } = e, { Evaluator: I } = await Promise.resolve().then(() => iD), C = new I();
  let c = null, B = null;
  const Q = () => {
    B || (B = queueMicrotask(() => {
      B = null;
      const h = { ...A.value || {} };
      delete h["@stores"];
      const w = {};
      for (const [y, m] of r.entries())
        w[y] = m;
      Object.keys(w).length > 0 && (h.$op = w);
      for (const [y, m] of o.entries())
        if (m && typeof m.subscribe == "function" && "value" in m) {
          delete h[y];
          const N = s.get(y) || !1, R = m.value;
          N ? Array.isArray(R) ? h[y] = R.length > 0 ? R[0] : null : R && typeof R == "object" ? h[y] = R : h[y] = null : h[y] = R;
        }
      const E = JSON.stringify(h), p = c ? JSON.stringify(c) : null;
      E !== p && (c = h, t._set(h));
    }));
  }, f = async (u) => {
    if (!u || typeof u != "object" || Array.isArray(u)) {
      Q();
      return;
    }
    const h = /* @__PURE__ */ new Set();
    for (const [w, E] of Object.entries(u))
      if (!(w === "$schema" || w === "$id" || w === "@stores" || w === "properties" || w === "items" || w === "$defs" || w === "cotype" || w === "indexing" || w === "title" || w === "description") && E && typeof E == "object" && !Array.isArray(E) && E.schema) {
        h.add(w);
        const p = o.get(w), y = await ir(E.filter || null, u, C), m = y && typeof y == "object" && Object.keys(y).length === 1 && y.id && typeof y.id == "string" && y.id.startsWith("co_z"), N = m ? y.id : null, L = r.get(w)?.filter || null, j = JSON.stringify(y) !== JSON.stringify(L);
        try {
          let J = E.schema;
          if (J && typeof J == "object" && J.$id && (J = J.$id), typeof J != "string") {
            process.env.DEBUG && console.error(`[createUnifiedStore] Invalid schema type for query "${w}": expected string, got ${typeof J}`, J);
            continue;
          }
          if (J.startsWith("co_z")) {
            if (J && typeof J == "string" && J.startsWith("co_z") && (j || !p)) {
              p && p._queryUnsubscribe && p._queryUnsubscribe();
              const z = {
                ...e,
                timeoutMs: n,
                ...E.options || {}
              }, X = m && N ? await IA(i, N, J, null, null, z) : await IA(i, null, J, y, null, z);
              s.set(w, m), r.set(w, {
                schema: E.schema,
                ...E.options ? { options: E.options } : {},
                filter: y
              });
              const Z = X.subscribe(() => {
                Q();
              });
              X._queryUnsubscribe = Z, o.set(w, X);
            }
          } else if (J.startsWith("@maia/schema/")) {
            const X = Ae(i, J, { timeoutMs: n }).subscribe(async (Z) => {
              if (Z.loading) {
                if (!o.has(w)) {
                  const T = await ir(E.filter || null, u, C), $ = T && typeof T == "object" && Object.keys(T).length === 1 && T.id && typeof T.id == "string" && T.id.startsWith("co_z"), O = new pA($ ? null : []);
                  o.set(w, O), s.set(w, $), r.set(w, {
                    schema: E.schema,
                    ...E.options ? { options: E.options } : {},
                    filter: T
                  }), Q();
                }
                return;
              }
              if (Z.error || !Z.schemaCoId) {
                process.env.DEBUG && console.error(`[createUnifiedStore] Failed to resolve schema ${E.schema} for query "${w}": ${Z.error || "Schema not found"}`), X();
                return;
              }
              const _ = Z.schemaCoId;
              try {
                const T = {
                  ...e,
                  timeoutMs: n,
                  ...E.options || {}
                }, $ = await ir(E.filter || null, u, C), O = $ && typeof $ == "object" && Object.keys($).length === 1 && $.id && typeof $.id == "string" && $.id.startsWith("co_z"), F = O ? $.id : null, b = r.get(w)?.filter || null;
                if (JSON.stringify($) !== JSON.stringify(b) || !o.has(w)) {
                  const M = o.get(w);
                  M && M._queryUnsubscribe && M._queryUnsubscribe();
                  const U = O && F ? await IA(i, F, _, null, null, T) : await IA(i, null, _, $, null, T);
                  s.set(w, O), r.set(w, {
                    schema: E.schema,
                    ...E.options ? { options: E.options } : {},
                    filter: $
                  });
                  const P = U.subscribe(() => {
                    Q();
                  });
                  U._queryUnsubscribe = P, o.set(w, U), Q();
                }
                X();
              } catch (T) {
                process.env.DEBUG && console.error(`[createUnifiedStore] Failed to execute query "${w}" after schema resolution:`, T), X();
              }
            });
            g.set(w, X);
            continue;
          } else {
            process.env.DEBUG && console.error(`[createUnifiedStore] Invalid schema format for query "${w}": ${J}`);
            continue;
          }
        } catch (J) {
          process.env.DEBUG && console.error(`[createUnifiedStore] Failed to resolve query "${w}":`, J);
        }
      }
    for (const [w, E] of o.entries())
      h.has(w) || (E._queryUnsubscribe && (E._queryUnsubscribe(), delete E._queryUnsubscribe), o.delete(w), r.delete(w), s.delete(w));
    for (const [w, E] of g.entries())
      h.has(w) || (E && E(), g.delete(w));
    Q();
  }, l = A.subscribe(async (u) => {
    await f(u);
  }), d = t._unsubscribe;
  return t._unsubscribe = () => {
    d && d(), l();
    for (const u of g.values())
      u && u();
    g.clear();
    for (const u of o.values())
      u._queryUnsubscribe && (u._queryUnsubscribe(), delete u._queryUnsubscribe), u._cacheKey && i.subscriptionCache && i.subscriptionCache.scheduleCleanup(u._cacheKey);
    o.clear();
  }, await f(A.value), t;
}
function Qg(i, A) {
  if (!A || typeof A != "object" || !i || typeof i != "object")
    return /* @__PURE__ */ new Set();
  const e = /* @__PURE__ */ new Set();
  for (const t of Object.values(A))
    if (typeof t == "string" && t.startsWith("$$")) {
      const o = t.substring(2).split(".")[0];
      if (o && o in i) {
        const r = i[o];
        typeof r == "string" && r.startsWith("co_z") && e.add(r);
      }
    }
  return e;
}
async function Eg(i, A, e, t, o = /* @__PURE__ */ new Set()) {
  const {
    deepResolve: r = !0,
    maxDepth: s = 15,
    // TODO: temporarily scaled up from 10 for @maia spark detail deep resolution
    timeoutMs: g = 5e3,
    resolveReferences: n = null,
    map: a = null
  } = t;
  let I = ee(i, A, e);
  if (r)
    try {
      nQ(i, A.id, { deepResolve: r, maxDepth: s, timeoutMs: g }).catch((C) => {
      });
    } catch {
    }
  if (n)
    try {
      const C = { ...n, timeoutMs: g };
      I = await Jt(i, I, C, o, s, 0);
    } catch {
    }
  if (a)
    try {
      I = await Wa(i, I, a, { timeoutMs: g });
    } catch (C) {
      process.env.DEBUG && console.warn("[processCoValueData] Failed to apply map transform:", C);
    }
  return I;
}
async function oo(i, A, e = null, t = {}) {
  const {
    deepResolve: o = !0,
    maxDepth: r = 15,
    // TODO: temporarily scaled up from 10 for @maia spark detail deep resolution
    timeoutMs: s = 5e3,
    resolveReferences: g = null,
    map: n = null
  } = t, a = i.subscriptionCache, I = { deepResolve: o, resolveReferences: g, map: n, maxDepth: r, timeoutMs: s }, C = a.getResolvedData(A, I);
  if (C) {
    const E = C && typeof C == "object" && Object.values(C).some(
      (m) => m && typeof m == "object" && !Array.isArray(m) && m.schema
    ), p = new pA(C), y = i.getCoValue(A);
    if (y) {
      const m = async (J) => {
        const z = await Eg(i, J, e, t, /* @__PURE__ */ new Set());
        return a.setResolvedData(A, I, z), z;
      }, N = /* @__PURE__ */ new Map(), R = (J) => {
        if (!n) return;
        const z = ee(i, J, e), X = Qg(z, n);
        for (const Z of X) {
          if (N.has(Z)) continue;
          const _ = i.getCoValue(Z);
          if (!_) continue;
          const T = _.subscribe(async () => {
            if (!J.isAvailable()) return;
            a.invalidateResolvedData(Z);
            const $ = await m(J);
            p._set($);
          });
          N.set(Z, T);
        }
        for (const [Z, _] of N.entries())
          X.has(Z) || (_(), N.delete(Z));
      }, L = y.subscribe(async (J) => {
        if (J.isAvailable()) {
          const z = await m(J);
          R(J), p._set(z);
        }
      });
      if (R(y), i.subscriptionCache.getOrCreate(`subscription:${A}`, () => ({ unsubscribe: L })), E) {
        const J = await ti(i, p, t), z = J._unsubscribe;
        return J._unsubscribe = () => {
          z && z(), L();
          for (const X of N.values()) X();
          N.clear(), i.subscriptionCache.scheduleCleanup(`subscription:${A}`);
        }, J;
      }
      const j = p._unsubscribe;
      p._unsubscribe = () => {
        j && j(), L();
        for (const J of N.values()) J();
        N.clear(), i.subscriptionCache.scheduleCleanup(`subscription:${A}`);
      };
    }
    return E ? await ti(i, p, t) : p;
  }
  const c = i.getCoValue(A);
  if (!c)
    return new pA({ error: "CoValue not found", id: A });
  const B = async (E) => {
    const p = await Eg(i, E, e, t, /* @__PURE__ */ new Set());
    return a.setResolvedData(A, I, p), p;
  }, Q = /* @__PURE__ */ new Map(), f = new pA(null);
  let l = null, d = null;
  const u = (E) => {
    if (!n) return;
    const p = ee(i, E, e), y = Qg(p, n);
    for (const m of y) {
      if (Q.has(m)) continue;
      const N = i.getCoValue(m);
      if (!N) continue;
      const R = N.subscribe(async () => {
        if (!E.isAvailable()) return;
        a.invalidateResolvedData(m);
        const L = await B(E);
        d ? d._set(L) : f._set(L);
      });
      Q.set(m, R);
    }
    for (const [m, N] of Q.entries())
      y.has(m) || (N(), Q.delete(m));
  }, h = c.subscribe(async (E) => {
    if (!E.isAvailable()) {
      f._set({ id: A, loading: !0 });
      return;
    }
    const p = await B(E);
    if (u(E), p && typeof p == "object" && Object.values(p).some(
      (m) => m && typeof m == "object" && !Array.isArray(m) && m.schema
    ))
      if (d)
        d._set(p);
      else {
        d = new pA(p);
        const m = await ti(i, d, t);
        l = m.subscribe((N) => f._set(N)), f._set(m.value);
      }
    else
      f._set(p);
  });
  if (i.subscriptionCache.getOrCreate(`subscription:${A}`, () => ({ unsubscribe: h })), c.isAvailable()) {
    const E = await B(c);
    if (u(c), E && typeof E == "object" && Object.values(E).some(
      (m) => m && typeof m == "object" && !Array.isArray(m) && m.schema
    )) {
      f._set(E);
      const m = await ti(i, f, t), N = m._unsubscribe;
      return m._unsubscribe = () => {
        N && N(), h();
        for (const R of Q.values()) R();
        Q.clear(), i.subscriptionCache.scheduleCleanup(`subscription:${A}`);
      }, m;
    }
    f._set(E);
    const y = f._unsubscribe;
    return f._unsubscribe = () => {
      y && y(), h();
      for (const m of Q.values()) m();
      Q.clear(), i.subscriptionCache.scheduleCleanup(`subscription:${A}`);
    }, f;
  }
  f._set({ id: A, loading: !0 }), aA(i, A).then(() => {
  }).catch((E) => {
    f._set({ error: E.message, id: A });
  });
  const w = f._unsubscribe;
  return f._unsubscribe = () => {
    w && w(), l && (l(), l = null), h();
    for (const E of Q.values()) E();
    Q.clear(), i.subscriptionCache.scheduleCleanup(`subscription:${A}`);
  }, f;
}
async function cQ(i, A = {}) {
  const { deepResolve: e = !0, maxDepth: t = 15, timeoutMs: o = 5e3 } = A, r = i.subscriptionCache.getOrCreateStore("sparks:account", () => new pA([])), s = i.account?.get?.("sparks");
  if (!s || !s.startsWith("co_"))
    return r;
  const g = async () => {
    const I = await oo(i, s, null, { deepResolve: !1 });
    try {
      await uA(I, s, o);
    } catch {
      return;
    }
    const C = I?.value ?? {};
    if (C?.error) return;
    const c = [];
    for (const Q of Object.keys(C)) {
      if (Q === "id" || Q === "loading" || Q === "error" || Q === "$schema" || Q === "type") continue;
      const f = C[Q], l = typeof f == "string" && f.startsWith("co_") ? f : Q.startsWith("co_") ? Q : null;
      l && c.push(l);
    }
    const B = [];
    for (const Q of c)
      try {
        const f = await oo(i, Q, null, { deepResolve: e, maxDepth: t, timeoutMs: o });
        await uA(f, Q, Math.min(o, 2e3));
        const l = f?.value;
        l && !l.error && B.push({ id: Q, name: l.name ?? Q, ...l });
      } catch {
        B.push({ id: Q, name: Q });
      }
    r._set(B);
  };
  await g();
  const a = (await oo(i, s, null, { deepResolve: !1 }))?.subscribe?.(() => g());
  return a && i.subscriptionCache.getOrCreate(`subscription:sparks:${s}`, () => ({ unsubscribe: a })), r;
}
async function BQ(i, A, e = null, t = {}) {
  const {
    deepResolve: o = !0,
    maxDepth: r = 15,
    // TODO: temporarily scaled up from 10 for @maia spark detail deep resolution
    timeoutMs: s = 5e3,
    resolveReferences: g = null,
    map: n = null
  } = t, a = t && (t.map || t.resolveReferences) ? JSON.stringify({ map: t.map || null, resolveReferences: t.resolveReferences || null }) : "", I = `${A}:${JSON.stringify(e || {})}:${a}`, C = i.subscriptionCache.getOrCreateStore(I, () => {
    const E = new pA([]);
    return E._cacheKey = `store:${I}`, E;
  }), c = await Bs(i, A);
  if (!c)
    return C;
  let B = i.getCoValue(c);
  if (!B)
    return C;
  const Q = /* @__PURE__ */ new Set(), f = /* @__PURE__ */ new Set(), l = i.subscriptionCache;
  let d = async () => {
  };
  if (!i.isAvailable(B)) {
    if (aA(i, c, { waitForAvailable: !1 }).catch((E) => {
      process.env.DEBUG && console.warn(`[readCollection] Failed to load CoList ${c.substring(0, 12)}...:`, E);
    }), B) {
      const E = B.subscribe((p) => {
        p && i.isAvailable(p) && d().catch((y) => {
          process.env.DEBUG && console.warn("[readCollection] Error updating store after colist load:", y);
        });
      });
      i.subscriptionCache.getOrCreate(`subscription:${c}`, () => ({ unsubscribe: E }));
    }
    return C;
  }
  const u = (E) => {
    if (Q.has(E))
      return;
    Q.add(E);
    const p = i.getCoValue(E);
    if (!p || !i.isAvailable(p)) {
      aA(i, E, { waitForAvailable: !0, timeoutMs: 2e3 }).then(() => {
        const m = i.getCoValue(E);
        if (m && i.isAvailable(m)) {
          const N = m.subscribe(() => {
            l.invalidateResolvedData(E), d && d().catch((R) => {
              process.env.DEBUG && console.warn("[CoJSONBackend] Error updating store:", R);
            });
          });
          i.subscriptionCache.getOrCreate(`subscription:${E}`, () => ({ unsubscribe: N })), d && d().catch((R) => {
            process.env.DEBUG && console.warn("[CoJSONBackend] Error updating store after item load:", R);
          });
        }
      }).catch((m) => {
        process.env.DEBUG && console.error(`[CoJSONBackend] Failed to load item ${E}:`, m);
      });
      return;
    }
    const y = p.subscribe(() => {
      l.invalidateResolvedData(E), d && d().catch((m) => {
        process.env.DEBUG && console.warn("[CoJSONBackend] Error updating store:", m);
      });
    });
    i.subscriptionCache.getOrCreate(`subscription:${E}`, () => ({ unsubscribe: y }));
  };
  d = async () => {
    const E = [];
    if (!i.isAvailable(B)) {
      aA(i, c).catch((y) => {
        process.env.DEBUG && console.error("[readCollection] Failed to reload CoList:", y);
      });
      return;
    }
    const p = i.getCurrentContent(B);
    if (!(!p || !p.toJSON)) {
      try {
        const y = p.toJSON();
        let m = 0, N = 0;
        for (const R of y) {
          if (typeof R != "string" || !R.startsWith("co_"))
            continue;
          u(R);
          const L = i.getCoValue(R);
          if (!L) {
            N++;
            continue;
          }
          if (i.isAvailable(L)) {
            m++;
            const j = { deepResolve: o, resolveReferences: g, map: n, maxDepth: r, timeoutMs: s }, J = i.getCoValue(R);
            if (!J || !i.isAvailable(J))
              continue;
            const z = await l.getOrCreateResolvedData(R, j, async () => {
              let Z = ee(i, J);
              if (Object.keys(Z).filter(
                (T) => !["id", "type", "$schema"].includes(T)
              ).length === 0 && Z.type === "comap")
                return Z;
              if (o && !n && !l.isResolved(R))
                try {
                  await tt(i, Z, f, {
                    maxDepth: r,
                    timeoutMs: s,
                    currentDepth: 0
                  });
                } catch {
                }
              if (g)
                try {
                  const T = { ...g, timeoutMs: s }, $ = await Jt(i, Z, T, f, r, 0);
                  Object.assign(Z, $);
                } catch {
                }
              if (n)
                try {
                  Z = await Wa(i, Z, n, { timeoutMs: s });
                } catch (T) {
                  process.env.DEBUG && console.warn("[readCollection] Failed to apply map transform:", T);
                }
              return Z;
            });
            if (Object.keys(z).filter(
              (Z) => !["id", "type", "$schema"].includes(Z)
            ).length === 0 && z.type === "comap")
              continue;
            (!e || ja(z, e)) && E.push(z);
          } else
            N++;
        }
      } catch (y) {
        process.env.DEBUG && console.warn("[readCollection] Error reading CoList items:", y);
      }
      C._set(E);
    }
  };
  const h = B.subscribe(() => {
    d().catch((E) => {
      process.env.DEBUG && console.warn("[CoJSONBackend] Error updating store:", E);
    });
  });
  if (i.subscriptionCache.getOrCreate(`subscription:${c}`, () => ({ unsubscribe: h })), i.isAvailable(B)) {
    const E = i.getCurrentContent(B);
    if (E && E.toJSON)
      try {
        const p = E.toJSON();
        for (const y of p)
          if (typeof y == "string" && y.startsWith("co_")) {
            const m = i.getCoValue(y);
            m && !i.isAvailable(m) && aA(i, y).catch((N) => {
              process.env.DEBUG && console.error(`[CoJSONBackend] Failed to load item ${y}:`, N);
            });
          }
      } catch {
      }
  }
  await d();
  const w = C._unsubscribe;
  return C._unsubscribe = () => {
    i.subscriptionCache.scheduleCleanup(`store:${I}`), w && w(), i.subscriptionCache.scheduleCleanup(`subscription:${c}`);
    for (const E of Q)
      i.subscriptionCache.scheduleCleanup(`subscription:${E}`);
  }, C;
}
async function QQ(i, A = null, e = {}) {
  const {
    deepResolve: t = !0,
    maxDepth: o = 15,
    // TODO: temporarily scaled up from 10 for @maia spark detail deep resolution
    timeoutMs: r = 5e3
  } = e, s = new pA([]), g = /* @__PURE__ */ new Set();
  let n = async () => {
  };
  const a = (C, c) => {
    if (g.has(C))
      return;
    g.add(C);
    const B = c.subscribe(() => {
      n();
    });
    i.subscriptionCache.getOrCreate(`subscription:${C}`, () => ({ unsubscribe: B }));
  };
  n = async () => {
    const C = i.getAllCoValues(), c = [];
    for (const [B, Q] of C.entries()) {
      if (!B || typeof B != "string" || !B.startsWith("co_"))
        continue;
      if (a(B, Q), !i.isAvailable(Q)) {
        aA(i, B).catch((d) => {
          process.env.DEBUG && console.error(`[CoJSONBackend] Failed to load CoValue ${B}:`, d);
        });
        continue;
      }
      const f = ee(i, Q);
      if (!(Object.keys(f).filter(
        (d) => !["id", "type", "$schema"].includes(d)
      ).length === 0 && f.type === "comap")) {
        if (t)
          try {
            await aQ(i, f, { maxDepth: o, timeoutMs: r });
          } catch {
          }
        (!A || ja(f, A)) && c.push(f);
      }
    }
    s._set(c);
  }, await n();
  const I = s._unsubscribe;
  return s._unsubscribe = () => {
    I && I();
    for (const C of g)
      i.subscriptionCache.scheduleCleanup(`subscription:${C}`);
  }, s;
}
function Rt(i, A, e = {}) {
  const { timeoutMs: t = 1e4 } = e, o = new pA({ loading: !0 });
  if (A.startsWith("co_z"))
    return o._set({ loading: !1, schemaCoId: A }), o;
  let r = null, s = null;
  const g = async () => {
    const { getSparkOsId: n } = await Promise.resolve().then(() => ue), a = i?.systemSpark ?? "@maia", I = await n(i, a);
    if (!I || typeof I != "string" || !I.startsWith("co_z")) {
      o._set({ loading: !1, error: "spark.os not found" });
      return;
    }
    r = (await IA(i, I, null, null, null, {
      deepResolve: !1,
      timeoutMs: t
    })).subscribe(async (B) => {
      if (!B || B.error)
        return;
      const Q = B.schematas;
      !Q || typeof Q != "string" || !Q.startsWith("co_z") || s || (s = (await IA(i, Q, null, null, null, {
        deepResolve: !1,
        timeoutMs: t
      })).subscribe((l) => {
        if (!l || l.error)
          return;
        const d = A.startsWith("@maia/schema/") ? A : `@maia/schema/${A}`, u = l[d] || l[A];
        u && typeof u == "string" && u.startsWith("co_z") && (o._set({ loading: !1, schemaCoId: u }), s && (s(), s = null), r && (r(), r = null));
      }));
    });
    const c = o._unsubscribe;
    o._unsubscribe = () => {
      c && c(), s && (s(), s = null), r && (r(), r = null);
    };
  };
  return eA(i, A, { returnType: "coId", timeoutMs: 2e3 }).then((n) => {
    n && n.startsWith("co_z") ? o._set({ loading: !1, schemaCoId: n }) : g().catch((a) => {
      o._set({ loading: !1, error: a.message });
    });
  }).catch(() => {
    g().catch((n) => {
      o._set({ loading: !1, error: n.message });
    });
  }), o;
}
function Gr(i, A, e = {}) {
  const t = new pA({ loading: !0 });
  if (!A || !A.startsWith("co_z"))
    return t._set({ loading: !1, error: "Invalid co-id" }), t;
  const o = i.getCoValue(A);
  if (!o)
    return t._set({ loading: !1, error: "CoValueCore not found" }), t;
  if (i.isAvailable(o))
    return t._set({ loading: !1, coValueCore: o }), t;
  aA(i, A, { waitForAvailable: !1 }).catch((g) => {
  });
  const r = o.subscribe((g) => {
    i.isAvailable(g) && (t._set({ loading: !1, coValueCore: g }), r());
  }), s = t._unsubscribe;
  return t._unsubscribe = () => {
    s && s(), r();
  }, t;
}
function za(i, A, e = {}) {
  const t = new pA({ loading: !0, items: [] });
  if (!A || !A.schema)
    return t._set({ loading: !1, items: [], error: "Invalid query definition" }), t;
  const r = Rt(i, A.schema, e).subscribe(async (s) => {
    if (!s.loading) {
      if (s.error || !s.schemaCoId) {
        t._set({ loading: !1, items: [], error: s.error || "Schema not found" }), r();
        return;
      }
      try {
        const n = (await IA(
          i,
          null,
          s.schemaCoId,
          A.filter || null,
          null,
          {
            ...e,
            ...A.options || {}
          }
        )).subscribe((I) => {
          const C = Array.isArray(I) ? I : I?.items || [];
          t._set({ loading: !1, items: C });
        }), a = t._unsubscribe;
        t._unsubscribe = () => {
          a && a(), n(), r();
        };
      } catch (g) {
        t._set({ loading: !1, items: [], error: g.message }), r();
      }
    }
  });
  return t;
}
function EQ(i, A, e = {}) {
  if (A && typeof A == "object" && !Array.isArray(A)) {
    if (A.schema)
      return za(i, A, e);
    if (A.fromCoValue) {
      const o = Gr(i, A.fromCoValue, e), r = new pA({ loading: !0 });
      let s, g, n;
      s = o.subscribe(async (I) => {
        if (I.loading)
          return;
        if (I.error || !I.coValueCore) {
          r._set({ loading: !1, error: I.error || "CoValue not found" }), s && s();
          return;
        }
        const B = (i.getHeader(I.coValueCore)?.meta || null)?.$schema || null;
        B && typeof B == "string" && B.startsWith("co_z") ? g = Rt(i, B, e).subscribe((f) => {
          r._set(f), f.loading || (g && g(), s && s());
        }) : n = I.coValueCore.subscribe((Q) => {
          const d = (i.getHeader(Q)?.meta || null)?.$schema || null;
          d && typeof d == "string" && d.startsWith("co_z") && (g = Rt(i, d, e).subscribe((h) => {
            r._set(h), h.loading || (g && g(), n && n(), s && s());
          }));
        });
      });
      const a = r._unsubscribe;
      return r._unsubscribe = () => {
        a && a(), s && s(), g && g(), n && n();
      }, r;
    }
  }
  return typeof A == "string" ? A.startsWith("co_z") ? Gr(i, A, e) : Rt(i, A, e) : new pA({ loading: !1, error: "Invalid identifier" });
}
function Fr(i, A = !1) {
  if (i == null || typeof i != "object")
    return i;
  if (Array.isArray(i))
    return i.map((t) => Fr(t, A));
  const e = {};
  for (const [t, o] of Object.entries(i))
    if (!(t === "id" && !A))
      if (o != null && typeof o == "object") {
        const r = t === "properties" || t === "items";
        e[t] = Fr(o, r || A);
      } else
        e[t] = o;
  return e;
}
const or = /^@[a-zA-Z0-9_-]+\/schema\//, Et = /^@[a-zA-Z0-9_-]+\/vibe\//;
async function eA(i, A, e = {}) {
  const {
    returnType: t = "schema",
    deepResolve: o = !1,
    timeoutMs: r = 5e3,
    spark: s
  } = e;
  if (!i)
    throw new Error("[resolve] backend is required");
  if (A && typeof A == "object" && !Array.isArray(A)) {
    if (A.fromCoValue) {
      if (!A.fromCoValue.startsWith("co_z"))
        throw new Error(`[resolve] fromCoValue must be a valid co-id (co_z...), got: ${A.fromCoValue}`);
      const I = await IA(i, A.fromCoValue, null, null, null, {
        deepResolve: !1,
        timeoutMs: r
      });
      try {
        await uA(I, A.fromCoValue, r);
      } catch {
        return null;
      }
      const C = I.value;
      if (!C || C.error)
        return null;
      const c = C.$schema || null;
      return c ? t === "coId" ? c : await eA(i, c, { returnType: t, deepResolve: o, timeoutMs: r }) : null;
    }
    throw new Error('[resolve] Invalid identifier object. Expected { fromCoValue: "co_z..." }');
  }
  if (typeof A != "string")
    throw new Error(`[resolve] Invalid identifier type. Expected string or object, got: ${typeof A}`);
  if (A.startsWith("co_z")) {
    const I = await IA(i, A, null, null, null, {
      deepResolve: o,
      timeoutMs: r
    });
    try {
      await uA(I, A, r);
    } catch {
      return null;
    }
    const C = I.value;
    if (!C || C.error)
      return null;
    if (t === "coValue")
      return I;
    if (t === "coId")
      return A;
    const c = C.cotype, B = C.properties, Q = C.items, f = C.title;
    if (c || B || Q || f) {
      const { id: d, type: u, ...h } = C;
      return {
        ...Fr(h),
        $id: A
        // Ensure $id is set
      };
    }
    return null;
  }
  const g = or.test(A), n = Et.test(A), a = !A.startsWith("@") && !A.startsWith("co_z");
  if (g || n || a) {
    const I = s ?? i?.systemSpark;
    if (!I && (g || n || a))
      throw new Error(`[resolve] spark required for registry lookup of ${A}. Pass options.spark or set backend.systemSpark.`);
    let C = A;
    if (!or.test(C) && !Et.test(C) && !C.startsWith("@") && (C = `@${I?.replace(/^@/, "") ?? "maia"}/schema/${C}`), !i.account || typeof i.account.get != "function")
      return console.warn("[resolve] Account not available for registry lookup"), null;
    if (or.test(C)) {
      const B = i.account.get("sparks");
      if (!B || typeof B != "string" || !B.startsWith("co_z"))
        return null;
      const Q = await IA(i, B, null, null, null, {
        deepResolve: !1,
        timeoutMs: r
      });
      try {
        await uA(Q, B, r);
      } catch {
        return null;
      }
      const f = Q.value;
      if (!f || f.error) return null;
      const l = f[I];
      if (!l || typeof l != "string" || !l.startsWith("co_z"))
        return null;
      const d = await IA(i, l, null, null, null, {
        deepResolve: !1,
        timeoutMs: r
      });
      try {
        await uA(d, l, r);
      } catch {
        return null;
      }
      const u = d.value;
      if (!u || u.error) return null;
      const h = u.os;
      if (!h || typeof h != "string" || !h.startsWith("co_z"))
        return null;
      const w = await IA(i, h, null, null, null, {
        deepResolve: !1,
        timeoutMs: r
      });
      try {
        await uA(w, h, r);
      } catch {
        return null;
      }
      const E = w.value;
      if (!E || E.error)
        return null;
      const p = E.schematas;
      if (!p || typeof p != "string" || !p.startsWith("co_z"))
        return null;
      const y = await IA(i, p, null, null, null, {
        deepResolve: !1,
        timeoutMs: r
      });
      try {
        await uA(y, p, r);
      } catch {
        return null;
      }
      const m = y.value;
      if (!m || m.error)
        return null;
      const N = m[C] || m[A];
      return N && typeof N == "string" && N.startsWith("co_z") ? t === "coId" ? N : await eA(i, N, { returnType: t, deepResolve: o, timeoutMs: r }) : (/^@[a-zA-Z0-9_-]+\/schema\/index\//.test(C) || console.warn(`[resolve] Schema "${A}" not found in registry`), null);
    } else if (Et.test(A) || !A.startsWith("@")) {
      const B = i.account.get("sparks");
      if (!B || typeof B != "string" || !B.startsWith("co_z"))
        return null;
      const Q = await IA(i, B, null, null, null, {
        deepResolve: !1,
        timeoutMs: r
      });
      try {
        await uA(Q, B, r);
      } catch {
        return null;
      }
      const f = Q.value;
      if (!f || f.error) return null;
      const l = f[I];
      if (!l || typeof l != "string" || !l.startsWith("co_z"))
        return null;
      const d = await IA(i, l, null, null, null, {
        deepResolve: !1,
        timeoutMs: r
      });
      try {
        await uA(d, l, r);
      } catch {
        return null;
      }
      const u = d.value;
      if (!u || u.error) return null;
      const h = u.vibes;
      if (!h || typeof h != "string" || !h.startsWith("co_z"))
        return null;
      const w = await IA(i, h, null, null, null, {
        deepResolve: !1,
        timeoutMs: r
      });
      try {
        await uA(w, h, r);
      } catch {
        return null;
      }
      const E = w.value;
      if (!E || E.error)
        return null;
      const p = Et.test(A) ? A.replace(Et, "") : A, y = E[p];
      return y && typeof y == "string" && y.startsWith("co_z") ? t === "coId" ? y : await eA(i, y, { returnType: t, deepResolve: o, timeoutMs: r }) : null;
    }
  }
  return null;
}
function Ae(i, A, e = {}) {
  const { returnType: t = "coId" } = e, o = EQ(i, A, e);
  if (t === "schema" || t === "coValue") {
    const r = new ReactiveStore({ loading: !0 }), s = o.subscribe(async (n) => {
      if (n.loading) {
        r._set({ loading: !0 });
        return;
      }
      if (n.error) {
        r._set({ loading: !1, error: n.error }), s();
        return;
      }
      if (n.schemaCoId)
        if (t === "coId")
          r._set({ loading: !1, schemaCoId: n.schemaCoId }), s();
        else
          try {
            const a = await eA(i, n.schemaCoId, { returnType: t });
            a ? r._set({ loading: !1, [t === "schema" ? "schema" : "coValue"]: a }) : r._set({ loading: !1, error: "Schema not found" }), s();
          } catch (a) {
            r._set({ loading: !1, error: a.message }), s();
          }
      else if (n.coValueCore)
        if (t === "coId") {
          const C = (i.getHeader(n.coValueCore)?.meta || null)?.$schema || null;
          C ? r._set({ loading: !1, schemaCoId: C }) : r._set({ loading: !1, error: "Schema not found in headerMeta" }), s();
        } else
          r._set({ loading: !1, coValue: n.coValueCore }), s();
    }), g = r._unsubscribe;
    return r._unsubscribe = () => {
      g && g(), s();
    }, r;
  }
  return o;
}
async function bt(i, A, e) {
  const t = await eA(i, A, { returnType: "schema" });
  if (!t)
    throw new Error(`[checkCotype] Schema ${A} not found`);
  return (t.cotype || "comap") === e;
}
const Qs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  checkCotype: bt,
  resolve: eA,
  resolveReactive: Ae
}, Symbol.toStringTag, { value: "Module" })), lQ = {
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $id: "https://maia.city/AccountSchema",
  title: "Account",
  description: "Schema for account CoMap (special CoMap with authentication properties)",
  allOf: [
    { $ref: "#/$defs/comap" }
  ],
  properties: {
    sealer: {
      type: "string",
      pattern: "^sealer_",
      description: "Sealer key for encryption"
    },
    signer: {
      type: "string",
      pattern: "^signer_",
      description: "Signer key for signing"
    },
    readKey: {
      type: "string",
      description: "Read key for decryption"
    },
    profile: {
      allOf: [
        {
          type: "string",
          pattern: "^co_z[a-zA-Z0-9]+$",
          description: "Co-id reference to Profile CoMap"
        },
        {
          $ref: "https://maia.city/ProfileSchema"
        }
      ]
    },
    examples: {
      type: "string",
      pattern: "^co_z[a-zA-Z0-9]+$",
      description: "Co-id reference to Examples CoMap (optional)"
    }
  },
  required: ["profile"],
  $defs: Tt.$defs
}, uQ = {
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $id: "https://maia.city/GroupSchema",
  title: "Group",
  description: "Schema for group CoMap (special CoMap with member management)",
  allOf: [
    { $ref: "#/$defs/comap" }
  ],
  properties: {
    // Groups can have members (co-ids) and permissions
    // Structure depends on cojson's group implementation
  },
  $defs: Tt.$defs
}, dQ = {
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $id: "https://maia.city/ProfileSchema",
  title: "Profile",
  description: "Schema for profile CoMap (account-owned, identity only)",
  allOf: [
    { $ref: "#/$defs/comap" }
  ],
  properties: {
    name: {
      type: "string",
      minLength: 1,
      description: "User's display name"
    }
  },
  required: ["name"],
  $defs: Tt.$defs
}, Es = {
  AccountSchema: lQ,
  GroupSchema: uQ,
  ProfileSchema: dQ
};
function yo() {
  return { ...Es };
}
function ls(i) {
  return ["@account", "@group", "@metaSchema"].includes(i) ? !0 : i in Es;
}
function Do(i, A = "createCoValue") {
  if (!i || typeof i != "string")
    throw new Error(`[${A}] Schema name is REQUIRED.`);
  if (!(Je(i) || i.startsWith("co_z") || ls(i)))
    throw new Error(`[${A}] Schema '${i}' not found in registry. Available: AccountSchema, GroupSchema, ProfileSchema`);
}
const yA = {
  ACCOUNT: "@account",
  GROUP: "@group",
  META_SCHEMA: "@metaSchema"
};
function Je(i) {
  return i === yA.ACCOUNT || i === yA.GROUP || i === yA.META_SCHEMA;
}
function gt(i) {
  return !Je(i) && !i.startsWith("co_z") && !ls(i) && console.warn(`[createSchemaMeta] Schema '${i}' not found in registry`), {
    $schema: i
    // Schema name, co-id, or exception schema
  };
}
function Za(i) {
  return i.headerMeta?.$schema || null;
}
function _a(i) {
  return Za(i);
}
const Pt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  EXCEPTION_SCHEMAS: yA,
  SCHEMA_REGISTRY: Es,
  assertSchemaValidForCreate: Do,
  createSchemaMeta: gt,
  getAllSchemas: yo,
  getSchema: _a,
  getSchemaFromCoValue: Za,
  hasSchemaInRegistry: ls,
  isExceptionSchema: Je
}, Symbol.toStringTag, { value: "Module" }));
async function us(i, A, e) {
  const t = e?.name ?? "Maia";
  let o = i.get("profile"), r;
  if (o) {
    let s = A.getCoValue(o);
    if (s || (s = await A.loadCoValueCore(o)), s && s.type === "comap")
      if (s.isAvailable?.()) {
        const g = s.getCurrentContent?.();
        g && typeof g.get == "function" && (r = g);
      } else {
        await new Promise((n, a) => {
          const I = setTimeout(() => a(new Error("Timeout waiting for profile")), 15e3), C = s.subscribe((c) => {
            c?.isAvailable?.() && (clearTimeout(I), C?.(), n());
          });
        });
        const g = s.getCurrentContent?.();
        g && typeof g.get == "function" && (r = g);
      }
  }
  if (r) {
    if (e?.name != null) {
      const s = r.get("name");
      s !== e.name && (r.set("name", e.name), console.log(`    Updated profile name from "${s}" to "${e.name}"`));
    }
  } else {
    const s = gt("ProfileSchema"), g = A.createGroup();
    g.addMember("everyone", "reader");
    const n = g.createMap({ name: t }, s);
    i.set("profile", n.id);
  }
  await hQ(i, A), await fQ(i, A);
}
async function hQ(i, A) {
  const e = i.get?.("sparks");
  if (!e || typeof e != "string" || !e.startsWith("co_z")) return;
  const t = A.getCoValue(e) || await A.loadCoValueCore(e);
  if (!t?.isAvailable?.()) return;
  const o = t.getCurrentContent?.();
  if (!o || typeof o.get != "function") return;
  let r = 0;
  const s = typeof o.keys == "function" ? Array.from(o.keys()) : Object.keys(o ?? {});
  for (const g of s) {
    const n = o.get(g);
    if (!n || typeof n != "string" || !n.startsWith("co_z")) continue;
    const a = A.getCoValue(n) || await A.loadCoValueCore(n);
    if (!a?.isAvailable?.()) continue;
    const I = a.getCurrentContent?.();
    if (!I || typeof I.get != "function") continue;
    const C = I.get("os");
    if (!C || typeof C != "string" || !C.startsWith("co_z")) continue;
    const c = A.getCoValue(C) || await A.loadCoValueCore(C);
    if (!c?.isAvailable?.()) continue;
    const B = c.getCurrentContent?.();
    if (!B || typeof B.get != "function") continue;
    const Q = B.get("capabilities");
    if (!Q || typeof Q != "string" || !Q.startsWith("co_z")) continue;
    const f = A.getCoValue(Q) || await A.loadCoValueCore(Q);
    if (!f?.isAvailable?.()) continue;
    const l = f.getCurrentContent?.();
    if (!l || typeof l.set != "function") continue;
    const d = l.get("sparkGuardian");
    !d || typeof d != "string" || !d.startsWith("co_z") || l.get("guardian") || (l.set("guardian", d), l.delete?.("sparkGuardian"), r++);
  }
  r > 0 && console.log(`    Migrated capabilities sparkGuardian -> guardian (${r} sparks)`);
}
async function fQ(i, A) {
  const e = i.get?.("sparks");
  if (!e || typeof e != "string" || !e.startsWith("co_z")) return;
  const t = A.getCoValue(e) || await A.loadCoValueCore(e);
  if (!t?.isAvailable?.()) return;
  const o = t.getCurrentContent?.();
  if (!o || typeof o.get != "function") return;
  const r = typeof o.keys == "function" ? Array.from(o.keys()) : Object.keys(o ?? {});
  for (const s of r) {
    const g = o.get(s);
    if (!g || typeof g != "string" || !g.startsWith("co_z")) continue;
    const n = A.getCoValue(g) || await A.loadCoValueCore(g);
    if (!n?.isAvailable?.()) continue;
    const a = n.getCurrentContent?.();
    if (!a || typeof a.get != "function") continue;
    const I = a.get("registries");
    if (!I || typeof I != "string" || !I.startsWith("co_z")) continue;
    const C = A.getCoValue(I) || await A.loadCoValueCore(I);
    if (!C?.isAvailable?.()) continue;
    const c = C.getCurrentContent?.();
    if (!c || typeof c.set != "function" || c.get("humans")) continue;
    const B = a.get("os");
    if (!B?.startsWith("co_z")) continue;
    const Q = A.getCoValue(B) || await A.loadCoValueCore(B);
    if (!Q?.isAvailable?.()) continue;
    const f = Q.getCurrentContent?.();
    if (!f?.get) continue;
    const l = f.get("capabilities");
    if (!l?.startsWith("co_z")) continue;
    const d = A.getCoValue(l) || await A.loadCoValueCore(l);
    if (!d?.isAvailable?.()) continue;
    const u = d.getCurrentContent?.();
    if (!u?.get) continue;
    const h = u.get("guardian"), w = u.get("publicReaders");
    if (!h?.startsWith("co_z") || !w?.startsWith("co_z")) continue;
    const E = A.getCoValue(h) || await A.loadCoValueCore(h), p = A.getCoValue(w) || await A.loadCoValueCore(w);
    if (!E?.isAvailable?.() || !p?.isAvailable?.()) continue;
    const y = E.getCurrentContent?.(), m = p.getCurrentContent?.();
    if (!y?.createMap || !m) continue;
    const { EXCEPTION_SCHEMAS: N } = await Promise.resolve().then(() => Pt), R = { $schema: N.META_SCHEMA }, L = A.createGroup();
    L.extend(y, "extend"), L.extend(m, "reader");
    const j = L.createMap({}, R), J = typeof A.getCurrentAccountOrAgentID == "function" ? A.getCurrentAccountOrAgentID() : i?.id ?? i?.$jazz?.id;
    try {
      const { removeGroupMember: z } = await Promise.resolve().then(() => ue);
      await z(L, J);
    } catch {
    }
    c.set("humans", j.id), console.log(`    Created spark.registries.humans for spark ${s}`);
  }
}
function wQ(i) {
  i.addKeyword({
    keyword: "$co",
    macro: (A) => ({
      type: "string",
      pattern: "^co_z[a-zA-Z0-9]+$",
      _schemaRef: A
      // Store schema co-id for metadata
    }),
    metaSchema: {
      type: "string",
      anyOf: [
        {
          pattern: "^co_z[a-zA-Z0-9]+$",
          description: "Co-id reference (after transformation)"
        },
        {
          pattern: "^@[a-zA-Z0-9_-]+/schema/",
          description: "Human-readable schema ID (before transformation)"
        }
      ],
      description: "Reference to schema that this property value must conform to (human-readable ID or co-id)"
    }
  }), i.addKeyword({
    keyword: "cotype",
    validate: (A, e) => e === null || typeof e != "object" ? !0 : A === "comap" ? !Array.isArray(e) : A === "colist" || A === "costream" ? !!(Array.isArray(e) || typeof e == "object" && e !== null && Array.isArray(e.items)) : !1,
    metaSchema: {
      enum: ["comap", "colist", "costream"]
    }
  }), i.addKeyword({
    keyword: "indexing",
    validate: () => !0,
    // Always pass - it's metadata, not a validation rule
    metaSchema: {
      type: "boolean",
      description: "Whether instances of this schema should be indexed in account.os.{schemaCoId}"
    }
  });
}
const mo = /^@[a-zA-Z0-9_-]+\/schema\//, $a = /^@[a-zA-Z0-9_-]+\/vibe\//;
function MA(i) {
  return typeof i == "string" && mo.test(i);
}
function Xa(i) {
  return typeof i == "string" && $a.test(i);
}
const pQ = "https://json-schema.org/draft/2020-12/schema", yQ = "@maia/schema/meta", DQ = { "https://json-schema.org/draft/2020-12/vocab/core": !0, "https://json-schema.org/draft/2020-12/vocab/applicator": !0, "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0, "https://json-schema.org/draft/2020-12/vocab/validation": !0, "https://json-schema.org/draft/2020-12/vocab/meta-data": !0, "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0, "https://json-schema.org/draft/2020-12/vocab/content": !0, "https://maiaos.dev/vocab/cojson": !0 }, mQ = [{ $ref: "https://json-schema.org/draft/2020-12/schema" }], SQ = "@maia/schema/meta", NQ = ["object", "boolean"], MQ = !1, kQ = { title: { type: "string", description: "Human-readable schema title (required)" }, cotype: { enum: ["comap", "colist", "costream"], description: "CRDT type at schema root. Schemas can be comap (with properties), colist (with items), or costream (with items). CoText is modeled as colist with string items." }, $co: { type: "string", anyOf: [{ pattern: "^co_z[a-zA-Z0-9]+$", description: "Co-id reference (after transformation)" }, { pattern: "^@[a-zA-Z0-9_-]+/schema/", description: "Human-readable schema ID (before transformation)" }], description: "Reference to schema that this property value must conform to (human-readable ID or co-id). Use $co in properties to reference separate CoValues, never use cotype in properties." }, indexing: { type: "boolean", default: !1, description: "Whether instances of this schema should be indexed in account.os.{schemaCoId}" } }, GQ = ["title", "cotype"], FQ = { comap: { description: "CoMap - CRDT-based collaborative map/object", type: "object", properties: {}, additionalProperties: { anyOf: [{ type: "string", description: "Standard string value" }, { type: "number", description: "Standard number value" }, { type: "integer", description: "Standard integer value" }, { type: "boolean", description: "Standard boolean value" }, { type: "null", description: "Null value" }, { type: "object", description: "Nested object value" }, { type: "array", description: "Array value" }, { type: "string", pattern: "^co_z[a-zA-Z0-9]+$", description: "Co-id reference to another CoValue" }, { type: "string", pattern: "^key_[a-zA-Z0-9_]+$", description: "Key reference" }, { type: "string", pattern: "^sealed_", description: "Sealed/encrypted value" }] } }, costream: { description: "CoStream - CRDT-based append-only stream", type: "array", items: { anyOf: [{ type: "object", description: "Stream item object" }, { type: "string", description: "Stream item string" }, { type: "number", description: "Stream item number" }, { type: "boolean", description: "Stream item boolean" }, { type: "null", description: "Stream item null" }] } }, colist: { description: "CoList - CRDT-based collaborative list/array", type: "array", items: { anyOf: [{ type: "object", description: "List item object" }, { type: "string", description: "List item string (can be co-id reference)" }, { type: "number", description: "List item number" }, { type: "integer", description: "List item integer" }, { type: "boolean", description: "List item boolean" }, { type: "null", description: "List item null" }, { type: "array", description: "Nested array" }] } } }, ro = {
  $schema: pQ,
  $id: yQ,
  $vocabulary: DQ,
  allOf: mQ,
  title: SQ,
  type: NQ,
  indexing: MQ,
  properties: kQ,
  required: GQ,
  $defs: FQ
};
function Ge(i) {
  return (i || []).map((A) => ({
    instancePath: A.instancePath || "/",
    schemaPath: A.schemaPath || "",
    keyword: A.keyword || "",
    message: A.message || "",
    params: A.params || {}
  }));
}
function lg(i, A, e) {
  if (e) {
    const t = A ? ` for '${A}'` : "", o = i.map((r) => `  - ${r.instancePath}: ${r.message}`).join(`
`);
    throw new Error(`Validation failed${t}:
${o}`);
  }
  return { valid: !1, errors: i };
}
async function se(i, A) {
  const e = i.opts.validateSchema;
  i.opts.validateSchema = !1;
  try {
    return await A();
  } finally {
    i.opts.validateSchema = e;
  }
}
class Ye {
  constructor(A = {}) {
    this.ajv = null, this.ajvPromise = null, this.initialized = !1, this.schemas = /* @__PURE__ */ new Map(), this.schemaResolver = null, this.registrySchemas = A.registrySchemas || null;
  }
  /**
   * Set schema resolver function for resolving $schema references from IndexedDB
   * @param {Function} resolver - Async function that takes a schema key and returns the schema
   */
  setSchemaResolver(A) {
    this.schemaResolver = A;
  }
  /**
   * Initialize AJV (loads from CDN in browser, uses import in Node/Bun)
   * @returns {Promise<void>}
   */
  async initialize() {
    if (!this.initialized) {
      if (this.ajvPromise) {
        await this.ajvPromise;
        return;
      }
      this.ajvPromise = (async () => {
        let A;
        try {
          const e = await Promise.resolve().then(() => VS);
          A = e.default || e.Ajv2020 || e;
        } catch {
          try {
            A = (await Promise.resolve().then(() => rN)).default;
          } catch {
            try {
              const o = await import("https://esm.sh/ajv@8.12.0/dist/2020.js");
              A = o.default || o.Ajv2020 || o;
            } catch {
              const r = await import("https://esm.sh/ajv@8.12.0");
              A = r.default || r;
            }
          }
        }
        this.ajv = new A({
          allErrors: !0,
          // Collect all errors, not just first
          verbose: !0,
          // Include schema and data paths in errors
          strict: !1,
          // Be permissive initially
          validateSchema: !0,
          // Validate schemas themselves (meta-schema will be loaded)
          validateFormats: !0,
          // Enable format validation
          removeAdditional: !1,
          // Don't remove extra properties
          useDefaults: !1,
          // Don't add defaults
          coerceTypes: !1,
          // Don't coerce types
          loadSchema: async (e) => {
            if (e.startsWith("co_z")) {
              if (this.schemaResolver)
                try {
                  let t = await this.schemaResolver(e);
                  return t && t.$coId && !t.$schema && (t = await this.schemaResolver(t.$coId)), t || void 0;
                } catch (t) {
                  console.warn(`[ValidationEngine] loadSchema failed for ${e}:`, t);
                  return;
                }
              return;
            }
          }
        }), this.ajv.addFormat("uri-reference", {
          type: "string",
          validate: (e) => {
            if (!e || typeof e != "string") return !1;
            if (e === "") return !0;
            try {
              return new URL(e), !0;
            } catch {
              return !0;
            }
          }
        }), this.ajv.addFormat("regex", {
          type: "string",
          validate: (e) => {
            if (!e || typeof e != "string") return !1;
            try {
              return new RegExp(e), !0;
            } catch {
              return !1;
            }
          }
        }), this._loadMetaSchema(), this._loadCoJsonMetaSchema(), wQ(this.ajv), await this._loadCoTypeDefinitions(), this.registrySchemas && await this.registerAllSchemas(this.registrySchemas), this.initialized = !0;
      })(), await this.ajvPromise;
    }
  }
  /**
   * Get the CoJSON custom meta-schema (extends JSON Schema Draft 2020-12)
   * @returns {Object} Meta schema object
   */
  static getMetaSchema() {
    return ro;
  }
  /**
   * Get the base JSON Schema Draft 2020-12 meta-schema
   * @returns {Object} Meta schema object
   */
  static getBaseMetaSchema() {
    return ro;
  }
  /**
   * Load JSON Schema Draft 2020-12 meta-schema (hardcoded)
   * @private
   */
  _loadMetaSchema() {
    const A = "https://json-schema.org/draft/2020-12/schema", e = "@maia/schema/meta-schema", t = Ye.getBaseMetaSchema();
    try {
      se(this.ajv, () => {
        if (this.ajv.getSchema(A) || this.ajv.addMetaSchema(t, t.$id), !this.ajv.getSchema(e)) {
          const o = JSON.parse(JSON.stringify(t));
          o.$id = e, this.ajv.addMetaSchema(o, e);
        }
      });
    } catch (o) {
      if (!o.message || !o.message.includes("already exists")) {
        console.warn("[ValidationEngine] Failed to add meta-schema:", o.message);
        return;
      }
    }
  }
  /**
   * Load CoJSON custom meta-schema
   * @private
   */
  _loadCoJsonMetaSchema() {
    const A = "@maia/schema/meta";
    try {
      se(this.ajv, () => {
        this.ajv.getSchema(A) || this.ajv.addMetaSchema(ro, A);
      });
    } catch (e) {
      (!e.message || !e.message.includes("already exists")) && console.warn("[ValidationEngine] Failed to add CoJSON meta-schema:", e.message);
    }
  }
  /**
   * Resolve meta-schema ID from co-id or return as-is
   * @private
   * @param {string} schemaMetaSchemaId - Meta-schema ID (may be co-id)
   * @returns {Promise<{resolvedMetaSchemaId: string, metaSchemaObject: Object|null}>}
   */
  async _resolveMetaSchemaId(A) {
    let e = A, t = null;
    if (A.startsWith("co_z"))
      if (this.schemaResolver)
        if (t = await this.schemaResolver(A), t && t.$id)
          e = t.$id;
        else if (this.ajv.getSchema(A))
          e = A;
        else
          throw new Error(`[ValidationEngine] Could not resolve meta-schema co-id '${A}'. Schema resolver returned null or undefined.`);
      else if (this.ajv.getSchema(A))
        e = A;
      else
        throw new Error(`[ValidationEngine] Meta-schema co-id '${A}' not found and no schema resolver available.`);
    return { resolvedMetaSchemaId: e, metaSchemaObject: t };
  }
  /**
   * Determine meta-schema type (CoJSON vs standard JSON Schema)
   * @private
   * @param {Object} metaSchemaObject - Resolved meta-schema object
   * @returns {string} Target meta-schema ID ('@maia/schema/meta' or standard meta-schema ID)
   */
  _determineMetaSchemaType(A) {
    const e = A.properties && A.properties.cotype && A.properties.cotype.enum && Array.isArray(A.properties.cotype.enum) && A.properties.cotype.enum.includes("comap"), t = A.$vocabulary && A.$vocabulary["https://maiaos.dev/vocab/cojson"] === !0;
    return e || t ? "@maia/schema/meta" : A.$vocabulary ? "https://json-schema.org/draft/2020-12/schema" : "@maia/schema/meta";
  }
  /**
   * Get meta-schema validator, registering if necessary
   * @private
   * @param {string} resolvedMetaSchemaId - Resolved meta-schema ID
   * @param {Object|null} metaSchemaObject - Resolved meta-schema object (if available)
   * @returns {Function|null} Meta-schema validator function
   */
  _getMetaSchemaValidator(A, e) {
    if (A === "@maia/schema/meta" || A === "@maia/schema/meta-schema")
      return this.ajv.getSchema("@maia/schema/meta");
    if (A === "https://json-schema.org/draft/2020-12/schema")
      return this.ajv.getSchema("https://json-schema.org/draft/2020-12/schema");
    if (A.startsWith("co_z")) {
      let t = this.ajv.getSchema(A);
      if (!t && e) {
        const o = this._determineMetaSchemaType(e);
        if (t = this.ajv.getSchema(o), !t && e)
          try {
            se(this.ajv, () => {
              this.ajv.addSchema(e, A), o !== A && this.ajv.addSchema(e, o), t = this.ajv.getSchema(o);
            });
          } catch {
            t = this.ajv.getSchema(o);
          }
      }
      if (!t)
        throw new Error(`[ValidationEngine] Meta-schema validator not found for co-id '${A}'. Make sure the meta-schema is registered in AJV.`);
      return t;
    } else
      throw new Error(`[ValidationEngine] Unknown meta schema (resolved to '${A}'). Expected '@maia/schema/meta' or standard JSON Schema meta schema.`);
  }
  /**
   * Validate a schema against its meta-schema
   * @param {Object} schema - Schema to validate
   * @returns {{valid: boolean, errors: Array|null}} Validation result
   */
  async validateSchemaAgainstMeta(A) {
    await this.initialize();
    const e = A.$schema;
    if (!e)
      throw new Error("[ValidationEngine] Schema missing required $schema field. All schemas must declare their meta schema.");
    const { resolvedMetaSchemaId: t, metaSchemaObject: o } = await this._resolveMetaSchemaId(e), r = this._getMetaSchemaValidator(t, o);
    if (!r)
      return console.warn(`[ValidationEngine] Meta schema '${e}' not available, skipping schema validation`), { valid: !0, errors: null };
    const s = "https://json-schema.org/draft/2020-12/schema";
    if (A.$id === s || A.$id === "@maia/schema/meta" || A.$schema === s && A.$id && A.$id.includes("schema"))
      return se(this.ajv, () => {
        if (r(A))
          return { valid: !0, errors: null };
        const c = r.errors || [];
        return {
          valid: !1,
          errors: Ge(c)
        };
      });
    if (r(A))
      return { valid: !0, errors: null };
    const a = r.errors || [];
    return {
      valid: !1,
      errors: Ge(a)
    };
  }
  /**
   * Load a schema for a given type
   * @param {string} type - Schema type identifier (e.g., 'actor', 'context', 'state')
   * @param {object} schema - JSON Schema object
   */
  async loadSchema(A, e) {
    if (await this.initialize(), !A || typeof A != "string")
      throw new Error("Schema type must be a non-empty string");
    if (!e || typeof e != "object")
      throw new Error("Schema must be an object");
    if (this.schemas.has(A))
      return this.schemas.get(A);
    if (await this._resolveAndRegisterSchemaDependencies(e), e.$id) {
      const t = this.ajv.getSchema(e.$id);
      if (t)
        return this.schemas.set(A, t), t;
    }
    try {
      const t = this.ajv.compile(e);
      return this.schemas.set(A, t), t;
    } catch (t) {
      if (t.message && t.message.includes("already exists") && e.$id) {
        const o = this.ajv.getSchema(e.$id);
        if (o)
          return this.schemas.set(A, o), o;
      }
      throw new Error(`Failed to load schema for type '${A}': ${t.message}`);
    }
  }
  /**
   * Resolve $schema reference (co-id) and register meta-schema
   * @private
   * @param {string} coId - Co-id of the meta-schema
   * @param {Set} resolvedSchemas - Set of already resolved schema co-ids
   * @param {Set} resolvingSchemas - Set of schemas currently being resolved
   * @param {Function} resolveRecursive - Recursive resolution function
   * @returns {Promise<void>}
   */
  async _resolveSchemaReference(A, e, t, o) {
    if (!(e.has(A) || t.has(A))) {
      t.add(A);
      try {
        let r = await this.schemaResolver(A);
        r && r.$coId && !r.$schema && (r = await this.schemaResolver(r.$coId)), r ? (await o(r), r.$id && (this.ajv.getSchema(r.$id) || this.ajv.addMetaSchema(r, r.$id)), this.ajv.getSchema(A) || this.ajv.addMetaSchema(r, A), e.add(A)) : console.warn(`[ValidationEngine] Schema resolver returned null for $schema co-id ${A}`);
      } catch (r) {
        throw console.error(`[ValidationEngine] Failed to resolve $schema co-id ${A}:`, r), r;
      } finally {
        t.delete(A);
      }
    }
  }
  /**
   * Register a resolved schema in AJV
   * @private
   * @param {Object} schema - Schema to register
   * @param {string} ref - Reference ID (should be co-id after transformation)
   * @param {string} coId - Co-id of the schema
   */
  _registerResolvedSchema(A, e, t) {
    if (e && MA(e) && console.warn(`[ValidationEngine] Warning: Registering schema with @maia/schema/ reference: ${e}. This should be a co-id after seeding. Schema may be from source files instead of database.`), e !== t && e && !this.ajv.getSchema(e))
      try {
        se(this.ajv, () => {
          this.ajv.addSchema(A, e);
        });
      } catch (o) {
        if (!(o.message && o.message.includes("already exists"))) throw o;
      }
    if (t && !this.ajv.getSchema(t))
      try {
        se(this.ajv, () => {
          this.ajv.addSchema(A, t);
        });
      } catch (o) {
        if (!(o.message && o.message.includes("already exists"))) throw o;
      }
  }
  /**
   * Resolve $co reference and register schema
   * @private
   * @param {string} ref - Reference (co-id or human-readable ID)
   * @param {Set} resolvedSchemas - Set of already resolved schema co-ids
   * @param {Set} resolvingSchemas - Set of schemas currently being resolved
   * @param {Function} resolveRecursive - Recursive resolution function
   * @returns {Promise<void>}
   */
  async _resolveCoReference(A, e, t, o) {
    if (!(e.has(A) || t.has(A))) {
      A && MA(A) && console.warn(`[ValidationEngine] Warning: Resolving $co reference with @maia/schema/ pattern: ${A}. This should be a co-id after seeding. The schema may not have been transformed correctly.`), t.add(A);
      try {
        let r = await this.schemaResolver(A);
        if (r && r.$coId && !r.$schema && (r = await this.schemaResolver(r.$coId)), !r) {
          const g = `[ValidationEngine] Schema resolver returned null for $co reference ${A}. This schema must be registered before it can be referenced. If this is an @domain/schema/... reference, ensure schemas were transformed correctly during seeding.`;
          throw console.error(g), new Error(g);
        }
        const s = r.$id;
        if (s && e.has(s)) {
          t.delete(A);
          return;
        }
        await o(r), s && e.add(s), e.add(A), this._registerResolvedSchema(r, A, s);
      } catch (r) {
        if (r.message && r.message.includes("already exists"))
          console.warn(`[ValidationEngine] Duplicate registration handled for ${A}`);
        else
          throw console.error(`[ValidationEngine] Failed to resolve $co reference ${A}:`, r), r;
      } finally {
        t.delete(A);
      }
    }
  }
  /**
   * Resolve and register all schema dependencies ($schema and $co references)
   * @private
   * @param {Object} schema - Schema object
   */
  async _resolveAndRegisterSchemaDependencies(A) {
    !A || typeof A != "object" || !this.schemaResolver || await se(this.ajv, async () => {
      const e = /* @__PURE__ */ new Set(), t = /* @__PURE__ */ new Set(), o = async (r) => {
        if (!(!r || typeof r != "object")) {
          r.$schema && typeof r.$schema == "string" && r.$schema.startsWith("co_z") && await this._resolveSchemaReference(r.$schema, e, t, o), r.$co && typeof r.$co == "string" && await this._resolveCoReference(r.$co, e, t, o);
          for (const s of Object.values(r))
            if (Array.isArray(s))
              for (const g of s)
                await o(g);
            else s && typeof s == "object" && await o(s);
        }
      };
      await o(A);
    });
  }
  /**
   * Check if a schema is loaded
   * @param {string} type - Schema type identifier
   * @returns {boolean} True if schema is loaded
   */
  hasSchema(A) {
    return this.schemas.has(A);
  }
  /**
   * Validate data against a schema
   * @param {string} type - Schema type identifier
   * @param {any} data - Data to validate
   * @returns {{valid: boolean, errors: Array|null}} Validation result
   */
  async validate(A, e) {
    if (await this.initialize(), !this.schemas.has(A))
      throw new Error(`Schema '${A}' not loaded. Call loadSchema() first.`);
    const t = this.schemas.get(A);
    if (t(e))
      return {
        valid: !0,
        errors: null
      };
    const r = t.errors || [];
    return {
      valid: !1,
      errors: Ge(r)
    };
  }
  /**
   * Validate data and throw if invalid
   * @param {string} type - Schema type identifier
   * @param {any} data - Data to validate
   * @param {string} context - Optional context for error message (e.g., file path)
   * @throws {Error} If validation fails
   */
  async validateOrThrow(A, e, t = "") {
    const o = await this.validate(A, e);
    if (!o.valid) {
      const r = t ? ` in ${t}` : "", s = o.errors.map((g) => `  - ${g.instancePath}: ${g.message}`).join(`
`);
      throw new Error(
        `Validation failed for '${A}'${r}:
${s}`
      );
    }
    return o;
  }
  /**
   * Load co-type definitions into AJV (REQUIRED for all CoValue validation)
   * @private
   */
  async _loadCoTypeDefinitions() {
    const e = {
      $id: "https://maia.city/schemas/co-types",
      $defs: (await Promise.resolve().then(() => oQ)).$defs
    };
    if (!this.ajv.getSchema(e.$id))
      try {
        se(this.ajv, () => {
          this.ajv.addSchema(e, e.$id);
        });
      } catch (t) {
        (!t.message || !t.message.includes("already exists")) && console.warn("[ValidationEngine] Failed to add co-type definitions:", t.message);
      }
  }
  /**
   * Register all schemas from registry into AJV (MIGRATIONS/SEEDING ONLY)
   * @param {Object} schemas - Map of schema names to schema definitions
   * @returns {Promise<void>}
   */
  async registerAllSchemas(A) {
    if (await this.initialize(), !A || typeof A != "object")
      return;
    const e = this.ajv, t = e.opts.validateSchema;
    e.opts.validateSchema = !1;
    try {
      for (const [o, r] of Object.entries(A))
        if (r && r.$id && !e.getSchema(r.$id))
          try {
            e.addSchema(r, r.$id);
          } catch (s) {
            s.message.includes("already exists") || console.warn(`[ValidationEngine] Failed to add schema ${o}:`, s);
          }
    } finally {
      e.opts.validateSchema = t;
    }
  }
  /**
   * Validate data against a schema by name (MIGRATIONS/SEEDING ONLY)
   * CRITICAL: This method is ONLY for migrations/seeding
   * Runtime validation MUST use validateAgainstSchema() with schema loaded from CoValue header metadata
   * 
   * @param {string} schemaName - Schema name (human-readable ID from registry)
   * @param {any} data - Data to validate
   * @returns {Promise<{valid: boolean, errors: Array|null}>} Validation result
   */
  async validateData(A, e) {
    if (await this.initialize(), !this.registrySchemas)
      throw new Error("[ValidationEngine] validateData() requires registrySchemas. This method is ONLY for migrations/seeding. Runtime validation must use validateAgainstSchema() with schema from CoValue header metadata.");
    const t = this.registrySchemas[A];
    if (!t)
      return {
        valid: !1,
        errors: [{ message: `Schema '${A}' not found in registry` }]
      };
    let o;
    if (t.$id && (o = this.ajv.getSchema(t.$id)), !o)
      try {
        await this._resolveAndRegisterSchemaDependencies(t), o = this.ajv.compile(t);
      } catch (r) {
        return {
          valid: !1,
          errors: [{ message: `Failed to compile schema '${A}': ${r.message}` }]
        };
      }
    try {
      if (o(e))
        return {
          valid: !0,
          errors: null
        };
      const s = o.errors || [];
      return {
        valid: !1,
        errors: Ge(s)
      };
    } catch (r) {
      return {
        valid: !1,
        errors: [{ message: `Validation error: ${r.message}` }]
      };
    }
  }
}
let $A = null, Rr = null;
function AI(i) {
  if (!i || typeof i != "object")
    throw new Error("[setSchemaResolver] Options object required: { dbEngine }");
  const { dbEngine: A } = i;
  if (!A)
    throw new Error("[setSchemaResolver] dbEngine is REQUIRED. No fallbacks allowed.");
  const e = async (t) => {
    try {
      if (!A.backend)
        throw new Error("[SchemaResolver] dbEngine.backend is required");
      const { resolve: o } = await Promise.resolve().then(() => Go), r = await o(A.backend, t, { returnType: "schema" });
      if (!r)
        throw new Error(`[SchemaResolver] Schema ${t} not found`);
      return r;
    } catch (o) {
      throw new Error(`[SchemaResolver] Failed to load schema ${t}: ${o.message}`);
    }
  };
  Rr = e, $A && $A.setSchemaResolver(e);
}
async function So(i = null) {
  let A = null;
  i && typeof i == "object" && (A = i.registrySchemas || null);
  let e = null;
  return Rr && (e = Rr), $A ? A && !$A.registrySchemas && ($A = new Ye({ registrySchemas: A })) : $A = new Ye({ registrySchemas: A }), e && !$A.schemaResolver && $A.setSchemaResolver(e), await $A.initialize(), $A;
}
async function jt(i, A, e = "", t = !1) {
  const o = await So();
  await o.initialize();
  try {
    await o._resolveAndRegisterSchemaDependencies(i);
    let r;
    if (i.$id) {
      const n = o.ajv.getSchema(i.$id);
      n ? r = n : r = o.ajv.compile(i);
    } else
      r = o.ajv.compile(i);
    if (r(A))
      return { valid: !0, errors: null };
    const g = Ge(r.errors || []);
    return lg(g, e, t);
  } catch (r) {
    if (r.message?.includes("already exists") && i.$id) {
      const s = o.ajv.getSchema(i.$id);
      if (s) {
        if (s(A)) return { valid: !0, errors: null };
        const g = Ge(s.errors || []);
        return lg(g, e, t);
      }
    }
    throw new Error(`[Validation] Failed to compile schema for ${e}: ${r.message}`);
  }
}
async function nt(i, A, e = "") {
  return await jt(i, A, e, !0);
}
function eI(i, A) {
  if (!Array.isArray(A))
    throw new Error("[validateItems] Items must be an array");
  if (i.items && i.items.$co) {
    for (const e of A)
      if (typeof e != "string" || !e.startsWith("co_z"))
        throw new Error(`[validateItems] Items must be co-ids when schema.items.$co is specified, got: ${e}`);
  }
}
function EA(i, A) {
  if (!i)
    throw new Error(`[${A}] coId required`);
  if (!i.startsWith("co_z"))
    throw new Error(`[${A}] coId must be a valid co-id (co_z...), got: ${i}`);
}
function BA(i, A, e) {
  if (i == null)
    throw new Error(`[${e}] ${A} required`);
}
function JA(i, A, e = "") {
  if (!i) {
    const t = e ? ` (${e})` : "";
    throw new Error(`[${A}] dbEngine required${t}`);
  }
}
async function Vt(i, A, e, t, o = {}) {
  const { dbEngine: r, registrySchemas: s, getAllSchemas: g } = o, { resolve: n } = await Promise.resolve().then(() => Go);
  if (A.startsWith("co_z")) {
    if (!r)
      throw new Error(`[${t}] dbEngine is REQUIRED for co-id schema validation. Schema: ${A}. Pass dbEngine in options.`);
    const a = await n(i, A, { returnType: "schema" });
    if (!a)
      throw new Error(`[${t}] Schema not found in database: ${A}`);
    return await nt(a, e, `${t} for schema ${A}`), a;
  } else {
    if (!g || typeof g != "function")
      throw new Error(`[${t}] getAllSchemas function is REQUIRED for name-based schema validation. Schema: ${A}. This is only for migrations/seeding.`);
    const a = g(), C = await (await So({
      registrySchemas: s || a
    })).validateData(A, e);
    if (!C.valid) {
      const B = C.errors.map((Q) => `  - ${Q.instancePath}: ${Q.message}`).join(`
`);
      throw new Error(`[${t}] Data validation failed for schema '${A}':
${B}`);
    }
    return (s || a)[A];
  }
}
async function tI(i, A, e) {
  const t = i.getCoValue(A);
  if (!t)
    throw new Error(`[${e}] CoValue not found: ${A}`);
  if (!t.isAvailable()) {
    await i.node.loadCoValueCore(A);
    let o = 0;
    for (; !t.isAvailable() && o < 10; )
      await new Promise((r) => setTimeout(r, 100)), o++;
    if (!t.isAvailable())
      throw new Error(`[${e}] CoValue ${A} is not available (may still be loading)`);
  }
  return t;
}
const RQ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ensureCoValueAvailable: tI,
  formatValidationErrors: Ge,
  getValidationEngine: So,
  loadSchemaAndValidate: Vt,
  requireDbEngine: JA,
  requireParam: BA,
  setSchemaResolver: AI,
  validateAgainstSchema: jt,
  validateAgainstSchemaOrThrow: nt,
  validateCoId: EA,
  validateItems: eI,
  withSchemaValidationDisabled: se
}, Symbol.toStringTag, { value: "Module" }));
async function iI(i, A = {}, e, t = null, o = null) {
  let r = i;
  if (i && typeof i.createMap == "function")
    r = i;
  else if (i && typeof i.get == "function" && i.get("profile")) {
    const a = o?.backend;
    if (!a)
      throw new Error("[createCoMap] dbEngine.backend required when passing account (to resolve @maia spark group)");
    const { getSparkGroup: I } = await Promise.resolve().then(() => ue);
    if (r = await I(a, "@maia"), !r)
      throw new Error("[createCoMap] @maia spark group not found. Ensure schemaMigration has run.");
  }
  if (e === yA.META_SCHEMA) {
    const n = { $schema: yA.META_SCHEMA };
    return r.createMap(A, n);
  }
  Do(e, "createCoMap"), Je(e) || await Vt(
    o?.backend || null,
    e,
    A,
    "createCoMap",
    { dbEngine: o, getAllSchemas: yo }
  );
  const s = gt(e);
  return r.createMap(A, s);
}
async function oI(i, A = [], e, t = null, o = null) {
  let r = i;
  if (i && typeof i.get == "function" && i.get("profile")) {
    const a = o?.backend;
    if (!a)
      throw new Error("[createCoList] dbEngine.backend required when passing account (to resolve @maia spark group)");
    const { getSparkGroup: I } = await Promise.resolve().then(() => ue);
    if (r = await I(a, "@maia"), !r)
      throw new Error("[createCoList] @maia spark group not found. Ensure schemaMigration has run.");
  }
  Do(e, "createCoList"), Je(e) || await Vt(
    o?.backend || null,
    e,
    A,
    "createCoList",
    { dbEngine: o, getAllSchemas: yo }
  );
  const s = gt(e);
  return r.createList(A, s);
}
async function rI(i, A, e = null, t = null) {
  let o = i;
  if (i && typeof i.get == "function" && i.get("profile")) {
    const g = t?.backend;
    if (!g)
      throw new Error("[createCoStream] dbEngine.backend required when passing account");
    const { getSparkGroup: n } = await Promise.resolve().then(() => ue);
    if (o = await n(g, "@maia"), !o)
      throw new Error("[createCoStream] @maia spark group not found. Ensure schemaMigration has run.");
  }
  Do(A, "createCoStream");
  const r = gt(A);
  return o.createStream(r);
}
async function sI(i, A) {
  const e = i.getCoValue(A);
  if (!e || !e?.isAvailable())
    return null;
  const t = e?.getCurrentContent();
  return !t || typeof t.addMember != "function" ? null : t;
}
async function ds(i, A, e) {
  if (!A || typeof A != "string" || !A.startsWith("co_z")) return null;
  const t = await i.read(null, A);
  await uA(t, A, 15e3);
  const o = i.getCoValue(A);
  if (!o || !i.isAvailable(o)) return null;
  const r = i.getCurrentContent(o);
  if (!r || typeof r.get != "function") return null;
  const s = r.get("capabilities");
  if (!s || typeof s != "string" || !s.startsWith("co_z")) return null;
  const g = await i.read(null, s);
  await uA(g, s, 15e3);
  const n = i.getCoValue(s);
  if (!n || !i.isAvailable(n)) return null;
  const a = i.getCurrentContent(n);
  if (!a || typeof a.get != "function") return null;
  const I = a.get(e);
  return !I || typeof I != "string" || !I.startsWith("co_z") ? null : I;
}
async function gI(i, A, e) {
  const t = await KA(i, A);
  return ds(i, t, e);
}
async function hs(i, A, e) {
  if (!A || typeof A != "string" || !A.startsWith("co_z")) return null;
  const t = i.getCoValue(A) || await i.node?.loadCoValueCore?.(A);
  if (!t || !i.isAvailable?.(t)) return null;
  const o = i.getCurrentContent?.(t);
  if (!o || typeof o.get != "function") return null;
  const r = o.get("os");
  return ds(i, r, e);
}
async function fs(i, A) {
  if (!A || typeof A != "string")
    throw new Error("[getSparkGroup] spark is required");
  const e = `_cachedSparkGroup_${A}`;
  if (i[e])
    return i[e];
  const t = await gI(i, A, "guardian");
  if (!t || typeof t != "string" || !t.startsWith("co_z"))
    throw new Error(`[getSparkGroup] Spark ${A} has no guardian in os.capabilities`);
  const o = await i.read("@group", t);
  if (!o || o.error)
    throw new Error(`[getSparkGroup] Group for spark ${A} not available: ${t}`);
  await new Promise((g, n) => {
    if (!o.loading) {
      g();
      return;
    }
    let a;
    const I = setTimeout(() => {
      n(new Error(`[getSparkGroup] Timeout waiting for group ${t}`));
    }, 1e4);
    a = o.subscribe(() => {
      o.loading || (clearTimeout(I), a(), g());
    });
  });
  const r = i.getCoValue(t);
  if (!r)
    throw new Error(`[getSparkGroup] Group core not found: ${t}`);
  const s = i.getCurrentContent(r);
  if (!s || typeof s.createMap != "function")
    throw new Error(`[getSparkGroup] Group content not available: ${t}`);
  return i[e] = s, s;
}
async function KA(i, A) {
  const e = i.account.get("sparks");
  if (!e?.startsWith("co_z")) return null;
  const t = await i.read(null, e);
  await new Promise((g, n) => {
    if (!t.loading) return g();
    let a;
    const I = setTimeout(() => n(new Error("Timeout")), 1e4);
    a = t.subscribe(() => {
      t.loading || (clearTimeout(I), a?.(), g());
    });
  });
  const o = t.value?.[A];
  if (!o?.startsWith("co_z")) return null;
  const r = await i.read(null, o);
  await new Promise((g, n) => {
    if (!r.loading) return g();
    let a;
    const I = setTimeout(() => n(new Error("Timeout")), 1e4);
    a = r.subscribe(() => {
      r.loading || (clearTimeout(I), a?.(), g());
    });
  });
  const s = r.value?.os || null;
  return s && (i._cachedMaiaOsId = s), s;
}
async function No(i, A) {
  const e = i.account.get("sparks");
  if (!e?.startsWith("co_z")) return null;
  const t = await i.read(null, e);
  await new Promise((s, g) => {
    if (!t.loading) return s();
    let n;
    const a = setTimeout(() => g(new Error("Timeout")), 1e4);
    n = t.subscribe(() => {
      t.loading || (clearTimeout(a), n?.(), s());
    });
  });
  const o = t.value?.[A];
  if (!o?.startsWith("co_z")) return null;
  const r = await i.read(null, o);
  return await new Promise((s, g) => {
    if (!r.loading) return s();
    let n;
    const a = setTimeout(() => g(new Error("Timeout")), 1e4);
    n = r.subscribe(() => {
      r.loading || (clearTimeout(a), n?.(), s());
    });
  }), r.value?.vibes || null;
}
async function nI(i, A, e) {
  const t = i.account.get("sparks");
  if (!t?.startsWith("co_z")) throw new Error("[setSparkVibesId] account.sparks not found");
  const o = await i.read(null, t);
  await new Promise((n, a) => {
    if (!o.loading) return n();
    let I;
    const C = setTimeout(() => a(new Error("Timeout")), 1e4);
    I = o.subscribe(() => {
      o.loading || (clearTimeout(C), I?.(), n());
    });
  });
  const r = o.value?.[A];
  if (!r?.startsWith("co_z")) throw new Error(`[setSparkVibesId] Spark ${A} not found`);
  const s = i.getCoValue(r);
  if (!s) throw new Error(`[setSparkVibesId] Spark core not found: ${r}`);
  const g = i.getCurrentContent(s);
  if (!g || typeof g.set != "function") throw new Error("[setSparkVibesId] Spark content not available");
  g.set("vibes", e);
}
async function Mo(i) {
  return fs(i, "@maia");
}
function ws(i) {
  const A = [], e = /* @__PURE__ */ new Set();
  try {
    if (typeof i.getMemberKeys == "function") {
      const t = i.getMemberKeys();
      for (const o of t) {
        if (e.has(o)) continue;
        e.add(o);
        let r = null;
        if (typeof i.roleOf == "function")
          try {
            r = i.roleOf(o);
          } catch {
            try {
              const g = i.get(o);
              g && g !== "revoked" && (r = g);
            } catch {
            }
          }
        else if (typeof i.get == "function") {
          const s = i.get(o);
          s && s !== "revoked" && (r = s);
        }
        if (r && r !== "revoked") {
          const s = i.get ? i.get(o) : null, g = s === "revoked" || s !== r;
          A.push({
            id: o,
            role: r,
            isInherited: g || !1
          });
        }
      }
    }
    if (A.length === 0 && i.members && typeof i.members[Symbol.iterator] == "function") {
      for (const t of i.members)
        if (t && t.account) {
          const o = t.account, r = typeof o == "string" ? o : o.id || o.$jazz && o.$jazz.id || "unknown";
          if (e.has(r)) continue;
          e.add(r);
          let s = null;
          if (typeof i.roleOf == "function")
            try {
              s = i.roleOf(r);
            } catch {
            }
          s && s !== "revoked" && A.push({
            id: r,
            role: s,
            isInherited: !1
          });
        }
    }
  } catch (t) {
    console.warn("[CoJSONBackend] Error extracting account members:", t);
  }
  return A;
}
function aI(i) {
  try {
    let A = null;
    if (typeof i.getRoleOf == "function")
      try {
        const e = i.getRoleOf("everyone");
        e && typeof e == "string" && e !== "revoked" && (A = e);
      } catch {
      }
    if (!A && typeof i.get == "function")
      try {
        const e = i.get("everyone");
        e && typeof e == "string" && e !== "revoked" && (A = e);
      } catch {
      }
    if (!A && i.everyone !== void 0) {
      const e = i.everyone;
      e && typeof e == "string" && e !== "revoked" && (A = e);
    }
    return A;
  } catch {
    return null;
  }
}
function ps(i) {
  const A = [];
  try {
    if (typeof i.getParentGroups == "function") {
      const e = i.getParentGroups();
      if (e && typeof e[Symbol.iterator] == "function")
        for (const t of e) {
          const o = typeof t == "string" ? t : t.id || t.$jazz && t.$jazz.id || "unknown";
          let r = null;
          const s = `parent_${o}`;
          if (typeof i.get == "function")
            try {
              r = i.get(s);
            } catch {
            }
          let g = "";
          r === "extend" ? g = "Inherits roles from this group" : r === "reader" ? g = "All members of this group get reader access" : r === "writer" ? g = "All members of this group get writer access" : r === "manager" ? g = "All members of this group get manager access" : r === "admin" ? g = "All members of this group get admin access" : r === "revoked" ? g = "Delegation revoked" : g = "Delegated access";
          const n = [];
          try {
            const a = typeof t.getMemberKeys == "function" ? t.getMemberKeys() : [], I = typeof t.get == "function" && t.get("everyone"), C = [...a];
            I && C.push("everyone");
            for (const c of C) {
              const B = typeof t.roleOf == "function" ? t.roleOf(c) : null;
              if (!B || B === "revoked") continue;
              const Q = r === "extend" || r === "inherit" ? B : r;
              n.push({ id: c, role: Q });
            }
          } catch {
          }
          A.push({
            id: o,
            role: r || "extend",
            roleDescription: g,
            members: n
          });
        }
    }
  } catch (e) {
    console.warn("[CoJSONBackend] Error extracting group members:", e);
  }
  return A;
}
function br(i) {
  if (!i || typeof i.addMember != "function")
    return null;
  try {
    const A = i.id || i.$jazz && i.$jazz.id;
    if (!A)
      return null;
    const e = ws(i), t = aI(i);
    t && (e.some((s) => s.id === "everyone") || e.push({
      id: "everyone",
      role: t
    }));
    const o = ps(i);
    return {
      groupId: A,
      accountMembers: e,
      groupMembers: o
    };
  } catch (A) {
    return console.warn("[CoJSONBackend] Error getting group info from group:", A), null;
  }
}
async function ys(i, A, e, t, o = null) {
  if (typeof A.addMember != "function")
    throw new Error("[CoJSONBackend] Group does not support addMember");
  if (!e || !e.startsWith("co_z"))
    throw new Error("[CoJSONBackend] Agent account co-id required (co_z...). Sealer/signer IDs are not supported - agents must use their account.");
  if (o) {
    const { ensureCoValueLoaded: g } = await Promise.resolve().then(() => rQ);
    await g(o, e, { waitForAvailable: !0, timeoutMs: 1e4 });
  }
  const s = i.expectCoValueLoaded(e, "Expected account to be loaded for addMember").getCurrentContent();
  A.addMember(s, t);
}
function II(i, A) {
  return !(ws(i).filter(
    (s) => (s.role === "admin" || s.role === "manager") && s.id !== A
  ).length > 0 || ps(i).some((s) => s.role === "admin" || s.role === "extend"));
}
async function Ds(i, A) {
  const e = typeof A == "string" ? A : A?.id ?? A?.$jazz?.id;
  if (!e || !e.startsWith("co_z"))
    throw new Error("[removeGroupMember] member must be co-id (co_z...) or account content with .id");
  if (typeof i.removeMember != "function")
    throw new Error("[CoJSONBackend] Group does not support removeMember");
  if (II(i, e))
    throw new Error("[removeGroupMember] Cannot remove last admin. Group must have at least one admin.");
  i.removeMember(e);
}
async function CI(i, A, e, t) {
  if (typeof A.setRole == "function")
    A.setRole(e, t);
  else if (typeof A.removeMember == "function" && typeof A.addMember == "function")
    A.removeMember(e), await ys(i, A, e, t, null);
  else
    throw new Error("[CoJSONBackend] Group does not support role changes");
}
const ue = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addGroupMember: ys,
  extractAccountMembers: ws,
  extractEveryoneRole: aI,
  extractGroupMembers: ps,
  getCapabilityGroupIdFromOsId: ds,
  getGroup: sI,
  getGroupInfoFromGroup: br,
  getMaiaGroup: Mo,
  getSparkCapabilityGroupId: gI,
  getSparkCapabilityGroupIdFromSparkCoId: hs,
  getSparkGroup: fs,
  getSparkOsId: KA,
  getSparkVibesId: No,
  removeGroupMember: Ds,
  setGroupMemberRole: CI,
  setSparkVibesId: nI,
  wouldLeaveNoAdmins: II
}, Symbol.toStringTag, { value: "Module" }));
async function bQ(i, A) {
  if (i.node && i.account && i.guardian)
    return {
      node: i.node,
      account: i.account,
      guardian: i.guardian
    };
  if (i.node && i.account && A) {
    const e = await fs(i, A);
    return { node: i.node, account: i.account, guardian: e };
  }
  throw new Error(
    "[createCoValueForSpark] Invalid context. Provide backend (with node, account) + spark, or { node, account, guardian }."
  );
}
async function hA(i, A, e) {
  const { schema: t, cotype: o, data: r, dbEngine: s } = e;
  if (!t || typeof t != "string")
    throw new Error("[createCoValueForSpark] options.schema is required");
  if (!o || !["comap", "colist", "costream"].includes(o))
    throw new Error("[createCoValueForSpark] options.cotype must be comap, colist, or costream");
  const { node: g, account: n, guardian: a } = await bQ(i, A);
  if (!n)
    throw new Error("[createCoValueForSpark] Account required");
  const I = g.createGroup();
  I.extend(a, "admin");
  let C;
  switch (o) {
    case "comap":
      C = await iI(I, r ?? {}, t, g, s);
      break;
    case "colist":
      C = await oI(I, Array.isArray(r) ? r : [], t, g, s);
      break;
    case "costream":
      C = await rI(I, t, g, s);
      break;
    default:
      throw new Error("[createCoValueForSpark] Unsupported cotype: " + o);
  }
  const c = typeof g.getCurrentAccountOrAgentID == "function" ? g.getCurrentAccountOrAgentID() : n?.id ?? n?.$jazz?.id;
  try {
    await Ds(I, c);
  } catch (B) {
    throw new Error(`[createCoValueForSpark] Failed to remove account from group: ${B.message}`);
  }
  return { coValue: C };
}
const Re = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createCoValueForSpark: hA
}, Symbol.toStringTag, { value: "Module" }));
async function KQ(i, A, e) {
  try {
    const t = await aA(i, A, { waitForAvailable: !0 });
    if (t && i.isAvailable(t)) {
      const o = i.getCurrentContent(t);
      if (o && o.get) {
        const r = o.get("definition");
        if (r && r.cotype) {
          if (r.cotype === "cotext" || r.cotype === "coplaintext")
            throw new Error(`[CoJSONBackend] CoText (cotext) support has been eliminated. Schema ${A} specifies cotext, which is no longer supported.`);
          return r.cotype;
        }
      }
    }
  } catch (t) {
    console.warn(`[CoJSONBackend] Failed to load schema ${A} for cotype:`, t);
  }
  if (Array.isArray(e))
    return "colist";
  if (typeof e == "string")
    throw new Error(`[CoJSONBackend] Cannot determine cotype from data type for schema ${A}. String data type is not supported (CoText/cotext support has been eliminated). Use CoMap or CoList instead.`);
  if (typeof e == "object" && e !== null)
    return "comap";
  throw new Error(`[CoJSONBackend] Cannot determine cotype from data type for schema ${A}`);
}
async function ms(i, A, e, t = {}) {
  const o = t.spark ?? "@maia", r = await KQ(i, A, e);
  if (!i.account)
    throw new Error("[CoJSONBackend] Account required for create");
  if (r === "comap" && (!e || typeof e != "object" || Array.isArray(e)))
    throw new Error("[CoJSONBackend] Data must be object for comap");
  if (r === "colist" && !Array.isArray(e))
    throw new Error("[CoJSONBackend] Data must be array for colist");
  const { coValue: s } = await hA(i, o, {
    schema: A,
    cotype: r,
    data: r === "comap" || r === "colist" ? e : void 0,
    dbEngine: i.dbEngine
  }), g = i.node.getCoValue(s.id);
  if (g && i.isAvailable(g)) {
    const n = i.getCurrentContent(g);
    if (n && typeof n.get == "function") {
      const I = { id: s.id, ...e }, C = n.keys && typeof n.keys == "function" ? n.keys() : Object.keys(n);
      for (const c of C)
        I[c] = n.get(c);
      return I;
    }
    const a = Pa(i, g);
    return { ...e, id: s.id, ...a };
  }
  return {
    id: s.id,
    ...e,
    // Include original data to ensure text and other properties are available
    type: r,
    schema: A
  };
}
const Ss = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  create: ms
}, Symbol.toStringTag, { value: "Module" }));
function cI(i, A, e = {}) {
  if (!i || typeof i != "object")
    return i;
  const t = i.$schema;
  if (typeof t == "string" && /\/schema\/meta$/.test(t) || typeof t == "string" && t.startsWith("https://json-schema.org/") || typeof t == "string" && t.startsWith("https://"))
    return Fe(i, A);
  const r = i.actor !== void 0 || i.context !== void 0 || i.view !== void 0 || i.state !== void 0 || i.brand !== void 0 || i.style !== void 0 || i.inbox !== void 0 || i.subscribers !== void 0 || i.name !== void 0 && i.description !== void 0;
  return t && MA(t) && !/\/schema\/meta$/.test(t) || r ? ug(i, A, e) : i.properties !== void 0 || i.$defs !== void 0 || i.items !== void 0 && typeof i.items == "object" && !Array.isArray(i.items) || i.cotype !== void 0 ? Fe(i, A) : ug(i, A, e);
}
function Fe(i, A) {
  if (!i || typeof i != "object")
    return i;
  const e = JSON.parse(JSON.stringify(i));
  if (e.$schema) {
    const o = e.$schema;
    if (MA(o)) {
      const r = A.get(o);
      r && (e.$schema = r);
    }
  }
  if (e.$id && typeof e.$id == "string" && (MA(e.$id) || e.$id.startsWith("https://"))) {
    const o = A.get(e.$id);
    o && (e.$id = o);
  }
  if (e.properties && YQ(e.properties, A), e.$defs)
    for (const [o, r] of Object.entries(e.$defs))
      e.$defs[o] = Fe(r, A);
  return Kr(e, A, e.$id || "root") > 0 && e.$id, e.items && (e.items = Fe(e.items, A)), e.additionalProperties && typeof e.additionalProperties == "object" && (e.additionalProperties = Fe(e.additionalProperties, A)), ["allOf", "anyOf", "oneOf"].forEach((o) => {
    e[o] && Array.isArray(e[o]) && (e[o] = e[o].map(
      (r) => Fe(r, A)
    ));
  }), e;
}
function YQ(i, A) {
  for (const [e, t] of Object.entries(i))
    t && typeof t == "object" && (i[e] = Fe(t, A));
}
function Kr(i, A, e = "") {
  if (!i || typeof i != "object")
    return 0;
  let t = 0;
  if (i.$co && typeof i.$co == "string") {
    const o = i.$co;
    if (o.startsWith("co_z"))
      return 0;
    if (MA(o)) {
      const r = A.get(o);
      if (r)
        i.$co = r, t++;
      else {
        const s = Array.from(A.keys()).filter((g) => MA(g)).slice(0, 10).join(", ");
        throw console.error(`[SchemaTransformer]  No co-id found for $co reference at ${e || "root"}: ${o}. Available schema keys (first 10): ${s}`), new Error(`[SchemaTransformer] Failed to transform $co reference: ${o}. Schema must be registered before it can be referenced.`);
      }
    }
  }
  for (const [o, r] of Object.entries(i))
    if (!(o === "$schema" || o === "$id" || o.startsWith("$")))
      if (r && typeof r == "object" && !Array.isArray(r)) {
        const s = e ? `${e}.${o}` : o;
        t += Kr(r, A, s);
      } else Array.isArray(r) && r.forEach((s, g) => {
        if (s && typeof s == "object") {
          const n = e ? `${e}.${o}[${g}]` : `${o}[${g}]`;
          t += Kr(s, A, n);
        }
      });
  return t;
}
function ug(i, A, e = {}) {
  if (!i || typeof i != "object")
    return i;
  const t = JSON.parse(JSON.stringify(i));
  if (t.$schema) {
    const r = t.$schema;
    if (MA(r)) {
      const s = A.get(r);
      s && (t.$schema = s);
    }
  }
  if (t.$id && typeof t.$id == "string" && !t.$id.startsWith("co_z")) {
    const r = MA(t.$id) || t.$id.startsWith("vibe/") || t.$id.startsWith("actor/") || t.$id.startsWith("view/") || t.$id.startsWith("context/") || t.$id.startsWith("state/") || t.$id.startsWith("interface/") || t.$id.startsWith("style/") || t.$id.startsWith("brand/") || t.$id.startsWith("tool/"), s = A.get(t.$id);
    s ? t.$id = s : r && console.warn(`[SchemaTransformer] No co-id found for $id: ${t.$id}`);
  }
  const o = ["actor", "context", "view", "state", "brand", "style", "inbox", "subscribers"];
  for (const r of o)
    if (t[r] && typeof t[r] == "string") {
      const s = t[r];
      if (s.startsWith("co_z"))
        continue;
      if (!s.startsWith("@"))
        throw new Error(`[SchemaTransformer] ${r} reference must use @maiatype/instance format, got: ${s}`);
      const g = A.get(s);
      if (g)
        t[r] = g;
      else {
        const n = Array.from(A.keys()).filter((a) => a.startsWith("@")).slice(0, 10).join(", ");
        throw new Error(
          `[SchemaTransformer] No co-id found for ${r} reference: ${s}. Make sure the referenced instance exists and has a unique $id. Available refs (first 10): ${n}`
        );
      }
    }
  if (t.actors && typeof t.actors == "object" && !Array.isArray(t.actors)) {
    for (const [r, s] of Object.entries(t.actors))
      if (typeof s == "string") {
        if (s.startsWith("co_z"))
          continue;
        if (!s.match(/^@[^/]+.*\/actor\//))
          throw new Error(`[SchemaTransformer] context.actors[${r}] must use @namespace/actor/instance format, got: ${s}`);
        const g = A.get(s);
        if (g)
          t.actors[r] = g;
        else
          throw new Error(
            `[SchemaTransformer] No co-id found for context.actors[${r}] reference: ${s}. Make sure the referenced actor exists and has a unique $id.`
          );
      }
  }
  if (t.children && typeof t.children == "object") {
    for (const [r, s] of Object.entries(t.children))
      if (typeof s == "string" && !s.startsWith("co_z")) {
        if (!s.match(/^@[^/]+.*\/actor\//))
          throw new Error(`[SchemaTransformer] children[${r}] reference must use @namespace/actor/instance format, got: ${s}`);
        const g = A.get(s);
        if (g)
          t.children[r] = g;
        else {
          const n = Array.from(A.keys()).filter((a) => a.startsWith("@actor/")).slice(0, 10).join(", ");
          throw new Error(
            `[SchemaTransformer] No co-id found for children[${r}] reference: ${s}. Available actors (first 10): ${n}`
          );
        }
      }
  }
  if (t.items && Array.isArray(t.items) && t.items.some(
    (s) => typeof s == "string" && s.startsWith("@") && !s.startsWith("co_z")
  ) && (t.items = t.items.map((s) => {
    if (typeof s == "string" && !s.startsWith("co_z")) {
      if (!s.startsWith("@"))
        throw new Error(`[SchemaTransformer] items array reference must use @maiatype/instance format, got: ${s}`);
      const g = A.get(s);
      if (g)
        return g;
      throw new Error(`[SchemaTransformer] No co-id found for items reference: ${s}. Make sure the referenced instance exists and has a unique $id.`);
    }
    return s;
  })), t.source && typeof t.source == "string" && !t.source.startsWith("co_z")) {
    if (!t.source.startsWith("@"))
      throw new Error(`[SchemaTransformer] source reference must use @actor/instance format, got: ${t.source}`);
    const r = A.get(t.source);
    if (r)
      t.source = r;
    else
      throw new Error(`[SchemaTransformer] No co-id found for source reference: ${t.source}`);
  }
  if (t.target && typeof t.target == "string" && !t.target.startsWith("co_z")) {
    if (!t.target.match(/^@[^/]+.*\/actor\//))
      throw new Error(`[SchemaTransformer] target reference must use @namespace/actor/instance format, got: ${t.target}`);
    const r = A.get(t.target);
    if (r)
      t.target = r;
    else
      throw new Error(`[SchemaTransformer] No co-id found for target reference: ${t.target}`);
  }
  if (t.states && typeof t.states == "object" && !Array.isArray(t.states)) {
    for (const [r, s] of Object.entries(t.states))
      if (!(!s || typeof s != "object")) {
        if (s.entry)
          if (s.entry.tool && s.entry.payload)
            qt(s.entry.payload, A, jA);
          else if (s.entry.mapData && typeof s.entry.mapData == "object") {
            const g = s.entry.mapData;
            for (const [n, a] of Object.entries(g)) {
              if (a && typeof a == "object" && a.schema && typeof a.schema == "string") {
                const I = st(a.schema, A, `mapData.${n}.schema`);
                I && (a.schema = I);
              }
              a && typeof a == "object" && jA(a, A);
            }
          } else Array.isArray(s.entry) ? Yr(s.entry, A, jA) : s.entry.payload && qt(s.entry.payload, A, jA);
        if (s.on && typeof s.on == "object")
          for (const [g, n] of Object.entries(s.on))
            n && typeof n == "object" && Array.isArray(n.actions) && Yr(n.actions, A, jA);
      }
  }
  return jA(t, A), t;
}
function st(i, A, e = "") {
  if (MA(i) && !i.startsWith("co_z")) {
    const t = A.get(i);
    return t || (console.warn(`[SchemaTransformer] No co-id found for ${e} schema: ${i}. Make sure data collections are registered before transformation.`), null);
  }
  return i;
}
function Ht(i, A, e = "") {
  if (i.match(/^@[^/]+.*\/actor\//) && !i.startsWith("co_z")) {
    const t = A.get(i);
    if (t)
      return t;
    {
      const o = Array.from(A.keys()).filter((n) => n.includes("actor") || n.includes("vibe") || n.includes("composite")), r = o.length, s = o.slice(0, e.includes("array") ? 10 : 20).join(", "), g = r > (e.includes("array") ? 10 : 20) ? "..." : "";
      return console.warn(`[SchemaTransformer]  No co-id found for ${e} target: ${i}. Available actor keys (${r}): ${s}${g}`), null;
    }
  }
  return i;
}
function UQ(i, A) {
  if (!("key" in i && !("op" in i)) && i.schema && typeof i.schema == "string") {
    const e = st(i.schema, A, "query object");
    e && (i.schema = e);
  }
}
function qt(i, A, e) {
  if (!(!i || typeof i != "object")) {
    if (e(i, A), i.schema && typeof i.schema == "string") {
      const t = st(i.schema, A, "tool payload");
      t && (i.schema = t);
    }
    if (i.target && typeof i.target == "string") {
      const t = Ht(i.target, A, "tool payload");
      t && (i.target = t);
    }
  }
}
function BI(i, A, e) {
  if (!(!i.payload || typeof i.payload != "object")) {
    if (i.payload.target && typeof i.payload.target == "string") {
      const t = Ht(i.payload.target, A, "tool action");
      t && (i.payload.target = t);
    }
    e(i.payload, A);
  }
}
function Yr(i, A, e) {
  for (let t = 0; t < i.length; t++) {
    const o = i[t];
    if (o && typeof o == "object")
      if (o.mapData && typeof o.mapData == "object")
        for (const [r, s] of Object.entries(o.mapData)) {
          if (s && typeof s == "object" && s.schema && typeof s.schema == "string") {
            const g = st(s.schema, A, `mapData.${r}.schema in array`);
            g && (s.schema = g);
          }
          s && typeof s == "object" && e(s, A);
        }
      else if (o.tool && typeof o.tool == "string" && o.payload && typeof o.payload == "object")
        BI(o, A, e), qt(o.payload, A, e);
      else if (o.payload && typeof o.payload == "object") {
        if (o.payload.target && typeof o.payload.target == "string") {
          const r = Ht(o.payload.target, A, "action payload.target in array");
          r && (o.payload.target = r);
        }
        qt(o.payload, A, e);
      } else
        e(o, A);
    else if (typeof o == "string" && o.startsWith("@actor/") && !o.startsWith("co_z")) {
      const r = A.get(o);
      r && (i[t] = r);
    }
  }
}
function jA(i, A, e = 0) {
  if (!(!i || typeof i != "object" || Array.isArray(i))) {
    for (const [t, o] of Object.entries(i))
      if (!(t === "$schema" || t === "$id" || t.startsWith("$"))) {
        if (t === "schema" && typeof o == "string") {
          const r = st(o, A, "top-level schema field");
          r && (i[t] = r);
          continue;
        }
        if (t === "@actors" && o && typeof o == "object" && !Array.isArray(o)) {
          for (const [r, s] of Object.entries(o))
            if (typeof s == "string") {
              if (s.startsWith("co_z"))
                continue;
              if (!s.match(/^@[^/]+.*\/actor\//))
                throw new Error(`[SchemaTransformer] context.@actors[${r}] must use @namespace/actor/instance format, got: ${s}`);
              const g = Ht(s, A, `context.@actors[${r}]`);
              g && (o[r] = g);
            }
          continue;
        }
        if (t === "actors" && o && typeof o == "object" && !Array.isArray(o))
          throw new Error('[SchemaTransformer] Legacy "actors" property found. Please migrate to "@actors" system property.');
        if (t === "target" && typeof o == "string") {
          const r = Ht(o, A, "target field");
          r && (i[t] = r);
          continue;
        }
        if (o && typeof o == "object" && !Array.isArray(o))
          if (o.mapData && typeof o.mapData == "object") {
            const r = o.mapData;
            for (const [s, g] of Object.entries(r)) {
              if (g && typeof g == "object" && g.schema && typeof g.schema == "string") {
                const n = st(g.schema, A, `mapData.${s}.schema`);
                n && (g.schema = n);
              }
              g && typeof g == "object" && jA(g, A, e + 1);
            }
            continue;
          } else o.schema && typeof o.schema == "string" && !("key" in o) && !("op" in o) ? UQ(o, A) : o.payload && typeof o.payload == "object" ? qt(o.payload, A, jA) : o.tool && typeof o.tool == "string" && o.payload && typeof o.payload == "object" ? BI(o, A, jA) : jA(o, A, e + 1);
        else o && typeof o == "object" && Array.isArray(o) && Yr(o, A, jA);
      }
  }
}
function co(i, A = "", e = {}) {
  const { checkSchemaReferences: t = !0, checkNestedCoTypes: o = !0 } = e, r = [];
  if (!i || typeof i != "object")
    return r;
  if (t && (i.$co && typeof i.$co == "string" && MA(i.$co) && r.push(`Found @maia/schema/ reference in $co at ${A || "root"}: ${i.$co}. All $co references must be transformed to co-ids.`), i.$schema && typeof i.$schema == "string" && MA(i.$schema) && r.push(`Found @maia/schema/ reference in $schema at ${A || "root"}: ${i.$schema}. $schema must be transformed to co-id.`), i.$id && typeof i.$id == "string" && MA(i.$id) && r.push(`Found @maia/schema/ reference in $id at ${A || "root"}: ${i.$id}. $id must be transformed to co-id.`)), o && i.cotype && A !== "")
    return r.push(`Nested co-type detected at ${A}. Use \`$co\` keyword to reference a separate CoValue entity instead.`), r;
  for (const [s, g] of Object.entries(i))
    if (g && typeof g == "object" && !Array.isArray(g)) {
      const n = A ? `${A}.${s}` : s, a = co(g, n, e);
      r.push(...a);
    } else Array.isArray(g) && g.forEach((n, a) => {
      if (n && typeof n == "object") {
        const I = A ? `${A}.${s}[${a}]` : `${s}[${a}]`, C = co(n, I, e);
        r.push(...C);
      }
    });
  return r;
}
const Ns = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  transformForSeeding: cI,
  validateSchemaStructure: co
}, Symbol.toStringTag, { value: "Module" }));
class QI {
  constructor() {
    this.registry = /* @__PURE__ */ new Map(), this.reverseRegistry = /* @__PURE__ */ new Map();
  }
  /**
   * Register a co-id for a human-readable ID
   * @param {string} humanId - Human-readable ID (e.g., "@maia/schema/actor", "actor_001")
   * @param {string} coId - Generated co-id
   */
  register(A, e) {
    if (this.registry.has(A)) {
      const t = this.registry.get(A);
      if (t !== e)
        throw new Error(`Co-id already registered for ${A}: ${t} (trying to register ${e})`);
      return;
    }
    this.registry.set(A, e), this.reverseRegistry.has(e) || this.reverseRegistry.set(e, A);
  }
  /**
   * Get co-id for a human-readable ID
   * @param {string} humanId - Human-readable ID
   * @returns {string|null} Co-id or null if not found
   */
  get(A) {
    return this.registry.get(A) || null;
  }
  /**
   * Get human-readable ID for a co-id
   * @param {string} coId - Co-id
   * @returns {string|null} Human-readable ID or null if not found
   */
  getHumanId(A) {
    return this.reverseRegistry.get(A) || null;
  }
  /**
   * Check if human-readable ID is registered
   * @param {string} humanId - Human-readable ID
   * @returns {boolean}
   */
  has(A) {
    return this.registry.has(A);
  }
  /**
   * Get all registered mappings
   * @returns {Map<string, string>} Map of human-readable ID  co-id
   */
  getAll() {
    return new Map(this.registry);
  }
  /**
   * Clear all registrations
   */
  clear() {
    this.registry.clear(), this.reverseRegistry.clear();
  }
}
const EI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CoIdRegistry: QI
}, Symbol.toStringTag, { value: "Module" })), vQ = "@maia/schema/meta", JQ = "@maia/schema/actor", HQ = "@maia/schema/actor", qQ = "Pure declarative actor specification", LQ = "comap", xQ = !0, OQ = { role: { type: "string", description: "Actor role (e.g., 'kanban-view', 'vibe', 'composite', 'leaf')" }, context: { $co: "@maia/schema/context", description: "Co-id reference to context definition" }, view: { $co: "@maia/schema/view", description: "Co-id reference to view definition" }, state: { $co: "@maia/schema/state", description: "Co-id reference to state machine definition" }, brand: { $co: "@maia/schema/style", description: "Co-id reference to brand style definition (uses style schema)" }, style: { $co: "@maia/schema/style", description: "Co-id reference to local style definition" }, inbox: { $co: "@maia/schema/inbox", description: "Co-id reference to message inbox costream (append-only message feed)" }, messageTypes: { type: "array", items: { type: "string" }, description: "REQUIRED: Message types this actor accepts (exhaustive list - like sealed protocol). All actors must declare their message contracts." } }, TQ = {
  $schema: vQ,
  $id: JQ,
  title: HQ,
  description: qQ,
  cotype: LQ,
  indexing: xQ,
  properties: OQ
}, PQ = "@maia/schema/meta", jQ = "@maia/schema/context", VQ = "@maia/schema/context", WQ = "Runtime data for an actor (flexible JSON structure). The context itself is a comap CoValue (for CRDT sync/versioning), but all inner properties are plain JS objects/arrays/strings - NOT CoJSON types.", zQ = "comap", ZQ = !0, _Q = { description: "Any context fields (query objects, collections, UI state, form values, etc.). Query objects have schema + options properties. All inner properties are plain JS types (objects/arrays/strings/primitives) - NOT CoJSON types.", anyOf: [{ type: "object", description: "Query object for reactive subscription (has schema property). Can include nested options object with map, filter, etc.", properties: { schema: { type: "string", description: "Schema reference (e.g., '@maia/schema/message' or co-id)" }, options: { type: "object", description: "Query options (map, filter, etc.)", properties: { map: { type: "object", description: "Map transformation expressions (e.g., { sender: '$$source.role' })", additionalProperties: { type: "string" } }, filter: { description: "Filter criteria", oneOf: [{ type: "object" }, { type: "null" }] } }, additionalProperties: !0 }, filter: { description: "Filter criteria (legacy - use options.filter instead)", oneOf: [{ type: "object" }, { type: "null" }] } }, required: ["schema"], additionalProperties: !0 }, { type: "array", description: "Array of data items (after SubscriptionEngine processes the query object)" }, { type: "string" }, { type: "number" }, { type: "boolean" }, { type: "null" }, { type: "object", description: "Any other nested object (UI state, form values, etc.)" }] }, $Q = {
  $schema: PQ,
  $id: jQ,
  title: VQ,
  description: WQ,
  cotype: zQ,
  indexing: ZQ,
  additionalProperties: _Q
}, XQ = "@maia/schema/meta", AE = "@maia/schema/state", eE = "@maia/schema/state", tE = "XState-like state machine with states, transitions, guards, and actions", iE = "comap", oE = !0, rE = ["initial", "states"], sE = { initial: { type: "string", description: "Initial state name" }, states: { type: "object", description: "State definitions", additionalProperties: { type: "object", properties: { entry: { oneOf: [{ type: "object", description: "Inline tool action object", properties: { tool: { type: "string", description: "Tool identifier" }, payload: { type: "object", description: "Tool payload", additionalProperties: !0 } }, required: ["tool"] }, { type: "object", description: "Infrastructure context update action", properties: { updateContext: { type: "object", description: "Context updates (infrastructure, not a tool)", additionalProperties: !0 } }, required: ["updateContext"] }, { type: "object", description: "Map operations engine configs to context keys (universal API)", properties: { mapData: { type: "object", description: "Map operations engine configs to context keys (universal API)", additionalProperties: { type: "object", description: "Operations engine config (op, schema, filter, key, keys, etc.)", properties: { op: { type: "string", description: "Operation type (read, create, update, delete, schema, resolve, etc.)", default: "read" } }, additionalProperties: !0 } } }, required: ["mapData"] }, { type: "array", description: "Array of inline action objects", items: { oneOf: [{ type: "object", properties: { tool: { type: "string", description: "Tool identifier" }, payload: { type: "object", description: "Tool payload", additionalProperties: !0 } }, required: ["tool"] }, { type: "object", properties: { updateContext: { type: "object", description: "Context updates (infrastructure, not a tool)", additionalProperties: !0 } }, required: ["updateContext"] }, { type: "object", properties: { mapData: { type: "object", description: "Map operations engine configs to context keys (universal API)", additionalProperties: { type: "object", description: "Operations engine config (op, schema, filter, key, keys, etc.)", properties: { op: { type: "string", description: "Operation type (read, create, update, delete, schema, resolve, etc.)", default: "read" } }, additionalProperties: !0 } } }, required: ["mapData"] }] } }, { $co: "@maia/schema/action", description: "Co-id reference to action CoValue" }, { type: "array", description: "Array of action co-id references", items: { $co: "@maia/schema/action" } }] }, exit: { oneOf: [{ type: "object", description: "Inline tool action object", properties: { tool: { type: "string", description: "Tool identifier" }, payload: { type: "object", description: "Tool payload", additionalProperties: !0 } }, required: ["tool"] }, { type: "object", description: "Infrastructure context update action", properties: { updateContext: { type: "object", description: "Context updates (infrastructure, not a tool)", additionalProperties: !0 } }, required: ["updateContext"] }, { type: "object", description: "Map operations engine configs to context keys (universal API)", properties: { mapData: { type: "object", description: "Map operations engine configs to context keys (universal API)", additionalProperties: { type: "object", description: "Operations engine config (op, schema, filter, key, keys, etc.)", properties: { op: { type: "string", description: "Operation type (read, create, update, delete, schema, resolve, etc.)", default: "read" } }, additionalProperties: !0 } } }, required: ["mapData"] }, { type: "array", description: "Array of inline action objects", items: { oneOf: [{ type: "object", properties: { tool: { type: "string", description: "Tool identifier" }, payload: { type: "object", description: "Tool payload", additionalProperties: !0 } }, required: ["tool"] }, { type: "object", properties: { updateContext: { type: "object", description: "Context updates (infrastructure, not a tool)", additionalProperties: !0 } }, required: ["updateContext"] }, { type: "object", properties: { mapData: { type: "object", description: "Map operations engine configs to context keys (universal API)", additionalProperties: { type: "object", description: "Operations engine config (op, schema, filter, key, keys, etc.)", properties: { op: { type: "string", description: "Operation type (read, create, update, delete, schema, resolve, etc.)", default: "read" } }, additionalProperties: !0 } } }, required: ["mapData"] }] } }, { $co: "@maia/schema/action", description: "Co-id reference to action CoValue" }, { type: "array", description: "Array of action co-id references", items: { $co: "@maia/schema/action" } }] }, on: { type: "object", description: "Event handlers (transitions)", additionalProperties: { oneOf: [{ type: "string", description: "Simple target state name" }, { type: "object", description: "Inline transition object", properties: { target: { type: "string", description: "Target state name" }, guard: { type: "object", description: "Guard condition", additionalProperties: !0 }, actions: { type: "array", description: "Transition actions", items: { oneOf: [{ type: "object", properties: { tool: { type: "string", description: "Tool identifier" }, payload: { type: "object", additionalProperties: !0 } }, required: ["tool"] }, { type: "object", properties: { updateContext: { type: "object", description: "Context updates (infrastructure, not a tool)", additionalProperties: !0 } }, required: ["updateContext"] }, { $co: "@maia/schema/action" }] } } }, required: ["target"] }, { $co: "@maia/schema/transition", description: "Co-id reference to transition CoValue" }] } } }, additionalProperties: !1 } } }, gE = {
  $schema: XQ,
  $id: AE,
  title: eE,
  description: tE,
  cotype: iE,
  indexing: oE,
  required: rE,
  properties: sE
}, nE = "@maia/schema/meta", aE = "@maia/schema/view", IE = "@maia/schema/view", CE = "UI structure definition with DOM tree, expressions, loops, and event handlers (recursive viewNode structure)", cE = "comap", BE = !0, QE = { content: { type: "object", description: "View content structure (recursive viewNode)", $ref: "#/$defs/viewNode" } }, EE = { viewNode: { type: "object", description: "Recursive DOM node structure", properties: { tag: { type: "string" }, class: { type: "string" }, text: { anyOf: [{ type: "string", pattern: "^\\$\\$" }, { type: "string", pattern: "^@" }, { type: "string", pattern: "^\\$[^$]" }, { type: "string" }, { type: "number" }, { type: "boolean" }, { type: "null" }] }, value: { anyOf: [{ type: "string", pattern: "^\\$\\$" }, { type: "string", pattern: "^@" }, { type: "string", pattern: "^\\$[^$]" }, { type: "string" }, { type: "number" }, { type: "boolean" }, { type: "null" }] }, attrs: { type: "object", additionalProperties: { anyOf: [{ type: "string", pattern: "^\\$\\$" }, { type: "string", pattern: "^@" }, { type: "string", pattern: "^\\$[^$]" }, { type: "string" }, { type: "number" }, { type: "boolean" }, { type: "null" }, { type: "object", additionalProperties: { anyOf: [{ type: "string", pattern: "^\\$\\$" }, { type: "string", pattern: "^@" }, { type: "string", pattern: "^\\$[^$]" }, { type: "string" }, { type: "number" }, { type: "boolean" }, { type: "null" }] } }] } }, children: { type: "array", items: { $ref: "#/$defs/viewNode" } }, $on: { type: "object", additionalProperties: { type: "object", properties: { send: { type: "string" }, payload: { type: "object", additionalProperties: !0 }, key: { type: "string" } }, required: ["send"] } }, $each: { type: "object", properties: { items: { anyOf: [{ type: "string", pattern: "^\\$\\$" }, { type: "string", pattern: "^@" }, { type: "string", pattern: "^\\$[^$]" }, { type: "string" }, { type: "number" }, { type: "boolean" }, { type: "null" }] }, template: { $ref: "#/$defs/viewNode" } }, required: ["items", "template"] }, $slot: { anyOf: [{ type: "string", pattern: "^\\$\\$" }, { type: "string", pattern: "^@" }, { type: "string", pattern: "^\\$[^$]" }, { type: "string" }, { type: "number" }, { type: "boolean" }, { type: "null" }] } }, additionalProperties: !1 } }, lE = !1, uE = {
  $schema: nE,
  $id: aE,
  title: IE,
  description: CE,
  cotype: cE,
  indexing: BE,
  properties: QE,
  $defs: EE,
  additionalProperties: lE
}, dE = "@maia/schema/meta", hE = "@maia/schema/style", fE = "@maia/schema/style", wE = "Style definition (brand or actor-specific). Brand styles typically include selectors, actor styles are overrides.", pE = "comap", yE = !0, DE = { tokens: { type: "object", description: "Design tokens (colors, spacing, typography, etc.)", additionalProperties: !0 }, components: { type: "object", description: "Component styles", additionalProperties: !0 }, selectors: { type: "object", description: "CSS selector-based styles (typically used in brand styles)", additionalProperties: { type: "object", description: "CSS properties and values", additionalProperties: { oneOf: [{ type: "string" }, { type: "number" }, { type: "object", additionalProperties: !0 }] } } } }, ii = {
  $schema: dE,
  $id: hE,
  title: fE,
  description: wE,
  cotype: pE,
  indexing: yE,
  properties: DE
}, mE = "@maia/schema/meta", SE = "@maia/schema/tool", NE = "@maia/schema/tool", ME = "Tool metadata (AI-compatible JSON schema)", kE = "comap", GE = !0, FE = ["name", "description", "parameters"], RE = { name: { type: "string", description: "Tool identifier (e.g., '@mutation/create')", pattern: "^@" }, description: { type: "string", description: "Tool description" }, parameters: { type: "object", description: "JSON Schema for tool parameters (standard JSON Schema format)", properties: { type: { type: "string", enum: ["object", "array", "string", "number", "boolean", "null"] }, properties: { type: "object", additionalProperties: { type: "object", description: "Parameter property schema", properties: { type: { type: "string" }, description: { type: "string" }, required: { type: "boolean" }, properties: { type: "object", additionalProperties: !0 } }, additionalProperties: !0 } }, required: { type: "array", items: { type: "string" } } }, required: ["type"], additionalProperties: !0 } }, bE = {
  $schema: mE,
  $id: SE,
  title: NE,
  description: ME,
  cotype: kE,
  indexing: GE,
  required: FE,
  properties: RE
}, KE = "@maia/schema/meta", YE = "@maia/schema/vibe", UE = "@maia/schema/vibe", vE = "Vibe manifest/metadata", JE = "comap", HE = !0, qE = ["name", "description", "actor"], LE = { name: { type: "string", description: "Vibe name" }, description: { type: "string", description: "Vibe description" }, actor: { $co: "@maia/schema/actor", description: "Co-id reference to actor definition (root actor for this vibe)" } }, xE = {
  $schema: KE,
  $id: YE,
  title: UE,
  description: vE,
  cotype: JE,
  indexing: HE,
  required: qE,
  properties: LE
}, OE = "@maia/schema/meta", TE = "@maia/schema/message", PE = "@maia/schema/message", jE = "Actor message for state machine transitions", VE = "comap", WE = !0, zE = ["type"], ZE = { type: { type: "string", description: "Message type (event name)" }, payload: { type: "object", description: "Message payload data" }, source: { $co: "@maia/schema/actor", description: "Co-id reference to source actor" }, target: { $co: "@maia/schema/actor", description: "Co-id reference to target actor (required for direct messaging)" }, processed: { type: "boolean", description: "Whether this message has been processed", default: !1 } }, _E = {
  $schema: OE,
  $id: TE,
  title: PE,
  description: jE,
  cotype: VE,
  indexing: WE,
  required: zE,
  properties: ZE
}, $E = "@maia/schema/meta", XE = "@maia/schema/guard", Al = "@maia/schema/guard", el = "JSON Schema guard for conditional logic - checks state/context conditions (NOT payload validation)", tl = "comap", il = !0, ol = ["schema"], rl = { schema: { type: "object", description: "JSON Schema to validate against current state/context (for conditional logic only, NOT payload validation)", additionalProperties: !0 } }, sl = !1, gl = {
  $schema: $E,
  $id: XE,
  title: Al,
  description: el,
  cotype: tl,
  indexing: il,
  required: ol,
  properties: rl,
  additionalProperties: sl
}, nl = "@maia/schema/meta", al = "@maia/schema/action", Il = "@maia/schema/action", Cl = "Action (tool invocation, context update, or data mapping)", cl = "comap", Bl = !0, Ql = [{ type: "object", properties: { tool: { type: "string", description: "Tool identifier (e.g., '@mutation/create')" }, payload: { description: "Tool payload (can contain expressions)", type: "object", additionalProperties: !0 } }, required: ["tool"] }, { type: "object", properties: { updateContext: { type: "object", description: "Context updates (infrastructure, not a tool)", additionalProperties: !0 } }, required: ["updateContext"] }, { type: "object", properties: { mapData: { type: "object", description: "Map operations engine configs to context keys (universal API)", additionalProperties: { type: "object", description: "Operations engine config (op, schema, filter, key, keys, etc.)", properties: { op: { type: "string", description: "Operation type (read, create, update, delete, schema, resolve, etc.)", default: "read" } }, additionalProperties: !0 } } }, required: ["mapData"] }], El = {
  $schema: nl,
  $id: al,
  title: Il,
  description: Cl,
  cotype: cl,
  indexing: Bl,
  oneOf: Ql
}, ll = "@maia/schema/meta", ul = "@maia/schema/transition", dl = "@maia/schema/transition", hl = "State machine transition", fl = "comap", wl = !0, pl = { target: { type: "string", description: "Target state name" }, guard: { $co: "@maia/schema/guard" }, actions: { type: "array", items: { $co: "@maia/schema/action" } } }, yl = ["target"], Dl = {
  $schema: ll,
  $id: ul,
  title: dl,
  description: hl,
  cotype: fl,
  indexing: wl,
  properties: pl,
  required: yl
}, ml = "@maia/schema/meta", Sl = "@maia/schema/messagePayload", Nl = "@maia/schema/messagePayload", Ml = "Message payload definition", kl = "comap", Gl = !0, Fl = {}, Rl = !0, bl = {
  $schema: ml,
  $id: Sl,
  title: Nl,
  description: Ml,
  cotype: kl,
  indexing: Gl,
  properties: Fl,
  additionalProperties: Rl
}, Kl = "@maia/schema/meta", Yl = "@maia/schema/messageType", Ul = "@maia/schema/messageType", vl = "Message type schemas are standard JSON Schemas that validate message payloads. The schema ID (e.g., '@maia/schema/message/CREATE_BUTTON') identifies the message type.", Jl = "comap", Hl = !0, ql = "object", Ll = !0, xl = {
  $schema: Kl,
  $id: Yl,
  title: Ul,
  description: vl,
  cotype: Jl,
  indexing: Hl,
  type: ql,
  additionalProperties: Ll
}, Ol = "@maia/schema/meta", Tl = "@maia/schema/maia-script-expression", Pl = "@maia/schema/maia-script-expression", jl = "comap", Vl = !1, Wl = "JSON-based DSL expression schema for MaiaScript runtime logic. Supports data access, comparisons, logical operations, control flow, and nested expressions.", zl = [{ description: "Primitive value", type: ["number", "boolean", "null"] }, { description: "String value (including shortcut syntax $key or $$key)", type: "string" }, { $ref: "#/$defs/expressionObject" }], Zl = { expressionObject: { description: "MaiaScript expression object (DSL operation)", type: "object", oneOf: [{ description: "$context operation - access context data", properties: { $context: { type: "string", description: "Dot-separated path in context object (e.g., 'user.name')", pattern: "^[a-zA-Z_][a-zA-Z0-9_]*(\\.[a-zA-Z_][a-zA-Z0-9_]*)*$" } }, required: ["$context"], additionalProperties: !1 }, { description: "$item operation - access item data", properties: { $item: { type: "string", description: "Dot-separated path in item object (e.g., 'id', 'status.value')", pattern: "^[a-zA-Z_][a-zA-Z0-9_]*(\\.[a-zA-Z_][a-zA-Z0-9_]*)*$" } }, required: ["$item"], additionalProperties: !1 }, { description: "$eq operation - equality comparison", properties: { $eq: { type: "array", description: "Array of two expressions to compare", items: { $ref: "#" }, minItems: 2, maxItems: 2 } }, required: ["$eq"], additionalProperties: !1 }, { description: "$ne operation - inequality comparison", properties: { $ne: { type: "array", description: "Array of two expressions to compare", items: { $ref: "#" }, minItems: 2, maxItems: 2 } }, required: ["$ne"], additionalProperties: !1 }, { description: "$not operation - logical NOT (negate boolean)", properties: { $not: { $ref: "#", description: "Expression to negate (evaluated to boolean, then negated)" } }, required: ["$not"], additionalProperties: !1 }, { description: "$and operation - logical AND (all operands must be truthy)", properties: { $and: { type: "array", description: "Array of expressions to evaluate (all must be truthy)", items: { $ref: "#" }, minItems: 1 } }, required: ["$and"], additionalProperties: !1 }, { description: "$or operation - logical OR (at least one operand must be truthy)", properties: { $or: { type: "array", description: "Array of expressions to evaluate (at least one must be truthy)", items: { $ref: "#" }, minItems: 1 } }, required: ["$or"], additionalProperties: !1 }, { description: "$trim operation - trim whitespace from string", properties: { $trim: { $ref: "#", description: "Expression to trim (evaluated to string, then trimmed of leading/trailing whitespace)" } }, required: ["$trim"], additionalProperties: !1 }, { description: "$gt operation - greater than comparison", properties: { $gt: { type: "array", description: "Array of two expressions to compare (left > right)", items: { $ref: "#" }, minItems: 2, maxItems: 2 } }, required: ["$gt"], additionalProperties: !1 }, { description: "$length operation - get array or string length", properties: { $length: { $ref: "#", description: "Expression to get length of (evaluated to array or string)" } }, required: ["$length"], additionalProperties: !1 }, { description: "$concat operation - concatenate arrays", properties: { $concat: { type: "array", description: "Array of expressions, arrays, or objects to concatenate (all evaluated to arrays, then flattened)", items: { anyOf: [{ $ref: "#" }, { type: ["array", "object", "string", "number", "boolean", "null"] }] }, minItems: 1 } }, required: ["$concat"], additionalProperties: !1 }, { description: "$map operation - map over array", properties: { $map: { type: "object", description: "Map configuration object", properties: { array: { $ref: "#", description: "Expression evaluating to array to map over" }, as: { type: "string", description: "Variable name for each item in the array (default: 'item')" }, return: { description: "Expression, object, or array to evaluate for each item (result becomes item in returned array). 'do' is also supported as an alias.", anyOf: [{ $ref: "#" }, { type: ["object", "array", "string", "number", "boolean", "null"] }] }, do: { description: "Alias for 'return' - expression, object, or array to evaluate for each item", anyOf: [{ $ref: "#" }, { type: ["object", "array", "string", "number", "boolean", "null"] }] } }, required: ["array"], additionalProperties: !1 } }, required: ["$map"], additionalProperties: !1 }, { description: "$if operation - conditional expression", properties: { $if: { type: "object", description: "Conditional expression object", properties: { condition: { $ref: "#", description: "Condition expression (evaluated to boolean)" }, then: { $ref: "#", description: "Expression to evaluate if condition is true" }, else: { $ref: "#", description: "Expression to evaluate if condition is false" } }, required: ["condition", "then", "else"], additionalProperties: !1 } }, required: ["$if"], additionalProperties: !1 }] } }, _l = {
  $schema: Ol,
  $id: Tl,
  title: Pl,
  cotype: jl,
  indexing: Vl,
  description: Wl,
  anyOf: zl,
  $defs: Zl
}, $l = "@maia/schema/meta", Xl = "@maia/schema/subscribers", Au = "@maia/schema/subscribers", eu = "A colist of actor co-ids subscribed to a topic", tu = "colist", iu = !0, ou = { $co: "@maia/schema/actor", description: "Each item is a co-id reference to an actor subscribed to this topic" }, ru = {
  $schema: $l,
  $id: Xl,
  title: Au,
  description: eu,
  cotype: tu,
  indexing: iu,
  items: ou
}, su = "@maia/schema/meta", gu = "@maia/schema/inbox", nu = "@maia/schema/inbox", au = "A costream (append-only stream) of messages received by this actor", Iu = "costream", Cu = !0, cu = { $co: "@maia/schema/message", description: "Each item is a co-id reference to a message" }, Bu = {
  $schema: su,
  $id: gu,
  title: nu,
  description: au,
  cotype: Iu,
  indexing: Cu,
  items: cu
}, Qu = "@maia/schema/meta", Eu = "@maia/schema/children", lu = "@maia/schema/children", uu = "A comap of child actors (namekey  actor co-id)", du = "comap", hu = !0, fu = {}, wu = { $co: "@maia/schema/actor", description: "Each value is a co-id reference to a child actor" }, pu = {
  $schema: Qu,
  $id: Eu,
  title: lu,
  description: uu,
  cotype: du,
  indexing: hu,
  properties: fu,
  additionalProperties: wu
}, yu = "@maia/schema/meta", Du = "@maia/schema/os/schematas-registry", mu = "@maia/schema/os/schematas-registry", Su = "Schema registry CoMap - maps schema namekeys (e.g., @maia/schema/data/todos) to schema co-ids (co_z...). Stored in account.os.schematas", Nu = "comap", Mu = !1, ku = { "@maia/schema/meta": { type: "string", description: "Metaschema co-id (co_z...)" } }, Gu = { type: "string", description: "Schema namekey  schema co-id mapping (e.g., @maia/schema/data/todos  co_z123...)" }, Fu = {
  $schema: yu,
  $id: Du,
  title: mu,
  description: Su,
  cotype: Nu,
  indexing: Mu,
  properties: ku,
  additionalProperties: Gu
}, Ru = "@maia/schema/meta", bu = "@maia/schema/os/os-registry", Ku = "@maia/schema/os/os-registry", Yu = "OS CoMap - contains capabilities, schematas, indexes. Stored in spark.os", Uu = "comap", vu = !1, Ju = { capabilities: { type: "string", pattern: "^co_z[a-zA-Z0-9]+$", description: "Capabilities CoMap co-id (guardian, publicReaders)" }, schematas: { type: "string", pattern: "^co_z[a-zA-Z0-9]+$", description: "Schemata registry CoMap co-id" }, indexes: { type: "string", pattern: "^co_z[a-zA-Z0-9]+$", description: "Indexes registry CoMap co-id" } }, Hu = {
  $schema: Ru,
  $id: bu,
  title: Ku,
  description: Yu,
  cotype: Uu,
  indexing: vu,
  properties: Ju
}, qu = "@maia/schema/meta", Lu = "@maia/schema/os/capabilities", xu = "@maia/schema/os/capabilities", Ou = "Capabilities CoMap - guardian, publicReaders. Stored in spark.os.capabilities", Tu = "comap", Pu = !1, ju = { guardian: { type: "string", pattern: "^co_z[a-zA-Z0-9]+$", description: "Guardian group co-id" }, publicReaders: { type: "string", pattern: "^co_z[a-zA-Z0-9]+$", description: "Public readers group co-id" } }, Vu = {
  $schema: qu,
  $id: Lu,
  title: xu,
  description: Ou,
  cotype: Tu,
  indexing: Pu,
  properties: ju
}, Wu = "@maia/schema/meta", zu = "@maia/schema/os/indexes-registry", Zu = "@maia/schema/os/indexes-registry", _u = "Indexes registry CoMap - schema co-id -> index colist. Stored in spark.os.indexes", $u = "comap", Xu = !1, Ad = { type: "string", pattern: "^co_z[a-zA-Z0-9]+$", description: "Schema co-id -> index colist co-id" }, ed = {
  $schema: Wu,
  $id: zu,
  title: Zu,
  description: _u,
  cotype: $u,
  indexing: Xu,
  additionalProperties: Ad
}, td = "@maia/schema/meta", id = "@maia/schema/os/vibes-registry", od = "@maia/schema/os/vibes-registry", rd = "Vibes registry CoMap - vibe key -> vibe co-id. Stored in spark.vibes", sd = "comap", gd = !1, nd = { type: "string", pattern: "^co_z[a-zA-Z0-9]+$", description: "Vibe key -> vibe CoMap co-id" }, ad = {
  $schema: td,
  $id: id,
  title: od,
  description: rd,
  cotype: sd,
  indexing: gd,
  additionalProperties: nd
}, Id = "@maia/schema/meta", Cd = "@maia/schema/os/sparks-registry", cd = "@maia/schema/os/sparks-registry", Bd = "Sparks registry CoMap - spark name -> spark co-id. Stored in account.sparks", Qd = "comap", Ed = !1, ld = { type: "string", pattern: "^co_z[a-zA-Z0-9]+$", description: "Spark name -> spark CoMap co-id" }, ud = {
  $schema: Id,
  $id: Cd,
  title: cd,
  description: Bd,
  cotype: Qd,
  indexing: Ed,
  additionalProperties: ld
}, dd = "@maia/schema/meta", hd = "@maia/schema/os/humans-registry", fd = "@maia/schema/os/humans-registry", wd = "Humans registry CoMap - username -> account co-id. Stored in spark.registries.humans", pd = "comap", yd = !1, Dd = { type: "string", pattern: "^co_z[a-zA-Z0-9]{20,}$", description: "Username -> account co-id" }, md = {
  $schema: dd,
  $id: hd,
  title: fd,
  description: wd,
  cotype: pd,
  indexing: yd,
  additionalProperties: Dd
}, Sd = "@maia/schema/meta", Nd = "@maia/schema/os/registries", Md = "@maia/schema/os/registries", kd = "Registries CoMap - contains sparks, etc. Stored in spark.registries", Gd = "comap", Fd = !1, Rd = { sparks: { type: "string", pattern: "^co_z[a-zA-Z0-9]+$", description: "Sparks registry CoMap co-id (spark name -> spark co-id)" } }, bd = { type: "string", pattern: "^co_z[a-zA-Z0-9]+$", description: "Registry name -> registry CoMap co-id" }, Kd = {
  $schema: Sd,
  $id: Nd,
  title: Md,
  description: kd,
  cotype: Gd,
  indexing: Fd,
  properties: Rd,
  additionalProperties: bd
}, Yd = "@maia/schema/data/todos", Ud = "@maia/schema/meta", vd = "@maia/schema/data/todos", Jd = "comap", Hd = !0, qd = { text: { type: "string", minLength: 1, pattern: ".*\\S.*", description: "The todo item text content (must contain at least one non-whitespace character)" }, done: { type: "boolean", description: "Whether the todo item is completed" } }, Ld = ["text", "done"], xd = !1, Od = {
  $id: Yd,
  $schema: Ud,
  title: vd,
  cotype: Jd,
  indexing: Hd,
  properties: qd,
  required: Ld,
  additionalProperties: xd
}, Td = "@maia/schema/data/chat", Pd = "@maia/schema/meta", jd = "@maia/schema/data/chat", Vd = "comap", Wd = !0, zd = { role: { type: "string", enum: ["user", "assistant", "system"], description: "The role of the message sender" }, content: { type: "string", minLength: 1, description: "The message content" } }, Zd = ["role", "content"], _d = !1, $d = {
  $id: Td,
  $schema: Pd,
  title: jd,
  cotype: Vd,
  indexing: Wd,
  properties: zd,
  required: Zd,
  additionalProperties: _d
}, Xd = "@maia/schema/meta", Ah = "@maia/schema/data/spark", eh = "@maia/schema/data/spark", th = "Spark CoMap. Guardian (admin) group is spark.os.capabilities.guardian.", ih = "comap", oh = !0, rh = ["name"], sh = { name: { type: "string", description: "Spark name e.g. @maia" }, os: { type: "string", pattern: "^co_z[a-zA-Z0-9]+$", description: "OS CoMap - contains schematas, indexes, capabilities (guardian, publicReaders)." }, vibes: { type: "string", pattern: "^co_z[a-zA-Z0-9]+$", description: "Vibes registry CoMap for this spark." } }, gh = {
  $schema: Xd,
  $id: Ah,
  title: eh,
  description: th,
  cotype: ih,
  indexing: oh,
  required: rh,
  properties: sh
}, nh = "@maia/schema/meta", ah = "@maia/schema/message/CREATE_BUTTON", Ih = "@maia/schema/message/CREATE_BUTTON", Ch = "Message type for creating a new item via button click (generic, reusable across vibes)", ch = "comap", Bh = !0, Qh = "object", Eh = { value: { type: "string", minLength: 1, pattern: "^\\S", description: "Item value/text (required, non-empty, must contain at least one non-whitespace character). Generic property name for reuse across vibes." } }, lh = ["value"], uh = !0, dh = {
  $schema: nh,
  $id: ah,
  title: Ih,
  description: Ch,
  cotype: ch,
  indexing: Bh,
  type: Qh,
  properties: Eh,
  required: lh,
  additionalProperties: uh
}, hh = "@maia/schema/meta", fh = "@maia/schema/message/TOGGLE_BUTTON", wh = "@maia/schema/message/TOGGLE_BUTTON", ph = "Message type for toggling a todo item's done status", yh = "comap", Dh = !0, mh = "object", Sh = { id: { type: "string", pattern: "^co_z", description: "Todo item co-id (required)" }, done: { type: "boolean", description: "Current done status (optional, will be toggled)" } }, Nh = ["id"], Mh = !1, kh = {
  $schema: hh,
  $id: fh,
  title: wh,
  description: ph,
  cotype: yh,
  indexing: Dh,
  type: mh,
  properties: Sh,
  required: Nh,
  additionalProperties: Mh
}, Gh = "@maia/schema/meta", Fh = "@maia/schema/message/DELETE_BUTTON", Rh = "@maia/schema/message/DELETE_BUTTON", bh = "Message type for deleting a todo item", Kh = "comap", Yh = !0, Uh = "object", vh = { id: { type: "string", pattern: "^co_z", description: "Todo item co-id (required)" } }, Jh = ["id"], Hh = !1, qh = {
  $schema: Gh,
  $id: Fh,
  title: Rh,
  description: bh,
  cotype: Kh,
  indexing: Yh,
  type: Uh,
  properties: vh,
  required: Jh,
  additionalProperties: Hh
}, Lh = "@maia/schema/meta", xh = "@maia/schema/message/UPDATE_INPUT", Oh = "@maia/schema/message/UPDATE_INPUT", Th = "Message type for updating input field value (generic, reusable across vibes)", Ph = "comap", jh = !0, Vh = "object", Wh = { value: { type: "string", description: "New input field value (generic property name for reuse across vibes)" } }, zh = !0, Zh = {
  $schema: Lh,
  $id: xh,
  title: Oh,
  description: Th,
  cotype: Ph,
  indexing: jh,
  type: Vh,
  properties: Wh,
  additionalProperties: zh
}, _h = "@maia/schema/meta", $h = "@maia/schema/message/SWITCH_VIEW", Xh = "@maia/schema/message/SWITCH_VIEW", Af = "Message type for switching view mode", ef = "comap", tf = !0, of = "object", rf = { viewMode: { type: "string", enum: ["list", "logs", "comingSoon"], description: "View mode to switch to (required)" } }, sf = ["viewMode"], gf = !1, nf = {
  $schema: _h,
  $id: $h,
  title: Xh,
  description: Af,
  cotype: ef,
  indexing: tf,
  type: of,
  properties: rf,
  required: sf,
  additionalProperties: gf
}, af = "@maia/schema/meta", If = "@maia/schema/message/SUCCESS", Cf = "@maia/schema/message/SUCCESS", cf = "Message type for successful operation completion", Bf = "comap", Qf = !0, Ef = "object", lf = { result: { description: "Tool execution result (optional, can be any type - object, boolean, string, etc.)" }, value: { type: "string", description: "Original event payload property (optional, for CREATE_BUTTON, UPDATE_INPUT - generic property name)" }, text: { type: "string", description: "Original event payload property (optional, legacy - use 'value' instead)" }, id: { type: "string", pattern: "^co_z", description: "Original event payload property (optional, for TOGGLE_BUTTON, DELETE_BUTTON)" }, done: { type: "boolean", description: "Original event payload property (optional, for TOGGLE_BUTTON)" }, viewMode: { type: "string", enum: ["list", "logs"], description: "Original event payload property (optional, for SWITCH_VIEW)" }, newTodoText: { type: "string", description: "Original event payload property (optional, legacy - use 'value' instead)" } }, uf = !0, df = {
  $schema: af,
  $id: If,
  title: Cf,
  description: cf,
  cotype: Bf,
  indexing: Qf,
  type: Ef,
  properties: lf,
  additionalProperties: uf
}, hf = "@maia/schema/meta", ff = "@maia/schema/message/ERROR", wf = "@maia/schema/message/ERROR", pf = "Message type for operation errors. Aligned with OperationResult createErrorEntry shape.", yf = "comap", Df = !0, mf = "object", Sf = { errors: { type: "array", description: "Structured error entries. Same shape as OperationResult.", items: { type: "object", required: ["type", "message"], properties: { type: { type: "string", description: "Error type: schema | permission | structural" }, message: { type: "string", description: "Error message" }, path: { type: "string", description: "Optional path (e.g. /field)" } } } } }, Nf = ["errors"], Mf = !1, kf = {
  $schema: hf,
  $id: ff,
  title: wf,
  description: pf,
  cotype: yf,
  indexing: Df,
  type: mf,
  properties: Sf,
  required: Nf,
  additionalProperties: Mf
}, Gf = "@maia/schema/meta", Ff = "@maia/schema/message/SEND_MESSAGE", Rf = "@maia/schema/message/SEND_MESSAGE", bf = "Message type for sending a chat message", Kf = "comap", Yf = !0, Uf = "object", vf = { inputText: { type: "string", minLength: 1, description: "Message text (required, non-empty)" } }, Jf = ["inputText"], Hf = !1, qf = {
  $schema: Gf,
  $id: Ff,
  title: Rf,
  description: bf,
  cotype: Kf,
  indexing: Yf,
  type: Uf,
  properties: vf,
  required: Jf,
  additionalProperties: Hf
}, Lf = "@maia/schema/meta", xf = "@maia/schema/message/RETRY", Of = "@maia/schema/message/RETRY", Tf = "Message type for retrying a failed operation", Pf = "comap", jf = !0, Vf = "object", Wf = {}, zf = !1, Zf = {
  $schema: Lf,
  $id: xf,
  title: Of,
  description: Tf,
  cotype: Pf,
  indexing: jf,
  type: Vf,
  properties: Wf,
  additionalProperties: zf
}, _f = "@maia/schema/meta", $f = "@maia/schema/message/DISMISS", Xf = "@maia/schema/message/DISMISS", Aw = "Message type for dismissing an error or notification", ew = "comap", tw = !0, iw = "object", ow = {}, rw = !1, sw = {
  $schema: _f,
  $id: $f,
  title: Xf,
  description: Aw,
  cotype: ew,
  indexing: tw,
  type: iw,
  properties: ow,
  additionalProperties: rw
}, gw = "@maia/schema/meta", nw = "@maia/schema/message/SELECT_NAV", aw = "@maia/schema/message/SELECT_NAV", Iw = "Message type for selecting a navigation item", Cw = "comap", cw = !0, Bw = "object", Qw = { navId: { type: "string", description: "Navigation item ID (required)" } }, Ew = ["navId"], lw = !1, uw = {
  $schema: gw,
  $id: nw,
  title: aw,
  description: Iw,
  cotype: Cw,
  indexing: cw,
  type: Bw,
  properties: Qw,
  required: Ew,
  additionalProperties: lw
}, dw = "@maia/schema/meta", hw = "@maia/schema/message/SELECT_ROW", fw = "@maia/schema/message/SELECT_ROW", ww = "Message type for selecting a table row", pw = "comap", yw = !0, Dw = "object", mw = { rowId: { type: "string", description: "Row ID (required)" } }, Sw = ["rowId"], Nw = !1, Mw = {
  $schema: dw,
  $id: hw,
  title: fw,
  description: ww,
  cotype: pw,
  indexing: yw,
  type: Dw,
  properties: mw,
  required: Sw,
  additionalProperties: Nw
}, kw = "@maia/schema/meta", Gw = "@maia/schema/message/SELECT_SPARK", Fw = "@maia/schema/message/SELECT_SPARK", Rw = "Message type for selecting a spark (generic, reusable across vibes)", bw = "comap", Kw = !0, Yw = "object", Uw = { sparkId: { type: "string", description: "Spark co-id (required, generic property name for reuse across vibes)" } }, vw = ["sparkId"], Jw = !0, Hw = {
  $schema: kw,
  $id: Gw,
  title: Fw,
  description: Rw,
  cotype: bw,
  indexing: Kw,
  type: Yw,
  properties: Uw,
  required: vw,
  additionalProperties: Jw
}, qw = "@maia/schema/meta", Lw = "@maia/schema/message/LOAD_ACTOR", xw = "@maia/schema/message/LOAD_ACTOR", Ow = "Generic message type for loading actor data (reusable across vibes)", Tw = "comap", Pw = !0, jw = "object", Vw = { id: { type: "string", description: "Entity co-id to load (required, generic property name for reuse across vibes)" } }, Ww = ["id"], zw = !0, Zw = {
  $schema: qw,
  $id: Lw,
  title: xw,
  description: Ow,
  cotype: Tw,
  indexing: Pw,
  type: jw,
  properties: Vw,
  required: Ww,
  additionalProperties: zw
}, _w = "@maia/schema/meta", $w = "@maia/schema/message/UPDATE_AGENT_INPUT", Xw = "@maia/schema/message/UPDATE_AGENT_INPUT", Ap = "Message type for updating agent ID input field in Spark detail view", ep = "comap", tp = !0, ip = "object", op = { value: { type: "string", description: "Agent account co-id input value" } }, rp = !0, sp = {
  $schema: _w,
  $id: $w,
  title: Xw,
  description: Ap,
  cotype: ep,
  indexing: tp,
  type: ip,
  properties: op,
  additionalProperties: rp
}, gp = "@maia/schema/meta", np = "@maia/schema/message/ADD_AGENT", ap = "@maia/schema/message/ADD_AGENT", Ip = "Message type for adding an agent as writer member to a Spark's group", Cp = "comap", cp = !0, Bp = "object", Qp = { agentId: { type: "string", description: "Agent account co-id to add as writer (co_z...). Operation validates format." } }, Ep = ["agentId"], lp = !0, up = {
  $schema: gp,
  $id: np,
  title: ap,
  description: Ip,
  cotype: Cp,
  indexing: cp,
  type: Bp,
  properties: Qp,
  required: Ep,
  additionalProperties: lp
}, dp = "@maia/schema/meta", hp = "@maia/schema/message/REMOVE_MEMBER", fp = "@maia/schema/message/REMOVE_MEMBER", wp = "Message type for removing a member from a Spark's group", pp = "comap", yp = !0, Dp = "object", mp = { memberId: { type: "string", description: "Account co-id of member to remove (co_z...). Operation validates format." } }, Sp = ["memberId"], Np = !0, Mp = {
  $schema: dp,
  $id: hp,
  title: fp,
  description: wp,
  cotype: pp,
  indexing: yp,
  type: Dp,
  properties: mp,
  required: Sp,
  additionalProperties: Np
};
function Ur() {
  return Ye.getMetaSchema();
}
const vr = {
  actor: TQ,
  context: $Q,
  state: gE,
  view: uE,
  style: ii,
  brand: ii,
  "brand.style": ii,
  "actor.style": ii,
  tool: bE,
  vibe: xE,
  message: _E,
  guard: gl,
  action: El,
  transition: Dl,
  messagePayload: bl,
  messageType: xl,
  "maia-script-expression": _l,
  subscribers: ru,
  inbox: Bu,
  children: pu,
  "os/schematas-registry": Fu,
  "os/os-registry": Hu,
  "os/capabilities": Vu,
  "os/indexes-registry": ed,
  "os/vibes-registry": ad,
  "os/sparks-registry": ud,
  "os/humans-registry": md,
  "os/registries": Kd,
  "data/todos": Od,
  "data/chat": $d,
  "data/spark": gh,
  "message/CREATE_BUTTON": dh,
  "message/TOGGLE_BUTTON": kh,
  "message/DELETE_BUTTON": qh,
  "message/UPDATE_INPUT": Zh,
  "message/SWITCH_VIEW": nf,
  "message/SUCCESS": df,
  "message/ERROR": kf,
  "message/SEND_MESSAGE": qf,
  "message/RETRY": Zf,
  "message/DISMISS": sw,
  "message/SELECT_NAV": uw,
  "message/SELECT_ROW": Mw,
  "message/SELECT_SPARK": Hw,
  "message/LOAD_ACTOR": Zw,
  "message/UPDATE_AGENT_INPUT": sp,
  "message/ADD_AGENT": up,
  "message/REMOVE_MEMBER": Mp
};
function kp(i) {
  const A = i.startsWith("@maia/schema/") ? i.replace("@maia/schema/", "") : i;
  return vr[A] || null;
}
function Jr() {
  const i = {};
  for (const [A, e] of Object.entries(vr))
    A.startsWith("message/") && (i[`@maia/schema/${A}`] = e);
  return { ...vr, ...i };
}
const Wt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CoIdRegistry: QI,
  SCHEMA_REF_PATTERN: mo,
  VIBE_REF_PATTERN: $a,
  ValidationEngine: Ye,
  coTypesDefs: Tt,
  getAllSchemas: Jr,
  getMetaSchema: Ur,
  getSchema: kp,
  getValidationEngine: So,
  isSchemaRef: MA,
  isVibeRef: Xa,
  resolve: eA,
  setSchemaResolver: AI,
  transformForSeeding: cI,
  validateAgainstSchema: jt,
  validateAgainstSchemaOrThrow: nt,
  validateSchemaStructure: co
}, Symbol.toStringTag, { value: "Module" })), Gp = /^@([a-zA-Z0-9_-]+)\/schema\/(.+)$/;
async function Ms(i, A) {
  const e = i?.systemSpark ?? "@maia";
  if (!i.account)
    throw new Error("[SchemaIndexManager] Account required");
  const t = await KA(i, e);
  if (t)
    try {
      const o = await IA(i, t, null, null, null, {
        deepResolve: !1,
        // Don't need deep resolution for infrastructure
        timeoutMs: 1e4
        // 10 second timeout for critical infrastructure
      });
      if (!o || o.value?.error)
        return process.env.DEBUG && console.warn(`[SchemaIndexManager] spark.os CoValue not found or error: ${t.substring(0, 12)}...`), null;
      const r = i.getCoValue(t);
      if (!r || !r.isAvailable())
        return process.env.DEBUG && console.warn(`[SchemaIndexManager] spark.os (${t.substring(0, 12)}...) is not available after read()`), null;
      const s = r.getCurrentContent?.();
      if (!s)
        return process.env.DEBUG && console.warn(`[SchemaIndexManager] spark.os (${t.substring(0, 12)}...) is available but getCurrentContent() returned nothing`), null;
      const g = s.cotype || s.type, I = (i.getHeader(r)?.meta || null)?.$schema || null;
      return g === "comap" && typeof s.get == "function" ? s : (process.env.DEBUG && console.warn(`[SchemaIndexManager] spark.os (${t.substring(0, 12)}...) is not a CoMap (cotype: ${g}, schema: ${I}, has get: ${typeof s.get})`), null);
    } catch (o) {
      return process.env.DEBUG && console.warn(`[SchemaIndexManager] Failed to load spark.os (${t.substring(0, 12)}...):`, o.message), null;
    }
  return null;
}
async function ko(i) {
  const A = await Ms(i);
  if (!A)
    return null;
  const e = A.get("indexes");
  if (e)
    try {
      const r = await IA(i, e, null, null, null, {
        deepResolve: !1,
        timeoutMs: 1e4
      });
      if (!r || r.value?.error)
        return process.env.DEBUG && console.warn(`[SchemaIndexManager] spark.os.indexes CoValue not found or error: ${e.substring(0, 12)}...`), null;
      const s = i.getCoValue(e);
      if (!s || !s.isAvailable())
        return process.env.DEBUG && console.warn(`[SchemaIndexManager] spark.os.indexes (${e.substring(0, 12)}...) is not available after read()`), null;
      const g = s.getCurrentContent?.();
      if (!g)
        return process.env.DEBUG && console.warn(`[SchemaIndexManager] spark.os.indexes (${e.substring(0, 12)}...) is available but getCurrentContent() returned nothing`), null;
      const n = g.cotype || g.type, C = (i.getHeader(s)?.meta || null)?.$schema || null;
      return n === "comap" && typeof g.get == "function" ? g : (process.env.DEBUG && console.warn(`[SchemaIndexManager] spark.os.indexes (${e.substring(0, 12)}...) is not a CoMap (cotype: ${n}, schema: ${C}, has get: ${typeof g.get})`), null);
    } catch (r) {
      return process.env.DEBUG && console.warn(`[SchemaIndexManager] Failed to load spark.os.indexes (${e.substring(0, 12)}...):`, r.message), null;
    }
  let t = await eA(i, "@maia/schema/os/indexes-registry", { returnType: "coId" }), o;
  if (t && typeof t == "string" && t.startsWith("co_z") && i.dbEngine) {
    const { create: r } = await Promise.resolve().then(() => Ss);
    o = (await r(i, t, {})).id;
  } else {
    const { createCoValueForSpark: r } = await Promise.resolve().then(() => Re), { coValue: s } = await r(i, "@maia", {
      schema: yA.META_SCHEMA,
      cotype: "comap",
      data: {}
    });
    o = s.id;
  }
  A.set("indexes", o);
  try {
    const r = await IA(i, o, null, null, null, {
      deepResolve: !1,
      timeoutMs: 5e3
    });
    if (r && !r.value?.error) {
      const s = i.getCoValue(o);
      if (s && i.isAvailable(s)) {
        const g = s.getCurrentContent?.();
        if (g && typeof g.get == "function")
          return g;
      }
    }
  } catch (r) {
    process.env.DEBUG && console.warn("[SchemaIndexManager] Failed to load newly created spark.os.indexes:", r.message);
  }
  return null;
}
async function Fp(i, A, e = null) {
  if (!A || !A.startsWith("co_z"))
    throw new Error(`[SchemaIndexManager] Invalid schema co-id: ${A}`);
  if (!e) {
    const C = i.getCoValue(A);
    C && (e = i.getHeader(C)?.meta?.$schema, e && !e.startsWith("co_z") && (e = await eA(i, e, { returnType: "coId" }))), (!e || !e.startsWith("co_z")) && (e = await lI(i));
  }
  if (!e || !e.startsWith("co_z"))
    return process.env.DEBUG && console.warn("[SchemaIndexManager] Cannot create schema-specific index colist schema - metaSchema not available"), null;
  const t = await eA(i, A, { returnType: "schema" });
  if (!t)
    return process.env.DEBUG && console.warn(`[SchemaIndexManager] Cannot load schema definition for ${A.substring(0, 12)}...`), null;
  const o = t.title || t.$id;
  if (!o || typeof o != "string" || !mo.test(o))
    return process.env.DEBUG && console.warn(`[SchemaIndexManager] Schema ${A.substring(0, 12)}... has invalid title: ${o}`), null;
  const r = o.match(Gp);
  if (!r)
    return process.env.DEBUG && console.warn(`[SchemaIndexManager] Schema ${A.substring(0, 12)}... has invalid title format: ${o}`), null;
  const [, s, g] = r, n = `@${s}/schema/index/${g}`, a = await eA(i, n, { returnType: "coId" });
  if (a && a.startsWith("co_z"))
    return a;
  const I = {
    title: n,
    description: `Schema-specific index colist for ${o} - only allows instances of this schema`,
    cotype: "colist",
    indexing: !1,
    // Index colist schemas themselves should not be indexed
    items: {
      $co: o
      // Enforces type safety - only co-ids referencing the target schema are allowed
    }
  };
  try {
    const c = (await ms(i, e, I)).id, B = await uI(i);
    return B && B.set(n, c), c;
  } catch (C) {
    return process.env.DEBUG && console.error(`[SchemaIndexManager] Failed to create schema-specific index colist schema for ${o}:`, C), null;
  }
}
async function ks(i, A, e = null) {
  if (!A || typeof A != "string" || !A.startsWith("co_z"))
    throw new Error(`[SchemaIndexManager] Invalid schema co-id: expected string starting with 'co_z', got ${typeof A}: ${A}`);
  const t = await eA(i, A, { returnType: "schema" });
  if (!t)
    return process.env.DEBUG && console.warn(`[SchemaIndexManager] Cannot load schema definition for ${A.substring(0, 12)}...`), null;
  if (t.indexing !== !0)
    return null;
  const o = await ko(i);
  if (!o)
    return null;
  let r = o.get(A);
  if (r) {
    try {
      const I = await IA(i, r, null, null, null, {
        deepResolve: !1,
        // Don't need deep resolution for index colists
        timeoutMs: 5e3
      });
      if (I && !I.value?.error) {
        const C = i.getCoValue(r);
        if (C && C.isAvailable()) {
          const c = C.getCurrentContent?.();
          if (c && typeof c.append == "function" && (c.cotype || c.type) === "colist")
            return c;
        }
      }
    } catch (I) {
      process.env.DEBUG && console.warn(`[SchemaIndexManager] Failed to read index colist (${r.substring(0, 12)}...):`, I.message);
    }
    return process.env.DEBUG && console.warn(`[SchemaIndexManager] Index colist (${r.substring(0, 12)}...) exists but could not be loaded. Skipping to prevent overwriting.`), null;
  }
  const s = await Fp(i, A, e);
  if (!s)
    return process.env.DEBUG && console.warn(`[SchemaIndexManager] Cannot create index colist - schema-specific index colist schema not available for ${A.substring(0, 12)}...`), null;
  const { createCoValueForSpark: g } = await Promise.resolve().then(() => Re), { coValue: n } = await g(i, "@maia", {
    schema: s,
    cotype: "colist",
    data: [],
    dbEngine: i.dbEngine
  });
  r = n.id, o.set(A, r);
  const a = i.node.getCoValue(r);
  if (a && a.type === "colist") {
    const I = a.getCurrentContent?.();
    if (I && typeof I.append == "function")
      return I;
  }
  return n;
}
async function Gs(i) {
  const A = await Ms(i);
  if (!A)
    return process.env.DEBUG && console.warn("[SchemaIndexManager] Cannot create unknown colist - spark.os not available"), null;
  const e = A.get("unknown");
  if (e) {
    const r = i.node.getCoValue(e);
    if (r && r.type === "colist") {
      const s = r.getCurrentContent?.();
      if (s && typeof s.append == "function")
        return s;
    }
  }
  const { createCoValueForSpark: t } = await Promise.resolve().then(() => Re), { coValue: o } = await t(i, "@maia", {
    schema: yA.META_SCHEMA,
    cotype: "colist",
    data: []
  });
  return A.set("unknown", o.id), o;
}
async function Rp(i, A) {
  if (!i.account || !A)
    return !1;
  const e = await KA(i, i?.systemSpark ?? "@maia");
  if (A === e)
    return !0;
  if (e) {
    const t = i.node.getCoValue(e);
    if (t && t.type === "comap") {
      const o = t.getCurrentContent?.();
      if (o && typeof o.get == "function") {
        const r = o.get("schematas");
        if (A === r)
          return !0;
        const s = o.get("unknown");
        if (A === s)
          return !0;
        const g = o.get("indexes");
        if (A === g)
          return !0;
        if (g) {
          const n = i.node.getCoValue(g);
          if (n && n.type === "comap") {
            const a = n.getCurrentContent?.();
            if (a && typeof a.get == "function") {
              const I = a.keys && typeof a.keys == "function" ? a.keys() : Object.keys(a);
              for (const C of I)
                if (a.get(C) === A)
                  return !0;
            }
          }
        }
      }
    }
  }
  return !1;
}
async function Fs(i, A) {
  if (!A)
    return { shouldIndex: !1, schemaCoId: null };
  if (await Rp(i, A.id))
    return { shouldIndex: !1, schemaCoId: null };
  const t = i.getHeader(A);
  if (!t || !t.meta)
    return { shouldIndex: !1, schemaCoId: null };
  const o = t.meta, r = o.$schema;
  if (yA.ACCOUNT === r || yA.GROUP === r || yA.META_SCHEMA === r)
    return { shouldIndex: !1, schemaCoId: null };
  if (o.type === "account" || r === yA.ACCOUNT)
    return { shouldIndex: !1, schemaCoId: null };
  const s = A.ruleset || t?.ruleset;
  if (s && s.type === "group")
    return { shouldIndex: !1, schemaCoId: null };
  if (r && typeof r == "string" && r.startsWith("co_z")) {
    try {
      const g = await eA(i, r, { returnType: "schema" });
      if (g && g.indexing !== !0)
        return { shouldIndex: !1, schemaCoId: r };
    } catch {
    }
    return { shouldIndex: !0, schemaCoId: r };
  }
  return r ? { shouldIndex: !1, schemaCoId: null } : { shouldIndex: !1, schemaCoId: null };
}
async function lI(i) {
  const A = i?.systemSpark ?? "@maia", e = await KA(i, A);
  if (!e)
    return null;
  const t = i.node.getCoValue(e);
  if (!t || t.type !== "comap")
    return null;
  const o = t.getCurrentContent?.();
  if (!o || typeof o.get != "function")
    return null;
  const r = o.get("schematas");
  if (!r)
    return null;
  const s = i.node.getCoValue(r);
  if (!s || s.type !== "comap")
    return null;
  const g = s.getCurrentContent?.();
  if (!g || typeof g.get != "function")
    return null;
  const n = g.get("@maia/schema/meta");
  return n && typeof n == "string" && n.startsWith("co_z") ? n : null;
}
async function uI(i) {
  const A = await Ms(i);
  if (!A)
    return null;
  const e = A.get("schematas");
  if (e) {
    try {
      const g = await IA(i, e, null, null, null, {
        deepResolve: !1,
        // Don't need deep resolution for registry
        timeoutMs: 5e3
      });
      if (g && !g.value?.error) {
        const n = i.getCoValue(e);
        if (n && n.isAvailable()) {
          const a = n.getCurrentContent?.();
          if (a && typeof a.set == "function" && (a.cotype || a.type) === "comap")
            return a;
        }
      }
    } catch (g) {
      process.env.DEBUG && console.warn(`[SchemaIndexManager] Failed to read schematas registry (${e.substring(0, 12)}...):`, g.message);
    }
    return process.env.DEBUG && console.warn(`[SchemaIndexManager] spark.os.schematas (${e.substring(0, 12)}...) exists but could not be loaded. Skipping to prevent overwriting.`), null;
  }
  const o = await eA(i, "@maia/schema/os/schematas-registry", { returnType: "coId" }) || yA.META_SCHEMA, { createCoValueForSpark: r } = await Promise.resolve().then(() => Re), { coValue: s } = await r(i, "@maia", {
    schema: o,
    cotype: "comap",
    data: {},
    dbEngine: i.dbEngine
  });
  return A.set("schematas", s.id), s;
}
async function dI(i, A) {
  if (!A || !A.id)
    return;
  const e = i.getCurrentContent(A);
  if (!e || typeof e.get != "function")
    return;
  const t = e.get("title");
  if (!t || typeof t != "string" || !mo.test(t))
    return;
  const o = await uI(i);
  if (!o)
    return;
  const r = o.get(t);
  if (r === A.id || r && r !== A.id || (o.set(t, A.id), e.get("indexing") !== !0))
    return;
  let a = i.getHeader(A)?.meta?.$schema;
  a && !a.startsWith("co_z") && (a = await eA(i, a, { returnType: "coId" })), await ks(i, A.id, a);
}
async function hI(i, A) {
  if (!A)
    return !1;
  const e = i.getHeader(A);
  if (!e || !e.meta)
    return !1;
  const o = e.meta.$schema;
  if (!o)
    return !1;
  if (o === yA.META_SCHEMA) {
    const r = i.getCurrentContent(A);
    return !!(r && typeof r.get == "function" && r.get("title") === "@maia/schema/meta");
  }
  if (o && typeof o == "string" && o.startsWith("co_z")) {
    try {
      const s = await IA(i, o, null, null, null, {
        deepResolve: !1,
        // Don't need deep resolution for schema detection
        timeoutMs: 5e3
        // 5 second timeout - metaschema should be available but may need more time during seeding
      });
      if (s && !s.value?.error) {
        const g = i.getCoValue(o);
        if (g && g.isAvailable()) {
          const n = i.getCurrentContent(g);
          if (n && typeof n.get == "function" && n.get("title") === "@maia/schema/meta")
            return !0;
        }
      }
    } catch {
    }
    const r = await lI(i);
    if (r && o === r)
      return !0;
  }
  return !1;
}
const rr = /* @__PURE__ */ new Set();
async function fI(i, A) {
  let e = A, t = null;
  if (typeof A == "string") {
    if (t = A, e = i.getCoValue(t), !e || !i.isAvailable(e))
      return;
  } else
    t = A?.id;
  if (!(!e || !t) && !rr.has(t)) {
    rr.add(t);
    try {
      const { shouldIndex: o, schemaCoId: r } = await Fs(i, e);
      if (o && r) {
        const s = await ks(i, r);
        if (!s)
          return;
        const a = i.getHeader(e)?.meta?.$schema;
        if (!a || a !== r)
          return;
        try {
          const I = s.toJSON ? s.toJSON() : [];
          if (Array.isArray(I) && I.includes(t))
            return;
        } catch {
        }
        try {
          s.append(t);
        } catch {
          return;
        }
      } else {
        const s = await Gs(i);
        if (!s)
          return;
        try {
          const g = s.toJSON ? s.toJSON() : [];
          if (Array.isArray(g) && g.includes(t))
            return;
        } catch {
        }
        s.append(t);
      }
    } finally {
      rr.delete(t);
    }
  }
}
async function bp(i, A) {
  if (!A || !A.startsWith("co_z") || !i.account)
    return null;
  const e = await ko(i);
  if (!e)
    return null;
  const t = e.get(A);
  if (!t || typeof t != "string" || !t.startsWith("co_"))
    return null;
  try {
    const o = await IA(i, t, null, null, null, {
      deepResolve: !1,
      // Don't need deep resolution for removal
      timeoutMs: 2e3
    });
    if (o && !o.value?.error) {
      const r = i.getCoValue(t);
      if (r && i.isAvailable(r)) {
        const s = i.getCurrentContent(r);
        if (s && typeof s.toJSON == "function" && typeof s.delete == "function" && (s.cotype || s.type) === "colist")
          return s;
      }
    }
  } catch {
  }
  return null;
}
async function wI(i, A, e = null) {
  if (!(!A || !A.startsWith("co_z"))) {
    if (!e) {
      const t = i.getCoValue(A);
      if (t && i.isAvailable(t)) {
        const o = i.getHeader(t);
        o && o.meta && (e = o.meta.$schema);
      }
    }
    if (e && typeof e == "string" && e.startsWith("co_z")) {
      const t = await bp(i, e);
      if (t && typeof t.toJSON == "function" && typeof t.delete == "function") {
        const r = t.toJSON().indexOf(A);
        r !== -1 && t.delete(r);
      }
    } else {
      const t = await Gs(i);
      if (t && typeof t.toJSON == "function" && typeof t.delete == "function") {
        const r = t.toJSON().indexOf(A);
        r !== -1 && t.delete(r);
      }
    }
  }
}
const pI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ensureIndexesCoMap: ko,
  ensureSchemaIndexColist: ks,
  ensureUnknownColist: Gs,
  indexCoValue: fI,
  isSchemaCoValue: hI,
  registerSchemaCoValue: dI,
  removeFromIndex: wI,
  shouldIndexCoValue: Fs
}, Symbol.toStringTag, { value: "Module" }));
async function so(i, A, e) {
  const t = await aA(i, e, { waitForAvailable: !0 });
  if (!t)
    throw new Error(`[CoJSONBackend] CoValue not found: ${e}`);
  if (!i.isAvailable(t))
    throw new Error(`[CoJSONBackend] CoValue not available: ${e}`);
  const o = i.getCurrentContent(t), r = o?.cotype || o?.type, n = (i.getHeader(t)?.meta || null)?.$schema || A;
  await wI(i, e, n);
  let a = !1;
  if (r === "comap" && o.set) {
    if (o.keys && typeof o.keys == "function") {
      const I = Array.from(o.keys());
      for (const C of I)
        typeof o.delete == "function" && o.delete(C);
    } else if (typeof o.delete == "function") {
      const I = Object.keys(o);
      for (const C of I)
        o.delete(C);
    }
    a = !0;
  } else if (r === "colist" && o.delete) {
    if (typeof o.toJSON == "function") {
      const I = o.toJSON();
      for (let C = I.length - 1; C >= 0; C--)
        typeof o.delete == "function" && o.delete(C);
    }
    a = !0;
  } else if (r === "costream")
    a = !0;
  else if (r === "coplaintext" && o.delete) {
    if (typeof o.toString == "function") {
      const I = o.toString();
      for (let C = I.length - 1; C >= 0; C--)
        typeof o.delete == "function" && o.delete(C, 1);
    }
    a = !0;
  } else
    throw new Error(`[CoJSONBackend] Delete not supported for type: ${r}. Supported types: comap, colist, costream, coplaintext`);
  return a && i.node.storage && await i.node.syncManager.waitForStorageSync(e), a;
}
const NA = "@maia";
async function Kp(i, A) {
  const { EXCEPTION_SCHEMAS: e } = await Promise.resolve().then(() => Pt), t = A.createGroup(), o = { node: A, account: i, guardian: t }, { coValue: r } = await hA(o, null, {
    schema: e.META_SCHEMA,
    cotype: "comap",
    data: {}
  });
  i.set("sparks", r.id), console.log(" Agent minimal bootstrap: account.sparks (empty, connect via /on-added)");
}
async function Yp(i, A, e, t = null) {
  const { EXCEPTION_SCHEMAS: o } = await Promise.resolve().then(() => Pt), { getAllSchemas: r } = await Promise.resolve().then(() => Wt), s = e || r(), g = A.createGroup(), n = A.createGroup();
  n.extend(g, "extend");
  const a = n.createMap({}, { $schema: o.META_SCHEMA });
  i.set("temp", a.id), a.set("guardian", g.id), o.META_SCHEMA;
  const I = Ee("co_zTEMP"), C = { definition: RA(I.definition || I) }, { coValue: c } = await hA(
    { node: A, account: i, guardian: g },
    null,
    { schema: o.META_SCHEMA, cotype: "comap", data: C, dbEngine: t }
  ), B = c.id, Q = Ee(B), { $schema: f, $id: l, id: d, ...u } = Q.definition || Q;
  for (const [P, G] of Object.entries(RA(u))) c.set(P, G);
  a.set("metaschema", B);
  const h = /* @__PURE__ */ new Map();
  for (const [P, G] of Object.entries(s)) {
    const x = G.$id || `@maia/schema/${P}`;
    h.has(x) || h.set(x, { name: P, schema: G });
  }
  const w = (P, G = /* @__PURE__ */ new Set()) => {
    if (!P || typeof P != "object" || G.has(P)) return /* @__PURE__ */ new Set();
    G.add(P);
    const x = /* @__PURE__ */ new Set();
    P.$co && typeof P.$co == "string" && P.$co.startsWith("@maia/schema/") && x.add(P.$co);
    for (const Y of Object.values(P))
      Y && typeof Y == "object" && (Array.isArray(Y) ? Y : [Y]).forEach((S) => {
        S && typeof S == "object" && w(S, G).forEach((k) => x.add(k));
      });
    return x;
  }, E = /* @__PURE__ */ new Map();
  for (const [P, { schema: G }] of h) E.set(P, w(G));
  const p = [], y = /* @__PURE__ */ new Set(), m = /* @__PURE__ */ new Set(), N = (P) => {
    if (!y.has(P) && !m.has(P)) {
      m.add(P);
      for (const G of E.get(P) || [])
        G.startsWith("@maia/schema/") && h.has(G) && N(G);
      m.delete(P), y.add(P), p.push(P);
    }
  };
  for (const P of h.keys())
    P !== "@maia/schema/meta" && N(P);
  const R = /* @__PURE__ */ new Map();
  for (const P of p) {
    const { schema: G } = h.get(P), { $schema: x, $id: Y, id: S, ...k } = G, K = RA(k), { coValue: H } = await hA(
      { node: A, account: i, guardian: g },
      null,
      { schema: B, cotype: "comap", data: K, dbEngine: t }
    ), V = H.id;
    R.set(P, V), a.set(P, V);
  }
  const L = a.get("@maia/schema/data/spark") || o.META_SCHEMA, j = a.get("@maia/schema/os/schematas-registry") || o.META_SCHEMA, J = a.get("@maia/schema/os/os-registry") || o.META_SCHEMA, z = a.get("@maia/schema/os/capabilities") || o.META_SCHEMA, X = a.get("@maia/schema/os/indexes-registry") || o.META_SCHEMA, Z = a.get("@maia/schema/os/vibes-registry") || o.META_SCHEMA, _ = a.get("@maia/schema/os/sparks-registry") || o.META_SCHEMA, T = { node: A, account: i, guardian: g }, $ = (P, G) => ({ schema: P, cotype: "comap", data: G, dbEngine: t }), { coValue: O } = await hA(T, null, $(L, { name: NA })), { coValue: F } = await hA(T, null, $(J, {})), { coValue: q } = await hA(T, null, $(z, {}));
  q.set("guardian", g.id), F.set("capabilities", q.id);
  const { coValue: b } = await hA(T, null, $(j, {})), { coValue: D } = await hA(T, null, $(X, {})), { coValue: M } = await hA(T, null, $(Z, {}));
  F.set("schematas", b.id), F.set("indexes", D.id), O.set("os", F.id), O.set("vibes", M.id), b.set("@maia/schema/meta", B);
  for (const [P, G] of R) b.set(P, G);
  const { coValue: U } = await hA(T, null, $(_, {}));
  U.set(NA, O.id), i.set("sparks", U.id), typeof i.delete == "function" && i.delete("temp"), console.log(" Bootstrap scaffold complete: account.sparks, @maia spark, os, schematas, indexes, vibes");
}
async function Up(i, A) {
  const e = i.account?.get("sparks");
  if (!e?.startsWith("co_z")) return;
  const t = await i.read(null, e);
  await new Promise((T, $) => {
    if (!t.loading) return T();
    let O;
    const F = setTimeout(() => $(new Error("Timeout")), 1e4);
    O = t.subscribe(() => {
      t.loading || (clearTimeout(F), O?.(), T());
    });
  });
  const o = t?.value;
  if (!o || o.error) return;
  const r = o[NA];
  if (!r || !r.startsWith("co_z")) return;
  const s = i.getCoValue(r);
  if (!s) return;
  i.isAvailable(s) || await new Promise((T, $) => {
    const O = setTimeout(() => $(new Error("Timeout")), 1e4), F = s.subscribe((q) => {
      q && i.isAvailable(q) && (clearTimeout(O), F?.(), T());
    });
  });
  const g = i.getCurrentContent(s);
  if (!g || typeof g.set != "function") return;
  const { EXCEPTION_SCHEMAS: n } = await Promise.resolve().then(() => Pt), a = i.node, I = g.get("os");
  if (!I || !I.startsWith("co_z")) return;
  const C = i.getCoValue(I);
  if (!C || !i.isAvailable(C)) return;
  const c = i.getCurrentContent(C);
  if (!c || typeof c.get != "function") return;
  const B = c.get("capabilities");
  if (!B || !B.startsWith("co_z")) return;
  const Q = i.getCoValue(B);
  if (!Q || !i.isAvailable(Q)) return;
  const f = i.getCurrentContent(Q);
  if (!f || typeof f.set != "function") return;
  let l = null;
  const d = f.get("publicReaders");
  if (d && d.startsWith("co_z")) {
    const T = a.getCoValue(d);
    T?.isGroup?.() && i.isAvailable(T) && (l = i.getCurrentContent(T));
  }
  if (!l || typeof l.createMap != "function") {
    const T = a.createGroup();
    T.addMember("everyone", "reader"), l = a.createGroup(), l.extend(A, "extend"), l.extend(T, "reader"), f.set("publicReaders", l.id);
  }
  const { resolve: u } = await Promise.resolve().then(() => Qs), h = await u(i, "@maia/schema/os/registries", { returnType: "coId" }), w = await u(i, "@maia/schema/os/sparks-registry", { returnType: "coId" }), E = await u(i, "@maia/schema/os/humans-registry", { returnType: "coId" }), p = h ? { $schema: h } : { $schema: n.META_SCHEMA }, y = w ? { $schema: w } : { $schema: n.META_SCHEMA }, m = E ? { $schema: E } : { $schema: n.META_SCHEMA }, { removeGroupMember: N } = await Promise.resolve().then(() => ue), R = i.account, L = typeof a.getCurrentAccountOrAgentID == "function" ? a.getCurrentAccountOrAgentID() : R?.id ?? R?.$jazz?.id;
  let j = g.get("registries"), J = null;
  if (j) {
    const T = i.getCoValue(j);
    T && i.isAvailable(T) && (J = i.getCurrentContent(T));
  }
  if (!J || typeof J.set != "function") {
    const T = a.createGroup();
    T.extend(A, "extend"), T.extend(l, "reader");
    const $ = T.createMap({}, p);
    try {
      await N(T, L);
    } catch {
    }
    g.set("registries", $.id), J = $;
  }
  let z = J.get("sparks"), X = null;
  if (z) {
    const T = i.getCoValue(z);
    T && i.isAvailable(T) && (X = i.getCurrentContent(T));
  }
  if (!X || typeof X.set != "function") {
    const T = a.createGroup();
    T.extend(A, "extend"), T.extend(l, "reader");
    const $ = T.createMap({}, y);
    try {
      await N(T, L);
    } catch {
    }
    J.set("sparks", $.id), X = $;
  }
  X.set(NA, r);
  let Z = J.get("humans"), _ = null;
  if (Z) {
    const T = i.getCoValue(Z);
    T && i.isAvailable(T) && (_ = i.getCurrentContent(T));
  }
  if (!_ || typeof _.set != "function") {
    const T = a.createGroup();
    T.extend(A, "extend"), T.extend(l, "reader");
    const $ = T.createMap({}, m);
    try {
      await N(T, L);
    } catch {
    }
    J.set("humans", $.id);
  }
}
function RA(i, A = !1) {
  if (i == null || typeof i != "object") return i;
  if (Array.isArray(i)) return i.map((t) => RA(t, A));
  const e = {};
  for (const [t, o] of Object.entries(i)) {
    if (t === "id" && !A) continue;
    const r = t === "properties" || t === "items";
    e[t] = o != null && typeof o == "object" ? RA(o, r || A) : o;
  }
  return e;
}
async function vp(i, A, e) {
  let t = 0, o = 0;
  try {
    const r = await KA(e, NA);
    if (!r)
      return { deleted: 0, errors: 0 };
    const s = await aA(e, r, {
      waitForAvailable: !0,
      timeoutMs: 5e3
    });
    if (!s || !e.isAvailable(s))
      return { deleted: 0, errors: 0 };
    const g = e.getCurrentContent(s);
    if (!g || typeof g.get != "function")
      return { deleted: 0, errors: 0 };
    const n = g.get("schematas"), a = /* @__PURE__ */ new Set();
    if (n) {
      const E = await aA(e, n, {
        waitForAvailable: !0,
        timeoutMs: 5e3
      });
      if (E && e.isAvailable(E)) {
        const p = e.getCurrentContent(E);
        if (p && typeof p.get == "function") {
          const y = p.keys && typeof p.keys == "function" ? p.keys() : Object.keys(p);
          for (const m of y) {
            const N = p.get(m);
            N && typeof N == "string" && N.startsWith("co_z") && a.add(N);
          }
        }
      }
    }
    const I = g.get("metaSchema");
    I && typeof I == "string" && I.startsWith("co_z") && a.add(I);
    const C = /* @__PURE__ */ new Set();
    let c = null;
    const B = g.get("indexes");
    if (B)
      try {
        const E = await aA(e, B, {
          waitForAvailable: !0,
          timeoutMs: 5e3
        });
        if (E && e.isAvailable(E) && (c = e.getCurrentContent(E), c && typeof c.get == "function")) {
          const p = c.keys && typeof c.keys == "function" ? c.keys() : Object.keys(c);
          console.log(`[Seed] Found ${p.length} schema index colists in account.os.indexes`);
          for (const y of p)
            if (y.startsWith("co_z")) {
              const m = c.get(y);
              if (m)
                try {
                  const N = await aA(e, m, {
                    waitForAvailable: !0,
                    timeoutMs: 2e3
                  });
                  if (N && e.isAvailable(N)) {
                    const R = e.getCurrentContent(N);
                    if (R && typeof R.toJSON == "function") {
                      const L = R.toJSON();
                      for (const j of L)
                        j && typeof j == "string" && j.startsWith("co_z") && C.add(j);
                    }
                  }
                } catch (N) {
                  console.warn(`[Seed] Failed to read index colist ${y ? y.substring(0, 12) : "undefined"}...:`, N.message), o++;
                }
            }
        }
      } catch (E) {
        console.warn("[Seed] Failed to read account.os.indexes:", E.message), o++;
      }
    let Q = null;
    const f = g.get("unknown");
    if (f)
      try {
        const E = await aA(e, f, {
          waitForAvailable: !0,
          timeoutMs: 2e3
        });
        if (E && e.isAvailable(E) && (Q = e.getCurrentContent(E), Q && typeof Q.toJSON == "function")) {
          const p = Q.toJSON();
          console.log(`[Seed] Found ${p.length} co-values in account.os.unknown`);
          for (const y of p)
            y && typeof y == "string" && y.startsWith("co_z") && C.add(y);
        }
      } catch (E) {
        console.warn("[Seed] Failed to read unknown colist:", E.message), o++;
      }
    const l = Array.from(C).filter((E) => !a.has(E));
    console.log(`[Seed] Deleting ${l.length} co-values (filtered from ${C.size} total, preserving ${a.size} schemas)`);
    for (const E of l)
      try {
        const p = e.getCoValue(E);
        if (!p)
          continue;
        const N = (e.getHeader(p)?.meta || null)?.$schema;
        if (N && a.has(E))
          continue;
        try {
          await so(e, N || null, E), t++;
        } catch (R) {
          if (R.message && (R.message.includes("Cannot access") || R.message.includes("before initialization") || R.message.includes("ReferenceError")))
            t++;
          else
            throw R;
        }
      } catch (p) {
        console.warn(`[Seed] Failed to delete co-value ${E ? E.substring(0, 12) : "undefined"}...:`, p.message), o++;
      }
    let d = null;
    const u = await No(e, NA);
    if (u)
      try {
        const E = await aA(e, u, {
          waitForAvailable: !0,
          timeoutMs: 2e3
        });
        if (E && e.isAvailable(E) && (d = e.getCurrentContent(E), d && typeof d.get == "function")) {
          const p = d.keys && typeof d.keys == "function" ? d.keys() : Object.keys(d);
          console.log(`[Seed] Deleting ${p.length} vibes from account.vibes`);
          for (const y of p) {
            const m = d.get(y);
            if (m && typeof m == "string" && m.startsWith("co_z"))
              try {
                const N = e.getCoValue(m);
                if (N) {
                  const j = (e.getHeader(N)?.meta || null)?.$schema;
                  await so(e, j || null, m), t++;
                }
              } catch (N) {
                console.warn(`[Seed] Failed to delete vibe ${m ? m.substring(0, 12) : "undefined"}...:`, N.message), o++;
              }
          }
          for (const y of p)
            typeof d.delete == "function" && d.delete(y);
        }
      } catch (E) {
        console.warn("[Seed] Failed to delete vibes:", E.message), o++;
      }
    const h = [];
    let w = null;
    if (c)
      w = c;
    else {
      const E = g.get("indexes");
      if (E)
        try {
          const p = await aA(e, E, {
            waitForAvailable: !0,
            timeoutMs: 5e3
          });
          p && e.isAvailable(p) && (w = e.getCurrentContent(p));
        } catch (p) {
          console.warn("[Seed] Failed to read account.os.indexes for index colist deletion:", p.message), o++;
        }
    }
    if (w && typeof w.get == "function") {
      const E = w.keys && typeof w.keys == "function" ? w.keys() : Object.keys(w);
      console.log(`[Seed] Deleting ${E.length} index colists from account.os.indexes`);
      for (const p of E)
        if (p.startsWith("co_z")) {
          const y = w.get(p);
          if (y && typeof y == "string" && y.startsWith("co_z")) {
            const m = p;
            h.push({ schemaCoId: m, indexColistId: y });
          }
        }
    }
    for (const { schemaCoId: E, indexColistId: p } of h)
      try {
        const y = await eA(e, E, { returnType: "schema" });
        if (!y || !y.title) {
          console.warn(`[Seed] Cannot get schema title for ${E ? E.substring(0, 12) : "undefined"}..., skipping index colist deletion`);
          continue;
        }
        const m = y.title;
        if (!m.startsWith("@maia/schema/")) {
          console.warn(`[Seed] Invalid schema title format: ${m}, skipping index colist deletion`);
          continue;
        }
        const R = `@maia/schema/index/${m.replace("@maia/schema/", "")}`, L = await eA(e, R, { returnType: "coId" });
        if (!L) {
          console.warn(`[Seed] Cannot resolve index colist schema ${R}, skipping index colist deletion`);
          continue;
        }
        try {
          await so(e, L, p), t++, w && typeof w.delete == "function" && w.delete(E);
        } catch (j) {
          if (j.message && (j.message.includes("Cannot access") || j.message.includes("before initialization") || j.message.includes("ReferenceError")))
            t++, w && typeof w.delete == "function" && w.delete(E);
          else
            throw j;
        }
      } catch (y) {
        console.warn(`[Seed] Failed to delete index colist ${p ? p.substring(0, 12) : "undefined"}...:`, y.message), o++;
      }
    if (w && typeof w.delete == "function")
      try {
        const E = w.keys && typeof w.keys == "function" ? Array.from(w.keys()) : Object.keys(w);
        if (E.length > 0) {
          console.log(`[Seed] Clearing ${E.length} remaining entries from account.os.indexes`);
          for (const p of E)
            w.delete(p);
        }
      } catch (E) {
        console.warn("[Seed] Failed to clear account.os.indexes:", E.message), o++;
      }
    if (Q && typeof Q.delete == "function")
      try {
        const E = Q.toJSON ? Q.toJSON() : [];
        E.length > 0 && console.log(`[Seed] Clearing ${E.length} remaining entries from account.os.unknown`);
      } catch (E) {
        console.warn("[Seed] Failed to clear account.os.unknown:", E.message), o++;
      }
    if (d && typeof d.get == "function") {
      const E = d.keys && typeof d.keys == "function" ? Array.from(d.keys()) : Object.keys(d);
      E.length > 0 ? console.warn(`[Seed] Warning: ${E.length} entries still remain in account.vibes after clearing`) : console.log("[Seed] account.vibes cleared successfully");
    }
    return console.log(`[Seed] Cleanup complete: deleted ${t} co-values, ${o} errors`), { deleted: t, errors: o };
  } catch (r) {
    return console.error("[Seed] Error during cleanup:", r), { deleted: t, errors: o + 1 };
  }
}
function Ee(i) {
  const A = i ? `https://maia.city/${i}` : "https://json-schema.org/draft/2020-12/schema";
  return {
    definition: {
      ...ro,
      $id: A,
      $schema: A
    }
  };
}
async function Jp(i, A, e, t, o, r = null) {
  const { CoJSONBackend: s } = await Promise.resolve().then(() => xr), g = r || new s(A, i, { systemSpark: "@maia" });
  if (!i.get("sparks") || !String(i.get("sparks")).startsWith("co_z")) {
    const { getAllSchemas: G } = await Promise.resolve().then(() => Wt);
    await Yp(i, A, t || G(), r?.dbEngine);
  }
  try {
    const G = await KA(g, NA);
    if (G) {
      const x = await aA(g, G, {
        waitForAvailable: !0,
        timeoutMs: 2e3
      });
      if (x && g.isAvailable(x)) {
        const Y = g.getCurrentContent(x);
        if (Y && typeof Y.get == "function") {
          const S = Y.get("schematas");
          if (S) {
            const k = await aA(g, S, {
              waitForAvailable: !0,
              timeoutMs: 2e3
            });
            if (k && g.isAvailable(k)) {
              const K = g.getCurrentContent(k);
              if (K && typeof K.get == "function" && (K.keys && typeof K.keys == "function" ? K.keys() : Object.keys(K)).length > 0 && (!e || !e.vibes?.length && Object.keys(e.actors || {}).length === 0))
                return console.log("  Account already seeded and no configs provided, skipping"), { skipped: !0, reason: "already_seeded_no_configs" };
            }
          }
        }
      }
    }
  } catch (G) {
    console.warn("[Seed] Idempotency check failed, proceeding with seeding:", G.message);
  }
  const { CoIdRegistry: n } = await Promise.resolve().then(() => EI), { transformForSeeding: a, validateSchemaStructure: I } = await Promise.resolve().then(() => Ns), C = new n(), c = await KA(g, NA);
  if (c)
    try {
      const G = await aA(g, c, {
        waitForAvailable: !0,
        timeoutMs: 2e3
      });
      if (G && g.isAvailable(G)) {
        const x = g.getCurrentContent(G);
        if (x && typeof x.get == "function" && x.get("schematas")) {
          console.log(" Cleaning up existing seeded data before reseeding...");
          const S = await vp(i, A, g);
          console.log(`[Seed] Cleanup complete: deleted ${S.deleted} co-values, ${S.errors} errors`);
        }
      }
    } catch (G) {
      console.warn("[Seed] Cleanup check failed, proceeding with seeding:", G.message);
    }
  const B = await Mo(g);
  if (!B || typeof B.createMap != "function")
    throw new Error("[CoJSONSeed] @maia spark group not found. Ensure schemaMigration has created @maia spark.");
  await Up(g, B);
  const Q = /* @__PURE__ */ new Map();
  for (const [G, x] of Object.entries(t)) {
    const Y = x.$id || `@maia/schema/${G}`;
    Q.has(Y) || Q.set(Y, { name: G, schema: x });
  }
  const f = (G, x = /* @__PURE__ */ new Set()) => {
    const Y = /* @__PURE__ */ new Set();
    if (!G || typeof G != "object" || x.has(G))
      return Y;
    x.add(G), G.$co && typeof G.$co == "string" && G.$co.startsWith("@maia/schema/") && Y.add(G.$co);
    for (const S of Object.values(G))
      if (S && typeof S == "object")
        if (Array.isArray(S))
          for (const k of S)
            k && typeof k == "object" && f(k, x).forEach((H) => Y.add(H));
        else
          f(S, x).forEach((K) => Y.add(K));
    return Y;
  }, l = /* @__PURE__ */ new Map();
  for (const [G, { schema: x }] of Q) {
    const Y = f(x);
    l.set(G, Y);
  }
  const d = [], u = /* @__PURE__ */ new Set(), h = /* @__PURE__ */ new Set(), w = (G) => {
    if (u.has(G) || h.has(G))
      return;
    h.add(G);
    const x = l.get(G) || /* @__PURE__ */ new Set();
    for (const Y of x)
      Y.startsWith("@maia/schema/") && Q.has(Y) && w(Y);
    h.delete(G), u.add(G), d.push(G);
  };
  for (const G of Q.keys())
    G !== "@maia/schema/meta" && w(G);
  await Hr(i, A, B, g, void 0);
  let E = null;
  const p = await KA(g, NA);
  if (p) {
    const G = await aA(g, p, {
      waitForAvailable: !0,
      timeoutMs: 2e3
    });
    if (G && g.isAvailable(G)) {
      const x = g.getCurrentContent(G);
      if (x && typeof x.get == "function" && !E) {
        const Y = x.get("schematas");
        if (Y) {
          const S = await aA(g, Y, {
            waitForAvailable: !0,
            timeoutMs: 2e3
          });
          if (S && g.isAvailable(S)) {
            const k = g.getCurrentContent(S);
            k && typeof k.get == "function" && (E = k.get("@maia/schema/meta"));
          }
        }
      }
    }
  }
  if (E) {
    const G = Ee(E), { $schema: x, $id: Y, id: S, ...k } = G.definition || G, K = RA(k), H = await aA(g, E, {
      waitForAvailable: !0,
      timeoutMs: 2e3
    });
    if (H && g.isAvailable(H)) {
      const V = g.getCurrentContent(H);
      if (V && typeof V.set == "function")
        for (const [W, iA] of Object.entries(K))
          V.set(W, iA);
    }
  } else {
    EXCEPTION_SCHEMAS.META_SCHEMA;
    const G = Ee("co_zTEMP"), x = {
      definition: RA(G.definition || G)
    }, { coValue: Y } = await hA(
      { node: A, account: i, guardian: B },
      null,
      { schema: EXCEPTION_SCHEMAS.META_SCHEMA, cotype: "comap", data: x }
    ), S = Y.id, k = Ee(S), { $schema: K, $id: H, id: V, ...W } = k.definition || k, iA = RA(W);
    for (const [gA, nA] of Object.entries(iA))
      Y.set(gA, nA);
    E = S;
  }
  if (!C.has("@maia/schema/meta"))
    C.register("@maia/schema/meta", E);
  else {
    const G = C.get("@maia/schema/meta");
    G !== E && (console.warn(`[Seed] Metaschema already registered with different co-id: ${G}, using existing instead of ${E}`), E = G);
  }
  const y = /* @__PURE__ */ new Map(), m = /* @__PURE__ */ new Map(), N = await Promise.resolve().then(() => Ss), R = await Promise.resolve().then(() => NI), L = /* @__PURE__ */ new Map();
  if (p) {
    const G = await aA(g, p, {
      waitForAvailable: !0,
      timeoutMs: 2e3
    });
    if (G && g.isAvailable(G)) {
      const x = g.getCurrentContent(G);
      if (x && typeof x.get == "function") {
        const Y = x.get("schematas");
        if (Y) {
          const S = await aA(g, Y, {
            waitForAvailable: !0,
            timeoutMs: 2e3
          });
          if (S && g.isAvailable(S)) {
            const k = g.getCurrentContent(S);
            if (k && typeof k.get == "function") {
              const K = k.keys && typeof k.keys == "function" ? k.keys() : Object.keys(k);
              for (const H of K) {
                const V = k.get(H);
                V && typeof V == "string" && V.startsWith("co_z") && L.set(H, V);
              }
            }
          }
        }
      }
    }
  }
  for (const G of d) {
    const { name: x, schema: Y } = Q.get(G), { $schema: S, $id: k, id: K, ...H } = Y, V = RA(H), W = L.get(G);
    let iA;
    W ? (await R.update(g, E, W, V), iA = W) : iA = (await N.create(g, E, V)).id, y.set(G, iA);
    const gA = g.getCoValue(iA);
    if (gA && g.isAvailable(gA)) {
      const nA = g.getCurrentContent(gA);
      nA && typeof nA.set == "function" && m.set(G, nA);
    }
    C.register(G, iA);
  }
  E && !y.has("@maia/schema/meta") && y.set("@maia/schema/meta", E);
  const j = /* @__PURE__ */ new Map();
  for (const G of d) {
    const { name: x, schema: Y } = Q.get(G), S = y.get(G), k = m.get(G), K = a(Y, y);
    K.$id = `https://maia.city/${S}`;
    const H = I(K, G, { checkSchemaReferences: !0, checkNestedCoTypes: !1 });
    if (H.length > 0) {
      const QA = `[Seed] Schema ${G} still contains @maia/schema/ references after transformation:
${H.join(`
`)}`;
      throw console.error(QA), new Error(QA);
    }
    j.set(G, K);
    const { $schema: V, $id: W, id: iA, ...gA } = K, nA = RA(gA);
    for (const [QA, dA] of Object.entries(nA))
      k.set(QA, dA);
  }
  const J = [];
  for (const G of d) {
    const { name: x } = Q.get(G), Y = y.get(G), S = m.get(G);
    J.push({
      name: x,
      key: G,
      coId: Y,
      coMapId: S.id
    });
  }
  await Hr(i, A, B, g, y);
  const z = /* @__PURE__ */ new Map();
  let Z = await (async () => {
    const G = /* @__PURE__ */ new Map(), x = await KA(g, NA);
    if (x) {
      const Y = A.getCoValue(x);
      if (Y && Y.type === "comap") {
        const S = Y.getCurrentContent?.();
        if (S && typeof S.get == "function") {
          const k = S.get("schematas");
          if (k) {
            const K = A.getCoValue(k);
            if (K && K.type === "comap") {
              const H = K.getCurrentContent?.();
              if (H && typeof H.get == "function") {
                const V = H.keys();
                for (const W of V) {
                  const iA = H.get(W);
                  iA && typeof iA == "string" && iA.startsWith("co_z") && G.set(W, iA);
                }
                G.size > 0;
              }
            }
          }
        }
      }
    }
    if (G.size === 0) {
      for (const [Y, S] of y.entries())
        G.set(Y, S);
      E && G.set("@maia/schema/meta", E);
    }
    return G;
  })();
  if (o)
    for (const [G] of Object.entries(o)) {
      const x = `@maia/schema/${G}`, Y = `@maia/schema/data/${G}`, S = Z.get(Y);
      S && (Z.set(x, S), C.register(x, S));
    }
  let _ = { configs: [], count: 0 };
  const T = ["actor", "context", "view", "state", "brand", "style", "inbox", "subscribers"], $ = ["states"], O = (G, x) => {
    if (!G || typeof G != "object")
      return G;
    const Y = JSON.parse(JSON.stringify(G));
    if (Y.$schema && Y.$schema.startsWith("@maia/schema/")) {
      const S = x.get(Y.$schema);
      S && (Y.$schema = S);
    }
    for (const S of T)
      delete Y[S];
    for (const S of $)
      S === "states" && Y.initial ? Y.states = Object.fromEntries(
        Object.keys(Y.states || {}).map((k) => [k, {}])
      ) : delete Y[S];
    return Y;
  }, F = () => {
    const G = new Map(Z);
    for (const [x, Y] of z.entries())
      Y && typeof Y == "string" && Y.startsWith("co_z") && G.set(x, Y);
    for (const [x, Y] of C.getAll())
      Y && typeof Y == "string" && Y.startsWith("co_z") && G.set(x, Y);
    return G;
  }, q = async (G, x, Y) => {
    if (!x || typeof x != "object")
      return { configs: [], count: 0 };
    const S = {};
    for (const [H, V] of Object.entries(x))
      S[H] = O(V, Z);
    const k = { [G]: S }, K = await dg(i, A, B, g, k, z, m, y);
    for (const H of K.configs || []) {
      const V = H.coId, W = H.path, iA = H.expectedCoId;
      z.set(W, V), iA && (z.set(iA, V), Z.set(iA, V), C.register(iA, V)), C.register(W, V);
    }
    return K;
  };
  if (e) {
    const G = await q("styles", e.styles);
    _.configs.push(...G.configs || []), _.count += G.count || 0, Z = F();
    const x = await q("actors", e.actors);
    _.configs.push(...x.configs || []), _.count += x.count || 0, Z = F();
    const Y = await q("views", e.views);
    _.configs.push(...Y.configs || []), _.count += Y.count || 0, Z = F();
    const S = await q("contexts", e.contexts);
    _.configs.push(...S.configs || []), _.count += S.count || 0, Z = F();
    const k = await q("states", e.states);
    _.configs.push(...k.configs || []), _.count += k.count || 0, Z = F();
    const K = await q("interfaces", e.interfaces);
    _.configs.push(...K.configs || []), _.count += K.count || 0, Z = F();
    const H = await q("subscriptions", e.subscriptions);
    _.configs.push(...H.configs || []), _.count += H.count || 0, Z = F();
    const V = await q("inboxes", e.inboxes);
    _.configs.push(...V.configs || []), _.count += V.count || 0, Z = F();
    const W = await q("children", e.children);
    _.configs.push(...W.configs || []), _.count += W.count || 0, Z = F();
    const iA = await q("tool", e.tool);
    _.configs.push(...iA.configs || []), _.count += iA.count || 0, Z = F();
  }
  const b = async (G, x) => {
    if (!G || !x)
      return 0;
    const Y = F();
    let S = 0;
    for (const k of G) {
      k.coId;
      const K = k.expectedCoId, H = K && x ? Object.values(x).find((gA) => gA.$id === K) : null;
      if (!H)
        continue;
      const V = a(H, Y), W = k.coMap, iA = k.cotype || "comap";
      if (iA === "colist") {
        if (W && typeof W.append == "function") {
          const gA = V.items || [];
          for (const nA of gA)
            W.append(nA);
          S++;
        }
      } else if (iA === "costream") {
        if (W && typeof W.push == "function") {
          const gA = V.items || [];
          for (const nA of gA)
            W.push(nA);
          S++;
        }
      } else if (W && typeof W.set == "function") {
        const { $id: gA, $schema: nA, ...QA } = V;
        QA.states && QA.states;
        for (const [dA, Ce] of Object.entries(QA))
          W.set(dA, Ce);
        S++;
      }
    }
    return S;
  };
  if (e) {
    const G = _.configs.filter((W) => W.type === "subscription");
    await b(G, e.subscriptions);
    const x = _.configs.filter((W) => W.type === "inbox");
    await b(x, e.inboxes);
    const Y = _.configs.filter((W) => W.type === "children");
    await b(Y, e.children), F();
    const S = _.configs.filter((W) => W.type === "actor");
    await b(S, e.actors);
    const k = _.configs.filter((W) => W.type === "view");
    await b(k, e.views);
    const K = _.configs.filter((W) => W.type === "context");
    await b(K, e.contexts);
    const H = _.configs.filter((W) => W.type === "state");
    await b(H, e.states);
    const V = _.configs.filter((W) => W.type === "interface");
    await b(V, e.interfaces);
  }
  const D = e?.vibes || [];
  if (D.length > 0) {
    Z = F();
    let G = await No(g, NA), x;
    if (G) {
      const Y = A.getCoValue(G);
      if (Y && Y.type === "comap") {
        const S = Y.getCurrentContent?.();
        S && typeof S.set == "function" && (x = S);
      }
    }
    if (!x) {
      const Y = y?.get("@maia/schema/os/vibes-registry") ?? await (await Promise.resolve().then(() => Qs)).resolve(g, "@maia/schema/os/vibes-registry", { returnType: "coId" }), S = { node: A, account: i, guardian: B }, { coValue: k } = await hA(S, null, {
        schema: Y || EXCEPTION_SCHEMAS.META_SCHEMA,
        cotype: "comap",
        data: {},
        dbEngine: g?.dbEngine
      });
      x = k, await nI(g, NA, x.id);
    }
    for (const Y of D) {
      const S = Y.actor;
      if (S && !S.startsWith("co_z") && !Z.get(S)) {
        const gA = Array.from(Z.keys()).filter((nA) => nA.startsWith("@actor/")).slice(0, 10).join(", ");
        console.warn(`[CoJSONSeed] Actor reference ${S} not found in registry for vibe ${Y.$id || Y.name}. Available actor keys (first 10): ${gA}`);
      }
      const k = a(Y, Z);
      k.actor && !k.actor.startsWith("co_z") && (console.error(`[CoJSONSeed]  Vibe actor transformation failed! Expected co-id, got: ${k.actor}`), console.error(`[CoJSONSeed] Original actor: ${Y.actor}, Registry has: ${Z.has(Y.actor)}`));
      const K = Y.$id || "", H = K.startsWith("@maia/vibe/") ? K.replace("@maia/vibe/", "") : (Y.name || "default").toLowerCase().replace(/\s+/g, "-"), W = await dg(i, A, B, g, { vibe: k }, z, m, y);
      if (_.configs.push(...W.configs || []), _.count += W.count || 0, W.configs && W.configs.length > 0) {
        const gA = W.configs[0].coId;
        if (x && typeof x.set == "function") {
          x.set(H, gA);
          const QA = x.get(H);
          QA !== gA && console.warn(`[CoJSONSeed] Vibe ${H} storage verification failed! Expected ${gA}, got ${QA}`);
        } else
          console.error(`[CoJSONSeed]  Cannot store vibe ${H}: vibes CoMap not available`);
        const nA = Y.$id;
        nA && (z.set(nA, gA), Z.set(nA, gA), C.register(nA, gA));
      }
    }
    if (x && typeof x.get == "function")
      for (const Y of D) {
        const S = Y.$id || "", k = S.startsWith("@maia/vibe/") ? S.replace("@maia/vibe/", "") : (Y.name || "default").toLowerCase().replace(/\s+/g, "-");
        x.get(k) || console.error(`[CoJSONSeed] Missing: ${k} not found in account.vibes!`);
      }
  }
  const M = await Hp(i, A, B, g, o, C);
  await DI(i, A, B, g, C, y);
  const { indexCoValue: U } = await Promise.resolve().then(() => pI), P = [
    ...(_.configs || []).map((G) => G.coId).filter(Boolean),
    ...M.coIds || []
  ];
  for (const G of P)
    if (G && typeof G == "string" && G.startsWith("co_z"))
      try {
        await U(g, G);
      } catch (x) {
        console.warn(`[Seed] Index pass failed for ${G.substring(0, 12)}...:`, x.message);
      }
  return {
    metaSchema: E,
    schemas: J,
    configs: _,
    data: M,
    registry: C.getAll()
  };
}
async function yI(i, A, e) {
  if (!i.get("sparks") || !String(i.get("sparks")).startsWith("co_z"))
    return await Kp(i, A), { metaSchema: null, schemas: {}, registry: {} };
  const t = await Mo(e), { getAllSchemas: o } = await Promise.resolve().then(() => Wt), r = o(), { CoIdRegistry: s } = await Promise.resolve().then(() => EI), { transformForSeeding: g, validateSchemaStructure: n } = await Promise.resolve().then(() => Ns), a = new s(), I = /* @__PURE__ */ new Map();
  for (const [N, R] of Object.entries(r)) {
    const L = R.$id || `@maia/schema/${N}`;
    I.has(L) || I.set(L, { name: N, schema: R });
  }
  const C = (N, R = /* @__PURE__ */ new Set()) => {
    if (!N || typeof N != "object" || R.has(N)) return /* @__PURE__ */ new Set();
    R.add(N);
    const L = /* @__PURE__ */ new Set();
    N.$co && typeof N.$co == "string" && N.$co.startsWith("@maia/schema/") && L.add(N.$co);
    for (const j of Object.values(N))
      j && typeof j == "object" && (Array.isArray(j) ? j : [j]).forEach((J) => {
        J && typeof J == "object" && C(J, R).forEach((z) => L.add(z));
      });
    return L;
  }, c = /* @__PURE__ */ new Map();
  for (const [N, { schema: R }] of I) c.set(N, C(R));
  const B = [], Q = /* @__PURE__ */ new Set(), f = /* @__PURE__ */ new Set(), l = (N) => {
    if (!Q.has(N) && !f.has(N)) {
      f.add(N);
      for (const R of c.get(N) || /* @__PURE__ */ new Set())
        R.startsWith("@maia/schema/") && I.has(R) && l(R);
      f.delete(N), Q.add(N), B.push(N);
    }
  };
  for (const N of I.keys())
    N !== "@maia/schema/meta" && l(N);
  await Hr(i, A, t, e);
  const d = await KA(e, NA);
  let u = null;
  if (d) {
    const N = await aA(e, d, { waitForAvailable: !0, timeoutMs: 2e3 });
    if (N && e.isAvailable(N)) {
      const R = e.getCurrentContent(N);
      if (R?.get) {
        const L = R.get("schematas");
        if (L) {
          const j = await aA(e, L, { waitForAvailable: !0, timeoutMs: 2e3 });
          if (j && e.isAvailable(j)) {
            const J = e.getCurrentContent(j);
            J?.get && (u = J.get("@maia/schema/meta"));
          }
        }
      }
    }
  }
  if (u) {
    const N = Ee(u), { $schema: R, $id: L, id: j, ...J } = N.definition || N, z = await aA(e, u, { waitForAvailable: !0, timeoutMs: 2e3 });
    if (z && e.isAvailable(z)) {
      const X = e.getCurrentContent(z);
      if (X?.set) for (const [Z, _] of Object.entries(RA(J))) X.set(Z, _);
    }
  } else {
    const N = Ee("co_zTEMP"), R = { definition: RA(N.definition || N) }, L = { node: A, account: i, guardian: t }, { coValue: j } = await hA(L, null, {
      schema: EXCEPTION_SCHEMAS.META_SCHEMA,
      cotype: "comap",
      data: R
    }), J = j.id, z = Ee(J), { $schema: X, $id: Z, id: _, ...T } = z.definition || z;
    for (const [$, O] of Object.entries(RA(T))) j.set($, O);
    u = J;
  }
  a.register("@maia/schema/meta", u);
  const h = /* @__PURE__ */ new Map(), w = /* @__PURE__ */ new Map(), E = await Promise.resolve().then(() => Ss), p = await Promise.resolve().then(() => NI), y = /* @__PURE__ */ new Map();
  if (d) {
    const N = await aA(e, d, { waitForAvailable: !0, timeoutMs: 2e3 });
    if (N && e.isAvailable(N)) {
      const L = e.getCurrentContent(N)?.get?.("schematas");
      if (L) {
        const j = await aA(e, L, { waitForAvailable: !0, timeoutMs: 2e3 });
        if (j && e.isAvailable(j)) {
          const J = e.getCurrentContent(j);
          if (J?.get)
            for (const z of J.keys?.() || Object.keys(J)) {
              const X = J.get(z);
              X?.startsWith?.("co_z") && y.set(z, X);
            }
        }
      }
    }
  }
  for (const N of B) {
    const { name: R, schema: L } = I.get(N), { $schema: j, $id: J, id: z, ...X } = L, Z = RA(X), _ = y.get(N);
    let T;
    _ ? (await p.update(e, u, _, Z), T = _) : T = (await E.create(e, u, Z)).id, h.set(N, T);
    const $ = e.getCoValue(T);
    if ($ && e.isAvailable($)) {
      const O = e.getCurrentContent($);
      O?.set && w.set(N, O);
    }
    a.register(N, T);
  }
  u && !h.has("@maia/schema/meta") && h.set("@maia/schema/meta", u);
  for (const N of B) {
    const { name: R, schema: L } = I.get(N), j = h.get(N), J = w.get(N), z = g(L, h);
    z.$id = `https://maia.city/${j}`;
    const X = n(z, N, { checkSchemaReferences: !0, checkNestedCoTypes: !1 });
    if (X.length > 0) throw new Error(`[Seed] Schema ${N} contains @maia/schema/ refs: ${X.join(", ")}`);
    const { $schema: Z, $id: _, id: T, ...$ } = z;
    if (J?.set) for (const [O, F] of Object.entries(RA($))) J.set(O, F);
  }
  const m = B.map((N) => {
    const { name: R } = I.get(N);
    return { name: R, key: N, coId: h.get(N), coMapId: w.get(N)?.id };
  });
  return await DI(i, A, t, e, a, h), console.log(`[Seed] Agent account seeded: ${m.length} schemas`), { metaSchema: u, schemas: m, registry: a.getAll() };
}
async function dg(i, A, e, t, o, r, s, g) {
  const n = [];
  let a = 0;
  const I = async (c, B, Q) => {
    const f = c.$schema;
    if (!f || !f.startsWith("co_z"))
      throw new Error(`[CoJSONSeed] Config ${B}:${Q} has invalid $schema: ${f}`);
    let l = "comap", d = null;
    for (const [N, R] of g.entries())
      if (R === f) {
        d = s.get(N);
        break;
      }
    if (!d) {
      const N = A.getCoValue(f);
      N && N.type === "comap" && (d = N.getCurrentContent?.());
    }
    d && typeof d.get == "function" ? l = d.get("cotype") || "comap" : console.warn(`     Cannot read schema CoMap for ${f ? f.substring(0, 12) : "undefined"}... (config: ${Q}), schemaCoMap type: ${typeof d}`);
    const { $id: u, $schema: h, ...w } = c, E = { node: A, account: i, guardian: e }, p = l === "colist" ? [] : l === "costream" ? void 0 : w, { coValue: y } = await hA(E, null, {
      schema: f,
      cotype: l,
      data: p,
      dbEngine: t?.dbEngine
    }), m = y.id;
    return u && (r.set(Q, m), r.set(u, m)), {
      type: B,
      path: Q,
      coId: m,
      expectedCoId: u || void 0,
      // Use $id from config (line 899), or undefined if not present
      coMapId: m,
      coMap: y,
      // Store the actual CoValue reference (CoMap, CoList, or CoStream)
      cotype: l
      // Store the type for reference
    };
  };
  if (o.vibe) {
    const c = await I(o.vibe, "vibe", "vibe");
    n.push(c), a++;
  }
  const C = async (c, B) => {
    if (!B || typeof B != "object")
      return 0;
    let Q = 0;
    for (const [f, l] of Object.entries(B))
      if (l && typeof l == "object" && l.$schema) {
        const d = await I(l, c, f);
        n.push(d), Q++;
      }
    return Q;
  };
  return a += await C("style", o.styles), a += await C("actor", o.actors), a += await C("view", o.views), a += await C("context", o.contexts), a += await C("state", o.states), a += await C("interface", o.interfaces), a += await C("subscription", o.subscriptions), a += await C("inbox", o.inboxes), a += await C("children", o.children), {
    count: a,
    types: [...new Set(n.map((c) => c.type))],
    configs: n
  };
}
async function Hp(i, A, e, t, o, r) {
  const { transformForSeeding: s } = await Promise.resolve().then(() => Ns);
  if (!o || Object.keys(o).length === 0)
    return {
      collections: [],
      totalItems: 0,
      coIds: []
    };
  const g = [];
  let n = 0;
  for (const [I, C] of Object.entries(o)) {
    if (!Array.isArray(C)) {
      console.warn(`[CoJSONSeed] Skipping ${I}: not an array`);
      continue;
    }
    const c = `data/${I}`, B = `@maia/schema/data/${I}`, Q = `@maia/schema/${I}`, f = r.registry.get(c) || r.registry.get(B) || r.registry.get(Q);
    if (!f) {
      console.warn(`[CoJSONSeed] No schema found for collection ${I} (tried: ${c}, ${B}, ${Q}), skipping`);
      continue;
    }
    let l = 0;
    const d = [];
    for (const u of C) {
      const h = s(u, r.getAll()), { $id: w, ...E } = h, p = { node: A, account: i, guardian: e }, { coValue: y } = await hA(p, null, {
        schema: f,
        cotype: "comap",
        data: E,
        dbEngine: t?.dbEngine
      });
      d.push(y.id), l++;
    }
    g.push({
      name: I,
      schemaCoId: f,
      itemCount: l,
      coIds: d
    }), n += l;
  }
  const a = g.flatMap((I) => I.coIds || []);
  return {
    collections: g,
    totalItems: n,
    coIds: a
  };
}
async function Hr(i, A, e, t, o) {
  const r = await KA(t, NA);
  if (!r)
    throw new Error("[Seed] @maia spark.os not found. Ensure schemaMigration or bootstrap has run.");
  const { resolve: s } = await Promise.resolve().then(() => Qs), g = o?.get("@maia/schema/os/schematas-registry") ?? await s(t, "@maia/schema/os/schematas-registry", { returnType: "coId" }), n = o?.get("@maia/schema/os/vibes-registry") ?? await s(t, "@maia/schema/os/vibes-registry", { returnType: "coId" });
  g || EXCEPTION_SCHEMAS.META_SCHEMA, n || EXCEPTION_SCHEMAS.META_SCHEMA;
  let a = A.getCoValue(r);
  if (!a && A.loadCoValueCore && (await A.loadCoValueCore(r), a = A.getCoValue(r)), (!a || !a.isAvailable()) && (await new Promise((C) => {
    let c;
    const B = setTimeout(C, 5e3);
    a ? c = a.subscribe((Q) => {
      Q?.isAvailable?.() && (clearTimeout(B), c?.(), C());
    }) : C();
  }), a = A.getCoValue(r)), a && a.isAvailable()) {
    const C = a.getCurrentContent?.();
    if (C && typeof C.get == "function") {
      if (!C.get("schematas")) {
        const Q = { node: A, account: i, guardian: e }, { coValue: f } = await hA(Q, null, {
          schema: g || EXCEPTION_SCHEMAS.META_SCHEMA,
          cotype: "comap",
          data: {},
          dbEngine: t?.dbEngine
        });
        if (C.set("schematas", f.id), A.storage?.syncManager)
          try {
            await A.syncManager.waitForStorageSync(f.id), await A.syncManager.waitForStorageSync(r);
          } catch (l) {
            console.warn("[Seed] Storage sync wait failed for spark.os.schematas:", l);
          }
      }
      !C.get("indexes") && t && await ko(t);
    }
  }
  if (!await No(t, NA) && o) {
    const C = t.account?.get("sparks");
    if (C?.startsWith("co_z")) {
      const c = await t.read(null, C);
      await new Promise((f, l) => {
        if (!c.loading) return f();
        const d = setTimeout(() => l(new Error("Timeout")), 1e4), u = c.subscribe(() => {
          c.loading || (clearTimeout(d), u?.(), f());
        });
      });
      const Q = c?.value?.[NA];
      if (Q?.startsWith("co_z")) {
        const f = t.getCoValue(Q);
        if (f && t.isAvailable(f)) {
          const l = t.getCurrentContent(f);
          if (l && typeof l.set == "function") {
            const d = { node: A, account: i, guardian: e }, { coValue: u } = await hA(d, null, {
              schema: n || EXCEPTION_SCHEMAS.META_SCHEMA,
              cotype: "comap",
              data: {},
              dbEngine: t?.dbEngine
            });
            l.set("vibes", u.id);
          }
        }
      }
    }
  }
}
async function DI(i, A, e, t, o, r, s, g, n) {
  const a = await KA(t, NA);
  if (!a) {
    console.warn("[Seed] spark.os not found - should have been created in Phase 0");
    return;
  }
  let I = A.getCoValue(a);
  if (!I && A.loadCoValueCore && (await A.loadCoValueCore(a), I = A.getCoValue(a)), !I || !I.isAvailable()) {
    console.warn(`[Seed] account.os (${a ? a.substring(0, 12) : "undefined"}...) not available`);
    return;
  }
  const C = I.getCurrentContent?.();
  if (!C || typeof C.get != "function") {
    console.warn("[Seed] account.os content not available");
    return;
  }
  let c = C.get("schematas"), B;
  if (c) {
    const f = A.getCoValue(c);
    if (f && f.isAvailable()) {
      const l = f.getCurrentContent?.();
      l && typeof l.set == "function" && (B = l);
    }
  }
  if (!B) {
    let f = null;
    r && r.has("@maia/schema/os/schematas-registry") && (f = r.get("@maia/schema/os/schematas-registry"));
    const l = f || EXCEPTION_SCHEMAS.META_SCHEMA, d = { node: A, account: i, guardian: e }, { coValue: u } = await hA(d, null, {
      schema: l,
      cotype: "comap",
      data: {},
      dbEngine: t?.dbEngine
    });
    if (B = u, C.set("schematas", B.id), A.storage && A.syncManager)
      try {
        await A.syncManager.waitForStorageSync(B.id), await A.syncManager.waitForStorageSync(a);
      } catch (h) {
        console.warn("[Seed] Storage sync wait failed for account.os.schematas:", h);
      }
  }
  const Q = o.get("@maia/schema/meta");
  if (Q) {
    const f = B.get("@maia/schema/meta");
    f ? f !== Q && console.warn(`[Seed] Metaschema already registered with different co-id: ${f ? f.substring(0, 12) : "undefined"}... (new: ${Q ? Q.substring(0, 12) : "undefined"}...). Skipping.`) : B.set("@maia/schema/meta", Q);
  }
}
const qp = [
  "coValues",
  "sessions",
  "transactions",
  "signatureAfter",
  "deletedCoValues"
];
class Lp {
  constructor(A, e = qp) {
    this.db = A, this.storeNames = e, this.pendingRequests = [], this.rejectHandlers = [], this.id = Math.random(), this.running = !1, this.failed = !1, this.done = !1, this.refresh();
  }
  refresh() {
    this.tx = this.db.transaction(this.storeNames, "readwrite"), this.tx.oncomplete = () => {
      this.done = !0;
    }, this.tx.onabort = () => {
      this.done = !0;
    };
  }
  rollback() {
    this.tx.abort();
  }
  getObjectStore(A) {
    try {
      return this.tx.objectStore(A);
    } catch {
      return this.refresh(), this.tx.objectStore(A);
    }
  }
  pushRequest(A) {
    const e = () => {
      const t = this.pendingRequests.shift();
      t ? t(this) : (this.running = !1, this.done = !0);
    };
    return this.running ? new Promise((t, o) => {
      this.rejectHandlers.push(o), this.pendingRequests.push(async () => {
        try {
          const r = await A(this, e);
          t(r);
        } catch (r) {
          o(r);
        }
      });
    }) : (this.running = !0, A(this, e));
  }
  handleRequest(A) {
    return this.pushRequest((e, t) => new Promise((o, r) => {
      const s = A(e);
      s.onerror = () => {
        this.failed = !0, this.tx.abort(), console.error(s.error), r(s.error);
        for (const g of this.rejectHandlers)
          g();
      }, s.onsuccess = () => {
        o(s.result), t();
      };
    }));
  }
  commit() {
    this.done || this.tx.commit();
  }
}
function Le(i, A, e) {
  return new Promise((t, o) => {
    const r = i.transaction(A, "readonly"), s = e(r.objectStore(A));
    s.onerror = () => {
      o(s.error);
    }, s.onsuccess = () => {
      t(s.result), r.commit();
    };
  });
}
function xp(i, A, e) {
  return new Promise((t, o) => {
    const r = i.transaction(A, "readwrite"), s = r.objectStore(A).put(e);
    s.onerror = () => {
      o(s.error);
    }, s.onsuccess = () => {
      t(s.result), r.commit();
    };
  });
}
var hg = function(i, A, e, t) {
  if (e === "a" && !t) throw new TypeError("Private accessor was defined without a getter");
  if (typeof A == "function" ? i !== A || !t : !A.has(i)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return e === "m" ? t : e === "a" ? t.call(i) : t ? t.value : A.get(i);
}, go, qr;
class Op {
  constructor(A) {
    go.add(this), this.tx = A;
  }
  async run(A) {
    return this.tx.handleRequest(A);
  }
  async getSingleCoValueSession(A, e) {
    return this.run((t) => t.getObjectStore("sessions").index("uniqueSessions").get([A, e]));
  }
  async markCoValueAsDeleted(A) {
    await this.run((e) => e.getObjectStore("deletedCoValues").put({
      coValueID: A,
      status: "pending"
    }));
  }
  async deleteCoValueContent(A) {
    const e = A.rowID, o = (await this.run((s) => s.getObjectStore("sessions").index("sessionsByCoValue").getAll(e))).filter((s) => !s.sessionID.endsWith("$")).map((s) => s.rowID), r = [];
    for (const s of o)
      r.push(hg(this, go, "m", qr).call(this, "transactions", s), hg(this, go, "m", qr).call(this, "signatureAfter", s), this.run((g) => g.getObjectStore("sessions").delete(s)));
    r.push(this.run((s) => s.getObjectStore("deletedCoValues").put({
      coValueID: A.id,
      status: "done"
    }))), await Promise.all(r);
  }
  async addSessionUpdate({ sessionUpdate: A, sessionRow: e }) {
    return this.run((t) => t.getObjectStore("sessions").put(e?.rowID ? {
      rowID: e.rowID,
      ...A
    } : A));
  }
  async addTransaction(A, e, t) {
    await this.run((o) => o.getObjectStore("transactions").add({
      ses: A,
      idx: e,
      tx: t
    }));
  }
  async addSignatureAfter({ sessionRowID: A, idx: e, signature: t }) {
    return this.run((o) => o.getObjectStore("signatureAfter").put({
      ses: A,
      idx: e,
      signature: t
    }));
  }
  /**
   * Get an unsynced CoValue record by coValueId and peerId.
   */
  async getUnsyncedCoValueRecord(A, e) {
    return this.run((t) => t.getObjectStore("unsyncedCoValues").index("uniqueUnsyncedCoValues").get([A, e]));
  }
  /**
   * Get all unsynced CoValue records for a given coValueId.
   */
  async getAllUnsyncedCoValueRecords(A) {
    return this.run((e) => e.getObjectStore("unsyncedCoValues").index("byCoValueId").getAll(A));
  }
  /**
   * Delete an unsynced CoValue record by rowID.
   */
  async deleteUnsyncedCoValueRecord(A) {
    await this.run((e) => e.getObjectStore("unsyncedCoValues").delete(A));
  }
  /**
   * Insert or update an unsynced CoValue record.
   */
  async putUnsyncedCoValueRecord(A) {
    await this.run((e) => e.getObjectStore("unsyncedCoValues").put(A));
  }
}
go = /* @__PURE__ */ new WeakSet(), qr = async function(A, e) {
  const t = IDBKeyRange.bound([e, 0], [e, Number.POSITIVE_INFINITY]), o = await this.run((r) => r.getObjectStore(A).getAllKeys(t));
  for (const r of o)
    await this.run((s) => s.getObjectStore(A).delete(r));
};
class Tp {
  constructor(A) {
    this.db = A;
  }
  async getCoValue(A) {
    return Le(this.db, "coValues", (e) => e.index("coValuesById").get(A));
  }
  async getCoValueRowID(A) {
    return this.getCoValue(A).then((e) => e?.rowID);
  }
  async getCoValueSessions(A) {
    return Le(this.db, "sessions", (e) => e.index("sessionsByCoValue").getAll(A));
  }
  async getNewTransactionInSession(A, e, t) {
    return Le(this.db, "transactions", (o) => o.getAll(IDBKeyRange.bound([A, e], [A, t])));
  }
  async getSignatures(A, e) {
    return Le(this.db, "signatureAfter", (t) => t.getAll(IDBKeyRange.bound([A, e], [A, Number.POSITIVE_INFINITY])));
  }
  async upsertCoValue(A, e) {
    return e ? xp(this.db, "coValues", {
      id: A,
      header: e
    }).catch(() => this.getCoValueRowID(A)) : this.getCoValueRowID(A);
  }
  async getAllCoValuesWaitingForDelete() {
    return (await Le(this.db, "deletedCoValues", (e) => e.index("deletedCoValuesByStatus").getAll("pending"))).map((e) => e.coValueID);
  }
  async transaction(A, e) {
    const t = new Lp(this.db, e);
    try {
      await A(new Op(t)), t.commit();
    } catch {
      t.rollback();
    }
  }
  async trackCoValuesSyncState(A) {
    A.length !== 0 && await this.transaction(async (e) => {
      await Promise.all(A.map(async (t) => {
        const o = await e.getUnsyncedCoValueRecord(t.id, t.peerId);
        t.synced ? o && await e.deleteUnsyncedCoValueRecord(o.rowID) : await e.putUnsyncedCoValueRecord(o ? {
          rowID: o.rowID,
          coValueId: t.id,
          peerId: t.peerId
        } : {
          coValueId: t.id,
          peerId: t.peerId
        });
      }));
    }, ["unsyncedCoValues"]);
  }
  async eraseCoValueButKeepTombstone(A) {
    const e = await this.getCoValue(A);
    if (!e) {
      console.warn(`CoValue ${A} not found, skipping deletion`);
      return;
    }
    await this.transaction((t) => t.deleteCoValueContent(e));
  }
  async getUnsyncedCoValueIDs() {
    const A = await Le(this.db, "unsyncedCoValues", (t) => t.getAll()), e = /* @__PURE__ */ new Set();
    for (const t of A)
      e.add(t.coValueId);
    return Array.from(e);
  }
  async stopTrackingSyncState(A) {
    await this.transaction(async (e) => {
      const t = e, o = await t.getAllUnsyncedCoValueRecords(A);
      await Promise.all(o.map((r) => t.deleteUnsyncedCoValueRecord(r.rowID)));
    }, ["unsyncedCoValues"]);
  }
  async getCoValueKnownState(A) {
    const e = await this.getCoValue(A);
    if (!e)
      return;
    const t = await this.getCoValueSessions(e.rowID), o = {
      id: A,
      header: !0,
      sessions: {}
    };
    for (const r of t)
      o.sessions[r.sessionID] = r.lastIdx;
    return o;
  }
}
let Pp = "jazz-storage";
async function jp(i = Pp) {
  const e = await new Promise((t, o) => {
    const r = indexedDB.open(i, 6);
    r.onerror = () => {
      o(r.error);
    }, r.onsuccess = () => {
      t(r.result);
    }, r.onupgradeneeded = async (s) => {
      const g = r.result;
      if (s.oldVersion === 0) {
        g.createObjectStore("coValues", {
          autoIncrement: !0,
          keyPath: "rowID"
        }).createIndex("coValuesById", "id", {
          unique: !0
        });
        const a = g.createObjectStore("sessions", {
          autoIncrement: !0,
          keyPath: "rowID"
        });
        a.createIndex("sessionsByCoValue", "coValue"), a.createIndex("uniqueSessions", ["coValue", "sessionID"], {
          unique: !0
        }), g.createObjectStore("transactions", {
          keyPath: ["ses", "idx"]
        });
      }
      if (s.oldVersion <= 1 && g.createObjectStore("signatureAfter", {
        keyPath: ["ses", "idx"]
      }), s.oldVersion <= 4) {
        const n = g.createObjectStore("unsyncedCoValues", {
          autoIncrement: !0,
          keyPath: "rowID"
        });
        n.createIndex("byCoValueId", "coValueId"), n.createIndex("uniqueUnsyncedCoValues", ["coValueId", "peerId"], {
          unique: !0
        });
      }
      s.oldVersion <= 5 && g.createObjectStore("deletedCoValues", {
        keyPath: "coValueID"
      }).createIndex("deletedCoValuesByStatus", "status", {
        unique: !1
      });
    };
  });
  return new Ya(new Tp(e));
}
async function Vp() {
  try {
    return await jp();
  } catch {
    return;
  }
}
const fg = {
  1: [
    `CREATE TABLE IF NOT EXISTS transactions (
      ses INTEGER,
      idx INTEGER,
      tx TEXT NOT NULL,
      PRIMARY KEY (ses, idx)
    );`,
    `CREATE TABLE IF NOT EXISTS sessions (
      "rowID" SERIAL PRIMARY KEY,
      "coValue" INTEGER NOT NULL,
      "sessionID" TEXT NOT NULL,
      "lastIdx" INTEGER,
      "lastSignature" TEXT,
      UNIQUE ("sessionID", "coValue")
    );`,
    'CREATE INDEX IF NOT EXISTS sessionsByCoValue ON sessions ("coValue");',
    `CREATE TABLE IF NOT EXISTS coValues (
      "rowID" SERIAL PRIMARY KEY,
      id TEXT NOT NULL UNIQUE,
      header TEXT NOT NULL
    );`,
    "CREATE INDEX IF NOT EXISTS coValuesByID ON coValues (id);"
  ],
  3: [
    `CREATE TABLE IF NOT EXISTS signatureAfter (
      ses INTEGER,
      idx INTEGER,
      signature TEXT NOT NULL,
      PRIMARY KEY (ses, idx)
    );`,
    'ALTER TABLE sessions ADD COLUMN IF NOT EXISTS "bytesSinceLastSignature" INTEGER;'
  ],
  4: [
    `CREATE TABLE IF NOT EXISTS unsynced_covalues (
      "rowID" SERIAL PRIMARY KEY,
      "co_value_id" TEXT NOT NULL,
      "peer_id" TEXT NOT NULL,
      UNIQUE ("co_value_id", "peer_id")
    );`,
    'CREATE INDEX IF NOT EXISTS idx_unsynced_covalues_co_value_id ON unsynced_covalues("co_value_id");'
  ],
  5: [
    `CREATE TABLE IF NOT EXISTS deletedCoValues (
      "coValueID" TEXT PRIMARY KEY,
      status INTEGER NOT NULL DEFAULT 0
    );`,
    "CREATE INDEX IF NOT EXISTS deletedCoValuesByStatus ON deletedCoValues (status);"
  ]
};
async function Wp(i) {
  try {
    return (await i.query("SELECT version FROM schema_version ORDER BY version DESC LIMIT 1")).rows[0]?.version || 0;
  } catch {
    return 0;
  }
}
async function zp(i, A) {
  await i.exec(`
    CREATE TABLE IF NOT EXISTS schema_version (
      version INTEGER PRIMARY KEY,
      applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
    INSERT INTO schema_version (version) VALUES (${A})
    ON CONFLICT (version) DO NOTHING;
  `);
}
async function Zp(i) {
  const A = await Wp(i), e = Object.keys(fg).map((t) => parseInt(t, 10)).filter((t) => t > A).sort((t, o) => t - o);
  for (const t of e) {
    const o = fg[t];
    for (const r of o)
      await i.exec(r);
    await zp(i, t);
  }
}
class _p {
  constructor(A) {
    this.db = A;
  }
  async getSingleCoValueSession(A, e) {
    const o = (await this.db.query(
      'SELECT * FROM sessions WHERE "coValue" = $1 AND "sessionID" = $2',
      [A, e]
    )).rows[0];
    if (o)
      return {
        rowID: o.rowID || o.rowid,
        coValue: o.coValue || o.covalue,
        sessionID: o.sessionID || o.sessionid,
        lastIdx: o.lastIdx || o.lastidx,
        lastSignature: o.lastSignature || o.lastsignature,
        bytesSinceLastSignature: o.bytesSinceLastSignature || o.bytessincelastsignature
      };
  }
  async markCoValueAsDeleted(A) {
    await this.db.query(
      "INSERT INTO deletedCoValues (coValueID, status) VALUES ($1, $2) ON CONFLICT (coValueID) DO NOTHING",
      [A, vt.Pending]
    );
  }
  async addSessionUpdate({ sessionUpdate: A, sessionRow: e }) {
    if (e)
      return (await this.db.query(
        `UPDATE sessions 
         SET "lastIdx" = $1, "lastSignature" = $2, "bytesSinceLastSignature" = $3
         WHERE "rowID" = $4
         RETURNING "rowID"`,
        [
          A.lastIdx,
          A.lastSignature,
          A.bytesSinceLastSignature,
          e.rowID
        ]
      )).rows[0]?.rowID || e.rowID;
    {
      const t = await this.db.query(
        `INSERT INTO sessions ("coValue", "sessionID", "lastIdx", "lastSignature", "bytesSinceLastSignature") 
         VALUES ($1, $2, $3, $4, $5)
         ON CONFLICT ("sessionID", "coValue") 
         DO UPDATE SET "lastIdx" = EXCLUDED."lastIdx", "lastSignature" = EXCLUDED."lastSignature", "bytesSinceLastSignature" = EXCLUDED."bytesSinceLastSignature"
         RETURNING "rowID"`,
        [
          A.coValue,
          A.sessionID,
          A.lastIdx,
          A.lastSignature,
          A.bytesSinceLastSignature
        ]
      );
      if (!t.rows[0])
        throw new Error("Failed to add session update");
      return t.rows[0].rowID;
    }
  }
  async addTransaction(A, e, t) {
    await this.db.query(
      "INSERT INTO transactions (ses, idx, tx) VALUES ($1, $2, $3)",
      [A, e, JSON.stringify(t)]
    );
  }
  async addSignatureAfter({ sessionRowID: A, idx: e, signature: t }) {
    await this.db.query(
      "INSERT INTO signatureAfter (ses, idx, signature) VALUES ($1, $2, $3)",
      [A, e, t]
    );
  }
}
class $p {
  constructor(A) {
    this.db = A;
  }
  async getCoValue(A) {
    const e = await this.db.query(
      "SELECT * FROM coValues WHERE id = $1",
      [A]
    );
    if (!e.rows[0]) return;
    const t = e.rows[0];
    try {
      const o = typeof t.header == "string" ? JSON.parse(t.header) : t.header;
      return {
        rowID: t.rowID || t.rowid,
        id: t.id,
        header: o
      };
    } catch (o) {
      AA.warn(`Invalid JSON in header: ${t.header}`, {
        id: A,
        err: o
      });
      return;
    }
  }
  async upsertCoValue(A, e) {
    if (!e) {
      const r = await this.db.query(
        'SELECT "rowID" FROM coValues WHERE id = $1',
        [A]
      );
      return r.rows[0]?.rowID || r.rows[0]?.rowid;
    }
    const t = await this.db.query(
      `INSERT INTO coValues (id, header) VALUES ($1, $2)
       ON CONFLICT (id) DO NOTHING
       RETURNING "rowID"`,
      [A, JSON.stringify(e)]
    );
    if (t.rows[0])
      return t.rows[0].rowID || t.rows[0].rowid;
    const o = await this.db.query(
      'SELECT "rowID" FROM coValues WHERE id = $1',
      [A]
    );
    return o.rows[0]?.rowID || o.rows[0]?.rowid;
  }
  async getAllCoValuesWaitingForDelete() {
    return (await this.db.query(
      'SELECT "coValueID" FROM deletedCoValues WHERE status = $1',
      [vt.Pending]
    )).rows.map((e) => e.coValueID || e.covalueid);
  }
  async getCoValueSessions(A) {
    return (await this.db.query(
      'SELECT * FROM sessions WHERE "coValue" = $1',
      [A]
    )).rows.map((t) => ({
      rowID: t.rowID || t.rowid,
      coValue: t.coValue || t.covalue,
      sessionID: t.sessionID || t.sessionid,
      lastIdx: t.lastIdx || t.lastidx,
      lastSignature: t.lastSignature || t.lastsignature,
      bytesSinceLastSignature: t.bytesSinceLastSignature || t.bytessincelastsignature
    }));
  }
  async getNewTransactionInSession(A, e, t) {
    return (await this.db.query(
      "SELECT * FROM transactions WHERE ses = $1 AND idx >= $2 AND idx <= $3 ORDER BY idx",
      [A, e, t]
    )).rows.map((r) => {
      try {
        return {
          ses: r.ses,
          idx: r.idx,
          tx: typeof r.tx == "string" ? JSON.parse(r.tx) : r.tx
        };
      } catch (s) {
        return AA.warn("Invalid JSON in transaction", { err: s }), null;
      }
    }).filter(Boolean);
  }
  async getSignatures(A, e) {
    return (await this.db.query(
      "SELECT * FROM signatureAfter WHERE ses = $1 AND idx >= $2 ORDER BY idx",
      [A, e]
    )).rows.map((o) => ({
      ses: o.ses,
      idx: o.idx,
      signature: o.signature
    }));
  }
  async transaction(A) {
    await this.db.exec("BEGIN");
    try {
      const e = new _p(this.db);
      await A(e), await this.db.exec("COMMIT");
    } catch (e) {
      throw await this.db.exec("ROLLBACK"), e;
    }
  }
  async trackCoValuesSyncState(A) {
    for (const e of A)
      e.synced ? await this.db.query(
        'DELETE FROM unsynced_covalues WHERE "co_value_id" = $1 AND "peer_id" = $2',
        [e.id, e.peerId]
      ) : await this.db.query(
        'INSERT INTO unsynced_covalues ("co_value_id", "peer_id") VALUES ($1, $2) ON CONFLICT ("co_value_id", "peer_id") DO NOTHING',
        [e.id, e.peerId]
      );
  }
  async getUnsyncedCoValueIDs() {
    return (await this.db.query(
      'SELECT DISTINCT "co_value_id" FROM unsynced_covalues'
    )).rows.map((e) => e.co_value_id);
  }
  async stopTrackingSyncState(A) {
    await this.db.query(
      'DELETE FROM unsynced_covalues WHERE "co_value_id" = $1',
      [A]
    );
  }
  async eraseCoValueButKeepTombstone(A) {
    const e = await this.db.query(
      'SELECT "rowID" FROM coValues WHERE id = $1',
      [A]
    );
    if (!e.rows[0]) {
      AA.warn(`CoValue ${A} not found, skipping deletion`);
      return;
    }
    const t = e.rows[0].rowID || e.rows[0].rowid;
    await this.transaction(async (o) => {
      await this.db.query(
        `DELETE FROM transactions
         WHERE ses IN (
           SELECT "rowID" FROM sessions
           WHERE "coValue" = $1 AND "sessionID" NOT LIKE '%$'
         )`,
        [t]
      ), await this.db.query(
        `DELETE FROM signatureAfter
         WHERE ses IN (
           SELECT "rowID" FROM sessions
           WHERE "coValue" = $1 AND "sessionID" NOT LIKE '%$'
         )`,
        [t]
      ), await this.db.query(
        `DELETE FROM sessions
         WHERE "coValue" = $1 AND "sessionID" NOT LIKE '%$'`,
        [t]
      ), await this.db.query(
        `INSERT INTO deletedCoValues ("coValueID", status) VALUES ($1, $2)
         ON CONFLICT ("coValueID") DO UPDATE SET status = $2`,
        [A, vt.Done]
      );
    });
  }
  async getCoValueKnownState(A) {
    const e = await this.db.query(
      'SELECT "rowID" FROM coValues WHERE id = $1',
      [A]
    );
    if (!e.rows[0])
      return;
    const t = e.rows[0].rowID || e.rows[0].rowid, o = await this.db.query(
      'SELECT "sessionID", "lastIdx" FROM sessions WHERE "coValue" = $1',
      [t]
    ), r = ve(A);
    r.header = !0;
    for (const s of o.rows) {
      const g = s.sessionID || s.sessionid, n = s.lastIdx || s.lastidx;
      r.sessions[g] = n;
    }
    return r;
  }
}
async function Xp(i) {
  if (typeof window < "u" || typeof process > "u" || !process.versions?.node)
    throw new Error("[STORAGE] PGlite is only available in Node.js/server environments");
  let A;
  try {
    const s = await import("@electric-sql/pglite");
    A = s.PGlite || s.default?.PGlite || s.default;
  } catch (s) {
    throw typeof window < "u" ? new Error("[STORAGE] PGlite cannot be imported in browser environment. This is a server-only module.") : s;
  }
  if (!A)
    throw new Error("[STORAGE] Failed to import PGlite - module structure may have changed");
  const e = await Promise.resolve().then(() => ia), o = (await Promise.resolve().then(() => ia)).dirname(i);
  try {
    await e.mkdir(o, { recursive: !0 });
  } catch (s) {
    if (s.code !== "EEXIST") throw s;
  }
  const r = await A.create(i);
  return await Zp(r), new $p(r);
}
async function Ay(i) {
  const A = await Xp(i), e = new Ya(A);
  return e.enableDeletedCoValuesErasure(), e;
}
const lt = { BASE_URL: "/", DEV: !1, MODE: "production", PROD: !0, SSR: !1 };
function ey() {
  return typeof EdgeRuntime < "u" || typeof Deno < "u" ? "edge" : typeof process < "u" && process.versions?.node ? "node" : "browser";
}
function ty(i, A = null) {
  const e = A ? `${A}_${i}` : i;
  if (typeof import.meta < "u" && lt)
    return lt[e] || lt[i] || lt[`VITE_${e}`] || lt[`VITE_${i}`];
  if (typeof process < "u" && process.env)
    return process.env[e] || process.env[i];
}
const ut = () => {
};
async function He(i = {}) {
  const { mode: A = "human", dbPath: e, inMemory: t, servicePrefix: o } = i, r = ey(), s = ty("MAIA_STORAGE", o);
  if (t === !0 || r === "edge" || s === "in-memory")
    return ut();
  if (r === "browser")
    return s === "indexeddb" || !s && A === "human" ? await Vp() ?? ut() : ut();
  if (r === "node") {
    const g = e || typeof process < "u" && process.env?.DB_PATH;
    if ((g && !t || s === "pglite" && !t && g) && g)
      try {
        return await Ay(g);
      } catch (a) {
        if (s === "pglite")
          throw new Error(
            `[STORAGE] PGlite storage initialization FAILED at ${g}. Storage type is explicitly set to 'pglite' via MAIA_STORAGE env var - refusing to fall back. Original error: ${a?.message || a}`
          );
        return ut();
      }
  }
  return ut();
}
const sr = { BASE_URL: "/", DEV: !1, MODE: "production", PROD: !0, SSR: !1 };
async function Rs({ agentSecret: i, name: A = "Maia", peers: e = [], storage: t = void 0, skipAutoSeeding: o = !1 }) {
  if (!i)
    throw new Error("agentSecret is required. Use signInWithPasskey() to get agentSecret.");
  const r = await Ie.create(), s = t !== void 0 ? t : await He({ mode: "human" }), g = await ke.withNewlyCreatedAccount({
    creationProps: { name: A },
    crypto: r,
    initialAgentSecret: i,
    // Use provided secret from passkey!
    peers: e,
    // Use provided sync peers
    storage: s,
    // Use centralized storage if not provided
    migration: us
    // Handles profile + schemata + Data
  }), n = g.node.expectCurrentAccount("oID/createAccountWithSecret"), a = n.get("profile");
  if (!a)
    throw new Error("Profile not created by account creation migration");
  if (o) {
    console.log("  Auto-seeding skipped (agent mode/server account)");
    try {
      const { CoJSONBackend: I } = await Promise.resolve().then(() => xr), { DBEngine: C } = await Promise.resolve().then(() => pg), c = new I(g.node, n, { systemSpark: "@maia" });
      c.dbEngine = new C(c), await yI(n, g.node, c);
    } catch (I) {
      console.error("[createAccountWithSecret] Agent seed failed (non-blocking):", I);
    }
  } else
    try {
      const I = typeof import.meta < "u" ? sr?.VITE_MAIA_CITY_SEED_VIBES || sr?.VITE_SEED_VIBES || sr?.SEED_VIBES : null, C = I ? I === "all" ? "all" : I.split(",").map((R) => R.trim()) : "all", { getAllVibeRegistries: c, filterVibesForSeeding: B } = await Promise.resolve().then(() => CN), Q = await c(), f = B(Q, C);
      if (f.length === 0)
        return Q.length === 0 ? console.log("  No vibe registries found, skipping auto-seeding") : console.log(`  Seeding config filters out all vibes (config: ${JSON.stringify(C)}), skipping vibe seeding`), {
          node: g.node,
          account: n,
          accountID: n.id,
          profile: a,
          group: null
        };
      console.log(` Auto-seeding ${f.length} vibe(s) based on config: ${JSON.stringify(C)}`);
      const l = {
        styles: {},
        actors: {},
        views: {},
        contexts: {},
        states: {},
        inboxes: {},
        vibes: f.map((R) => R.vibe),
        // Pass vibes as array
        data: {}
      };
      for (const R of f)
        Object.assign(l.styles, R.styles || {}), Object.assign(l.actors, R.actors || {}), Object.assign(l.views, R.views || {}), Object.assign(l.contexts, R.contexts || {}), Object.assign(l.states, R.states || {}), Object.assign(l.inboxes, R.inboxes || {}), Object.assign(l.data, R.data || {});
      const { CoJSONBackend: d } = await Promise.resolve().then(() => xr), u = new d(g.node, n, { systemSpark: "@maia" }), { DBEngine: h } = await Promise.resolve().then(() => pg), w = new h(u);
      u.dbEngine = w;
      const { getAllToolDefinitions: E } = await Promise.resolve().then(() => GI), p = E(), y = {
        ...l,
        tool: p
        // Add tool definitions under 'tool' key
      }, { getAllSchemas: m } = await Promise.resolve().then(() => Wt), N = m();
      await w.execute({
        op: "seed",
        configs: y,
        schemas: N,
        data: l.data || {}
      });
    } catch (I) {
      console.error("[createAccountWithSecret] Auto-seeding failed (non-blocking):", I);
    }
  return {
    node: g.node,
    account: n,
    accountID: n.id,
    profile: a,
    group: null
    // No group in minimal setup
  };
}
async function bs({ accountID: i, agentSecret: A, peers: e = [], storage: t = void 0 }) {
  if (!A)
    throw new Error("agentSecret is required. Use signInWithPasskey() to get agentSecret.");
  if (!i)
    throw new Error("accountID is required.");
  const o = await Ie.create(), r = t !== void 0 ? t : await He({ mode: "human" }), s = performance.now();
  console.log("   Sync peers:", e.length > 0 ? `${e.length} peer(s)` : "none");
  const g = t ? typeof process < "u" && process.versions?.node ? "PGlite available (local-first)" : "IndexedDB available (local-first)" : "no storage (sync-only)";
  console.log("   Storage:", g), performance.now();
  const n = performance.now();
  t && console.log("    Storage available"), performance.now() - n;
  let a = null;
  const I = async (h, w) => (a = us(h, w).catch((E) => {
    console.error("[loadAccount] Migration error (non-blocking):", E);
  }), Promise.resolve()), C = performance.now(), c = 3e3, B = ke.withLoadedAccount({
    crypto: o,
    accountID: i,
    accountSecret: A,
    sessionID: o.newRandomSessionID(i),
    peers: e,
    // Use provided sync peers (sync happens in background if storage has data)
    storage: r,
    // Use centralized storage if not provided - enables local-first loading
    migration: I
    //  Runs after account loads, non-blocking
  }).catch((h) => {
    if (h?.message?.includes("Account unavailable from all peers") && e.length === 0 && r) {
      const w = new Error("Account not found in storage (first-time setup - will be created)");
      throw w.originalError = h, w.isAccountNotFound = !0, w;
    }
    throw h;
  }), Q = new Promise((h) => {
    setTimeout(() => {
      performance.now() - C, h(null);
    }, c);
  }), f = await Promise.race([B, Q]).then((h) => h === null ? B : h);
  if (performance.now(), a) {
    const h = performance.now();
    a.then(() => {
      performance.now() - h;
    }).catch(() => {
    });
  }
  const l = f.expectCurrentAccount("oID/loadAccount");
  performance.now();
  const d = l.get("profile");
  if (d) {
    const h = f.getCoValue(d);
    h && !h.isAvailable() && await f.load(d), performance.now();
  }
  performance.now();
  const u = l.get("os");
  if (u && typeof u == "string" && u.startsWith("co_z")) {
    const h = f.getCoValue(u);
    h && !h.isAvailable() ? f.loadCoValueCore(u).catch((w) => {
      console.warn("[loadAccount] Failed to prefetch account.os:", w);
    }) : h && h.isAvailable();
  }
  return performance.now() - s, {
    node: f,
    account: l,
    accountID: l.id
  };
}
function iy(i, A, { name: e = null } = {}) {
  const t = i.createGroup();
  if (A && typeof A.extend == "function")
    try {
      t.extend(A, "admin");
    } catch (o) {
      console.warn("[createChildGroup] Could not extend parent group, account is already admin:", o.message);
    }
  return e && t.set("name", e, "trusting"), console.log(" Child group created:", t.id), e && console.log("   Name:", e), console.log("   Owner:", A?.id), t;
}
const oy = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createChildGroup: iy
}, Symbol.toStringTag, { value: "Module" }));
function bA(i, A = {}) {
  return { ok: !0, data: i, ...A };
}
function fA(i, A = {}) {
  return { ok: !1, errors: i, ...A };
}
function wA(i, A, e) {
  return { type: i, message: A, path: e ?? void 0 };
}
function Ve(i) {
  return i && i.ok === !0;
}
const ry = [
  "Transactor has no write permissions",
  "lacks admin permissions",
  "lacks write permissions",
  "lacks read permissions",
  "Cannot verify delete permissions",
  "wouldLeaveNoAdmins",
  "Not a member",
  "NotAdmin",
  "CannotVerifyPermissions",
  "permission"
];
function Ks(i) {
  if (!i || !(i instanceof Error)) return !1;
  const A = (i.message || "").toLowerCase(), e = String(i);
  return ry.some(
    (t) => A.includes(t.toLowerCase()) || e.includes(t)
  );
}
async function Ys(i, A, e) {
  try {
    const t = await eA(i, { fromCoValue: A }, { returnType: "coId" });
    return t || null;
  } catch {
    return null;
  }
}
async function sy(i, A, e) {
  return e ? await ot(i, e, { context: { existing: A }, item: {} }) : i;
}
function gy(i, A) {
  if (!i || i.error) return null;
  const e = {};
  if (i.properties?.length) {
    for (const a of i.properties)
      if (a?.key !== void 0) {
        let I = a.value;
        if (typeof I == "string" && (I.startsWith("{") || I.startsWith("[")))
          try {
            I = JSON.parse(I);
          } catch {
          }
        e[a.key] = I;
      }
  } else Object.assign(e, i);
  const { id: t, loading: o, error: r, type: s, ...g } = e;
  if (g.definition) {
    const { id: a, type: I, ...C } = g.definition;
    return { ...C, $id: A };
  }
  return g.cotype || g.properties || g.items || g.title || g.description ? { ...g, $id: A } : null;
}
async function ny(i, A) {
  const { schema: e, key: t, keys: o, filter: r, options: s } = A;
  if (e && !e.startsWith("co_z") && !["@account", "@group", "@metaSchema"].includes(e))
    throw new Error(`[ReadOperation] Schema must be a co-id (co_z...) or special schema hint (@account, @group, @metaSchema), got: ${e}. Runtime code must use co-ids only, not '@maia/schema/...' patterns.`);
  if (o !== void 0 && !Array.isArray(o)) throw new Error("[ReadOperation] keys parameter must be an array of co-ids");
  if (t && o) throw new Error("[ReadOperation] Cannot provide both key and keys parameters");
  return await i.read(e, t, o, r, s);
}
async function ay(i, A, e) {
  const { schema: t, data: o, spark: r } = e;
  BA(t, "schema", "CreateOperation"), BA(o, "data", "CreateOperation"), JA(A, "CreateOperation", "runtime schema validation");
  const s = await eA(i, t, { returnType: "coId" });
  if (!s) throw new Error(`[CreateOperation] Could not resolve schema: ${t}`);
  const g = r != null ? { spark: r } : {}, n = await i.create(s, o, g);
  return bA(n, { op: "create" });
}
async function Iy(i, A, e, t) {
  const { id: o, data: r } = t;
  BA(o, "id", "UpdateOperation"), EA(o, "UpdateOperation"), BA(r, "data", "UpdateOperation"), JA(A, "UpdateOperation", "schema validation");
  const s = await i.getRawRecord(o);
  if (!s) throw new Error(`[UpdateOperation] Record not found: ${o}`);
  const n = await Ys(i, o) || s.$schema || null, { $schema: a, ...I } = s, C = await sy(r, I, e), c = await i.update(n, o, C);
  return bA(c, { op: "update" });
}
async function Cy(i, A, e) {
  const { id: t } = e;
  BA(t, "id", "DeleteOperation"), EA(t, "DeleteOperation"), JA(A, "DeleteOperation", "extract schema from CoValue headerMeta");
  const o = await Ys(A.backend, t), r = await i.delete(o, t);
  return bA(r, { op: "delete" });
}
async function cy(i, A) {
  const { configs: e, schemas: t, data: o } = A;
  if (!e) throw new Error("[SeedOperation] Configs required");
  if (!t) throw new Error("[SeedOperation] Schemas required");
  const r = await i.seed(e, t, o || {});
  return bA(r, { op: "seed" });
}
async function By(i, A, e) {
  const { coId: t, fromCoValue: o } = e, r = [t, o].filter(Boolean).length;
  if (r === 0) throw new Error("[SchemaOperation] One of coId or fromCoValue must be provided");
  if (r > 1) throw new Error("[SchemaOperation] Only one of coId or fromCoValue can be provided");
  let s = t ? (EA(t, "SchemaOperation"), t) : null;
  if (o && (EA(o, "SchemaOperation"), s = await eA(i, { fromCoValue: o }, { returnType: "coId" }), !s))
    return console.warn(`[SchemaOperation] Could not extract schema co-id from CoValue ${o} headerMeta`), new pA(null);
  const g = await i.read(null, s), n = new pA(null), a = (c) => n._set(gy(c, s)), I = g.subscribe(a);
  a(g.value);
  const C = n._unsubscribe;
  return n._unsubscribe = () => {
    C && C(), I();
  }, n;
}
async function Qy(i, A) {
  const { humanReadableKey: e } = A;
  if (BA(e, "humanReadableKey", "ResolveOperation"), typeof e != "string") throw new Error("[ResolveOperation] humanReadableKey must be a string");
  (MA(e) || e.startsWith("@actor/") || Xa(e)) && console.warn(`[ResolveOperation] resolve() called with human-readable key: ${e}. This should only be used during seeding. At runtime, all IDs should already be co-ids.`);
  const t = A.spark ?? i?.systemSpark;
  return await eA(i, e, { returnType: "coId", spark: t });
}
async function wg(i, A, e) {
  const { coId: t, item: o, items: r, cotype: s } = e;
  BA(t, "coId", "AppendOperation"), EA(t, "AppendOperation"), JA(A, "AppendOperation", "check schema cotype");
  const g = await tI(i, t, "AppendOperation"), n = await Ys(i, t);
  let a = s;
  if (!a) {
    const l = await bt(i, n, "colist"), d = await bt(i, n, "costream");
    if (l) a = "colist";
    else if (d) a = "costream";
    else throw new Error(`[AppendOperation] CoValue ${t} must be a CoList (colist) or CoStream (costream), got schema cotype: ${n}`);
  }
  if (!await bt(i, n, a)) throw new Error(`[AppendOperation] CoValue ${t} is not a ${a} (schema cotype check failed)`);
  const I = await eA(i, n, { returnType: "schema" });
  if (!I) throw new Error(`[AppendOperation] Schema ${n} not found`);
  const C = i.getCurrentContent(g), c = a === "colist" ? "append" : "push";
  if (!C || typeof C[c] != "function") throw new Error(`[AppendOperation] ${a === "colist" ? "CoList" : "CoStream"} ${t} doesn't have ${c} method`);
  const B = r || (o ? [o] : []);
  if (B.length === 0) throw new Error("[AppendOperation] At least one item required (use item or items parameter)");
  eI(I, B);
  let Q = 0;
  if (a === "colist") {
    let l = [];
    try {
      typeof C.toJSON == "function" && (l = C.toJSON() || []);
    } catch (d) {
      console.warn("[AppendOperation] Error checking existing items:", d);
    }
    for (const d of B)
      l.includes(d) || (C.append(d), Q++);
  } else
    for (const l of B) C.push(l), Q++;
  i.node?.storage && await i.node.syncManager.waitForStorageSync(t);
  const f = { coId: t, [a === "colist" ? "itemsAppended" : "itemsPushed"]: Q, ...a === "colist" && { itemsSkipped: B.length - Q } };
  return bA(f, { op: "append" });
}
async function Ey(i, A, e) {
  const { actorId: t, inboxCoId: o } = e;
  BA(t, "actorId", "ProcessInboxOperation"), BA(o, "inboxCoId", "ProcessInboxOperation"), EA(t, "ProcessInboxOperation"), EA(o, "ProcessInboxOperation");
  const { processInbox: r } = await Promise.resolve().then(() => Go);
  return await r(i, t, o);
}
async function ly(i, A, e) {
  const { name: t } = e;
  return BA(t, "name", "CreateSparkOperation"), JA(A, "CreateSparkOperation", "spark creation"), await i.createSpark(t);
}
async function uy(i, A) {
  const { id: e, schema: t } = A;
  if (e)
    return EA(e, "ReadSparkOperation"), await i.readSpark(e);
  const o = t || "@maia/schema/data/spark";
  return await i.readSpark(null, o);
}
async function dy(i, A, e) {
  const { id: t, data: o } = e;
  return BA(t, "id", "UpdateSparkOperation"), EA(t, "UpdateSparkOperation"), BA(o, "data", "UpdateSparkOperation"), JA(A, "UpdateSparkOperation", "spark update"), await i.updateSpark(t, o);
}
async function hy(i, A, e) {
  const { id: t } = e;
  return BA(t, "id", "DeleteSparkOperation"), EA(t, "DeleteSparkOperation"), JA(A, "DeleteSparkOperation", "spark deletion"), await i.deleteSpark(t);
}
async function at(i, A) {
  EA(A, "GetSparkGroup");
  const e = await hs(i, A, "guardian");
  if (!e || typeof e != "string" || !e.startsWith("co_z"))
    throw new Error(`[GetSparkGroup] Spark has no guardian in os.capabilities: ${A}`);
  const t = await i.getGroup(e);
  if (!t)
    throw new Error(`[GetSparkGroup] Group not found: ${e}`);
  return t;
}
async function fy(i, A, e) {
  const { id: t, memberId: o, role: r } = e;
  BA(t, "id", "AddSparkMemberOperation"), EA(t, "AddSparkMemberOperation"), BA(o, "memberId", "AddSparkMemberOperation"), EA(o, "AddSparkMemberOperation"), BA(r, "role", "AddSparkMemberOperation"), JA(A, "AddSparkMemberOperation", "spark member addition");
  const s = ["reader", "writer", "admin", "manager", "writeOnly"];
  if (!s.includes(r))
    throw new Error(`[AddSparkMemberOperation] Invalid role: ${r}. Must be one of: ${s.join(", ")}`);
  const g = await at(i, t);
  return await i.addGroupMember(g, o, r), {
    success: !0,
    sparkId: t,
    memberId: o,
    role: r
  };
}
async function wy(i, A, e) {
  const { id: t, memberId: o } = e;
  BA(t, "id", "RemoveSparkMemberOperation"), EA(t, "RemoveSparkMemberOperation"), BA(o, "memberId", "RemoveSparkMemberOperation"), EA(o, "RemoveSparkMemberOperation"), JA(A, "RemoveSparkMemberOperation", "spark member removal");
  const r = await at(i, t);
  return await i.removeGroupMember(r, o), {
    success: !0,
    sparkId: t,
    memberId: o
  };
}
async function py(i, A, e) {
  const { id: t, parentGroupId: o, role: r = "extend" } = e;
  BA(t, "id", "AddSparkParentGroupOperation"), EA(t, "AddSparkParentGroupOperation"), BA(o, "parentGroupId", "AddSparkParentGroupOperation"), EA(o, "AddSparkParentGroupOperation"), JA(A, "AddSparkParentGroupOperation", "spark parent group addition");
  const s = ["reader", "writer", "manager", "admin", "extend"];
  if (!s.includes(r))
    throw new Error(`[AddSparkParentGroupOperation] Invalid role: ${r}. Must be one of: ${s.join(", ")}`);
  const g = await at(i, t), n = await i.getGroup(o);
  if (!n)
    throw new Error(`[AddSparkParentGroupOperation] Parent group not found: ${o}`);
  return g.extend(n, r), {
    success: !0,
    sparkId: t,
    parentGroupId: o,
    role: r
  };
}
async function yy(i, A, e) {
  const { id: t, parentGroupId: o } = e;
  BA(t, "id", "RemoveSparkParentGroupOperation"), EA(t, "RemoveSparkParentGroupOperation"), BA(o, "parentGroupId", "RemoveSparkParentGroupOperation"), EA(o, "RemoveSparkParentGroupOperation"), JA(A, "RemoveSparkParentGroupOperation", "spark parent group removal");
  const r = await at(i, t), s = await i.getGroup(o);
  if (!s)
    throw new Error(`[RemoveSparkParentGroupOperation] Parent group not found: ${o}`);
  return r.revokeExtend(s), {
    success: !0,
    sparkId: t,
    parentGroupId: o
  };
}
async function Dy(i, A) {
  const { id: e } = A;
  BA(e, "id", "GetSparkMembersOperation"), EA(e, "GetSparkMembersOperation");
  const t = await at(i, e), o = i.getGroupInfoFromGroup(t);
  return {
    sparkId: e,
    groupId: t.id,
    members: o?.accountMembers || [],
    parentGroups: o?.groupMembers || []
  };
}
async function my(i, A, e) {
  const { id: t, memberId: o, role: r } = e;
  BA(t, "id", "UpdateSparkMemberRoleOperation"), EA(t, "UpdateSparkMemberRoleOperation"), BA(o, "memberId", "UpdateSparkMemberRoleOperation"), EA(o, "UpdateSparkMemberRoleOperation"), BA(r, "role", "UpdateSparkMemberRoleOperation"), JA(A, "UpdateSparkMemberRoleOperation", "spark member role update");
  const s = ["reader", "writer", "admin", "manager", "writeOnly"];
  if (!s.includes(r))
    throw new Error(`[UpdateSparkMemberRoleOperation] Invalid role: ${r}. Must be one of: ${s.join(", ")}`);
  const g = await at(i, t);
  return await i.setGroupMemberRole(g, o, r), {
    success: !0,
    sparkId: t,
    memberId: o,
    role: r
  };
}
class Bo {
  /**
   * Create a new DBEngine instance
   * @param {DBAdapter} backend - Backend adapter instance (must implement DBAdapter interface)
   * @param {Object} [options] - Optional configuration
   * @param {Object} [options.evaluator] - Optional MaiaScript evaluator for expression evaluation in updates
   */
  constructor(A, e = {}) {
    this.backend = A;
    const { evaluator: t } = e;
    A && typeof A.setDbEngine == "function" ? A.setDbEngine(this) : A && A.constructor.name === "CoJSONBackend" && (A.dbEngine = this), this.operations = {
      read: { execute: (o) => ny(this.backend, o) },
      create: { execute: (o) => ay(this.backend, this, o) },
      update: { execute: (o) => Iy(this.backend, this, t, o) },
      delete: { execute: (o) => Cy(this.backend, this, o) },
      seed: { execute: (o) => cy(this.backend, o) },
      schema: { execute: (o) => By(this.backend, this, o) },
      resolve: { execute: (o) => Qy(this.backend, o) },
      append: { execute: (o) => wg(this.backend, this, o) },
      push: { execute: (o) => wg(this.backend, this, { ...o, cotype: "costream" }) },
      processInbox: { execute: (o) => Ey(this.backend, this, o) },
      createSpark: { execute: (o) => ly(this.backend, this, o) },
      readSpark: { execute: (o) => uy(this.backend, o) },
      updateSpark: { execute: (o) => dy(this.backend, this, o) },
      deleteSpark: { execute: (o) => hy(this.backend, this, o) },
      addSparkMember: { execute: (o) => fy(this.backend, this, o) },
      removeSparkMember: { execute: (o) => wy(this.backend, this, o) },
      addSparkParentGroup: { execute: (o) => py(this.backend, this, o) },
      removeSparkParentGroup: { execute: (o) => yy(this.backend, this, o) },
      getSparkMembers: { execute: (o) => Dy(this.backend, o) },
      updateSparkMemberRole: { execute: (o) => my(this.backend, this, o) }
    };
  }
  /**
   * Execute a database operation
   * @param {Object} payload - Operation payload
   * @param {string} payload.op - Operation name (read, create, update, delete, seed)
   * @param {Object} payload params - Operation-specific parameters
   * @returns {Promise<any>} Operation result
   */
  async execute(A) {
    const { op: e, ...t } = A;
    if (!e)
      throw new Error('[DBEngine] Operation required: {op: "read|create|update|delete|seed|schema|resolve|append|push|createSpark|readSpark|updateSpark|deleteSpark|addSparkMember|removeSparkMember|addSparkParentGroup|removeSparkParentGroup|getSparkMembers|updateSparkMemberRole"}');
    if (e === "push")
      return await this.operations.append.execute({ ...t, cotype: "costream" });
    const o = this.operations[e];
    if (!o)
      throw new Error(`[DBEngine] Unknown operation: ${e}`);
    const r = /* @__PURE__ */ new Set(["create", "update", "delete", "append", "push", "seed"]);
    try {
      return await o.execute(t);
    } catch (s) {
      if (console.error(`[DBEngine] Operation ${e} failed:`, s), r.has(e)) {
        const g = [Ks(s) ? wA("permission", s.message) : wA("schema", s.message)];
        return fA(g, { op: e });
      }
      throw s;
    }
  }
  /**
   * Resolve a human-readable ID to a co-id
   * DEPRECATED: This method should only be used during seeding. At runtime, all IDs should already be co-ids.
   * @deprecated Use co-ids directly at runtime. This method is only for seeding/backward compatibility.
   * @param {string} humanReadableId - Human-readable ID (e.g., '@maia/vibe/todos', 'vibe/vibe')
   * @returns {Promise<string|null>} Co-id (co_z...) or null if not found
   */
}
class mI {
  /**
   * Read data from database
   * @param {string} schema - Schema co-id (co_z...)
   * @param {string} [key] - Specific key (co-id) for single item
   * @param {string[]} [keys] - Array of co-ids for batch reads
   * @param {Object} [filter] - Filter criteria for collection queries
   * @returns {Promise<ReactiveStore|ReactiveStore[]>} Reactive store(s) that hold current value and notify on updates
   */
  async read(A, e, t, o) {
    throw new Error("[DBAdapter] read() must be implemented by backend");
  }
  /**
   * Create new record
   * @param {string} schema - Schema co-id (co_z...) for data collections
   * @param {Object} data - Data to create
   * @returns {Promise<Object>} Created record with generated co-id
   */
  async create(A, e) {
    throw new Error("[DBAdapter] create() must be implemented by backend");
  }
  /**
   * Update existing record (unified for data collections and configs)
   * @param {string} schema - Schema co-id (co_z...) - MUST be a co-id, not '@maia/schema/...'
   * @param {string} id - Record co-id to update
   * @param {Object} data - Data to update
   * @returns {Promise<Object>} Updated record
   */
  async update(A, e, t) {
    throw new Error("[DBAdapter] update() must be implemented by backend");
  }
  /**
   * Delete record
   * @param {string} schema - Schema co-id (co_z...)
   * @param {string} id - Record co-id to delete
   * @returns {Promise<boolean>} true if deleted successfully
   */
  async delete(A, e) {
    throw new Error("[DBAdapter] delete() must be implemented by backend");
  }
  /**
   * Get raw record from database (without normalization)
   * Used for validation - returns stored data as-is (with $schema metadata, without id)
   * @param {string} id - Record co-id
   * @returns {Promise<Object|null>} Raw stored record or null if not found
   */
  async getRawRecord(A) {
    throw new Error("[DBAdapter] getRawRecord() must be implemented by backend");
  }
  /**
   * Seed database with configs, schemas, and initial data (optional - backend-specific)
   * @param {Object} configs - Config registry
   * @param {Object} schemas - Schema definitions
   * @param {Object} data - Initial application data
   * @returns {Promise<void>}
   */
  async seed(A, e, t) {
    throw new Error("[DBAdapter] seed() is optional - backend may not implement this");
  }
}
const pg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DBAdapter: mI,
  DBEngine: Bo,
  ReactiveStore: pA,
  createErrorEntry: wA,
  createErrorResult: fA,
  createSuccessResult: bA,
  isPermissionError: Ks,
  isSuccessResult: Ve
}, Symbol.toStringTag, { value: "Module" }));
async function SI(i, A, e, t) {
  const o = await aA(i, e, { waitForAvailable: !0 });
  if (!o)
    throw new Error(`[CoJSONBackend] CoValue not found: ${e}`);
  if (!i.isAvailable(o))
    throw new Error(`[CoJSONBackend] CoValue not available: ${e}`);
  const r = i.getCurrentContent(o), s = r?.type || "unknown";
  let g = null;
  try {
    g = await eA(i, { fromCoValue: e }, { returnType: "coId" });
  } catch (n) {
    console.log(`[Update] Skipping validation for ${e}: ${n.message}`);
  }
  if (g && i.dbEngine && g.startsWith("co_z")) {
    const { isExceptionSchema: n } = await Promise.resolve().then(() => Pt);
    if (!n(g)) {
      const a = await i.getRawRecord(e);
      if (a) {
        const { $schema: I, ...C } = a, c = { ...C, ...t };
        try {
          await Vt(
            i,
            g,
            c,
            `update for ${e}`,
            { dbEngine: i.dbEngine }
          );
        } catch (B) {
          throw new Error(`[Update] Validation failed: ${B.message}`);
        }
      }
    }
  }
  if (s === "comap" && r.set)
    for (const [n, a] of Object.entries(t))
      r.set(n, a);
  else
    throw new Error(`[CoJSONBackend] Update not supported for type: ${s}`);
  return Pa(i, o);
}
const NI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  update: SI
}, Symbol.toStringTag, { value: "Module" }));
function Us(i, A, e) {
  const t = A?.account && A.account.id === e, o = A?.account && A.account.get && A.account.get("profile") === e, r = i.header?.meta?.type === "account", g = i.header?.ruleset?.type === "group", n = A?.account && !i.header, a = t || r || n, I = g && !t && !r && !n, C = i.header?.meta?.$schema, c = C ? Je(C) : !1;
  return {
    isAccount: a,
    isGroup: I,
    isProfile: o,
    isException: c
  };
}
function Lr(i) {
  return !i || !i.header || !i.header.meta ? null : i.header.meta.$schema || null;
}
function Sy(i, A, e) {
  const t = Us(i, A, e);
  return t.isAccount || t.isGroup || t.isProfile || t.isException;
}
const _A = /* @__PURE__ */ new Set();
function Ny(i, A) {
  if (!i || !A)
    return i;
  const e = i.store.bind(i), t = new Proxy(i, {
    get(r, s) {
      if (s === "store")
        return function(n, a) {
          return o.call(r, n, a, e);
        };
      const g = r[s];
      return typeof g == "function" ? g.bind(r) : g;
    }
  });
  function o(r, s, g) {
    const n = r.id, a = Us(r, A, n);
    if (!a.isAccount && !a.isGroup && !a.isProfile) {
      if (!r.header || !r.header.meta)
        throw process.env.DEBUG && (r.header ? console.warn(`[StorageHook] Co-value ${n} has header but no meta. Header structure:`, {
          type: r.header.type,
          ruleset: r.header.ruleset,
          hasMeta: !!r.header.meta,
          headerKeys: Object.keys(r.header || {})
        }) : console.warn(`[StorageHook] Co-value ${n} has no header at all. Message structure:`, {
          id: r.id,
          hasHeader: !!r.header,
          messageKeys: Object.keys(r || {})
        })), console.error(`[StorageHook] REJECTING co-value ${n}: Missing header.meta. Every co-value MUST have headerMeta.$schema (except groups, accounts, and profiles during account creation).`), new Error(`[StorageHook] Co-value ${n} missing header.meta. Every co-value MUST have headerMeta.$schema (except groups, accounts, and profiles during account creation).`);
      if (!Lr(r) && !a.isException)
        throw console.error(`[StorageHook] REJECTING co-value ${n}: Missing $schema in headerMeta. Every co-value MUST have a schema (except @account, @group, @metaSchema, and groups/accounts).`), new Error(`[StorageHook] Co-value ${n} missing $schema in headerMeta. Every co-value MUST have a schema (except @account, @group, @metaSchema, and groups/accounts).`);
    }
    let I = Sy(r, A, n);
    if (I && Lr(r) === yA.META_SCHEMA && (I = !1), !I && A.account) {
      const c = A._cachedMaiaOsId;
      if (n === c)
        I = !0;
      else if (c) {
        const B = A.node.getCoValue(c);
        if (B && A.isAvailable(B) && B.type === "comap") {
          const Q = B.getCurrentContent?.();
          if (Q && typeof Q.get == "function") {
            const f = Q.get("schematas");
            n === f && (I = !0);
            const l = Q.get("unknown");
            n === l && (I = !0);
            const d = Q.get("indexes");
            if (n === d && (I = !0), d && !I) {
              const u = A.node.getCoValue(d);
              if (u && A.isAvailable(u) && u.type === "comap") {
                const h = u.getCurrentContent?.();
                if (h && typeof h.get == "function")
                  try {
                    const w = h.keys && typeof h.keys == "function" ? h.keys() : Object.keys(h);
                    for (const E of w)
                      if (h.get(E) === n) {
                        I = !0;
                        break;
                      }
                  } catch {
                    I = !0;
                  }
              }
            }
          }
        } else (!B || !A.isAvailable(B)) && (I = !0);
      }
    }
    const C = g(r, s);
    return I || Promise.resolve(C).then(async () => {
      if (!_A.has(n)) {
        _A.add(n);
        try {
          let c = A.getCoValue(n), B = 0;
          const Q = 5;
          for (; (!c || !A.isAvailable(c)) && B < Q; )
            A.node?.loadCoValueCore && await A.node.loadCoValueCore(n).catch(() => {
            }), await new Promise((u) => setTimeout(u, 10 * (B + 1))), c = A.getCoValue(n), B++;
          if (!c || !A.isAvailable(c))
            return;
          const f = A.getCoValue(n);
          if (!f || !A.isAvailable(f))
            return;
          if (await hI(A, f)) {
            setTimeout(() => {
              _A.has(n) && dI(A, f).then(() => {
                _A.delete(n);
              }).catch(() => {
                _A.delete(n);
              });
            }, 0);
            return;
          }
          const { shouldIndex: d } = await Fs(A, f);
          if (!d)
            return;
          setTimeout(() => {
            _A.has(n) && fI(A, f).then(() => {
              _A.delete(n);
            }).catch(() => {
              _A.delete(n);
            });
          }, 0);
        } catch {
          _A.delete(n);
        }
      }
    }).catch(() => {
      const c = r.id;
      _A.delete(c);
    }), C;
  }
  return t;
}
async function My(i, A) {
  try {
    const e = i.getCoValue(A);
    if (!e || !i.isAvailable(e))
      return null;
    const t = i.getCurrentContent(e);
    return t ? t && typeof t.toJSON == "function" ? t.toJSON() : t : null;
  } catch (e) {
    return console.warn(`[ValidationHook] Failed to extract content for ${A}:`, e), null;
  }
}
async function ky(i, A, e = 5e3) {
  const t = Date.now();
  for (; Date.now() - t < e; ) {
    try {
      const o = await eA(i, A, { returnType: "schema" });
      if (o)
        return o;
    } catch {
    }
    await new Promise((o) => setTimeout(o, 100));
  }
  return null;
}
async function Gy(i, A, e) {
  const t = e.id, o = Us(e, i, t);
  if (o.isGroup || o.isAccount || o.isProfile)
    return { valid: !0, error: null };
  const r = Lr(e);
  if (!r)
    return {
      valid: !1,
      error: `Co-value ${t} missing $schema in headerMeta. Every co-value MUST have a schema (except @account, @group, @maia, and groups/accounts).`
    };
  if (Je(r))
    return { valid: !0, error: null };
  if (!r.startsWith("co_z"))
    return {
      valid: !1,
      error: `Co-value ${t} has invalid schema format: ${r}. Schema must be a co-id (co_z...) or exception schema (@account, @group, @maia).`
    };
  let s = await eA(i, r, { returnType: "schema" });
  if (!s && (console.log(`[ValidationHook] Schema ${r} not available, waiting for sync...`), s = await ky(i, r, 5e3), !s))
    return {
      valid: !1,
      error: `Schema ${r} not available after timeout. Cannot validate remote transactions for ${t}.`
    };
  const g = await My(i, t);
  if (!g)
    return console.log(`[ValidationHook] Cannot extract content for ${t} (likely new co-value) - schema availability verified, allowing transactions`), { valid: !0, error: null };
  try {
    return await Vt(
      i,
      r,
      g,
      `remote sync for ${t}`,
      { dbEngine: A }
    ), { valid: !0, error: null };
  } catch (n) {
    return {
      valid: !1,
      error: `Validation failed for remote transactions: ${n.message}`
    };
  }
}
function Fy(i, A, e) {
  if (!i || !A)
    return i;
  const t = i.handleNewContent?.bind(i);
  return t && (i.handleNewContent = async function(o, r) {
    if (o && o.id && e) {
      const s = await Gy(A, e, o);
      if (!s.valid)
        throw console.error(`[ValidationHook] Rejecting remote transactions for ${o.id}: ${s.error}`), new Error(`[ValidationHook] Invalid remote transactions rejected: ${s.error}`);
    }
    return t(o, r);
  }), i;
}
class vs extends mI {
  constructor(A, e, t = null) {
    super();
    const o = t && typeof t == "object" && !t.backend && typeof t.execute != "function", r = o ? null : t, s = o ? t : {};
    this.node = A, this.account = e, this.dbEngine = r, this.systemSpark = s.systemSpark ?? "@maia", this.subscriptionCache = Va(A), A.storage && (A.storage = Ny(A.storage, this)), A.syncManager && r && Fy(A.syncManager, this, r);
  }
  /**
   * Reset all subscription-related caches
   * 
   * Called when new backend is created to clear stale subscriptions from previous session.
   */
  _resetCaches() {
  }
  /**
   * Get a CoValue by ID
   * @param {string} coId - CoValue ID
   * @returns {CoValueCore|null} CoValueCore or null if not found
   */
  getCoValue(A) {
    return this.node.getCoValue(A);
  }
  /**
   * Get all CoValues from the node
   * @returns {Map<string, CoValueCore>} Map of CoValue IDs to CoValueCore instances
   */
  getAllCoValues() {
    return this.node.coValues || /* @__PURE__ */ new Map();
  }
  /**
   * Check if CoValue is available (has verified state)
   * @param {CoValueCore} coValueCore - CoValueCore instance
   * @returns {boolean} True if available
   */
  isAvailable(A) {
    return A?.isAvailable() || !1;
  }
  /**
   * Get current content from CoValueCore
   * @param {CoValueCore} coValueCore - CoValueCore instance
   * @returns {RawCoValue|null} Current content or null
   */
  getCurrentContent(A) {
    return !A || !A.isAvailable() ? null : A.getCurrentContent();
  }
  /**
   * Get header from CoValueCore
   * @param {CoValueCore} coValueCore - CoValueCore instance
   * @returns {Object|null} Header object or null
   */
  getHeader(A) {
    return A?.verified?.header || null;
  }
  /**
   * Get account (for create operations)
   * @returns {RawAccount} Account CoMap
   */
  getAccount() {
    return this.account;
  }
  /**
   * Get current session ID from the node
   * @returns {string|null} Current session ID or null if node not available
   */
  getCurrentSessionID() {
    return !this.node || !this.node.currentSessionID ? null : this.node.currentSessionID;
  }
  /**
   * Read inbox CoStream with session structure and CRDT metadata preserved
   * Backend-to-backend method for inbox processing
   * @param {string} inboxCoId - Inbox CoStream co-id
   * @returns {Object|null} CoStream data with sessions and CRDT metadata, or null if not found/not a CoStream
   */
  readInboxWithSessions(A) {
    const e = this.getCoValue(A);
    return !e || !this.isAvailable(e) ? null : gQ(this, e);
  }
  /**
   * Get @maia spark's group (for create operations)
   * @returns {Promise<RawGroup|null>} @maia spark's group
   */
  async getMaiaGroup() {
    return Mo(this);
  }
  /**
   * Get group information for a CoValue
   * Extracts owner group, account members, and group members with roles
   * @param {CoValueCore} coValueCore - CoValueCore instance
   * @returns {Object|null} Group info object or null if no group found
   */
  getGroupInfo(A) {
    if (!A || !this.isAvailable(A))
      return null;
    try {
      const e = this.getHeader(A), t = this.getCurrentContent(A), o = A.ruleset || e?.ruleset;
      if (!o)
        return null;
      let r = null, s = null, g = null;
      if (o.type === "group")
        r = A.id, s = A, g = t;
      else if (o.type === "ownedByGroup" && o.group)
        r = o.group, s = this.getCoValue(r), s && this.isAvailable(s) && (g = this.getCurrentContent(s));
      else if (t && t.group) {
        const a = t.group;
        r = typeof a == "string" ? a : a.id || a.$jazz && a.$jazz.id, r && (s = this.getCoValue(r), s && this.isAvailable(s) && (g = this.getCurrentContent(s)));
      } else
        return null;
      if (!g || typeof g.addMember != "function")
        return null;
      const n = br(g);
      return n && r && (n.groupId = r), n;
    } catch (e) {
      return console.warn("[CoJSONBackend] Error getting group info:", e), null;
    }
  }
  /**
   * Get a Group CoValue by ID
   * @param {string} groupId - Group CoValue ID
   * @returns {Promise<RawGroup|null>} Group CoValue or null if not found
   */
  async getGroup(A) {
    return await sI(this.node, A);
  }
  /**
   * Get group info from a RawGroup
   * @param {RawGroup} group - RawGroup instance
   * @returns {Object|null} Group info object
   */
  getGroupInfoFromGroup(A) {
    return br(A);
  }
  /**
   * Add a member to a group
   * @param {RawGroup} group - Group CoValue
   * @param {string} memberId - Member ID (account or group Co-ID)
   * @param {string} role - Role name
   * @returns {Promise<void>}
   */
  async addGroupMember(A, e, t) {
    return await ys(this.node, A, e, t, this);
  }
  /**
   * Remove a member from a group
   * @param {RawGroup} group - Group CoValue
   * @param {string} memberId - Member ID to remove
   * @returns {Promise<void>}
   */
  async removeGroupMember(A, e) {
    return await Ds(A, e);
  }
  /**
   * Set a member's role in a group
   * @param {RawGroup} group - Group CoValue
   * @param {string} memberId - Member ID
   * @param {string} role - New role name
   * @returns {Promise<void>}
   */
  async setGroupMemberRole(A, e, t) {
    return await CI(this.node, A, e, t);
  }
  // ============================================================================
  // Spark Operations (Group References)
  // ============================================================================
  /**
   * Create a new Spark (CoMap that references a group)
   * Creates a child group owned by @maia spark's group, then creates Spark CoMap
   * @param {string} name - Spark name
   * @returns {Promise<Object>} Created spark with co-id
   */
  async createSpark(A) {
    if (!this.account)
      throw new Error("[CoJSONBackend] Account required for createSpark");
    const e = await this.getMaiaGroup();
    if (!e)
      throw new Error("[CoJSONBackend] @maia spark group not found");
    const { createChildGroup: t } = await Promise.resolve().then(() => oy), o = t(this.node, e, { name: A }), r = await eA(this, "@maia/schema/data/spark", { returnType: "coId" }), s = await eA(this, "@maia/schema/os/capabilities", { returnType: "coId" }), g = await eA(this, "@maia/schema/os/os-registry", { returnType: "coId" }), n = await eA(this, "@maia/schema/os/vibes-registry", { returnType: "coId" });
    if (!r || !s || !g || !n)
      throw new Error("[CoJSONBackend] Spark scaffold schemas not found");
    const a = { node: this.node, account: this.account, guardian: o }, { createCoValueForSpark: I } = await Promise.resolve().then(() => Re), { coValue: C } = await I(a, null, {
      schema: s,
      cotype: "comap",
      data: { guardian: o.id },
      dbEngine: this.dbEngine
    }), { coValue: c } = await I(a, null, {
      schema: g,
      cotype: "comap",
      data: { capabilities: C.id },
      dbEngine: this.dbEngine
    }), { coValue: B } = await I(a, null, {
      schema: n,
      cotype: "comap",
      data: {},
      dbEngine: this.dbEngine
    }), { coValue: Q } = await I(a, null, {
      schema: r,
      cotype: "comap",
      data: { name: A, os: c.id, vibes: B.id },
      dbEngine: this.dbEngine
    });
    return await this._registerSparkInAccount(Q.id), {
      id: Q.id,
      name: A,
      guardian: o.id
    };
  }
  /**
   * Read Spark(s)
   * @param {string} [id] - Specific spark co-id
   * @param {string} [schema] - Schema co-id (optional)
   * @returns {Promise<ReactiveStore|ReactiveStore[]>} Reactive store(s) with spark data
   */
  async readSpark(A, e = null) {
    if (A)
      return await this.read(null, A);
    const t = e || "@maia/schema/data/spark", o = await eA(this, t, { returnType: "coId" });
    if (!o)
      throw new Error(`[CoJSONBackend] Spark schema not found: ${t}`);
    return await this.read(o);
  }
  /**
   * Update Spark
   * @param {string} id - Spark co-id
   * @param {Object} data - Update data (name only; group is resolved via os.capabilities.guardian)
   * @returns {Promise<Object>} Updated spark
   */
  async updateSpark(A, e) {
    const { group: t, ...o } = e || {}, r = await eA(this, { fromCoValue: A }, { returnType: "coId" });
    return await this.update(r, A, o);
  }
  /**
   * Delete Spark
   * Removes spark from account.sparks and deletes Spark CoMap
   * @param {string} id - Spark co-id
   * @returns {Promise<Object>} Deletion result
   */
  async deleteSpark(A) {
    const e = await eA(this, { fromCoValue: A }, { returnType: "coId" });
    return await this.delete(e, A), await this._unregisterSparkFromAccount(A), { success: !0, id: A };
  }
  /**
   * Register spark in account.sparks CoMap
   * Stores spark keyed by co-id: account.sparks[sparkCoId] = sparkCoId
   * Uses read() + waitForStoreReady (proper $store architecture)
   * @private
   * @param {string} sparkCoId - Spark co-id (key and value)
   */
  async _registerSparkInAccount(A) {
    let e = this.account.get("sparks"), t;
    if (e) {
      const o = await IA(this, e, null, null, null, { deepResolve: !1 });
      await uA(o, e, 15e3);
      const r = this.node.getCoValue(e);
      r && this.isAvailable(r) && (t = this.getCurrentContent(r));
    }
    if (!t && !e) {
      const r = await eA(this, "@maia/schema/os/sparks-registry", { returnType: "coId" }) || yA.META_SCHEMA, { createCoValueForSpark: s } = await Promise.resolve().then(() => Re), { coValue: g } = await s(this, "@maia", {
        schema: r,
        cotype: "comap",
        data: {},
        dbEngine: this.dbEngine
      });
      t = g, this.account.set("sparks", t.id);
    }
    if (!t || typeof t.set != "function")
      throw new Error(`[_registerSparkInAccount] account.sparks not available. sparksId=${e || "null"}`);
    t.set(A, A);
  }
  /**
   * Unregister spark from account.sparks CoMap
   * Uses read() + waitForStoreReady (proper $store architecture)
   * @private
   * @param {string} sparkCoId - Spark co-id (key)
   */
  async _unregisterSparkFromAccount(A) {
    const e = this.account.get("sparks");
    if (e)
      try {
        const t = await IA(this, e, null, null, null, { deepResolve: !1 });
        await uA(t, e, 5e3);
        const o = this.node.getCoValue(e);
        if (!o || !this.isAvailable(o)) return;
        const r = this.getCurrentContent(o);
        r && typeof r.delete == "function" && r.delete(A);
      } catch {
      }
  }
  // ============================================================================
  // DBAdapter Interface Implementation
  // ============================================================================
  /**
   * Read data from database - directly translates to CoJSON raw operations
   * @param {string} schema - Schema co-id (co_z...) or special exceptions:
   *   - '@group' - For groups (no $schema, use ruleset.type === 'group')
   *   - '@account' - For accounts (no $schema, use headerMeta.type === 'account')
   *   - '@metaSchema' - For meta schema
   * @param {string} [key] - Specific key (co-id) for single item
   * @param {string[]} [keys] - Array of co-ids for batch reads
   * @param {Object} [filter] - Filter criteria for collection queries
   * @param {Object} [options] - Options for deep resolution
   * @param {boolean} [options.deepResolve=true] - Enable/disable deep resolution (default: true)
   * @param {number} [options.maxDepth=10] - Maximum depth for recursive resolution (default: 10)
   * @param {number} [options.timeoutMs=5000] - Timeout for waiting for nested CoValues (default: 5000)
   * @param {Object} [options.resolveReferences] - Configuration for resolving CoValue references (e.g., { fields: ['source', 'target'] })
   * @param {Object} [options.map] - Map transformation config (e.g., { sender: '$$source.role', recipient: '$$target.role' })
   * @returns {Promise<ReactiveStore|ReactiveStore[]>} Reactive store(s) that hold current value and notify on updates
   */
  async read(A, e, t, o, r = {}) {
    const {
      deepResolve: s = !0,
      maxDepth: g = 15,
      // TODO: temporarily scaled up from 10 for @maia spark detail deep resolution
      timeoutMs: n = 5e3,
      resolveReferences: a = null,
      map: I = null,
      onChange: C = null
    } = r, c = { deepResolve: s, maxDepth: g, timeoutMs: n, resolveReferences: a, map: I, onChange: C };
    return t && Array.isArray(t) ? await Promise.all(t.map((Q) => IA(this, Q, A, null, A, c))) : e ? await IA(this, e, A, null, A, c) : A ? await IA(this, null, A, o, null, c) : await IA(this, null, null, o, null, c);
  }
  /**
   * Create new record - directly creates CoValue using CoJSON raw methods
   * @param {string} schema - Schema co-id (co_z...) for data collections
   * @param {Object} data - Data to create
   * @param {Object} [options] - Optional settings
   * @param {string} [options.spark='@maia'] - Spark name for context (e.g. '@maia', '@Maia')
   * @returns {Promise<Object>} Created record with generated co-id
   */
  async create(A, e, t = {}) {
    return await ms(this, A, e, t);
  }
  /**
   * Update existing record - directly updates CoValue using CoJSON raw methods
   * @param {string} schema - Schema co-id (co_z...)
   * @param {string} id - Record co-id to update
   * @param {Object} data - Data to update
   * @returns {Promise<Object>} Updated record
   */
  async update(A, e, t) {
    return await SI(this, A, e, t);
  }
  /**
   * Delete record - hard delete using CoJSON native operations
   * Removes item from CoList (hard delete) and clears CoMap content
   * @param {string} schema - Schema co-id (co_z...)
   * @param {string} id - Record co-id to delete
   * @returns {Promise<boolean>} true if deleted successfully
   */
  async delete(A, e) {
    return await so(this, A, e);
  }
  /**
   * Get raw record from database (without normalization)
   * Used for validation - returns stored data as-is (with $schema metadata, without id)
   * @param {string} id - Record co-id
   * @returns {Promise<Object|null>} Raw stored record or null if not found
   */
  async getRawRecord(A) {
    const e = this.getCoValue(A);
    if (!e || !this.isAvailable(e))
      return null;
    const t = this.getCurrentContent(e), s = (this.getHeader(e)?.meta || null)?.$schema || null;
    if (t && t.get && typeof t.get == "function") {
      const g = {
        $schema: s
        // Metadata for querying/validation
      }, n = t.keys && typeof t.keys == "function" ? t.keys() : Object.keys(t);
      for (const a of n)
        g[a] = t.get && typeof t.get == "function" ? t.get(a) : t[a];
      return g;
    }
    if (t && t.toJSON)
      try {
        return t.toJSON();
      } catch {
        return null;
      }
    return null;
  }
  /**
   * Seed database with configs, schemas, and initial data
   * @param {Object} configs - Config registry {vibe, styles, actors, views, contexts, states, interfaces}
   * @param {Object} schemas - Schema definitions
   * @param {Object} data - Initial application data {todos: [], ...}
   * @returns {Promise<Object>} Summary of what was seeded
   */
  async seed(A, e, t) {
    if (!this.account)
      throw new Error("[CoJSONBackend] Account required for seed");
    return await Jp(this.account, this.node, A, e, t || {}, this);
  }
  /**
   * Ensure spark.os (account.sparks[@maia].os) is loaded and ready for schema-dependent operations
   * 
   * Progressive loading: spark.os is NOT required for account loading itself
   * It's only needed for schema resolution, which can happen progressively as spark.os becomes available
   * 
   * This function is called non-blocking during boot - MaiaOS boots immediately without waiting
   * Schema resolution will return null until spark.os is ready, then progressively start working
   * 
   * @param {Object} [options] - Options
   * @param {number} [options.timeoutMs=10000] - Timeout for waiting for spark.os to be ready
   * @returns {Promise<boolean>} True if spark.os is ready, false if failed
   */
  async ensureAccountOsReady(A = {}) {
    const { timeoutMs: e = 1e4 } = A;
    if (!this.account)
      return process.env.DEBUG && console.warn("[CoJSONBackend.ensureAccountOsReady] Account not available"), !1;
    let t = await KA(this, "@maia");
    if (!t || typeof t != "string" || !t.startsWith("co_z"))
      return process.env.DEBUG && console.warn("[CoJSONBackend.ensureAccountOsReady] @maia spark.os not found - migration should have created it"), !1;
    const o = await IA(this, t, null, null, null, {
      deepResolve: !1,
      timeoutMs: e
    });
    try {
      await uA(o, t, e);
    } catch (a) {
      return process.env.DEBUG && console.error(`[CoJSONBackend.ensureAccountOsReady] Timeout waiting for spark.os to load: ${a.message}`), !1;
    }
    const r = o.value;
    if (!r || r.error)
      return process.env.DEBUG && console.error("[CoJSONBackend.ensureAccountOsReady] spark.os data not available or has error"), !1;
    let s = r.schematas;
    if (!s || typeof s != "string" || !s.startsWith("co_z")) {
      const a = this.getCoValue(t);
      if (!a || !a.isAvailable())
        return process.env.DEBUG && console.error("[CoJSONBackend.ensureAccountOsReady] spark.os not available for creating schematas"), !1;
      const I = this.getCurrentContent(a);
      if (!I || typeof I.set != "function")
        return process.env.DEBUG && console.error("[CoJSONBackend.ensureAccountOsReady] spark.os content not available for creating schematas"), !1;
      const c = await eA(this, "@maia/schema/os/schematas-registry", { returnType: "coId" }) || yA.META_SCHEMA, { createCoValueForSpark: B } = await Promise.resolve().then(() => Re), { coValue: Q } = await B(this, "@maia", {
        schema: c,
        cotype: "comap",
        data: {},
        dbEngine: this.dbEngine
      });
      I.set("schematas", Q.id), s = Q.id;
      const f = await IA(this, t, null, null, null, {
        deepResolve: !1,
        timeoutMs: 2e3
      });
      try {
        await uA(f, t, 2e3);
        const l = f.value;
        l && !l.error && (s = l.schematas || s);
      } catch {
      }
    }
    if (!s || typeof s != "string" || !s.startsWith("co_z"))
      return process.env.DEBUG && console.error("[CoJSONBackend.ensureAccountOsReady] Failed to ensure schematas registry exists"), !1;
    const g = await IA(this, s, null, null, null, {
      deepResolve: !1,
      timeoutMs: e
    });
    try {
      await uA(g, s, e);
    } catch (a) {
      return process.env.DEBUG && console.error(`[CoJSONBackend.ensureAccountOsReady] Timeout waiting for schematas registry to load: ${a.message}`), !1;
    }
    const n = g.value;
    return !n || n.error ? (process.env.DEBUG && console.error("[CoJSONBackend.ensureAccountOsReady] schematas registry data not available or has error"), !1) : !0;
  }
}
const xr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CoJSONBackend: vs
}, Symbol.toStringTag, { value: "Module" }));
function Ry(i, A) {
  if (!i)
    throw new Error("[createCoJSONAPI] Node required");
  if (!A)
    throw new Error("[createCoJSONAPI] Account required");
  const e = new vs(i, A, { systemSpark: "@maia" }), t = new Bo(e);
  return e.dbEngine = t, {
    /**
     * Execute a database operation
     * @param {Object} payload - Operation payload
     * @param {string} payload.op - Operation name (read, create, update, delete)
     * @param {Object} payload params - Operation-specific parameters
     * @returns {Promise<any>} Operation result
     */
    cojson: async (o) => await t.execute(o)
  };
}
async function Or(i, A, e) {
  if (!i)
    throw new Error("[createAndPushMessage] dbEngine is required");
  if (!A || !A.startsWith("co_z"))
    throw new Error(`[createAndPushMessage] inboxCoId must be a valid co-id (co_z...), got: ${A}`);
  if (!e || typeof e != "object")
    throw new Error("[createAndPushMessage] messageData must be an object");
  let t = null;
  try {
    const C = (await i.execute({
      op: "schema",
      fromCoValue: A
    })).value;
    if (C && C.items && C.items.$co) {
      const c = C.items.$co;
      if (c.startsWith("co_z"))
        t = c;
      else if (c.startsWith("@maia/schema/")) {
        const B = c.replace("@maia/schema/", ""), f = (await i.execute({
          op: "schema",
          schemaName: B
        })).value;
        f && f.$id && (t = f.$id);
      }
    }
    if (t || (t = await i.execute({
      op: "resolve",
      humanReadableKey: "@maia/schema/message"
    })), !t || !t.startsWith("co_z"))
      throw new Error(`[createAndPushMessage] Failed to get message schema co-id. Inbox schema items.$co: ${C?.items?.$co || "not found"}`);
  } catch (I) {
    throw new Error(`[createAndPushMessage] Failed to get message schema co-id: ${I.message}`);
  }
  if (!await eA(i.backend, t, { returnType: "schema" }))
    throw new Error(`[createAndPushMessage] Message schema not found: ${t}`);
  const r = {
    processed: !1,
    ...e
  };
  if (r.payload && rt(r.payload))
    throw new Error(`[createAndPushMessage] Payload contains unresolved expressions. Only resolved values can be persisted to CoJSON. Payload: ${JSON.stringify(r.payload).substring(0, 200)}`);
  const s = await i.execute({
    op: "create",
    schema: t,
    data: r
  });
  if (!s.ok) {
    const I = s.errors?.map((C) => C.message).join("; ") || "Create failed";
    throw new Error(`[createAndPushMessage] Failed to create message: ${I}`);
  }
  const g = s.data;
  if (!g || !g.id)
    throw new Error("[createAndPushMessage] Failed to create message CoMap - create operation returned no id");
  const n = g.id;
  if (!n.startsWith("co_z"))
    throw new Error(`[createAndPushMessage] Invalid message co-id returned: ${n}`);
  const a = await i.execute({
    op: "push",
    coId: A,
    item: n
  });
  if (!a.ok) {
    const I = a.errors?.map((C) => C.message).join("; ") || "Push failed";
    throw new Error(`[createAndPushMessage] Failed to push message to inbox: ${I}`);
  }
  return n;
}
async function by(i, A, e) {
  if (!i || !A || !e)
    throw new Error("[processInbox] backend, actorId, and inboxCoId are required");
  if (!i.getCurrentSessionID())
    throw new Error("[processInbox] Cannot get current session ID from backend");
  const o = i.dbEngine;
  if (!o)
    throw new Error("[processInbox] Backend must have dbEngine set");
  let r = null;
  try {
    const a = (await o.execute({
      op: "schema",
      fromCoValue: e
    })).value;
    if (a && a.items && a.items.$co) {
      const I = a.items.$co;
      if (I.startsWith("co_z"))
        r = I;
      else if (I.startsWith("@maia/schema/")) {
        const C = I.replace("@maia/schema/", ""), B = (await o.execute({
          op: "schema",
          schemaName: C
        })).value;
        B && B.$id ? r = B.$id : console.warn(`[processInbox] Failed to resolve message schema reference ${I}`);
      } else
        console.warn(`[processInbox] Unknown message schema reference format: ${I}`);
    }
  } catch (n) {
    console.warn("[processInbox] Failed to get message schema:", n);
  }
  const s = i.readInboxWithSessions(e);
  if (!s || !s.sessions)
    return { messages: [] };
  const g = [];
  for (const [n, a] of Object.entries(s.sessions))
    for (const I of a) {
      if (I.type === "INIT" || I.from === "system")
        continue;
      const c = I._madeAt || 0, B = I._coId;
      if (!B) {
        console.error(
          `[processInbox]  REJECTED legacy plain object message in inbox ${e}. All messages must be CoMap references (co-id strings). Message data: ${JSON.stringify(I).substring(0, 200)}`
        );
        continue;
      }
      try {
        const Q = await IA(i, B, r);
        try {
          await uA(Q, B, 2e3);
        } catch (d) {
          console.warn(`[processInbox] Message CoMap not available: ${B} - ${d.message}`);
          continue;
        }
        const f = Q.value;
        if (!f || f.error) {
          console.warn(`[processInbox] Message CoMap error: ${B} - ${f?.error || "unknown error"}`);
          continue;
        }
        if (!(f.processed === !0)) {
          try {
            const h = await o.execute({
              op: "update",
              schema: r,
              id: B,
              data: { processed: !0 }
            });
            if (!h.ok)
              throw new Error(h.errors?.map((w) => w.message).join("; ") || "Update failed");
            try {
              const w = await IA(i, B, r);
              await uA(w, B, 1e3);
              const E = w.value;
              E && E.processed !== !0 && console.warn(`[processInbox] Update verification failed for ${B} - processed flag is still false`);
            } catch (w) {
              console.warn(`[processInbox] Update verification failed for ${B}:`, w.message);
            }
          } catch (h) {
            console.error(`[processInbox] Failed to mark message ${B} as processed:`, h);
          }
          const d = {}, u = Object.keys(f);
          for (const h of u)
            h !== "processed" && !h.startsWith("_") && h !== "id" && h !== "$schema" && h !== "hasProperties" && h !== "properties" && (d[h] = f[h]);
          if (!d.type) {
            console.error(
              `[processInbox]  REJECTED message ${B} - missing required 'type' field. Keys found: [${u.join(", ")}]. All values: ${JSON.stringify(f).substring(0, 300)}`
            );
            continue;
          }
          g.push({
            ...d,
            _coId: B,
            // Keep co-id for reference
            _sessionID: n,
            _madeAt: c
          });
        }
      } catch (Q) {
        console.error(`[processInbox] Failed to read message CoMap ${B}:`, Q);
      }
    }
  return g.sort((n, a) => (n._madeAt || 0) - (a._madeAt || 0)), {
    messages: g
  };
}
const Ky = 1e5, Yy = 10;
function Nt(i) {
  return i.readyState === 1;
}
function Tr(i) {
  return i.bufferedAmount > Ky && Nt(i);
}
function Uy(i) {
  return new Promise((A) => {
    i.readyState === 1 ? A() : i.addEventListener("open", () => A(), { once: !0 });
  });
}
async function vy(i) {
  for (; Tr(i); )
    await new Promise((A) => setTimeout(A, Yy));
}
const { CO_VALUE_PRIORITY: Jy, getContentMessageSize: Hy, WEBSOCKET_CONFIG: yg } = Is;
class qy {
  constructor(A, e, t, o, r) {
    this.websocket = A, this.batching = e, this.meta = o, this.backlog = [], this.processing = !1, this.closed = !1, this.closeListeners = /* @__PURE__ */ new Set(), this.egressBytesCounter = (r ?? ae.getMeter("cojson-transport-ws")).createCounter("jazz.usage.egress", {
      description: "Total egress bytes",
      unit: "bytes",
      valueType: WA.INT
    }), this.queue = new bB(Jy.HIGH, "outgoing", {
      peerRole: t
    }), this.egressBytesCounter.add(0, this.meta);
  }
  push(A) {
    if (A === "Disconnected") {
      this.close();
      return;
    }
    if (!this.closed) {
      if (this.processing) {
        this.queue.push(A);
        return;
      }
      if (Nt(this.websocket) && !Tr(this.websocket)) {
        this.processMessage(A, !0);
        return;
      }
      this.queue.push(A), this.processQueue().catch((e) => {
        AA.error("Error while processing sendMessage queue", { err: e });
      });
    }
  }
  async processQueue() {
    const { websocket: A } = this;
    this.processing = !0;
    let e = this.queue.pull();
    for (; e; ) {
      if (this.closed)
        return;
      Nt(A) || await Uy(A), Tr(A) && await vy(A), Nt(A) && (this.processMessage(e), e = this.queue.pull());
    }
    this.sendMessagesInBulk(), this.processing = !1;
  }
  processMessage(A, e = !1) {
    A.action === "content" && this.egressBytesCounter.add(Hy(A), this.meta);
    const t = this.serializeMessage(A);
    if (!this.batching || e) {
      this.websocket.send(t);
      return;
    }
    const o = t.length, r = this.backlog.length + o;
    this.backlog.length > 0 && r > yg.MAX_OUTGOING_MESSAGES_CHUNK_BYTES && this.sendMessagesInBulk(), this.appendMessage(t), o >= yg.MAX_OUTGOING_MESSAGES_CHUNK_BYTES && this.sendMessagesInBulk();
  }
  serializeMessage(A) {
    return JSON.stringify(A);
  }
  appendMessage(A) {
    this.backlog.push(A);
  }
  sendMessagesInBulk() {
    this.backlog.length > 0 && Nt(this.websocket) && (this.websocket.send(this.backlog.join(`
`)), this.backlog.length = 0);
  }
  drain() {
    for (; this.queue.pull(); )
      ;
  }
  setBatching(A) {
    this.batching = A;
  }
  onClose(A) {
    this.closeListeners.add(A);
  }
  close() {
    if (this.closed)
      return;
    let A = this.queue.pull();
    for (; A; )
      this.processMessage(A), A = this.queue.pull();
    this.closed = !0, this.sendMessagesInBulk();
    for (const e of this.closeListeners)
      e();
    this.closeListeners.clear();
  }
}
function Ly(i) {
  if (typeof i != "string")
    return {
      ok: !1,
      error: new Error("Expected a string")
    };
  try {
    return {
      ok: !0,
      messages: i.split(`
`).map((A) => JSON.parse(A))
    };
  } catch (A) {
    return AA.error("Error while deserializing messages", { err: A }), {
      ok: !1,
      error: A
    };
  }
}
const { ConnectedPeerChannel: xy, getContentMessageSize: Oy } = Is;
function Ty(i, A, e) {
  if (!i)
    return {
      reset() {
      },
      clear() {
      }
    };
  let t = null;
  return {
    reset() {
      t && clearTimeout(t), t = setTimeout(() => {
        e();
      }, A);
    },
    clear() {
      t && clearTimeout(t);
    }
  };
}
function Py(i = () => {
}) {
  let A = !1;
  return () => {
    A || (A = !0, i());
  };
}
function jy({ id: i, websocket: A, role: e, expectPings: t = !0, batchingByDefault: o = !0, deletePeerStateOnClose: r = !1, pingTimeout: s = 1e4, onSuccess: g, onClose: n, meter: a, meta: I }) {
  const C = (a ?? ae.getMeter("cojson-transport-ws")).createCounter("jazz.usage.ingress", {
    description: "Total ingress bytes from peer",
    unit: "bytes",
    valueType: WA.INT
  });
  C.add(0, I);
  const c = new xy(), B = Py(n);
  function Q() {
    A.removeEventListener("message", w), A.removeEventListener("close", f), A.removeEventListener("error", l), d.clear(), u.drain();
  }
  function f() {
    c.push("Disconnected"), B(), Q();
  }
  function l(E) {
    E instanceof Error && E.message && AA.warn("WebSocket error", { err: E }), f();
  }
  A.addEventListener("close", f), A.addEventListener("error", l);
  const d = Ty(t, s, () => {
    f(), AA.warn("Ping timeout from peer", {
      peerId: i,
      peerRole: e
    });
  }), u = new qy(A, o, e, I, a);
  let h = !0;
  function w(E) {
    if (d.reset(), E.data === "")
      return;
    const p = Ly(E.data);
    if (!p.ok) {
      AA.warn("Error while deserializing messages", { err: p.error });
      return;
    }
    h && (g?.(), h = !1);
    const { messages: y } = p;
    y.length > 1 && u.setBatching(!0);
    for (const m of y)
      m && "action" in m && (c.push(m), m.action === "content" && C.add(Oy(m), I));
  }
  return A.addEventListener("message", w), u.onClose(() => {
    Q(), B(), A.readyState === 0 ? A.addEventListener("open", function() {
      A.close();
    }, { once: !0 }) : A.readyState === 1 && A.close();
  }), {
    id: i,
    incoming: c,
    outgoing: u,
    role: e,
    persistent: !r
  };
}
class Vy {
  constructor(A) {
    this.enabled = !1, this.closed = !0, this.connected = !1, this.currentPeer = void 0, this.unsubscribeNetworkChange = void 0, this.reconnectionAttempts = 0, this.onConnectionChangeListeners = /* @__PURE__ */ new Set(), this.waitUntilConnected = async () => {
      if (this.closed)
        return new Promise((e) => {
          const t = (o) => {
            o && (e(), this.onConnectionChangeListeners.delete(t));
          };
          this.onConnectionChangeListeners.add(t);
        });
    }, this.subscribe = (e) => {
      this.onConnectionChangeListeners.add(e), e(!this.closed);
    }, this.unsubscribe = (e) => {
      this.onConnectionChangeListeners.delete(e);
    }, this.startConnection = async () => {
      if (this.enabled) {
        if (this.currentPeer) {
          this.removePeer(this.currentPeer), this.currentPeer.outgoing.close(), this.reconnectionAttempts++;
          const e = this.reconnectionTimeout * this.reconnectionAttempts;
          AA.debug(`Websocket disconnected, trying to reconnect in ${e}ms`), await this.waitForOnline(e);
        }
        this.enabled && (this.currentPeer = jy({
          websocket: new this.WebSocketConstructor(this.peer),
          pingTimeout: this.pingTimeout,
          id: this.peer,
          role: "server",
          onClose: () => {
            this.closed = !0, this.connected = !1;
            for (const e of this.onConnectionChangeListeners)
              e(!1);
            this.startConnection();
          },
          onSuccess: () => {
            this.closed = !1, this.connected = !0;
            for (const e of this.onConnectionChangeListeners)
              e(!0);
            AA.debug("Websocket connection successful"), this.reconnectionAttempts = 0;
          }
        }), this.addPeer(this.currentPeer));
      }
    }, this.enable = () => {
      this.enabled || (this.connected = !0, this.enabled = !0, this.startConnection());
    }, this.disable = () => {
      this.enabled && (this.enabled = !1, this.reconnectionAttempts = 0, this.unsubscribeNetworkChange?.(), this.unsubscribeNetworkChange = void 0, this.currentPeer && (this.removePeer(this.currentPeer), this.currentPeer.outgoing.close(), this.currentPeer = void 0));
    }, this.peer = A.peer, this.reconnectionTimeout = A.reconnectionTimeout || 500, this.addPeer = A.addPeer, this.removePeer = A.removePeer, this.WebSocketConstructor = A.WebSocketConstructor || WebSocket, this.pingTimeout = A.pingTimeout || 1e4;
  }
  // Basic implementation for environments that don't support network change events (e.g. Node.js)
  // Needs to be extended to handle platform specific APIs
  onNetworkChange(A) {
    return () => {
    };
  }
  waitForOnline(A) {
    return new Promise((e) => {
      const t = this.onNetworkChange((s) => {
        s && o();
      });
      function o() {
        clearTimeout(r), t?.(), e();
      }
      const r = setTimeout(o, A);
    });
  }
}
const Dg = {};
let Be = {
  connected: !1,
  syncing: !1,
  error: null,
  status: null
  // 'authenticating' | 'loading-account' | 'syncing' | 'connected' | 'error'
};
const Pr = /* @__PURE__ */ new Set();
function Wy(i) {
  return Pr.add(i), i(Be), () => Pr.delete(i);
}
function oi() {
  for (const i of Pr)
    i(Be);
}
function zt(i = null) {
  const A = typeof window < "u" && window.location.hostname === "localhost", e = i || typeof window < "u" && window.__PUBLIC_API_DOMAIN__ || Dg?.PUBLIC_API_DOMAIN || typeof process < "u" && process.env?.PUBLIC_API_DOMAIN;
  let t;
  if (typeof window > "u") {
    if (!i)
      return { peers: [], setNode: () => {
      }, wsPeer: null };
    t = `${i.includes("localhost") || i.includes("127.0.0.1") ? "ws:" : "wss:"}//${i}/sync`;
  } else A ? t = `${window.location.protocol === "https:" ? "wss:" : "ws:"}//${window.location.host}/sync` : e ? t = `${window.location.protocol === "https:" ? "wss:" : "ws:"}//${e}/sync` : (console.warn(" [SYNC] Sync domain not set! Falling back to same origin. Sync may not work."), t = `${window.location.protocol === "https:" ? "wss:" : "ws:"}//${window.location.host}/sync`);
  A || (console.log(`   Sync Domain: ${e || "(not set - using same origin fallback)"}`), console.log(`   Source: ${i ? "kernel" : typeof window < "u" && window.__PUBLIC_API_DOMAIN__ ? "runtime env" : Dg?.PUBLIC_API_DOMAIN ? "build-time env" : "fallback"}`));
  let o;
  const r = [];
  let s = null, g = !1, n = null, a = 0;
  const I = 6e4, C = new Promise((B) => {
    n = B;
  });
  if (!t)
    return { peers: [], setNode: () => {
    }, wsPeer: null };
  const c = new Vy({
    peer: t,
    reconnectionTimeout: 5e3,
    addPeer: (B) => {
      s && (clearTimeout(s), s = null), r.push(B), o && o.syncManager.addPeer(B);
    },
    removePeer: (B) => {
      const Q = r.indexOf(B);
      Q > -1 && r.splice(Q, 1);
      const f = Date.now();
      Be.connected && f - a > I && (a = f, console.warn(" [SYNC] Peer removed, connection lost")), g = !1, Be = { connected: !1, syncing: !1, error: "Disconnected", status: "error" }, oi();
    }
  });
  return c.subscribe((B) => {
    if (B && !g)
      g = !0, a = 0, Be = { connected: !0, syncing: !0, error: null, status: "syncing" }, oi(), n && (n(), n = null);
    else if (!B && g) {
      g = !1;
      const Q = Date.now();
      Q - a > I && (a = Q, console.warn(" [SYNC] WebSocket connection lost")), Be = { connected: !1, syncing: !1, error: "Offline", status: "error" }, oi();
    }
  }), typeof window < "u" && (s = setTimeout(() => {
    Be.connected || (console.error(" [SYNC] Connection timeout after 10s. Check:"), console.error(`   1. Sync service is running: curl https://${e || window.location.hostname}/health`), console.error(`   2. PUBLIC_API_DOMAIN is set correctly: ${e || "NOT SET"}`), console.error(`   3. WebSocket URL: ${t}`), Be = { connected: !1, syncing: !1, error: "Connection timeout", status: "error" }, oi());
  }, 1e4)), c.enable(), {
    peers: r,
    wsPeer: c,
    // Wait for WebSocket to be actually connected (not just peer object created)
    waitForPeer: () => new Promise((B) => {
      if (g && r.length > 0) {
        B(!0);
        return;
      }
      let Q = !1;
      const f = setTimeout(() => {
        Q || (Q = !0, B(!1));
      }, 2e3);
      C.then(() => {
        !Q && r.length > 0 && (Q = !0, clearTimeout(f), B(!0));
      }).catch(() => {
        Q || (Q = !0, clearTimeout(f), B(!1));
      });
    }),
    setNode: (B) => {
      if (o = B, r.length > 0)
        for (const Q of r)
          o.syncManager.addPeer(Q);
    }
  };
}
const Go = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CoCache: Mr,
  CoJSONBackend: vs,
  EXCEPTION_SCHEMAS: yA,
  checkCotype: bt,
  createAccountWithSecret: Rs,
  createAndPushMessage: Or,
  createCoJSONAPI: Ry,
  createCoList: oI,
  createCoMap: iI,
  createCoStream: rI,
  createCoValueForSpark: hA,
  createSchemaMeta: gt,
  ensureCoValueLoaded: aA,
  getAllSchemas: yo,
  getCoListId: Bs,
  getGlobalCoCache: Va,
  getSchema: _a,
  getSchemaIndexColistId: cs,
  getSparkCapabilityGroupIdFromSparkCoId: hs,
  loadAccount: bs,
  processInbox: by,
  resolve: eA,
  resolveCoValueReactive: Gr,
  resolveQueryReactive: za,
  resolveReactive: Ae,
  resolveSchemaReactive: Rt,
  schemaMigration: us,
  seedAgentAccount: yI,
  setupSyncPeers: zt,
  subscribeSyncState: Wy,
  waitForReactiveResolution: Qe,
  waitForStoreReady: uA
}, Symbol.toStringTag, { value: "Module" })), lA = {
  INITIALIZING: "initializing",
  // Setting up subscriptions, loading initial data
  RENDERING: "rendering",
  // Currently rendering (prevents nested renders)
  READY: "ready",
  // Initial render complete, ready for updates
  UPDATING: "updating"
  // Data changed, queued for rerender
};
class zy {
  constructor(A, e, t, o, r = null) {
    this.styleEngine = A, this.viewEngine = e, this.registry = t, this.toolEngine = o, this.stateEngine = r, this.actors = /* @__PURE__ */ new Map(), this.pendingMessages = /* @__PURE__ */ new Map(), this.dbEngine = null, this.os = null, this._containerActors = /* @__PURE__ */ new Map(), this._vibeActors = /* @__PURE__ */ new Map(), this.viewEngine.setActorEngine(this), this.pendingRerenders = /* @__PURE__ */ new Set(), this.batchTimer = null;
  }
  async updateContextCoValue(A, e) {
    if (!A.contextCoId || !this.dbEngine) {
      A.contextCoId || console.warn(`[ActorEngine] Actor ${A.id} has no contextCoId`);
      return;
    }
    const t = A.contextSchemaCoId || await eA(this.dbEngine.backend, { fromCoValue: A.contextCoId }, { returnType: "coId" }), o = {};
    for (const [s, g] of Object.entries(e))
      o[s] = g === void 0 ? null : g;
    const r = await this.dbEngine.execute({
      op: "update",
      schema: t,
      id: A.contextCoId,
      data: o
    });
    if (!r.ok) {
      const s = r.errors?.map((g) => g.message).join("; ") || "Update failed";
      throw new Error(`[ActorEngine] Context update failed: ${s}`);
    }
  }
  async _loadActorConfigs(A) {
    if (!A.view) throw new Error("[ActorEngine] Actor config must have 'view' property");
    const e = A.id || "temp", t = [], o = Ae(this.dbEngine.backend, { fromCoValue: A.view }, { returnType: "coId" }), r = await Qe(o, { timeoutMs: 1e4 }), s = r.schemaCoId;
    if (!s)
      throw new Error(`[ActorEngine] Failed to extract schema co-id from view CoValue ${A.view}: ${r.error || "Schema not found"}`);
    await this.dbEngine.execute({ op: "read", schema: null, key: A.view });
    const g = await this.dbEngine.execute({ op: "read", schema: s, key: A.view }), n = g.value, a = g.subscribe((w) => {
      const E = this.actors.get(e);
      E && (E.viewDef = w, E._renderState === lA.READY && (E._renderState = lA.UPDATING, this._scheduleRerender(E.id)));
    }, { skipInitial: !0 });
    t.push(a);
    const I = [];
    let C = null;
    A.context && (C = (async () => {
      const w = A.context;
      let E = w;
      if (typeof w == "string" && !w.startsWith("co_z")) {
        const m = await this.dbEngine.execute({ op: "resolve", humanReadableKey: w });
        if (m && m.startsWith("co_z"))
          E = m;
        else
          throw new Error(`[ActorEngine] Failed to resolve context reference "${w}"`);
      }
      const p = await eA(this.dbEngine.backend, { fromCoValue: E }, { returnType: "coId" }), y = await this.dbEngine.execute({
        op: "read",
        schema: p,
        key: E
      });
      return { context: y, contextCoId: E, contextSchemaCoId: p, store: y };
    })(), I.push(C));
    let c = null, B = null;
    A.style && (c = (async () => {
      try {
        const w = await eA(this.dbEngine.backend, { fromCoValue: A.style }, { returnType: "coId" }), E = await this.dbEngine.execute({ op: "read", schema: w, key: A.style }), p = E.subscribe(async (y) => {
          const m = this.actors.get(e);
          if (m && this.styleEngine)
            try {
              const N = await this.styleEngine.getStyleSheets(m.config, m.id);
              m.shadowRoot.adoptedStyleSheets = N, m._renderState === lA.READY && (m._renderState = lA.UPDATING, this._scheduleRerender(m.id));
            } catch (N) {
              console.error("[ActorEngine] Failed to update stylesheets after style change:", N);
            }
        }, { skipInitial: !0 });
        return t.push(p), E;
      } catch (w) {
        return console.error("[ActorEngine] Failed to load style:", w), null;
      }
    })(), I.push(c)), A.brand && (B = (async () => {
      try {
        const w = await eA(this.dbEngine.backend, { fromCoValue: A.brand }, { returnType: "coId" }), E = await this.dbEngine.execute({ op: "read", schema: w, key: A.brand }), p = E.subscribe(async (y) => {
          const m = this.actors.get(e);
          if (m && this.styleEngine)
            try {
              const N = await this.styleEngine.getStyleSheets(m.config, m.id);
              m.shadowRoot.adoptedStyleSheets = N, m._renderState === lA.READY && (m._renderState = lA.UPDATING, this._scheduleRerender(m.id));
            } catch (N) {
              console.error("[ActorEngine] Failed to update stylesheets after brand change:", N);
            }
        }, { skipInitial: !0 });
        return t.push(p), E;
      } catch (w) {
        return console.error("[ActorEngine] Failed to load brand:", w), null;
      }
    })(), I.push(B));
    let Q = null;
    A.inbox && (Q = (async () => {
      const w = await eA(this.dbEngine.backend, { fromCoValue: A.inbox }, { returnType: "coId" });
      return await this.dbEngine.execute({ op: "read", schema: w, key: A.inbox });
    })(), I.push(Q)), await Promise.all(I);
    let f = null, l = null, d = null;
    if (C) {
      const w = await C;
      f = w.store, l = w.contextCoId, d = w.contextSchemaCoId;
    }
    let u = null, h = null;
    return Q && (h = A.inbox, u = await Q), { viewDef: n, context: f, contextCoId: l, contextSchemaCoId: d, inbox: u, inboxCoId: h, configUnsubscribes: t };
  }
  /**
   * Set up reactive subscriptions for inbox costream
   * @param {Object} actor - Actor instance
   * @param {Object} actorConfig - The actor configuration
   * @returns {Promise<void>}
   * @private
   */
  async _setupMessageSubscriptions(A, e) {
    if (e.inbox)
      try {
        const t = await eA(this.dbEngine.backend, { fromCoValue: e.inbox }, { returnType: "coId" }), r = (await this.dbEngine.execute({
          op: "read",
          schema: t,
          key: e.inbox
        })).subscribe((s) => {
          this.actors.has(A.id) && s?.items && this.processMessages(A.id);
        });
        A._configUnsubscribes && A._configUnsubscribes.push(r);
      } catch (t) {
        console.error("[ActorEngine] Failed to subscribe to inbox:", t);
      }
  }
  /**
   * Initialize actor state (state machine)
   * @param {Object} actor - Actor instance
   * @param {Object} actorConfig - The actor configuration
   * @returns {Promise<void>}
   * @private
   */
  async _initializeActorState(A, e) {
    if (this.stateEngine && e.state && !A.machine)
      try {
        const t = Ae(this.dbEngine.backend, { fromCoValue: e.state }, { returnType: "coId" }), o = await Qe(t, { timeoutMs: 1e4 }), r = o.schemaCoId;
        if (!r)
          throw new Error(`[ActorEngine] Failed to extract schema co-id from state CoValue ${e.state}: ${o.error || "Schema not found"}`);
        const s = await this.dbEngine.execute({
          op: "read",
          schema: r,
          key: e.state
        }), g = s.value, n = A.id, a = s.subscribe(async (I) => {
          const C = this.actors.get(n);
          if (C && this.stateEngine)
            try {
              C.machine && this.stateEngine.destroyMachine(C.machine.id), C.machine = await this.stateEngine.createMachine(I, C), C._renderState === lA.READY && (C._renderState = lA.UPDATING, this._scheduleRerender(n));
            } catch (c) {
              console.error("[ActorEngine] Failed to update state machine:", c);
            }
        }, { skipInitial: !0 });
        A._configUnsubscribes && A._configUnsubscribes.push(a), A.machine = await this.stateEngine.createMachine(g, A);
      } catch (t) {
        console.error("[ActorEngine] Failed to load state machine:", t);
      }
  }
  // Query resolution handled by backend unified store automatically
  /**
   * Determine if an actor is a service actor (orchestrator) vs UI actor (presentation)
   * Service actors: Have role "agent" OR have minimal view (only renders child actors via $slot)
   * UI actors: Have full view (render actual UI components)
   * @param {Object} actorConfig - Actor configuration
   * @param {Object} viewDef - View definition (optional, will be loaded if not provided)
   * @returns {Promise<boolean>} True if service actor, false if UI actor
   * @private
   */
  async _isServiceActor(A, e = null) {
    if (A.role === "agent" || !A.view) return !0;
    if (!e)
      try {
        try {
          const r = Ae(this.dbEngine.backend, { fromCoValue: A.view }, { returnType: "coId" });
          if (!(await Qe(r, { timeoutMs: 1e4 })).schemaCoId)
            return !1;
        } catch {
          return !1;
        }
        e = (await this.dbEngine.execute({ op: "read", schema: viewSchemaCoId, key: A.view })).value;
      } catch {
        return !1;
      }
    const t = e.content || e.root || e;
    return !t || t.$slot && !t.children || t.children?.every((o) => o.$slot || o.children?.every((r) => r.$slot)) ? !0 : !(t.tag && (t.text || t.value || t.$on || t.children?.some((o) => o.tag && (o.text || o.value || o.$on))));
  }
  /**
   * Create a child actor lazily if it doesn't exist yet
   * Only creates the child actor when it's actually needed (referenced by context.currentView)
   * @param {Object} actor - Parent actor instance
   * @param {string} namekey - Child actor namekey (e.g., "list", "kanban")
   * @param {string} [vibeKey] - Optional vibe key for tracking child actors
   * @returns {Promise<Object|null>} The child actor instance, or null if not found/created
   * @private
   */
  async _createChildActorIfNeeded(A, e, t = null) {
    if (A.children?.[e]) return A.children[e];
    A.children || (A.children = {});
    const o = A.context.value;
    if (!o["@actors"]?.[e]) return null;
    const r = o["@actors"][e];
    if (!r.startsWith("co_z"))
      throw new Error(`[ActorEngine] Child actor ID must be co-id: ${r}`);
    try {
      const s = Ae(this.dbEngine.backend, { fromCoValue: r }, { returnType: "coId" }), g = await Qe(s, { timeoutMs: 1e4 }), n = g.schemaCoId;
      if (!n)
        throw new Error(`[ActorEngine] Failed to extract schema co-id from child actor CoValue ${r}: ${g.error || "Schema not found"}`);
      const I = (await this.dbEngine.execute({ op: "read", schema: n, key: r })).value;
      I.$id !== r && (I.$id = r);
      const C = document.createElement("div");
      C.dataset.namekey = e, C.dataset.childActorId = r;
      const c = await this.createActor(I, C, t);
      return c.namekey = e, A.children[e] = c, c;
    } catch (s) {
      return console.error("[ActorEngine] Failed to create child actor:", s), null;
    }
  }
  async createActor(A, e, t = null) {
    const o = A.$id || A.id;
    if (this.actors.has(o))
      return t ? await this.reuseActor(o, e, t) : this.actors.get(o);
    typeof window < "u" && window._maiaDebugFreeze && console.debug("[ActorEngine] createActor", o, t);
    const r = e.attachShadow({ mode: "open" }), s = await this.styleEngine.getStyleSheets(A, o), { viewDef: g, context: n, contextCoId: a, contextSchemaCoId: I, inbox: C, inboxCoId: c, tempSubscriptions: B, configUnsubscribes: Q } = await this._loadActorConfigs(A), f = await this._isServiceActor(A, g) ? "service" : "ui", l = {
      id: o,
      config: A,
      shadowRoot: r,
      context: n,
      contextCoId: a,
      contextSchemaCoId: I,
      containerElement: e,
      actorEngine: this,
      viewDef: g,
      actorType: f,
      vibeKey: t,
      inbox: C,
      inboxCoId: c,
      messageTypes: A.messageTypes || null,
      // REQUIRED: Message types this actor accepts
      _renderState: lA.INITIALIZING,
      // Start in INITIALIZING state
      children: {},
      _configUnsubscribes: Q || []
    };
    if (await this._setupMessageSubscriptions(l, A), this.actors.set(o, l), l.context && typeof l.context.subscribe == "function") {
      let d = JSON.stringify(l.context.value || {});
      l._contextUnsubscribe = l.context.subscribe((u) => {
        const h = JSON.stringify(u || {}), w = h !== d;
        d = h, l._renderState === lA.READY && w && (l._renderState = lA.UPDATING, this._scheduleRerender(o));
      }, { skipInitial: !0 });
    }
    if (e && (this._containerActors.has(e) || this._containerActors.set(e, /* @__PURE__ */ new Set()), this._containerActors.get(e).add(o)), t && this.registerActorForVibe(o, t), await this._initializeActorState(l, A), l._renderState = lA.RENDERING, await this.viewEngine.render(g, l.context, r, s, o), l._renderState = lA.READY, l._needsPostInitRerender && (delete l._needsPostInitRerender, this._scheduleRerender(o)), this.pendingMessages.has(o)) {
      for (const d of this.pendingMessages.get(o))
        await this.sendMessage(o, d);
      this.pendingMessages.delete(o);
    }
    return l;
  }
  /**
   * Schedule a rerender for an actor (batched via microtask queue)
   * Following Svelte's batching pattern: multiple updates in same tick = one rerender
   * CRITICAL: Set-based deduplication ensures each actor only rerenders once per batch
   * This prevents doubled rendering when multiple subscriptions fire simultaneously
   * @param {string} actorId - The actor ID to rerender
   */
  _scheduleRerender(A) {
    this.actors.has(A) && (this.pendingRerenders.add(A), this.batchTimer || (this.batchTimer = queueMicrotask(async () => {
      this.batchTimer = null, await this._flushRerenders();
    })));
  }
  /**
   * Flush all pending rerenders in batch
   * Processes all actors that need rerendering in one microtask
   * CRITICAL: Set-based deduplication ensures each actor only rerenders once
   * This prevents doubled rendering when multiple subscriptions fire simultaneously
   */
  async _flushRerenders() {
    const A = Array.from(this.pendingRerenders);
    this.pendingRerenders.clear();
    const e = A.filter((t) => this.actors.has(t));
    await Promise.all(e.map((t) => this.rerender(t)));
  }
  /**
   * Rerender an actor (private implementation - only called by _flushRerenders)
   * @param {string} actorId - The actor ID to rerender
   * @private
   */
  async rerender(A) {
    const e = this.actors.get(A);
    if (!e || e._renderState !== lA.UPDATING && e._renderState !== lA.READY)
      return;
    e._renderState = lA.RENDERING;
    const t = Ae(this.dbEngine.backend, { fromCoValue: e.config.view }, { returnType: "coId" }), o = await Qe(t, { timeoutMs: 1e4 }), r = o.schemaCoId;
    if (!r)
      throw new Error(`[ActorEngine] Failed to extract schema co-id from view CoValue ${e.config.view}: ${o.error || "Schema not found"}`);
    const g = (await this.dbEngine.execute({ op: "read", schema: r, key: e.config.view })).value, n = await this.styleEngine.getStyleSheets(e.config, A);
    await this.viewEngine.render(g, e.context, e.shadowRoot, n, A), e._renderState = lA.READY;
  }
  /**
   * Get actor by ID
   * @param {string} actorId - The actor ID
   * @returns {Object|undefined} The actor instance
   */
  getActor(A) {
    return this.actors.get(A);
  }
  /**
   * Register an actor with a vibe key for reuse tracking
   * @param {string} actorId - The actor ID
   * @param {string} vibeKey - The vibe key (e.g., 'todos')
   */
  registerActorForVibe(A, e) {
    e && (this._vibeActors.has(e) || this._vibeActors.set(e, /* @__PURE__ */ new Set()), this._vibeActors.get(e).add(A));
  }
  /**
   * Get all actors for a vibe
   * @param {string} vibeKey - The vibe key (e.g., 'todos')
   * @returns {Set<string>|undefined} Set of actor IDs for the vibe
   */
  getActorsForVibe(A) {
    return this._vibeActors.get(A);
  }
  /**
   * Reuse an existing actor by reattaching it to a new container
   * @param {string} actorId - The actor ID
   * @param {HTMLElement} containerElement - The new container to attach to
   * @param {string} vibeKey - The vibe key (e.g., 'todos')
   * @returns {Promise<Object>} The reused actor instance
   */
  async reuseActor(A, e, t) {
    const o = this.actors.get(A);
    if (!o) throw new Error(`[ActorEngine] Cannot reuse actor ${A}`);
    const r = o.containerElement;
    if (o.containerElement = e, r && this._containerActors.has(r)) {
      const s = this._containerActors.get(r);
      s.delete(A), s.size === 0 && this._containerActors.delete(r);
    }
    if (e && (this._containerActors.has(e) || this._containerActors.set(e, /* @__PURE__ */ new Set()), this._containerActors.get(e).add(A)), this.registerActorForVibe(A, t), o.shadowRoot) {
      const s = o.shadowRoot.host;
      s && s !== e && (s.parentNode && s.parentNode.removeChild(s), e.appendChild(s));
    } else
      o.shadowRoot = e.attachShadow({ mode: "open" });
    return o._initialRenderComplete && this._scheduleRerender(A), o;
  }
  /**
   * Destroy an actor
   * @param {string} actorId - The actor ID
   */
  destroyActor(A) {
    const e = this.actors.get(A);
    if (e) {
      typeof window < "u" && window._maiaDebugFreeze && console.debug("[ActorEngine] destroyActor", A), e.shadowRoot.innerHTML = "", this.viewEngine && this.viewEngine.cleanupActor(A), e._contextUnsubscribe && typeof e._contextUnsubscribe == "function" && (e._contextUnsubscribe(), delete e._contextUnsubscribe);
      for (const t of e._configUnsubscribes || [])
        try {
          typeof t == "function" && t();
        } catch {
        }
      if (delete e._configUnsubscribes, e.context && e.context._unsubscribe && typeof e.context._unsubscribe == "function")
        try {
          e.context._unsubscribe();
        } catch (t) {
          console.warn("[ActorEngine] Error cleaning up context store:", t.message);
        }
      if (e.machine && this.stateEngine && this.stateEngine.destroyMachine(e.machine.id), e._processedMessageKeys && (e._processedMessageKeys.clear(), delete e._processedMessageKeys), e.containerElement && this._containerActors.has(e.containerElement)) {
        const t = this._containerActors.get(e.containerElement);
        t.delete(A), t.size === 0 && this._containerActors.delete(e.containerElement);
      }
      for (const [t, o] of this._vibeActors.entries())
        if (o.has(A)) {
          o.delete(A), o.size === 0 && this._vibeActors.delete(t);
          break;
        }
      this.actors.delete(A);
    }
  }
  /**
   * Destroy all actors for a given container
   * Used when unloading a vibe to clean up all actors associated with that container
   * @param {HTMLElement} containerElement - The container element
   */
  destroyActorsForContainer(A) {
    const e = this._containerActors.get(A);
    if (e?.size) {
      for (const t of Array.from(e))
        this.destroyActor(t);
      this._containerActors.delete(A);
    }
  }
  /**
   * Destroy all actors for a vibe (complete cleanup)
   * Used for explicit cleanup when needed (e.g., app shutdown)
   * @param {string} vibeKey - The vibe key (e.g., 'todos')
   */
  destroyActorsForVibe(A) {
    const e = this._vibeActors.get(A);
    if (!(!A || !e?.size)) {
      for (const t of Array.from(e))
        this.destroyActor(t);
      this._vibeActors.delete(A);
    }
  }
  // ============================================
  // MESSAGE PASSING SYSTEM (v0.2)
  // ============================================
  /**
   * Send a message to an actor's inbox
   * CRDT handles persistence and sync automatically - no MessageQueue needed
   * @param {string} actorId - Target actor ID
   * @param {Object} message - Message object { type, payload, from, timestamp }
   */
  async sendMessage(A, e) {
    if (e.payload && rt(e.payload))
      throw new Error(`[ActorEngine] Message payload contains unresolved expressions. Only resolved values can be sent between actors. Payload: ${JSON.stringify(e.payload).substring(0, 200)}`);
    const t = this.actors.get(A);
    if (!t) {
      this.pendingMessages.has(A) || this.pendingMessages.set(A, []);
      const o = this.pendingMessages.get(A), r = e.id || `${e.type}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      o.some((s) => s.id === r || !s.id && !e.id && s.type === e.type) || o.push(e);
      return;
    }
    if (t.inboxCoId && this.dbEngine)
      try {
        const o = {
          type: e.type,
          payload: e.payload || {},
          source: e.from || e.source,
          target: A,
          processed: !1
        };
        await Or(this.dbEngine, t.inboxCoId, o), setTimeout(() => {
          this.processMessages(A).catch((r) => {
            console.error("[ActorEngine] Error processing deferred messages:", r);
          });
        }, 0);
      } catch (o) {
        console.error("[ActorEngine] Failed to send message:", o);
      }
  }
  async sendInternalEvent(A, e, t = {}) {
    if (rt(t))
      throw new Error(`[ActorEngine] Payload contains unresolved expressions. Views must resolve all expressions before sending to inbox. Payload: ${JSON.stringify(t).substring(0, 200)}`);
    const o = this.actors.get(A);
    if (!o || !o.inboxCoId || !this.dbEngine) {
      console.warn("[ActorEngine] Cannot send internal event:", {
        hasActor: !!o,
        hasInboxCoId: !!o?.inboxCoId,
        hasDbEngine: !!this.dbEngine
      });
      return;
    }
    try {
      await Or(this.dbEngine, o.inboxCoId, {
        type: e,
        payload: t,
        source: A,
        target: A,
        processed: !1
      }), setTimeout(() => {
        this.processMessages(A).catch((r) => {
          console.error("[ActorEngine] Error processing deferred messages:", r);
        });
      }, 0);
    } catch (r) {
      console.error("[ActorEngine] Failed to send internal event:", r);
    }
  }
  /**
   * Validate message type against actor's message contract
   * @param {Object} actor - Actor instance
   * @param {string} messageType - Message type to validate
   * @returns {boolean} True if message type is accepted, false otherwise
   */
  _validateMessageType(A, e) {
    return !A.messageTypes || !Array.isArray(A.messageTypes) ? (console.error(`[ActorEngine] Actor "${A.id}" missing required "messageTypes" array. All actors must declare their message contracts.`), !1) : A.messageTypes.includes(e) ? !0 : (console.error(`[ActorEngine] Message type "${e}" not in actor's message contract. Actor: ${A.id}, Accepted types: ${A.messageTypes.join(", ")}`), !1);
  }
  /**
   * Load message type schema from registry
   * @param {string} messageType - Message type name (e.g., 'CREATE_BUTTON')
   * @returns {Promise<Object|null>} Message type schema or null if not found
   */
  async _loadMessageTypeSchema(A) {
    if (!this.dbEngine || !this.dbEngine.backend)
      return console.warn("[ActorEngine] Cannot load message type schema: dbEngine not available"), null;
    try {
      const t = `@${this.dbEngine?.backend?.systemSpark?.replace(/^@/, "") ?? "maia"}/schema/message/${A}`;
      return await eA(this.dbEngine.backend, t, { returnType: "schema" });
    } catch (e) {
      return console.error(`[ActorEngine] Message type schema not found for "${A}". All message types must have schemas registered.`, e), null;
    }
  }
  /**
   * Validate message payload against message type schema
   * Message type schema IS the payload schema (merged concept)
   * @param {Object} messageTypeSchema - Message type schema definition (this IS the payload schema)
   * @param {Object} payload - Message payload to validate
   * @param {string} messageType - Message type name (for error messages)
   * @returns {Promise<{valid: boolean, errors: Array|null}>} Validation result
   */
  async _validateMessagePayload(A, e, t) {
    if (!A)
      return { valid: !1, errors: [`Message type schema is required for ${t}`] };
    try {
      const { groupInfo: o, ...r } = A;
      return await jt(r, e || {}, `message payload for ${t}`);
    } catch (o) {
      return console.error(`[ActorEngine] Error validating message payload for ${t}:`, o), { valid: !1, errors: [o.message] };
    }
  }
  async processMessages(A) {
    const e = this.actors.get(A);
    if (!(!e || !e.inboxCoId || !this.dbEngine || e._isProcessing)) {
      e._isProcessing = !0;
      try {
        const o = (await this.dbEngine.execute({ op: "processInbox", actorId: A, inboxCoId: e.inboxCoId })).messages || [];
        for (const r of o)
          if (!(r.type === "INIT" || r.from === "system"))
            try {
              if (!this._validateMessageType(e, r.type)) {
                console.error(`[ActorEngine] Message type "${r.type}" rejected by actor "${A}" - not in message contract`);
                continue;
              }
              const s = await this._loadMessageTypeSchema(r.type);
              if (!s) {
                console.error(`[ActorEngine] Message type schema not found for "${r.type}". All message types must have schemas registered.`);
                continue;
              }
              const g = r.payload || {}, n = await this._validateMessagePayload(s, g, r.type);
              if (!n.valid) {
                const a = n.errors?.map((I) => `  - ${I.instancePath || I.path || "root"}: ${I.message || I}`).join(`
`) || "Unknown validation error";
                console.error(`[ActorEngine] Message payload validation failed for "${r.type}":
${a}
Payload:`, JSON.stringify(g, null, 2));
                continue;
              }
              e.machine && this.stateEngine ? await this.stateEngine.send(e.machine.id, r.type, g) : console.error(`[ActorEngine] Actor ${A} has no state machine. All actors must have state machines. Message type: ${r.type}`);
            } catch (s) {
              console.error("[ActorEngine] Failed to process message:", s);
            }
      } catch (t) {
        console.error("[ActorEngine] Error processing messages:", t);
      } finally {
        e._isProcessing = !1;
      }
    }
  }
}
function jr(i, A) {
  if (!i || typeof i != "object")
    return i;
  if (Array.isArray(i))
    return i.map((t) => jr(t, A));
  const e = {};
  for (const [t, o] of Object.entries(i))
    if (o === "@inputValue") {
      let r = A;
      A.tagName !== "INPUT" && A.tagName !== "TEXTAREA" && (r = (A.closest("form") || A.closest('[class*="form"]') || A.parentElement)?.querySelector("input, textarea") ?? A), e[t] = (r?.value ?? "") || "";
    } else o === "@dataColumn" ? e[t] = A.dataset.column || A.getAttribute("data-column") || null : typeof o == "object" && o !== null ? e[t] = jr(o, A) : e[t] = o;
  return e;
}
function Zy(i) {
  return i == null ? "" : String(i).replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;").replace(/\//g, "&#x2F;");
}
function _y(i) {
  return typeof i != "string" ? !1 : [/<script/i, /javascript:/i, /on\w+\s*=/i, /<iframe/i, /<object/i, /<embed/i, /<link/i, /<meta/i, /<style/i].some((A) => A.test(i));
}
class $y {
  constructor(A, e, t) {
    this.evaluator = A, this.actorEngine = e, this.moduleRegistry = t, this.dbEngine = null, this.actorInputCounters = /* @__PURE__ */ new Map();
  }
  async loadView(A) {
    const e = Ae(this.dbEngine.backend, { fromCoValue: A }, { returnType: "coId" }), t = await Qe(e, { timeoutMs: 1e4 }), o = t.schemaCoId;
    if (!o)
      throw new Error(`[ViewEngine] Failed to extract schema co-id from view CoValue ${A}: ${t.error || "Schema not found"}`);
    return await this.dbEngine.execute({
      op: "read",
      schema: null,
      key: A
    }), await this.dbEngine.execute({
      op: "read",
      schema: o,
      key: A
    });
  }
  async render(A, e, t, o, r) {
    this.actorInputCounters.set(r, 0), t.innerHTML = "", t.adoptedStyleSheets = o, this.currentActorId = r;
    const s = A.content || A;
    if (!e) {
      console.error(`[ViewEngine] Context is null/undefined for actor ${r}`);
      return;
    }
    const g = e.value || {}, n = await this.renderNode(s, { context: g }, r);
    n ? (n.dataset.actorId = r, t.appendChild(n)) : console.error(`[ViewEngine.render] renderNode returned null for actor ${r}`, {
      viewNode: s ? { tag: s.tag, hasContent: !!s.content } : null,
      contextKeys: Object.keys(g)
    });
  }
  async renderNode(A, e, t) {
    if (!A) return null;
    const o = A.tag || "div", r = document.createElement(o);
    if (await this._applyNodeAttributes(r, A, e, t), A.$each) {
      r.innerHTML = "";
      const s = await this.renderEach(A.$each, e, t);
      r.appendChild(s);
    }
    if (A.$on && this.attachEvents(r, A.$on, e, t), A.$slot)
      return await this._renderSlot(A, e, r, t), r;
    if (A.slot)
      throw new Error('[ViewEngine] Old "slot" syntax is no longer supported. Use "$slot" instead.');
    return A.$each || await this._renderNodeChildren(r, A, e, t), r;
  }
  async _applyNodeAttributes(A, e, t, o) {
    if (e.class) {
      if (typeof e.class == "object" && this._isDSLOperation(e.class)) {
        const s = Object.keys(e.class)[0];
        throw new Error(`[ViewEngine] Conditional logic (${s}) is not allowed in class property. Use state machines to compute boolean flags and reference them via context, then use data-attributes and CSS.`);
      }
      if (typeof e.class == "string" && e.class.includes("?") && e.class.includes(":"))
        throw new Error("[ViewEngine] Ternary operators are not allowed in class property. Use state machines to compute values and reference them via context.");
      const r = await this.evaluator.evaluate(e.class, t);
      r && (A.className = r);
    }
    if (e.attrs)
      for (const [r, s] of Object.entries(e.attrs))
        if (r === "data")
          await this._resolveDataAttributes(s, t, A);
        else {
          if (typeof s == "object" && this._isDSLOperation(s)) {
            const n = Object.keys(s)[0];
            throw new Error(`[ViewEngine] Conditional logic (${n}) is not allowed in attributes. Use state machines to compute values and reference them via context.`);
          }
          if (typeof s == "string" && s.includes("?") && s.includes(":"))
            throw new Error("[ViewEngine] Ternary operators are not allowed in attributes. Use state machines to compute values and reference them via context.");
          const g = await this.evaluator.evaluate(s, t);
          if (g != null)
            if (["disabled", "readonly", "checked", "selected", "autofocus", "required", "multiple"].includes(r.toLowerCase())) {
              const a = !!g;
              A[r] = a, a ? A.setAttribute(r, "") : A.removeAttribute(r);
            } else {
              let a = String(g);
              _y(a) && (console.warn(`[ViewEngine] Potentially dangerous HTML detected in attribute ${r}, sanitizing`), a = Zy(a)), A.setAttribute(r, a);
            }
        }
    if (e.value !== void 0) {
      if (typeof e.value == "object" && this._isDSLOperation(e.value)) {
        const s = Object.keys(e.value)[0];
        throw new Error(`[ViewEngine] Conditional logic (${s}) is not allowed in value property. Use state machines to compute values and reference them via context.`);
      }
      if (typeof e.value == "string" && e.value.includes("?") && e.value.includes(":"))
        throw new Error("[ViewEngine] Ternary operators are not allowed in value property. Use state machines to compute values and reference them via context.");
      const r = await this.evaluator.evaluate(e.value, t);
      if (A.tagName === "INPUT" || A.tagName === "TEXTAREA") {
        const s = r || "";
        document.activeElement === A || (A.tagName === "INPUT" ? A.value = s : A.textContent = s), this.actorInputCounters.has(o) || this.actorInputCounters.set(o, 0);
        const n = this.actorInputCounters.get(o);
        this.actorInputCounters.set(o, n + 1), A.setAttribute("data-actor-input", `${o}_input_${n}`);
      }
    }
    if (e.text !== void 0) {
      if (typeof e.text == "object" && this._isDSLOperation(e.text)) {
        const s = Object.keys(e.text)[0];
        throw new Error(`[ViewEngine] Conditional logic (${s}) is not allowed in text property. Use state machines to compute values and reference them via context.`);
      }
      if (typeof e.text == "string" && e.text.includes("?") && e.text.includes(":"))
        throw new Error("[ViewEngine] Ternary operators are not allowed in text property. Use state machines to compute values and reference them via context.");
      const r = await this.evaluator.evaluate(e.text, t);
      if (r && typeof r == "object")
        if (r.role && r.id && r.id.startsWith("co_z")) {
          const s = r.id.substring(0, 15) + "...";
          A.textContent = `${r.role} (${s})`;
        } else
          try {
            A.textContent = JSON.stringify(r, null, 2);
          } catch {
            A.textContent = String(r);
          }
      else {
        let s = String(r || "");
        s.startsWith("co_z") && s.length > 15 && (s = s.substring(0, 15) + "..."), A.textContent = s;
      }
    }
  }
  async _renderNodeChildren(A, e, t, o) {
    if (e.children && Array.isArray(e.children))
      for (const r of e.children) {
        if (r && typeof r == "object" && this._isDSLOperation(r)) {
          const g = Object.keys(r)[0];
          throw new Error(`[ViewEngine] Conditional logic (${g}) is not allowed in view templates. Use state machines to compute boolean flags and reference them via context, then use data-attributes and CSS.`);
        }
        const s = await this.renderNode(r, t, o);
        s && A.appendChild(s);
      }
  }
  async _resolveDataAttributes(A, e, t) {
    if (typeof A == "string") {
      if (this._containsConditionalLogic(A))
        throw new Error(`[ViewEngine] Conditional logic is not allowed in data attributes. Use state machines to compute boolean flags and reference them via context. Found: ${A}`);
      if (A.includes(".$$")) {
        const [o, r] = A.split("."), s = await this.evaluator.evaluate(o, e), g = await this.evaluator.evaluate(r, e);
        if (s && typeof s == "object" && g) {
          const n = s[g];
          if (n != null) {
            const a = o.substring(1), I = `data-${this._toKebabCase(a)}`;
            t.setAttribute(I, String(n));
          }
        }
      } else {
        const o = await this.evaluator.evaluate(A, e);
        if (o != null) {
          const r = A.startsWith("$$") ? A.substring(2) : A.substring(1), s = `data-${this._toKebabCase(r)}`;
          t.setAttribute(s, String(o));
        }
      }
    } else if (typeof A == "object" && A !== null)
      for (const [o, r] of Object.entries(A)) {
        if (typeof r == "object" && r !== null && this._isDSLOperation(r))
          throw new Error(`[ViewEngine] Conditional logic (${Object.keys(r)[0]}) is not allowed in data attributes. Use state machines to compute boolean flags and reference them via context.`);
        if (typeof r == "string" && r.includes("?") && r.includes(":"))
          throw new Error("[ViewEngine] Ternary operators are not allowed in views. Use state machines to compute values and reference them via context.");
        let s;
        if (typeof r == "string" && r.includes(".$$")) {
          const [g, n] = r.split("."), a = await this.evaluator.evaluate(g, e), I = await this.evaluator.evaluate(n, e);
          a && typeof a == "object" && I && (s = a[I]);
        } else
          s = await this.evaluator.evaluate(r, e);
        if (s != null) {
          const g = `data-${this._toKebabCase(o)}`;
          t.setAttribute(g, String(s));
        }
      }
  }
  /**
   * Check if a value contains conditional logic (DSL operations or ternary operators)
   * Views should only contain simple context/item references
   */
  _containsConditionalLogic(A) {
    return typeof A != "string" ? !1 : !!(A.includes("?") && A.includes(":"));
  }
  /**
   * Check if a value is a DSL operation (conditional logic)
   */
  _isDSLOperation(A) {
    if (!A || typeof A != "object" || Array.isArray(A)) return !1;
    const e = Object.keys(A);
    if (e.length === 0) return !1;
    const t = e[0];
    return t.startsWith("$") ? ["$if", "$eq", "$ne", "$and", "$or", "$not", "$switch", "$gt", "$lt", "$gte", "$lte"].includes(t) : !1;
  }
  _toKebabCase(A) {
    return A.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
  }
  async _renderSlot(A, e, t, o) {
    const r = A.$slot;
    if (!r || !r.startsWith("$")) {
      console.warn(`[ViewEngine] Slot key must start with $: ${r}`);
      return;
    }
    const s = r.slice(1), g = e.context || {}, n = g[s];
    if (!n) {
      console.warn(`[ViewEngine] No context value for slot key: ${s}`, {
        actorId: o,
        availableKeys: Object.keys(g || {}),
        contextType: "ReactiveStore"
      });
      return;
    }
    let a;
    if (typeof n == "string" && n.startsWith("@")) {
      a = n.slice(1);
      const c = g["@actors"];
      c && !c[a] && console.warn(`[ViewEngine] Namekey "${a}" not found in context["@actors"]`, {
        actorId: o,
        contextKey: s,
        contextValue: g,
        availableActors: c ? Object.keys(c) : []
      });
    } else {
      t.textContent = String(g);
      return;
    }
    const I = this.actorEngine?.getActor(o);
    if (!I) {
      console.warn(`[ViewEngine] Parent actor not found: ${o}`);
      return;
    }
    let C = I.children?.[a];
    if (!C) {
      const c = I.vibeKey || null;
      if (C = await this.actorEngine._createChildActorIfNeeded(I, a, c), !C) {
        I._renderState === lA.READY && console.warn(`[ViewEngine] Failed to create child actor for namekey: ${a}`, {
          actorId: o,
          availableChildren: I?.children ? Object.keys(I.children) : [],
          contextValue: g,
          namekey: a
        });
        return;
      }
    }
    if (C.containerElement) {
      if (I?.children)
        for (const [c, B] of Object.entries(I.children))
          c !== a && B.actorType === "ui" && (this.actorEngine.destroyActor(B.id), delete I.children[c]);
      C._renderState === lA.READY && this.actorEngine && (C._renderState = lA.UPDATING, this.actorEngine._scheduleRerender(C.id)), C.containerElement.parentNode !== t && (C.containerElement.parentNode && C.containerElement.parentNode.removeChild(C.containerElement), t.innerHTML = "", t.appendChild(C.containerElement));
    } else
      console.warn(`[ViewEngine] Child actor ${a} has no containerElement`, {
        actorId: o,
        namekey: a,
        childActorId: C.id
      });
  }
  async renderEach(A, e, t) {
    const o = document.createDocumentFragment(), r = await this.evaluator.evaluate(A.items, e);
    if (!r || !Array.isArray(r) || r.length === 0)
      return o;
    for (let s = 0; s < r.length; s++) {
      const g = r[s], n = {
        context: e.context,
        item: g,
        index: s
      }, a = await this.renderNode(A.template, n, t);
      a && o.appendChild(a);
    }
    return o;
  }
  attachEvents(A, e, t, o) {
    for (const [r, s] of Object.entries(e))
      A.addEventListener(r, async (g) => {
        try {
          await this._handleEvent(g, s, t, A, o);
        } catch (n) {
          console.error(`[ViewEngine] Error handling event ${r}:`, n);
        }
      });
  }
  async _handleEvent(A, e, t, o, r) {
    const s = e.send;
    let g = e.payload || {};
    if ((A.type === "dragover" || A.type === "drop" || A.type === "dragenter") && (A.preventDefault(), A.type === "dragover" && (A.dataTransfer.dropEffect = "move")), s === "STOP_PROPAGATION") {
      A.stopPropagation();
      return;
    }
    if (e.key && A.key !== e.key || s === "UPDATE_INPUT" && A.type === "input")
      return;
    const n = s === "UPDATE_INPUT" || s === "UPDATE_AGENT_INPUT";
    if (this.actorEngine) {
      const a = this.actorEngine.getActor(r);
      if (a && a.machine) {
        g = jr(g, o);
        const I = a.context.value, C = {
          context: I,
          item: t.item || {},
          result: null
          // $$result not available in view events (only in state machine actions after tool execution)
        };
        if (g = await ot(g, this.evaluator, C), rt(g))
          throw new Error(`[ViewEngine] Payload contains unresolved expressions. Views must resolve all expressions before sending to inbox. Payload: ${JSON.stringify(g).substring(0, 200)}`);
        if (n && A.type === "blur" && g && typeof g == "object") {
          let c = !0;
          for (const [B, Q] of Object.entries(g)) {
            const f = I[B];
            if (Q !== f) {
              c = !1;
              break;
            }
          }
          if (c)
            return;
        }
        await this.actorEngine.sendInternalEvent(r, s, g), n || this._clearInputFields(o, r);
      } else
        console.warn(`Cannot send event ${s}: Actor has no state machine`);
    } else
      console.warn("No actorEngine set, cannot handle event:", s);
  }
  /**
   * Clear all input and textarea fields in the form containing the element
   * If no form found, clears inputs in the actor's shadow root
   * @param {HTMLElement} element - The element that triggered the event
   * @param {string} actorId - The actor ID
   * @private
   */
  _clearInputFields(A, e) {
    let t = A.closest("form");
    if (!t && this.actorEngine) {
      const r = this.actorEngine.getActor(e);
      r && r.shadowRoot && (t = r.shadowRoot);
    }
    if (!t) return;
    t.querySelectorAll("input, textarea").forEach((r) => {
      r.hasAttribute("data-actor-input") && (r.tagName === "INPUT" || r.tagName === "TEXTAREA") && (r.value = "");
    });
  }
  setActorEngine(A) {
    this.actorEngine = A;
  }
  cleanupActor(A) {
  }
}
function Xy(i, A) {
  if (!(!i || !A))
    return A.split(".").reduce((e, t) => e?.[t], i);
}
class AD {
  constructor() {
    this.cache = /* @__PURE__ */ new Map(), this.dbEngine = null;
  }
  resolveStyleRef(A) {
    if (!A || !A.startsWith("co_z"))
      throw new Error(`[StyleEngine] Style reference must be a co-id (starts with 'co_z'), got: ${A}`);
    return A;
  }
  deepMerge(A, e) {
    const t = { ...A };
    for (const o in e)
      e[o] instanceof Object && !Array.isArray(e[o]) && o in A ? t[o] = this.deepMerge(A[o], e[o]) : t[o] = e[o];
    return t;
  }
  _interpolateTokens(A, e) {
    return typeof A != "string" ? A : A.replace(/\{([^}]+)\}/g, (t, o) => {
      const r = Xy(e, o);
      return r !== void 0 ? r : t;
    });
  }
  _toKebabCase(A) {
    return A.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
  }
  /**
   * Convert camelCase class selectors to kebab-case
   * Preserves special selectors (:host, @container, @media, pseudo-selectors)
   * @param {string} selector - CSS selector (e.g., ".todoCategory", ":host", ".buttonViewSwitch:hover")
   * @returns {string} Converted selector (e.g., ".todo-category", ":host", ".button-view-switch:hover")
   */
  _toKebabCaseSelector(A) {
    return !A || typeof A != "string" || A.startsWith(":host") || A.startsWith("@container") || A.startsWith("@media") || A.startsWith("@") ? A : A.replace(/\.([a-zA-Z][a-zA-Z0-9]*)/g, (e, t) => `.${t.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase()}`);
  }
  compileModifierStyles(A, e) {
    return typeof A != "object" || A === null || Array.isArray(A) ? "" : Object.entries(A).map(([t, o]) => {
      const r = t.replace(/([A-Z])/g, "-$1").toLowerCase(), s = this._interpolateTokens(o, e);
      return `  ${r}: ${s};`;
    }).join(`
`);
  }
  _flattenTokens(A, e = "") {
    const t = {};
    for (const [o, r] of Object.entries(A)) {
      const s = e ? `${e}-${o}` : o;
      typeof r == "object" && r !== null && !Array.isArray(r) ? Object.assign(t, this._flattenTokens(r, s)) : t[`--${s}`] = r;
    }
    return t;
  }
  compileTokensToCSS(A, e = null) {
    const t = this._flattenTokens(A), o = Object.entries(t).map(([g, n]) => `  ${g}: ${n};`).join(`
`);
    let r = "";
    A.typography?.fontFaces && Array.isArray(A.typography.fontFaces) && (r = A.typography.fontFaces.map((g) => `@font-face {
${Object.entries(g).map(([a, I]) => `  ${a.replace(/([A-Z])/g, "-$1").toLowerCase()}: ${I};`).join(`
`)}
}`).join(`

`) + `

`);
    let s = "";
    return e ? s = `  container-type: inline-size;
  container-name: ${e.replace(/[^a-zA-Z0-9-_]/g, "-").replace(/-+/g, "-")};
` : s = `  container-type: inline-size;
`, `${r}:host {
${s}${o}
}
`;
  }
  _compileDataAttributeSelectors(A, e, t, o = "") {
    const r = [];
    if (!e || typeof e != "object" || Array.isArray(e)) return r;
    for (const [s, g] of Object.entries(e)) {
      if (typeof g != "object" || g === null || Array.isArray(g)) continue;
      const n = this._toKebabCase(s);
      for (const [a, I] of Object.entries(g)) {
        if (typeof I != "object" || I === null || Array.isArray(I)) continue;
        const C = this._toKebabCase(a), c = `[data-${n}="${C}"]`, B = `${A}${o}${c}`, Q = {}, f = {};
        let l = null;
        for (const [d, u] of Object.entries(I))
          d === "data" ? l = u : d.startsWith(":") ? f[d] = u : Q[d] = u;
        Object.keys(Q).length > 0 && r.push(`${B} {
${this.compileModifierStyles(Q, t)}
}`);
        for (const [d, u] of Object.entries(f))
          r.push(`${B}${d} {
${this.compileModifierStyles(u, t)}
}`);
        l && typeof l == "object" && !Array.isArray(l) && r.push(...this._compileDataAttributeSelectors(A, l, t, `${o}${c}`));
      }
    }
    return r;
  }
  compileComponentsToCSS(A, e) {
    if (!A || Object.keys(A).length === 0) return "";
    const t = [];
    for (const [o, r] of Object.entries(A)) {
      const s = o.replace(/([A-Z])/g, "-$1").toLowerCase(), g = r.data, n = { ...r };
      delete n.data;
      const a = {}, I = {};
      for (const [C, c] of Object.entries(n))
        C.startsWith(":") || C.startsWith("[") || typeof c == "object" && c !== null && !Array.isArray(c) ? I[C] = c : a[C] = c;
      if (Object.keys(a).length > 0) {
        const C = Object.entries(a).map(([B, Q]) => `  ${B.replace(/([A-Z])/g, "-$1").toLowerCase()}: ${this._interpolateTokens(Q, e)};`).join(`
`), c = `.${s} {
${C}
}`;
        t.push(c);
      }
      for (const [C, c] of Object.entries(I)) {
        let B;
        C.startsWith(":") ? B = `.${s}${C}` : C.startsWith("[") ? B = `.${s}${C}` : C.includes(" ") ? B = `.${s} ${C}` : B = `.${s}[${C}]`, t.push(`${B} {
${this.compileModifierStyles(c, e)}
}`);
      }
      g && typeof g == "object" && !Array.isArray(g) && t.push(...this._compileDataAttributeSelectors(`.${s}`, g, e));
    }
    return t.join(`

`);
  }
  compileSelectors(A, e) {
    if (!A || Object.keys(A).length === 0) return "";
    const t = [];
    for (const [o, r] of Object.entries(A)) {
      const s = this._interpolateTokens(o, e);
      if (s.startsWith("@container") || s.startsWith("@media")) {
        const n = [];
        for (const [a, I] of Object.entries(r))
          if (typeof I == "object" && I !== null && !Array.isArray(I))
            if (a.startsWith("@container") || a.startsWith("@media")) {
              const c = this._interpolateTokens(a, e), B = this.compileSelectors({ [c]: I }, e);
              n.push(B.split(`
`).map((Q) => `  ${Q}`).join(`
`));
            } else {
              const c = this._toKebabCaseSelector(a), B = Object.entries(I).map(([Q, f]) => `    ${Q.replace(/([A-Z])/g, "-$1").toLowerCase()}: ${this._interpolateTokens(f, e)};`).join(`
`);
              n.push(`  ${c} {
${B}
  }`);
            }
        t.push(`${s} {
${n.join(`
`)}
}`);
      } else {
        const n = this._toKebabCaseSelector(s), a = Object.entries(r).map(([I, C]) => `  ${I.replace(/([A-Z])/g, "-$1").toLowerCase()}: ${this._interpolateTokens(C, e)};`).join(`
`);
        t.push(`${n} {
${a}
}`);
      }
    }
    return t.join(`

`);
  }
  compileToCSS(A, e, t = {}, o = "", r = null) {
    let s = `${this.compileTokensToCSS(A, r)}
${this.compileComponentsToCSS(e, A)}`;
    const g = this.compileSelectors(t, A);
    return g && (s += `

/* State-based selectors */
${g}`), o && (s += `

/* Raw CSS fallback */
${o}`), s;
  }
  async getStyleSheets(A, e = null) {
    const t = A.brand, o = A.style;
    if (!t)
      throw new Error(`[StyleEngine] Actor config must have 'brand' property with co-id. Config keys: ${Object.keys(A).join(", ")}. Config: ${JSON.stringify(A, null, 2)}`);
    const r = e || A.$id || A.id || "actor", s = `${t}_${o || "none"}_${r}`;
    if (this.cache.has(s))
      return this.cache.get(s);
    const g = this.resolveStyleRef(t), n = await eA(this.dbEngine.backend, { fromCoValue: g }, { returnType: "coId" }), I = (await this.dbEngine.execute({ op: "read", schema: n, key: g })).value;
    let C = { tokens: {}, components: {} };
    if (o) {
      const p = this.resolveStyleRef(o), y = await eA(this.dbEngine.backend, { fromCoValue: p }, { returnType: "coId" });
      C = (await this.dbEngine.execute({ op: "read", schema: y, key: p })).value;
    }
    const c = r.replace(/[^a-zA-Z0-9-_]/g, "-").replace(/-+/g, "-"), B = {
      containers: {
        xs: "240px",
        sm: "360px",
        md: "480px",
        lg: "640px",
        xl: "768px",
        "2xl": "1024px"
      },
      containerName: c
      // Inject container name so queries can reference root :host container
    }, Q = this.deepMerge(B, I.tokens || {}), f = this.deepMerge(Q, C.tokens || {}), l = this.deepMerge(I.components || {}, C.components || {}), d = this.deepMerge(I.selectors || {}, C.selectors || {}), u = [I.rawCSS, C.rawCSS].filter(Boolean).join(`

`), h = this.compileToCSS(f, l, d, u, c), w = new CSSStyleSheet();
    w.replaceSync(h);
    const E = [w];
    return this.cache.set(s, E), E;
  }
  clearCache() {
    this.cache.clear();
  }
}
class eD {
  constructor(A, e, t = null) {
    this.toolEngine = A, this.evaluator = e, this.actorEngine = t, this.machines = /* @__PURE__ */ new Map(), this.dbEngine = null;
  }
  async createMachine(A, e) {
    const t = `${e.id}_machine`;
    let o = A.initial;
    const r = e.context?.value?._currentState;
    r && typeof r == "string" && A.states?.[r] && (o = r);
    const s = {
      id: t,
      definition: A,
      actor: e,
      currentState: o,
      history: [],
      eventPayload: {}
    };
    return this.machines.set(t, s), s._isInitialCreation = !0, await this._executeEntry(s, o), s._isInitialCreation = !1, s;
  }
  async send(A, e, t = {}) {
    const o = this.machines.get(A);
    if (!o) {
      console.warn(`[StateEngine] Machine not found: ${A}`);
      return;
    }
    o.eventPayload = t || {};
    const r = o.definition.states[o.currentState];
    if (!r) {
      console.warn(`[StateEngine] State definition not found for state: ${o.currentState}`);
      return;
    }
    const s = (r.on || {})[e];
    if (!s) {
      console.warn(`[StateEngine] No transition handler for event '${e}' in state '${o.currentState}'`);
      return;
    }
    await this._executeTransition(o, s, e, t);
  }
  async _executeTransition(A, e, t, o) {
    A.eventPayload || (A.eventPayload = o || {}), t === "SUCCESS" && (A.lastToolResult = o.result || null);
    const r = typeof e == "string" ? e : e.target, s = typeof e == "object" ? e.guard : null, g = typeof e == "object" ? e.actions : null;
    if (s != null && !await this._evaluateGuard(s, A.actor.context, A.eventPayload, A.actor))
      return;
    await this._executeExit(A, A.currentState), g && await this._executeActions(A, g, A.eventPayload), A.history.push({ from: A.currentState, to: r, event: t, timestamp: Date.now() });
    const n = A.currentState;
    if (A.currentState = r, A.actor.contextCoId && A.actor.actorEngine)
      try {
        await A.actor.actorEngine.updateContextCoValue(A.actor, { _currentState: r });
      } catch (C) {
        console.warn("[StateEngine] Failed to persist _currentState to context:", C.message);
      }
    const a = A.eventPayload;
    n !== r && (A.eventPayload = a, await this._executeEntry(A, r)), n !== r && r !== "dragging" && !A._isInitialCreation && !(n === "init" && r === "idle") && A.actor._renderState === lA.READY && A.actor.actorEngine && (A.actor._renderState = lA.UPDATING, A.actor.actorEngine._scheduleRerender(A.actor.id));
  }
  /**
   * Clean tool result by removing CoJSON metadata (groupInfo)
   * Tool results from database operations include groupInfo which is metadata, not data
   * @param {any} result - Tool result (can be any type)
   * @returns {any} Cleaned result without groupInfo
   */
  _cleanToolResult(A) {
    if (!A || typeof A != "object")
      return A;
    if (Array.isArray(A))
      return A.map((r) => this._cleanToolResult(r));
    const { groupInfo: e, ...t } = A, o = {};
    for (const [r, s] of Object.entries(t))
      o[r] = this._cleanToolResult(s);
    return o;
  }
  /**
   * Evaluate guard using JSON Schema validation
   * Guards check state/context conditions (NOT payload validation)
   * 
   * CRITICAL ARCHITECTURAL SEPARATION:
   * - Guards are for CONDITIONAL LOGIC (should transition happen given current state/context?)
   * - Payload validation happens in ActorEngine BEFORE reaching state machine
   * 
   * @param {Object} guard - Guard definition with schema property
   * @param {ReactiveStore} context - Actor context (ReactiveStore)
   * @param {Object} payload - Event payload (NOT validated here - already validated in ActorEngine)
   * @param {Object} actor - Actor instance (for state access)
   * @returns {Promise<boolean>} True if guard passes, false otherwise
   */
  async _evaluateGuard(A, e, t, o = null) {
    if (typeof A == "boolean") return A;
    if (!A || typeof A != "object" || !A.schema)
      return console.warn('[StateEngine] Guard must be an object with a "schema" property. Guards are schema-based only (no MaiaScript expressions).', { guard: A }), !1;
    try {
      const r = e.value, s = {
        state: o?.machine?.currentState || null,
        ...r
      };
      return (await jt(A.schema, s, "guard")).valid;
    } catch (r) {
      return console.error("[StateEngine] Guard evaluation error:", r), !1;
    }
  }
  async _executeStateActions(A, e, t) {
    try {
      if (!A || !A.definition || !A.definition.states) {
        console.warn("[StateEngine] Invalid machine or definition in _executeStateActions", { machine: A, stateName: e, type: t });
        return;
      }
      if (!e || typeof e != "string") {
        console.warn("[StateEngine] Invalid stateName in _executeStateActions", { stateName: e, type: t });
        return;
      }
      const o = A.definition.states[e];
      if (!o || typeof o != "object") {
        console.warn("[StateEngine] State not found or invalid in definition", {
          stateName: e,
          stateDef: o,
          availableStates: Object.keys(A.definition.states || {})
        });
        return;
      }
      if (t == null || typeof t != "string") {
        console.warn("[StateEngine] Type is undefined/null or not a string in _executeStateActions", { stateName: e, type: t, typeOf: typeof t });
        return;
      }
      const r = o?.[t];
      if (!r)
        return;
      if (!A.actor) {
        console.warn("[StateEngine] Machine has no actor in _executeStateActions", { machineId: A.id, stateName: e, type: t });
        return;
      }
      if (r.tool) {
        const s = t === "entry", g = await this._invokeTool(A, r.tool, r.payload, !0, s);
        if (g && Ve(g) && (A.lastToolResult = g.data), s && Ve(g) && o.on?.SUCCESS && A.actor?.actorEngine) {
          const n = A.eventPayload || {}, a = A.lastToolResult != null ? this._cleanToolResult(A.lastToolResult) : null, I = {
            ...n,
            result: a
          };
          try {
            await A.actor.actorEngine.sendInternalEvent(A.actor.id, "SUCCESS", I);
          } catch (C) {
            console.error("[StateEngine]  Failed to send SUCCESS event:", C);
          }
        }
      } else if (Array.isArray(r)) {
        const s = A.eventPayload || {};
        if (await this._executeActions(A, r, A.eventPayload), t === "entry" && o.on?.SUCCESS && A.actor?.actorEngine) {
          const n = A.lastToolResult ? this._cleanToolResult(A.lastToolResult) : null, a = {
            ...s,
            result: n
            // CRITICAL: result must come AFTER spread to override any result in originalEventPayload
          };
          try {
            await A.actor.actorEngine.sendInternalEvent(A.actor.id, "SUCCESS", a);
          } catch (I) {
            console.error("[StateEngine]  Failed to send SUCCESS event:", I);
          }
        }
      } else if (typeof r == "object" && r !== null) {
        const s = A.eventPayload || {};
        if (await this._executeActions(A, r, A.eventPayload), t === "entry" && o.on?.SUCCESS && A.actor?.actorEngine) {
          const g = A.lastToolResult ? this._cleanToolResult(A.lastToolResult) : null, n = {
            ...s,
            result: g
            // CRITICAL: result must come AFTER spread to override any result in originalEventPayload
          };
          await A.actor.actorEngine.sendInternalEvent(A.actor.id, "SUCCESS", n);
        }
      }
    } catch (o) {
      console.error("[StateEngine] Error in _executeStateActions", {
        error: o.message,
        stack: o.stack,
        machineId: A?.id,
        stateName: e,
        type: t,
        machine: A ? { id: A.id, hasActor: !!A.actor, hasDefinition: !!A.definition } : null
      });
    }
  }
  async _executeEntry(A, e) {
    await this._executeStateActions(A, e, "entry");
  }
  async _executeExit(A, e) {
    await this._executeStateActions(A, e, "exit");
  }
  _sanitizeUpdates(A, e = {}) {
    return typeof A == "string" && A === "$$result" ? e : typeof A != "object" || A === null || Array.isArray(A) ? {} : Object.fromEntries(Object.entries(A).map(([t, o]) => [t, o === void 0 ? null : o]));
  }
  async _executeActions(A, e, t = {}) {
    if (!A || !A.actor) {
      console.warn("[StateEngine] Machine has no actor in _executeActions", { machineId: A?.id });
      return;
    }
    Array.isArray(e) || (e = [e]);
    const o = {};
    for (const r of e)
      if (typeof r == "string")
        await this._executeNamedAction(A, r, t);
      else if (r?.mapData)
        await this._executeMapData(A, r.mapData, t);
      else if (r?.updateContext) {
        const s = await this._evaluatePayload(r.updateContext, A.actor.context, t, A.lastToolResult, A.actor);
        Object.assign(o, this._sanitizeUpdates(s, A.lastToolResult || {}));
      } else if (r?.tool) {
        const s = await this._invokeTool(A, r.tool, r.payload, !1);
        if (s && Ve(s) && (A.lastToolResult = s.data), r.onSuccess?.updateContext && Ve(s)) {
          const g = await this._evaluatePayload(r.onSuccess.updateContext, A.actor.context, A.eventPayload, s.data, A.actor);
          Object.assign(o, this._sanitizeUpdates(g, s.data || {}));
        }
      }
    Object.keys(o).length > 0 && A.actor?.actorEngine && await A.actor.actorEngine.updateContextCoValue(A.actor, o);
  }
  /**
   * Execute mapData action - map operations engine configs to context keys
   * Universal API that supports any operation (read, create, update, etc.)
   * @param {Object} machine - State machine instance
   * @param {Object} mapData - Map of context keys to operation configs: { contextKey: { op: 'read', schema: '...', ... } }
   * @param {Object} payload - Event payload for expression evaluation
   */
  async _executeMapData(A, e, t = {}) {
    if (!A || !A.actor) {
      console.warn("[StateEngine] Machine has no actor in _executeMapData", { machineId: A?.id });
      return;
    }
    if (!this.dbEngine) {
      console.error("[StateEngine] Cannot execute mapData: dbEngine not available");
      return;
    }
    if (!e || typeof e != "object") {
      console.error("[StateEngine] mapData must be an object mapping context keys to operation configs", { mapData: e });
      return;
    }
    for (const [o, r] of Object.entries(e)) {
      if (!o || typeof o != "string") {
        console.error("[StateEngine] mapData context keys must be strings", { contextKey: o, operationConfig: r });
        continue;
      }
      if (!r || typeof r != "object") {
        console.error("[StateEngine] mapData operation config must be an object", { contextKey: o, operationConfig: r });
        continue;
      }
      const s = await this._evaluatePayload(
        r,
        A.actor.context,
        t,
        A.lastToolResult,
        A.actor
      ), { op: g = "read", ...n } = s;
      if (!g || typeof g != "string") {
        console.error('[StateEngine] mapData operation config must have an "op" property', { contextKey: o, operationConfig: r });
        continue;
      }
      if (n.schema && typeof n.schema == "string" && !n.schema.startsWith("co_z"))
        if (MA(n.schema))
          try {
            const a = await this.dbEngine.execute({ op: "resolve", humanReadableKey: n.schema });
            if (a?.startsWith("co_z"))
              n.schema = a;
            else {
              console.error(`[StateEngine] Failed to resolve schema ${n.schema} for context key ${o}`);
              continue;
            }
          } catch (a) {
            console.error(`[StateEngine] Error resolving schema ${n.schema} for context key ${o}:`, a);
            continue;
          }
        else {
          console.error(`[StateEngine] Invalid schema format for context key ${o}: ${n.schema}. Expected co-id or @domain/schema/... pattern.`);
          continue;
        }
      try {
        const a = { op: g, ...n }, I = await this.dbEngine.execute(a);
        if (I && typeof I == "object" && typeof I.subscribe == "function" && "value" in I) {
          const C = A.actor;
          if (C && C.contextCoId && C.contextSchemaCoId && this.actorEngine) {
            const c = e[o];
            c && c.op === "read" && c.schema && await this.actorEngine.updateContextCoValue(C, {
              [o]: {
                schema: c.schema,
                filter: c.filter || null,
                options: c.options || null
              }
            });
          }
        } else
          console.warn(`[StateEngine] mapData operation "${g}" did not return a ReactiveStore. Mutations should use tool calls instead.`);
      } catch (a) {
        console.error(`[StateEngine] Failed to execute ${g} operation for context key ${o}:`, a);
      }
    }
  }
  async _executeNamedAction(A, e, t) {
    const r = {
      resetError: { error: null },
      setLoading: { isLoading: !0 },
      clearLoading: { isLoading: !1 }
    }[e];
    if (r && await A.actor.actorEngine.updateContextCoValue(A.actor, r), e === "sendToDetailActor") {
      const s = t?.sparkId || A.actor.context.value?.selectedSparkId;
      if (s && A.actor?.children?.detail) {
        const g = A.actor.children.detail;
        await A.actor.actorEngine.sendMessage(g.id, {
          type: "LOAD_ACTOR",
          payload: { id: s },
          from: A.actor.id
        });
      }
    }
  }
  async _invokeTool(A, e, t = {}, o = !0, r = !1) {
    const s = A.eventPayload || {}, g = A.definition.states[A.currentState];
    try {
      const n = await this._evaluatePayload(t, A.actor.context, A.eventPayload || {}, A.lastToolResult, A.actor), a = await this.toolEngine.execute(e, A.actor, n);
      if (!Ve(a))
        return o && g?.on?.ERROR && A.actor?.actorEngine ? await A.actor.actorEngine.sendInternalEvent(A.actor.id, "ERROR", { errors: a.errors }) : o && !g?.on?.ERROR && console.warn(`[StateEngine] No ERROR handler for ${e} in state ${A.currentState}`), a;
      const I = a.data;
      if (A.lastToolResult = I, o && !r && g?.on?.SUCCESS && A.actor?.actorEngine) {
        const C = I != null ? this._cleanToolResult(I) : null;
        await A.actor.actorEngine.sendInternalEvent(A.actor.id, "SUCCESS", {
          ...s,
          result: C
        });
      }
      return a;
    } catch (n) {
      if (console.error(`[StateEngine] Tool execution failed: ${e}`, {
        error: n.message,
        stack: n.stack,
        currentState: A.currentState,
        autoTransition: o
      }), o && g?.on?.ERROR && A.actor?.actorEngine) {
        const a = n.errors ?? [
          wA(Ks(n) ? "permission" : "structural", n.message)
        ];
        await A.actor.actorEngine.sendInternalEvent(A.actor.id, "ERROR", { errors: a });
      } else o && !g?.on?.ERROR && console.warn(`[StateEngine] No ERROR handler for ${e} in state ${A.currentState}`);
      throw n;
    }
  }
  async _evaluatePayload(A, e, t = {}, o = null, r = null) {
    const s = e.value, g = t?.result || o || null, n = { context: s, item: t || {}, result: g };
    return await ot(A, this.evaluator, n);
  }
  getCurrentState(A) {
    return this.machines.get(A)?.currentState || null;
  }
  getMachine(A) {
    return this.machines.get(A) || null;
  }
  destroyMachine(A) {
    this.machines.delete(A);
  }
}
class tD {
  constructor(A) {
    this.moduleRegistry = A, this.tools = /* @__PURE__ */ new Map();
  }
  async registerTool(A, e, t = {}) {
    !t.definition || !t.function || this.tools.set(e, { definition: t.definition, function: t.function, namespacePath: A });
  }
  async execute(A, e, t) {
    const o = this.tools.get(A);
    if (!o) {
      const s = Array.from(this.tools.keys());
      throw console.error(`[ToolEngine] Tool not found: ${A}`, {
        availableTools: s,
        totalTools: s.length
      }), new Error(`Tool not found: ${A}. Available tools: ${s.join(", ")}`);
    }
    const r = o.definition.parameters || o.definition.params;
    return r && await nt(this._normalizeToolSchema(r), t, "tool-payload"), await o.function.execute(e, t);
  }
  _normalizeToolSchema(A) {
    const e = (g) => {
      const n = {}, a = [];
      for (const [I, C] of Object.entries(g))
        if (C && typeof C == "object" && C.type !== "function") {
          const { required: c, type: B, ...Q } = C;
          n[I] = { type: B, ...Q }, c === !0 && a.push(I);
        } else C && typeof C == "object" && (n[I] = C);
      return { cleaned: n, required: a };
    };
    if (A.type === "object" && !A.properties) return A;
    const t = A.properties || A, { cleaned: o, required: r } = e(t), s = Array.isArray(A.required) ? A.required : [];
    return {
      type: "object",
      properties: o,
      required: [.../* @__PURE__ */ new Set([...s, ...r])]
    };
  }
  getToolDefinition(A) {
    return this.tools.get(A)?.definition || null;
  }
  getAllTools() {
    return Array.from(this.tools.values()).map((A) => A.definition);
  }
}
function de(i, A) {
  if (!(!i || !A))
    return A.split(".").reduce((e, t) => e?.[t], i);
}
class Vr {
  constructor(A = null, e = {}) {
    this.registry = A, this.maxDepth = e.maxDepth || 50, this.validateExpressions = e.validateExpressions !== !1, this.dbEngine = e.dbEngine || null;
  }
  /**
   * Evaluate a MaiaScript expression
   * @param {any} expression - The expression to evaluate
   * @param {Object} data - The data context { context, item }
   * @param {number} depth - Current recursion depth (internal)
   * @returns {Promise<any>} The evaluated result
   */
  async evaluate(A, e, t = 0) {
    if (t > this.maxDepth)
      throw new Error(`[Evaluator] Maximum recursion depth (${this.maxDepth}) exceeded. Expression may be malicious or too complex.`);
    if (this.validateExpressions && t === 0 && typeof A == "object" && A !== null && !Array.isArray(A))
      try {
        const { getSchema: o } = await Promise.resolve().then(() => Wt), r = o("maia-script-expression");
        r && await nt(r, A, "maia-script-expression");
      } catch (o) {
        throw console.error("[Evaluator] Expression validation failed:", o), new Error(`[Evaluator] Invalid MaiaScript expression: ${o.message}`);
      }
    if (typeof A == "number" || typeof A == "boolean" || A === null || A === void 0)
      return A;
    if (typeof A == "string" && A.startsWith("$"))
      return this.evaluateShortcut(A, e);
    if (typeof A != "object") return A;
    if ("$context" in A)
      return de(e.context, A.$context);
    if ("$item" in A)
      return de(e.item, A.$item);
    if ("$eq" in A) {
      const [o, r] = A.$eq, s = await this.evaluate(o, e, t + 1), g = await this.evaluate(r, e, t + 1);
      return s === g;
    }
    if ("$ne" in A) {
      const [o, r] = A.$ne, s = await this.evaluate(o, e, t + 1), g = await this.evaluate(r, e, t + 1);
      return s !== g;
    }
    if ("$not" in A)
      return !await this.evaluate(A.$not, e, t + 1);
    if ("$and" in A) {
      const o = Array.isArray(A.$and) ? A.$and : [A.$and];
      for (const r of o)
        if (!await this.evaluate(r, e, t + 1))
          return !1;
      return !0;
    }
    if ("$or" in A) {
      const o = Array.isArray(A.$or) ? A.$or : [A.$or];
      for (const r of o)
        if (await this.evaluate(r, e, t + 1))
          return !0;
      return !1;
    }
    if ("$trim" in A) {
      const o = await this.evaluate(A.$trim, e, t + 1);
      return typeof o == "string" ? o.trim() : o;
    }
    if ("$gt" in A) {
      const [o, r] = A.$gt, s = await this.evaluate(o, e, t + 1), g = await this.evaluate(r, e, t + 1);
      return s > g;
    }
    if ("$length" in A) {
      const o = await this.evaluate(A.$length, e, t + 1);
      return Array.isArray(o) || typeof o == "string" ? o.length : 0;
    }
    if ("$concat" in A) {
      const o = Array.isArray(A.$concat) ? A.$concat : [A.$concat];
      return (await Promise.all(o.map((g) => this.evaluate(g, e, t + 1)))).filter((g) => g != null).map((g) => Array.isArray(g) ? g : [g]).flat();
    }
    if ("$map" in A) {
      const o = A.$map, r = await this.evaluate(o.array, e, t + 1);
      if (!r || !Array.isArray(r))
        return [];
      const s = o.as || "item", g = o.return || o.do;
      if (!g)
        throw new Error('[Evaluator] $map operation requires either "return" or "do" property');
      const n = [];
      for (const a of r) {
        const I = {
          ...e,
          item: a
        }, C = await this.evaluateMapReturn(g, I, s, a, t + 1);
        n.push(C);
      }
      return n;
    }
    if ("$if" in A) {
      let o = A.$if.condition;
      return typeof o == "string" && o.startsWith("$") ? o = this.evaluateShortcut(o, e) : o = await this.evaluate(o, e, t + 1), o ? await this.evaluate(A.$if.then, e, t + 1) : await this.evaluate(A.$if.else, e, t + 1);
    }
    if (typeof A == "string" && A.includes("?") && A.includes(":")) {
      const [o, r] = A.split("?").map((s) => s.trim());
      if (r) {
        const [s, g] = r.split(":").map((a) => a.trim());
        return (o.startsWith("$") ? this.evaluateShortcut(o, e) : await this.evaluate(o, e, t + 1)) ? await this.evaluate(s, e, t + 1) : await this.evaluate(g, e, t + 1);
      }
    }
    return A;
  }
  /**
   * Evaluate return expression in $map context with custom item key
   * Handles shortcuts like $$msg.role when as="msg" by treating $$itemKey.path as item.path
   * @param {any} returnExpr - The return expression to evaluate
   * @param {Object} data - The data context { context, item, result }
   * @param {string} itemKey - The 'as' variable name (e.g., "msg")
   * @param {any} currentItem - The current array item being mapped
   * @param {number} depth - Current recursion depth
   * @returns {Promise<any>} The evaluated result
   */
  async evaluateMapReturn(A, e, t, o, r) {
    if (typeof A == "string" && A.startsWith("$$" + t + ".")) {
      const s = A.substring(2 + t.length + 1);
      return de(o, s);
    }
    if (typeof A == "object" && A !== null && !Array.isArray(A)) {
      const s = {};
      for (const [g, n] of Object.entries(A))
        if (typeof n == "string" && n.startsWith("$$" + t + ".")) {
          const a = n.substring(2 + t.length + 1);
          s[g] = de(o, a);
        } else
          s[g] = await this.evaluate(n, e, r + 1);
      return s;
    }
    return await this.evaluate(A, e, r + 1);
  }
  /**
   * Evaluate compact shortcut syntax: $key or $$key
   * v0.2 syntax:
   * - $key  context.key (implicit context)
   * - $$key  item.key (explicit item with double-dollar)
   * - $$result  result (tool result with double-dollar)
   * @param {string} shortcut - The shortcut string (e.g., "$title", "$$text", "$$result.draggedItemId")
   * @param {Object} data - The data context { context, item, result }
   * @returns {any} The evaluated result
   */
  evaluateShortcut(A, e) {
    if (A.startsWith("$$result")) {
      const r = A.substring(8);
      if (r.startsWith(".")) return de(e.result, r.substring(1));
      if (r === "") return e.result;
    }
    if (A.startsWith("$$"))
      return de(e.item, A.substring(2));
    const t = A.substring(1), o = de(e.context, t);
    return o instanceof pA ? o.value : o;
  }
  /**
   * Check if an expression is a DSL operation
   * @param {any} expression - The expression to check
   * @returns {boolean} True if it's a DSL operation
   */
  isDSLOperation(A) {
    return typeof A == "string" && A.startsWith("$") ? !0 : typeof A != "object" || A === null ? !1 : "$context" in A || "$item" in A || "$if" in A || "$eq" in A || "$ne" in A || "$not" in A || "$and" in A || "$or" in A || "$trim" in A || "$gt" in A || "$length" in A || "$concat" in A || "$map" in A;
  }
}
const iD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Evaluator: Vr
}, Symbol.toStringTag, { value: "Module" })), oD = {
  $schema: "@maia/schema/tool",
  $id: "tool_publish_message_001",
  name: "@core/publishMessage",
  description: "Publishes a message to subscribed actors",
  parameters: {
    type: "object",
    properties: {
      type: {
        type: "string",
        description: "Message type"
      },
      payload: {
        type: "object",
        description: "Message payload",
        required: !1
      }
    },
    required: ["type"]
  }
}, rD = {
  $schema: "@maia/schema/tool",
  $id: "@tool/core/computeMessageNames",
  name: "computeMessageNames",
  description: "Computes a lookup object mapping message IDs to display names based on role",
  parameters: {
    type: "object",
    properties: {
      conversations: {
        type: "array",
        description: "Array of conversation messages with id and role properties"
      }
    },
    required: ["conversations"]
  }
}, sD = {
  $schema: "@maia/schema/tool",
  $id: "tool_memory_001",
  name: "@memory",
  description: "Memory tool for interacting with Honcho - persistent agent memory system",
  parameters: {
    type: "object",
    properties: {
      op: {
        type: "string",
        enum: ["createSession", "addMessage", "getContext", "chat"],
        description: "Memory operation to execute"
      },
      workspaceId: {
        type: "string",
        description: "Honcho workspace ID (default: 'maiaos-dev')"
      },
      peerId: {
        type: "string",
        description: "Peer ID ('maia' for agent, 'samuel' for user)"
      },
      sessionId: {
        type: "string",
        description: "Session ID (required for addMessage, optional for chat)"
      },
      content: {
        type: "string",
        description: "Message content (required for addMessage)"
      },
      query: {
        type: "string",
        description: "Query for chat/getContext operations"
      },
      target: {
        type: "string",
        description: "Target peer ID for chat (optional, defaults to querying about the peer)"
      }
    },
    required: ["op"]
  }
}, gD = {
  $schema: "@maia/schema/tool",
  $id: "tool_ai_001",
  name: "@ai/chat",
  description: "Unified AI chat tool using OpenAI-compatible API (RedPill) for LLM interactions. Model can be configured dynamically via payload - RedPill API endpoint is hardcoded, but each call can specify which LLM model to query. LLMs are stateless - each request sends the full context (complete conversation history).",
  parameters: {
    type: "object",
    properties: {
      context: {
        type: "array",
        description: "Complete conversation context to send to the LLM. LLMs are stateless - this represents the full context/history for this request. Each request can have completely different context.",
        items: {
          type: "object",
          properties: {
            role: {
              type: "string",
              enum: ["system", "user", "assistant"],
              description: "Message role"
            },
            content: {
              type: "string",
              description: "Message content"
            }
          },
          required: ["role", "content"]
        }
      },
      model: {
        type: "string",
        description: "LLM model to query (dynamically configurable per call). Default: qwen/qwen3-30b-a3b-instruct-2507. The RedPill API endpoint is hardcoded, but you can specify any model available on RedPill.",
        default: "qwen/qwen3-30b-a3b-instruct-2507"
      },
      temperature: {
        type: "number",
        description: "Temperature for response (0-2, default: 1)",
        default: 1
      }
    },
    required: ["context"]
  }
}, nD = {
  $schema: "@maia/schema/tool",
  $id: "sparks",
  name: "@sparks",
  description: "Sparks tool for managing collaborative spaces (groups). Supports CRUD operations, member management, and parent group management.",
  schema: "@maia/schema/tool",
  params: {
    op: {
      type: "string",
      enum: [
        "createSpark",
        "readSpark",
        "updateSpark",
        "deleteSpark",
        "addSparkMember",
        "removeSparkMember",
        "addSparkParentGroup",
        "removeSparkParentGroup",
        "getSparkMembers",
        "updateSparkMemberRole"
      ],
      description: "Spark operation to execute"
    },
    name: {
      type: "string",
      description: "Spark name (required for createSpark operation)"
    },
    id: {
      type: "string",
      description: "Spark co-id (required for most operations)"
    },
    data: {
      type: "object",
      description: "Update data (name, group) - required for updateSpark operation"
    },
    schema: {
      type: "string",
      description: "Schema co-id (optional for readSpark, defaults to spark schema)"
    },
    memberId: {
      type: "string",
      description: "Member account/group co-id (required for addSparkMember, removeSparkMember, updateSparkMemberRole)"
    },
    role: {
      type: "string",
      enum: ["reader", "writer", "admin", "manager", "writeOnly"],
      description: "Member role (required for addSparkMember, updateSparkMemberRole)"
    },
    parentGroupId: {
      type: "string",
      description: "Parent group co-id (required for addSparkParentGroup, removeSparkParentGroup)"
    }
  },
  returns: {
    type: "any",
    description: "Operation result (created/updated/deleted spark, reactive store for reads, member/group management results)"
  }
}, aD = {
  $schema: "@maia/schema/tool",
  $id: "db",
  name: "Database Tool",
  description: "Unified API for all database operations (query, create, update, delete)",
  schema: "@maia/schema/tool",
  params: {
    op: {
      type: "string",
      enum: ["query", "create", "update", "delete", "seed"],
      description: "Database operation to execute"
    },
    schema: {
      type: "string",
      description: "Schema reference (co-id) - REQUIRED for 'create' operation only (no CoValue exists yet). OPTIONAL for 'update' and 'delete' operations (schema is extracted from CoValue headerMeta internally by operations)."
    },
    key: {
      type: "string",
      description: "Optional: Specific key for config queries"
    },
    filter: {
      type: "object",
      description: "Optional: Filter criteria for data queries"
    },
    callback: {
      description: "Optional: Callback function for reactive subscriptions (not validated - runtime only)"
    },
    id: {
      type: "string",
      description: "Optional: Record ID for update/delete operations"
    },
    data: {
      type: "object",
      description: "Optional: Data for create/update operations"
    }
  },
  returns: {
    type: "any",
    description: "Operation result (data, unsubscribe function, created/updated/deleted record, etc.)"
  }
}, ID = {
  async execute(i, A) {
    const { type: e, payload: t = {}, target: o } = A;
    return e ? o ? i.actorEngine ? o.startsWith("@actor/") ? fA([wA("structural", `[publishMessage] Target not transformed: ${o}. Should be a co-id. Check schema transformer.`)]) : (await i.actorEngine.sendMessage(o, {
      type: e,
      payload: t,
      from: i.id,
      timestamp: Date.now()
    }), bA({})) : fA([wA("structural", "[publishMessage] Actor has no actorEngine reference")]) : fA([wA("structural", "Target is required. Topics infrastructure removed - use direct messaging with target parameter.")]) : fA([wA("structural", "Message type is required")]);
  }
}, CD = {
  async execute(i, A) {
    const { conversations: e = [] } = A;
    if (!Array.isArray(e))
      return bA({});
    const t = {};
    for (const o of e)
      o && o.id && (t[o.id] = o.role === "user" ? "me" : "Maia");
    return bA(t);
  }
}, mg = {};
function MI() {
  const i = mg?.PUBLIC_DOMAIN_API || mg?.VITE_API_SERVICE_URL || "localhost:4201";
  return i.startsWith("http://") || i.startsWith("https://") ? i : `http://${i}`;
}
function kI(i) {
  if (!i || typeof i != "object")
    return [wA("structural", "Unknown error")];
  const A = i.validationErrors;
  if (Array.isArray(A) && A.length > 0)
    return A.map(
      (t) => wA("schema", t.message || t.msg || "Validation error", t.field ?? t.path ?? void 0)
    );
  const e = i.error || i.message || "Unknown error";
  return [wA("structural", typeof e == "string" ? e : String(e))];
}
const cD = MI();
async function ri(i, A) {
  const e = `${cD}${i}`, t = await fetch(e, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(A)
  });
  if (!t.ok) {
    const o = await t.json().catch(() => ({ error: "Unknown error" }));
    return { ok: !1, errors: kI(o) };
  }
  return { ok: !0, data: await t.json() };
}
const BD = {
  async execute(i, A) {
    const { op: e, workspaceId: t = "maiaos-dev", peerId: o, sessionId: r, content: s, query: g, target: n } = A;
    switch (e) {
      case "createSession": {
        if (!o)
          return fA([wA("structural", "[@memory] peerId is required for createSession")]);
        const a = await ri("/api/v0/memory/create-session", { workspaceId: t, peerId: o, sessionId: r });
        return a.ok ? bA({ sessionId: a.data.sessionId, workspaceId: a.data.workspaceId, peerId: a.data.peerId }) : fA(a.errors);
      }
      case "addMessage": {
        if (!r || !o || !s)
          return fA([wA("structural", "[@memory] sessionId, peerId, and content are required for addMessage")]);
        const a = await ri("/api/v0/memory/add-message", { workspaceId: t, sessionId: r, peerId: o, content: s });
        return a.ok ? bA({ success: a.data.success, sessionId: a.data.sessionId, peerId: a.data.peerId, content: a.data.content }) : fA(a.errors);
      }
      case "getContext": {
        if (!o || !g)
          return fA([wA("structural", "[@memory] peerId and query are required for getContext")]);
        const a = await ri("/api/v0/memory/get-context", { workspaceId: t, peerId: o, sessionId: r, query: g, target: n });
        return a.ok ? bA({ context: a.data.context }) : fA(a.errors);
      }
      case "chat": {
        if (!o || !g)
          return fA([wA("structural", "[@memory] peerId and query are required for chat")]);
        const a = await ri("/api/v0/memory/chat", { workspaceId: t, peerId: o, sessionId: r, query: g, target: n });
        return a.ok ? bA({ response: a.data.response }) : fA(a.errors);
      }
      default:
        return fA([wA("structural", `[@memory] Unknown operation: ${e}`)]);
    }
  }
}, QD = MI(), ED = {
  async execute(i, A) {
    const e = A?.context || A?.messages, { model: t = "qwen/qwen3-30b-a3b-instruct-2507", temperature: o = 1 } = A;
    if (!e || !Array.isArray(e) || e.length === 0)
      return fA([wA("structural", "[@ai/chat] context array is required")]);
    const r = `${QD}/api/v0/llm/chat`, s = await fetch(r, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ model: t, messages: e, temperature: o })
    });
    if (!s.ok) {
      const n = await s.json().catch(() => ({ error: "Unknown error" }));
      return fA(kI(n));
    }
    const g = await s.json();
    return bA({
      content: g.content,
      role: g.role || "assistant",
      usage: g.usage || null
    });
  }
}, Sg = {
  async execute(i, A) {
    if (!i)
      return fA([wA("structural", "[@db] Actor context required")]);
    const e = i.actorEngine?.os;
    if (!e || !e.db)
      return fA([wA("structural", "[@db] Database engine not available")]);
    if (A.op === "create" && A.schema && !A.schema.startsWith("co_z"))
      return fA([wA("structural", `[@db] Schema must be a co-id (co_z...), got: ${A.schema}`)]);
    try {
      const t = await e.db(A);
      return bA(t);
    } catch (t) {
      return fA(t.errors ?? [wA("structural", t.message || "Database operation failed")]);
    }
  }
}, Js = {
  "core/publishMessage": { definition: oD, function: ID },
  "core/computeMessageNames": { definition: rD, function: CD },
  "memory/memory": { definition: sD, function: BD },
  "ai/chat": { definition: gD, function: ED },
  "sparks/sparks": { definition: nD, function: Sg },
  "db/db": { definition: aD, function: Sg }
};
function Zt(i) {
  return Js[i] || null;
}
function lD() {
  const i = {};
  for (const [A, e] of Object.entries(Js))
    i[A] = e.definition;
  return i;
}
const GI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  TOOLS: Js,
  getAllToolDefinitions: lD,
  getTool: Zt
}, Symbol.toStringTag, { value: "Module" }));
class uD {
  constructor() {
    this.modules = /* @__PURE__ */ new Map(), this.moduleConfigs = /* @__PURE__ */ new Map();
  }
  /**
   * Register a MaiaScript module
   * @param {string} name - Module name (e.g., 'core', 'dragdrop')
   * @param {Object} module - Module instance or class
   * @param {Object} config - Optional module configuration/metadata
   */
  registerModule(A, e, t = {}) {
    this.modules.has(A) && console.warn(`[Registry] Module "${A}" already registered, overwriting`), this.modules.set(A, e), this.moduleConfigs.set(A, {
      name: A,
      version: t.version || "1.0.0",
      description: t.description || "",
      ...t
    });
  }
  /**
   * Get a module by name
   * @param {string} name - Module name
   * @returns {Object|null} Module instance or null
   */
  getModule(A) {
    return this.modules.get(A) || null;
  }
  /**
   * Get module configuration
   * @param {string} name - Module name
   * @returns {Object|null} Module config or null
   */
  getModuleConfig(A) {
    return this.moduleConfigs.get(A) || null;
  }
  /**
   * Check if a module exists
   * @param {string} name - Module name
   * @returns {boolean}
   */
  hasModule(A) {
    return this.modules.has(A);
  }
  /**
   * List all registered modules
   * @returns {Array<string>} Array of module names
   */
  listModules() {
    return Array.from(this.modules.keys());
  }
  /**
   * List all module configs
   * @returns {Array<Object>} Array of module configurations
   */
  listModuleConfigs() {
    return Array.from(this.moduleConfigs.values());
  }
  /**
   * Clear all registered modules
   * @internal For testing purposes only
   */
  clear() {
    this.modules.clear(), this.moduleConfigs.clear(), console.log("[Registry] Cleared all modules");
  }
  /**
   * Load a module (imports and registers)
   * @param {string} moduleName - Module name to load
   * @param {string} modulePath - Path to module file (optional, defaults to modules/{name}.module.js)
   * @returns {Promise<void>}
   */
  async loadModule(A, e = null) {
    if (this.hasModule(A)) {
      console.log(`[Registry] Module "${A}" already loaded`);
      return;
    }
    const t = e || `./${A}.module.js`;
    try {
      const o = await import(
        /* @vite-ignore */
        t
      );
      o.default && typeof o.default.register == "function" ? await o.default.register(this) : typeof o.register == "function" ? await o.register(this) : console.warn(`[Registry] Module "${A}" has no register method`);
    } catch (o) {
      throw console.error(`[Registry] Failed to load module "${A}":`, o), o;
    }
  }
  /**
   * Query module for configuration/data
   * @param {string} moduleName - Module name
   * @param {string} query - Query string
   * @returns {any} Query result or null
   */
  query(A, e) {
    const t = this.getModule(A);
    return t ? typeof t.query == "function" ? t.query(e) : t.config && e in t.config ? t.config[e] : null : null;
  }
  /**
   * Get tool engine from registry
   * @param {string} moduleName - Module name for error messages
   * @returns {Object} ToolEngine instance
   */
  _getToolEngine(A) {
    const e = this._toolEngine;
    if (!e)
      throw new Error(`[${A}] ToolEngine not available in registry`);
    return e;
  }
  /**
   * Register tools from tools registry
   * @param {string} moduleName - Module name
   * @param {Array<string>} toolNames - Array of tool names
   * @param {string} namespace - Namespace prefix (e.g., '@core')
   * @param {Object} options - Options (silent, etc.)
   * @returns {Promise<Array<string>>} Array of registered tool names
   */
  async _registerToolsFromRegistry(A, e, t, o = {}) {
    const { silent: r = !1 } = o, s = this._getToolEngine(A), g = [];
    for (const n of e)
      try {
        const a = Zt(`${A}/${n}`);
        a && (await s.registerTool(`${A}/${n}`, `${t}/${n}`, {
          definition: a.definition,
          function: a.function
        }), g.push(`${t}/${n}`));
      } catch (a) {
        r || console.error(`[${A}] Failed to register ${t}/${n}:`, a.message);
      }
    return g;
  }
}
const We = {
  version: "1.0.0",
  description: "Unified database operation API",
  namespace: "@db",
  tools: ["@db"]
};
async function dD(i) {
  const A = Zt("db/db");
  if (!A) return;
  i._getToolEngine("DBModule").tools.set("@db", {
    definition: A.definition,
    function: A.function,
    namespacePath: "db/db"
  }), i.registerModule("db", { config: We, query: (t) => t === "tools" ? ["@db"] : null }, {
    version: We.version,
    description: We.description,
    namespace: We.namespace,
    tools: We.tools
  });
}
const hD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  config: We,
  register: dD
}, Symbol.toStringTag, { value: "Module" })), me = {
  version: "1.0.0",
  description: "Core UI tools (view modes, modals, utilities)",
  namespace: "@core",
  tools: ["preventDefault", "publishMessage", "computeMessageNames"]
};
async function fD(i) {
  const A = me.tools, e = await i._registerToolsFromRegistry("core", A, me.namespace, { silent: !0 });
  i.registerModule("core", { config: me, query: () => null }, {
    version: me.version,
    description: me.description,
    namespace: me.namespace,
    tools: e
  });
}
const wD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  config: me,
  register: fD
}, Symbol.toStringTag, { value: "Module" })), ze = {
  version: "1.0.0",
  description: "Unified AI tool for OpenAI-compatible API integration (RedPill)",
  namespace: "@ai",
  tools: ["@ai/chat"]
};
async function pD(i) {
  const A = Zt("ai/chat");
  if (!A) return;
  i._getToolEngine("AiModule").tools.set("@ai/chat", {
    definition: A.definition,
    function: A.function,
    namespacePath: "ai/chat"
  }), i.registerModule("ai", { config: ze, query: (t) => t === "tools" ? ["@ai/chat"] : null }, {
    version: ze.version,
    description: ze.description,
    namespace: ze.namespace,
    tools: ze.tools
  });
}
const yD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  config: ze,
  register: pD
}, Symbol.toStringTag, { value: "Module" })), Ze = {
  version: "1.0.0",
  description: "Sparks tool for managing collaborative spaces (groups)",
  namespace: "@sparks",
  tools: ["@sparks"]
};
async function DD(i) {
  const A = Zt("sparks/sparks");
  if (!A) return;
  i._getToolEngine("SparksModule").tools.set("@sparks", {
    definition: A.definition,
    function: A.function,
    namespacePath: "sparks/sparks"
  }), i.registerModule("sparks", { config: Ze, query: (t) => t === "tools" ? ["@sparks"] : null }, {
    version: Ze.version,
    description: Ze.description,
    namespace: Ze.namespace,
    tools: Ze.tools
  });
}
const mD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  config: Ze,
  register: DD
}, Symbol.toStringTag, { value: "Module" })), xe = {}, Ng = {
  db: hD,
  core: wD,
  ai: yD,
  sparks: mD
};
class ge {
  constructor() {
    this.moduleRegistry = null, this.evaluator = null, this.toolEngine = null, this.stateEngine = null, this.styleEngine = null, this.viewEngine = null, this.actorEngine = null, this.subscriptionEngine = null, this.dbEngine = null, this._node = null, this._account = null, this._syncDomain = null;
  }
  /**
   * Compatibility property for maia-city and other tools
   * Exposes node and account for CoJSON backend access
   */
  get id() {
    return !this._node || !this._account ? null : {
      maiaId: this._account,
      node: this._node
    };
  }
  /**
   * Get all CoValues from the node (for maia-city compatibility)
   * @returns {Array} Array of CoValue metadata
   */
  getAllCoValues() {
    if (!this._node)
      return [];
    const A = [], e = this._node.coValues;
    if (e && typeof e.entries == "function")
      for (const [t, o] of e.entries())
        try {
          if (!o.isAvailable()) {
            A.push({
              id: t,
              type: "loading",
              schema: null,
              headerMeta: null,
              keys: "N/A",
              content: null,
              createdAt: null
            });
            continue;
          }
          const r = o.getCurrentContent(), s = o.verified?.header, g = s?.meta || null, n = g?.$schema || null, a = s?.createdAt || null;
          let I = "N/A";
          if (r && r.keys && typeof r.keys == "function")
            try {
              I = r.keys().length;
            } catch {
            }
          const C = r?.type || "unknown";
          let c = null;
          if (C === "costream")
            try {
              const B = r.toJSON();
              if (B instanceof Uint8Array)
                c = {
                  type: "stream",
                  itemCount: "binary",
                  preview: `${B.length} bytes`
                };
              else if (B && typeof B == "object") {
                const Q = [];
                for (const f in B)
                  Array.isArray(B[f]) && Q.push(...B[f]);
                c = {
                  type: "stream",
                  itemCount: Q.length,
                  preview: Q.slice(0, 3)
                };
              }
            } catch {
            }
          else if (C === "coplaintext")
            try {
              c = {
                type: "plaintext",
                content: r.text || r.toString()
              };
            } catch {
            }
          A.push({
            id: t,
            type: C,
            schema: n,
            headerMeta: g,
            keys: I,
            content: c || r,
            createdAt: a
          });
        } catch (r) {
          console.warn(`Error processing CoValue ${t}:`, r), A.push({
            id: t,
            type: "error",
            schema: null,
            headerMeta: null,
            keys: "N/A",
            content: null,
            createdAt: null,
            error: r.message
          });
        }
    return A;
  }
  /**
   * Boot the operating system
   * @param {Object} config - Boot configuration
   * @param {Object} [config.node] - LocalNode instance (required for CoJSON backend if backend not provided)
   * @param {Object} [config.account] - RawAccount instance (required for CoJSON backend if backend not provided)
   * @param {Object} [config.backend] - Pre-initialized backend (alternative to node+account)
   * @param {Object} [config.registry] - Config registry for seeding
   * @param {string} [config.syncDomain] - Sync service domain (overrides env vars, single source of truth)
   * @param {'human' | 'agent'} [config.mode] - Operational mode (default: detect from env vars)
   * @returns {Promise<MaiaOS>} Booted OS instance
   * @throws {Error} If neither backend nor node+account is provided (or agent mode credentials missing)
   */
  static async boot(A = {}) {
    const e = new ge(), t = A.mode || typeof process < "u" && process.env?.MAIA_MODE || typeof import.meta < "u" && xe?.MAIA_MODE || typeof import.meta < "u" && xe?.VITE_MAIA_MODE || "human";
    if (A.syncDomain && (e._syncDomain = A.syncDomain), t === "agent" && !A.node && !A.account && !A.backend) {
      const { loadOrCreateAgentAccount: r } = await Promise.resolve().then(() => GD), s = typeof process < "u" && process.env?.MAIA_AGENT_ACCOUNT_ID || typeof import.meta < "u" && xe?.MAIA_AGENT_ACCOUNT_ID || typeof import.meta < "u" && xe?.VITE_MAIA_AGENT_ACCOUNT_ID, g = typeof process < "u" && process.env?.MAIA_AGENT_SECRET || typeof import.meta < "u" && xe?.MAIA_AGENT_SECRET || typeof import.meta < "u" && xe?.VITE_MAIA_AGENT_SECRET;
      if (!s || !g)
        throw new Error(
          "Agent mode requires MAIA_AGENT_ACCOUNT_ID and MAIA_AGENT_SECRET environment variables. For services, use service-specific prefixes: SYNC_MAIA_* for sync service, CITY_MAIA_* for maia-city. Run `bun agent:generate --service <service>` to generate credentials."
        );
      const n = await r({
        accountID: s,
        agentSecret: g,
        syncDomain: A.syncDomain || null,
        createName: "Maia Agent"
      });
      e._node = n.node, e._account = n.account;
    } else
      A.node && A.account && (e._node = A.node, e._account = A.account);
    const o = await ge._initializeDatabase(e, A);
    return o && typeof o.ensureAccountOsReady == "function" && o.ensureAccountOsReady({ timeoutMs: 1e4 }).then((r) => {
      r || console.warn("[MaiaOS.boot]  account.os readiness check failed - schema resolution may fail until it loads");
    }).catch((r) => {
      console.warn("[MaiaOS.boot]  account.os loading error (non-blocking):", r);
    }), A.registry && await ge._seedDatabase(e, o, A), ge._initializeEngines(e, A), await ge._loadModules(e, A), e;
  }
  /**
   * Initialize database backend and engine
   * Requires either a pre-initialized backend or CoJSON node+account
   * @param {MaiaOS} os - OS instance
   * @param {Object} config - Boot configuration
   * @param {Object} [config.node] - LocalNode instance (required for CoJSON backend)
   * @param {Object} [config.account] - RawAccount instance (required for CoJSON backend)
   * @param {Object} [config.backend] - Pre-initialized backend (alternative to node+account)
   * @returns {Promise<DBAdapter>} Initialized backend
   * @throws {Error} If neither backend nor node+account is provided
   */
  static async _initializeDatabase(A, e = {}) {
    const t = new Vr();
    if (e.backend)
      return A.dbEngine = new Bo(e.backend, { evaluator: t }), e.backend;
    if (e.node && e.account) {
      const { CoJSONBackend: o } = await Promise.resolve().then(() => Go), r = new o(e.node, e.account, { systemSpark: "@maia" });
      return A.dbEngine = new Bo(r, { evaluator: t }), r.dbEngine = A.dbEngine, r;
    }
    throw new Error(
      "MaiaOS.boot() requires either a backend or node+account for CoJSON backend. Provide either: { backend: <DBAdapter> } or { node: <LocalNode>, account: <RawAccount> }"
    );
  }
  /**
   * Collect schemas from schemata module
   * @returns {Object} Schemas object
   */
  static _collectSchemas() {
    const A = {};
    return typeof Jr == "function" && Object.assign(A, Jr()), typeof Ur == "function" && (A["meta-schema"] = Ur()), A;
  }
  /**
   * Validate schemas against meta schema
   * @param {Object} schemas - Schemas to validate
   * @param {ValidationEngine} validationEngine - Validation engine instance
   * @throws {Error} If any schema fails validation
   */
  static async _validateSchemas(A, e) {
    for (const [t, o] of Object.entries(A)) {
      const r = await e.validateSchemaAgainstMeta(o);
      if (!r.valid) {
        const s = r.errors.map((g) => `  - ${g.instancePath}: ${g.message}`).join(`
`);
        throw console.error(` Schema '${t}' failed meta schema validation:
${s}`), new Error(`Schema '${t}' is not valid JSON Schema`);
      }
    }
  }
  /**
   * Seed database with configs, schemas, and tool definitions
   * @param {MaiaOS} os - OS instance
   * @param {DBAdapter} backend - Database backend (CoJSONBackend)
   * @param {Object} config - Boot configuration
   */
  static async _seedDatabase(A, e, t) {
    const { getAllToolDefinitions: o } = await Promise.resolve().then(() => GI), r = o(), s = {
      ...t.registry,
      tool: r
      // Add tool definitions under 'tool' key
    }, g = ge._collectSchemas(), n = new Ye();
    await n.initialize(), await ge._validateSchemas(g, n);
    const I = t.registry?.data || {}, C = await A.dbEngine.execute({
      op: "seed",
      configs: s,
      schemas: g,
      data: I
    });
    if (!C.ok) {
      const B = C.errors?.map((Q) => Q.message).join("; ") || "Seed failed";
      throw new Error(`[MaiaOS] Seed failed: ${B}`);
    }
    const { setSchemaResolver: c } = await Promise.resolve().then(() => RQ);
    c({ dbEngine: A.dbEngine });
  }
  /**
   * Initialize all engines and wire dependencies
   * @param {MaiaOS} os - OS instance
   * @param {Object} config - Boot configuration
   */
  static _initializeEngines(A, e) {
    A.moduleRegistry = new uD(), A.evaluator = new Vr(A.moduleRegistry, { dbEngine: A.dbEngine }), A.toolEngine = new tD(A.moduleRegistry), A.moduleRegistry._toolEngine = A.toolEngine, A.moduleRegistry._dbEngine = A.dbEngine, A.stateEngine = new eD(A.toolEngine, A.evaluator), A.styleEngine = new AD(), e.isDevelopment && A.styleEngine.clearCache(), A.viewEngine = new $y(A.evaluator, null, A.moduleRegistry), A.actorEngine = new zy(
      A.styleEngine,
      A.viewEngine,
      A.moduleRegistry,
      A.toolEngine,
      A.stateEngine
    ), A.actorEngine.dbEngine = A.dbEngine, A.viewEngine.dbEngine = A.dbEngine, A.styleEngine.dbEngine = A.dbEngine, A.stateEngine.dbEngine = A.dbEngine, A.actorEngine.os = A, A.viewEngine.actorEngine = A.actorEngine, A.stateEngine.actorEngine = A.actorEngine;
  }
  /**
   * Load modules
   * @param {MaiaOS} os - OS instance
   * @param {Object} config - Boot configuration
   */
  static async _loadModules(A, e) {
    const t = e.modules || ["db", "core", "sparks"];
    for (const o of t)
      try {
        if (Ng[o]) {
          const r = Ng[o];
          r.default && typeof r.default.register == "function" ? await r.default.register(A.moduleRegistry) : typeof r.register == "function" && await r.register(A.moduleRegistry);
        } else
          await A.moduleRegistry.loadModule(o);
      } catch (r) {
        console.error(`Failed to load module "${o}":`, r);
      }
  }
  /**
   * Create an actor
   * @param {string} actorPath - Path to actor.maia file
   * @param {HTMLElement} container - Container element
   * @returns {Promise<Object>} Created actor
   */
  async createActor(A, e) {
    let t;
    if (typeof A == "object" && A !== null)
      t = A;
    else if (typeof A == "string" && A.startsWith("co_z")) {
      const r = await eA(this.actorEngine.dbEngine.backend, { fromCoValue: A }, { returnType: "coId" });
      t = (await this.actorEngine.dbEngine.execute({ op: "read", schema: r, key: A })).value;
    } else
      throw new Error(`[MaiaOS] createActor expects co-id (co_z...) or config object, got: ${typeof A}`);
    return await this.actorEngine.createActor(t, e);
  }
  /**
   * Load a vibe (app manifest) from file and create its root actor
   * @param {string} vibePath - Path to vibe manifest
   * @param {HTMLElement} container - Container element
   * @returns {Promise<{vibe: Object, actor: Object}>} Vibe metadata and actor instance
   */
  async loadVibe(A, e) {
    const t = await fetch(A);
    if (!t.ok)
      throw new Error(`Failed to load vibe: ${A}`);
    const o = await t.json(), s = `${A.substring(0, A.lastIndexOf("/"))}/${o.actor}`, g = await this.createActor(s, e);
    return { vibe: o, actor: g };
  }
  /**
   * Load a vibe from account.sparks[spark].vibes using the abstracted operations API
   * @param {string} vibeKey - Vibe key in spark's vibes (e.g., "todos")
   * @param {HTMLElement} container - Container element
   * @param {string} [spark='@maia'] - Spark name (context scope), e.g. '@maia'
   * @returns {Promise<{vibe: Object, actor: Object}>} Vibe metadata and actor instance
   */
  async loadVibeFromAccount(A, e, t = "@maia") {
    if (!this.dbEngine || !this._account)
      throw new Error("[Kernel] Cannot load vibe from account - dbEngine or account not available");
    const o = this._account, s = (await this.dbEngine.execute({
      op: "read",
      schema: "@account",
      key: o.id
    })).value;
    if (!s)
      throw new Error("[Kernel] Failed to read account CoMap");
    const g = s.sparks;
    if (!g || typeof g != "string" || !g.startsWith("co_"))
      throw new Error(`[Kernel] account.sparks not found. Ensure schemaMigration has run. Account data: ${JSON.stringify({ id: s.id, hasSparks: !!s.sparks })}`);
    const a = (await this.dbEngine.execute({
      op: "read",
      schema: g,
      key: g
    })).value;
    if (!a || a.error)
      throw new Error(`[Kernel] account.sparks not available: ${a?.error || "Unknown error"}`);
    const I = a[t];
    if (!I || typeof I != "string" || !I.startsWith("co_")) {
      const d = Object.keys(a).filter((u) => u !== "id" && u !== "$schema" && u !== "type" && typeof a[u] == "string" && a[u].startsWith("co_"));
      throw new Error(`[Kernel] Spark "${t}" not found in account.sparks. Available: ${d.join(", ") || "none"}`);
    }
    const c = (await this.dbEngine.execute({
      op: "read",
      schema: null,
      key: I
    })).value;
    if (!c || c.error)
      throw new Error(`[Kernel] Spark "${t}" not available: ${c?.error || "Unknown error"}`);
    const B = c.vibes;
    if (!B || typeof B != "string" || !B.startsWith("co_"))
      throw new Error(`[Kernel] Spark "${t}" has no vibes registry. Ensure seeding has run.`);
    const f = (await this.dbEngine.execute({
      op: "read",
      schema: B,
      key: B
    })).value;
    if (!f || f.error)
      throw new Error(`[Kernel] Spark "${t}" vibes not available: ${f?.error || "Unknown error"}`);
    const l = f[A];
    if (!l || typeof l != "string" || !l.startsWith("co_")) {
      const d = Object.keys(f).filter((u) => u !== "id" && u !== "$schema" && u !== "type" && typeof f[u] == "string" && f[u].startsWith("co_"));
      throw new Error(`[Kernel] Vibe '${A}' not found in ${t}.vibes. Available: ${d.join(", ") || "none"}`);
    }
    return await this.loadVibeFromDatabase(l, e, A);
  }
  /**
   * Load a vibe from database (maia.db)
   * @param {string} vibeId - Vibe ID (co-id or human-readable like "@maia/vibe/todos")
   * @param {HTMLElement} container - Container element
   * @param {string} [vibeKey] - Optional vibe key for actor reuse tracking (e.g., 'todos')
   * @returns {Promise<{vibe: Object, actor: Object}>} Vibe metadata and actor instance
   */
  async loadVibeFromDatabase(A, e, t = null) {
    if (!A.startsWith("co_z"))
      throw new Error(`[Kernel] Vibe ID must be co-id at runtime: ${A}. This should have been resolved during seeding.`);
    const o = A, r = await this.dbEngine.execute({
      op: "read",
      schema: null,
      // No schema filter - read CoValue directly
      key: o
    }), s = await this.dbEngine.execute({
      op: "schema",
      fromCoValue: o
      //  Extracts headerMeta.$schema internally
    }), g = s.value?.$id || r.value?.$schema;
    if (!g)
      throw new Error(`[Kernel] Failed to extract schema co-id from vibe ${o}. Vibe must have $schema in headerMeta.`);
    let a = r.value;
    if (!a || a.error) {
      console.error("[Kernel] Vibe not found! Trying to debug..."), console.error(`[Kernel] Vibe co-id: ${o}`), console.error(`[Kernel] Schema co-id: ${g}`);
      try {
        const w = (await this.dbEngine.execute({
          op: "read",
          schema: null,
          // Read CoValue directly
          key: o
        })).value;
        console.error("[Kernel] Direct read() result:", w ? "FOUND" : "NULL", w);
      } catch (h) {
        console.error("[Kernel] Direct read() error:", h);
      }
      throw new Error(`Vibe not found in database: ${A} (co-id: ${o})`);
    }
    if (a.properties && Array.isArray(a.properties)) {
      const h = {};
      for (const w of a.properties)
        h[w.key] = w.value;
      a.id && (h.id = a.id), a.$schema && (h.$schema = a.$schema), a.type && (h.type = a.type), a = h;
    }
    const I = s.value;
    I && await nt(I, a, "vibe");
    let C = a.actor;
    if (!C)
      throw new Error(`[MaiaOS] Vibe ${A} (${o}) does not have an 'actor' property. Vibe structure: ${JSON.stringify(Object.keys(a))}`);
    if (!C.startsWith("co_z"))
      throw new Error(`[Kernel] Actor ID must be co-id at runtime: ${C}. This should have been resolved during seeding.`);
    const c = Ae(this.dbEngine.backend, { fromCoValue: C }, { returnType: "coId" });
    let B;
    const Q = await new Promise((h, w) => {
      const E = setTimeout(() => {
        B && B(), w(new Error(`[Kernel] Timeout waiting for actor schema to resolve for ${C} after 10000ms`));
      }, 1e4);
      B = c.subscribe((p) => {
        p.loading || (clearTimeout(E), B && B(), p.error || !p.schemaCoId ? w(new Error(`[Kernel] Failed to extract schema co-id from actor ${C}: ${p.error || "Schema not found"}`)) : h(p.schemaCoId));
      });
    }), f = await this.dbEngine.execute({
      op: "read",
      schema: Q,
      key: C
    });
    if (!f.value)
      throw new Error(`[MaiaOS] Actor with co-id ${C} not found in database. The actor may not have been seeded correctly.`);
    t && this.actorEngine.destroyActorsForVibe(t);
    const d = f.value, u = await this.actorEngine.createActor(d, e, t);
    return { vibe: a, actor: u };
  }
  /**
   * Debug helper to list coIdRegistry keys (for troubleshooting)
   * @private
   */
  async _debugCoIdRegistry() {
    try {
      const t = this.dbEngine.backend.db.transaction(["coIdRegistry"], "readonly").objectStore("coIdRegistry").getAllKeys();
      return (await new Promise((r, s) => {
        t.onsuccess = () => r(t.result), t.onerror = () => s(t.error);
      })).filter((r) => r && (r.includes("actor") || r.includes("agent")));
    } catch (A) {
      return [`Error: ${A.message}`];
    }
  }
  /**
   * Get actor by ID
   * @param {string} actorId - Actor ID
   * @returns {Object|null} Actor instance
   */
  getActor(A) {
    return this.actorEngine.getActor(A);
  }
  /**
   * Send message to actor
   * @param {string} actorId - Target actor ID
   * @param {Object} message - Message object
   */
  sendMessage(A, e) {
    this.actorEngine.sendMessage(A, e);
  }
  /**
   * Execute database operation (internal use + @db tool)
   * @param {Object} payload - Operation payload {op: 'query|create|update|delete|seed', ...}
   * @returns {Promise<any>} Operation result; for write ops: throws on error, returns data on success (backward compat for state machines)
   */
  async db(A) {
    const e = await this.dbEngine.execute(A), t = /* @__PURE__ */ new Set(["create", "update", "delete", "append", "push", "seed"]);
    if (e && e.ok === !1 && t.has(A?.op)) {
      const o = e.errors?.map((s) => s.message).join("; ") || "Operation failed", r = new Error(`[db] ${A.op} failed: ${o}`);
      throw r.errors = e.errors, r;
    }
    return e && e.ok === !0 && typeof e.data < "u" ? e.data : e;
  }
  /**
   * Get sync domain (single source of truth)
   * Returns the sync domain configured during boot, or null if not set
   * @returns {string|null} Sync domain or null
   */
  getSyncDomain() {
    return this._syncDomain;
  }
  /**
   * Expose engines for debugging
   */
  getEngines() {
    return {
      actorEngine: this.actorEngine,
      viewEngine: this.viewEngine,
      styleEngine: this.styleEngine,
      stateEngine: this.stateEngine,
      toolEngine: this.toolEngine,
      dbEngine: this.dbEngine,
      evaluator: this.evaluator,
      moduleRegistry: this.moduleRegistry
    };
  }
}
async function FI() {
  if (!window.PublicKeyCredential)
    throw new Error(
      `WebAuthn not supported. Please use:
- Chrome on macOS/Linux/Windows 11
- Safari on macOS 13+/iOS 16+
Firefox and Windows 10 are NOT supported.`
    );
  try {
    if (!await PublicKeyCredential.isConditionalMediationAvailable?.())
      throw new Error(
        `WebAuthn PRF not supported. Please use:
- Chrome on macOS/Linux/Windows 11
- Safari on macOS 13+/iOS 16+
Firefox and Windows 10 are NOT supported.`
      );
    return !0;
  } catch {
    throw new Error(
      `WebAuthn PRF not supported. Please use:
- Chrome on macOS/Linux/Windows 11
- Safari on macOS 13+/iOS 16+
Firefox and Windows 10 are NOT supported.`
    );
  }
}
async function Hs() {
  await FI();
}
function RI(i) {
  const A = new Uint8Array(i);
  let e = "";
  for (let t = 0; t < A.byteLength; t++)
    e += String.fromCharCode(A[t]);
  return btoa(e);
}
function qs(i) {
  return new TextEncoder().encode(i);
}
async function bI({ salt: i, rpId: A = window.location.hostname }) {
  try {
    const e = await navigator.credentials.get({
      publicKey: {
        challenge: crypto.getRandomValues(new Uint8Array(32)),
        rpId: A,
        userVerification: "required",
        authenticatorAttachment: "platform",
        // ONLY platform authenticators!
        // WebAuthn Level 3: Hint the browser UI to show platform authenticator
        hints: ["client-device"],
        // Prioritize local device, suppress QR code UI
        extensions: {
          prf: {
            eval: {
              first: i
              // The salt we want to evaluate
            }
          }
        }
      },
      mediation: "optional"
      // Show passkey picker
    });
    if (!e)
      throw new Error("No passkey selected");
    const t = e.getClientExtensionResults()?.prf;
    if (!t?.results?.first)
      throw new Error("PRF evaluation failed: no results returned");
    return {
      prfOutput: new Uint8Array(t.results.first),
      credentialId: e.rawId
    };
  } catch (e) {
    throw console.error("PRF evaluation error:", e), new Error(`Failed to evaluate PRF: ${e.message}`);
  }
}
async function KI({ name: i, userId: A, rpId: e = window.location.hostname, salt: t }) {
  try {
    const o = t ? {
      prf: {
        eval: {
          first: t
          // Evaluate PRF during creation!
        }
      }
    } : {
      prf: {}
      // Just enable PRF without evaluation
    }, r = await navigator.credentials.create({
      publicKey: {
        challenge: crypto.getRandomValues(new Uint8Array(32)),
        rp: {
          name: "Maia OS",
          id: e
        },
        user: {
          id: A,
          name: i,
          displayName: i
        },
        pubKeyCredParams: [
          { type: "public-key", alg: -7 },
          // ES256
          { type: "public-key", alg: -257 }
          // RS256
        ],
        authenticatorSelection: {
          authenticatorAttachment: "platform",
          // ONLY platform authenticators
          residentKey: "required",
          userVerification: "required"
        },
        // WebAuthn Level 3: Hint the browser UI to show platform authenticator first
        hints: ["client-device"],
        // Prioritize local device authenticator UI
        extensions: o
      }
    }), s = r.getClientExtensionResults();
    if (!s.prf?.enabled)
      throw new Error("PRF extension not enabled on credential");
    const g = s.prf?.results?.first ? new Uint8Array(s.prf.results.first) : null;
    return {
      credentialId: r.rawId,
      response: r.response,
      prfOutput: g
      // May be null if salt wasn't provided
    };
  } catch (o) {
    throw console.error("Passkey creation error:", o), new Error(`Failed to create passkey: ${o.message}`);
  }
}
const { accountHeaderForInitialAgentSecret: Fo, idforHeader: Ro } = Is;
async function SD({ name: i = "maia", salt: A = "maia.city" } = {}) {
  await Hs();
  const e = qs(A), t = await Ie.create(), { credentialId: o, prfOutput: r } = await KI({
    name: i,
    userId: globalThis.crypto.getRandomValues(new Uint8Array(32)),
    // Random userID - we don't store anything!
    salt: e
  });
  if (!r)
    throw new Error("PRF evaluation failed");
  const s = t.agentSecretFromSecretSeed(r), g = Fo(s, t), n = Ro(g, t), a = await He({ mode: "human", servicePrefix: "CITY" }), I = zt(), C = await Rs({
    agentSecret: s,
    name: i,
    peers: I ? I.peers : [],
    storage: a
  }), { node: c, account: B, accountID: Q } = C;
  if (I && I.setNode(c), Q !== n)
    throw new Error(
      `CRITICAL: AccountID mismatch!
  Computed: ${n}
  Created:  ${Q}
This should never happen - deterministic computation failed!`
    );
  return {
    accountID: Q,
    agentSecret: s,
    node: c,
    account: B,
    credentialId: RI(o)
  };
}
async function ND({ salt: i = "maia.city" } = {}) {
  await Hs();
  const A = qs(i), { prfOutput: e } = await bI({ salt: A });
  if (!e)
    throw new Error("PRF evaluation failed during sign-in");
  const t = await Ie.create(), o = t.agentSecretFromSecretSeed(e), r = Fo(o, t), s = Ro(r, t), g = await He({ mode: "human", servicePrefix: "CITY" }), n = zt();
  performance.now();
  const a = (async () => {
    try {
      let I = !1;
      n && n.waitForPeer && (I = await n.waitForPeer());
      const C = await bs({
        accountID: s,
        agentSecret: o,
        peers: n ? n.peers : [],
        storage: g
      }), { node: c, account: B } = C;
      return n && n.setNode(c), console.log("    0 secrets retrieved from storage"), console.log("    Everything computed deterministically!"), {
        accountID: B.id,
        agentSecret: o,
        node: c,
        account: B
      };
    } catch (I) {
      throw console.error(" Account loading failed:", I), console.error("   Error message:", I.message), console.error("   Error stack:", I.stack), console.error("   AccountID:", s), console.error("   Peers available:", n ? n.peers.length : 0), n && n.peers.length > 0 && console.error("   Peer IDs:", n.peers.map((C) => C.id || "unknown")), I;
    }
  })();
  return console.log(" Returning from signInWithPasskey() immediately (account loading in background)..."), {
    accountID: s,
    agentSecret: o,
    loadingPromise: a
  };
}
async function MD({ name: i = "Maia Agent" } = {}) {
  const A = await Ie.create(), e = A.newRandomAgentSecret(), t = Fo(e, A);
  return {
    accountID: Ro(t, A),
    agentSecret: e,
    name: i
  };
}
async function YI({ agentSecret: i, name: A = "Maia Agent", syncDomain: e = null, servicePrefix: t = null, dbPath: o = null, inMemory: r = !1 } = {}) {
  if (!i)
    throw new Error(
      "agentSecret is required. Set service-specific env var (e.g., SYNC_MAIA_AGENT_SECRET or CITY_MAIA_AGENT_SECRET). Run `bun agent:generate --service <service>` to generate credentials."
    );
  const s = await Ie.create(), g = Fo(i, s), n = Ro(g, s), a = await He({ mode: "agent", servicePrefix: t, dbPath: o, inMemory: r }), I = zt(e), C = await Rs({
    agentSecret: i,
    name: A,
    peers: I ? I.peers : [],
    storage: a,
    skipAutoSeeding: !0
    // Agent accounts don't need vibes/views seeding
  }), { node: c, account: B, accountID: Q } = C;
  if (I && I.setNode(c), Q !== n)
    throw new Error(
      `CRITICAL: AccountID mismatch!
  Computed: ${n}
  Created:  ${Q}
This should never happen - deterministic computation failed!`
    );
  return {
    accountID: Q,
    agentSecret: i,
    node: c,
    account: B
  };
}
async function UI({ accountID: i, agentSecret: A, syncDomain: e = null, servicePrefix: t = null, dbPath: o = null, inMemory: r = !1 } = {}) {
  if (!A)
    throw new Error(
      "agentSecret is required. Set service-specific env var (e.g., SYNC_MAIA_AGENT_SECRET or CITY_MAIA_AGENT_SECRET). Run `bun agent:generate --service <service>` to generate credentials."
    );
  if (!i)
    throw new Error(
      "accountID is required. Set service-specific env var (e.g., SYNC_MAIA_AGENT_ACCOUNT_ID or CITY_MAIA_AGENT_ACCOUNT_ID). Run `bun agent:generate --service <service>` to generate credentials."
    );
  const s = await He({ mode: "agent", servicePrefix: t, dbPath: o, inMemory: r }), g = zt(e), n = await bs({
    accountID: i,
    agentSecret: A,
    peers: g ? g.peers : [],
    storage: s
  }), { node: a, account: I } = n;
  return g && g.setNode(a), {
    accountID: I.id,
    agentSecret: A,
    node: a,
    account: I
  };
}
async function kD({
  accountID: i,
  agentSecret: A,
  syncDomain: e = null,
  servicePrefix: t = null,
  dbPath: o = null,
  inMemory: r = !1,
  createName: s = "Maia Agent"
} = {}) {
  try {
    return await UI({
      accountID: i,
      agentSecret: A,
      syncDomain: e,
      servicePrefix: t,
      dbPath: o,
      inMemory: r
    });
  } catch (g) {
    const n = g?.message || String(g);
    if (g?.isAccountNotFound || n.includes("Account unavailable from all peers") || n.includes("unavailable from all peers") || n.includes("Account not found in storage"))
      return await YI({
        agentSecret: A,
        name: s,
        syncDomain: e,
        servicePrefix: t,
        dbPath: o,
        inMemory: r
      });
    throw g;
  }
}
const GD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  arrayBufferToBase64: RI,
  createAgentAccount: YI,
  createPasskeyWithPRF: KI,
  evaluatePRF: bI,
  generateAgentCredentials: MD,
  getStorage: He,
  isPRFSupported: FI,
  loadAgentAccount: UI,
  loadOrCreateAgentAccount: kD,
  requirePRFSupport: Hs,
  signInWithPasskey: ND,
  signUpWithPasskey: SD,
  stringToUint8Array: qs
}, Symbol.toStringTag, { value: "Module" }));
function vI(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
}
var si = { exports: {} }, gr = {}, ie = {}, he = {}, nr = {}, ar = {}, Ir = {}, Mg;
function Qo() {
  return Mg || (Mg = 1, (function(i) {
    Object.defineProperty(i, "__esModule", { value: !0 }), i.regexpCode = i.getEsmExportName = i.getProperty = i.safeStringify = i.stringify = i.strConcat = i.addCodeArg = i.str = i._ = i.nil = i._Code = i.Name = i.IDENTIFIER = i._CodeOrName = void 0;
    class A {
    }
    i._CodeOrName = A, i.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    class e extends A {
      constructor(u) {
        if (super(), !i.IDENTIFIER.test(u))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = u;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return !1;
      }
      get names() {
        return { [this.str]: 1 };
      }
    }
    i.Name = e;
    class t extends A {
      constructor(u) {
        super(), this._items = typeof u == "string" ? [u] : u;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return !1;
        const u = this._items[0];
        return u === "" || u === '""';
      }
      get str() {
        var u;
        return (u = this._str) !== null && u !== void 0 ? u : this._str = this._items.reduce((h, w) => `${h}${w}`, "");
      }
      get names() {
        var u;
        return (u = this._names) !== null && u !== void 0 ? u : this._names = this._items.reduce((h, w) => (w instanceof e && (h[w.str] = (h[w.str] || 0) + 1), h), {});
      }
    }
    i._Code = t, i.nil = new t("");
    function o(d, ...u) {
      const h = [d[0]];
      let w = 0;
      for (; w < u.length; )
        g(h, u[w]), h.push(d[++w]);
      return new t(h);
    }
    i._ = o;
    const r = new t("+");
    function s(d, ...u) {
      const h = [B(d[0])];
      let w = 0;
      for (; w < u.length; )
        h.push(r), g(h, u[w]), h.push(r, B(d[++w]));
      return n(h), new t(h);
    }
    i.str = s;
    function g(d, u) {
      u instanceof t ? d.push(...u._items) : u instanceof e ? d.push(u) : d.push(C(u));
    }
    i.addCodeArg = g;
    function n(d) {
      let u = 1;
      for (; u < d.length - 1; ) {
        if (d[u] === r) {
          const h = a(d[u - 1], d[u + 1]);
          if (h !== void 0) {
            d.splice(u - 1, 3, h);
            continue;
          }
          d[u++] = "+";
        }
        u++;
      }
    }
    function a(d, u) {
      if (u === '""')
        return d;
      if (d === '""')
        return u;
      if (typeof d == "string")
        return u instanceof e || d[d.length - 1] !== '"' ? void 0 : typeof u != "string" ? `${d.slice(0, -1)}${u}"` : u[0] === '"' ? d.slice(0, -1) + u.slice(1) : void 0;
      if (typeof u == "string" && u[0] === '"' && !(d instanceof e))
        return `"${d}${u.slice(1)}`;
    }
    function I(d, u) {
      return u.emptyStr() ? d : d.emptyStr() ? u : s`${d}${u}`;
    }
    i.strConcat = I;
    function C(d) {
      return typeof d == "number" || typeof d == "boolean" || d === null ? d : B(Array.isArray(d) ? d.join(",") : d);
    }
    function c(d) {
      return new t(B(d));
    }
    i.stringify = c;
    function B(d) {
      return JSON.stringify(d).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    i.safeStringify = B;
    function Q(d) {
      return typeof d == "string" && i.IDENTIFIER.test(d) ? new t(`.${d}`) : o`[${d}]`;
    }
    i.getProperty = Q;
    function f(d) {
      if (typeof d == "string" && i.IDENTIFIER.test(d))
        return new t(`${d}`);
      throw new Error(`CodeGen: invalid export name: ${d}, use explicit $id name mapping`);
    }
    i.getEsmExportName = f;
    function l(d) {
      return new t(d.toString());
    }
    i.regexpCode = l;
  })(Ir)), Ir;
}
var Cr = {}, kg;
function Gg() {
  return kg || (kg = 1, (function(i) {
    Object.defineProperty(i, "__esModule", { value: !0 }), i.ValueScope = i.ValueScopeName = i.Scope = i.varKinds = i.UsedValueState = void 0;
    const A = Qo();
    class e extends Error {
      constructor(a) {
        super(`CodeGen: "code" for ${a} not defined`), this.value = a.value;
      }
    }
    var t;
    (function(n) {
      n[n.Started = 0] = "Started", n[n.Completed = 1] = "Completed";
    })(t || (i.UsedValueState = t = {})), i.varKinds = {
      const: new A.Name("const"),
      let: new A.Name("let"),
      var: new A.Name("var")
    };
    class o {
      constructor({ prefixes: a, parent: I } = {}) {
        this._names = {}, this._prefixes = a, this._parent = I;
      }
      toName(a) {
        return a instanceof A.Name ? a : this.name(a);
      }
      name(a) {
        return new A.Name(this._newName(a));
      }
      _newName(a) {
        const I = this._names[a] || this._nameGroup(a);
        return `${a}${I.index++}`;
      }
      _nameGroup(a) {
        var I, C;
        if (!((C = (I = this._parent) === null || I === void 0 ? void 0 : I._prefixes) === null || C === void 0) && C.has(a) || this._prefixes && !this._prefixes.has(a))
          throw new Error(`CodeGen: prefix "${a}" is not allowed in this scope`);
        return this._names[a] = { prefix: a, index: 0 };
      }
    }
    i.Scope = o;
    class r extends A.Name {
      constructor(a, I) {
        super(I), this.prefix = a;
      }
      setValue(a, { property: I, itemIndex: C }) {
        this.value = a, this.scopePath = (0, A._)`.${new A.Name(I)}[${C}]`;
      }
    }
    i.ValueScopeName = r;
    const s = (0, A._)`\n`;
    class g extends o {
      constructor(a) {
        super(a), this._values = {}, this._scope = a.scope, this.opts = { ...a, _n: a.lines ? s : A.nil };
      }
      get() {
        return this._scope;
      }
      name(a) {
        return new r(a, this._newName(a));
      }
      value(a, I) {
        var C;
        if (I.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const c = this.toName(a), { prefix: B } = c, Q = (C = I.key) !== null && C !== void 0 ? C : I.ref;
        let f = this._values[B];
        if (f) {
          const u = f.get(Q);
          if (u)
            return u;
        } else
          f = this._values[B] = /* @__PURE__ */ new Map();
        f.set(Q, c);
        const l = this._scope[B] || (this._scope[B] = []), d = l.length;
        return l[d] = I.ref, c.setValue(I, { property: B, itemIndex: d }), c;
      }
      getValue(a, I) {
        const C = this._values[a];
        if (C)
          return C.get(I);
      }
      scopeRefs(a, I = this._values) {
        return this._reduceValues(I, (C) => {
          if (C.scopePath === void 0)
            throw new Error(`CodeGen: name "${C}" has no value`);
          return (0, A._)`${a}${C.scopePath}`;
        });
      }
      scopeCode(a = this._values, I, C) {
        return this._reduceValues(a, (c) => {
          if (c.value === void 0)
            throw new Error(`CodeGen: name "${c}" has no value`);
          return c.value.code;
        }, I, C);
      }
      _reduceValues(a, I, C = {}, c) {
        let B = A.nil;
        for (const Q in a) {
          const f = a[Q];
          if (!f)
            continue;
          const l = C[Q] = C[Q] || /* @__PURE__ */ new Map();
          f.forEach((d) => {
            if (l.has(d))
              return;
            l.set(d, t.Started);
            let u = I(d);
            if (u) {
              const h = this.opts.es5 ? i.varKinds.var : i.varKinds.const;
              B = (0, A._)`${B}${h} ${d} = ${u};${this.opts._n}`;
            } else if (u = c?.(d))
              B = (0, A._)`${B}${u}${this.opts._n}`;
            else
              throw new e(d);
            l.set(d, t.Completed);
          });
        }
        return B;
      }
    }
    i.ValueScope = g;
  })(Cr)), Cr;
}
var Fg;
function oA() {
  return Fg || (Fg = 1, (function(i) {
    Object.defineProperty(i, "__esModule", { value: !0 }), i.or = i.and = i.not = i.CodeGen = i.operators = i.varKinds = i.ValueScopeName = i.ValueScope = i.Scope = i.Name = i.regexpCode = i.stringify = i.getProperty = i.nil = i.strConcat = i.str = i._ = void 0;
    const A = Qo(), e = Gg();
    var t = Qo();
    Object.defineProperty(i, "_", { enumerable: !0, get: function() {
      return t._;
    } }), Object.defineProperty(i, "str", { enumerable: !0, get: function() {
      return t.str;
    } }), Object.defineProperty(i, "strConcat", { enumerable: !0, get: function() {
      return t.strConcat;
    } }), Object.defineProperty(i, "nil", { enumerable: !0, get: function() {
      return t.nil;
    } }), Object.defineProperty(i, "getProperty", { enumerable: !0, get: function() {
      return t.getProperty;
    } }), Object.defineProperty(i, "stringify", { enumerable: !0, get: function() {
      return t.stringify;
    } }), Object.defineProperty(i, "regexpCode", { enumerable: !0, get: function() {
      return t.regexpCode;
    } }), Object.defineProperty(i, "Name", { enumerable: !0, get: function() {
      return t.Name;
    } });
    var o = Gg();
    Object.defineProperty(i, "Scope", { enumerable: !0, get: function() {
      return o.Scope;
    } }), Object.defineProperty(i, "ValueScope", { enumerable: !0, get: function() {
      return o.ValueScope;
    } }), Object.defineProperty(i, "ValueScopeName", { enumerable: !0, get: function() {
      return o.ValueScopeName;
    } }), Object.defineProperty(i, "varKinds", { enumerable: !0, get: function() {
      return o.varKinds;
    } }), i.operators = {
      GT: new A._Code(">"),
      GTE: new A._Code(">="),
      LT: new A._Code("<"),
      LTE: new A._Code("<="),
      EQ: new A._Code("==="),
      NEQ: new A._Code("!=="),
      NOT: new A._Code("!"),
      OR: new A._Code("||"),
      AND: new A._Code("&&"),
      ADD: new A._Code("+")
    };
    class r {
      optimizeNodes() {
        return this;
      }
      optimizeNames(D, M) {
        return this;
      }
    }
    class s extends r {
      constructor(D, M, U) {
        super(), this.varKind = D, this.name = M, this.rhs = U;
      }
      render({ es5: D, _n: M }) {
        const U = D ? e.varKinds.var : this.varKind, P = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${U} ${this.name}${P};` + M;
      }
      optimizeNames(D, M) {
        if (D[this.name.str])
          return this.rhs && (this.rhs = z(this.rhs, D, M)), this;
      }
      get names() {
        return this.rhs instanceof A._CodeOrName ? this.rhs.names : {};
      }
    }
    class g extends r {
      constructor(D, M, U) {
        super(), this.lhs = D, this.rhs = M, this.sideEffects = U;
      }
      render({ _n: D }) {
        return `${this.lhs} = ${this.rhs};` + D;
      }
      optimizeNames(D, M) {
        if (!(this.lhs instanceof A.Name && !D[this.lhs.str] && !this.sideEffects))
          return this.rhs = z(this.rhs, D, M), this;
      }
      get names() {
        const D = this.lhs instanceof A.Name ? {} : { ...this.lhs.names };
        return J(D, this.rhs);
      }
    }
    class n extends g {
      constructor(D, M, U, P) {
        super(D, U, P), this.op = M;
      }
      render({ _n: D }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + D;
      }
    }
    class a extends r {
      constructor(D) {
        super(), this.label = D, this.names = {};
      }
      render({ _n: D }) {
        return `${this.label}:` + D;
      }
    }
    class I extends r {
      constructor(D) {
        super(), this.label = D, this.names = {};
      }
      render({ _n: D }) {
        return `break${this.label ? ` ${this.label}` : ""};` + D;
      }
    }
    class C extends r {
      constructor(D) {
        super(), this.error = D;
      }
      render({ _n: D }) {
        return `throw ${this.error};` + D;
      }
      get names() {
        return this.error.names;
      }
    }
    class c extends r {
      constructor(D) {
        super(), this.code = D;
      }
      render({ _n: D }) {
        return `${this.code};` + D;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(D, M) {
        return this.code = z(this.code, D, M), this;
      }
      get names() {
        return this.code instanceof A._CodeOrName ? this.code.names : {};
      }
    }
    class B extends r {
      constructor(D = []) {
        super(), this.nodes = D;
      }
      render(D) {
        return this.nodes.reduce((M, U) => M + U.render(D), "");
      }
      optimizeNodes() {
        const { nodes: D } = this;
        let M = D.length;
        for (; M--; ) {
          const U = D[M].optimizeNodes();
          Array.isArray(U) ? D.splice(M, 1, ...U) : U ? D[M] = U : D.splice(M, 1);
        }
        return D.length > 0 ? this : void 0;
      }
      optimizeNames(D, M) {
        const { nodes: U } = this;
        let P = U.length;
        for (; P--; ) {
          const G = U[P];
          G.optimizeNames(D, M) || (X(D, G.names), U.splice(P, 1));
        }
        return U.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((D, M) => j(D, M.names), {});
      }
    }
    class Q extends B {
      render(D) {
        return "{" + D._n + super.render(D) + "}" + D._n;
      }
    }
    class f extends B {
    }
    class l extends Q {
    }
    l.kind = "else";
    class d extends Q {
      constructor(D, M) {
        super(M), this.condition = D;
      }
      render(D) {
        let M = `if(${this.condition})` + super.render(D);
        return this.else && (M += "else " + this.else.render(D)), M;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const D = this.condition;
        if (D === !0)
          return this.nodes;
        let M = this.else;
        if (M) {
          const U = M.optimizeNodes();
          M = this.else = Array.isArray(U) ? new l(U) : U;
        }
        if (M)
          return D === !1 ? M instanceof d ? M : M.nodes : this.nodes.length ? this : new d(Z(D), M instanceof d ? [M] : M.nodes);
        if (!(D === !1 || !this.nodes.length))
          return this;
      }
      optimizeNames(D, M) {
        var U;
        if (this.else = (U = this.else) === null || U === void 0 ? void 0 : U.optimizeNames(D, M), !!(super.optimizeNames(D, M) || this.else))
          return this.condition = z(this.condition, D, M), this;
      }
      get names() {
        const D = super.names;
        return J(D, this.condition), this.else && j(D, this.else.names), D;
      }
    }
    d.kind = "if";
    class u extends Q {
    }
    u.kind = "for";
    class h extends u {
      constructor(D) {
        super(), this.iteration = D;
      }
      render(D) {
        return `for(${this.iteration})` + super.render(D);
      }
      optimizeNames(D, M) {
        if (super.optimizeNames(D, M))
          return this.iteration = z(this.iteration, D, M), this;
      }
      get names() {
        return j(super.names, this.iteration.names);
      }
    }
    class w extends u {
      constructor(D, M, U, P) {
        super(), this.varKind = D, this.name = M, this.from = U, this.to = P;
      }
      render(D) {
        const M = D.es5 ? e.varKinds.var : this.varKind, { name: U, from: P, to: G } = this;
        return `for(${M} ${U}=${P}; ${U}<${G}; ${U}++)` + super.render(D);
      }
      get names() {
        const D = J(super.names, this.from);
        return J(D, this.to);
      }
    }
    class E extends u {
      constructor(D, M, U, P) {
        super(), this.loop = D, this.varKind = M, this.name = U, this.iterable = P;
      }
      render(D) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(D);
      }
      optimizeNames(D, M) {
        if (super.optimizeNames(D, M))
          return this.iterable = z(this.iterable, D, M), this;
      }
      get names() {
        return j(super.names, this.iterable.names);
      }
    }
    class p extends Q {
      constructor(D, M, U) {
        super(), this.name = D, this.args = M, this.async = U;
      }
      render(D) {
        return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(D);
      }
    }
    p.kind = "func";
    class y extends B {
      render(D) {
        return "return " + super.render(D);
      }
    }
    y.kind = "return";
    class m extends Q {
      render(D) {
        let M = "try" + super.render(D);
        return this.catch && (M += this.catch.render(D)), this.finally && (M += this.finally.render(D)), M;
      }
      optimizeNodes() {
        var D, M;
        return super.optimizeNodes(), (D = this.catch) === null || D === void 0 || D.optimizeNodes(), (M = this.finally) === null || M === void 0 || M.optimizeNodes(), this;
      }
      optimizeNames(D, M) {
        var U, P;
        return super.optimizeNames(D, M), (U = this.catch) === null || U === void 0 || U.optimizeNames(D, M), (P = this.finally) === null || P === void 0 || P.optimizeNames(D, M), this;
      }
      get names() {
        const D = super.names;
        return this.catch && j(D, this.catch.names), this.finally && j(D, this.finally.names), D;
      }
    }
    class N extends Q {
      constructor(D) {
        super(), this.error = D;
      }
      render(D) {
        return `catch(${this.error})` + super.render(D);
      }
    }
    N.kind = "catch";
    class R extends Q {
      render(D) {
        return "finally" + super.render(D);
      }
    }
    R.kind = "finally";
    class L {
      constructor(D, M = {}) {
        this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...M, _n: M.lines ? `
` : "" }, this._extScope = D, this._scope = new e.Scope({ parent: D }), this._nodes = [new f()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(D) {
        return this._scope.name(D);
      }
      // reserves unique name in the external scope
      scopeName(D) {
        return this._extScope.name(D);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(D, M) {
        const U = this._extScope.value(D, M);
        return (this._values[U.prefix] || (this._values[U.prefix] = /* @__PURE__ */ new Set())).add(U), U;
      }
      getScopeValue(D, M) {
        return this._extScope.getValue(D, M);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(D) {
        return this._extScope.scopeRefs(D, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(D, M, U, P) {
        const G = this._scope.toName(M);
        return U !== void 0 && P && (this._constants[G.str] = U), this._leafNode(new s(D, G, U)), G;
      }
      // `const` declaration (`var` in es5 mode)
      const(D, M, U) {
        return this._def(e.varKinds.const, D, M, U);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(D, M, U) {
        return this._def(e.varKinds.let, D, M, U);
      }
      // `var` declaration with optional assignment
      var(D, M, U) {
        return this._def(e.varKinds.var, D, M, U);
      }
      // assignment code
      assign(D, M, U) {
        return this._leafNode(new g(D, M, U));
      }
      // `+=` code
      add(D, M) {
        return this._leafNode(new n(D, i.operators.ADD, M));
      }
      // appends passed SafeExpr to code or executes Block
      code(D) {
        return typeof D == "function" ? D() : D !== A.nil && this._leafNode(new c(D)), this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...D) {
        const M = ["{"];
        for (const [U, P] of D)
          M.length > 1 && M.push(","), M.push(U), (U !== P || this.opts.es5) && (M.push(":"), (0, A.addCodeArg)(M, P));
        return M.push("}"), new A._Code(M);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(D, M, U) {
        if (this._blockNode(new d(D)), M && U)
          this.code(M).else().code(U).endIf();
        else if (M)
          this.code(M).endIf();
        else if (U)
          throw new Error('CodeGen: "else" body without "then" body');
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(D) {
        return this._elseNode(new d(D));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new l());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(d, l);
      }
      _for(D, M) {
        return this._blockNode(D), M && this.code(M).endFor(), this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(D, M) {
        return this._for(new h(D), M);
      }
      // `for` statement for a range of values
      forRange(D, M, U, P, G = this.opts.es5 ? e.varKinds.var : e.varKinds.let) {
        const x = this._scope.toName(D);
        return this._for(new w(G, x, M, U), () => P(x));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(D, M, U, P = e.varKinds.const) {
        const G = this._scope.toName(D);
        if (this.opts.es5) {
          const x = M instanceof A.Name ? M : this.var("_arr", M);
          return this.forRange("_i", 0, (0, A._)`${x}.length`, (Y) => {
            this.var(G, (0, A._)`${x}[${Y}]`), U(G);
          });
        }
        return this._for(new E("of", P, G, M), () => U(G));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(D, M, U, P = this.opts.es5 ? e.varKinds.var : e.varKinds.const) {
        if (this.opts.ownProperties)
          return this.forOf(D, (0, A._)`Object.keys(${M})`, U);
        const G = this._scope.toName(D);
        return this._for(new E("in", P, G, M), () => U(G));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(u);
      }
      // `label` statement
      label(D) {
        return this._leafNode(new a(D));
      }
      // `break` statement
      break(D) {
        return this._leafNode(new I(D));
      }
      // `return` statement
      return(D) {
        const M = new y();
        if (this._blockNode(M), this.code(D), M.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(y);
      }
      // `try` statement
      try(D, M, U) {
        if (!M && !U)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const P = new m();
        if (this._blockNode(P), this.code(D), M) {
          const G = this.name("e");
          this._currNode = P.catch = new N(G), M(G);
        }
        return U && (this._currNode = P.finally = new R(), this.code(U)), this._endBlockNode(N, R);
      }
      // `throw` statement
      throw(D) {
        return this._leafNode(new C(D));
      }
      // start self-balancing block
      block(D, M) {
        return this._blockStarts.push(this._nodes.length), D && this.code(D).endBlock(M), this;
      }
      // end the current self-balancing block
      endBlock(D) {
        const M = this._blockStarts.pop();
        if (M === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const U = this._nodes.length - M;
        if (U < 0 || D !== void 0 && U !== D)
          throw new Error(`CodeGen: wrong number of nodes: ${U} vs ${D} expected`);
        return this._nodes.length = M, this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(D, M = A.nil, U, P) {
        return this._blockNode(new p(D, M, U)), P && this.code(P).endFunc(), this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(p);
      }
      optimize(D = 1) {
        for (; D-- > 0; )
          this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
      }
      _leafNode(D) {
        return this._currNode.nodes.push(D), this;
      }
      _blockNode(D) {
        this._currNode.nodes.push(D), this._nodes.push(D);
      }
      _endBlockNode(D, M) {
        const U = this._currNode;
        if (U instanceof D || M && U instanceof M)
          return this._nodes.pop(), this;
        throw new Error(`CodeGen: not in block "${M ? `${D.kind}/${M.kind}` : D.kind}"`);
      }
      _elseNode(D) {
        const M = this._currNode;
        if (!(M instanceof d))
          throw new Error('CodeGen: "else" without "if"');
        return this._currNode = M.else = D, this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const D = this._nodes;
        return D[D.length - 1];
      }
      set _currNode(D) {
        const M = this._nodes;
        M[M.length - 1] = D;
      }
    }
    i.CodeGen = L;
    function j(b, D) {
      for (const M in D)
        b[M] = (b[M] || 0) + (D[M] || 0);
      return b;
    }
    function J(b, D) {
      return D instanceof A._CodeOrName ? j(b, D.names) : b;
    }
    function z(b, D, M) {
      if (b instanceof A.Name)
        return U(b);
      if (!P(b))
        return b;
      return new A._Code(b._items.reduce((G, x) => (x instanceof A.Name && (x = U(x)), x instanceof A._Code ? G.push(...x._items) : G.push(x), G), []));
      function U(G) {
        const x = M[G.str];
        return x === void 0 || D[G.str] !== 1 ? G : (delete D[G.str], x);
      }
      function P(G) {
        return G instanceof A._Code && G._items.some((x) => x instanceof A.Name && D[x.str] === 1 && M[x.str] !== void 0);
      }
    }
    function X(b, D) {
      for (const M in D)
        b[M] = (b[M] || 0) - (D[M] || 0);
    }
    function Z(b) {
      return typeof b == "boolean" || typeof b == "number" || b === null ? !b : (0, A._)`!${q(b)}`;
    }
    i.not = Z;
    const _ = F(i.operators.AND);
    function T(...b) {
      return b.reduce(_);
    }
    i.and = T;
    const $ = F(i.operators.OR);
    function O(...b) {
      return b.reduce($);
    }
    i.or = O;
    function F(b) {
      return (D, M) => D === A.nil ? M : M === A.nil ? D : (0, A._)`${q(D)} ${b} ${q(M)}`;
    }
    function q(b) {
      return b instanceof A.Name ? b : (0, A._)`(${b})`;
    }
  })(ar)), ar;
}
var rA = {}, Rg;
function sA() {
  if (Rg) return rA;
  Rg = 1, Object.defineProperty(rA, "__esModule", { value: !0 }), rA.checkStrictMode = rA.getErrorPath = rA.Type = rA.useFunc = rA.setEvaluated = rA.evaluatedPropsToName = rA.mergeEvaluated = rA.eachItem = rA.unescapeJsonPointer = rA.escapeJsonPointer = rA.escapeFragment = rA.unescapeFragment = rA.schemaRefOrVal = rA.schemaHasRulesButRef = rA.schemaHasRules = rA.checkUnknownRules = rA.alwaysValidSchema = rA.toHash = void 0;
  const i = oA(), A = Qo();
  function e(E) {
    const p = {};
    for (const y of E)
      p[y] = !0;
    return p;
  }
  rA.toHash = e;
  function t(E, p) {
    return typeof p == "boolean" ? p : Object.keys(p).length === 0 ? !0 : (o(E, p), !r(p, E.self.RULES.all));
  }
  rA.alwaysValidSchema = t;
  function o(E, p = E.schema) {
    const { opts: y, self: m } = E;
    if (!y.strictSchema || typeof p == "boolean")
      return;
    const N = m.RULES.keywords;
    for (const R in p)
      N[R] || w(E, `unknown keyword: "${R}"`);
  }
  rA.checkUnknownRules = o;
  function r(E, p) {
    if (typeof E == "boolean")
      return !E;
    for (const y in E)
      if (p[y])
        return !0;
    return !1;
  }
  rA.schemaHasRules = r;
  function s(E, p) {
    if (typeof E == "boolean")
      return !E;
    for (const y in E)
      if (y !== "$ref" && p.all[y])
        return !0;
    return !1;
  }
  rA.schemaHasRulesButRef = s;
  function g({ topSchemaRef: E, schemaPath: p }, y, m, N) {
    if (!N) {
      if (typeof y == "number" || typeof y == "boolean")
        return y;
      if (typeof y == "string")
        return (0, i._)`${y}`;
    }
    return (0, i._)`${E}${p}${(0, i.getProperty)(m)}`;
  }
  rA.schemaRefOrVal = g;
  function n(E) {
    return C(decodeURIComponent(E));
  }
  rA.unescapeFragment = n;
  function a(E) {
    return encodeURIComponent(I(E));
  }
  rA.escapeFragment = a;
  function I(E) {
    return typeof E == "number" ? `${E}` : E.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  rA.escapeJsonPointer = I;
  function C(E) {
    return E.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  rA.unescapeJsonPointer = C;
  function c(E, p) {
    if (Array.isArray(E))
      for (const y of E)
        p(y);
    else
      p(E);
  }
  rA.eachItem = c;
  function B({ mergeNames: E, mergeToName: p, mergeValues: y, resultToName: m }) {
    return (N, R, L, j) => {
      const J = L === void 0 ? R : L instanceof i.Name ? (R instanceof i.Name ? E(N, R, L) : p(N, R, L), L) : R instanceof i.Name ? (p(N, L, R), R) : y(R, L);
      return j === i.Name && !(J instanceof i.Name) ? m(N, J) : J;
    };
  }
  rA.mergeEvaluated = {
    props: B({
      mergeNames: (E, p, y) => E.if((0, i._)`${y} !== true && ${p} !== undefined`, () => {
        E.if((0, i._)`${p} === true`, () => E.assign(y, !0), () => E.assign(y, (0, i._)`${y} || {}`).code((0, i._)`Object.assign(${y}, ${p})`));
      }),
      mergeToName: (E, p, y) => E.if((0, i._)`${y} !== true`, () => {
        p === !0 ? E.assign(y, !0) : (E.assign(y, (0, i._)`${y} || {}`), f(E, y, p));
      }),
      mergeValues: (E, p) => E === !0 ? !0 : { ...E, ...p },
      resultToName: Q
    }),
    items: B({
      mergeNames: (E, p, y) => E.if((0, i._)`${y} !== true && ${p} !== undefined`, () => E.assign(y, (0, i._)`${p} === true ? true : ${y} > ${p} ? ${y} : ${p}`)),
      mergeToName: (E, p, y) => E.if((0, i._)`${y} !== true`, () => E.assign(y, p === !0 ? !0 : (0, i._)`${y} > ${p} ? ${y} : ${p}`)),
      mergeValues: (E, p) => E === !0 ? !0 : Math.max(E, p),
      resultToName: (E, p) => E.var("items", p)
    })
  };
  function Q(E, p) {
    if (p === !0)
      return E.var("props", !0);
    const y = E.var("props", (0, i._)`{}`);
    return p !== void 0 && f(E, y, p), y;
  }
  rA.evaluatedPropsToName = Q;
  function f(E, p, y) {
    Object.keys(y).forEach((m) => E.assign((0, i._)`${p}${(0, i.getProperty)(m)}`, !0));
  }
  rA.setEvaluated = f;
  const l = {};
  function d(E, p) {
    return E.scopeValue("func", {
      ref: p,
      code: l[p.code] || (l[p.code] = new A._Code(p.code))
    });
  }
  rA.useFunc = d;
  var u;
  (function(E) {
    E[E.Num = 0] = "Num", E[E.Str = 1] = "Str";
  })(u || (rA.Type = u = {}));
  function h(E, p, y) {
    if (E instanceof i.Name) {
      const m = p === u.Num;
      return y ? m ? (0, i._)`"[" + ${E} + "]"` : (0, i._)`"['" + ${E} + "']"` : m ? (0, i._)`"/" + ${E}` : (0, i._)`"/" + ${E}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return y ? (0, i.getProperty)(E).toString() : "/" + I(E);
  }
  rA.getErrorPath = h;
  function w(E, p, y = E.opts.strictSchema) {
    if (y) {
      if (p = `strict mode: ${p}`, y === !0)
        throw new Error(p);
      E.self.logger.warn(p);
    }
  }
  return rA.checkStrictMode = w, rA;
}
var gi = {}, bg;
function zA() {
  if (bg) return gi;
  bg = 1, Object.defineProperty(gi, "__esModule", { value: !0 });
  const i = oA(), A = {
    // validation function arguments
    data: new i.Name("data"),
    // data passed to validation function
    // args passed from referencing schema
    valCxt: new i.Name("valCxt"),
    // validation/data context - should not be used directly, it is destructured to the names below
    instancePath: new i.Name("instancePath"),
    parentData: new i.Name("parentData"),
    parentDataProperty: new i.Name("parentDataProperty"),
    rootData: new i.Name("rootData"),
    // root data - same as the data passed to the first/top validation function
    dynamicAnchors: new i.Name("dynamicAnchors"),
    // used to support recursiveRef and dynamicRef
    // function scoped variables
    vErrors: new i.Name("vErrors"),
    // null or array of validation errors
    errors: new i.Name("errors"),
    // counter of validation errors
    this: new i.Name("this"),
    // "globals"
    self: new i.Name("self"),
    scope: new i.Name("scope"),
    // JTD serialize/parse name for JSON string and position
    json: new i.Name("json"),
    jsonPos: new i.Name("jsonPos"),
    jsonLen: new i.Name("jsonLen"),
    jsonPart: new i.Name("jsonPart")
  };
  return gi.default = A, gi;
}
var Kg;
function bo() {
  return Kg || (Kg = 1, (function(i) {
    Object.defineProperty(i, "__esModule", { value: !0 }), i.extendErrors = i.resetErrorsCount = i.reportExtraError = i.reportError = i.keyword$DataError = i.keywordError = void 0;
    const A = oA(), e = sA(), t = zA();
    i.keywordError = {
      message: ({ keyword: l }) => (0, A.str)`must pass "${l}" keyword validation`
    }, i.keyword$DataError = {
      message: ({ keyword: l, schemaType: d }) => d ? (0, A.str)`"${l}" keyword must be ${d} ($data)` : (0, A.str)`"${l}" keyword is invalid ($data)`
    };
    function o(l, d = i.keywordError, u, h) {
      const { it: w } = l, { gen: E, compositeRule: p, allErrors: y } = w, m = C(l, d, u);
      h ?? (p || y) ? n(E, m) : a(w, (0, A._)`[${m}]`);
    }
    i.reportError = o;
    function r(l, d = i.keywordError, u) {
      const { it: h } = l, { gen: w, compositeRule: E, allErrors: p } = h, y = C(l, d, u);
      n(w, y), E || p || a(h, t.default.vErrors);
    }
    i.reportExtraError = r;
    function s(l, d) {
      l.assign(t.default.errors, d), l.if((0, A._)`${t.default.vErrors} !== null`, () => l.if(d, () => l.assign((0, A._)`${t.default.vErrors}.length`, d), () => l.assign(t.default.vErrors, null)));
    }
    i.resetErrorsCount = s;
    function g({ gen: l, keyword: d, schemaValue: u, data: h, errsCount: w, it: E }) {
      if (w === void 0)
        throw new Error("ajv implementation error");
      const p = l.name("err");
      l.forRange("i", w, t.default.errors, (y) => {
        l.const(p, (0, A._)`${t.default.vErrors}[${y}]`), l.if((0, A._)`${p}.instancePath === undefined`, () => l.assign((0, A._)`${p}.instancePath`, (0, A.strConcat)(t.default.instancePath, E.errorPath))), l.assign((0, A._)`${p}.schemaPath`, (0, A.str)`${E.errSchemaPath}/${d}`), E.opts.verbose && (l.assign((0, A._)`${p}.schema`, u), l.assign((0, A._)`${p}.data`, h));
      });
    }
    i.extendErrors = g;
    function n(l, d) {
      const u = l.const("err", d);
      l.if((0, A._)`${t.default.vErrors} === null`, () => l.assign(t.default.vErrors, (0, A._)`[${u}]`), (0, A._)`${t.default.vErrors}.push(${u})`), l.code((0, A._)`${t.default.errors}++`);
    }
    function a(l, d) {
      const { gen: u, validateName: h, schemaEnv: w } = l;
      w.$async ? u.throw((0, A._)`new ${l.ValidationError}(${d})`) : (u.assign((0, A._)`${h}.errors`, d), u.return(!1));
    }
    const I = {
      keyword: new A.Name("keyword"),
      schemaPath: new A.Name("schemaPath"),
      // also used in JTD errors
      params: new A.Name("params"),
      propertyName: new A.Name("propertyName"),
      message: new A.Name("message"),
      schema: new A.Name("schema"),
      parentSchema: new A.Name("parentSchema")
    };
    function C(l, d, u) {
      const { createErrors: h } = l.it;
      return h === !1 ? (0, A._)`{}` : c(l, d, u);
    }
    function c(l, d, u = {}) {
      const { gen: h, it: w } = l, E = [
        B(w, u),
        Q(l, u)
      ];
      return f(l, d, E), h.object(...E);
    }
    function B({ errorPath: l }, { instancePath: d }) {
      const u = d ? (0, A.str)`${l}${(0, e.getErrorPath)(d, e.Type.Str)}` : l;
      return [t.default.instancePath, (0, A.strConcat)(t.default.instancePath, u)];
    }
    function Q({ keyword: l, it: { errSchemaPath: d } }, { schemaPath: u, parentSchema: h }) {
      let w = h ? d : (0, A.str)`${d}/${l}`;
      return u && (w = (0, A.str)`${w}${(0, e.getErrorPath)(u, e.Type.Str)}`), [I.schemaPath, w];
    }
    function f(l, { params: d, message: u }, h) {
      const { keyword: w, data: E, schemaValue: p, it: y } = l, { opts: m, propertyName: N, topSchemaRef: R, schemaPath: L } = y;
      h.push([I.keyword, w], [I.params, typeof d == "function" ? d(l) : d || (0, A._)`{}`]), m.messages && h.push([I.message, typeof u == "function" ? u(l) : u]), m.verbose && h.push([I.schema, p], [I.parentSchema, (0, A._)`${R}${L}`], [t.default.data, E]), N && h.push([I.propertyName, N]);
    }
  })(nr)), nr;
}
var Yg;
function FD() {
  if (Yg) return he;
  Yg = 1, Object.defineProperty(he, "__esModule", { value: !0 }), he.boolOrEmptySchema = he.topBoolOrEmptySchema = void 0;
  const i = bo(), A = oA(), e = zA(), t = {
    message: "boolean schema is false"
  };
  function o(g) {
    const { gen: n, schema: a, validateName: I } = g;
    a === !1 ? s(g, !1) : typeof a == "object" && a.$async === !0 ? n.return(e.default.data) : (n.assign((0, A._)`${I}.errors`, null), n.return(!0));
  }
  he.topBoolOrEmptySchema = o;
  function r(g, n) {
    const { gen: a, schema: I } = g;
    I === !1 ? (a.var(n, !1), s(g)) : a.var(n, !0);
  }
  he.boolOrEmptySchema = r;
  function s(g, n) {
    const { gen: a, data: I } = g, C = {
      gen: a,
      keyword: "false schema",
      data: I,
      schema: !1,
      schemaCode: !1,
      schemaValue: !1,
      params: {},
      it: g
    };
    (0, i.reportError)(C, t, void 0, n);
  }
  return he;
}
var mA = {}, fe = {}, Ug;
function JI() {
  if (Ug) return fe;
  Ug = 1, Object.defineProperty(fe, "__esModule", { value: !0 }), fe.getRules = fe.isJSONType = void 0;
  const i = ["string", "number", "integer", "boolean", "null", "object", "array"], A = new Set(i);
  function e(o) {
    return typeof o == "string" && A.has(o);
  }
  fe.isJSONType = e;
  function t() {
    const o = {
      number: { type: "number", rules: [] },
      string: { type: "string", rules: [] },
      array: { type: "array", rules: [] },
      object: { type: "object", rules: [] }
    };
    return {
      types: { ...o, integer: !0, boolean: !0, null: !0 },
      rules: [{ rules: [] }, o.number, o.string, o.array, o.object],
      post: { rules: [] },
      all: {},
      keywords: {}
    };
  }
  return fe.getRules = t, fe;
}
var oe = {}, vg;
function HI() {
  if (vg) return oe;
  vg = 1, Object.defineProperty(oe, "__esModule", { value: !0 }), oe.shouldUseRule = oe.shouldUseGroup = oe.schemaHasRulesForType = void 0;
  function i({ schema: t, self: o }, r) {
    const s = o.RULES.types[r];
    return s && s !== !0 && A(t, s);
  }
  oe.schemaHasRulesForType = i;
  function A(t, o) {
    return o.rules.some((r) => e(t, r));
  }
  oe.shouldUseGroup = A;
  function e(t, o) {
    var r;
    return t[o.keyword] !== void 0 || ((r = o.definition.implements) === null || r === void 0 ? void 0 : r.some((s) => t[s] !== void 0));
  }
  return oe.shouldUseRule = e, oe;
}
var Jg;
function Eo() {
  if (Jg) return mA;
  Jg = 1, Object.defineProperty(mA, "__esModule", { value: !0 }), mA.reportTypeError = mA.checkDataTypes = mA.checkDataType = mA.coerceAndCheckDataType = mA.getJSONTypes = mA.getSchemaTypes = mA.DataType = void 0;
  const i = JI(), A = HI(), e = bo(), t = oA(), o = sA();
  var r;
  (function(u) {
    u[u.Correct = 0] = "Correct", u[u.Wrong = 1] = "Wrong";
  })(r || (mA.DataType = r = {}));
  function s(u) {
    const h = g(u.type);
    if (h.includes("null")) {
      if (u.nullable === !1)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!h.length && u.nullable !== void 0)
        throw new Error('"nullable" cannot be used without "type"');
      u.nullable === !0 && h.push("null");
    }
    return h;
  }
  mA.getSchemaTypes = s;
  function g(u) {
    const h = Array.isArray(u) ? u : u ? [u] : [];
    if (h.every(i.isJSONType))
      return h;
    throw new Error("type must be JSONType or JSONType[]: " + h.join(","));
  }
  mA.getJSONTypes = g;
  function n(u, h) {
    const { gen: w, data: E, opts: p } = u, y = I(h, p.coerceTypes), m = h.length > 0 && !(y.length === 0 && h.length === 1 && (0, A.schemaHasRulesForType)(u, h[0]));
    if (m) {
      const N = Q(h, E, p.strictNumbers, r.Wrong);
      w.if(N, () => {
        y.length ? C(u, h, y) : l(u);
      });
    }
    return m;
  }
  mA.coerceAndCheckDataType = n;
  const a = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
  function I(u, h) {
    return h ? u.filter((w) => a.has(w) || h === "array" && w === "array") : [];
  }
  function C(u, h, w) {
    const { gen: E, data: p, opts: y } = u, m = E.let("dataType", (0, t._)`typeof ${p}`), N = E.let("coerced", (0, t._)`undefined`);
    y.coerceTypes === "array" && E.if((0, t._)`${m} == 'object' && Array.isArray(${p}) && ${p}.length == 1`, () => E.assign(p, (0, t._)`${p}[0]`).assign(m, (0, t._)`typeof ${p}`).if(Q(h, p, y.strictNumbers), () => E.assign(N, p))), E.if((0, t._)`${N} !== undefined`);
    for (const L of w)
      (a.has(L) || L === "array" && y.coerceTypes === "array") && R(L);
    E.else(), l(u), E.endIf(), E.if((0, t._)`${N} !== undefined`, () => {
      E.assign(p, N), c(u, N);
    });
    function R(L) {
      switch (L) {
        case "string":
          E.elseIf((0, t._)`${m} == "number" || ${m} == "boolean"`).assign(N, (0, t._)`"" + ${p}`).elseIf((0, t._)`${p} === null`).assign(N, (0, t._)`""`);
          return;
        case "number":
          E.elseIf((0, t._)`${m} == "boolean" || ${p} === null
              || (${m} == "string" && ${p} && ${p} == +${p})`).assign(N, (0, t._)`+${p}`);
          return;
        case "integer":
          E.elseIf((0, t._)`${m} === "boolean" || ${p} === null
              || (${m} === "string" && ${p} && ${p} == +${p} && !(${p} % 1))`).assign(N, (0, t._)`+${p}`);
          return;
        case "boolean":
          E.elseIf((0, t._)`${p} === "false" || ${p} === 0 || ${p} === null`).assign(N, !1).elseIf((0, t._)`${p} === "true" || ${p} === 1`).assign(N, !0);
          return;
        case "null":
          E.elseIf((0, t._)`${p} === "" || ${p} === 0 || ${p} === false`), E.assign(N, null);
          return;
        case "array":
          E.elseIf((0, t._)`${m} === "string" || ${m} === "number"
              || ${m} === "boolean" || ${p} === null`).assign(N, (0, t._)`[${p}]`);
      }
    }
  }
  function c({ gen: u, parentData: h, parentDataProperty: w }, E) {
    u.if((0, t._)`${h} !== undefined`, () => u.assign((0, t._)`${h}[${w}]`, E));
  }
  function B(u, h, w, E = r.Correct) {
    const p = E === r.Correct ? t.operators.EQ : t.operators.NEQ;
    let y;
    switch (u) {
      case "null":
        return (0, t._)`${h} ${p} null`;
      case "array":
        y = (0, t._)`Array.isArray(${h})`;
        break;
      case "object":
        y = (0, t._)`${h} && typeof ${h} == "object" && !Array.isArray(${h})`;
        break;
      case "integer":
        y = m((0, t._)`!(${h} % 1) && !isNaN(${h})`);
        break;
      case "number":
        y = m();
        break;
      default:
        return (0, t._)`typeof ${h} ${p} ${u}`;
    }
    return E === r.Correct ? y : (0, t.not)(y);
    function m(N = t.nil) {
      return (0, t.and)((0, t._)`typeof ${h} == "number"`, N, w ? (0, t._)`isFinite(${h})` : t.nil);
    }
  }
  mA.checkDataType = B;
  function Q(u, h, w, E) {
    if (u.length === 1)
      return B(u[0], h, w, E);
    let p;
    const y = (0, o.toHash)(u);
    if (y.array && y.object) {
      const m = (0, t._)`typeof ${h} != "object"`;
      p = y.null ? m : (0, t._)`!${h} || ${m}`, delete y.null, delete y.array, delete y.object;
    } else
      p = t.nil;
    y.number && delete y.integer;
    for (const m in y)
      p = (0, t.and)(p, B(m, h, w, E));
    return p;
  }
  mA.checkDataTypes = Q;
  const f = {
    message: ({ schema: u }) => `must be ${u}`,
    params: ({ schema: u, schemaValue: h }) => typeof u == "string" ? (0, t._)`{type: ${u}}` : (0, t._)`{type: ${h}}`
  };
  function l(u) {
    const h = d(u);
    (0, e.reportError)(h, f);
  }
  mA.reportTypeError = l;
  function d(u) {
    const { gen: h, data: w, schema: E } = u, p = (0, o.schemaRefOrVal)(u, E, "type");
    return {
      gen: h,
      keyword: "type",
      data: w,
      schema: E.type,
      schemaCode: p,
      schemaValue: p,
      parentSchema: E,
      params: {},
      it: u
    };
  }
  return mA;
}
var dt = {}, Hg;
function RD() {
  if (Hg) return dt;
  Hg = 1, Object.defineProperty(dt, "__esModule", { value: !0 }), dt.assignDefaults = void 0;
  const i = oA(), A = sA();
  function e(o, r) {
    const { properties: s, items: g } = o.schema;
    if (r === "object" && s)
      for (const n in s)
        t(o, n, s[n].default);
    else r === "array" && Array.isArray(g) && g.forEach((n, a) => t(o, a, n.default));
  }
  dt.assignDefaults = e;
  function t(o, r, s) {
    const { gen: g, compositeRule: n, data: a, opts: I } = o;
    if (s === void 0)
      return;
    const C = (0, i._)`${a}${(0, i.getProperty)(r)}`;
    if (n) {
      (0, A.checkStrictMode)(o, `default is ignored for: ${C}`);
      return;
    }
    let c = (0, i._)`${C} === undefined`;
    I.useDefaults === "empty" && (c = (0, i._)`${c} || ${C} === null || ${C} === ""`), g.if(c, (0, i._)`${C} = ${(0, i.stringify)(s)}`);
  }
  return dt;
}
var PA = {}, CA = {}, qg;
function ZA() {
  if (qg) return CA;
  qg = 1, Object.defineProperty(CA, "__esModule", { value: !0 }), CA.validateUnion = CA.validateArray = CA.usePattern = CA.callValidateCode = CA.schemaProperties = CA.allSchemaProperties = CA.noPropertyInData = CA.propertyInData = CA.isOwnProperty = CA.hasPropFunc = CA.reportMissingProp = CA.checkMissingProp = CA.checkReportMissingProp = void 0;
  const i = oA(), A = sA(), e = zA(), t = sA();
  function o(u, h) {
    const { gen: w, data: E, it: p } = u;
    w.if(I(w, E, h, p.opts.ownProperties), () => {
      u.setParams({ missingProperty: (0, i._)`${h}` }, !0), u.error();
    });
  }
  CA.checkReportMissingProp = o;
  function r({ gen: u, data: h, it: { opts: w } }, E, p) {
    return (0, i.or)(...E.map((y) => (0, i.and)(I(u, h, y, w.ownProperties), (0, i._)`${p} = ${y}`)));
  }
  CA.checkMissingProp = r;
  function s(u, h) {
    u.setParams({ missingProperty: h }, !0), u.error();
  }
  CA.reportMissingProp = s;
  function g(u) {
    return u.scopeValue("func", {
      // eslint-disable-next-line @typescript-eslint/unbound-method
      ref: Object.prototype.hasOwnProperty,
      code: (0, i._)`Object.prototype.hasOwnProperty`
    });
  }
  CA.hasPropFunc = g;
  function n(u, h, w) {
    return (0, i._)`${g(u)}.call(${h}, ${w})`;
  }
  CA.isOwnProperty = n;
  function a(u, h, w, E) {
    const p = (0, i._)`${h}${(0, i.getProperty)(w)} !== undefined`;
    return E ? (0, i._)`${p} && ${n(u, h, w)}` : p;
  }
  CA.propertyInData = a;
  function I(u, h, w, E) {
    const p = (0, i._)`${h}${(0, i.getProperty)(w)} === undefined`;
    return E ? (0, i.or)(p, (0, i.not)(n(u, h, w))) : p;
  }
  CA.noPropertyInData = I;
  function C(u) {
    return u ? Object.keys(u).filter((h) => h !== "__proto__") : [];
  }
  CA.allSchemaProperties = C;
  function c(u, h) {
    return C(h).filter((w) => !(0, A.alwaysValidSchema)(u, h[w]));
  }
  CA.schemaProperties = c;
  function B({ schemaCode: u, data: h, it: { gen: w, topSchemaRef: E, schemaPath: p, errorPath: y }, it: m }, N, R, L) {
    const j = L ? (0, i._)`${u}, ${h}, ${E}${p}` : h, J = [
      [e.default.instancePath, (0, i.strConcat)(e.default.instancePath, y)],
      [e.default.parentData, m.parentData],
      [e.default.parentDataProperty, m.parentDataProperty],
      [e.default.rootData, e.default.rootData]
    ];
    m.opts.dynamicRef && J.push([e.default.dynamicAnchors, e.default.dynamicAnchors]);
    const z = (0, i._)`${j}, ${w.object(...J)}`;
    return R !== i.nil ? (0, i._)`${N}.call(${R}, ${z})` : (0, i._)`${N}(${z})`;
  }
  CA.callValidateCode = B;
  const Q = (0, i._)`new RegExp`;
  function f({ gen: u, it: { opts: h } }, w) {
    const E = h.unicodeRegExp ? "u" : "", { regExp: p } = h.code, y = p(w, E);
    return u.scopeValue("pattern", {
      key: y.toString(),
      ref: y,
      code: (0, i._)`${p.code === "new RegExp" ? Q : (0, t.useFunc)(u, p)}(${w}, ${E})`
    });
  }
  CA.usePattern = f;
  function l(u) {
    const { gen: h, data: w, keyword: E, it: p } = u, y = h.name("valid");
    if (p.allErrors) {
      const N = h.let("valid", !0);
      return m(() => h.assign(N, !1)), N;
    }
    return h.var(y, !0), m(() => h.break()), y;
    function m(N) {
      const R = h.const("len", (0, i._)`${w}.length`);
      h.forRange("i", 0, R, (L) => {
        u.subschema({
          keyword: E,
          dataProp: L,
          dataPropType: A.Type.Num
        }, y), h.if((0, i.not)(y), N);
      });
    }
  }
  CA.validateArray = l;
  function d(u) {
    const { gen: h, schema: w, keyword: E, it: p } = u;
    if (!Array.isArray(w))
      throw new Error("ajv implementation error");
    if (w.some((R) => (0, A.alwaysValidSchema)(p, R)) && !p.opts.unevaluated)
      return;
    const m = h.let("valid", !1), N = h.name("_valid");
    h.block(() => w.forEach((R, L) => {
      const j = u.subschema({
        keyword: E,
        schemaProp: L,
        compositeRule: !0
      }, N);
      h.assign(m, (0, i._)`${m} || ${N}`), u.mergeValidEvaluated(j, N) || h.if((0, i.not)(m));
    })), u.result(m, () => u.reset(), () => u.error(!0));
  }
  return CA.validateUnion = d, CA;
}
var Lg;
function bD() {
  if (Lg) return PA;
  Lg = 1, Object.defineProperty(PA, "__esModule", { value: !0 }), PA.validateKeywordUsage = PA.validSchemaType = PA.funcKeywordCode = PA.macroKeywordCode = void 0;
  const i = oA(), A = zA(), e = ZA(), t = bo();
  function o(c, B) {
    const { gen: Q, keyword: f, schema: l, parentSchema: d, it: u } = c, h = B.macro.call(u.self, l, d, u), w = a(Q, f, h);
    u.opts.validateSchema !== !1 && u.self.validateSchema(h, !0);
    const E = Q.name("valid");
    c.subschema({
      schema: h,
      schemaPath: i.nil,
      errSchemaPath: `${u.errSchemaPath}/${f}`,
      topSchemaRef: w,
      compositeRule: !0
    }, E), c.pass(E, () => c.error(!0));
  }
  PA.macroKeywordCode = o;
  function r(c, B) {
    var Q;
    const { gen: f, keyword: l, schema: d, parentSchema: u, $data: h, it: w } = c;
    n(w, B);
    const E = !h && B.compile ? B.compile.call(w.self, d, u, w) : B.validate, p = a(f, l, E), y = f.let("valid");
    c.block$data(y, m), c.ok((Q = B.valid) !== null && Q !== void 0 ? Q : y);
    function m() {
      if (B.errors === !1)
        L(), B.modifying && s(c), j(() => c.error());
      else {
        const J = B.async ? N() : R();
        B.modifying && s(c), j(() => g(c, J));
      }
    }
    function N() {
      const J = f.let("ruleErrs", null);
      return f.try(() => L((0, i._)`await `), (z) => f.assign(y, !1).if((0, i._)`${z} instanceof ${w.ValidationError}`, () => f.assign(J, (0, i._)`${z}.errors`), () => f.throw(z))), J;
    }
    function R() {
      const J = (0, i._)`${p}.errors`;
      return f.assign(J, null), L(i.nil), J;
    }
    function L(J = B.async ? (0, i._)`await ` : i.nil) {
      const z = w.opts.passContext ? A.default.this : A.default.self, X = !("compile" in B && !h || B.schema === !1);
      f.assign(y, (0, i._)`${J}${(0, e.callValidateCode)(c, p, z, X)}`, B.modifying);
    }
    function j(J) {
      var z;
      f.if((0, i.not)((z = B.valid) !== null && z !== void 0 ? z : y), J);
    }
  }
  PA.funcKeywordCode = r;
  function s(c) {
    const { gen: B, data: Q, it: f } = c;
    B.if(f.parentData, () => B.assign(Q, (0, i._)`${f.parentData}[${f.parentDataProperty}]`));
  }
  function g(c, B) {
    const { gen: Q } = c;
    Q.if((0, i._)`Array.isArray(${B})`, () => {
      Q.assign(A.default.vErrors, (0, i._)`${A.default.vErrors} === null ? ${B} : ${A.default.vErrors}.concat(${B})`).assign(A.default.errors, (0, i._)`${A.default.vErrors}.length`), (0, t.extendErrors)(c);
    }, () => c.error());
  }
  function n({ schemaEnv: c }, B) {
    if (B.async && !c.$async)
      throw new Error("async keyword in sync schema");
  }
  function a(c, B, Q) {
    if (Q === void 0)
      throw new Error(`keyword "${B}" failed to compile`);
    return c.scopeValue("keyword", typeof Q == "function" ? { ref: Q } : { ref: Q, code: (0, i.stringify)(Q) });
  }
  function I(c, B, Q = !1) {
    return !B.length || B.some((f) => f === "array" ? Array.isArray(c) : f === "object" ? c && typeof c == "object" && !Array.isArray(c) : typeof c == f || Q && typeof c > "u");
  }
  PA.validSchemaType = I;
  function C({ schema: c, opts: B, self: Q, errSchemaPath: f }, l, d) {
    if (Array.isArray(l.keyword) ? !l.keyword.includes(d) : l.keyword !== d)
      throw new Error("ajv implementation error");
    const u = l.dependencies;
    if (u?.some((h) => !Object.prototype.hasOwnProperty.call(c, h)))
      throw new Error(`parent schema must have dependencies of ${d}: ${u.join(",")}`);
    if (l.validateSchema && !l.validateSchema(c[d])) {
      const w = `keyword "${d}" value is invalid at path "${f}": ` + Q.errorsText(l.validateSchema.errors);
      if (B.validateSchema === "log")
        Q.logger.error(w);
      else
        throw new Error(w);
    }
  }
  return PA.validateKeywordUsage = C, PA;
}
var re = {}, xg;
function KD() {
  if (xg) return re;
  xg = 1, Object.defineProperty(re, "__esModule", { value: !0 }), re.extendSubschemaMode = re.extendSubschemaData = re.getSubschema = void 0;
  const i = oA(), A = sA();
  function e(r, { keyword: s, schemaProp: g, schema: n, schemaPath: a, errSchemaPath: I, topSchemaRef: C }) {
    if (s !== void 0 && n !== void 0)
      throw new Error('both "keyword" and "schema" passed, only one allowed');
    if (s !== void 0) {
      const c = r.schema[s];
      return g === void 0 ? {
        schema: c,
        schemaPath: (0, i._)`${r.schemaPath}${(0, i.getProperty)(s)}`,
        errSchemaPath: `${r.errSchemaPath}/${s}`
      } : {
        schema: c[g],
        schemaPath: (0, i._)`${r.schemaPath}${(0, i.getProperty)(s)}${(0, i.getProperty)(g)}`,
        errSchemaPath: `${r.errSchemaPath}/${s}/${(0, A.escapeFragment)(g)}`
      };
    }
    if (n !== void 0) {
      if (a === void 0 || I === void 0 || C === void 0)
        throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
      return {
        schema: n,
        schemaPath: a,
        topSchemaRef: C,
        errSchemaPath: I
      };
    }
    throw new Error('either "keyword" or "schema" must be passed');
  }
  re.getSubschema = e;
  function t(r, s, { dataProp: g, dataPropType: n, data: a, dataTypes: I, propertyName: C }) {
    if (a !== void 0 && g !== void 0)
      throw new Error('both "data" and "dataProp" passed, only one allowed');
    const { gen: c } = s;
    if (g !== void 0) {
      const { errorPath: Q, dataPathArr: f, opts: l } = s, d = c.let("data", (0, i._)`${s.data}${(0, i.getProperty)(g)}`, !0);
      B(d), r.errorPath = (0, i.str)`${Q}${(0, A.getErrorPath)(g, n, l.jsPropertySyntax)}`, r.parentDataProperty = (0, i._)`${g}`, r.dataPathArr = [...f, r.parentDataProperty];
    }
    if (a !== void 0) {
      const Q = a instanceof i.Name ? a : c.let("data", a, !0);
      B(Q), C !== void 0 && (r.propertyName = C);
    }
    I && (r.dataTypes = I);
    function B(Q) {
      r.data = Q, r.dataLevel = s.dataLevel + 1, r.dataTypes = [], s.definedProperties = /* @__PURE__ */ new Set(), r.parentData = s.data, r.dataNames = [...s.dataNames, Q];
    }
  }
  re.extendSubschemaData = t;
  function o(r, { jtdDiscriminator: s, jtdMetadata: g, compositeRule: n, createErrors: a, allErrors: I }) {
    n !== void 0 && (r.compositeRule = n), a !== void 0 && (r.createErrors = a), I !== void 0 && (r.allErrors = I), r.jtdDiscriminator = s, r.jtdMetadata = g;
  }
  return re.extendSubschemaMode = o, re;
}
var kA = {}, cr, Og;
function qI() {
  return Og || (Og = 1, cr = function i(A, e) {
    if (A === e) return !0;
    if (A && e && typeof A == "object" && typeof e == "object") {
      if (A.constructor !== e.constructor) return !1;
      var t, o, r;
      if (Array.isArray(A)) {
        if (t = A.length, t != e.length) return !1;
        for (o = t; o-- !== 0; )
          if (!i(A[o], e[o])) return !1;
        return !0;
      }
      if (A.constructor === RegExp) return A.source === e.source && A.flags === e.flags;
      if (A.valueOf !== Object.prototype.valueOf) return A.valueOf() === e.valueOf();
      if (A.toString !== Object.prototype.toString) return A.toString() === e.toString();
      if (r = Object.keys(A), t = r.length, t !== Object.keys(e).length) return !1;
      for (o = t; o-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(e, r[o])) return !1;
      for (o = t; o-- !== 0; ) {
        var s = r[o];
        if (!i(A[s], e[s])) return !1;
      }
      return !0;
    }
    return A !== A && e !== e;
  }), cr;
}
var Br = { exports: {} }, Tg;
function YD() {
  if (Tg) return Br.exports;
  Tg = 1;
  var i = Br.exports = function(t, o, r) {
    typeof o == "function" && (r = o, o = {}), r = o.cb || r;
    var s = typeof r == "function" ? r : r.pre || function() {
    }, g = r.post || function() {
    };
    A(o, s, g, t, "", t);
  };
  i.keywords = {
    additionalItems: !0,
    items: !0,
    contains: !0,
    additionalProperties: !0,
    propertyNames: !0,
    not: !0,
    if: !0,
    then: !0,
    else: !0
  }, i.arrayKeywords = {
    items: !0,
    allOf: !0,
    anyOf: !0,
    oneOf: !0
  }, i.propsKeywords = {
    $defs: !0,
    definitions: !0,
    properties: !0,
    patternProperties: !0,
    dependencies: !0
  }, i.skipKeywords = {
    default: !0,
    enum: !0,
    const: !0,
    required: !0,
    maximum: !0,
    minimum: !0,
    exclusiveMaximum: !0,
    exclusiveMinimum: !0,
    multipleOf: !0,
    maxLength: !0,
    minLength: !0,
    pattern: !0,
    format: !0,
    maxItems: !0,
    minItems: !0,
    uniqueItems: !0,
    maxProperties: !0,
    minProperties: !0
  };
  function A(t, o, r, s, g, n, a, I, C, c) {
    if (s && typeof s == "object" && !Array.isArray(s)) {
      o(s, g, n, a, I, C, c);
      for (var B in s) {
        var Q = s[B];
        if (Array.isArray(Q)) {
          if (B in i.arrayKeywords)
            for (var f = 0; f < Q.length; f++)
              A(t, o, r, Q[f], g + "/" + B + "/" + f, n, g, B, s, f);
        } else if (B in i.propsKeywords) {
          if (Q && typeof Q == "object")
            for (var l in Q)
              A(t, o, r, Q[l], g + "/" + B + "/" + e(l), n, g, B, s, l);
        } else (B in i.keywords || t.allKeys && !(B in i.skipKeywords)) && A(t, o, r, Q, g + "/" + B, n, g, B, s);
      }
      r(s, g, n, a, I, C, c);
    }
  }
  function e(t) {
    return t.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  return Br.exports;
}
var Pg;
function Ko() {
  if (Pg) return kA;
  Pg = 1, Object.defineProperty(kA, "__esModule", { value: !0 }), kA.getSchemaRefs = kA.resolveUrl = kA.normalizeId = kA._getFullPath = kA.getFullPath = kA.inlineRef = void 0;
  const i = sA(), A = qI(), e = YD(), t = /* @__PURE__ */ new Set([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum",
    "const"
  ]);
  function o(f, l = !0) {
    return typeof f == "boolean" ? !0 : l === !0 ? !s(f) : l ? g(f) <= l : !1;
  }
  kA.inlineRef = o;
  const r = /* @__PURE__ */ new Set([
    "$ref",
    "$recursiveRef",
    "$recursiveAnchor",
    "$dynamicRef",
    "$dynamicAnchor"
  ]);
  function s(f) {
    for (const l in f) {
      if (r.has(l))
        return !0;
      const d = f[l];
      if (Array.isArray(d) && d.some(s) || typeof d == "object" && s(d))
        return !0;
    }
    return !1;
  }
  function g(f) {
    let l = 0;
    for (const d in f) {
      if (d === "$ref")
        return 1 / 0;
      if (l++, !t.has(d) && (typeof f[d] == "object" && (0, i.eachItem)(f[d], (u) => l += g(u)), l === 1 / 0))
        return 1 / 0;
    }
    return l;
  }
  function n(f, l = "", d) {
    d !== !1 && (l = C(l));
    const u = f.parse(l);
    return a(f, u);
  }
  kA.getFullPath = n;
  function a(f, l) {
    return f.serialize(l).split("#")[0] + "#";
  }
  kA._getFullPath = a;
  const I = /#\/?$/;
  function C(f) {
    return f ? f.replace(I, "") : "";
  }
  kA.normalizeId = C;
  function c(f, l, d) {
    return d = C(d), f.resolve(l, d);
  }
  kA.resolveUrl = c;
  const B = /^[a-z_][-a-z0-9._]*$/i;
  function Q(f, l) {
    if (typeof f == "boolean")
      return {};
    const { schemaId: d, uriResolver: u } = this.opts, h = C(f[d] || l), w = { "": h }, E = n(u, h, !1), p = {}, y = /* @__PURE__ */ new Set();
    return e(f, { allKeys: !0 }, (R, L, j, J) => {
      if (J === void 0)
        return;
      const z = E + L;
      let X = w[J];
      typeof R[d] == "string" && (X = Z.call(this, R[d])), _.call(this, R.$anchor), _.call(this, R.$dynamicAnchor), w[L] = X;
      function Z(T) {
        const $ = this.opts.uriResolver.resolve;
        if (T = C(X ? $(X, T) : T), y.has(T))
          throw N(T);
        y.add(T);
        let O = this.refs[T];
        return typeof O == "string" && (O = this.refs[O]), typeof O == "object" ? m(R, O.schema, T) : T !== C(z) && (T[0] === "#" ? (m(R, p[T], T), p[T] = R) : this.refs[T] = z), T;
      }
      function _(T) {
        if (typeof T == "string") {
          if (!B.test(T))
            throw new Error(`invalid anchor "${T}"`);
          Z.call(this, `#${T}`);
        }
      }
    }), p;
    function m(R, L, j) {
      if (L !== void 0 && !A(R, L))
        throw N(j);
    }
    function N(R) {
      return new Error(`reference "${R}" resolves to more than one schema`);
    }
  }
  return kA.getSchemaRefs = Q, kA;
}
var jg;
function _t() {
  if (jg) return ie;
  jg = 1, Object.defineProperty(ie, "__esModule", { value: !0 }), ie.getData = ie.KeywordCxt = ie.validateFunctionCode = void 0;
  const i = FD(), A = Eo(), e = HI(), t = Eo(), o = RD(), r = bD(), s = KD(), g = oA(), n = zA(), a = Ko(), I = sA(), C = bo();
  function c(S) {
    if (E(S) && (y(S), w(S))) {
      l(S);
      return;
    }
    B(S, () => (0, i.topBoolOrEmptySchema)(S));
  }
  ie.validateFunctionCode = c;
  function B({ gen: S, validateName: k, schema: K, schemaEnv: H, opts: V }, W) {
    V.code.es5 ? S.func(k, (0, g._)`${n.default.data}, ${n.default.valCxt}`, H.$async, () => {
      S.code((0, g._)`"use strict"; ${u(K, V)}`), f(S, V), S.code(W);
    }) : S.func(k, (0, g._)`${n.default.data}, ${Q(V)}`, H.$async, () => S.code(u(K, V)).code(W));
  }
  function Q(S) {
    return (0, g._)`{${n.default.instancePath}="", ${n.default.parentData}, ${n.default.parentDataProperty}, ${n.default.rootData}=${n.default.data}${S.dynamicRef ? (0, g._)`, ${n.default.dynamicAnchors}={}` : g.nil}}={}`;
  }
  function f(S, k) {
    S.if(n.default.valCxt, () => {
      S.var(n.default.instancePath, (0, g._)`${n.default.valCxt}.${n.default.instancePath}`), S.var(n.default.parentData, (0, g._)`${n.default.valCxt}.${n.default.parentData}`), S.var(n.default.parentDataProperty, (0, g._)`${n.default.valCxt}.${n.default.parentDataProperty}`), S.var(n.default.rootData, (0, g._)`${n.default.valCxt}.${n.default.rootData}`), k.dynamicRef && S.var(n.default.dynamicAnchors, (0, g._)`${n.default.valCxt}.${n.default.dynamicAnchors}`);
    }, () => {
      S.var(n.default.instancePath, (0, g._)`""`), S.var(n.default.parentData, (0, g._)`undefined`), S.var(n.default.parentDataProperty, (0, g._)`undefined`), S.var(n.default.rootData, n.default.data), k.dynamicRef && S.var(n.default.dynamicAnchors, (0, g._)`{}`);
    });
  }
  function l(S) {
    const { schema: k, opts: K, gen: H } = S;
    B(S, () => {
      K.$comment && k.$comment && J(S), R(S), H.let(n.default.vErrors, null), H.let(n.default.errors, 0), K.unevaluated && d(S), m(S), z(S);
    });
  }
  function d(S) {
    const { gen: k, validateName: K } = S;
    S.evaluated = k.const("evaluated", (0, g._)`${K}.evaluated`), k.if((0, g._)`${S.evaluated}.dynamicProps`, () => k.assign((0, g._)`${S.evaluated}.props`, (0, g._)`undefined`)), k.if((0, g._)`${S.evaluated}.dynamicItems`, () => k.assign((0, g._)`${S.evaluated}.items`, (0, g._)`undefined`));
  }
  function u(S, k) {
    const K = typeof S == "object" && S[k.schemaId];
    return K && (k.code.source || k.code.process) ? (0, g._)`/*# sourceURL=${K} */` : g.nil;
  }
  function h(S, k) {
    if (E(S) && (y(S), w(S))) {
      p(S, k);
      return;
    }
    (0, i.boolOrEmptySchema)(S, k);
  }
  function w({ schema: S, self: k }) {
    if (typeof S == "boolean")
      return !S;
    for (const K in S)
      if (k.RULES.all[K])
        return !0;
    return !1;
  }
  function E(S) {
    return typeof S.schema != "boolean";
  }
  function p(S, k) {
    const { schema: K, gen: H, opts: V } = S;
    V.$comment && K.$comment && J(S), L(S), j(S);
    const W = H.const("_errs", n.default.errors);
    m(S, W), H.var(k, (0, g._)`${W} === ${n.default.errors}`);
  }
  function y(S) {
    (0, I.checkUnknownRules)(S), N(S);
  }
  function m(S, k) {
    if (S.opts.jtd)
      return Z(S, [], !1, k);
    const K = (0, A.getSchemaTypes)(S.schema), H = (0, A.coerceAndCheckDataType)(S, K);
    Z(S, K, !H, k);
  }
  function N(S) {
    const { schema: k, errSchemaPath: K, opts: H, self: V } = S;
    k.$ref && H.ignoreKeywordsWithRef && (0, I.schemaHasRulesButRef)(k, V.RULES) && V.logger.warn(`$ref: keywords ignored in schema at path "${K}"`);
  }
  function R(S) {
    const { schema: k, opts: K } = S;
    k.default !== void 0 && K.useDefaults && K.strictSchema && (0, I.checkStrictMode)(S, "default is ignored in the schema root");
  }
  function L(S) {
    const k = S.schema[S.opts.schemaId];
    k && (S.baseId = (0, a.resolveUrl)(S.opts.uriResolver, S.baseId, k));
  }
  function j(S) {
    if (S.schema.$async && !S.schemaEnv.$async)
      throw new Error("async schema in sync schema");
  }
  function J({ gen: S, schemaEnv: k, schema: K, errSchemaPath: H, opts: V }) {
    const W = K.$comment;
    if (V.$comment === !0)
      S.code((0, g._)`${n.default.self}.logger.log(${W})`);
    else if (typeof V.$comment == "function") {
      const iA = (0, g.str)`${H}/$comment`, gA = S.scopeValue("root", { ref: k.root });
      S.code((0, g._)`${n.default.self}.opts.$comment(${W}, ${iA}, ${gA}.schema)`);
    }
  }
  function z(S) {
    const { gen: k, schemaEnv: K, validateName: H, ValidationError: V, opts: W } = S;
    K.$async ? k.if((0, g._)`${n.default.errors} === 0`, () => k.return(n.default.data), () => k.throw((0, g._)`new ${V}(${n.default.vErrors})`)) : (k.assign((0, g._)`${H}.errors`, n.default.vErrors), W.unevaluated && X(S), k.return((0, g._)`${n.default.errors} === 0`));
  }
  function X({ gen: S, evaluated: k, props: K, items: H }) {
    K instanceof g.Name && S.assign((0, g._)`${k}.props`, K), H instanceof g.Name && S.assign((0, g._)`${k}.items`, H);
  }
  function Z(S, k, K, H) {
    const { gen: V, schema: W, data: iA, allErrors: gA, opts: nA, self: QA } = S, { RULES: dA } = QA;
    if (W.$ref && (nA.ignoreKeywordsWithRef || !(0, I.schemaHasRulesButRef)(W, dA))) {
      V.block(() => P(S, "$ref", dA.all.$ref.definition));
      return;
    }
    nA.jtd || T(S, k), V.block(() => {
      for (const HA of dA.rules)
        Ce(HA);
      Ce(dA.post);
    });
    function Ce(HA) {
      (0, e.shouldUseGroup)(W, HA) && (HA.type ? (V.if((0, t.checkDataType)(HA.type, iA, nA.strictNumbers)), _(S, HA), k.length === 1 && k[0] === HA.type && K && (V.else(), (0, t.reportTypeError)(S)), V.endIf()) : _(S, HA), gA || V.if((0, g._)`${n.default.errors} === ${H || 0}`));
    }
  }
  function _(S, k) {
    const { gen: K, schema: H, opts: { useDefaults: V } } = S;
    V && (0, o.assignDefaults)(S, k.type), K.block(() => {
      for (const W of k.rules)
        (0, e.shouldUseRule)(H, W) && P(S, W.keyword, W.definition, k.type);
    });
  }
  function T(S, k) {
    S.schemaEnv.meta || !S.opts.strictTypes || ($(S, k), S.opts.allowUnionTypes || O(S, k), F(S, S.dataTypes));
  }
  function $(S, k) {
    if (k.length) {
      if (!S.dataTypes.length) {
        S.dataTypes = k;
        return;
      }
      k.forEach((K) => {
        b(S.dataTypes, K) || M(S, `type "${K}" not allowed by context "${S.dataTypes.join(",")}"`);
      }), D(S, k);
    }
  }
  function O(S, k) {
    k.length > 1 && !(k.length === 2 && k.includes("null")) && M(S, "use allowUnionTypes to allow union type keyword");
  }
  function F(S, k) {
    const K = S.self.RULES.all;
    for (const H in K) {
      const V = K[H];
      if (typeof V == "object" && (0, e.shouldUseRule)(S.schema, V)) {
        const { type: W } = V.definition;
        W.length && !W.some((iA) => q(k, iA)) && M(S, `missing type "${W.join(",")}" for keyword "${H}"`);
      }
    }
  }
  function q(S, k) {
    return S.includes(k) || k === "number" && S.includes("integer");
  }
  function b(S, k) {
    return S.includes(k) || k === "integer" && S.includes("number");
  }
  function D(S, k) {
    const K = [];
    for (const H of S.dataTypes)
      b(k, H) ? K.push(H) : k.includes("integer") && H === "number" && K.push("integer");
    S.dataTypes = K;
  }
  function M(S, k) {
    const K = S.schemaEnv.baseId + S.errSchemaPath;
    k += ` at "${K}" (strictTypes)`, (0, I.checkStrictMode)(S, k, S.opts.strictTypes);
  }
  class U {
    constructor(k, K, H) {
      if ((0, r.validateKeywordUsage)(k, K, H), this.gen = k.gen, this.allErrors = k.allErrors, this.keyword = H, this.data = k.data, this.schema = k.schema[H], this.$data = K.$data && k.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, I.schemaRefOrVal)(k, this.schema, H, this.$data), this.schemaType = K.schemaType, this.parentSchema = k.schema, this.params = {}, this.it = k, this.def = K, this.$data)
        this.schemaCode = k.gen.const("vSchema", Y(this.$data, k));
      else if (this.schemaCode = this.schemaValue, !(0, r.validSchemaType)(this.schema, K.schemaType, K.allowUndefined))
        throw new Error(`${H} value must be ${JSON.stringify(K.schemaType)}`);
      ("code" in K ? K.trackErrors : K.errors !== !1) && (this.errsCount = k.gen.const("_errs", n.default.errors));
    }
    result(k, K, H) {
      this.failResult((0, g.not)(k), K, H);
    }
    failResult(k, K, H) {
      this.gen.if(k), H ? H() : this.error(), K ? (this.gen.else(), K(), this.allErrors && this.gen.endIf()) : this.allErrors ? this.gen.endIf() : this.gen.else();
    }
    pass(k, K) {
      this.failResult((0, g.not)(k), void 0, K);
    }
    fail(k) {
      if (k === void 0) {
        this.error(), this.allErrors || this.gen.if(!1);
        return;
      }
      this.gen.if(k), this.error(), this.allErrors ? this.gen.endIf() : this.gen.else();
    }
    fail$data(k) {
      if (!this.$data)
        return this.fail(k);
      const { schemaCode: K } = this;
      this.fail((0, g._)`${K} !== undefined && (${(0, g.or)(this.invalid$data(), k)})`);
    }
    error(k, K, H) {
      if (K) {
        this.setParams(K), this._error(k, H), this.setParams({});
        return;
      }
      this._error(k, H);
    }
    _error(k, K) {
      (k ? C.reportExtraError : C.reportError)(this, this.def.error, K);
    }
    $dataError() {
      (0, C.reportError)(this, this.def.$dataError || C.keyword$DataError);
    }
    reset() {
      if (this.errsCount === void 0)
        throw new Error('add "trackErrors" to keyword definition');
      (0, C.resetErrorsCount)(this.gen, this.errsCount);
    }
    ok(k) {
      this.allErrors || this.gen.if(k);
    }
    setParams(k, K) {
      K ? Object.assign(this.params, k) : this.params = k;
    }
    block$data(k, K, H = g.nil) {
      this.gen.block(() => {
        this.check$data(k, H), K();
      });
    }
    check$data(k = g.nil, K = g.nil) {
      if (!this.$data)
        return;
      const { gen: H, schemaCode: V, schemaType: W, def: iA } = this;
      H.if((0, g.or)((0, g._)`${V} === undefined`, K)), k !== g.nil && H.assign(k, !0), (W.length || iA.validateSchema) && (H.elseIf(this.invalid$data()), this.$dataError(), k !== g.nil && H.assign(k, !1)), H.else();
    }
    invalid$data() {
      const { gen: k, schemaCode: K, schemaType: H, def: V, it: W } = this;
      return (0, g.or)(iA(), gA());
      function iA() {
        if (H.length) {
          if (!(K instanceof g.Name))
            throw new Error("ajv implementation error");
          const nA = Array.isArray(H) ? H : [H];
          return (0, g._)`${(0, t.checkDataTypes)(nA, K, W.opts.strictNumbers, t.DataType.Wrong)}`;
        }
        return g.nil;
      }
      function gA() {
        if (V.validateSchema) {
          const nA = k.scopeValue("validate$data", { ref: V.validateSchema });
          return (0, g._)`!${nA}(${K})`;
        }
        return g.nil;
      }
    }
    subschema(k, K) {
      const H = (0, s.getSubschema)(this.it, k);
      (0, s.extendSubschemaData)(H, this.it, k), (0, s.extendSubschemaMode)(H, k);
      const V = { ...this.it, ...H, items: void 0, props: void 0 };
      return h(V, K), V;
    }
    mergeEvaluated(k, K) {
      const { it: H, gen: V } = this;
      H.opts.unevaluated && (H.props !== !0 && k.props !== void 0 && (H.props = I.mergeEvaluated.props(V, k.props, H.props, K)), H.items !== !0 && k.items !== void 0 && (H.items = I.mergeEvaluated.items(V, k.items, H.items, K)));
    }
    mergeValidEvaluated(k, K) {
      const { it: H, gen: V } = this;
      if (H.opts.unevaluated && (H.props !== !0 || H.items !== !0))
        return V.if(K, () => this.mergeEvaluated(k, g.Name)), !0;
    }
  }
  ie.KeywordCxt = U;
  function P(S, k, K, H) {
    const V = new U(S, K, k);
    "code" in K ? K.code(V, H) : V.$data && K.validate ? (0, r.funcKeywordCode)(V, K) : "macro" in K ? (0, r.macroKeywordCode)(V, K) : (K.compile || K.validate) && (0, r.funcKeywordCode)(V, K);
  }
  const G = /^\/(?:[^~]|~0|~1)*$/, x = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
  function Y(S, { dataLevel: k, dataNames: K, dataPathArr: H }) {
    let V, W;
    if (S === "")
      return n.default.rootData;
    if (S[0] === "/") {
      if (!G.test(S))
        throw new Error(`Invalid JSON-pointer: ${S}`);
      V = S, W = n.default.rootData;
    } else {
      const QA = x.exec(S);
      if (!QA)
        throw new Error(`Invalid JSON-pointer: ${S}`);
      const dA = +QA[1];
      if (V = QA[2], V === "#") {
        if (dA >= k)
          throw new Error(nA("property/index", dA));
        return H[k - dA];
      }
      if (dA > k)
        throw new Error(nA("data", dA));
      if (W = K[k - dA], !V)
        return W;
    }
    let iA = W;
    const gA = V.split("/");
    for (const QA of gA)
      QA && (W = (0, g._)`${W}${(0, g.getProperty)((0, I.unescapeJsonPointer)(QA))}`, iA = (0, g._)`${iA} && ${W}`);
    return iA;
    function nA(QA, dA) {
      return `Cannot access ${QA} ${dA} levels up, current level is ${k}`;
    }
  }
  return ie.getData = Y, ie;
}
var ni = {}, Vg;
function Yo() {
  if (Vg) return ni;
  Vg = 1, Object.defineProperty(ni, "__esModule", { value: !0 });
  class i extends Error {
    constructor(e) {
      super("validation failed"), this.errors = e, this.ajv = this.validation = !0;
    }
  }
  return ni.default = i, ni;
}
var ai = {}, Wg;
function $t() {
  if (Wg) return ai;
  Wg = 1, Object.defineProperty(ai, "__esModule", { value: !0 });
  const i = Ko();
  class A extends Error {
    constructor(t, o, r, s) {
      super(s || `can't resolve reference ${r} from id ${o}`), this.missingRef = (0, i.resolveUrl)(t, o, r), this.missingSchema = (0, i.normalizeId)((0, i.getFullPath)(t, this.missingRef));
    }
  }
  return ai.default = A, ai;
}
var YA = {}, zg;
function Uo() {
  if (zg) return YA;
  zg = 1, Object.defineProperty(YA, "__esModule", { value: !0 }), YA.resolveSchema = YA.getCompilingSchema = YA.resolveRef = YA.compileSchema = YA.SchemaEnv = void 0;
  const i = oA(), A = Yo(), e = zA(), t = Ko(), o = sA(), r = _t();
  class s {
    constructor(d) {
      var u;
      this.refs = {}, this.dynamicAnchors = {};
      let h;
      typeof d.schema == "object" && (h = d.schema), this.schema = d.schema, this.schemaId = d.schemaId, this.root = d.root || this, this.baseId = (u = d.baseId) !== null && u !== void 0 ? u : (0, t.normalizeId)(h?.[d.schemaId || "$id"]), this.schemaPath = d.schemaPath, this.localRefs = d.localRefs, this.meta = d.meta, this.$async = h?.$async, this.refs = {};
    }
  }
  YA.SchemaEnv = s;
  function g(l) {
    const d = I.call(this, l);
    if (d)
      return d;
    const u = (0, t.getFullPath)(this.opts.uriResolver, l.root.baseId), { es5: h, lines: w } = this.opts.code, { ownProperties: E } = this.opts, p = new i.CodeGen(this.scope, { es5: h, lines: w, ownProperties: E });
    let y;
    l.$async && (y = p.scopeValue("Error", {
      ref: A.default,
      code: (0, i._)`require("ajv/dist/runtime/validation_error").default`
    }));
    const m = p.scopeName("validate");
    l.validateName = m;
    const N = {
      gen: p,
      allErrors: this.opts.allErrors,
      data: e.default.data,
      parentData: e.default.parentData,
      parentDataProperty: e.default.parentDataProperty,
      dataNames: [e.default.data],
      dataPathArr: [i.nil],
      // TODO can its length be used as dataLevel if nil is removed?
      dataLevel: 0,
      dataTypes: [],
      definedProperties: /* @__PURE__ */ new Set(),
      topSchemaRef: p.scopeValue("schema", this.opts.code.source === !0 ? { ref: l.schema, code: (0, i.stringify)(l.schema) } : { ref: l.schema }),
      validateName: m,
      ValidationError: y,
      schema: l.schema,
      schemaEnv: l,
      rootId: u,
      baseId: l.baseId || u,
      schemaPath: i.nil,
      errSchemaPath: l.schemaPath || (this.opts.jtd ? "" : "#"),
      errorPath: (0, i._)`""`,
      opts: this.opts,
      self: this
    };
    let R;
    try {
      this._compilations.add(l), (0, r.validateFunctionCode)(N), p.optimize(this.opts.code.optimize);
      const L = p.toString();
      R = `${p.scopeRefs(e.default.scope)}return ${L}`, this.opts.code.process && (R = this.opts.code.process(R, l));
      const J = new Function(`${e.default.self}`, `${e.default.scope}`, R)(this, this.scope.get());
      if (this.scope.value(m, { ref: J }), J.errors = null, J.schema = l.schema, J.schemaEnv = l, l.$async && (J.$async = !0), this.opts.code.source === !0 && (J.source = { validateName: m, validateCode: L, scopeValues: p._values }), this.opts.unevaluated) {
        const { props: z, items: X } = N;
        J.evaluated = {
          props: z instanceof i.Name ? void 0 : z,
          items: X instanceof i.Name ? void 0 : X,
          dynamicProps: z instanceof i.Name,
          dynamicItems: X instanceof i.Name
        }, J.source && (J.source.evaluated = (0, i.stringify)(J.evaluated));
      }
      return l.validate = J, l;
    } catch (L) {
      throw delete l.validate, delete l.validateName, R && this.logger.error("Error compiling schema, function code:", R), L;
    } finally {
      this._compilations.delete(l);
    }
  }
  YA.compileSchema = g;
  function n(l, d, u) {
    var h;
    u = (0, t.resolveUrl)(this.opts.uriResolver, d, u);
    const w = l.refs[u];
    if (w)
      return w;
    let E = c.call(this, l, u);
    if (E === void 0) {
      const p = (h = l.localRefs) === null || h === void 0 ? void 0 : h[u], { schemaId: y } = this.opts;
      p && (E = new s({ schema: p, schemaId: y, root: l, baseId: d }));
    }
    if (E !== void 0)
      return l.refs[u] = a.call(this, E);
  }
  YA.resolveRef = n;
  function a(l) {
    return (0, t.inlineRef)(l.schema, this.opts.inlineRefs) ? l.schema : l.validate ? l : g.call(this, l);
  }
  function I(l) {
    for (const d of this._compilations)
      if (C(d, l))
        return d;
  }
  YA.getCompilingSchema = I;
  function C(l, d) {
    return l.schema === d.schema && l.root === d.root && l.baseId === d.baseId;
  }
  function c(l, d) {
    let u;
    for (; typeof (u = this.refs[d]) == "string"; )
      d = u;
    return u || this.schemas[d] || B.call(this, l, d);
  }
  function B(l, d) {
    const u = this.opts.uriResolver.parse(d), h = (0, t._getFullPath)(this.opts.uriResolver, u);
    let w = (0, t.getFullPath)(this.opts.uriResolver, l.baseId, void 0);
    if (Object.keys(l.schema).length > 0 && h === w)
      return f.call(this, u, l);
    const E = (0, t.normalizeId)(h), p = this.refs[E] || this.schemas[E];
    if (typeof p == "string") {
      const y = B.call(this, l, p);
      return typeof y?.schema != "object" ? void 0 : f.call(this, u, y);
    }
    if (typeof p?.schema == "object") {
      if (p.validate || g.call(this, p), E === (0, t.normalizeId)(d)) {
        const { schema: y } = p, { schemaId: m } = this.opts, N = y[m];
        return N && (w = (0, t.resolveUrl)(this.opts.uriResolver, w, N)), new s({ schema: y, schemaId: m, root: l, baseId: w });
      }
      return f.call(this, u, p);
    }
  }
  YA.resolveSchema = B;
  const Q = /* @__PURE__ */ new Set([
    "properties",
    "patternProperties",
    "enum",
    "dependencies",
    "definitions"
  ]);
  function f(l, { baseId: d, schema: u, root: h }) {
    var w;
    if (((w = l.fragment) === null || w === void 0 ? void 0 : w[0]) !== "/")
      return;
    for (const y of l.fragment.slice(1).split("/")) {
      if (typeof u == "boolean")
        return;
      const m = u[(0, o.unescapeFragment)(y)];
      if (m === void 0)
        return;
      u = m;
      const N = typeof u == "object" && u[this.opts.schemaId];
      !Q.has(y) && N && (d = (0, t.resolveUrl)(this.opts.uriResolver, d, N));
    }
    let E;
    if (typeof u != "boolean" && u.$ref && !(0, o.schemaHasRulesButRef)(u, this.RULES)) {
      const y = (0, t.resolveUrl)(this.opts.uriResolver, d, u.$ref);
      E = B.call(this, h, y);
    }
    const { schemaId: p } = this.opts;
    if (E = E || new s({ schema: u, schemaId: p, root: h, baseId: d }), E.schema !== E.root.schema)
      return E;
  }
  return YA;
}
const UD = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#", vD = "Meta-schema for $data reference (JSON AnySchema extension proposal)", JD = "object", HD = ["$data"], qD = { $data: { type: "string", anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }] } }, LD = !1, xD = {
  $id: UD,
  description: vD,
  type: JD,
  required: HD,
  properties: qD,
  additionalProperties: LD
};
var Ii = {}, ht = { exports: {} }, Qr, Zg;
function LI() {
  if (Zg) return Qr;
  Zg = 1;
  const i = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu), A = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
  function e(c) {
    let B = "", Q = 0, f = 0;
    for (f = 0; f < c.length; f++)
      if (Q = c[f].charCodeAt(0), Q !== 48) {
        if (!(Q >= 48 && Q <= 57 || Q >= 65 && Q <= 70 || Q >= 97 && Q <= 102))
          return "";
        B += c[f];
        break;
      }
    for (f += 1; f < c.length; f++) {
      if (Q = c[f].charCodeAt(0), !(Q >= 48 && Q <= 57 || Q >= 65 && Q <= 70 || Q >= 97 && Q <= 102))
        return "";
      B += c[f];
    }
    return B;
  }
  const t = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
  function o(c) {
    return c.length = 0, !0;
  }
  function r(c, B, Q) {
    if (c.length) {
      const f = e(c);
      if (f !== "")
        B.push(f);
      else
        return Q.error = !0, !1;
      c.length = 0;
    }
    return !0;
  }
  function s(c) {
    let B = 0;
    const Q = { error: !1, address: "", zone: "" }, f = [], l = [];
    let d = !1, u = !1, h = r;
    for (let w = 0; w < c.length; w++) {
      const E = c[w];
      if (!(E === "[" || E === "]"))
        if (E === ":") {
          if (d === !0 && (u = !0), !h(l, f, Q))
            break;
          if (++B > 7) {
            Q.error = !0;
            break;
          }
          w > 0 && c[w - 1] === ":" && (d = !0), f.push(":");
          continue;
        } else if (E === "%") {
          if (!h(l, f, Q))
            break;
          h = o;
        } else {
          l.push(E);
          continue;
        }
    }
    return l.length && (h === o ? Q.zone = l.join("") : u ? f.push(l.join("")) : f.push(e(l))), Q.address = f.join(""), Q;
  }
  function g(c) {
    if (n(c, ":") < 2)
      return { host: c, isIPV6: !1 };
    const B = s(c);
    if (B.error)
      return { host: c, isIPV6: !1 };
    {
      let Q = B.address, f = B.address;
      return B.zone && (Q += "%" + B.zone, f += "%25" + B.zone), { host: Q, isIPV6: !0, escapedHost: f };
    }
  }
  function n(c, B) {
    let Q = 0;
    for (let f = 0; f < c.length; f++)
      c[f] === B && Q++;
    return Q;
  }
  function a(c) {
    let B = c;
    const Q = [];
    let f = -1, l = 0;
    for (; l = B.length; ) {
      if (l === 1) {
        if (B === ".")
          break;
        if (B === "/") {
          Q.push("/");
          break;
        } else {
          Q.push(B);
          break;
        }
      } else if (l === 2) {
        if (B[0] === ".") {
          if (B[1] === ".")
            break;
          if (B[1] === "/") {
            B = B.slice(2);
            continue;
          }
        } else if (B[0] === "/" && (B[1] === "." || B[1] === "/")) {
          Q.push("/");
          break;
        }
      } else if (l === 3 && B === "/..") {
        Q.length !== 0 && Q.pop(), Q.push("/");
        break;
      }
      if (B[0] === ".") {
        if (B[1] === ".") {
          if (B[2] === "/") {
            B = B.slice(3);
            continue;
          }
        } else if (B[1] === "/") {
          B = B.slice(2);
          continue;
        }
      } else if (B[0] === "/" && B[1] === ".") {
        if (B[2] === "/") {
          B = B.slice(2);
          continue;
        } else if (B[2] === "." && B[3] === "/") {
          B = B.slice(3), Q.length !== 0 && Q.pop();
          continue;
        }
      }
      if ((f = B.indexOf("/", 1)) === -1) {
        Q.push(B);
        break;
      } else
        Q.push(B.slice(0, f)), B = B.slice(f);
    }
    return Q.join("");
  }
  function I(c, B) {
    const Q = B !== !0 ? escape : unescape;
    return c.scheme !== void 0 && (c.scheme = Q(c.scheme)), c.userinfo !== void 0 && (c.userinfo = Q(c.userinfo)), c.host !== void 0 && (c.host = Q(c.host)), c.path !== void 0 && (c.path = Q(c.path)), c.query !== void 0 && (c.query = Q(c.query)), c.fragment !== void 0 && (c.fragment = Q(c.fragment)), c;
  }
  function C(c) {
    const B = [];
    if (c.userinfo !== void 0 && (B.push(c.userinfo), B.push("@")), c.host !== void 0) {
      let Q = unescape(c.host);
      if (!A(Q)) {
        const f = g(Q);
        f.isIPV6 === !0 ? Q = `[${f.escapedHost}]` : Q = c.host;
      }
      B.push(Q);
    }
    return (typeof c.port == "number" || typeof c.port == "string") && (B.push(":"), B.push(String(c.port))), B.length ? B.join("") : void 0;
  }
  return Qr = {
    nonSimpleDomain: t,
    recomposeAuthority: C,
    normalizeComponentEncoding: I,
    removeDotSegments: a,
    isIPv4: A,
    isUUID: i,
    normalizeIPv6: g,
    stringArrayToHexStripped: e
  }, Qr;
}
var Er, _g;
function OD() {
  if (_g) return Er;
  _g = 1;
  const { isUUID: i } = LI(), A = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu, e = (
    /** @type {const} */
    [
      "http",
      "https",
      "ws",
      "wss",
      "urn",
      "urn:uuid"
    ]
  );
  function t(E) {
    return e.indexOf(
      /** @type {*} */
      E
    ) !== -1;
  }
  function o(E) {
    return E.secure === !0 ? !0 : E.secure === !1 ? !1 : E.scheme ? E.scheme.length === 3 && (E.scheme[0] === "w" || E.scheme[0] === "W") && (E.scheme[1] === "s" || E.scheme[1] === "S") && (E.scheme[2] === "s" || E.scheme[2] === "S") : !1;
  }
  function r(E) {
    return E.host || (E.error = E.error || "HTTP URIs must have a host."), E;
  }
  function s(E) {
    const p = String(E.scheme).toLowerCase() === "https";
    return (E.port === (p ? 443 : 80) || E.port === "") && (E.port = void 0), E.path || (E.path = "/"), E;
  }
  function g(E) {
    return E.secure = o(E), E.resourceName = (E.path || "/") + (E.query ? "?" + E.query : ""), E.path = void 0, E.query = void 0, E;
  }
  function n(E) {
    if ((E.port === (o(E) ? 443 : 80) || E.port === "") && (E.port = void 0), typeof E.secure == "boolean" && (E.scheme = E.secure ? "wss" : "ws", E.secure = void 0), E.resourceName) {
      const [p, y] = E.resourceName.split("?");
      E.path = p && p !== "/" ? p : void 0, E.query = y, E.resourceName = void 0;
    }
    return E.fragment = void 0, E;
  }
  function a(E, p) {
    if (!E.path)
      return E.error = "URN can not be parsed", E;
    const y = E.path.match(A);
    if (y) {
      const m = p.scheme || E.scheme || "urn";
      E.nid = y[1].toLowerCase(), E.nss = y[2];
      const N = `${m}:${p.nid || E.nid}`, R = w(N);
      E.path = void 0, R && (E = R.parse(E, p));
    } else
      E.error = E.error || "URN can not be parsed.";
    return E;
  }
  function I(E, p) {
    if (E.nid === void 0)
      throw new Error("URN without nid cannot be serialized");
    const y = p.scheme || E.scheme || "urn", m = E.nid.toLowerCase(), N = `${y}:${p.nid || m}`, R = w(N);
    R && (E = R.serialize(E, p));
    const L = E, j = E.nss;
    return L.path = `${m || p.nid}:${j}`, p.skipEscape = !0, L;
  }
  function C(E, p) {
    const y = E;
    return y.uuid = y.nss, y.nss = void 0, !p.tolerant && (!y.uuid || !i(y.uuid)) && (y.error = y.error || "UUID is not valid."), y;
  }
  function c(E) {
    const p = E;
    return p.nss = (E.uuid || "").toLowerCase(), p;
  }
  const B = (
    /** @type {SchemeHandler} */
    {
      scheme: "http",
      domainHost: !0,
      parse: r,
      serialize: s
    }
  ), Q = (
    /** @type {SchemeHandler} */
    {
      scheme: "https",
      domainHost: B.domainHost,
      parse: r,
      serialize: s
    }
  ), f = (
    /** @type {SchemeHandler} */
    {
      scheme: "ws",
      domainHost: !0,
      parse: g,
      serialize: n
    }
  ), l = (
    /** @type {SchemeHandler} */
    {
      scheme: "wss",
      domainHost: f.domainHost,
      parse: f.parse,
      serialize: f.serialize
    }
  ), h = (
    /** @type {Record<SchemeName, SchemeHandler>} */
    {
      http: B,
      https: Q,
      ws: f,
      wss: l,
      urn: (
        /** @type {SchemeHandler} */
        {
          scheme: "urn",
          parse: a,
          serialize: I,
          skipNormalize: !0
        }
      ),
      "urn:uuid": (
        /** @type {SchemeHandler} */
        {
          scheme: "urn:uuid",
          parse: C,
          serialize: c,
          skipNormalize: !0
        }
      )
    }
  );
  Object.setPrototypeOf(h, null);
  function w(E) {
    return E && (h[
      /** @type {SchemeName} */
      E
    ] || h[
      /** @type {SchemeName} */
      E.toLowerCase()
    ]) || void 0;
  }
  return Er = {
    wsIsSecure: o,
    SCHEMES: h,
    isValidSchemeName: t,
    getSchemeHandler: w
  }, Er;
}
var $g;
function TD() {
  if ($g) return ht.exports;
  $g = 1;
  const { normalizeIPv6: i, removeDotSegments: A, recomposeAuthority: e, normalizeComponentEncoding: t, isIPv4: o, nonSimpleDomain: r } = LI(), { SCHEMES: s, getSchemeHandler: g } = OD();
  function n(l, d) {
    return typeof l == "string" ? l = /** @type {T} */
    c(Q(l, d), d) : typeof l == "object" && (l = /** @type {T} */
    Q(c(l, d), d)), l;
  }
  function a(l, d, u) {
    const h = u ? Object.assign({ scheme: "null" }, u) : { scheme: "null" }, w = I(Q(l, h), Q(d, h), h, !0);
    return h.skipEscape = !0, c(w, h);
  }
  function I(l, d, u, h) {
    const w = {};
    return h || (l = Q(c(l, u), u), d = Q(c(d, u), u)), u = u || {}, !u.tolerant && d.scheme ? (w.scheme = d.scheme, w.userinfo = d.userinfo, w.host = d.host, w.port = d.port, w.path = A(d.path || ""), w.query = d.query) : (d.userinfo !== void 0 || d.host !== void 0 || d.port !== void 0 ? (w.userinfo = d.userinfo, w.host = d.host, w.port = d.port, w.path = A(d.path || ""), w.query = d.query) : (d.path ? (d.path[0] === "/" ? w.path = A(d.path) : ((l.userinfo !== void 0 || l.host !== void 0 || l.port !== void 0) && !l.path ? w.path = "/" + d.path : l.path ? w.path = l.path.slice(0, l.path.lastIndexOf("/") + 1) + d.path : w.path = d.path, w.path = A(w.path)), w.query = d.query) : (w.path = l.path, d.query !== void 0 ? w.query = d.query : w.query = l.query), w.userinfo = l.userinfo, w.host = l.host, w.port = l.port), w.scheme = l.scheme), w.fragment = d.fragment, w;
  }
  function C(l, d, u) {
    return typeof l == "string" ? (l = unescape(l), l = c(t(Q(l, u), !0), { ...u, skipEscape: !0 })) : typeof l == "object" && (l = c(t(l, !0), { ...u, skipEscape: !0 })), typeof d == "string" ? (d = unescape(d), d = c(t(Q(d, u), !0), { ...u, skipEscape: !0 })) : typeof d == "object" && (d = c(t(d, !0), { ...u, skipEscape: !0 })), l.toLowerCase() === d.toLowerCase();
  }
  function c(l, d) {
    const u = {
      host: l.host,
      scheme: l.scheme,
      userinfo: l.userinfo,
      port: l.port,
      path: l.path,
      query: l.query,
      nid: l.nid,
      nss: l.nss,
      uuid: l.uuid,
      fragment: l.fragment,
      reference: l.reference,
      resourceName: l.resourceName,
      secure: l.secure,
      error: ""
    }, h = Object.assign({}, d), w = [], E = g(h.scheme || u.scheme);
    E && E.serialize && E.serialize(u, h), u.path !== void 0 && (h.skipEscape ? u.path = unescape(u.path) : (u.path = escape(u.path), u.scheme !== void 0 && (u.path = u.path.split("%3A").join(":")))), h.reference !== "suffix" && u.scheme && w.push(u.scheme, ":");
    const p = e(u);
    if (p !== void 0 && (h.reference !== "suffix" && w.push("//"), w.push(p), u.path && u.path[0] !== "/" && w.push("/")), u.path !== void 0) {
      let y = u.path;
      !h.absolutePath && (!E || !E.absolutePath) && (y = A(y)), p === void 0 && y[0] === "/" && y[1] === "/" && (y = "/%2F" + y.slice(2)), w.push(y);
    }
    return u.query !== void 0 && w.push("?", u.query), u.fragment !== void 0 && w.push("#", u.fragment), w.join("");
  }
  const B = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
  function Q(l, d) {
    const u = Object.assign({}, d), h = {
      scheme: void 0,
      userinfo: void 0,
      host: "",
      port: void 0,
      path: "",
      query: void 0,
      fragment: void 0
    };
    let w = !1;
    u.reference === "suffix" && (u.scheme ? l = u.scheme + ":" + l : l = "//" + l);
    const E = l.match(B);
    if (E) {
      if (h.scheme = E[1], h.userinfo = E[3], h.host = E[4], h.port = parseInt(E[5], 10), h.path = E[6] || "", h.query = E[7], h.fragment = E[8], isNaN(h.port) && (h.port = E[5]), h.host)
        if (o(h.host) === !1) {
          const m = i(h.host);
          h.host = m.host.toLowerCase(), w = m.isIPV6;
        } else
          w = !0;
      h.scheme === void 0 && h.userinfo === void 0 && h.host === void 0 && h.port === void 0 && h.query === void 0 && !h.path ? h.reference = "same-document" : h.scheme === void 0 ? h.reference = "relative" : h.fragment === void 0 ? h.reference = "absolute" : h.reference = "uri", u.reference && u.reference !== "suffix" && u.reference !== h.reference && (h.error = h.error || "URI is not a " + u.reference + " reference.");
      const p = g(u.scheme || h.scheme);
      if (!u.unicodeSupport && (!p || !p.unicodeSupport) && h.host && (u.domainHost || p && p.domainHost) && w === !1 && r(h.host))
        try {
          h.host = URL.domainToASCII(h.host.toLowerCase());
        } catch (y) {
          h.error = h.error || "Host's domain name can not be converted to ASCII: " + y;
        }
      (!p || p && !p.skipNormalize) && (l.indexOf("%") !== -1 && (h.scheme !== void 0 && (h.scheme = unescape(h.scheme)), h.host !== void 0 && (h.host = unescape(h.host))), h.path && (h.path = escape(unescape(h.path))), h.fragment && (h.fragment = encodeURI(decodeURIComponent(h.fragment)))), p && p.parse && p.parse(h, u);
    } else
      h.error = h.error || "URI can not be parsed.";
    return h;
  }
  const f = {
    SCHEMES: s,
    normalize: n,
    resolve: a,
    resolveComponent: I,
    equal: C,
    serialize: c,
    parse: Q
  };
  return ht.exports = f, ht.exports.default = f, ht.exports.fastUri = f, ht.exports;
}
var Xg;
function PD() {
  if (Xg) return Ii;
  Xg = 1, Object.defineProperty(Ii, "__esModule", { value: !0 });
  const i = TD();
  return i.code = 'require("ajv/dist/runtime/uri").default', Ii.default = i, Ii;
}
var An;
function xI() {
  return An || (An = 1, (function(i) {
    Object.defineProperty(i, "__esModule", { value: !0 }), i.CodeGen = i.Name = i.nil = i.stringify = i.str = i._ = i.KeywordCxt = void 0;
    var A = _t();
    Object.defineProperty(i, "KeywordCxt", { enumerable: !0, get: function() {
      return A.KeywordCxt;
    } });
    var e = oA();
    Object.defineProperty(i, "_", { enumerable: !0, get: function() {
      return e._;
    } }), Object.defineProperty(i, "str", { enumerable: !0, get: function() {
      return e.str;
    } }), Object.defineProperty(i, "stringify", { enumerable: !0, get: function() {
      return e.stringify;
    } }), Object.defineProperty(i, "nil", { enumerable: !0, get: function() {
      return e.nil;
    } }), Object.defineProperty(i, "Name", { enumerable: !0, get: function() {
      return e.Name;
    } }), Object.defineProperty(i, "CodeGen", { enumerable: !0, get: function() {
      return e.CodeGen;
    } });
    const t = Yo(), o = $t(), r = JI(), s = Uo(), g = oA(), n = Ko(), a = Eo(), I = sA(), C = xD, c = PD(), B = (O, F) => new RegExp(O, F);
    B.code = "new RegExp";
    const Q = ["removeAdditional", "useDefaults", "coerceTypes"], f = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]), l = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    }, d = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    }, u = 200;
    function h(O) {
      var F, q, b, D, M, U, P, G, x, Y, S, k, K, H, V, W, iA, gA, nA, QA, dA, Ce, HA, vo, Jo;
      const It = O.strict, Ho = (F = O.code) === null || F === void 0 ? void 0 : F.optimize, Ts = Ho === !0 || Ho === void 0 ? 1 : Ho || 0, Ps = (b = (q = O.code) === null || q === void 0 ? void 0 : q.regExp) !== null && b !== void 0 ? b : B, eC = (D = O.uriResolver) !== null && D !== void 0 ? D : c.default;
      return {
        strictSchema: (U = (M = O.strictSchema) !== null && M !== void 0 ? M : It) !== null && U !== void 0 ? U : !0,
        strictNumbers: (G = (P = O.strictNumbers) !== null && P !== void 0 ? P : It) !== null && G !== void 0 ? G : !0,
        strictTypes: (Y = (x = O.strictTypes) !== null && x !== void 0 ? x : It) !== null && Y !== void 0 ? Y : "log",
        strictTuples: (k = (S = O.strictTuples) !== null && S !== void 0 ? S : It) !== null && k !== void 0 ? k : "log",
        strictRequired: (H = (K = O.strictRequired) !== null && K !== void 0 ? K : It) !== null && H !== void 0 ? H : !1,
        code: O.code ? { ...O.code, optimize: Ts, regExp: Ps } : { optimize: Ts, regExp: Ps },
        loopRequired: (V = O.loopRequired) !== null && V !== void 0 ? V : u,
        loopEnum: (W = O.loopEnum) !== null && W !== void 0 ? W : u,
        meta: (iA = O.meta) !== null && iA !== void 0 ? iA : !0,
        messages: (gA = O.messages) !== null && gA !== void 0 ? gA : !0,
        inlineRefs: (nA = O.inlineRefs) !== null && nA !== void 0 ? nA : !0,
        schemaId: (QA = O.schemaId) !== null && QA !== void 0 ? QA : "$id",
        addUsedSchema: (dA = O.addUsedSchema) !== null && dA !== void 0 ? dA : !0,
        validateSchema: (Ce = O.validateSchema) !== null && Ce !== void 0 ? Ce : !0,
        validateFormats: (HA = O.validateFormats) !== null && HA !== void 0 ? HA : !0,
        unicodeRegExp: (vo = O.unicodeRegExp) !== null && vo !== void 0 ? vo : !0,
        int32range: (Jo = O.int32range) !== null && Jo !== void 0 ? Jo : !0,
        uriResolver: eC
      };
    }
    class w {
      constructor(F = {}) {
        this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = /* @__PURE__ */ new Set(), this._loading = {}, this._cache = /* @__PURE__ */ new Map(), F = this.opts = { ...F, ...h(F) };
        const { es5: q, lines: b } = this.opts.code;
        this.scope = new g.ValueScope({ scope: {}, prefixes: f, es5: q, lines: b }), this.logger = j(F.logger);
        const D = F.validateFormats;
        F.validateFormats = !1, this.RULES = (0, r.getRules)(), E.call(this, l, F, "NOT SUPPORTED"), E.call(this, d, F, "DEPRECATED", "warn"), this._metaOpts = R.call(this), F.formats && m.call(this), this._addVocabularies(), this._addDefaultMetaSchema(), F.keywords && N.call(this, F.keywords), typeof F.meta == "object" && this.addMetaSchema(F.meta), y.call(this), F.validateFormats = D;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data: F, meta: q, schemaId: b } = this.opts;
        let D = C;
        b === "id" && (D = { ...C }, D.id = D.$id, delete D.$id), q && F && this.addMetaSchema(D, D[b], !1);
      }
      defaultMeta() {
        const { meta: F, schemaId: q } = this.opts;
        return this.opts.defaultMeta = typeof F == "object" ? F[q] || F : void 0;
      }
      validate(F, q) {
        let b;
        if (typeof F == "string") {
          if (b = this.getSchema(F), !b)
            throw new Error(`no schema with key or ref "${F}"`);
        } else
          b = this.compile(F);
        const D = b(q);
        return "$async" in b || (this.errors = b.errors), D;
      }
      compile(F, q) {
        const b = this._addSchema(F, q);
        return b.validate || this._compileSchemaEnv(b);
      }
      compileAsync(F, q) {
        if (typeof this.opts.loadSchema != "function")
          throw new Error("options.loadSchema should be a function");
        const { loadSchema: b } = this.opts;
        return D.call(this, F, q);
        async function D(Y, S) {
          await M.call(this, Y.$schema);
          const k = this._addSchema(Y, S);
          return k.validate || U.call(this, k);
        }
        async function M(Y) {
          Y && !this.getSchema(Y) && await D.call(this, { $ref: Y }, !0);
        }
        async function U(Y) {
          try {
            return this._compileSchemaEnv(Y);
          } catch (S) {
            if (!(S instanceof o.default))
              throw S;
            return P.call(this, S), await G.call(this, S.missingSchema), U.call(this, Y);
          }
        }
        function P({ missingSchema: Y, missingRef: S }) {
          if (this.refs[Y])
            throw new Error(`AnySchema ${Y} is loaded but ${S} cannot be resolved`);
        }
        async function G(Y) {
          const S = await x.call(this, Y);
          this.refs[Y] || await M.call(this, S.$schema), this.refs[Y] || this.addSchema(S, Y, q);
        }
        async function x(Y) {
          const S = this._loading[Y];
          if (S)
            return S;
          try {
            return await (this._loading[Y] = b(Y));
          } finally {
            delete this._loading[Y];
          }
        }
      }
      // Adds schema to the instance
      addSchema(F, q, b, D = this.opts.validateSchema) {
        if (Array.isArray(F)) {
          for (const U of F)
            this.addSchema(U, void 0, b, D);
          return this;
        }
        let M;
        if (typeof F == "object") {
          const { schemaId: U } = this.opts;
          if (M = F[U], M !== void 0 && typeof M != "string")
            throw new Error(`schema ${U} must be string`);
        }
        return q = (0, n.normalizeId)(q || M), this._checkUnique(q), this.schemas[q] = this._addSchema(F, b, q, D, !0), this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(F, q, b = this.opts.validateSchema) {
        return this.addSchema(F, q, !0, b), this;
      }
      //  Validate schema against its meta-schema
      validateSchema(F, q) {
        if (typeof F == "boolean")
          return !0;
        let b;
        if (b = F.$schema, b !== void 0 && typeof b != "string")
          throw new Error("$schema must be a string");
        if (b = b || this.opts.defaultMeta || this.defaultMeta(), !b)
          return this.logger.warn("meta-schema not available"), this.errors = null, !0;
        const D = this.validate(b, F);
        if (!D && q) {
          const M = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(M);
          else
            throw new Error(M);
        }
        return D;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(F) {
        let q;
        for (; typeof (q = p.call(this, F)) == "string"; )
          F = q;
        if (q === void 0) {
          const { schemaId: b } = this.opts, D = new s.SchemaEnv({ schema: {}, schemaId: b });
          if (q = s.resolveSchema.call(this, D, F), !q)
            return;
          this.refs[F] = q;
        }
        return q.validate || this._compileSchemaEnv(q);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(F) {
        if (F instanceof RegExp)
          return this._removeAllSchemas(this.schemas, F), this._removeAllSchemas(this.refs, F), this;
        switch (typeof F) {
          case "undefined":
            return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
          case "string": {
            const q = p.call(this, F);
            return typeof q == "object" && this._cache.delete(q.schema), delete this.schemas[F], delete this.refs[F], this;
          }
          case "object": {
            const q = F;
            this._cache.delete(q);
            let b = F[this.opts.schemaId];
            return b && (b = (0, n.normalizeId)(b), delete this.schemas[b], delete this.refs[b]), this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(F) {
        for (const q of F)
          this.addKeyword(q);
        return this;
      }
      addKeyword(F, q) {
        let b;
        if (typeof F == "string")
          b = F, typeof q == "object" && (this.logger.warn("these parameters are deprecated, see docs for addKeyword"), q.keyword = b);
        else if (typeof F == "object" && q === void 0) {
          if (q = F, b = q.keyword, Array.isArray(b) && !b.length)
            throw new Error("addKeywords: keyword must be string or non-empty array");
        } else
          throw new Error("invalid addKeywords parameters");
        if (z.call(this, b, q), !q)
          return (0, I.eachItem)(b, (M) => X.call(this, M)), this;
        _.call(this, q);
        const D = {
          ...q,
          type: (0, a.getJSONTypes)(q.type),
          schemaType: (0, a.getJSONTypes)(q.schemaType)
        };
        return (0, I.eachItem)(b, D.type.length === 0 ? (M) => X.call(this, M, D) : (M) => D.type.forEach((U) => X.call(this, M, D, U))), this;
      }
      getKeyword(F) {
        const q = this.RULES.all[F];
        return typeof q == "object" ? q.definition : !!q;
      }
      // Remove keyword
      removeKeyword(F) {
        const { RULES: q } = this;
        delete q.keywords[F], delete q.all[F];
        for (const b of q.rules) {
          const D = b.rules.findIndex((M) => M.keyword === F);
          D >= 0 && b.rules.splice(D, 1);
        }
        return this;
      }
      // Add format
      addFormat(F, q) {
        return typeof q == "string" && (q = new RegExp(q)), this.formats[F] = q, this;
      }
      errorsText(F = this.errors, { separator: q = ", ", dataVar: b = "data" } = {}) {
        return !F || F.length === 0 ? "No errors" : F.map((D) => `${b}${D.instancePath} ${D.message}`).reduce((D, M) => D + q + M);
      }
      $dataMetaSchema(F, q) {
        const b = this.RULES.all;
        F = JSON.parse(JSON.stringify(F));
        for (const D of q) {
          const M = D.split("/").slice(1);
          let U = F;
          for (const P of M)
            U = U[P];
          for (const P in b) {
            const G = b[P];
            if (typeof G != "object")
              continue;
            const { $data: x } = G.definition, Y = U[P];
            x && Y && (U[P] = $(Y));
          }
        }
        return F;
      }
      _removeAllSchemas(F, q) {
        for (const b in F) {
          const D = F[b];
          (!q || q.test(b)) && (typeof D == "string" ? delete F[b] : D && !D.meta && (this._cache.delete(D.schema), delete F[b]));
        }
      }
      _addSchema(F, q, b, D = this.opts.validateSchema, M = this.opts.addUsedSchema) {
        let U;
        const { schemaId: P } = this.opts;
        if (typeof F == "object")
          U = F[P];
        else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          if (typeof F != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let G = this._cache.get(F);
        if (G !== void 0)
          return G;
        b = (0, n.normalizeId)(U || b);
        const x = n.getSchemaRefs.call(this, F, b);
        return G = new s.SchemaEnv({ schema: F, schemaId: P, meta: q, baseId: b, localRefs: x }), this._cache.set(G.schema, G), M && !b.startsWith("#") && (b && this._checkUnique(b), this.refs[b] = G), D && this.validateSchema(F, !0), G;
      }
      _checkUnique(F) {
        if (this.schemas[F] || this.refs[F])
          throw new Error(`schema with key or id "${F}" already exists`);
      }
      _compileSchemaEnv(F) {
        if (F.meta ? this._compileMetaSchema(F) : s.compileSchema.call(this, F), !F.validate)
          throw new Error("ajv implementation error");
        return F.validate;
      }
      _compileMetaSchema(F) {
        const q = this.opts;
        this.opts = this._metaOpts;
        try {
          s.compileSchema.call(this, F);
        } finally {
          this.opts = q;
        }
      }
    }
    w.ValidationError = t.default, w.MissingRefError = o.default, i.default = w;
    function E(O, F, q, b = "error") {
      for (const D in O) {
        const M = D;
        M in F && this.logger[b](`${q}: option ${D}. ${O[M]}`);
      }
    }
    function p(O) {
      return O = (0, n.normalizeId)(O), this.schemas[O] || this.refs[O];
    }
    function y() {
      const O = this.opts.schemas;
      if (O)
        if (Array.isArray(O))
          this.addSchema(O);
        else
          for (const F in O)
            this.addSchema(O[F], F);
    }
    function m() {
      for (const O in this.opts.formats) {
        const F = this.opts.formats[O];
        F && this.addFormat(O, F);
      }
    }
    function N(O) {
      if (Array.isArray(O)) {
        this.addVocabulary(O);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const F in O) {
        const q = O[F];
        q.keyword || (q.keyword = F), this.addKeyword(q);
      }
    }
    function R() {
      const O = { ...this.opts };
      for (const F of Q)
        delete O[F];
      return O;
    }
    const L = { log() {
    }, warn() {
    }, error() {
    } };
    function j(O) {
      if (O === !1)
        return L;
      if (O === void 0)
        return console;
      if (O.log && O.warn && O.error)
        return O;
      throw new Error("logger must implement log, warn and error methods");
    }
    const J = /^[a-z_$][a-z0-9_$:-]*$/i;
    function z(O, F) {
      const { RULES: q } = this;
      if ((0, I.eachItem)(O, (b) => {
        if (q.keywords[b])
          throw new Error(`Keyword ${b} is already defined`);
        if (!J.test(b))
          throw new Error(`Keyword ${b} has invalid name`);
      }), !!F && F.$data && !("code" in F || "validate" in F))
        throw new Error('$data keyword must have "code" or "validate" function');
    }
    function X(O, F, q) {
      var b;
      const D = F?.post;
      if (q && D)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES: M } = this;
      let U = D ? M.post : M.rules.find(({ type: G }) => G === q);
      if (U || (U = { type: q, rules: [] }, M.rules.push(U)), M.keywords[O] = !0, !F)
        return;
      const P = {
        keyword: O,
        definition: {
          ...F,
          type: (0, a.getJSONTypes)(F.type),
          schemaType: (0, a.getJSONTypes)(F.schemaType)
        }
      };
      F.before ? Z.call(this, U, P, F.before) : U.rules.push(P), M.all[O] = P, (b = F.implements) === null || b === void 0 || b.forEach((G) => this.addKeyword(G));
    }
    function Z(O, F, q) {
      const b = O.rules.findIndex((D) => D.keyword === q);
      b >= 0 ? O.rules.splice(b, 0, F) : (O.rules.push(F), this.logger.warn(`rule ${q} is not defined`));
    }
    function _(O) {
      let { metaSchema: F } = O;
      F !== void 0 && (O.$data && this.opts.$data && (F = $(F)), O.validateSchema = this.compile(F, !0));
    }
    const T = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function $(O) {
      return { anyOf: [O, T] };
    }
  })(gr)), gr;
}
var Ci = {}, ci = {}, Bi = {}, en;
function jD() {
  if (en) return Bi;
  en = 1, Object.defineProperty(Bi, "__esModule", { value: !0 });
  const i = {
    keyword: "id",
    code() {
      throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
    }
  };
  return Bi.default = i, Bi;
}
var ce = {}, tn;
function Ls() {
  if (tn) return ce;
  tn = 1, Object.defineProperty(ce, "__esModule", { value: !0 }), ce.callRef = ce.getValidate = void 0;
  const i = $t(), A = ZA(), e = oA(), t = zA(), o = Uo(), r = sA(), s = {
    keyword: "$ref",
    schemaType: "string",
    code(a) {
      const { gen: I, schema: C, it: c } = a, { baseId: B, schemaEnv: Q, validateName: f, opts: l, self: d } = c, { root: u } = Q;
      if ((C === "#" || C === "#/") && B === u.baseId)
        return w();
      const h = o.resolveRef.call(d, u, B, C);
      if (h === void 0)
        throw new i.default(c.opts.uriResolver, B, C);
      if (h instanceof o.SchemaEnv)
        return E(h);
      return p(h);
      function w() {
        if (Q === u)
          return n(a, f, Q, Q.$async);
        const y = I.scopeValue("root", { ref: u });
        return n(a, (0, e._)`${y}.validate`, u, u.$async);
      }
      function E(y) {
        const m = g(a, y);
        n(a, m, y, y.$async);
      }
      function p(y) {
        const m = I.scopeValue("schema", l.code.source === !0 ? { ref: y, code: (0, e.stringify)(y) } : { ref: y }), N = I.name("valid"), R = a.subschema({
          schema: y,
          dataTypes: [],
          schemaPath: e.nil,
          topSchemaRef: m,
          errSchemaPath: C
        }, N);
        a.mergeEvaluated(R), a.ok(N);
      }
    }
  };
  function g(a, I) {
    const { gen: C } = a;
    return I.validate ? C.scopeValue("validate", { ref: I.validate }) : (0, e._)`${C.scopeValue("wrapper", { ref: I })}.validate`;
  }
  ce.getValidate = g;
  function n(a, I, C, c) {
    const { gen: B, it: Q } = a, { allErrors: f, schemaEnv: l, opts: d } = Q, u = d.passContext ? t.default.this : e.nil;
    c ? h() : w();
    function h() {
      if (!l.$async)
        throw new Error("async schema referenced by sync schema");
      const y = B.let("valid");
      B.try(() => {
        B.code((0, e._)`await ${(0, A.callValidateCode)(a, I, u)}`), p(I), f || B.assign(y, !0);
      }, (m) => {
        B.if((0, e._)`!(${m} instanceof ${Q.ValidationError})`, () => B.throw(m)), E(m), f || B.assign(y, !1);
      }), a.ok(y);
    }
    function w() {
      a.result((0, A.callValidateCode)(a, I, u), () => p(I), () => E(I));
    }
    function E(y) {
      const m = (0, e._)`${y}.errors`;
      B.assign(t.default.vErrors, (0, e._)`${t.default.vErrors} === null ? ${m} : ${t.default.vErrors}.concat(${m})`), B.assign(t.default.errors, (0, e._)`${t.default.vErrors}.length`);
    }
    function p(y) {
      var m;
      if (!Q.opts.unevaluated)
        return;
      const N = (m = C?.validate) === null || m === void 0 ? void 0 : m.evaluated;
      if (Q.props !== !0)
        if (N && !N.dynamicProps)
          N.props !== void 0 && (Q.props = r.mergeEvaluated.props(B, N.props, Q.props));
        else {
          const R = B.var("props", (0, e._)`${y}.evaluated.props`);
          Q.props = r.mergeEvaluated.props(B, R, Q.props, e.Name);
        }
      if (Q.items !== !0)
        if (N && !N.dynamicItems)
          N.items !== void 0 && (Q.items = r.mergeEvaluated.items(B, N.items, Q.items));
        else {
          const R = B.var("items", (0, e._)`${y}.evaluated.items`);
          Q.items = r.mergeEvaluated.items(B, R, Q.items, e.Name);
        }
    }
  }
  return ce.callRef = n, ce.default = s, ce;
}
var on;
function OI() {
  if (on) return ci;
  on = 1, Object.defineProperty(ci, "__esModule", { value: !0 });
  const i = jD(), A = Ls(), e = [
    "$schema",
    "$id",
    "$defs",
    "$vocabulary",
    { keyword: "$comment" },
    "definitions",
    i.default,
    A.default
  ];
  return ci.default = e, ci;
}
var Qi = {}, Ei = {}, rn;
function VD() {
  if (rn) return Ei;
  rn = 1, Object.defineProperty(Ei, "__esModule", { value: !0 });
  const i = oA(), A = i.operators, e = {
    maximum: { okStr: "<=", ok: A.LTE, fail: A.GT },
    minimum: { okStr: ">=", ok: A.GTE, fail: A.LT },
    exclusiveMaximum: { okStr: "<", ok: A.LT, fail: A.GTE },
    exclusiveMinimum: { okStr: ">", ok: A.GT, fail: A.LTE }
  }, t = {
    message: ({ keyword: r, schemaCode: s }) => (0, i.str)`must be ${e[r].okStr} ${s}`,
    params: ({ keyword: r, schemaCode: s }) => (0, i._)`{comparison: ${e[r].okStr}, limit: ${s}}`
  }, o = {
    keyword: Object.keys(e),
    type: "number",
    schemaType: "number",
    $data: !0,
    error: t,
    code(r) {
      const { keyword: s, data: g, schemaCode: n } = r;
      r.fail$data((0, i._)`${g} ${e[s].fail} ${n} || isNaN(${g})`);
    }
  };
  return Ei.default = o, Ei;
}
var li = {}, sn;
function WD() {
  if (sn) return li;
  sn = 1, Object.defineProperty(li, "__esModule", { value: !0 });
  const i = oA(), e = {
    keyword: "multipleOf",
    type: "number",
    schemaType: "number",
    $data: !0,
    error: {
      message: ({ schemaCode: t }) => (0, i.str)`must be multiple of ${t}`,
      params: ({ schemaCode: t }) => (0, i._)`{multipleOf: ${t}}`
    },
    code(t) {
      const { gen: o, data: r, schemaCode: s, it: g } = t, n = g.opts.multipleOfPrecision, a = o.let("res"), I = n ? (0, i._)`Math.abs(Math.round(${a}) - ${a}) > 1e-${n}` : (0, i._)`${a} !== parseInt(${a})`;
      t.fail$data((0, i._)`(${s} === 0 || (${a} = ${r}/${s}, ${I}))`);
    }
  };
  return li.default = e, li;
}
var ui = {}, di = {}, gn;
function zD() {
  if (gn) return di;
  gn = 1, Object.defineProperty(di, "__esModule", { value: !0 });
  function i(A) {
    const e = A.length;
    let t = 0, o = 0, r;
    for (; o < e; )
      t++, r = A.charCodeAt(o++), r >= 55296 && r <= 56319 && o < e && (r = A.charCodeAt(o), (r & 64512) === 56320 && o++);
    return t;
  }
  return di.default = i, i.code = 'require("ajv/dist/runtime/ucs2length").default', di;
}
var nn;
function ZD() {
  if (nn) return ui;
  nn = 1, Object.defineProperty(ui, "__esModule", { value: !0 });
  const i = oA(), A = sA(), e = zD(), o = {
    keyword: ["maxLength", "minLength"],
    type: "string",
    schemaType: "number",
    $data: !0,
    error: {
      message({ keyword: r, schemaCode: s }) {
        const g = r === "maxLength" ? "more" : "fewer";
        return (0, i.str)`must NOT have ${g} than ${s} characters`;
      },
      params: ({ schemaCode: r }) => (0, i._)`{limit: ${r}}`
    },
    code(r) {
      const { keyword: s, data: g, schemaCode: n, it: a } = r, I = s === "maxLength" ? i.operators.GT : i.operators.LT, C = a.opts.unicode === !1 ? (0, i._)`${g}.length` : (0, i._)`${(0, A.useFunc)(r.gen, e.default)}(${g})`;
      r.fail$data((0, i._)`${C} ${I} ${n}`);
    }
  };
  return ui.default = o, ui;
}
var hi = {}, an;
function _D() {
  if (an) return hi;
  an = 1, Object.defineProperty(hi, "__esModule", { value: !0 });
  const i = ZA(), A = oA(), t = {
    keyword: "pattern",
    type: "string",
    schemaType: "string",
    $data: !0,
    error: {
      message: ({ schemaCode: o }) => (0, A.str)`must match pattern "${o}"`,
      params: ({ schemaCode: o }) => (0, A._)`{pattern: ${o}}`
    },
    code(o) {
      const { data: r, $data: s, schema: g, schemaCode: n, it: a } = o, I = a.opts.unicodeRegExp ? "u" : "", C = s ? (0, A._)`(new RegExp(${n}, ${I}))` : (0, i.usePattern)(o, g);
      o.fail$data((0, A._)`!${C}.test(${r})`);
    }
  };
  return hi.default = t, hi;
}
var fi = {}, In;
function $D() {
  if (In) return fi;
  In = 1, Object.defineProperty(fi, "__esModule", { value: !0 });
  const i = oA(), e = {
    keyword: ["maxProperties", "minProperties"],
    type: "object",
    schemaType: "number",
    $data: !0,
    error: {
      message({ keyword: t, schemaCode: o }) {
        const r = t === "maxProperties" ? "more" : "fewer";
        return (0, i.str)`must NOT have ${r} than ${o} properties`;
      },
      params: ({ schemaCode: t }) => (0, i._)`{limit: ${t}}`
    },
    code(t) {
      const { keyword: o, data: r, schemaCode: s } = t, g = o === "maxProperties" ? i.operators.GT : i.operators.LT;
      t.fail$data((0, i._)`Object.keys(${r}).length ${g} ${s}`);
    }
  };
  return fi.default = e, fi;
}
var wi = {}, Cn;
function XD() {
  if (Cn) return wi;
  Cn = 1, Object.defineProperty(wi, "__esModule", { value: !0 });
  const i = ZA(), A = oA(), e = sA(), o = {
    keyword: "required",
    type: "object",
    schemaType: "array",
    $data: !0,
    error: {
      message: ({ params: { missingProperty: r } }) => (0, A.str)`must have required property '${r}'`,
      params: ({ params: { missingProperty: r } }) => (0, A._)`{missingProperty: ${r}}`
    },
    code(r) {
      const { gen: s, schema: g, schemaCode: n, data: a, $data: I, it: C } = r, { opts: c } = C;
      if (!I && g.length === 0)
        return;
      const B = g.length >= c.loopRequired;
      if (C.allErrors ? Q() : f(), c.strictRequired) {
        const u = r.parentSchema.properties, { definedProperties: h } = r.it;
        for (const w of g)
          if (u?.[w] === void 0 && !h.has(w)) {
            const E = C.schemaEnv.baseId + C.errSchemaPath, p = `required property "${w}" is not defined at "${E}" (strictRequired)`;
            (0, e.checkStrictMode)(C, p, C.opts.strictRequired);
          }
      }
      function Q() {
        if (B || I)
          r.block$data(A.nil, l);
        else
          for (const u of g)
            (0, i.checkReportMissingProp)(r, u);
      }
      function f() {
        const u = s.let("missing");
        if (B || I) {
          const h = s.let("valid", !0);
          r.block$data(h, () => d(u, h)), r.ok(h);
        } else
          s.if((0, i.checkMissingProp)(r, g, u)), (0, i.reportMissingProp)(r, u), s.else();
      }
      function l() {
        s.forOf("prop", n, (u) => {
          r.setParams({ missingProperty: u }), s.if((0, i.noPropertyInData)(s, a, u, c.ownProperties), () => r.error());
        });
      }
      function d(u, h) {
        r.setParams({ missingProperty: u }), s.forOf(u, n, () => {
          s.assign(h, (0, i.propertyInData)(s, a, u, c.ownProperties)), s.if((0, A.not)(h), () => {
            r.error(), s.break();
          });
        }, A.nil);
      }
    }
  };
  return wi.default = o, wi;
}
var pi = {}, cn;
function Am() {
  if (cn) return pi;
  cn = 1, Object.defineProperty(pi, "__esModule", { value: !0 });
  const i = oA(), e = {
    keyword: ["maxItems", "minItems"],
    type: "array",
    schemaType: "number",
    $data: !0,
    error: {
      message({ keyword: t, schemaCode: o }) {
        const r = t === "maxItems" ? "more" : "fewer";
        return (0, i.str)`must NOT have ${r} than ${o} items`;
      },
      params: ({ schemaCode: t }) => (0, i._)`{limit: ${t}}`
    },
    code(t) {
      const { keyword: o, data: r, schemaCode: s } = t, g = o === "maxItems" ? i.operators.GT : i.operators.LT;
      t.fail$data((0, i._)`${r}.length ${g} ${s}`);
    }
  };
  return pi.default = e, pi;
}
var yi = {}, Di = {}, Bn;
function xs() {
  if (Bn) return Di;
  Bn = 1, Object.defineProperty(Di, "__esModule", { value: !0 });
  const i = qI();
  return i.code = 'require("ajv/dist/runtime/equal").default', Di.default = i, Di;
}
var Qn;
function em() {
  if (Qn) return yi;
  Qn = 1, Object.defineProperty(yi, "__esModule", { value: !0 });
  const i = Eo(), A = oA(), e = sA(), t = xs(), r = {
    keyword: "uniqueItems",
    type: "array",
    schemaType: "boolean",
    $data: !0,
    error: {
      message: ({ params: { i: s, j: g } }) => (0, A.str)`must NOT have duplicate items (items ## ${g} and ${s} are identical)`,
      params: ({ params: { i: s, j: g } }) => (0, A._)`{i: ${s}, j: ${g}}`
    },
    code(s) {
      const { gen: g, data: n, $data: a, schema: I, parentSchema: C, schemaCode: c, it: B } = s;
      if (!a && !I)
        return;
      const Q = g.let("valid"), f = C.items ? (0, i.getSchemaTypes)(C.items) : [];
      s.block$data(Q, l, (0, A._)`${c} === false`), s.ok(Q);
      function l() {
        const w = g.let("i", (0, A._)`${n}.length`), E = g.let("j");
        s.setParams({ i: w, j: E }), g.assign(Q, !0), g.if((0, A._)`${w} > 1`, () => (d() ? u : h)(w, E));
      }
      function d() {
        return f.length > 0 && !f.some((w) => w === "object" || w === "array");
      }
      function u(w, E) {
        const p = g.name("item"), y = (0, i.checkDataTypes)(f, p, B.opts.strictNumbers, i.DataType.Wrong), m = g.const("indices", (0, A._)`{}`);
        g.for((0, A._)`;${w}--;`, () => {
          g.let(p, (0, A._)`${n}[${w}]`), g.if(y, (0, A._)`continue`), f.length > 1 && g.if((0, A._)`typeof ${p} == "string"`, (0, A._)`${p} += "_"`), g.if((0, A._)`typeof ${m}[${p}] == "number"`, () => {
            g.assign(E, (0, A._)`${m}[${p}]`), s.error(), g.assign(Q, !1).break();
          }).code((0, A._)`${m}[${p}] = ${w}`);
        });
      }
      function h(w, E) {
        const p = (0, e.useFunc)(g, t.default), y = g.name("outer");
        g.label(y).for((0, A._)`;${w}--;`, () => g.for((0, A._)`${E} = ${w}; ${E}--;`, () => g.if((0, A._)`${p}(${n}[${w}], ${n}[${E}])`, () => {
          s.error(), g.assign(Q, !1).break(y);
        })));
      }
    }
  };
  return yi.default = r, yi;
}
var mi = {}, En;
function tm() {
  if (En) return mi;
  En = 1, Object.defineProperty(mi, "__esModule", { value: !0 });
  const i = oA(), A = sA(), e = xs(), o = {
    keyword: "const",
    $data: !0,
    error: {
      message: "must be equal to constant",
      params: ({ schemaCode: r }) => (0, i._)`{allowedValue: ${r}}`
    },
    code(r) {
      const { gen: s, data: g, $data: n, schemaCode: a, schema: I } = r;
      n || I && typeof I == "object" ? r.fail$data((0, i._)`!${(0, A.useFunc)(s, e.default)}(${g}, ${a})`) : r.fail((0, i._)`${I} !== ${g}`);
    }
  };
  return mi.default = o, mi;
}
var Si = {}, ln;
function im() {
  if (ln) return Si;
  ln = 1, Object.defineProperty(Si, "__esModule", { value: !0 });
  const i = oA(), A = sA(), e = xs(), o = {
    keyword: "enum",
    schemaType: "array",
    $data: !0,
    error: {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode: r }) => (0, i._)`{allowedValues: ${r}}`
    },
    code(r) {
      const { gen: s, data: g, $data: n, schema: a, schemaCode: I, it: C } = r;
      if (!n && a.length === 0)
        throw new Error("enum must have non-empty array");
      const c = a.length >= C.opts.loopEnum;
      let B;
      const Q = () => B ?? (B = (0, A.useFunc)(s, e.default));
      let f;
      if (c || n)
        f = s.let("valid"), r.block$data(f, l);
      else {
        if (!Array.isArray(a))
          throw new Error("ajv implementation error");
        const u = s.const("vSchema", I);
        f = (0, i.or)(...a.map((h, w) => d(u, w)));
      }
      r.pass(f);
      function l() {
        s.assign(f, !1), s.forOf("v", I, (u) => s.if((0, i._)`${Q()}(${g}, ${u})`, () => s.assign(f, !0).break()));
      }
      function d(u, h) {
        const w = a[h];
        return typeof w == "object" && w !== null ? (0, i._)`${Q()}(${g}, ${u}[${h}])` : (0, i._)`${g} === ${w}`;
      }
    }
  };
  return Si.default = o, Si;
}
var un;
function TI() {
  if (un) return Qi;
  un = 1, Object.defineProperty(Qi, "__esModule", { value: !0 });
  const i = VD(), A = WD(), e = ZD(), t = _D(), o = $D(), r = XD(), s = Am(), g = em(), n = tm(), a = im(), I = [
    // number
    i.default,
    A.default,
    // string
    e.default,
    t.default,
    // object
    o.default,
    r.default,
    // array
    s.default,
    g.default,
    // any
    { keyword: "type", schemaType: ["string", "array"] },
    { keyword: "nullable", schemaType: "boolean" },
    n.default,
    a.default
  ];
  return Qi.default = I, Qi;
}
var Ni = {}, Oe = {}, dn;
function PI() {
  if (dn) return Oe;
  dn = 1, Object.defineProperty(Oe, "__esModule", { value: !0 }), Oe.validateAdditionalItems = void 0;
  const i = oA(), A = sA(), t = {
    keyword: "additionalItems",
    type: "array",
    schemaType: ["boolean", "object"],
    before: "uniqueItems",
    error: {
      message: ({ params: { len: r } }) => (0, i.str)`must NOT have more than ${r} items`,
      params: ({ params: { len: r } }) => (0, i._)`{limit: ${r}}`
    },
    code(r) {
      const { parentSchema: s, it: g } = r, { items: n } = s;
      if (!Array.isArray(n)) {
        (0, A.checkStrictMode)(g, '"additionalItems" is ignored when "items" is not an array of schemas');
        return;
      }
      o(r, n);
    }
  };
  function o(r, s) {
    const { gen: g, schema: n, data: a, keyword: I, it: C } = r;
    C.items = !0;
    const c = g.const("len", (0, i._)`${a}.length`);
    if (n === !1)
      r.setParams({ len: s.length }), r.pass((0, i._)`${c} <= ${s.length}`);
    else if (typeof n == "object" && !(0, A.alwaysValidSchema)(C, n)) {
      const Q = g.var("valid", (0, i._)`${c} <= ${s.length}`);
      g.if((0, i.not)(Q), () => B(Q)), r.ok(Q);
    }
    function B(Q) {
      g.forRange("i", s.length, c, (f) => {
        r.subschema({ keyword: I, dataProp: f, dataPropType: A.Type.Num }, Q), C.allErrors || g.if((0, i.not)(Q), () => g.break());
      });
    }
  }
  return Oe.validateAdditionalItems = o, Oe.default = t, Oe;
}
var Mi = {}, Te = {}, hn;
function jI() {
  if (hn) return Te;
  hn = 1, Object.defineProperty(Te, "__esModule", { value: !0 }), Te.validateTuple = void 0;
  const i = oA(), A = sA(), e = ZA(), t = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "array", "boolean"],
    before: "uniqueItems",
    code(r) {
      const { schema: s, it: g } = r;
      if (Array.isArray(s))
        return o(r, "additionalItems", s);
      g.items = !0, !(0, A.alwaysValidSchema)(g, s) && r.ok((0, e.validateArray)(r));
    }
  };
  function o(r, s, g = r.schema) {
    const { gen: n, parentSchema: a, data: I, keyword: C, it: c } = r;
    f(a), c.opts.unevaluated && g.length && c.items !== !0 && (c.items = A.mergeEvaluated.items(n, g.length, c.items));
    const B = n.name("valid"), Q = n.const("len", (0, i._)`${I}.length`);
    g.forEach((l, d) => {
      (0, A.alwaysValidSchema)(c, l) || (n.if((0, i._)`${Q} > ${d}`, () => r.subschema({
        keyword: C,
        schemaProp: d,
        dataProp: d
      }, B)), r.ok(B));
    });
    function f(l) {
      const { opts: d, errSchemaPath: u } = c, h = g.length, w = h === l.minItems && (h === l.maxItems || l[s] === !1);
      if (d.strictTuples && !w) {
        const E = `"${C}" is ${h}-tuple, but minItems or maxItems/${s} are not specified or different at path "${u}"`;
        (0, A.checkStrictMode)(c, E, d.strictTuples);
      }
    }
  }
  return Te.validateTuple = o, Te.default = t, Te;
}
var fn;
function om() {
  if (fn) return Mi;
  fn = 1, Object.defineProperty(Mi, "__esModule", { value: !0 });
  const i = jI(), A = {
    keyword: "prefixItems",
    type: "array",
    schemaType: ["array"],
    before: "uniqueItems",
    code: (e) => (0, i.validateTuple)(e, "items")
  };
  return Mi.default = A, Mi;
}
var ki = {}, wn;
function rm() {
  if (wn) return ki;
  wn = 1, Object.defineProperty(ki, "__esModule", { value: !0 });
  const i = oA(), A = sA(), e = ZA(), t = PI(), r = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    error: {
      message: ({ params: { len: s } }) => (0, i.str)`must NOT have more than ${s} items`,
      params: ({ params: { len: s } }) => (0, i._)`{limit: ${s}}`
    },
    code(s) {
      const { schema: g, parentSchema: n, it: a } = s, { prefixItems: I } = n;
      a.items = !0, !(0, A.alwaysValidSchema)(a, g) && (I ? (0, t.validateAdditionalItems)(s, I) : s.ok((0, e.validateArray)(s)));
    }
  };
  return ki.default = r, ki;
}
var Gi = {}, pn;
function sm() {
  if (pn) return Gi;
  pn = 1, Object.defineProperty(Gi, "__esModule", { value: !0 });
  const i = oA(), A = sA(), t = {
    keyword: "contains",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    trackErrors: !0,
    error: {
      message: ({ params: { min: o, max: r } }) => r === void 0 ? (0, i.str)`must contain at least ${o} valid item(s)` : (0, i.str)`must contain at least ${o} and no more than ${r} valid item(s)`,
      params: ({ params: { min: o, max: r } }) => r === void 0 ? (0, i._)`{minContains: ${o}}` : (0, i._)`{minContains: ${o}, maxContains: ${r}}`
    },
    code(o) {
      const { gen: r, schema: s, parentSchema: g, data: n, it: a } = o;
      let I, C;
      const { minContains: c, maxContains: B } = g;
      a.opts.next ? (I = c === void 0 ? 1 : c, C = B) : I = 1;
      const Q = r.const("len", (0, i._)`${n}.length`);
      if (o.setParams({ min: I, max: C }), C === void 0 && I === 0) {
        (0, A.checkStrictMode)(a, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
        return;
      }
      if (C !== void 0 && I > C) {
        (0, A.checkStrictMode)(a, '"minContains" > "maxContains" is always invalid'), o.fail();
        return;
      }
      if ((0, A.alwaysValidSchema)(a, s)) {
        let h = (0, i._)`${Q} >= ${I}`;
        C !== void 0 && (h = (0, i._)`${h} && ${Q} <= ${C}`), o.pass(h);
        return;
      }
      a.items = !0;
      const f = r.name("valid");
      C === void 0 && I === 1 ? d(f, () => r.if(f, () => r.break())) : I === 0 ? (r.let(f, !0), C !== void 0 && r.if((0, i._)`${n}.length > 0`, l)) : (r.let(f, !1), l()), o.result(f, () => o.reset());
      function l() {
        const h = r.name("_valid"), w = r.let("count", 0);
        d(h, () => r.if(h, () => u(w)));
      }
      function d(h, w) {
        r.forRange("i", 0, Q, (E) => {
          o.subschema({
            keyword: "contains",
            dataProp: E,
            dataPropType: A.Type.Num,
            compositeRule: !0
          }, h), w();
        });
      }
      function u(h) {
        r.code((0, i._)`${h}++`), C === void 0 ? r.if((0, i._)`${h} >= ${I}`, () => r.assign(f, !0).break()) : (r.if((0, i._)`${h} > ${C}`, () => r.assign(f, !1).break()), I === 1 ? r.assign(f, !0) : r.if((0, i._)`${h} >= ${I}`, () => r.assign(f, !0)));
      }
    }
  };
  return Gi.default = t, Gi;
}
var lr = {}, yn;
function Os() {
  return yn || (yn = 1, (function(i) {
    Object.defineProperty(i, "__esModule", { value: !0 }), i.validateSchemaDeps = i.validatePropertyDeps = i.error = void 0;
    const A = oA(), e = sA(), t = ZA();
    i.error = {
      message: ({ params: { property: n, depsCount: a, deps: I } }) => {
        const C = a === 1 ? "property" : "properties";
        return (0, A.str)`must have ${C} ${I} when property ${n} is present`;
      },
      params: ({ params: { property: n, depsCount: a, deps: I, missingProperty: C } }) => (0, A._)`{property: ${n},
    missingProperty: ${C},
    depsCount: ${a},
    deps: ${I}}`
      // TODO change to reference
    };
    const o = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: i.error,
      code(n) {
        const [a, I] = r(n);
        s(n, a), g(n, I);
      }
    };
    function r({ schema: n }) {
      const a = {}, I = {};
      for (const C in n) {
        if (C === "__proto__")
          continue;
        const c = Array.isArray(n[C]) ? a : I;
        c[C] = n[C];
      }
      return [a, I];
    }
    function s(n, a = n.schema) {
      const { gen: I, data: C, it: c } = n;
      if (Object.keys(a).length === 0)
        return;
      const B = I.let("missing");
      for (const Q in a) {
        const f = a[Q];
        if (f.length === 0)
          continue;
        const l = (0, t.propertyInData)(I, C, Q, c.opts.ownProperties);
        n.setParams({
          property: Q,
          depsCount: f.length,
          deps: f.join(", ")
        }), c.allErrors ? I.if(l, () => {
          for (const d of f)
            (0, t.checkReportMissingProp)(n, d);
        }) : (I.if((0, A._)`${l} && (${(0, t.checkMissingProp)(n, f, B)})`), (0, t.reportMissingProp)(n, B), I.else());
      }
    }
    i.validatePropertyDeps = s;
    function g(n, a = n.schema) {
      const { gen: I, data: C, keyword: c, it: B } = n, Q = I.name("valid");
      for (const f in a)
        (0, e.alwaysValidSchema)(B, a[f]) || (I.if(
          (0, t.propertyInData)(I, C, f, B.opts.ownProperties),
          () => {
            const l = n.subschema({ keyword: c, schemaProp: f }, Q);
            n.mergeValidEvaluated(l, Q);
          },
          () => I.var(Q, !0)
          // TODO var
        ), n.ok(Q));
    }
    i.validateSchemaDeps = g, i.default = o;
  })(lr)), lr;
}
var Fi = {}, Dn;
function gm() {
  if (Dn) return Fi;
  Dn = 1, Object.defineProperty(Fi, "__esModule", { value: !0 });
  const i = oA(), A = sA(), t = {
    keyword: "propertyNames",
    type: "object",
    schemaType: ["object", "boolean"],
    error: {
      message: "property name must be valid",
      params: ({ params: o }) => (0, i._)`{propertyName: ${o.propertyName}}`
    },
    code(o) {
      const { gen: r, schema: s, data: g, it: n } = o;
      if ((0, A.alwaysValidSchema)(n, s))
        return;
      const a = r.name("valid");
      r.forIn("key", g, (I) => {
        o.setParams({ propertyName: I }), o.subschema({
          keyword: "propertyNames",
          data: I,
          dataTypes: ["string"],
          propertyName: I,
          compositeRule: !0
        }, a), r.if((0, i.not)(a), () => {
          o.error(!0), n.allErrors || r.break();
        });
      }), o.ok(a);
    }
  };
  return Fi.default = t, Fi;
}
var Ri = {}, mn;
function VI() {
  if (mn) return Ri;
  mn = 1, Object.defineProperty(Ri, "__esModule", { value: !0 });
  const i = ZA(), A = oA(), e = zA(), t = sA(), r = {
    keyword: "additionalProperties",
    type: ["object"],
    schemaType: ["boolean", "object"],
    allowUndefined: !0,
    trackErrors: !0,
    error: {
      message: "must NOT have additional properties",
      params: ({ params: s }) => (0, A._)`{additionalProperty: ${s.additionalProperty}}`
    },
    code(s) {
      const { gen: g, schema: n, parentSchema: a, data: I, errsCount: C, it: c } = s;
      if (!C)
        throw new Error("ajv implementation error");
      const { allErrors: B, opts: Q } = c;
      if (c.props = !0, Q.removeAdditional !== "all" && (0, t.alwaysValidSchema)(c, n))
        return;
      const f = (0, i.allSchemaProperties)(a.properties), l = (0, i.allSchemaProperties)(a.patternProperties);
      d(), s.ok((0, A._)`${C} === ${e.default.errors}`);
      function d() {
        g.forIn("key", I, (p) => {
          !f.length && !l.length ? w(p) : g.if(u(p), () => w(p));
        });
      }
      function u(p) {
        let y;
        if (f.length > 8) {
          const m = (0, t.schemaRefOrVal)(c, a.properties, "properties");
          y = (0, i.isOwnProperty)(g, m, p);
        } else f.length ? y = (0, A.or)(...f.map((m) => (0, A._)`${p} === ${m}`)) : y = A.nil;
        return l.length && (y = (0, A.or)(y, ...l.map((m) => (0, A._)`${(0, i.usePattern)(s, m)}.test(${p})`))), (0, A.not)(y);
      }
      function h(p) {
        g.code((0, A._)`delete ${I}[${p}]`);
      }
      function w(p) {
        if (Q.removeAdditional === "all" || Q.removeAdditional && n === !1) {
          h(p);
          return;
        }
        if (n === !1) {
          s.setParams({ additionalProperty: p }), s.error(), B || g.break();
          return;
        }
        if (typeof n == "object" && !(0, t.alwaysValidSchema)(c, n)) {
          const y = g.name("valid");
          Q.removeAdditional === "failing" ? (E(p, y, !1), g.if((0, A.not)(y), () => {
            s.reset(), h(p);
          })) : (E(p, y), B || g.if((0, A.not)(y), () => g.break()));
        }
      }
      function E(p, y, m) {
        const N = {
          keyword: "additionalProperties",
          dataProp: p,
          dataPropType: t.Type.Str
        };
        m === !1 && Object.assign(N, {
          compositeRule: !0,
          createErrors: !1,
          allErrors: !1
        }), s.subschema(N, y);
      }
    }
  };
  return Ri.default = r, Ri;
}
var bi = {}, Sn;
function nm() {
  if (Sn) return bi;
  Sn = 1, Object.defineProperty(bi, "__esModule", { value: !0 });
  const i = _t(), A = ZA(), e = sA(), t = VI(), o = {
    keyword: "properties",
    type: "object",
    schemaType: "object",
    code(r) {
      const { gen: s, schema: g, parentSchema: n, data: a, it: I } = r;
      I.opts.removeAdditional === "all" && n.additionalProperties === void 0 && t.default.code(new i.KeywordCxt(I, t.default, "additionalProperties"));
      const C = (0, A.allSchemaProperties)(g);
      for (const l of C)
        I.definedProperties.add(l);
      I.opts.unevaluated && C.length && I.props !== !0 && (I.props = e.mergeEvaluated.props(s, (0, e.toHash)(C), I.props));
      const c = C.filter((l) => !(0, e.alwaysValidSchema)(I, g[l]));
      if (c.length === 0)
        return;
      const B = s.name("valid");
      for (const l of c)
        Q(l) ? f(l) : (s.if((0, A.propertyInData)(s, a, l, I.opts.ownProperties)), f(l), I.allErrors || s.else().var(B, !0), s.endIf()), r.it.definedProperties.add(l), r.ok(B);
      function Q(l) {
        return I.opts.useDefaults && !I.compositeRule && g[l].default !== void 0;
      }
      function f(l) {
        r.subschema({
          keyword: "properties",
          schemaProp: l,
          dataProp: l
        }, B);
      }
    }
  };
  return bi.default = o, bi;
}
var Ki = {}, Nn;
function am() {
  if (Nn) return Ki;
  Nn = 1, Object.defineProperty(Ki, "__esModule", { value: !0 });
  const i = ZA(), A = oA(), e = sA(), t = sA(), o = {
    keyword: "patternProperties",
    type: "object",
    schemaType: "object",
    code(r) {
      const { gen: s, schema: g, data: n, parentSchema: a, it: I } = r, { opts: C } = I, c = (0, i.allSchemaProperties)(g), B = c.filter((w) => (0, e.alwaysValidSchema)(I, g[w]));
      if (c.length === 0 || B.length === c.length && (!I.opts.unevaluated || I.props === !0))
        return;
      const Q = C.strictSchema && !C.allowMatchingProperties && a.properties, f = s.name("valid");
      I.props !== !0 && !(I.props instanceof A.Name) && (I.props = (0, t.evaluatedPropsToName)(s, I.props));
      const { props: l } = I;
      d();
      function d() {
        for (const w of c)
          Q && u(w), I.allErrors ? h(w) : (s.var(f, !0), h(w), s.if(f));
      }
      function u(w) {
        for (const E in Q)
          new RegExp(w).test(E) && (0, e.checkStrictMode)(I, `property ${E} matches pattern ${w} (use allowMatchingProperties)`);
      }
      function h(w) {
        s.forIn("key", n, (E) => {
          s.if((0, A._)`${(0, i.usePattern)(r, w)}.test(${E})`, () => {
            const p = B.includes(w);
            p || r.subschema({
              keyword: "patternProperties",
              schemaProp: w,
              dataProp: E,
              dataPropType: t.Type.Str
            }, f), I.opts.unevaluated && l !== !0 ? s.assign((0, A._)`${l}[${E}]`, !0) : !p && !I.allErrors && s.if((0, A.not)(f), () => s.break());
          });
        });
      }
    }
  };
  return Ki.default = o, Ki;
}
var Yi = {}, Mn;
function Im() {
  if (Mn) return Yi;
  Mn = 1, Object.defineProperty(Yi, "__esModule", { value: !0 });
  const i = sA(), A = {
    keyword: "not",
    schemaType: ["object", "boolean"],
    trackErrors: !0,
    code(e) {
      const { gen: t, schema: o, it: r } = e;
      if ((0, i.alwaysValidSchema)(r, o)) {
        e.fail();
        return;
      }
      const s = t.name("valid");
      e.subschema({
        keyword: "not",
        compositeRule: !0,
        createErrors: !1,
        allErrors: !1
      }, s), e.failResult(s, () => e.reset(), () => e.error());
    },
    error: { message: "must NOT be valid" }
  };
  return Yi.default = A, Yi;
}
var Ui = {}, kn;
function Cm() {
  if (kn) return Ui;
  kn = 1, Object.defineProperty(Ui, "__esModule", { value: !0 });
  const A = {
    keyword: "anyOf",
    schemaType: "array",
    trackErrors: !0,
    code: ZA().validateUnion,
    error: { message: "must match a schema in anyOf" }
  };
  return Ui.default = A, Ui;
}
var vi = {}, Gn;
function cm() {
  if (Gn) return vi;
  Gn = 1, Object.defineProperty(vi, "__esModule", { value: !0 });
  const i = oA(), A = sA(), t = {
    keyword: "oneOf",
    schemaType: "array",
    trackErrors: !0,
    error: {
      message: "must match exactly one schema in oneOf",
      params: ({ params: o }) => (0, i._)`{passingSchemas: ${o.passing}}`
    },
    code(o) {
      const { gen: r, schema: s, parentSchema: g, it: n } = o;
      if (!Array.isArray(s))
        throw new Error("ajv implementation error");
      if (n.opts.discriminator && g.discriminator)
        return;
      const a = s, I = r.let("valid", !1), C = r.let("passing", null), c = r.name("_valid");
      o.setParams({ passing: C }), r.block(B), o.result(I, () => o.reset(), () => o.error(!0));
      function B() {
        a.forEach((Q, f) => {
          let l;
          (0, A.alwaysValidSchema)(n, Q) ? r.var(c, !0) : l = o.subschema({
            keyword: "oneOf",
            schemaProp: f,
            compositeRule: !0
          }, c), f > 0 && r.if((0, i._)`${c} && ${I}`).assign(I, !1).assign(C, (0, i._)`[${C}, ${f}]`).else(), r.if(c, () => {
            r.assign(I, !0), r.assign(C, f), l && o.mergeEvaluated(l, i.Name);
          });
        });
      }
    }
  };
  return vi.default = t, vi;
}
var Ji = {}, Fn;
function Bm() {
  if (Fn) return Ji;
  Fn = 1, Object.defineProperty(Ji, "__esModule", { value: !0 });
  const i = sA(), A = {
    keyword: "allOf",
    schemaType: "array",
    code(e) {
      const { gen: t, schema: o, it: r } = e;
      if (!Array.isArray(o))
        throw new Error("ajv implementation error");
      const s = t.name("valid");
      o.forEach((g, n) => {
        if ((0, i.alwaysValidSchema)(r, g))
          return;
        const a = e.subschema({ keyword: "allOf", schemaProp: n }, s);
        e.ok(s), e.mergeEvaluated(a);
      });
    }
  };
  return Ji.default = A, Ji;
}
var Hi = {}, Rn;
function Qm() {
  if (Rn) return Hi;
  Rn = 1, Object.defineProperty(Hi, "__esModule", { value: !0 });
  const i = oA(), A = sA(), t = {
    keyword: "if",
    schemaType: ["object", "boolean"],
    trackErrors: !0,
    error: {
      message: ({ params: r }) => (0, i.str)`must match "${r.ifClause}" schema`,
      params: ({ params: r }) => (0, i._)`{failingKeyword: ${r.ifClause}}`
    },
    code(r) {
      const { gen: s, parentSchema: g, it: n } = r;
      g.then === void 0 && g.else === void 0 && (0, A.checkStrictMode)(n, '"if" without "then" and "else" is ignored');
      const a = o(n, "then"), I = o(n, "else");
      if (!a && !I)
        return;
      const C = s.let("valid", !0), c = s.name("_valid");
      if (B(), r.reset(), a && I) {
        const f = s.let("ifClause");
        r.setParams({ ifClause: f }), s.if(c, Q("then", f), Q("else", f));
      } else a ? s.if(c, Q("then")) : s.if((0, i.not)(c), Q("else"));
      r.pass(C, () => r.error(!0));
      function B() {
        const f = r.subschema({
          keyword: "if",
          compositeRule: !0,
          createErrors: !1,
          allErrors: !1
        }, c);
        r.mergeEvaluated(f);
      }
      function Q(f, l) {
        return () => {
          const d = r.subschema({ keyword: f }, c);
          s.assign(C, c), r.mergeValidEvaluated(d, C), l ? s.assign(l, (0, i._)`${f}`) : r.setParams({ ifClause: f });
        };
      }
    }
  };
  function o(r, s) {
    const g = r.schema[s];
    return g !== void 0 && !(0, A.alwaysValidSchema)(r, g);
  }
  return Hi.default = t, Hi;
}
var qi = {}, bn;
function Em() {
  if (bn) return qi;
  bn = 1, Object.defineProperty(qi, "__esModule", { value: !0 });
  const i = sA(), A = {
    keyword: ["then", "else"],
    schemaType: ["object", "boolean"],
    code({ keyword: e, parentSchema: t, it: o }) {
      t.if === void 0 && (0, i.checkStrictMode)(o, `"${e}" without "if" is ignored`);
    }
  };
  return qi.default = A, qi;
}
var Kn;
function WI() {
  if (Kn) return Ni;
  Kn = 1, Object.defineProperty(Ni, "__esModule", { value: !0 });
  const i = PI(), A = om(), e = jI(), t = rm(), o = sm(), r = Os(), s = gm(), g = VI(), n = nm(), a = am(), I = Im(), C = Cm(), c = cm(), B = Bm(), Q = Qm(), f = Em();
  function l(d = !1) {
    const u = [
      // any
      I.default,
      C.default,
      c.default,
      B.default,
      Q.default,
      f.default,
      // object
      s.default,
      g.default,
      r.default,
      n.default,
      a.default
    ];
    return d ? u.push(A.default, t.default) : u.push(i.default, e.default), u.push(o.default), u;
  }
  return Ni.default = l, Ni;
}
var Li = {}, Pe = {}, Yn;
function zI() {
  if (Yn) return Pe;
  Yn = 1, Object.defineProperty(Pe, "__esModule", { value: !0 }), Pe.dynamicAnchor = void 0;
  const i = oA(), A = zA(), e = Uo(), t = Ls(), o = {
    keyword: "$dynamicAnchor",
    schemaType: "string",
    code: (g) => r(g, g.schema)
  };
  function r(g, n) {
    const { gen: a, it: I } = g;
    I.schemaEnv.root.dynamicAnchors[n] = !0;
    const C = (0, i._)`${A.default.dynamicAnchors}${(0, i.getProperty)(n)}`, c = I.errSchemaPath === "#" ? I.validateName : s(g);
    a.if((0, i._)`!${C}`, () => a.assign(C, c));
  }
  Pe.dynamicAnchor = r;
  function s(g) {
    const { schemaEnv: n, schema: a, self: I } = g.it, { root: C, baseId: c, localRefs: B, meta: Q } = n.root, { schemaId: f } = I.opts, l = new e.SchemaEnv({ schema: a, schemaId: f, root: C, baseId: c, localRefs: B, meta: Q });
    return e.compileSchema.call(I, l), (0, t.getValidate)(g, l);
  }
  return Pe.default = o, Pe;
}
var je = {}, Un;
function ZI() {
  if (Un) return je;
  Un = 1, Object.defineProperty(je, "__esModule", { value: !0 }), je.dynamicRef = void 0;
  const i = oA(), A = zA(), e = Ls(), t = {
    keyword: "$dynamicRef",
    schemaType: "string",
    code: (r) => o(r, r.schema)
  };
  function o(r, s) {
    const { gen: g, keyword: n, it: a } = r;
    if (s[0] !== "#")
      throw new Error(`"${n}" only supports hash fragment reference`);
    const I = s.slice(1);
    if (a.allErrors)
      C();
    else {
      const B = g.let("valid", !1);
      C(B), r.ok(B);
    }
    function C(B) {
      if (a.schemaEnv.root.dynamicAnchors[I]) {
        const Q = g.let("_v", (0, i._)`${A.default.dynamicAnchors}${(0, i.getProperty)(I)}`);
        g.if(Q, c(Q, B), c(a.validateName, B));
      } else
        c(a.validateName, B)();
    }
    function c(B, Q) {
      return Q ? () => g.block(() => {
        (0, e.callRef)(r, B), g.let(Q, !0);
      }) : () => (0, e.callRef)(r, B);
    }
  }
  return je.dynamicRef = o, je.default = t, je;
}
var xi = {}, vn;
function lm() {
  if (vn) return xi;
  vn = 1, Object.defineProperty(xi, "__esModule", { value: !0 });
  const i = zI(), A = sA(), e = {
    keyword: "$recursiveAnchor",
    schemaType: "boolean",
    code(t) {
      t.schema ? (0, i.dynamicAnchor)(t, "") : (0, A.checkStrictMode)(t.it, "$recursiveAnchor: false is ignored");
    }
  };
  return xi.default = e, xi;
}
var Oi = {}, Jn;
function um() {
  if (Jn) return Oi;
  Jn = 1, Object.defineProperty(Oi, "__esModule", { value: !0 });
  const i = ZI(), A = {
    keyword: "$recursiveRef",
    schemaType: "string",
    code: (e) => (0, i.dynamicRef)(e, e.schema)
  };
  return Oi.default = A, Oi;
}
var Hn;
function dm() {
  if (Hn) return Li;
  Hn = 1, Object.defineProperty(Li, "__esModule", { value: !0 });
  const i = zI(), A = ZI(), e = lm(), t = um(), o = [i.default, A.default, e.default, t.default];
  return Li.default = o, Li;
}
var Ti = {}, Pi = {}, qn;
function hm() {
  if (qn) return Pi;
  qn = 1, Object.defineProperty(Pi, "__esModule", { value: !0 });
  const i = Os(), A = {
    keyword: "dependentRequired",
    type: "object",
    schemaType: "object",
    error: i.error,
    code: (e) => (0, i.validatePropertyDeps)(e)
  };
  return Pi.default = A, Pi;
}
var ji = {}, Ln;
function fm() {
  if (Ln) return ji;
  Ln = 1, Object.defineProperty(ji, "__esModule", { value: !0 });
  const i = Os(), A = {
    keyword: "dependentSchemas",
    type: "object",
    schemaType: "object",
    code: (e) => (0, i.validateSchemaDeps)(e)
  };
  return ji.default = A, ji;
}
var Vi = {}, xn;
function wm() {
  if (xn) return Vi;
  xn = 1, Object.defineProperty(Vi, "__esModule", { value: !0 });
  const i = sA(), A = {
    keyword: ["maxContains", "minContains"],
    type: "array",
    schemaType: "number",
    code({ keyword: e, parentSchema: t, it: o }) {
      t.contains === void 0 && (0, i.checkStrictMode)(o, `"${e}" without "contains" is ignored`);
    }
  };
  return Vi.default = A, Vi;
}
var On;
function pm() {
  if (On) return Ti;
  On = 1, Object.defineProperty(Ti, "__esModule", { value: !0 });
  const i = hm(), A = fm(), e = wm(), t = [i.default, A.default, e.default];
  return Ti.default = t, Ti;
}
var Wi = {}, zi = {}, Tn;
function ym() {
  if (Tn) return zi;
  Tn = 1, Object.defineProperty(zi, "__esModule", { value: !0 });
  const i = oA(), A = sA(), e = zA(), o = {
    keyword: "unevaluatedProperties",
    type: "object",
    schemaType: ["boolean", "object"],
    trackErrors: !0,
    error: {
      message: "must NOT have unevaluated properties",
      params: ({ params: r }) => (0, i._)`{unevaluatedProperty: ${r.unevaluatedProperty}}`
    },
    code(r) {
      const { gen: s, schema: g, data: n, errsCount: a, it: I } = r;
      if (!a)
        throw new Error("ajv implementation error");
      const { allErrors: C, props: c } = I;
      c instanceof i.Name ? s.if((0, i._)`${c} !== true`, () => s.forIn("key", n, (l) => s.if(Q(c, l), () => B(l)))) : c !== !0 && s.forIn("key", n, (l) => c === void 0 ? B(l) : s.if(f(c, l), () => B(l))), I.props = !0, r.ok((0, i._)`${a} === ${e.default.errors}`);
      function B(l) {
        if (g === !1) {
          r.setParams({ unevaluatedProperty: l }), r.error(), C || s.break();
          return;
        }
        if (!(0, A.alwaysValidSchema)(I, g)) {
          const d = s.name("valid");
          r.subschema({
            keyword: "unevaluatedProperties",
            dataProp: l,
            dataPropType: A.Type.Str
          }, d), C || s.if((0, i.not)(d), () => s.break());
        }
      }
      function Q(l, d) {
        return (0, i._)`!${l} || !${l}[${d}]`;
      }
      function f(l, d) {
        const u = [];
        for (const h in l)
          l[h] === !0 && u.push((0, i._)`${d} !== ${h}`);
        return (0, i.and)(...u);
      }
    }
  };
  return zi.default = o, zi;
}
var Zi = {}, Pn;
function Dm() {
  if (Pn) return Zi;
  Pn = 1, Object.defineProperty(Zi, "__esModule", { value: !0 });
  const i = oA(), A = sA(), t = {
    keyword: "unevaluatedItems",
    type: "array",
    schemaType: ["boolean", "object"],
    error: {
      message: ({ params: { len: o } }) => (0, i.str)`must NOT have more than ${o} items`,
      params: ({ params: { len: o } }) => (0, i._)`{limit: ${o}}`
    },
    code(o) {
      const { gen: r, schema: s, data: g, it: n } = o, a = n.items || 0;
      if (a === !0)
        return;
      const I = r.const("len", (0, i._)`${g}.length`);
      if (s === !1)
        o.setParams({ len: a }), o.fail((0, i._)`${I} > ${a}`);
      else if (typeof s == "object" && !(0, A.alwaysValidSchema)(n, s)) {
        const c = r.var("valid", (0, i._)`${I} <= ${a}`);
        r.if((0, i.not)(c), () => C(c, a)), o.ok(c);
      }
      n.items = !0;
      function C(c, B) {
        r.forRange("i", B, I, (Q) => {
          o.subschema({ keyword: "unevaluatedItems", dataProp: Q, dataPropType: A.Type.Num }, c), n.allErrors || r.if((0, i.not)(c), () => r.break());
        });
      }
    }
  };
  return Zi.default = t, Zi;
}
var jn;
function mm() {
  if (jn) return Wi;
  jn = 1, Object.defineProperty(Wi, "__esModule", { value: !0 });
  const i = ym(), A = Dm(), e = [i.default, A.default];
  return Wi.default = e, Wi;
}
var _i = {}, $i = {}, Vn;
function Sm() {
  if (Vn) return $i;
  Vn = 1, Object.defineProperty($i, "__esModule", { value: !0 });
  const i = oA(), e = {
    keyword: "format",
    type: ["number", "string"],
    schemaType: "string",
    $data: !0,
    error: {
      message: ({ schemaCode: t }) => (0, i.str)`must match format "${t}"`,
      params: ({ schemaCode: t }) => (0, i._)`{format: ${t}}`
    },
    code(t, o) {
      const { gen: r, data: s, $data: g, schema: n, schemaCode: a, it: I } = t, { opts: C, errSchemaPath: c, schemaEnv: B, self: Q } = I;
      if (!C.validateFormats)
        return;
      g ? f() : l();
      function f() {
        const d = r.scopeValue("formats", {
          ref: Q.formats,
          code: C.code.formats
        }), u = r.const("fDef", (0, i._)`${d}[${a}]`), h = r.let("fType"), w = r.let("format");
        r.if((0, i._)`typeof ${u} == "object" && !(${u} instanceof RegExp)`, () => r.assign(h, (0, i._)`${u}.type || "string"`).assign(w, (0, i._)`${u}.validate`), () => r.assign(h, (0, i._)`"string"`).assign(w, u)), t.fail$data((0, i.or)(E(), p()));
        function E() {
          return C.strictSchema === !1 ? i.nil : (0, i._)`${a} && !${w}`;
        }
        function p() {
          const y = B.$async ? (0, i._)`(${u}.async ? await ${w}(${s}) : ${w}(${s}))` : (0, i._)`${w}(${s})`, m = (0, i._)`(typeof ${w} == "function" ? ${y} : ${w}.test(${s}))`;
          return (0, i._)`${w} && ${w} !== true && ${h} === ${o} && !${m}`;
        }
      }
      function l() {
        const d = Q.formats[n];
        if (!d) {
          E();
          return;
        }
        if (d === !0)
          return;
        const [u, h, w] = p(d);
        u === o && t.pass(y());
        function E() {
          if (C.strictSchema === !1) {
            Q.logger.warn(m());
            return;
          }
          throw new Error(m());
          function m() {
            return `unknown format "${n}" ignored in schema at path "${c}"`;
          }
        }
        function p(m) {
          const N = m instanceof RegExp ? (0, i.regexpCode)(m) : C.code.formats ? (0, i._)`${C.code.formats}${(0, i.getProperty)(n)}` : void 0, R = r.scopeValue("formats", { key: n, ref: m, code: N });
          return typeof m == "object" && !(m instanceof RegExp) ? [m.type || "string", m.validate, (0, i._)`${R}.validate`] : ["string", m, R];
        }
        function y() {
          if (typeof d == "object" && !(d instanceof RegExp) && d.async) {
            if (!B.$async)
              throw new Error("async format in sync schema");
            return (0, i._)`await ${w}(${s})`;
          }
          return typeof h == "function" ? (0, i._)`${w}(${s})` : (0, i._)`${w}.test(${s})`;
        }
      }
    }
  };
  return $i.default = e, $i;
}
var Wn;
function _I() {
  if (Wn) return _i;
  Wn = 1, Object.defineProperty(_i, "__esModule", { value: !0 });
  const A = [Sm().default];
  return _i.default = A, _i;
}
var we = {}, zn;
function $I() {
  return zn || (zn = 1, Object.defineProperty(we, "__esModule", { value: !0 }), we.contentVocabulary = we.metadataVocabulary = void 0, we.metadataVocabulary = [
    "title",
    "description",
    "default",
    "deprecated",
    "readOnly",
    "writeOnly",
    "examples"
  ], we.contentVocabulary = [
    "contentMediaType",
    "contentEncoding",
    "contentSchema"
  ]), we;
}
var Zn;
function Nm() {
  if (Zn) return Ci;
  Zn = 1, Object.defineProperty(Ci, "__esModule", { value: !0 });
  const i = OI(), A = TI(), e = WI(), t = dm(), o = pm(), r = mm(), s = _I(), g = $I(), n = [
    t.default,
    i.default,
    A.default,
    (0, e.default)(!0),
    s.default,
    g.metadataVocabulary,
    g.contentVocabulary,
    o.default,
    r.default
  ];
  return Ci.default = n, Ci;
}
var Xi = {}, ft = {}, _n;
function Mm() {
  if (_n) return ft;
  _n = 1, Object.defineProperty(ft, "__esModule", { value: !0 }), ft.DiscrError = void 0;
  var i;
  return (function(A) {
    A.Tag = "tag", A.Mapping = "mapping";
  })(i || (ft.DiscrError = i = {})), ft;
}
var $n;
function XI() {
  if ($n) return Xi;
  $n = 1, Object.defineProperty(Xi, "__esModule", { value: !0 });
  const i = oA(), A = Mm(), e = Uo(), t = $t(), o = sA(), s = {
    keyword: "discriminator",
    type: "object",
    schemaType: "object",
    error: {
      message: ({ params: { discrError: g, tagName: n } }) => g === A.DiscrError.Tag ? `tag "${n}" must be string` : `value of tag "${n}" must be in oneOf`,
      params: ({ params: { discrError: g, tag: n, tagName: a } }) => (0, i._)`{error: ${g}, tag: ${a}, tagValue: ${n}}`
    },
    code(g) {
      const { gen: n, data: a, schema: I, parentSchema: C, it: c } = g, { oneOf: B } = C;
      if (!c.opts.discriminator)
        throw new Error("discriminator: requires discriminator option");
      const Q = I.propertyName;
      if (typeof Q != "string")
        throw new Error("discriminator: requires propertyName");
      if (I.mapping)
        throw new Error("discriminator: mapping is not supported");
      if (!B)
        throw new Error("discriminator: requires oneOf keyword");
      const f = n.let("valid", !1), l = n.const("tag", (0, i._)`${a}${(0, i.getProperty)(Q)}`);
      n.if((0, i._)`typeof ${l} == "string"`, () => d(), () => g.error(!1, { discrError: A.DiscrError.Tag, tag: l, tagName: Q })), g.ok(f);
      function d() {
        const w = h();
        n.if(!1);
        for (const E in w)
          n.elseIf((0, i._)`${l} === ${E}`), n.assign(f, u(w[E]));
        n.else(), g.error(!1, { discrError: A.DiscrError.Mapping, tag: l, tagName: Q }), n.endIf();
      }
      function u(w) {
        const E = n.name("valid"), p = g.subschema({ keyword: "oneOf", schemaProp: w }, E);
        return g.mergeEvaluated(p, i.Name), E;
      }
      function h() {
        var w;
        const E = {}, p = m(C);
        let y = !0;
        for (let L = 0; L < B.length; L++) {
          let j = B[L];
          if (j?.$ref && !(0, o.schemaHasRulesButRef)(j, c.self.RULES)) {
            const z = j.$ref;
            if (j = e.resolveRef.call(c.self, c.schemaEnv.root, c.baseId, z), j instanceof e.SchemaEnv && (j = j.schema), j === void 0)
              throw new t.default(c.opts.uriResolver, c.baseId, z);
          }
          const J = (w = j?.properties) === null || w === void 0 ? void 0 : w[Q];
          if (typeof J != "object")
            throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${Q}"`);
          y = y && (p || m(j)), N(J, L);
        }
        if (!y)
          throw new Error(`discriminator: "${Q}" must be required`);
        return E;
        function m({ required: L }) {
          return Array.isArray(L) && L.includes(Q);
        }
        function N(L, j) {
          if (L.const)
            R(L.const, j);
          else if (L.enum)
            for (const J of L.enum)
              R(J, j);
          else
            throw new Error(`discriminator: "properties/${Q}" must have "const" or "enum"`);
        }
        function R(L, j) {
          if (typeof L != "string" || L in E)
            throw new Error(`discriminator: "${Q}" values must be unique strings`);
          E[L] = j;
        }
      }
    }
  };
  return Xi.default = s, Xi;
}
var Ao = {};
const km = "https://json-schema.org/draft/2020-12/schema", Gm = "https://json-schema.org/draft/2020-12/schema", Fm = { "https://json-schema.org/draft/2020-12/vocab/core": !0, "https://json-schema.org/draft/2020-12/vocab/applicator": !0, "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0, "https://json-schema.org/draft/2020-12/vocab/validation": !0, "https://json-schema.org/draft/2020-12/vocab/meta-data": !0, "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0, "https://json-schema.org/draft/2020-12/vocab/content": !0 }, Rm = "meta", bm = "Core and Validation specifications meta-schema", Km = [{ $ref: "meta/core" }, { $ref: "meta/applicator" }, { $ref: "meta/unevaluated" }, { $ref: "meta/validation" }, { $ref: "meta/meta-data" }, { $ref: "meta/format-annotation" }, { $ref: "meta/content" }], Ym = ["object", "boolean"], Um = "This meta-schema also defines keywords that have appeared in previous drafts in order to prevent incompatible extensions as they remain in common use.", vm = { definitions: { $comment: '"definitions" has been replaced by "$defs".', type: "object", additionalProperties: { $dynamicRef: "#meta" }, deprecated: !0, default: {} }, dependencies: { $comment: '"dependencies" has been split and replaced by "dependentSchemas" and "dependentRequired" in order to serve their differing semantics.', type: "object", additionalProperties: { anyOf: [{ $dynamicRef: "#meta" }, { $ref: "meta/validation#/$defs/stringArray" }] }, deprecated: !0, default: {} }, $recursiveAnchor: { $comment: '"$recursiveAnchor" has been replaced by "$dynamicAnchor".', $ref: "meta/core#/$defs/anchorString", deprecated: !0 }, $recursiveRef: { $comment: '"$recursiveRef" has been replaced by "$dynamicRef".', $ref: "meta/core#/$defs/uriReferenceString", deprecated: !0 } }, Jm = {
  $schema: km,
  $id: Gm,
  $vocabulary: Fm,
  $dynamicAnchor: Rm,
  title: bm,
  allOf: Km,
  type: Ym,
  $comment: Um,
  properties: vm
}, Hm = "https://json-schema.org/draft/2020-12/schema", qm = "https://json-schema.org/draft/2020-12/meta/applicator", Lm = { "https://json-schema.org/draft/2020-12/vocab/applicator": !0 }, xm = "meta", Om = "Applicator vocabulary meta-schema", Tm = ["object", "boolean"], Pm = { prefixItems: { $ref: "#/$defs/schemaArray" }, items: { $dynamicRef: "#meta" }, contains: { $dynamicRef: "#meta" }, additionalProperties: { $dynamicRef: "#meta" }, properties: { type: "object", additionalProperties: { $dynamicRef: "#meta" }, default: {} }, patternProperties: { type: "object", additionalProperties: { $dynamicRef: "#meta" }, propertyNames: { format: "regex" }, default: {} }, dependentSchemas: { type: "object", additionalProperties: { $dynamicRef: "#meta" }, default: {} }, propertyNames: { $dynamicRef: "#meta" }, if: { $dynamicRef: "#meta" }, then: { $dynamicRef: "#meta" }, else: { $dynamicRef: "#meta" }, allOf: { $ref: "#/$defs/schemaArray" }, anyOf: { $ref: "#/$defs/schemaArray" }, oneOf: { $ref: "#/$defs/schemaArray" }, not: { $dynamicRef: "#meta" } }, jm = { schemaArray: { type: "array", minItems: 1, items: { $dynamicRef: "#meta" } } }, Vm = {
  $schema: Hm,
  $id: qm,
  $vocabulary: Lm,
  $dynamicAnchor: xm,
  title: Om,
  type: Tm,
  properties: Pm,
  $defs: jm
}, Wm = "https://json-schema.org/draft/2020-12/schema", zm = "https://json-schema.org/draft/2020-12/meta/unevaluated", Zm = { "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0 }, _m = "meta", $m = "Unevaluated applicator vocabulary meta-schema", Xm = ["object", "boolean"], AS = { unevaluatedItems: { $dynamicRef: "#meta" }, unevaluatedProperties: { $dynamicRef: "#meta" } }, eS = {
  $schema: Wm,
  $id: zm,
  $vocabulary: Zm,
  $dynamicAnchor: _m,
  title: $m,
  type: Xm,
  properties: AS
}, tS = "https://json-schema.org/draft/2020-12/schema", iS = "https://json-schema.org/draft/2020-12/meta/content", oS = { "https://json-schema.org/draft/2020-12/vocab/content": !0 }, rS = "meta", sS = "Content vocabulary meta-schema", gS = ["object", "boolean"], nS = { contentEncoding: { type: "string" }, contentMediaType: { type: "string" }, contentSchema: { $dynamicRef: "#meta" } }, aS = {
  $schema: tS,
  $id: iS,
  $vocabulary: oS,
  $dynamicAnchor: rS,
  title: sS,
  type: gS,
  properties: nS
}, IS = "https://json-schema.org/draft/2020-12/schema", CS = "https://json-schema.org/draft/2020-12/meta/core", cS = { "https://json-schema.org/draft/2020-12/vocab/core": !0 }, BS = "meta", QS = "Core vocabulary meta-schema", ES = ["object", "boolean"], lS = { $id: { $ref: "#/$defs/uriReferenceString", $comment: "Non-empty fragments not allowed.", pattern: "^[^#]*#?$" }, $schema: { $ref: "#/$defs/uriString" }, $ref: { $ref: "#/$defs/uriReferenceString" }, $anchor: { $ref: "#/$defs/anchorString" }, $dynamicRef: { $ref: "#/$defs/uriReferenceString" }, $dynamicAnchor: { $ref: "#/$defs/anchorString" }, $vocabulary: { type: "object", propertyNames: { $ref: "#/$defs/uriString" }, additionalProperties: { type: "boolean" } }, $comment: { type: "string" }, $defs: { type: "object", additionalProperties: { $dynamicRef: "#meta" } } }, uS = { anchorString: { type: "string", pattern: "^[A-Za-z_][-A-Za-z0-9._]*$" }, uriString: { type: "string", format: "uri" }, uriReferenceString: { type: "string", format: "uri-reference" } }, dS = {
  $schema: IS,
  $id: CS,
  $vocabulary: cS,
  $dynamicAnchor: BS,
  title: QS,
  type: ES,
  properties: lS,
  $defs: uS
}, hS = "https://json-schema.org/draft/2020-12/schema", fS = "https://json-schema.org/draft/2020-12/meta/format-annotation", wS = { "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0 }, pS = "meta", yS = "Format vocabulary meta-schema for annotation results", DS = ["object", "boolean"], mS = { format: { type: "string" } }, SS = {
  $schema: hS,
  $id: fS,
  $vocabulary: wS,
  $dynamicAnchor: pS,
  title: yS,
  type: DS,
  properties: mS
}, NS = "https://json-schema.org/draft/2020-12/schema", MS = "https://json-schema.org/draft/2020-12/meta/meta-data", kS = { "https://json-schema.org/draft/2020-12/vocab/meta-data": !0 }, GS = "meta", FS = "Meta-data vocabulary meta-schema", RS = ["object", "boolean"], bS = { title: { type: "string" }, description: { type: "string" }, default: !0, deprecated: { type: "boolean", default: !1 }, readOnly: { type: "boolean", default: !1 }, writeOnly: { type: "boolean", default: !1 }, examples: { type: "array", items: !0 } }, KS = {
  $schema: NS,
  $id: MS,
  $vocabulary: kS,
  $dynamicAnchor: GS,
  title: FS,
  type: RS,
  properties: bS
}, YS = "https://json-schema.org/draft/2020-12/schema", US = "https://json-schema.org/draft/2020-12/meta/validation", vS = { "https://json-schema.org/draft/2020-12/vocab/validation": !0 }, JS = "meta", HS = "Validation vocabulary meta-schema", qS = ["object", "boolean"], LS = { type: { anyOf: [{ $ref: "#/$defs/simpleTypes" }, { type: "array", items: { $ref: "#/$defs/simpleTypes" }, minItems: 1, uniqueItems: !0 }] }, const: !0, enum: { type: "array", items: !0 }, multipleOf: { type: "number", exclusiveMinimum: 0 }, maximum: { type: "number" }, exclusiveMaximum: { type: "number" }, minimum: { type: "number" }, exclusiveMinimum: { type: "number" }, maxLength: { $ref: "#/$defs/nonNegativeInteger" }, minLength: { $ref: "#/$defs/nonNegativeIntegerDefault0" }, pattern: { type: "string", format: "regex" }, maxItems: { $ref: "#/$defs/nonNegativeInteger" }, minItems: { $ref: "#/$defs/nonNegativeIntegerDefault0" }, uniqueItems: { type: "boolean", default: !1 }, maxContains: { $ref: "#/$defs/nonNegativeInteger" }, minContains: { $ref: "#/$defs/nonNegativeInteger", default: 1 }, maxProperties: { $ref: "#/$defs/nonNegativeInteger" }, minProperties: { $ref: "#/$defs/nonNegativeIntegerDefault0" }, required: { $ref: "#/$defs/stringArray" }, dependentRequired: { type: "object", additionalProperties: { $ref: "#/$defs/stringArray" } } }, xS = { nonNegativeInteger: { type: "integer", minimum: 0 }, nonNegativeIntegerDefault0: { $ref: "#/$defs/nonNegativeInteger", default: 0 }, simpleTypes: { enum: ["array", "boolean", "integer", "null", "number", "object", "string"] }, stringArray: { type: "array", items: { type: "string" }, uniqueItems: !0, default: [] } }, OS = {
  $schema: YS,
  $id: US,
  $vocabulary: vS,
  $dynamicAnchor: JS,
  title: HS,
  type: qS,
  properties: LS,
  $defs: xS
};
var Xn;
function TS() {
  if (Xn) return Ao;
  Xn = 1, Object.defineProperty(Ao, "__esModule", { value: !0 });
  const i = Jm, A = Vm, e = eS, t = aS, o = dS, r = SS, s = KS, g = OS, n = ["/properties"];
  function a(I) {
    return [
      i,
      A,
      e,
      t,
      o,
      C(this, r),
      s,
      C(this, g)
    ].forEach((c) => this.addMetaSchema(c, void 0, !1)), this;
    function C(c, B) {
      return I ? c.$dataMetaSchema(B, n) : B;
    }
  }
  return Ao.default = a, Ao;
}
var Aa;
function PS() {
  return Aa || (Aa = 1, (function(i, A) {
    Object.defineProperty(A, "__esModule", { value: !0 }), A.MissingRefError = A.ValidationError = A.CodeGen = A.Name = A.nil = A.stringify = A.str = A._ = A.KeywordCxt = A.Ajv2020 = void 0;
    const e = xI(), t = Nm(), o = XI(), r = TS(), s = "https://json-schema.org/draft/2020-12/schema";
    class g extends e.default {
      constructor(B = {}) {
        super({
          ...B,
          dynamicRef: !0,
          next: !0,
          unevaluated: !0
        });
      }
      _addVocabularies() {
        super._addVocabularies(), t.default.forEach((B) => this.addVocabulary(B)), this.opts.discriminator && this.addKeyword(o.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        const { $data: B, meta: Q } = this.opts;
        Q && (r.default.call(this, B), this.refs["http://json-schema.org/schema"] = s);
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(s) ? s : void 0);
      }
    }
    A.Ajv2020 = g, i.exports = A = g, i.exports.Ajv2020 = g, Object.defineProperty(A, "__esModule", { value: !0 }), A.default = g;
    var n = _t();
    Object.defineProperty(A, "KeywordCxt", { enumerable: !0, get: function() {
      return n.KeywordCxt;
    } });
    var a = oA();
    Object.defineProperty(A, "_", { enumerable: !0, get: function() {
      return a._;
    } }), Object.defineProperty(A, "str", { enumerable: !0, get: function() {
      return a.str;
    } }), Object.defineProperty(A, "stringify", { enumerable: !0, get: function() {
      return a.stringify;
    } }), Object.defineProperty(A, "nil", { enumerable: !0, get: function() {
      return a.nil;
    } }), Object.defineProperty(A, "Name", { enumerable: !0, get: function() {
      return a.Name;
    } }), Object.defineProperty(A, "CodeGen", { enumerable: !0, get: function() {
      return a.CodeGen;
    } });
    var I = Yo();
    Object.defineProperty(A, "ValidationError", { enumerable: !0, get: function() {
      return I.default;
    } });
    var C = $t();
    Object.defineProperty(A, "MissingRefError", { enumerable: !0, get: function() {
      return C.default;
    } });
  })(si, si.exports)), si.exports;
}
var AC = PS();
const jS = /* @__PURE__ */ vI(AC), VS = /* @__PURE__ */ tC({
  __proto__: null,
  default: jS
}, [AC]);
var eo = { exports: {} }, to = {}, ea;
function WS() {
  if (ea) return to;
  ea = 1, Object.defineProperty(to, "__esModule", { value: !0 });
  const i = OI(), A = TI(), e = WI(), t = _I(), o = $I(), r = [
    i.default,
    A.default,
    (0, e.default)(),
    t.default,
    o.metadataVocabulary,
    o.contentVocabulary
  ];
  return to.default = r, to;
}
const zS = "http://json-schema.org/draft-07/schema#", ZS = "http://json-schema.org/draft-07/schema#", _S = "Core schema meta-schema", $S = { schemaArray: { type: "array", minItems: 1, items: { $ref: "#" } }, nonNegativeInteger: { type: "integer", minimum: 0 }, nonNegativeIntegerDefault0: { allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }] }, simpleTypes: { enum: ["array", "boolean", "integer", "null", "number", "object", "string"] }, stringArray: { type: "array", items: { type: "string" }, uniqueItems: !0, default: [] } }, XS = ["object", "boolean"], AN = { $id: { type: "string", format: "uri-reference" }, $schema: { type: "string", format: "uri" }, $ref: { type: "string", format: "uri-reference" }, $comment: { type: "string" }, title: { type: "string" }, description: { type: "string" }, default: !0, readOnly: { type: "boolean", default: !1 }, examples: { type: "array", items: !0 }, multipleOf: { type: "number", exclusiveMinimum: 0 }, maximum: { type: "number" }, exclusiveMaximum: { type: "number" }, minimum: { type: "number" }, exclusiveMinimum: { type: "number" }, maxLength: { $ref: "#/definitions/nonNegativeInteger" }, minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, pattern: { type: "string", format: "regex" }, additionalItems: { $ref: "#" }, items: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }], default: !0 }, maxItems: { $ref: "#/definitions/nonNegativeInteger" }, minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, uniqueItems: { type: "boolean", default: !1 }, contains: { $ref: "#" }, maxProperties: { $ref: "#/definitions/nonNegativeInteger" }, minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, required: { $ref: "#/definitions/stringArray" }, additionalProperties: { $ref: "#" }, definitions: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, properties: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, patternProperties: { type: "object", additionalProperties: { $ref: "#" }, propertyNames: { format: "regex" }, default: {} }, dependencies: { type: "object", additionalProperties: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }] } }, propertyNames: { $ref: "#" }, const: !0, enum: { type: "array", items: !0, minItems: 1, uniqueItems: !0 }, type: { anyOf: [{ $ref: "#/definitions/simpleTypes" }, { type: "array", items: { $ref: "#/definitions/simpleTypes" }, minItems: 1, uniqueItems: !0 }] }, format: { type: "string" }, contentMediaType: { type: "string" }, contentEncoding: { type: "string" }, if: { $ref: "#" }, then: { $ref: "#" }, else: { $ref: "#" }, allOf: { $ref: "#/definitions/schemaArray" }, anyOf: { $ref: "#/definitions/schemaArray" }, oneOf: { $ref: "#/definitions/schemaArray" }, not: { $ref: "#" } }, eN = {
  $schema: zS,
  $id: ZS,
  title: _S,
  definitions: $S,
  type: XS,
  properties: AN,
  default: !0
};
var ta;
function tN() {
  return ta || (ta = 1, (function(i, A) {
    Object.defineProperty(A, "__esModule", { value: !0 }), A.MissingRefError = A.ValidationError = A.CodeGen = A.Name = A.nil = A.stringify = A.str = A._ = A.KeywordCxt = A.Ajv = void 0;
    const e = xI(), t = WS(), o = XI(), r = eN, s = ["/properties"], g = "http://json-schema.org/draft-07/schema";
    class n extends e.default {
      _addVocabularies() {
        super._addVocabularies(), t.default.forEach((Q) => this.addVocabulary(Q)), this.opts.discriminator && this.addKeyword(o.default);
      }
      _addDefaultMetaSchema() {
        if (super._addDefaultMetaSchema(), !this.opts.meta)
          return;
        const Q = this.opts.$data ? this.$dataMetaSchema(r, s) : r;
        this.addMetaSchema(Q, g, !1), this.refs["http://json-schema.org/schema"] = g;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(g) ? g : void 0);
      }
    }
    A.Ajv = n, i.exports = A = n, i.exports.Ajv = n, Object.defineProperty(A, "__esModule", { value: !0 }), A.default = n;
    var a = _t();
    Object.defineProperty(A, "KeywordCxt", { enumerable: !0, get: function() {
      return a.KeywordCxt;
    } });
    var I = oA();
    Object.defineProperty(A, "_", { enumerable: !0, get: function() {
      return I._;
    } }), Object.defineProperty(A, "str", { enumerable: !0, get: function() {
      return I.str;
    } }), Object.defineProperty(A, "stringify", { enumerable: !0, get: function() {
      return I.stringify;
    } }), Object.defineProperty(A, "nil", { enumerable: !0, get: function() {
      return I.nil;
    } }), Object.defineProperty(A, "Name", { enumerable: !0, get: function() {
      return I.Name;
    } }), Object.defineProperty(A, "CodeGen", { enumerable: !0, get: function() {
      return I.CodeGen;
    } });
    var C = Yo();
    Object.defineProperty(A, "ValidationError", { enumerable: !0, get: function() {
      return C.default;
    } });
    var c = $t();
    Object.defineProperty(A, "MissingRefError", { enumerable: !0, get: function() {
      return c.default;
    } });
  })(eo, eo.exports)), eo.exports;
}
var iN = tN();
const oN = /* @__PURE__ */ vI(iN), rN = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: oN
}, Symbol.toStringTag, { value: "Module" })), sN = {}, ia = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: sN
}, Symbol.toStringTag, { value: "Module" })), gN = [
  ["./todos/registry.js", "TodosVibeRegistry"],
  ["./chat/registry.js", "ChatVibeRegistry"],
  ["./db/registry.js", "DbVibeRegistry"],
  ["./sparks/registry.js", "SparksVibeRegistry"],
  ["./creator/registry.js", "CreatorVibeRegistry"]
];
async function nN() {
  const i = [];
  for (const [A, e] of gN)
    try {
      const o = (await import(A))[e];
      o?.vibe && i.push(o);
    } catch (t) {
      console.warn(`[Vibes] Could not load ${e}:`, t.message);
    }
  return i;
}
function aN(i) {
  if (!i) return null;
  const A = i.$id || "";
  return A.startsWith("@maia/vibe/") ? A.replace("@maia/vibe/", "") : (i.name || "default").toLowerCase().replace(/\s+/g, "-");
}
function IN(i, A = null) {
  if (A == null || Array.isArray(A) && A.length === 0)
    return [];
  if (A === "all")
    return i;
  if (Array.isArray(A)) {
    const e = A.map((t) => t.toLowerCase().trim());
    return i.filter((t) => {
      if (!t.vibe) return !1;
      const o = aN(t.vibe);
      return e.includes(o);
    });
  }
  return console.warn(`[Vibes] Invalid seeding config: ${A}. Expected null, "all", or array of vibe keys.`), [];
}
const CN = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  MaiaOS: ge,
  filterVibesForSeeding: IN,
  getAllVibeRegistries: nN
}, Symbol.toStringTag, { value: "Module" }));
export {
  ge as MaiaOS,
  pA as ReactiveStore,
  YI as createAgentAccount,
  Ry as createCoJSONAPI,
  MD as generateAgentCredentials,
  yo as getAllSchemas,
  _a as getSchema,
  cs as getSchemaIndexColistId,
  FI as isPRFSupported,
  UI as loadAgentAccount,
  kD as loadOrCreateAgentAccount,
  zt as setupSyncPeers,
  ND as signInWithPasskey,
  SD as signUpWithPasskey,
  Wy as subscribeSyncState
};
