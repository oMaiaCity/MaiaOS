function aI(i, A) {
  for (var e = 0; e < A.length; e++) {
    const t = A[e];
    if (typeof t != "string" && !Array.isArray(t)) {
      for (const o in t)
        if (o !== "default" && !(o in i)) {
          const g = Object.getOwnPropertyDescriptor(t, o);
          g && Object.defineProperty(i, o, g.get ? g : {
            enumerable: !0,
            get: () => t[o]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(i, Symbol.toStringTag, { value: "Module" }));
}
const II = new TextEncoder(), CI = new TextDecoder();
function Oo(i) {
  i = i.replace(/=/g, "");
  const A = i.length, e = A % 4, t = e && e - 1, o = (A >> 2) * 3 + t, g = new Uint8Array(A + 3);
  II.encodeInto(i + "===", g);
  for (let r = 0, n = 0; r < A; r += 4, n += 3) {
    const s = (Te[g[r]] << 18) + (Te[g[r + 1]] << 12) + (Te[g[r + 2]] << 6) + Te[g[r + 3]];
    g[n] = s >> 16, g[n + 1] = s >> 8 & 255, g[n + 2] = s & 255;
  }
  return new Uint8Array(g.buffer, 0, o);
}
function Po(i) {
  const A = i.length, e = A % 3, t = Math.floor(A / 3) * 4 + (e && e + 1), o = Math.ceil(A / 3) * 4, g = new Uint8Array(o);
  for (let n = 0, s = 0; s < A; n += 4, s += 3) {
    const a = (i[s] << 16) + (i[s + 1] << 8) + (i[s + 2] | 0);
    g[n] = at[a >> 18], g[n + 1] = at[a >> 12 & 63], g[n + 2] = at[a >> 6 & 63], g[n + 3] = at[a & 63];
  }
  let r = CI.decode(new Uint8Array(g.buffer, 0, t));
  return e === 1 && (r += "=="), e === 2 && (r += "="), r;
}
const us = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", Te = new Uint8Array(128);
for (const [i, A] of Array.from(us).entries())
  Te[A.charCodeAt(0)] = i;
Te[61] = 0;
const at = new Uint8Array(64);
for (const [i, A] of Array.from(us).entries())
  at[i] = A.charCodeAt(0);
var cI = typeof globalThis == "object" ? globalThis : typeof self == "object" ? self : typeof window == "object" ? window : typeof globalThis == "object" ? globalThis : {}, we = "1.9.0", sr = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
function BI(i) {
  var A = /* @__PURE__ */ new Set([i]), e = /* @__PURE__ */ new Set(), t = i.match(sr);
  if (!t)
    return function() {
      return !1;
    };
  var o = {
    major: +t[1],
    minor: +t[2],
    patch: +t[3],
    prerelease: t[4]
  };
  if (o.prerelease != null)
    return function(s) {
      return s === i;
    };
  function g(n) {
    return e.add(n), !1;
  }
  function r(n) {
    return A.add(n), !0;
  }
  return function(s) {
    if (A.has(s))
      return !0;
    if (e.has(s))
      return !1;
    var a = s.match(sr);
    if (!a)
      return g(s);
    var I = {
      major: +a[1],
      minor: +a[2],
      patch: +a[3],
      prerelease: a[4]
    };
    return I.prerelease != null || o.major !== I.major ? g(s) : o.major === 0 ? o.minor === I.minor && o.patch <= I.patch ? r(s) : g(s) : o.minor <= I.minor ? r(s) : g(s);
  };
}
var QI = BI(we), EI = we.split(".")[0], wt = /* @__PURE__ */ Symbol.for("opentelemetry.js.api." + EI), yt = cI;
function Mt(i, A, e, t) {
  var o;
  t === void 0 && (t = !1);
  var g = yt[wt] = (o = yt[wt]) !== null && o !== void 0 ? o : {
    version: we
  };
  if (!t && g[i]) {
    var r = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + i);
    return e.error(r.stack || r.message), !1;
  }
  if (g.version !== we) {
    var r = new Error("@opentelemetry/api: Registration of version v" + g.version + " for " + i + " does not match previously registered API v" + we);
    return e.error(r.stack || r.message), !1;
  }
  return g[i] = A, e.debug("@opentelemetry/api: Registered a global for " + i + " v" + we + "."), !0;
}
function Se(i) {
  var A, e, t = (A = yt[wt]) === null || A === void 0 ? void 0 : A.version;
  if (!(!t || !QI(t)))
    return (e = yt[wt]) === null || e === void 0 ? void 0 : e[i];
}
function Gt(i, A) {
  A.debug("@opentelemetry/api: Unregistering a global for " + i + " v" + we + ".");
  var e = yt[wt];
  e && delete e[i];
}
var lI = function(i, A) {
  var e = typeof Symbol == "function" && i[Symbol.iterator];
  if (!e) return i;
  var t = e.call(i), o, g = [], r;
  try {
    for (; (A === void 0 || A-- > 0) && !(o = t.next()).done; ) g.push(o.value);
  } catch (n) {
    r = { error: n };
  } finally {
    try {
      o && !o.done && (e = t.return) && e.call(t);
    } finally {
      if (r) throw r.error;
    }
  }
  return g;
}, dI = function(i, A, e) {
  if (arguments.length === 2) for (var t = 0, o = A.length, g; t < o; t++)
    (g || !(t in A)) && (g || (g = Array.prototype.slice.call(A, 0, t)), g[t] = A[t]);
  return i.concat(g || Array.prototype.slice.call(A));
}, hI = (
  /** @class */
  (function() {
    function i(A) {
      this._namespace = A.namespace || "DiagComponentLogger";
    }
    return i.prototype.debug = function() {
      for (var A = [], e = 0; e < arguments.length; e++)
        A[e] = arguments[e];
      return et("debug", this._namespace, A);
    }, i.prototype.error = function() {
      for (var A = [], e = 0; e < arguments.length; e++)
        A[e] = arguments[e];
      return et("error", this._namespace, A);
    }, i.prototype.info = function() {
      for (var A = [], e = 0; e < arguments.length; e++)
        A[e] = arguments[e];
      return et("info", this._namespace, A);
    }, i.prototype.warn = function() {
      for (var A = [], e = 0; e < arguments.length; e++)
        A[e] = arguments[e];
      return et("warn", this._namespace, A);
    }, i.prototype.verbose = function() {
      for (var A = [], e = 0; e < arguments.length; e++)
        A[e] = arguments[e];
      return et("verbose", this._namespace, A);
    }, i;
  })()
);
function et(i, A, e) {
  var t = Se("diag");
  if (t)
    return e.unshift(A), t[i].apply(t, dI([], lI(e), !1));
}
var MA;
(function(i) {
  i[i.NONE = 0] = "NONE", i[i.ERROR = 30] = "ERROR", i[i.WARN = 50] = "WARN", i[i.INFO = 60] = "INFO", i[i.DEBUG = 70] = "DEBUG", i[i.VERBOSE = 80] = "VERBOSE", i[i.ALL = 9999] = "ALL";
})(MA || (MA = {}));
function uI(i, A) {
  i < MA.NONE ? i = MA.NONE : i > MA.ALL && (i = MA.ALL), A = A || {};
  function e(t, o) {
    var g = A[t];
    return typeof g == "function" && i >= o ? g.bind(A) : function() {
    };
  }
  return {
    error: e("error", MA.ERROR),
    warn: e("warn", MA.WARN),
    info: e("info", MA.INFO),
    debug: e("debug", MA.DEBUG),
    verbose: e("verbose", MA.VERBOSE)
  };
}
var fI = function(i, A) {
  var e = typeof Symbol == "function" && i[Symbol.iterator];
  if (!e) return i;
  var t = e.call(i), o, g = [], r;
  try {
    for (; (A === void 0 || A-- > 0) && !(o = t.next()).done; ) g.push(o.value);
  } catch (n) {
    r = { error: n };
  } finally {
    try {
      o && !o.done && (e = t.return) && e.call(t);
    } finally {
      if (r) throw r.error;
    }
  }
  return g;
}, wI = function(i, A, e) {
  if (arguments.length === 2) for (var t = 0, o = A.length, g; t < o; t++)
    (g || !(t in A)) && (g || (g = Array.prototype.slice.call(A, 0, t)), g[t] = A[t]);
  return i.concat(g || Array.prototype.slice.call(A));
}, yI = "diag", jA = (
  /** @class */
  (function() {
    function i() {
      function A(o) {
        return function() {
          for (var g = [], r = 0; r < arguments.length; r++)
            g[r] = arguments[r];
          var n = Se("diag");
          if (n)
            return n[o].apply(n, wI([], fI(g), !1));
        };
      }
      var e = this, t = function(o, g) {
        var r, n, s;
        if (g === void 0 && (g = { logLevel: MA.INFO }), o === e) {
          var a = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
          return e.error((r = a.stack) !== null && r !== void 0 ? r : a.message), !1;
        }
        typeof g == "number" && (g = {
          logLevel: g
        });
        var I = Se("diag"), C = uI((n = g.logLevel) !== null && n !== void 0 ? n : MA.INFO, o);
        if (I && !g.suppressOverrideMessage) {
          var c = (s = new Error().stack) !== null && s !== void 0 ? s : "<failed to generate stacktrace>";
          I.warn("Current logger will be overwritten from " + c), C.warn("Current logger will overwrite one already registered from " + c);
        }
        return Mt("diag", C, e, !0);
      };
      e.setLogger = t, e.disable = function() {
        Gt(yI, e);
      }, e.createComponentLogger = function(o) {
        return new hI(o);
      }, e.verbose = A("verbose"), e.debug = A("debug"), e.info = A("info"), e.warn = A("warn"), e.error = A("error");
    }
    return i.instance = function() {
      return this._instance || (this._instance = new i()), this._instance;
    }, i;
  })()
), pI = function(i, A) {
  var e = typeof Symbol == "function" && i[Symbol.iterator];
  if (!e) return i;
  var t = e.call(i), o, g = [], r;
  try {
    for (; (A === void 0 || A-- > 0) && !(o = t.next()).done; ) g.push(o.value);
  } catch (n) {
    r = { error: n };
  } finally {
    try {
      o && !o.done && (e = t.return) && e.call(t);
    } finally {
      if (r) throw r.error;
    }
  }
  return g;
}, DI = function(i) {
  var A = typeof Symbol == "function" && Symbol.iterator, e = A && i[A], t = 0;
  if (e) return e.call(i);
  if (i && typeof i.length == "number") return {
    next: function() {
      return i && t >= i.length && (i = void 0), { value: i && i[t++], done: !i };
    }
  };
  throw new TypeError(A ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, mI = (
  /** @class */
  (function() {
    function i(A) {
      this._entries = A ? new Map(A) : /* @__PURE__ */ new Map();
    }
    return i.prototype.getEntry = function(A) {
      var e = this._entries.get(A);
      if (e)
        return Object.assign({}, e);
    }, i.prototype.getAllEntries = function() {
      return Array.from(this._entries.entries()).map(function(A) {
        var e = pI(A, 2), t = e[0], o = e[1];
        return [t, o];
      });
    }, i.prototype.setEntry = function(A, e) {
      var t = new i(this._entries);
      return t._entries.set(A, e), t;
    }, i.prototype.removeEntry = function(A) {
      var e = new i(this._entries);
      return e._entries.delete(A), e;
    }, i.prototype.removeEntries = function() {
      for (var A, e, t = [], o = 0; o < arguments.length; o++)
        t[o] = arguments[o];
      var g = new i(this._entries);
      try {
        for (var r = DI(t), n = r.next(); !n.done; n = r.next()) {
          var s = n.value;
          g._entries.delete(s);
        }
      } catch (a) {
        A = { error: a };
      } finally {
        try {
          n && !n.done && (e = r.return) && e.call(r);
        } finally {
          if (A) throw A.error;
        }
      }
      return g;
    }, i.prototype.clear = function() {
      return new i();
    }, i;
  })()
);
jA.instance();
function SI(i) {
  return i === void 0 && (i = {}), new mI(new Map(Object.entries(i)));
}
function fs(i) {
  return Symbol.for(i);
}
var NI = (
  /** @class */
  /* @__PURE__ */ (function() {
    function i(A) {
      var e = this;
      e._currentContext = A ? new Map(A) : /* @__PURE__ */ new Map(), e.getValue = function(t) {
        return e._currentContext.get(t);
      }, e.setValue = function(t, o) {
        var g = new i(e._currentContext);
        return g._currentContext.set(t, o), g;
      }, e.deleteValue = function(t) {
        var o = new i(e._currentContext);
        return o._currentContext.delete(t), o;
      };
    }
    return i;
  })()
), MI = new NI(), Ge = /* @__PURE__ */ (function() {
  var i = function(A, e) {
    return i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, o) {
      t.__proto__ = o;
    } || function(t, o) {
      for (var g in o) Object.prototype.hasOwnProperty.call(o, g) && (t[g] = o[g]);
    }, i(A, e);
  };
  return function(A, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
    i(A, e);
    function t() {
      this.constructor = A;
    }
    A.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
  };
})(), GI = (
  /** @class */
  (function() {
    function i() {
    }
    return i.prototype.createGauge = function(A, e) {
      return HI;
    }, i.prototype.createHistogram = function(A, e) {
      return qI;
    }, i.prototype.createCounter = function(A, e) {
      return JI;
    }, i.prototype.createUpDownCounter = function(A, e) {
      return LI;
    }, i.prototype.createObservableGauge = function(A, e) {
      return TI;
    }, i.prototype.createObservableCounter = function(A, e) {
      return xI;
    }, i.prototype.createObservableUpDownCounter = function(A, e) {
      return OI;
    }, i.prototype.addBatchObservableCallback = function(A, e) {
    }, i.prototype.removeBatchObservableCallback = function(A) {
    }, i;
  })()
), Xi = (
  /** @class */
  /* @__PURE__ */ (function() {
    function i() {
    }
    return i;
  })()
), kI = (
  /** @class */
  (function(i) {
    Ge(A, i);
    function A() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return A.prototype.add = function(e, t) {
    }, A;
  })(Xi)
), FI = (
  /** @class */
  (function(i) {
    Ge(A, i);
    function A() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return A.prototype.add = function(e, t) {
    }, A;
  })(Xi)
), RI = (
  /** @class */
  (function(i) {
    Ge(A, i);
    function A() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return A.prototype.record = function(e, t) {
    }, A;
  })(Xi)
), bI = (
  /** @class */
  (function(i) {
    Ge(A, i);
    function A() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return A.prototype.record = function(e, t) {
    }, A;
  })(Xi)
), ug = (
  /** @class */
  (function() {
    function i() {
    }
    return i.prototype.addCallback = function(A) {
    }, i.prototype.removeCallback = function(A) {
    }, i;
  })()
), KI = (
  /** @class */
  (function(i) {
    Ge(A, i);
    function A() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return A;
  })(ug)
), YI = (
  /** @class */
  (function(i) {
    Ge(A, i);
    function A() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return A;
  })(ug)
), vI = (
  /** @class */
  (function(i) {
    Ge(A, i);
    function A() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return A;
  })(ug)
), UI = new GI(), JI = new kI(), HI = new RI(), qI = new bI(), LI = new FI(), xI = new KI(), TI = new YI(), OI = new vI(), qA;
(function(i) {
  i[i.INT = 0] = "INT", i[i.DOUBLE = 1] = "DOUBLE";
})(qA || (qA = {}));
var PI = {
  get: function(i, A) {
    if (i != null)
      return i[A];
  },
  keys: function(i) {
    return i == null ? [] : Object.keys(i);
  }
}, jI = {
  set: function(i, A, e) {
    i != null && (i[A] = e);
  }
}, VI = function(i, A) {
  var e = typeof Symbol == "function" && i[Symbol.iterator];
  if (!e) return i;
  var t = e.call(i), o, g = [], r;
  try {
    for (; (A === void 0 || A-- > 0) && !(o = t.next()).done; ) g.push(o.value);
  } catch (n) {
    r = { error: n };
  } finally {
    try {
      o && !o.done && (e = t.return) && e.call(t);
    } finally {
      if (r) throw r.error;
    }
  }
  return g;
}, WI = function(i, A, e) {
  if (e || arguments.length === 2) for (var t = 0, o = A.length, g; t < o; t++)
    (g || !(t in A)) && (g || (g = Array.prototype.slice.call(A, 0, t)), g[t] = A[t]);
  return i.concat(g || Array.prototype.slice.call(A));
}, zI = (
  /** @class */
  (function() {
    function i() {
    }
    return i.prototype.active = function() {
      return MI;
    }, i.prototype.with = function(A, e, t) {
      for (var o = [], g = 3; g < arguments.length; g++)
        o[g - 3] = arguments[g];
      return e.call.apply(e, WI([t], VI(o), !1));
    }, i.prototype.bind = function(A, e) {
      return e;
    }, i.prototype.enable = function() {
      return this;
    }, i.prototype.disable = function() {
      return this;
    }, i;
  })()
), $I = function(i, A) {
  var e = typeof Symbol == "function" && i[Symbol.iterator];
  if (!e) return i;
  var t = e.call(i), o, g = [], r;
  try {
    for (; (A === void 0 || A-- > 0) && !(o = t.next()).done; ) g.push(o.value);
  } catch (n) {
    r = { error: n };
  } finally {
    try {
      o && !o.done && (e = t.return) && e.call(t);
    } finally {
      if (r) throw r.error;
    }
  }
  return g;
}, ZI = function(i, A, e) {
  if (arguments.length === 2) for (var t = 0, o = A.length, g; t < o; t++)
    (g || !(t in A)) && (g || (g = Array.prototype.slice.call(A, 0, t)), g[t] = A[t]);
  return i.concat(g || Array.prototype.slice.call(A));
}, Eo = "context", _I = new zI(), Ao = (
  /** @class */
  (function() {
    function i() {
    }
    return i.getInstance = function() {
      return this._instance || (this._instance = new i()), this._instance;
    }, i.prototype.setGlobalContextManager = function(A) {
      return Mt(Eo, A, jA.instance());
    }, i.prototype.active = function() {
      return this._getContextManager().active();
    }, i.prototype.with = function(A, e, t) {
      for (var o, g = [], r = 3; r < arguments.length; r++)
        g[r - 3] = arguments[r];
      return (o = this._getContextManager()).with.apply(o, ZI([A, e, t], $I(g), !1));
    }, i.prototype.bind = function(A, e) {
      return this._getContextManager().bind(A, e);
    }, i.prototype._getContextManager = function() {
      return Se(Eo) || _I;
    }, i.prototype.disable = function() {
      this._getContextManager().disable(), Gt(Eo, jA.instance());
    }, i;
  })()
), jo;
(function(i) {
  i[i.NONE = 0] = "NONE", i[i.SAMPLED = 1] = "SAMPLED";
})(jo || (jo = {}));
var ws = "0000000000000000", ys = "00000000000000000000000000000000", XI = {
  traceId: ys,
  spanId: ws,
  traceFlags: jo.NONE
}, lt = (
  /** @class */
  (function() {
    function i(A) {
      A === void 0 && (A = XI), this._spanContext = A;
    }
    return i.prototype.spanContext = function() {
      return this._spanContext;
    }, i.prototype.setAttribute = function(A, e) {
      return this;
    }, i.prototype.setAttributes = function(A) {
      return this;
    }, i.prototype.addEvent = function(A, e) {
      return this;
    }, i.prototype.addLink = function(A) {
      return this;
    }, i.prototype.addLinks = function(A) {
      return this;
    }, i.prototype.setStatus = function(A) {
      return this;
    }, i.prototype.updateName = function(A) {
      return this;
    }, i.prototype.end = function(A) {
    }, i.prototype.isRecording = function() {
      return !1;
    }, i.prototype.recordException = function(A, e) {
    }, i;
  })()
), fg = fs("OpenTelemetry Context Key SPAN");
function wg(i) {
  return i.getValue(fg) || void 0;
}
function AC() {
  return wg(Ao.getInstance().active());
}
function yg(i, A) {
  return i.setValue(fg, A);
}
function eC(i) {
  return i.deleteValue(fg);
}
function tC(i, A) {
  return yg(i, new lt(A));
}
function ps(i) {
  var A;
  return (A = wg(i)) === null || A === void 0 ? void 0 : A.spanContext();
}
var iC = /^([0-9a-f]{32})$/i, oC = /^[0-9a-f]{16}$/i;
function gC(i) {
  return iC.test(i) && i !== ys;
}
function rC(i) {
  return oC.test(i) && i !== ws;
}
function Ds(i) {
  return gC(i.traceId) && rC(i.spanId);
}
function nC(i) {
  return new lt(i);
}
var lo = Ao.getInstance(), ms = (
  /** @class */
  (function() {
    function i() {
    }
    return i.prototype.startSpan = function(A, e, t) {
      t === void 0 && (t = lo.active());
      var o = !!e?.root;
      if (o)
        return new lt();
      var g = t && ps(t);
      return sC(g) && Ds(g) ? new lt(g) : new lt();
    }, i.prototype.startActiveSpan = function(A, e, t, o) {
      var g, r, n;
      if (!(arguments.length < 2)) {
        arguments.length === 2 ? n = e : arguments.length === 3 ? (g = e, n = t) : (g = e, r = t, n = o);
        var s = r ?? lo.active(), a = this.startSpan(A, g, s), I = yg(s, a);
        return lo.with(I, n, void 0, a);
      }
    }, i;
  })()
);
function sC(i) {
  return typeof i == "object" && typeof i.spanId == "string" && typeof i.traceId == "string" && typeof i.traceFlags == "number";
}
var aC = new ms(), IC = (
  /** @class */
  (function() {
    function i(A, e, t, o) {
      this._provider = A, this.name = e, this.version = t, this.options = o;
    }
    return i.prototype.startSpan = function(A, e, t) {
      return this._getTracer().startSpan(A, e, t);
    }, i.prototype.startActiveSpan = function(A, e, t, o) {
      var g = this._getTracer();
      return Reflect.apply(g.startActiveSpan, g, arguments);
    }, i.prototype._getTracer = function() {
      if (this._delegate)
        return this._delegate;
      var A = this._provider.getDelegateTracer(this.name, this.version, this.options);
      return A ? (this._delegate = A, this._delegate) : aC;
    }, i;
  })()
), CC = (
  /** @class */
  (function() {
    function i() {
    }
    return i.prototype.getTracer = function(A, e, t) {
      return new ms();
    }, i;
  })()
), cC = new CC(), ar = (
  /** @class */
  (function() {
    function i() {
    }
    return i.prototype.getTracer = function(A, e, t) {
      var o;
      return (o = this.getDelegateTracer(A, e, t)) !== null && o !== void 0 ? o : new IC(this, A, e, t);
    }, i.prototype.getDelegate = function() {
      var A;
      return (A = this._delegate) !== null && A !== void 0 ? A : cC;
    }, i.prototype.setDelegate = function(A) {
      this._delegate = A;
    }, i.prototype.getDelegateTracer = function(A, e, t) {
      var o;
      return (o = this._delegate) === null || o === void 0 ? void 0 : o.getTracer(A, e, t);
    }, i;
  })()
);
Ao.getInstance();
jA.instance();
var BC = (
  /** @class */
  (function() {
    function i() {
    }
    return i.prototype.getMeter = function(A, e, t) {
      return UI;
    }, i;
  })()
), QC = new BC(), ho = "metrics", EC = (
  /** @class */
  (function() {
    function i() {
    }
    return i.getInstance = function() {
      return this._instance || (this._instance = new i()), this._instance;
    }, i.prototype.setGlobalMeterProvider = function(A) {
      return Mt(ho, A, jA.instance());
    }, i.prototype.getMeterProvider = function() {
      return Se(ho) || QC;
    }, i.prototype.getMeter = function(A, e, t) {
      return this.getMeterProvider().getMeter(A, e, t);
    }, i.prototype.disable = function() {
      Gt(ho, jA.instance());
    }, i;
  })()
), te = EC.getInstance(), lC = (
  /** @class */
  (function() {
    function i() {
    }
    return i.prototype.inject = function(A, e) {
    }, i.prototype.extract = function(A, e) {
      return A;
    }, i.prototype.fields = function() {
      return [];
    }, i;
  })()
), pg = fs("OpenTelemetry Baggage Key");
function Ss(i) {
  return i.getValue(pg) || void 0;
}
function dC() {
  return Ss(Ao.getInstance().active());
}
function hC(i, A) {
  return i.setValue(pg, A);
}
function uC(i) {
  return i.deleteValue(pg);
}
var uo = "propagation", fC = new lC(), wC = (
  /** @class */
  (function() {
    function i() {
      this.createBaggage = SI, this.getBaggage = Ss, this.getActiveBaggage = dC, this.setBaggage = hC, this.deleteBaggage = uC;
    }
    return i.getInstance = function() {
      return this._instance || (this._instance = new i()), this._instance;
    }, i.prototype.setGlobalPropagator = function(A) {
      return Mt(uo, A, jA.instance());
    }, i.prototype.inject = function(A, e, t) {
      return t === void 0 && (t = jI), this._getGlobalPropagator().inject(A, e, t);
    }, i.prototype.extract = function(A, e, t) {
      return t === void 0 && (t = PI), this._getGlobalPropagator().extract(A, e, t);
    }, i.prototype.fields = function() {
      return this._getGlobalPropagator().fields();
    }, i.prototype.disable = function() {
      Gt(uo, jA.instance());
    }, i.prototype._getGlobalPropagator = function() {
      return Se(uo) || fC;
    }, i;
  })()
);
wC.getInstance();
var fo = "trace", yC = (
  /** @class */
  (function() {
    function i() {
      this._proxyTracerProvider = new ar(), this.wrapSpanContext = nC, this.isSpanContextValid = Ds, this.deleteSpan = eC, this.getSpan = wg, this.getActiveSpan = AC, this.getSpanContext = ps, this.setSpan = yg, this.setSpanContext = tC;
    }
    return i.getInstance = function() {
      return this._instance || (this._instance = new i()), this._instance;
    }, i.prototype.setGlobalTracerProvider = function(A) {
      var e = Mt(fo, this._proxyTracerProvider, jA.instance());
      return e && this._proxyTracerProvider.setDelegate(A), e;
    }, i.prototype.getTracerProvider = function() {
      return Se(fo) || this._proxyTracerProvider;
    }, i.prototype.getTracer = function(A, e) {
      return this.getTracerProvider().getTracer(A, e);
    }, i.prototype.disable = function() {
      Gt(fo, jA.instance()), this._proxyTracerProvider = new ar();
    }, i;
  })()
);
yC.getInstance();
class pC {
  constructor(A) {
    this.totalValidTransactions = 0, this.version = 0, this.id = A.id, this.core = A;
  }
  get type() {
    return this.core.verified.header.type;
  }
  get headerMeta() {
    return this.core.verified.header.meta;
  }
  /** @category 6. Meta */
  get group() {
    return this.core.getGroup();
  }
  toJSON() {
    return {};
  }
  atTime() {
    return this;
  }
  subscribe(A) {
    return this.core.subscribe((e) => {
      A(e.getCurrentContent());
    });
  }
  processNewTransactions() {
  }
  rebuildFromCore() {
  }
}
function DC(i) {
  return i instanceof Uint8Array || ArrayBuffer.isView(i) && i.constructor.name === "Uint8Array";
}
function Ns(i, A) {
  return Array.isArray(A) ? A.length === 0 ? !0 : i ? A.every((e) => typeof e == "string") : A.every((e) => Number.isSafeInteger(e)) : !1;
}
function Vo(i, A) {
  if (typeof A != "string")
    throw new Error(`${i}: string expected`);
  return !0;
}
function Ms(i) {
  if (!Number.isSafeInteger(i))
    throw new Error(`invalid integer: ${i}`);
}
function Wo(i) {
  if (!Array.isArray(i))
    throw new Error("array expected");
}
function Gs(i, A) {
  if (!Ns(!0, A))
    throw new Error(`${i}: array of strings expected`);
}
function mC(i, A) {
  if (!Ns(!1, A))
    throw new Error(`${i}: array of numbers expected`);
}
// @__NO_SIDE_EFFECTS__
function SC(...i) {
  const A = (g) => g, e = (g, r) => (n) => g(r(n)), t = i.map((g) => g.encode).reduceRight(e, A), o = i.map((g) => g.decode).reduce(e, A);
  return { encode: t, decode: o };
}
// @__NO_SIDE_EFFECTS__
function NC(i) {
  const A = typeof i == "string" ? i.split("") : i, e = A.length;
  Gs("alphabet", A);
  const t = new Map(A.map((o, g) => [o, g]));
  return {
    encode: (o) => (Wo(o), o.map((g) => {
      if (!Number.isSafeInteger(g) || g < 0 || g >= e)
        throw new Error(`alphabet.encode: digit index outside alphabet "${g}". Allowed: ${i}`);
      return A[g];
    })),
    decode: (o) => (Wo(o), o.map((g) => {
      Vo("alphabet.decode", g);
      const r = t.get(g);
      if (r === void 0)
        throw new Error(`Unknown letter: "${g}". Allowed: ${i}`);
      return r;
    }))
  };
}
// @__NO_SIDE_EFFECTS__
function MC(i = "") {
  return Vo("join", i), {
    encode: (A) => (Gs("join.decode", A), A.join(i)),
    decode: (A) => (Vo("join.decode", A), A.split(i))
  };
}
function Ir(i, A, e) {
  if (A < 2)
    throw new Error(`convertRadix: invalid from=${A}, base cannot be less than 2`);
  if (e < 2)
    throw new Error(`convertRadix: invalid to=${e}, base cannot be less than 2`);
  if (Wo(i), !i.length)
    return [];
  let t = 0;
  const o = [], g = Array.from(i, (n) => {
    if (Ms(n), n < 0 || n >= A)
      throw new Error(`invalid integer: ${n}`);
    return n;
  }), r = g.length;
  for (; ; ) {
    let n = 0, s = !0;
    for (let a = t; a < r; a++) {
      const I = g[a], C = A * n, c = C + I;
      if (!Number.isSafeInteger(c) || C / A !== n || c - I !== C)
        throw new Error("convertRadix: carry overflow");
      const Q = c / e;
      n = c % e;
      const d = Math.floor(Q);
      if (g[a] = d, !Number.isSafeInteger(d) || d * e + n !== c)
        throw new Error("convertRadix: carry overflow");
      if (s)
        d ? s = !1 : t = a;
      else continue;
    }
    if (o.push(n), s)
      break;
  }
  for (let n = 0; n < i.length - 1 && i[n] === 0; n++)
    o.push(0);
  return o.reverse();
}
// @__NO_SIDE_EFFECTS__
function GC(i) {
  Ms(i);
  const A = 2 ** 8;
  return {
    encode: (e) => {
      if (!DC(e))
        throw new Error("radix.encode input should be Uint8Array");
      return Ir(Array.from(e), A, i);
    },
    decode: (e) => (mC("radix.decode", e), Uint8Array.from(Ir(e, i, A)))
  };
}
const kC = /* @__NO_SIDE_EFFECTS__ */ (i) => /* @__PURE__ */ SC(/* @__PURE__ */ GC(58), /* @__PURE__ */ NC(i), /* @__PURE__ */ MC("")), NA = /* @__PURE__ */ kC("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
function bA(i) {
  const A = [];
  let e = i;
  if (e && e.toJSON && typeof e.toJSON == "function" && (e = e.toJSON()), e === void 0)
    return;
  if (typeof e == "number")
    return isFinite(e) ? "" + e : "null";
  if (typeof e != "object")
    return typeof e == "string" && (e.startsWith("encrypted_U") || e.startsWith("binary_U")) ? `"${e}"` : JSON.stringify(e);
  let t, o;
  if (Array.isArray(e)) {
    for (o = "[", t = 0; t < e.length; t++)
      t && (o += ","), o += bA(e[t]) || "null";
    return o + "]";
  }
  if (e === null)
    return "null";
  if (A.indexOf(e) !== -1)
    throw new TypeError("Converting circular structure to JSON");
  const g = A.push(e) - 1, r = Object.keys(e).sort();
  for (o = "", t = 0; t < r.length; t++) {
    const n = r[t], s = bA(e[n]);
    s && (o && (o += ","), o += JSON.stringify(n) + ":" + s);
  }
  return A.splice(g, 1), "{" + o + "}";
}
function ji(i) {
  return JSON.parse(i);
}
function zo(i) {
  try {
    return JSON.parse(i);
  } catch {
    return;
  }
}
const tt = {
  DEBUG: 0,
  INFO: 1,
  WARN: 2,
  ERROR: 3
};
class FC {
  debug(A, e) {
    console.debug(A, e);
  }
  info(A, e) {
    console.info(A, e);
  }
  warn(A, e) {
    console.warn(A, e);
  }
  error(A, e) {
    console.error(A, e);
  }
}
class RC {
  constructor(A = tt.INFO, e = new FC()) {
    this.level = A, this.logSystem = e;
  }
  setLevel(A) {
    this.level = A;
  }
  setLogSystem(A) {
    this.logSystem = A;
  }
  debug(A, e) {
    this.level <= tt.DEBUG && this.logSystem.debug(A, e);
  }
  info(A, e) {
    this.level <= tt.INFO && this.logSystem.info(A, e);
  }
  warn(A, e) {
    this.level <= tt.WARN && this.logSystem.warn(A, e);
  }
  error(A, e) {
    this.level <= tt.ERROR && this.logSystem.error(A, e);
  }
}
const Z = new RC();
function bC(i = 32) {
  return crypto.getRandomValues(new Uint8Array(i));
}
const fA = new TextEncoder(), Cr = new TextDecoder();
class KC {
  constructor() {
    this.agentIdCache = /* @__PURE__ */ new Map();
  }
  randomBytes(A) {
    return bC(A);
  }
  newRandomSigner() {
    return `signerSecret_z${NA.encode(this.newEd25519SigningKey())}`;
  }
  newRandomSealer() {
    return `sealerSecret_z${NA.encode(this.newX25519StaticSecret())}`;
  }
  newRandomAgentSecret() {
    return `${this.newRandomSealer()}/${this.newRandomSigner()}`;
  }
  getAgentID(A) {
    const e = A;
    let t = this.agentIdCache.get(e);
    if (!t) {
      const [o, g] = A.split("/");
      t = `${this.getSealerID(o)}/${this.getSignerID(g)}`, this.agentIdCache.set(e, t);
    }
    return t;
  }
  getAgentSignerID(A) {
    return A.split("/")[1];
  }
  getAgentSignerSecret(A) {
    return A.split("/")[1];
  }
  getAgentSealerID(A) {
    return A.split("/")[0];
  }
  getAgentSealerSecret(A) {
    return A.split("/")[0];
  }
  secureHash(A) {
    return `hash_z${NA.encode(this.blake3HashOnce(fA.encode(bA(A))))}`;
  }
  shortHash(A) {
    return `shortHash_z${NA.encode(this.blake3HashOnce(fA.encode(bA(A))).slice(0, YC))}`;
  }
  decrypt(A, e, t) {
    try {
      return ji(this.decryptRaw(A, e, t));
    } catch (o) {
      Z.error("Decryption error", { err: o });
      return;
    }
  }
  newRandomKeySecret() {
    return {
      secret: `keySecret_z${NA.encode(this.randomBytes(32))}`,
      id: `key_z${NA.encode(this.randomBytes(12))}`
    };
  }
  encryptKeySecret(A) {
    const e = {
      encryptedID: A.toEncrypt.id,
      encryptingID: A.encrypting.id
    };
    return {
      encryptedID: A.toEncrypt.id,
      encryptingID: A.encrypting.id,
      encrypted: this.encrypt(A.toEncrypt.secret, A.encrypting.secret, e)
    };
  }
  decryptKeySecret(A, e) {
    const t = {
      encryptedID: A.encryptedID,
      encryptingID: A.encryptingID
    };
    return this.decrypt(A.encrypted, e, t);
  }
  uniquenessForHeader() {
    return `z${NA.encode(this.randomBytes(12))}`;
  }
  createdNowUnique() {
    return {
      createdAt: (/* @__PURE__ */ new Date()).toISOString(),
      uniqueness: this.uniquenessForHeader()
    };
  }
  newRandomSecretSeed() {
    return this.randomBytes(wo);
  }
  agentSecretFromSecretSeed(A) {
    if (A.length !== wo)
      throw new Error(`Secret seed needs to be ${wo} bytes long`);
    return `sealerSecret_z${NA.encode(this.blake3HashOnceWithContext(A, {
      context: fA.encode("seal")
    }))}/signerSecret_z${NA.encode(this.blake3HashOnceWithContext(A, {
      context: fA.encode("sign")
    }))}`;
  }
  newRandomSessionID(A) {
    const e = NA.encode(this.randomBytes(8));
    return `${A}_session_z${e}`;
  }
  newDeleteSessionID(A) {
    const e = NA.encode(this.randomBytes(7));
    return `${A}_session_d${e}$`;
  }
}
const YC = 19, wo = 32;
function ks(i) {
  return typeof i == "string" && i.startsWith("co_z");
}
function Oe(i) {
  return typeof i == "string" && i.startsWith("sealer_") && i.includes("/signer_");
}
const vC = 36;
function Ne(i) {
  return i.charCodeAt(i.length - 1) === vC;
}
function Fs(i) {
  return i.startsWith("parent_");
}
function Rs(i) {
  return i.slice(7);
}
function UC(i) {
  if (typeof i == "string") {
    if (Fs(i))
      return Rs(i);
    if (i.startsWith("co_"))
      return i;
  }
}
function vA(i) {
  const A = i.indexOf("_session");
  return i.slice(0, A);
}
class kt {
  resetInternalState() {
    this.afterStart = [], this.beforeEnd = [], this.insertions = {}, this.deletionsByInsertion = {}, this._cachedEntries = void 0, this.knownTransactions = { [this.core.id]: 0 }, this.lastValidTransaction = void 0, this.totalValidTransactions = 0;
  }
  /** @internal */
  constructor(A, e) {
    this.type = "colist", this.afterStart = [], this.beforeEnd = [], this.insertions = {}, this.deletionsByInsertion = {}, this.atTimeFilter = void 0, this.knownTransactions = {}, this.version = 0, this.totalValidTransactions = 0, this.id = A.id, this.core = A, this.insertions = {}, this.deletionsByInsertion = {}, this.afterStart = [], this.beforeEnd = [], this.knownTransactions = { [A.id]: 0 }, this.atTimeFilter = e, this._processNewTransactions();
  }
  getInsertionsEntry(A) {
    const e = Jt(A), t = this.insertions[e];
    if (!t)
      return;
    const o = t[A.txIndex];
    if (o)
      return o[A.changeIdx];
  }
  createInsertionsEntry(A, e) {
    const t = Jt(A);
    let o = this.insertions[t];
    o || (o = {}, this.insertions[t] = o);
    let g = o[A.txIndex];
    return g || (g = {}, o[A.txIndex] = g), g[A.changeIdx] ? !1 : (g[A.changeIdx] = e, !0);
  }
  isDeleted(A) {
    const e = Jt(A), t = this.deletionsByInsertion[e];
    if (!t)
      return !1;
    const o = t[A.txIndex];
    return o ? !!o[A.changeIdx]?.length : !1;
  }
  pushDeletionsByInsertionEntry(A, e) {
    const t = Jt(A);
    let o = this.deletionsByInsertion[t];
    o || (o = {}, this.deletionsByInsertion[t] = o);
    let g = o[A.txIndex];
    g || (g = {}, o[A.txIndex] = g);
    let r = g[A.changeIdx];
    r || (r = [], g[A.changeIdx] = r), r.push(e);
  }
  processNewTransactions() {
    if (this.isTimeTravelEntity())
      throw new Error("Cannot process transactions on a time travel entity");
    this._processNewTransactions();
  }
  _processNewTransactions() {
    const A = this.core.getValidSortedTransactions({
      ignorePrivateTransactions: !1,
      knownTransactions: this.knownTransactions
    });
    if (A.length === 0)
      return;
    let e, t;
    this._cachedEntries = void 0;
    for (const { txID: o, changes: g, madeAt: r } of A)
      if (!this.isFilteredOut(r)) {
        e = Math.max(e ?? 0, r), t = Math.min(t ?? 1 / 0, r);
        for (const [n, s] of g.entries()) {
          const a = s, I = {
            sessionID: o.sessionID,
            txIndex: o.txIndex,
            branch: o.branch,
            changeIdx: n
          };
          if (a.op === "pre" || a.op === "app") {
            if (!this.createInsertionsEntry(I, {
              madeAt: r,
              predecessors: [],
              successors: [],
              change: a
            }))
              continue;
            if (a.op === "pre")
              if (a.before === "end")
                this.beforeEnd.push(I);
              else {
                const c = this.getInsertionsEntry(a.before);
                if (!c)
                  continue;
                c.predecessors.push(I);
              }
            else if (a.after === "start")
              this.afterStart.push(I);
            else {
              const c = this.getInsertionsEntry(a.after);
              if (!c)
                continue;
              c.successors.push(I);
            }
          } else if (a.op === "del")
            this.pushDeletionsByInsertionEntry(a.insertion, {
              madeAt: r,
              deletionID: I,
              change: a
            });
          else
            throw new Error("Unknown list operation " + a.op);
        }
      }
    this.lastValidTransaction && t && t < this.lastValidTransaction ? this.rebuildFromCore() : this.lastValidTransaction = e, this.totalValidTransactions += A.length;
  }
  rebuildFromCore() {
    this.version += 1, this.resetInternalState(), this.processNewTransactions();
  }
  isTimeTravelEntity() {
    return !!this.atTimeFilter;
  }
  isFilteredOut(A) {
    return this.atTimeFilter === void 0 ? !1 : A > this.atTimeFilter;
  }
  /** @category 6. Meta */
  get headerMeta() {
    return this.core.verified.header.meta;
  }
  /** @category 6. Meta */
  get group() {
    return this.core.getGroup();
  }
  /**
   * Not yet implemented
   *
   * @category 4. Time travel
   */
  atTime(A) {
    return new kt(this.core, A);
  }
  /**
   * Get the item currently at `idx`.
   *
   * @category 1. Reading
   */
  get(A) {
    const e = this.entries()[A];
    if (e)
      return e.value;
  }
  /**
   * Returns the current items in the CoList as an array.
   *
   * @category 1. Reading
   **/
  asArray() {
    return this.entries().map((A) => A.value);
  }
  /** @internal */
  entries() {
    if (this._cachedEntries)
      return this._cachedEntries;
    const A = this.entriesUncached();
    return this._cachedEntries = A, A;
  }
  length() {
    return this.entries().length;
  }
  /** @internal */
  entriesUncached() {
    const A = [];
    for (const e of this.afterStart)
      this.fillArrayFromOpID(e, A);
    for (const e of this.beforeEnd)
      this.fillArrayFromOpID(e, A);
    return A;
  }
  /** @internal */
  fillArrayFromOpID(A, e) {
    const t = [A], o = /* @__PURE__ */ new Set();
    for (; t.length > 0; ) {
      const g = t[t.length - 1], r = this.getInsertionsEntry(g);
      if (!r)
        throw new Error("Missing op " + g);
      if (r.predecessors.length > 0 && !o.has(g)) {
        for (const s of r.predecessors)
          t.push(s);
        o.add(g);
      } else {
        t.pop(), this.isDeleted(g) || e.push({
          value: r.change.value,
          madeAt: r.madeAt,
          opID: g
        });
        for (const a of r.successors)
          t.push(a);
      }
    }
  }
  /**
   * Returns the current items in the CoList as an array. (alias of `asArray`)
   *
   * @category 1. Reading
   */
  toJSON() {
    return this.asArray();
  }
  /** @category 5. Edit history */
  editAt(A) {
    const e = this.entries()[A];
    if (!e)
      return;
    const t = new Date(e.madeAt), o = vA(e.opID.sessionID), g = e.value;
    return {
      by: o,
      tx: {
        sessionID: e.opID.sessionID,
        txIndex: e.opID.txIndex
      },
      at: t,
      value: g
    };
  }
  /** @category 5. Edit history */
  deletionEdits() {
    const A = [];
    for (const e in this.deletionsByInsertion) {
      const t = this.deletionsByInsertion[e];
      for (const o in t) {
        const g = t[Number(o)];
        for (const r in g) {
          const n = g[Number(r)];
          for (const s of n || []) {
            const a = new Date(s.madeAt), I = vA(s.deletionID.sessionID);
            A.push({
              by: I,
              tx: s.deletionID,
              at: a
            });
          }
        }
      }
    }
    return A;
  }
  /** @category 3. Subscription */
  subscribe(A) {
    return this.core.subscribe((e) => {
      A(e.getCurrentContent());
    });
  }
  /** Appends `item` after the item currently at index `after`.
   *
   * If `privacy` is `"private"` **(default)**, `item` is encrypted in the transaction, only readable by other members of the group this `CoList` belongs to. Not even sync servers can see the content in plaintext.
   *
   * If `privacy` is `"trusting"`, `item` is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
   *
   * @category 2. Editing
   **/
  append(A, e, t = "private") {
    this.appendItems([A], e, t);
  }
  /**
   * Appends `items` to the list at index `after`. If `after` is negative, it is treated as `0`.
   *
   * If `privacy` is `"private"` **(default)**, `items` are encrypted in the transaction, only readable by other members of the group this `CoList` belongs to. Not even sync servers can see the content in plaintext.
   *
   * If `privacy` is `"trusting"`, `items` are stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
   *
   * @category 2. Editing
   */
  appendItems(A, e, t = "private") {
    const o = this.entries();
    e = e === void 0 ? o.length > 0 ? o.length - 1 : 0 : Math.max(0, e);
    let g;
    if (o.length > 0) {
      const n = o[e];
      if (!n)
        throw new Error("Invalid index " + e);
      g = n.opID;
    } else {
      if (e !== 0)
        throw new Error("Invalid index " + e);
      g = "start";
    }
    const r = A.map((n) => ({
      op: "app",
      value: je(n) ? n.id : n,
      after: g
    }));
    g !== "start" && r.reverse(), this.core.makeTransaction(r, t), this.processNewTransactions();
  }
  /**
   * Prepends `item` before the item currently at index `before`.
   *
   * If `privacy` is `"private"` **(default)**, `item` is encrypted in the transaction, only readable by other members of the group this `CoList` belongs to. Not even sync servers can see the content in plaintext.
   *
   * If `privacy` is `"trusting"`, `item` is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
   *
   * @category 2. Editing
   */
  prepend(A, e, t = "private") {
    const o = this.entries();
    e = e === void 0 ? 0 : e;
    let g;
    if (o.length > 0) {
      const r = o[e];
      if (r)
        g = r.opID;
      else {
        if (e !== o.length)
          throw new Error("Invalid index " + e);
        g = "end";
      }
    } else {
      if (e !== 0)
        throw new Error("Invalid index " + e);
      g = "end";
    }
    this.core.makeTransaction([
      {
        op: "pre",
        value: je(A) ? A.id : A,
        before: g
      }
    ], t), this.processNewTransactions();
  }
  /** Deletes the item at index `at`.
   *
   * If `privacy` is `"private"` **(default)**, the fact of this deletion is encrypted in the transaction, only readable by other members of the group this `CoList` belongs to. Not even sync servers can see the content in plaintext.
   *
   * If `privacy` is `"trusting"`, the fact of this deletion is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
   *
   * @category 2. Editing
   **/
  delete(A, e = "private") {
    const o = this.entries()[A];
    if (!o)
      throw new Error("Invalid index " + A);
    this.core.makeTransaction([
      {
        op: "del",
        insertion: o.opID
      }
    ], e), this.processNewTransactions();
  }
  replace(A, e, t = "private") {
    const g = this.entries()[A];
    if (!g)
      throw new Error("Invalid index " + A);
    this.core.makeTransaction([
      {
        op: "app",
        value: je(e) ? e.id : e,
        after: g.opID
      },
      {
        op: "del",
        insertion: g.opID
      }
    ], t), this.processNewTransactions();
  }
}
function Jt(i) {
  return i.branch ? `${i.sessionID}_branch_${i.branch}` : i.sessionID;
}
function Dg(i) {
  return i.startsWith("co_");
}
class bs {
  resetInternalState() {
    this.items = {}, this.knownTransactions = { [this.core.id]: 0 }, this.totalValidTransactions = 0;
  }
  constructor(A) {
    this.type = "costream", this.totalValidTransactions = 0, this.version = 0, this.id = A.id, this.core = A, this.items = {}, this.knownTransactions = { [A.id]: 0 }, this.processNewTransactions();
  }
  rebuildFromCore() {
    this.version++, this.resetInternalState(), this.processNewTransactions();
  }
  get headerMeta() {
    return this.core.verified.header.meta;
  }
  get group() {
    return this.core.getGroup();
  }
  /** Not yet implemented */
  atTime(A) {
    throw new Error("Not yet implemented");
  }
  /** @internal */
  compareStreamItems(A, e) {
    return A.madeAt - e.madeAt || (A.tx.sessionID === e.tx.sessionID ? 0 : A.tx.sessionID < e.tx.sessionID ? -1 : 1) || A.tx.txIndex - e.tx.txIndex;
  }
  /** @internal */
  processNewTransactions() {
    const A = /* @__PURE__ */ new Set(), e = this.core.getValidTransactions({
      ignorePrivateTransactions: !1,
      knownTransactions: this.knownTransactions
    });
    if (e.length !== 0) {
      for (const { txID: t, madeAt: o, changes: g } of e)
        for (const r of g) {
          const n = r;
          let s = this.items[t.sessionID];
          s || (s = [], this.items[t.sessionID] = s), s.push({ value: n, madeAt: o, tx: t }), A.add(s);
        }
      for (const t of A)
        t.sort(this.compareStreamItems);
      this.totalValidTransactions += e.length;
    }
  }
  getSingleStream() {
    const A = Object.values(this.items), e = A[0];
    if (e) {
      if (A.length > 1)
        throw new Error("CoStream.getSingleStream() can only be called when there is exactly one stream");
      return e.map((t) => t.value);
    }
  }
  sessions() {
    return Object.keys(this.items);
  }
  accounts() {
    return new Set(this.sessions().map(vA).filter(Dg));
  }
  nthItemIn(A, e) {
    const t = this.items[A];
    if (!t)
      return;
    const o = t[e];
    if (o)
      return {
        by: vA(A),
        tx: o.tx,
        at: new Date(o.madeAt),
        value: o.value
      };
  }
  lastItemIn(A) {
    const e = this.items[A];
    if (e)
      return this.nthItemIn(A, e.length - 1);
  }
  *itemsIn(A) {
    const e = this.items[A];
    if (e)
      for (const t of e)
        yield {
          by: vA(A),
          tx: t.tx,
          at: new Date(t.madeAt),
          value: t.value
        };
  }
  lastItemBy(A) {
    let e;
    for (const t of Object.keys(this.items))
      if (t.startsWith(A)) {
        const o = this.lastItemIn(t);
        if (!o)
          continue;
        (!e || o.at > e.at) && (e = {
          by: o.by,
          tx: o.tx,
          at: o.at,
          value: o.value
        });
      }
    return e;
  }
  *itemsBy(A) {
    const e = [
      ...Object.keys(this.items).flatMap((t) => t.startsWith(A) ? [...this.itemsIn(t)].map((o) => ({
        in: t,
        ...o
      })) : [])
    ];
    e.sort((t, o) => t.at.getTime() - o.at.getTime());
    for (const t of e)
      yield t;
  }
  toJSON() {
    return Object.fromEntries(Object.entries(this.items).map(([A, e]) => [
      A,
      e.map((t) => t.value)
    ]));
  }
  subscribe(A) {
    return this.core.subscribe((e) => {
      A(e.getCurrentContent());
    });
  }
}
class Ks extends bs {
  push(A, e = "private") {
    this.core.makeTransaction([je(A) ? A.id : A], e), this.processNewTransactions();
  }
}
const JC = 8;
class HC extends bs {
  isBinaryStreamEnded() {
    const A = this.getSingleStream();
    return !A || A.length === 0 ? !1 : A[A.length - 1]?.type === "end";
  }
  getBinaryStreamInfo() {
    const A = this.getSingleStream();
    if (!A)
      return;
    const e = A[0];
    if (e?.type !== "start") {
      Z.error("Invalid binary stream start", e);
      return;
    }
    return {
      mimeType: e.mimeType,
      fileName: e.fileName,
      totalSizeBytes: e.totalSizeBytes
    };
  }
  getBinaryChunks(A) {
    const e = this.getSingleStream();
    if (!e)
      return;
    const t = this.getBinaryStreamInfo();
    if (!t || e[e.length - 1]?.type !== "end" && !A)
      return;
    const g = [];
    let r = !1;
    for (const n of e.slice(1)) {
      if (n.type === "end") {
        r = !0;
        break;
      }
      if (n.type !== "chunk") {
        Z.error("Invalid binary stream chunk", n);
        return;
      }
      const s = Oo(n.chunk.slice(JC));
      g.push(s);
    }
    return {
      ...t,
      chunks: g,
      finished: r
    };
  }
}
class Ys extends HC {
  /** @internal */
  push(A, e = "private", t = !0) {
    this.core.makeTransaction([A], e), t && this.processNewTransactions();
  }
  startBinaryStream(A, e = "private") {
    this.push({
      type: "start",
      ...A
    }, e, !1);
  }
  pushBinaryStreamChunk(A, e = "private") {
    this.push({
      type: "chunk",
      chunk: `binary_U${Po(A)}`
    }, e, !1);
  }
  endBinaryStream(A = "private") {
    this.push({
      type: "end"
    }, A, !0);
  }
}
function je(i) {
  return i instanceof mg || i instanceof kt || i instanceof Ks || i instanceof Ys;
}
class mg {
  /** @internal */
  get latestTxMadeAt() {
    return this.core.latestTxMadeAt;
  }
  /** @internal */
  get earliestTxMadeAt() {
    return this.core.earliestTxMadeAt;
  }
  resetInternalState() {
    this.ops = {}, this.latest = {}, this.knownTransactions = { [this.core.id]: 0 }, this.totalValidTransactions = 0;
  }
  /** @internal */
  constructor(A, e) {
    this.type = "comap", this.ops = {}, this.latest = {}, this.knownTransactions = {}, this.totalValidTransactions = 0, this.version = 0, this.atTimeFilter = void 0, this.id = A.id, this.core = A, this.ignorePrivateTransactions = e?.ignorePrivateTransactions ?? !1, this.processNewTransactions();
  }
  processNewTransactions() {
    if (this.isTimeTravelEntity())
      throw new Error("Cannot process transactions on a time travel entity");
    const A = this.core.getValidTransactions({
      ignorePrivateTransactions: this.ignorePrivateTransactions,
      knownTransactions: this.knownTransactions
    });
    if (A.length === 0)
      return;
    const { ops: e } = this, t = /* @__PURE__ */ new Map();
    for (const o of A) {
      const { txID: g, changes: r, madeAt: n, tx: s } = o;
      for (let a = 0; a < r.length; a++) {
        const I = r[a], C = {
          txID: g,
          madeAt: n,
          changeIdx: a,
          change: I,
          trusting: s.privacy === "trusting"
        }, c = e[I.key];
        if (c)
          c.push(C), t.set(I.key, c);
        else {
          const Q = [C];
          e[I.key] = Q, t.set(I.key, Q);
        }
      }
      this.handleNewTransaction(o);
    }
    for (const o of t.values())
      o.sort(this.core.compareTransactions);
    for (const [o, g] of t.entries())
      this.latest[o] = g[g.length - 1];
    this.totalValidTransactions += A.length;
  }
  handleNewTransaction(A) {
  }
  rebuildFromCore() {
    this.version += 1, this.resetInternalState(), this.processNewTransactions();
  }
  isTimeTravelEntity() {
    return !!this.atTimeFilter;
  }
  /** @category 6. Meta */
  get headerMeta() {
    return this.core.verified.header.meta;
  }
  /** @category 6. Meta */
  get group() {
    return this.core.getGroup();
  }
  /** @category 4. Time travel */
  atTime(A) {
    const e = Object.create(this);
    return e.atTimeFilter = A, e.latest = {}, e;
  }
  /** @internal */
  timeFilteredOps(A) {
    if (A === "constructor")
      return;
    const e = this.atTimeFilter;
    return e ? this.ops[A]?.filter((t) => t.madeAt <= e) : this.ops[A];
  }
  /**
   * Get all keys currently in the map.
   *
   * @category 1. Reading */
  keys() {
    return Object.keys(this.ops).filter((A) => {
      const e = this.getRaw(A);
      return !(e === void 0 || e.change.op === "del");
    });
  }
  getRaw(A) {
    let e = this.latest[A];
    if (e === void 0) {
      const t = this.ops[A];
      if (t && !(A in this.latest)) {
        const o = this.atTimeFilter;
        o ? e = t.findLast((g) => g.madeAt <= o) : e = t[t.length - 1], this.latest[A] = e;
      }
      if (e === void 0)
        return;
    }
    return e;
  }
  /**
   * Returns the current value for the given key.
   *
   * @category 1. Reading
   **/
  get(A) {
    const e = this.getRaw(A);
    if (e?.change !== void 0 && e.change.op !== "del")
      return e.change.value;
  }
  /** @category 1. Reading */
  asObject() {
    const A = {};
    for (const e of Object.keys(this.ops)) {
      const t = this.get(e);
      t !== void 0 && (A[e] = t);
    }
    return A;
  }
  /** @category 1. Reading */
  toJSON() {
    return this.asObject();
  }
  /** @category 5. Edit history */
  nthEditAt(A, e) {
    const t = this.ops[A], o = this.atTimeFilter, g = t?.[e];
    if (g && !(o && g.madeAt > o))
      return yo(g);
  }
  /** @category 5. Edit history */
  lastEditAt(A) {
    const e = this.getRaw(A);
    if (e)
      return yo(e);
  }
  /** @category 5. Edit history */
  *editsAt(A) {
    const e = this.ops[A];
    if (!e)
      return;
    const t = this.atTimeFilter;
    for (const o of e) {
      if (t && o.madeAt > t)
        return;
      yield yo(o);
    }
  }
  /** @category 3. Subscription */
  subscribe(A) {
    return this.core.subscribe((e) => {
      A(e.getCurrentContent());
    });
  }
  /** Set a new value for the given key.
   *
   * If `privacy` is `"private"` **(default)**, both `key` and `value` are encrypted in the transaction, only readable by other members of the group this `CoMap` belongs to. Not even sync servers can see the content in plaintext.
   *
   * If `privacy` is `"trusting"`, both `key` and `value` are stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
   *
   * @category 2. Editing
   **/
  set(A, e, t = "private") {
    if (this.isTimeTravelEntity())
      throw new Error("Cannot set value on a time travel entity");
    this.core.makeTransaction([
      {
        op: "set",
        key: A,
        value: je(e) ? e.id : e
      }
    ], t), this.processNewTransactions();
  }
  assign(A, e = "private") {
    if (this.isTimeTravelEntity())
      throw new Error("Cannot set value on a time travel entity");
    this.core.makeTransaction(Object.entries(A).map(([t, o]) => ({
      op: "set",
      key: t,
      value: je(o) ? o.id : o
    })), e), this.processNewTransactions();
  }
  /** Delete the given key (setting it to undefined).
   *
   * If `privacy` is `"private"` **(default)**, `key` is encrypted in the transaction, only readable by other members of the group this `CoMap` belongs to. Not even sync servers can see the content in plaintext.
   *
   * If `privacy` is `"trusting"`, `key` is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
   *
   * @category 2. Editing
   **/
  delete(A, e = "private") {
    if (this.isTimeTravelEntity())
      throw new Error("Cannot delete value on a time travel entity");
    this.core.makeTransaction([
      {
        op: "del",
        key: A
      }
    ], e), this.processNewTransactions();
  }
}
function yo(i) {
  return {
    by: vA(i.txID.sessionID),
    tx: i.txID,
    at: new Date(i.madeAt),
    value: i.change.op === "del" ? void 0 : i.change.value
  };
}
function DA(i) {
  if (i.type !== "comap")
    throw new Error("Expected group");
  if (i.core.verified.header.ruleset.type !== "group")
    throw new Error("Expected group ruleset in group");
  if (!(i instanceof Sg))
    throw new Error("Expected group");
  return i;
}
function cr(i) {
  return i === "manager" || i === "admin" || i === "writer" || i === "reader" || i === "writeOnly";
}
function it(i) {
  return i === "admin" || i === "manager";
}
function qC(i) {
  if (!i.isAvailable())
    throw new Error("determineValidTransactions CoValue is not available");
  if (i.verified.header.ruleset.type === "group") {
    const A = i.verified.header.ruleset.initialAdmin;
    if (!A)
      throw new Error("Group must have initialAdmin");
    TC(i, A);
    return;
  }
  if (i.verified.header.ruleset.type === "ownedByGroup") {
    const A = DA(i.node.expectCoValueLoaded(i.verified.header.ruleset.group, "Determining valid transaction in owned object but its group wasn't loaded").getCurrentContent());
    if (A.type !== "comap")
      throw new Error("Group must be a map");
    for (const e of i.toValidateTransactions) {
      const t = A.atTime(e.currentMadeAt), o = OC(e.author, t);
      if (!o) {
        e.markInvalid("Transactor not found in group", {
          transactor: e.author,
          group: t.toJSON()
        });
        continue;
      }
      const g = t.roleOfInternal(o);
      if (g === "reader" && e.meta?.branch && e.meta?.ownerId) {
        e.meta = {
          branch: e.meta.branch,
          ownerId: e.meta.ownerId
        }, e.changes = [], e.markValid();
        continue;
      }
      if (g !== "admin" && g !== "manager" && g !== "writer" && g !== "writeOnly") {
        e.markInvalid("Transactor has no write permissions", {
          transactor: e.author,
          transactorRole: g ?? "undefined"
        });
        continue;
      }
      e.markValid();
    }
    return;
  }
  if (i.verified.header.ruleset.type === "unsafeAllowAll") {
    for (const A of i.toValidateTransactions)
      A.markValid();
    return;
  }
  throw new Error("Unknown ruleset type " + i.verified.header.ruleset.type);
}
function LC(i, A) {
  return i === void 0 || i === "revoked" ? !1 : A === void 0 || A === "revoked" ? !0 : A === "admin" ? !1 : i === "admin" ? !0 : A === "manager" ? !1 : i === "manager" ? !0 : i === "writer" && A === "reader";
}
class xC {
  constructor() {
    this.parentGroups = /* @__PURE__ */ new Map(), this.memberRoles = /* @__PURE__ */ new Map();
  }
  setDirectRole(A, e) {
    this.memberRoles.set(A, e);
  }
  removeMember(A) {
    this.memberRoles.delete(A);
  }
  addParentGroup(A, e) {
    this.parentGroups.set(A, e);
  }
  removeParentGroup(A) {
    this.parentGroups.delete(A);
  }
  getDirectRole(A) {
    return this.memberRoles.get(A);
  }
  getRoleAtTime(A, e) {
    let t = this.memberRoles.get(A);
    for (const [o, g] of this.parentGroups.entries()) {
      const r = o.atTime(e).roleOfInternal(A);
      if (!r || !Us(r))
        continue;
      const n = g === "extend" ? r : g;
      LC(n, t) && (t = n);
    }
    return t;
  }
}
function TC(i, A) {
  i.verifiedTransactions.sort(i.compareTransactions);
  const e = {}, t = /* @__PURE__ */ new Set(), o = new xC(), g = i.isGroup();
  for (const r of i.verifiedTransactions) {
    let d = function(h) {
      if (h.op !== "set")
        throw new Error("Expected set operation");
      o.setDirectRole(h.key, h.value), r.markValid();
    };
    const n = r.author, s = o.getRoleAtTime(n, r.currentMadeAt);
    if (r.tx.privacy === "private") {
      if (g) {
        r.markInvalid("Can't make private transactions in groups");
        continue;
      }
      if (s === "admin") {
        r.markValid();
        continue;
      } else {
        r.markInvalid("Only admins can make private transactions in groups");
        continue;
      }
    }
    const I = r.changes;
    if (!I)
      continue;
    const C = I[0];
    if (I.length !== 1) {
      r.markInvalid("Group transaction must have exactly one change");
      continue;
    }
    if (C.op !== "set") {
      r.markInvalid("Group transaction must set a role or readKey");
      continue;
    }
    if (C.key === "readKey") {
      if (!it(s)) {
        r.markInvalid("Only admins can set readKeys");
        continue;
      }
      r.markValid();
      continue;
    } else if (C.key === "profile") {
      if (!it(s)) {
        r.markInvalid("Only admins can set profile");
        continue;
      }
      r.markValid();
      continue;
    } else if (C.key === "root") {
      if (!it(s)) {
        r.markInvalid("Only admins can set root");
        continue;
      }
      r.markValid();
      continue;
    } else if (vs(C.key) || VC(C.key)) {
      if (s !== "admin" && s !== "adminInvite" && s !== "manager" && s !== "managerInvite" && s !== "writerInvite" && s !== "readerInvite" && s !== "writeOnlyInvite" && !$C(C.key, n, e)) {
        r.markInvalid("Only admins and managers can reveal keys");
        continue;
      }
      r.markValid();
      continue;
    } else if (WC(C.key)) {
      if (!it(s)) {
        r.markInvalid("Only admins and managers can set parent extensions");
        continue;
      }
      const h = Rs(C.key), l = i.node.expectCoValueLoaded(h, "Expected parent group to be loaded");
      if (!l.isGroup()) {
        r.markInvalid("Parent group is not a group");
        continue;
      }
      const B = DA(l.getCurrentContent());
      if (Js(i, B)) {
        r.markInvalid("Parent group is a circular dependency");
        continue;
      }
      const u = C.value;
      u === "revoked" ? o.removeParentGroup(B) : o.addParentGroup(B, u), r.markValid();
      continue;
    } else if (zC(C.key)) {
      r.markInvalid("Child extensions are not allowed anymore");
      continue;
    } else if (PC(C.key)) {
      const h = jC(C.key);
      if (s !== "admin" && s !== "manager" && s !== "writeOnlyInvite" && h !== n) {
        r.markInvalid("Only admins and managers can set writeKeys");
        continue;
      }
      if (e[h] = C.value, t.has(C.key) && !it(s)) {
        r.markInvalid("Write key already exists and can't be overridden by invite");
        continue;
      }
      t.add(C.key), r.markValid();
      continue;
    }
    const c = C.key, Q = C.value;
    if (Q !== "admin" && Q !== "manager" && Q !== "writer" && Q !== "reader" && Q !== "writeOnly" && Q !== "revoked" && Q !== "managerInvite" && Q !== "adminInvite" && Q !== "writerInvite" && Q !== "readerInvite" && Q !== "writeOnlyInvite") {
      r.markInvalid("Group transaction must set a valid role");
      continue;
    }
    if (c === PA && !(Q === "reader" || Q === "writer" || Q === "writeOnly" || Q === "revoked")) {
      r.markInvalid("Everyone can only be set to reader, writer, writeOnly or revoked");
      continue;
    }
    if (s === void 0 && n === A && c === n && Q === "admin") {
      d(C);
      continue;
    }
    if (n === C.key && C.value === "revoked") {
      d(C);
      continue;
    }
    const f = o.getRoleAtTime(c, r.currentMadeAt);
    if (s === "admin") {
      if (f === "admin" && Q !== "admin" && c !== n) {
        r.markInvalid("Admins can't demote admins.");
        continue;
      }
      d(C);
      continue;
    }
    if (s === "manager") {
      if (f === "admin") {
        r.markInvalid("Managers can't demote admins.");
        continue;
      }
      if (C.value === "admin") {
        r.markInvalid("Managers can't promote to admin.");
        continue;
      }
      if (C.value === "adminInvite") {
        r.markInvalid("Managers can't invite admins.");
        continue;
      }
      if (C.value === "managerInvite") {
        r.markInvalid("Managers can't invite managers.");
        continue;
      }
      d(C);
      continue;
    }
    if (s === "adminInvite") {
      if (C.value !== "admin") {
        r.markInvalid("AdminInvites can only create admins.");
        continue;
      }
    } else if (s === "managerInvite") {
      if (C.value !== "manager") {
        r.markInvalid("managerInvite can only create managers.");
        continue;
      }
    } else if (s === "writerInvite") {
      if (C.value !== "writer") {
        r.markInvalid("WriterInvites can only create writers.");
        continue;
      }
    } else if (s === "readerInvite") {
      if (C.value !== "reader") {
        r.markInvalid("ReaderInvites can only create reader.");
        continue;
      }
    } else if (s === "writeOnlyInvite") {
      if (C.value !== "writeOnly") {
        r.markInvalid("WriteOnlyInvites can only create writeOnly.");
        continue;
      }
    } else {
      r.markInvalid("Group transaction must be made by current admin, manager, or invite");
      continue;
    }
    o.setDirectRole(c, C.value), r.markValid();
  }
}
function OC(i, A) {
  return i === A.id && A instanceof Ng ? A.currentAgentID() : i;
}
function PC(i) {
  return i.startsWith("writeKeyFor_");
}
function jC(i) {
  return i.slice(12);
}
function vs(i) {
  return i.startsWith("key_") && i.includes("_for_key");
}
function VC(i) {
  return i.startsWith("key_") && (i.includes("_for_sealer") || i.includes("_for_co")) || i.includes("_for_everyone");
}
function WC(i) {
  return i.startsWith("parent_");
}
function zC(i) {
  return i.startsWith("child_");
}
function $C(i, A, e) {
  if (Object.keys(e).length === 0)
    return !1;
  const t = i.slice(0, i.indexOf("_for_"));
  return e[A] === t;
}
const PA = "everyone";
function ZC(i) {
  const A = i.get("readKey");
  if (!A || !Vi(i, PA) || i.get(`${A}_for_${PA}`))
    return;
  if (Vi(i, i.core.node.getCurrentAgent().id)) {
    const g = i.getReadKey(A);
    g && i.set(`${A}_for_${PA}`, g, "trusting");
    return;
  }
  const t = i.keys().filter((g) => g.startsWith("key_") && g.endsWith("_for_everyone"));
  let o = t[0];
  for (const g of t) {
    if (!o) {
      o = g;
      continue;
    }
    const r = i.getRaw(g), n = i.getRaw(o);
    r && n && r.madeAt > n.madeAt && (o = g);
  }
  o && (i._lastReadableKeyId = o.replace("_for_everyone", ""));
}
class _C {
  constructor() {
    this.changes = [];
  }
  addChange(A, e) {
    const t = this.changes, o = { madeAt: A, value: e };
    let g = t.length;
    for (; g > 0 && t[g - 1].madeAt > A; )
      g--;
    g === t.length ? t.push(o) : t.splice(g, 0, o);
  }
  getLatest() {
    return this.changes[this.changes.length - 1]?.value;
  }
  getAtTime(A) {
    return A === void 0 ? this.getLatest() : this.changes.findLast((e) => e.madeAt <= A)?.value;
  }
}
class Sg extends mg {
  resetInternalState() {
    super.resetInternalState(), this.parentGroupsChanges = /* @__PURE__ */ new Map(), this.keyRevelations = /* @__PURE__ */ new Map(), this._lastReadableKeyId = void 0;
  }
  constructor(A, e) {
    super(A, e), this.crypto = A.node.crypto, this.migrate();
  }
  // We override the handleNewTransaction hook from CoMap to build the parent group cache
  // and key revelations cache
  handleNewTransaction(A) {
    this.parentGroupsChanges || (this.parentGroupsChanges = /* @__PURE__ */ new Map()), this.keyRevelations || (this.keyRevelations = /* @__PURE__ */ new Map());
    for (const e of A.changes) {
      const t = e;
      t.op === "set" && (Fs(t.key) ? this.updateParentGroupCache(t.key, t.value, A.madeAt) : vs(t.key) && this.updateKeyRevelationsCache(t.key));
    }
  }
  updateKeyRevelationsCache(A) {
    const e = A.split("_for_");
    if (e.length === 2) {
      const t = e[0], o = e[1];
      let g = this.keyRevelations.get(t);
      g || (g = /* @__PURE__ */ new Set(), this.keyRevelations.set(t, g)), g.add(o);
    }
  }
  updateParentGroupCache(A, e, t) {
    const o = A.substring(7);
    let g = this.parentGroupsChanges.get(o);
    g || (g = new _C(), this.parentGroupsChanges.set(o, g)), g.addChange(t, e);
  }
  migrate() {
    if (!this.core.isGroup())
      return;
    const A = () => {
      ZC(this);
    };
    this.core.isCompletelyDownloaded() ? A() : this.core.waitFor({
      predicate: (e) => e.isCompletelyDownloaded(),
      onSuccess: A
    });
  }
  /**
   * Returns the current role of a given account.
   *
   * @category 1. Role reading
   */
  roleOf(A) {
    return this.roleOfInternal(A);
  }
  /**
   *  This is a performance-critical function, micro-optimizing it is important
   *
   *  Avoid to add objects/array allocations in this function
   */
  /** @internal */
  roleOfInternal(A) {
    let e = this.get(A);
    e === "revoked" && (e = void 0);
    let t = e;
    for (const [o, g] of this.parentGroupsChanges.entries()) {
      const r = g.getAtTime(this.atTimeFilter);
      if (!r || r === "revoked")
        continue;
      const s = this.getParentGroup(o, this.atTimeFilter).roleOfInternal(A);
      if (!Us(s))
        continue;
      const a = r !== "extend" ? r : s;
      XC(a, t) && (t = a);
    }
    if (!t && A !== "everyone") {
      const o = this.get("everyone");
      if (o && o !== "revoked")
        return o;
    }
    return t;
  }
  getParentGroup(A, e) {
    const t = this.core.node.expectCoValueLoaded(A, "Expected parent group to be loaded"), o = DA(t.getCurrentContent());
    return e ? o.atTime(e) : o;
  }
  getParentGroups() {
    const A = [];
    for (const [e, t] of this.parentGroupsChanges.entries()) {
      const o = t.getAtTime(this.atTimeFilter);
      !o || o === "revoked" || A.push(this.getParentGroup(e, this.atTimeFilter));
    }
    return A;
  }
  forEachChildGroup(A) {
    for (const e of this.core.dependant) {
      const t = this.core.node.getCoValue(e);
      if (!t.isGroup())
        continue;
      const o = DA(t.getCurrentContent()), g = o.get(`parent_${this.id}`);
      g && g !== "revoked" && A(o);
    }
  }
  /**
   * Returns the role of the current account in the group.
   *
   * @category 1. Role reading
   */
  myRole() {
    return this.roleOfInternal(this.core.node.getCurrentAccountOrAgentID());
  }
  /**
   * Directly grants a new member a role in the group. The current account must be an
   * admin to be able to do so. Throws otherwise.
   *
   * @category 2. Role changing
   */
  addMember(A, e) {
    this.addMemberInternal(A, e);
  }
  /** @internal */
  addMemberInternal(A, e) {
    const t = typeof A == "string" ? A : A.id, o = this.get(t);
    if (o === e)
      return;
    if (t === PA) {
      if (!(e === "reader" || e === "writer" || e === "writeOnly"))
        throw new Error("Can't make everyone something other than reader, writer or writeOnly");
      const r = this.getCurrentReadKey();
      if (!r.secret)
        throw new Error("Can't add member without read key secret");
      const n = this.get(t);
      if (this.set(t, e, "trusting"), this.get(t) !== e)
        throw new Error(`Failed to set role ${e} to ${t} (role of current account is ${this.myRole()})`);
      e === "writeOnly" ? ((n === "reader" || n === "writer") && this.rotateReadKey("everyone"), this.delete(`${r.id}_for_${PA}`)) : this.set(`${r.id}_for_${PA}`, r.secret, "trusting");
      return;
    }
    const g = typeof A == "string" ? A : A.currentAgentID();
    if (g === PA)
      throw new Error("Agent should not be everyone");
    if (e === "writeOnly" || e === "writeOnlyInvite") {
      if ((o === "reader" || o === "writer" || o === "manager" || o === "admin") && this.rotateReadKey(t), this.set(t, e, "trusting"), this.get(t) !== e)
        throw new Error(`Failed to set role ${e} to ${t} (role of current account is ${this.myRole()})`);
      this.internalCreateWriteOnlyKeyForMember(t, g);
    } else {
      const r = this.getCurrentReadKey();
      if (!r.secret)
        throw new Error("Can't add member without read key secret");
      if (this.set(t, e, "trusting"), this.get(t) !== e)
        throw new Error(`Failed to set role ${e} to ${t} (role of current account is ${this.myRole()})`);
      this.storeKeyRevelationForMember(t, g, r.id, r.secret);
      for (const n of this.getWriteOnlyKeys()) {
        const s = this.core.getReadKey(n);
        if (!s) {
          Z.error("Can't find key " + n);
          continue;
        }
        this.storeKeyRevelationForMember(t, g, n, s);
      }
    }
  }
  internalCreateWriteOnlyKeyForMember(A, e) {
    const t = this.crypto.newRandomKeySecret();
    this.set(`writeKeyFor_${A}`, t.id, "trusting"), this.storeKeyRevelationForMember(A, e, t.id, t.secret);
    for (const o of this.getMemberKeys()) {
      const g = this.get(o);
      if (g === "reader" || g === "writer" || g === "admin" || g === "manager" || g === "readerInvite" || g === "writerInvite" || g === "adminInvite") {
        const r = this.core.node.resolveAccountAgent(o, "Expected member agent to be loaded").value;
        if (!r)
          throw new Error("Expected member agent to be loaded");
        this.storeKeyRevelationForMember(o, r, t.id, t.secret);
      }
    }
    for (const o of this.getParentGroups())
      this.revealReadKeyToParentGroup(o, t.id, t.secret, { revealAllWriteOnlyKeys: !1 });
    return t.id;
  }
  storeKeyRevelationForMember(A, e, t, o) {
    this.set(`${t}_for_${A}`, this.crypto.seal({
      message: o,
      from: this.core.node.getCurrentAgent().currentSealerSecret(),
      to: this.crypto.getAgentSealerID(e),
      nOnceMaterial: {
        in: this.id,
        tx: this.core.nextTransactionID()
      }
    }), "trusting");
  }
  storeKeyRevelationForParentGroup(A, e, t, o) {
    this.set(`${t}_for_${A}`, this.crypto.encryptKeySecret({
      encrypting: {
        id: A,
        secret: e
      },
      toEncrypt: {
        id: t,
        secret: o
      }
    }).encrypted, "trusting");
  }
  getWriteOnlyKeys() {
    const A = [];
    for (const e of this.keys())
      e.startsWith("writeKeyFor_") && A.push(this.get(e));
    return A;
  }
  getCurrentReadKeyId() {
    if (this._lastReadableKeyId)
      return this._lastReadableKeyId;
    const A = this.myRole();
    if (A === "writeOnly") {
      const e = this.core.node.getCurrentAgent().id, t = this.get(`writeKeyFor_${e}`);
      return !t && this.get("everyone") === "writeOnly" ? (this.internalCreateWriteOnlyKeyForMember(e, this.core.node.getCurrentAgent().currentAgentID()), this.get(`writeKeyFor_${e}`)) : t;
    }
    if (!A) {
      const e = this.core.node.getCurrentAgent().id, t = this.get(`writeKeyFor_${e}`);
      if (t)
        return t;
    }
    return this.get("readKey");
  }
  getMemberKeys() {
    return this.keys().filter((A) => A.startsWith("co_") || Oe(A));
  }
  getAllMemberKeysSet() {
    const A = new Set(this.getMemberKeys());
    for (const e of this.getParentGroups())
      for (const t of e.getAllMemberKeysSet())
        A.add(t);
    return A;
  }
  getReadKey(A) {
    const e = this.core.readKeyCache;
    let t = e.get(A);
    return t || (t = this.getUncachedReadKey(A), t && e.set(A, t)), t;
  }
  getUncachedReadKey(A) {
    const e = this.core, t = this.get(`${A}_for_everyone`);
    if (t)
      return t;
    const o = vA(e.node.currentSessionID), g = Dg(o) && e.id === o ? e.node.crypto.getAgentID(e.node.agentSecret) : o, r = this.lastEditAt(`${A}_for_${g}`);
    if (r?.value) {
      const s = r.by, a = e.node.resolveAccountAgent(s, "Expected to know revealer").value;
      if (!a)
        throw new Error("Expected to know revealer");
      const I = this.crypto.unseal(
        r.value,
        this.crypto.getAgentSealerSecret(e.node.agentSecret),
        // being careful here to avoid recursion
        this.crypto.getAgentSealerID(a),
        {
          in: this.id,
          tx: r.tx
        }
      );
      if (I)
        return I;
    }
    const n = this.keyRevelations.get(A);
    if (n)
      for (const s of n) {
        const a = this.getReadKey(s);
        if (!a)
          continue;
        const I = this.get(`${A}_for_${s}`), C = this.crypto.decryptKeySecret({
          encryptedID: A,
          encryptingID: s,
          encrypted: I
        }, a);
        if (C)
          return C;
        Z.warn(`Encrypting ${s} key didn't decrypt ${A}`);
      }
    for (const s of this.parentGroupsChanges.keys()) {
      const a = e.node.expectCoValueLoaded(s, "Expected parent group to be loaded"), I = this.findValidParentKeys(A, a);
      for (const C of I) {
        const c = this.get(`${A}_for_${C.id}`);
        if (c) {
          const Q = a.node.crypto.decryptKeySecret({
            encryptedID: A,
            encryptingID: C.id,
            encrypted: c
          }, C.secret);
          if (Q)
            return Q;
          Z.warn(`Encrypting parent ${C.id} key didn't decrypt ${A}`);
        }
      }
    }
  }
  findValidParentKeys(A, e) {
    const t = [], o = this.keyRevelations.get(A);
    if (o)
      for (const g of o) {
        const r = e.getReadKey(g);
        r && t.push({
          id: g,
          secret: r
        });
      }
    return t;
  }
  /** @internal */
  rotateReadKey(A) {
    if (A !== PA && Vi(this, PA))
      return;
    const e = this.getMemberKeys().filter((a) => a !== A), t = e.filter((a) => Vi(this, a)), o = e.filter((a) => {
      const I = this.get(a);
      return I === "writeOnly" || I === "writeOnlyInvite";
    }), g = this.getParentGroups(), r = this.getCurrentReadKey();
    if (!r.secret)
      throw new Br("Can't rotate read key secret we don't have access to");
    const n = {
      id: r.id,
      secret: r.secret
    }, s = this.crypto.newRandomKeySecret();
    for (const a of t) {
      const I = this.core.node.resolveAccountAgent(a, "Expected to know currently permitted reader").value;
      if (!I)
        throw new Error("Expected to know currently permitted reader");
      this.storeKeyRevelationForMember(a, I, s.id, s.secret);
    }
    for (const a of o) {
      const I = this.core.node.resolveAccountAgent(a, "Expected to know writeOnly member").value;
      if (!I)
        throw new Error("Expected to know writeOnly member");
      const C = this.crypto.newRandomKeySecret();
      this.storeKeyRevelationForMember(a, I, C.id, C.secret), this.set(`writeKeyFor_${a}`, C.id, "trusting");
      for (const c of t) {
        const Q = this.core.node.resolveAccountAgent(c, "Expected to know currently permitted reader").value;
        if (!Q)
          throw new Error("Expected to know currently permitted reader");
        this.storeKeyRevelationForMember(c, Q, C.id, C.secret);
      }
      for (const c of this.getParentGroups())
        this.revealReadKeyToParentGroup(c, C.id, C.secret, { revealAllWriteOnlyKeys: !1 });
    }
    this.set(`${n.id}_for_${s.id}`, this.crypto.encryptKeySecret({
      encrypting: s,
      toEncrypt: n
    }).encrypted, "trusting"), this.set("readKey", s.id, "trusting");
    for (const a of g) {
      const { id: I, secret: C } = a.getCurrentReadKey();
      if (!C) {
        Z.warn("Can't reveal new child key to parent where we don't have access to the parent read key");
        continue;
      }
      this.storeKeyRevelationForParentGroup(I, C, s.id, s.secret);
    }
    this.forEachChildGroup((a) => {
      if (!a.isSelfExtension(this))
        try {
          a.rotateReadKey(A);
        } catch (I) {
          if (I instanceof Br)
            Z.warn(`Can't rotate read key on child ${a.id} because we don't have access to the read key`);
          else
            throw I;
        }
    });
  }
  /** Detect circular references in group inheritance */
  isSelfExtension(A) {
    return Js(this.core, A);
  }
  getCurrentReadKey() {
    const A = this.getCurrentReadKeyId();
    if (!A)
      throw new Error("No readKey set");
    return {
      secret: this.getReadKey(A),
      id: A
    };
  }
  extend(A, e = "inherit") {
    if (this.isSelfExtension(A))
      return;
    if (this.myRole() !== "admin")
      throw new Error("To extend a group, the current account must be an admin in the child group");
    const t = e === "inherit" ? "extend" : e;
    this.set(`parent_${A.id}`, t, "trusting");
    const { id: o, secret: g } = this.getCurrentReadKey();
    if (g === void 0)
      throw new Error("Can't extend group without child read key secret");
    this.revealReadKeyToParentGroup(A, o, g, { revealAllWriteOnlyKeys: !0 });
  }
  revealReadKeyToParentGroup(A, e, t, { revealAllWriteOnlyKeys: o }) {
    let g;
    cr(A.myRole()) || (g = A.internalCreateWriteOnlyKeyForMember(this.core.node.getCurrentAgent().id, this.core.node.getCurrentAgent().currentAgentID()));
    let { id: r, secret: n } = A.getCurrentReadKey();
    if (!n)
      throw new Error("Can't extend group without parent read key secret");
    if (this.storeKeyRevelationForParentGroup(r, n, e, t), o)
      for (const s of this.getWriteOnlyKeys()) {
        if (s === g)
          continue;
        const a = this.core.getReadKey(s);
        if (!a) {
          Z.error("Can't find key " + s);
          continue;
        }
        this.storeKeyRevelationForParentGroup(r, n, s, a);
      }
  }
  revokeExtend(A) {
    if (this.myRole() !== "admin")
      throw new Error("To unextend a group, the current account must be an admin in the child group");
    if (!cr(A.myRole()))
      throw new Error("To unextend a group, the current account must be a member of the parent group");
    !this.get(`parent_${A.id}`) || this.get(`parent_${A.id}`) === "revoked" || (this.set(`parent_${A.id}`, "revoked", "trusting"), A.get(`child_${this.id}`) && A.set(`child_${this.id}`, "revoked", "trusting"), this.rotateReadKey());
  }
  /**
   * Strips the specified member of all roles (preventing future writes in
   *  the group and owned values) and rotates the read encryption key for that group
   * (preventing reads of new content in the group and owned values)
   *
   * @category 2. Role changing
   */
  removeMember(A) {
    const e = typeof A == "string" ? A : A.id;
    if ((this.myRole() === "admin" || this.myRole() === "manager") && this.rotateReadKey(e), this.set(e, "revoked", "trusting"), this.get(e) !== "revoked")
      throw new Error(`Failed to revoke role to ${e} (role of current account is ${this.myRole()})`);
  }
  /**
   * Creates an invite for new members to indirectly join the group,
   * allowing them to grant themselves the specified role with the InviteSecret
   * (a string starting with "inviteSecret_") - use `LocalNode.acceptInvite()` for this purpose.
   *
   * @category 2. Role changing
   */
  createInvite(A) {
    const e = this.crypto.newRandomSecretSeed(), t = this.crypto.agentSecretFromSecretSeed(e), o = this.crypto.getAgentID(t);
    return this.addMemberInternal(o, `${A}Invite`), Ac(e);
  }
  /**
   * Creates a new `CoMap` within this group, with the specified specialized
   * `CoMap` type `M` and optional static metadata.
   *
   * @category 3. Value creation
   */
  createMap(A, e, t = "private", o = this.crypto.createdNowUnique()) {
    const g = this.core.node.createCoValue({
      type: "comap",
      ruleset: {
        type: "ownedByGroup",
        group: this.id
      },
      meta: e || null,
      ...o.createdAt !== void 0 ? { createdAt: o.createdAt } : {},
      uniqueness: o.uniqueness
    }).getCurrentContent();
    return A ? g.assign(A, t) : o.createdAt || g.core.makeTransaction([], "trusting"), g;
  }
  /**
   * Creates a new `CoList` within this group, with the specified specialized
   * `CoList` type `L` and optional static metadata.
   *
   * @category 3. Value creation
   */
  createList(A, e, t = "private", o = this.crypto.createdNowUnique()) {
    const g = this.core.node.createCoValue({
      type: "colist",
      ruleset: {
        type: "ownedByGroup",
        group: this.id
      },
      meta: e || null,
      ...o.createdAt !== void 0 ? { createdAt: o.createdAt } : {},
      uniqueness: o.uniqueness
    }).getCurrentContent();
    return A?.length ? g.appendItems(A, void 0, t) : o.createdAt || g.core.makeTransaction([], "trusting"), g;
  }
  /**
   * Creates a new `CoPlainText` within this group, with the specified specialized
   * `CoPlainText` type `T` and optional static metadata.
   *
   * @category 3. Value creation
   */
  createPlainText(A, e, t = "private") {
    const o = this.core.node.createCoValue({
      type: "coplaintext",
      ruleset: {
        type: "ownedByGroup",
        group: this.id
      },
      meta: e || null,
      ...this.crypto.createdNowUnique()
    }).getCurrentContent();
    return A && o.insertAfter(0, A, t), o;
  }
  /** @category 3. Value creation */
  createStream(A, e = this.crypto.createdNowUnique()) {
    const t = this.core.node.createCoValue({
      type: "costream",
      ruleset: {
        type: "ownedByGroup",
        group: this.id
      },
      meta: A || null,
      ...e.createdAt !== void 0 ? { createdAt: e.createdAt } : {},
      uniqueness: e.uniqueness
    }).getCurrentContent();
    return e.createdAt || t.core.makeTransaction([], "trusting"), t;
  }
  /** @category 3. Value creation */
  createBinaryStream(A = { type: "binary" }, e = this.crypto.createdNowUnique()) {
    return this.core.node.createCoValue({
      type: "costream",
      ruleset: {
        type: "ownedByGroup",
        group: this.id
      },
      meta: A,
      ...e.createdAt !== void 0 ? { createdAt: e.createdAt } : {},
      uniqueness: e.uniqueness
    }).getCurrentContent();
  }
}
function Us(i) {
  return i === "revoked" || i === "admin" || i === "manager" || i === "writer" || i === "reader";
}
function XC(i, A) {
  return i === "revoked" ? !0 : i === "manager" ? !A || A !== "manager" && A !== "admin" : i === "admin" ? !A || A !== "admin" : i === "writer" ? !A || A === "reader" || A === "writeOnly" : i === "reader" ? !A : !1;
}
function Ac(i) {
  return `inviteSecret_z${NA.encode(i)}`;
}
function ec(i) {
  if (!i.startsWith("inviteSecret_z"))
    throw new Error("Invalid invite secret");
  return NA.decode(i.slice(14));
}
const Vi = (i, A) => {
  const e = i.get(A);
  return e === "admin" || e === "manager" || e === "writer" || e === "reader" || e === "adminInvite" || e === "writerInvite" || e === "readerInvite";
};
class Br extends Error {
  constructor(A) {
    super(A), this.name = "NoReadKeyAccessError";
  }
}
function Js(i, A) {
  const e = /* @__PURE__ */ new Set(), t = [A];
  for (; ; ) {
    const o = t.pop();
    if (!o)
      return !1;
    if (o.id === i.id)
      return !0;
    e.add(o.id);
    const g = o.getParentGroups();
    for (const r of g)
      e.has(r.id) || t.push(r);
  }
}
function Hs(i, A) {
  return {
    type: "comap",
    ruleset: { type: "group", initialAdmin: A.getAgentID(i) },
    meta: {
      type: "account"
    },
    createdAt: null,
    uniqueness: null
  };
}
class Ng extends Sg {
  currentAgentID() {
    if (this._cachedCurrentAgentID)
      return this._cachedCurrentAgentID;
    const A = this.core.verified.header;
    if (A.ruleset.type !== "group")
      throw new Error("You can't get an agent id from a non-group value");
    const e = A.ruleset.initialAdmin;
    if (!Oe(e))
      throw new Error("You can read agent ids only from account values");
    return this._cachedCurrentAgentID = e, e;
  }
  createInvite(A) {
    throw new Error("Cannot create invite from an account");
  }
  roleOfInternal(A) {
    return A === this.id ? "admin" : super.roleOfInternal(A);
  }
  addMember(A, e) {
    throw new Error("Cannot add a member to an account");
  }
  removeMember(A) {
    throw new Error("Cannot remove a member from an account");
  }
  extend(A, e = "inherit") {
    throw new Error("Cannot extend an account");
  }
  revokeExtend(A) {
    throw new Error("Cannot unextend an account");
  }
}
class tc {
  constructor(A, e) {
    this.account = A, this.agentSecret = e, this.crypto = A.core.node.crypto;
  }
  get id() {
    return this.account.id;
  }
  currentAgentID() {
    return this.crypto.getAgentID(this.agentSecret);
  }
  currentSignerID() {
    return this.crypto.getAgentSignerID(this.currentAgentID());
  }
  currentSignerSecret() {
    return this.crypto.getAgentSignerSecret(this.agentSecret);
  }
  currentSealerID() {
    return this.crypto.getAgentSealerID(this.currentAgentID());
  }
  currentSealerSecret() {
    return this.crypto.getAgentSealerSecret(this.agentSecret);
  }
}
class Qr {
  constructor(A, e) {
    this.agentSecret = A, this.crypto = e;
  }
  get id() {
    return this.crypto.getAgentID(this.agentSecret);
  }
  currentAgentID() {
    return this.crypto.getAgentID(this.agentSecret);
  }
  currentSignerID() {
    return this.crypto.getAgentSignerID(this.currentAgentID());
  }
  currentSignerSecret() {
    return this.crypto.getAgentSignerSecret(this.agentSecret);
  }
  currentSealerID() {
    return this.crypto.getAgentSealerID(this.currentAgentID());
  }
  currentSealerSecret() {
    return this.crypto.getAgentSealerSecret(this.agentSecret);
  }
}
function Er(i) {
  if (!(i instanceof Ng))
    throw new Error("Expected an account");
  return i;
}
function qs(i, A = "") {
  let e = (
    /** @type {Array<CategorizedUnicodeRange<T>>} */
    []
  ), t = i.split(",").map((g) => g ? parseInt(g, 36) : 0), o = 0;
  for (let g = 0; g < t.length; g++)
    g % 2 ? e.push([
      o,
      o + t[g],
      /** @type {T} */
      A ? parseInt(A[g >> 1], 36) : 0
    ]) : o = t[g];
  return e;
}
function Ls(i, A) {
  let e = 0, t = A.length - 1;
  for (; e <= t; ) {
    let o = e + t >> 1, g = A[o], r = g[0], n = g[1];
    if (r <= i && i <= n) return o;
    i > n ? e = o + 1 : t = o - 1;
  }
  return -1;
}
function ic(i) {
  return i <= 65535;
}
const lr = qs(
  /** @type {UnicodeDataEncoding} */
  ",9,a,,b,1,d,,e,h,3j,w,4p,,4t,,4u,,lc,33,w3,6,13l,18,14v,,14x,1,150,1,153,,16o,5,174,a,17g,,18r,k,19s,,1cm,6,1ct,,1cv,5,1d3,1,1d6,3,1e7,,1e9,,1f4,q,1ie,a,1kb,8,1kt,,1li,3,1ln,8,1lx,2,1m1,4,1nd,2,1ow,1,1p3,8,1qi,n,1r6,,1r7,v,1s3,,1tm,,1tn,,1to,,1tq,2,1tt,7,1u1,3,1u5,,1u6,1,1u9,6,1uq,1,1vl,,1vm,1,1x8,,1xa,,1xb,1,1xd,3,1xj,1,1xn,1,1xp,,1xz,,1ya,1,1z2,,1z5,1,1z7,,20s,,20u,2,20x,1,213,1,217,2,21d,,228,1,22d,,22p,1,22r,,24c,,24e,2,24h,4,24n,1,24p,,24r,1,24t,,25e,1,262,5,269,,26a,1,27w,,27y,1,280,,281,3,287,1,28b,1,28d,,28l,2,28y,1,29u,,2bi,,2bj,,2bk,,2bl,1,2bq,2,2bu,2,2bx,,2c7,,2dc,,2dd,2,2dg,,2f0,,2f2,2,2f5,3,2fa,2,2fe,3,2fp,1,2g2,1,2gx,,2gy,1,2ik,,2im,,2in,1,2ip,,2iq,,2ir,1,2iu,2,2iy,3,2j9,1,2jm,1,2k3,,2kg,1,2ki,1,2m3,1,2m6,,2m7,1,2m9,3,2me,2,2mi,2,2ml,,2mm,,2mv,,2n6,1,2o1,,2o2,1,2q2,,2q7,,2q8,1,2qa,2,2qe,,2qg,6,2qn,,2r6,1,2sx,,2sz,,2t0,6,2tj,7,2wh,,2wj,,2wk,8,2x4,6,2zc,1,305,,307,,309,,30e,1,31t,d,327,,328,4,32e,1,32l,a,32x,z,346,,371,3,375,,376,5,37d,1,37f,1,37h,1,386,1,388,1,38e,2,38x,3,39e,,39g,,39h,1,39p,,3a5,,3cw,2n,3fk,1z,3hk,2f,3tp,2,4k2,3,4ky,2,4lu,1,4mq,1,4ok,1,4om,,4on,6,4ou,7,4p2,,4p3,1,4p5,a,4pp,,4qz,2,4r2,,4r3,,4ud,1,4vd,,4yo,2,4yr,3,4yv,1,4yx,2,4z4,1,4z6,,4z7,5,4zd,2,55j,1,55l,1,55n,,579,,57a,,57b,,57c,6,57k,,57m,,57p,7,57x,5,583,9,58f,,59s,u,5c0,3,5c4,,5dg,9,5dq,3,5du,2,5ez,8,5fk,1,5fm,,5gh,,5gi,3,5gm,1,5go,5,5ie,,5if,,5ig,1,5ii,2,5il,,5im,,5in,4,5k4,7,5kc,7,5kk,1,5km,1,5ow,2,5p0,c,5pd,,5pe,6,5pp,,5pw,,5pz,,5q0,1,5vk,1r,6bv,,6bw,,6bx,,6by,1,6co,6,6d8,,6dl,,6e8,f,6hc,w,6jm,,6k9,,6ms,5,6nd,1,6xm,1,6y0,,70o,,72n,,73d,a,73s,2,79e,,7fu,1,7g6,,7gg,,7i3,3,7i8,5,7if,b,7is,35,7m8,39,7pk,a,7pw,,7py,,7q5,,7q9,,7qg,,7qr,1,7r8,,7rb,,7rg,,7ri,,7rn,2,7rr,,7s3,4,7th,2,7tt,,7u8,,7un,,850,1,8hx,2,8ij,1,8k0,,8k5,,8vj,2,8zj,,928,v,9ii,5,9io,,9j1,,9ll,1,9zr,,9zt,,wvj,3,wvo,9,wwu,1,wz4,1,x6q,,x6u,,x6z,,x7n,1,x7p,1,x7r,,x7w,,xa8,1,xbo,f,xc4,1,xcw,h,xdr,,xeu,7,xfr,a,xg2,,xg3,,xgg,s,xhc,2,xhf,,xir,,xis,1,xiu,3,xiy,1,xj0,1,xj2,1,xj4,,xk5,,xm1,5,xm7,1,xm9,1,xmb,1,xmd,1,xmr,,xn0,,xn1,,xoc,,xps,,xpu,2,xpz,1,xq6,1,xq9,,xrf,,xrg,1,xri,1,xrp,,xrq,,xyb,1,xyd,,xye,1,xyg,,xyh,1,xyk,,xyl,,xz4,,xz5,q,xzw,,xzx,q,y0o,,y0p,q,y1g,,y1h,q,y28,,y29,q,y30,,y31,q,y3s,,y3t,q,y4k,,y4l,q,y5c,,y5d,q,y64,,y65,q,y6w,,y6x,q,y7o,,y7p,q,y8g,,y8h,q,y98,,y99,q,ya0,,ya1,q,yas,,yat,q,ybk,,ybl,q,ycc,,ycd,q,yd4,,yd5,q,ydw,,ydx,q,yeo,,yep,q,yfg,,yfh,q,yg8,,yg9,q,yh0,,yh1,q,yhs,,yht,q,yik,,yil,q,yjc,,yjd,q,yk4,,yk5,q,ykw,,ykx,q,ylo,,ylp,q,ymg,,ymh,q,yn8,,yn9,q,yo0,,yo1,q,yos,,yot,q,ypk,,ypl,q,yqc,,yqd,q,yr4,,yr5,q,yrw,,yrx,q,yso,,ysp,q,ytg,,yth,q,yu8,,yu9,q,yv0,,yv1,q,yvs,,yvt,q,ywk,,ywl,q,yxc,,yxd,q,yy4,,yy5,q,yyw,,yyx,q,yzo,,yzp,q,z0g,,z0h,q,z18,,z19,q,z20,,z21,q,z2s,,z2t,q,z3k,,z3l,q,z4c,,z4d,q,z54,,z55,q,z5w,,z5x,q,z6o,,z6p,q,z7g,,z7h,q,z88,,z89,q,z90,,z91,q,z9s,,z9t,q,zak,,zal,q,zbc,,zbd,q,zc4,,zc5,q,zcw,,zcx,q,zdo,,zdp,q,zeg,,zeh,q,zf8,,zf9,q,zg0,,zg1,q,zgs,,zgt,q,zhk,,zhl,q,zic,,zid,q,zj4,,zj5,q,zjw,,zjx,q,zko,,zkp,q,zlg,,zlh,q,zm8,,zm9,q,zn0,,zn1,q,zns,,znt,q,zok,,zol,q,zpc,,zpd,q,zq4,,zq5,q,zqw,,zqx,q,zro,,zrp,q,zsg,,zsh,q,zt8,,zt9,q,zu0,,zu1,q,zus,,zut,q,zvk,,zvl,q,zwc,,zwd,q,zx4,,zx5,q,zxw,,zxx,q,zyo,,zyp,q,zzg,,zzh,q,1008,,1009,q,1010,,1011,q,101s,,101t,q,102k,,102l,q,103c,,103d,q,1044,,1045,q,104w,,104x,q,105o,,105p,q,106g,,106h,q,1078,,1079,q,1080,,1081,q,108s,,108t,q,109k,,109l,q,10ac,,10ad,q,10b4,,10b5,q,10bw,,10bx,q,10co,,10cp,q,10dg,,10dh,q,10e8,,10e9,q,10f0,,10f1,q,10fs,,10ft,q,10gk,,10gl,q,10hc,,10hd,q,10i4,,10i5,q,10iw,,10ix,q,10jo,,10jp,q,10kg,,10kh,q,10l8,,10l9,q,10m0,,10m1,q,10ms,,10mt,q,10nk,,10nl,q,10oc,,10od,q,10p4,,10p5,q,10pw,,10px,q,10qo,,10qp,q,10rg,,10rh,q,10s8,,10s9,q,10t0,,10t1,q,10ts,,10tt,q,10uk,,10ul,q,10vc,,10vd,q,10w4,,10w5,q,10ww,,10wx,q,10xo,,10xp,q,10yg,,10yh,q,10z8,,10z9,q,1100,,1101,q,110s,,110t,q,111k,,111l,q,112c,,112d,q,1134,,1135,q,113w,,113x,q,114o,,114p,q,115g,,115h,q,1168,,1169,q,1170,,1171,q,117s,,117t,q,118k,,118l,q,119c,,119d,q,11a4,,11a5,q,11aw,,11ax,q,11bo,,11bp,q,11cg,,11ch,q,11d8,,11d9,q,11e0,,11e1,q,11es,,11et,q,11fk,,11fl,q,11gc,,11gd,q,11h4,,11h5,q,11hw,,11hx,q,11io,,11ip,q,11jg,,11jh,q,11k8,,11k9,q,11l0,,11l1,q,11ls,,11lt,q,11mk,,11ml,q,11nc,,11nd,q,11o4,,11o5,q,11ow,,11ox,q,11po,,11pp,q,11qg,,11qh,q,11r8,,11r9,q,11s0,,11s1,q,11ss,,11st,q,11tk,,11tl,q,11uc,,11ud,q,11v4,,11v5,q,11vw,,11vx,q,11wo,,11wp,q,11xg,,11xh,q,11y8,,11y9,q,11z0,,11z1,q,11zs,,11zt,q,120k,,120l,q,121c,,121d,q,1224,,1225,q,122w,,122x,q,123o,,123p,q,124g,,124h,q,1258,,1259,q,1260,,1261,q,126s,,126t,q,127k,,127l,q,128c,,128d,q,1294,,1295,q,129w,,129x,q,12ao,,12ap,q,12bg,,12bh,q,12c8,,12c9,q,12d0,,12d1,q,12ds,,12dt,q,12ek,,12el,q,12fc,,12fd,q,12g4,,12g5,q,12gw,,12gx,q,12ho,,12hp,q,12ig,,12ih,q,12j8,,12j9,q,12k0,,12k1,q,12ks,,12kt,q,12lk,,12ll,q,12mc,,12md,q,12n4,,12n5,q,12nw,,12nx,q,12oo,,12op,q,12pg,,12ph,q,12q8,,12q9,q,12r0,,12r1,q,12rs,,12rt,q,12sk,,12sl,q,12tc,,12td,q,12u4,,12u5,q,12uw,,12ux,q,12vo,,12vp,q,12wg,,12wh,q,12x8,,12x9,q,12y0,,12y1,q,12ys,,12yt,q,12zk,,12zl,q,130c,,130d,q,1314,,1315,q,131w,,131x,q,132o,,132p,q,133g,,133h,q,1348,,1349,q,1350,,1351,q,135s,,135t,q,136k,,136l,q,137c,,137d,q,1384,,1385,q,138w,,138x,q,139o,,139p,q,13ag,,13ah,q,13b8,,13b9,q,13c0,,13c1,q,13cs,,13ct,q,13dk,,13dl,q,13ec,,13ed,q,13f4,,13f5,q,13fw,,13fx,q,13go,,13gp,q,13hg,,13hh,q,13i8,,13i9,q,13j0,,13j1,q,13js,,13jt,q,13kk,,13kl,q,13lc,,13ld,q,13m4,,13m5,q,13mw,,13mx,q,13no,,13np,q,13og,,13oh,q,13p8,,13p9,q,13q0,,13q1,q,13qs,,13qt,q,13rk,,13rl,q,13sc,,13sd,q,13t4,,13t5,q,13tw,,13tx,q,13uo,,13up,q,13vg,,13vh,q,13w8,,13w9,q,13x0,,13x1,q,13xs,,13xt,q,13yk,,13yl,q,13zc,,13zd,q,1404,,1405,q,140w,,140x,q,141o,,141p,q,142g,,142h,q,1438,,1439,q,1440,,1441,q,144s,,144t,q,145k,,145l,q,146c,,146d,q,1474,,1475,q,147w,,147x,q,148o,,148p,q,149g,,149h,q,14a8,,14a9,q,14b0,,14b1,q,14bs,,14bt,q,14ck,,14cl,q,14dc,,14dd,q,14e4,,14e5,q,14ew,,14ex,q,14fo,,14fp,q,14gg,,14gh,q,14h8,,14h9,q,14i0,,14i1,q,14is,,14it,q,14jk,,14jl,q,14kc,,14kd,q,14l4,,14l5,q,14lw,,14lx,q,14mo,,14mp,q,14ng,,14nh,q,14o8,,14o9,q,14p0,,14p1,q,14ps,,14pt,q,14qk,,14ql,q,14rc,,14rd,q,14s4,,14s5,q,14sw,,14sx,q,14to,,14tp,q,14ug,,14uh,q,14v8,,14v9,q,14w0,,14w1,q,14ws,,14wt,q,14xk,,14xl,q,14yc,,14yd,q,14z4,,14z5,q,14zw,,14zx,q,150o,,150p,q,151g,,151h,q,1528,,1529,q,1530,,1531,q,153s,,153t,q,154k,,154l,q,155c,,155d,q,1564,,1565,q,156w,,156x,q,157o,,157p,q,158g,,158h,q,1598,,1599,q,15a0,,15a1,q,15as,,15at,q,15bk,,15bl,q,15cc,,15cd,q,15d4,,15d5,q,15dw,,15dx,q,15eo,,15ep,q,15fg,,15fh,q,15g8,,15g9,q,15h0,,15h1,q,15hs,,15ht,q,15ik,,15il,q,15jc,,15jd,q,15k4,,15k5,q,15kw,,15kx,q,15lo,,15lp,q,15mg,,15mh,q,15n8,,15n9,q,15o0,,15o1,q,15os,,15ot,q,15pk,,15pl,q,15qc,,15qd,q,15r4,,15r5,q,15rw,,15rx,q,15so,,15sp,q,15tg,,15th,q,15u8,,15u9,q,15v0,,15v1,q,15vs,,15vt,q,15wk,,15wl,q,15xc,,15xd,q,15y4,,15y5,q,15yw,,15yx,q,15zo,,15zp,q,160g,,160h,q,1618,,1619,q,1620,,1621,q,162s,,162t,q,163k,,163l,q,164c,,164d,q,1654,,1655,q,165w,,165x,q,166o,,166p,q,167g,,167h,q,1688,,1689,q,1690,,1691,q,169s,,169t,q,16ak,,16al,q,16bc,,16bd,q,16c4,,16c5,q,16cw,,16cx,q,16do,,16dp,q,16eg,,16eh,q,16f8,,16f9,q,16g0,,16g1,q,16gs,,16gt,q,16hk,,16hl,q,16ic,,16id,q,16j4,,16j5,q,16jw,,16jx,q,16ko,,16kp,q,16ls,m,16mj,1c,1dlq,,1e68,f,1e74,f,1edb,,1ehq,1,1ek0,b,1eyl,,1f4w,,1f92,4,1gjl,2,1gjp,1,1gjw,3,1gl4,2,1glb,,1gpx,1,1h5w,3,1h7t,4,1hgr,1,1hj0,3,1hl2,a,1hmq,3,1hq8,,1hq9,,1hqa,,1hrs,e,1htc,,1htf,1,1htr,2,1htu,,1hv4,2,1hv7,3,1hvb,1,1hvd,1,1hvh,,1hvm,,1hvx,,1hxc,2,1hyf,4,1hyk,,1hyl,7,1hz9,1,1i0j,,1i0w,1,1i0y,,1i2b,2,1i2e,8,1i2n,,1i2o,,1i2q,1,1i2x,3,1i32,,1i33,,1i5o,2,1i5r,2,1i5u,1,1i5w,3,1i66,,1i69,,1ian,,1iao,2,1iar,7,1ibk,1,1ibm,1,1id7,1,1ida,,1idb,,1idc,,1idd,3,1idj,1,1idn,1,1idp,,1idz,,1iea,1,1iee,6,1ieo,4,1igo,,1igp,1,1igr,5,1igy,,1ih1,,1ih3,2,1ih6,,1ih8,1,1iha,2,1ihd,,1ihe,,1iht,1,1ik5,2,1ik8,7,1ikg,1,1iki,2,1ikl,,1ikm,,1ila,,1ink,,1inl,1,1inn,5,1int,,1inu,,1inv,1,1inx,,1iny,,1inz,1,1io1,,1io2,1,1iun,,1iuo,1,1iuq,3,1iuw,3,1iv0,1,1iv2,,1iv3,1,1ivw,1,1iy8,2,1iyb,7,1iyj,1,1iyl,,1iym,,1iyn,1,1j1n,,1j1o,,1j1p,,1j1q,1,1j1s,7,1j4t,,1j4u,,1j4v,,1j4y,3,1j52,,1j53,4,1jcc,2,1jcf,8,1jco,,1jcp,1,1jjk,,1jjl,4,1jjr,1,1jjv,3,1jjz,,1jk0,,1jk1,,1jk2,,1jk3,,1jo1,2,1jo4,3,1joa,1,1joc,3,1jog,,1jok,,1jpd,9,1jqr,5,1jqx,,1jqy,,1jqz,3,1jrb,,1jrl,5,1jrr,1,1jrt,2,1jt0,5,1jt6,c,1jtj,,1jtk,1,1k4v,,1k4w,6,1k54,5,1k5a,,1k5b,,1k7m,l,1k89,,1k8a,6,1k8h,,1k8i,1,1k8k,,1k8l,1,1kc1,5,1kca,,1kcc,1,1kcf,6,1kcm,,1kcn,,1kei,4,1keo,1,1ker,1,1ket,,1keu,,1kev,,1koj,1,1kol,1,1kow,1,1koy,,1koz,,1kqc,1,1kqe,4,1kqm,1,1kqo,2,1kre,,1ovk,f,1ow0,,1ow7,e,1xr2,b,1xre,2,1xrh,2,1zow,4,1zqo,6,206b,,206f,3,20jz,,20k1,1i,20lr,3,20o4,,20og,1,2ftp,1,2fts,3,2jgg,19,2jhs,m,2jxh,4,2jxp,5,2jxv,7,2jy3,7,2jyd,6,2jze,3,2k3m,2,2lmo,1i,2lob,1d,2lpx,,2lqc,,2lqz,4,2lr5,e,2mtc,6,2mtk,g,2mu3,6,2mub,1,2mue,4,2mxb,,2n1s,6,2nce,,2ne4,3,2nsc,3,2nzi,1,2ok0,6,2on8,6,2pz4,73,2q6l,2,2q7j,,2q98,5,2q9q,1,2qa6,,2qa9,9,2qb1,1k,2qcm,p,2qdd,e,2qe2,,2qen,,2qeq,8,2qf0,3,2qfd,c1,2qrf,4,2qrk,8t,2r0m,7d,2r9c,3j,2rg4,b,2rit,16,2rkc,3,2rm0,7,2rmi,5,2rns,7,2rou,29,2rrg,1a,2rss,9,2rt3,c8,2scg,sd,jny8,v,jnz4,2n,jo1s,3j,jo5c,6n,joc0,2rz",
  "262122424333333393233393339333333333393393b3b3b3b3b333b33b3bb33333b3b3333333b3b33bb3333b33b3bb33333b3bbb333b333b33333b3b3b3b3333b3b33b3bb39333b33b33b3b3b333b333333b3b333333b33b3b3333b3335dc333333b3b3b33323333b3bb3b33b3b3b3333b3333b3b333bb3b33b3b3b3b3b333b333b3323e2244234444444444444444444444444444444444444444443333443443333333b3b3bb33333b353b3b3b3b333b3b333b333333b3bb3b3b3bb3787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878dc333232333333333333333b3b3333bb3b393933b3b33bb3b393b3b3b3333b33b33b3bbb33b333b3333bb3933b3b3b333b3b3b3b3b33b3b3b33b3b3b33b3b33b33b3b3b33bb39b9b3b33b3b33b9333b393b3b33b33b3b3b3333393b3b3b33b39bb3b332333b333dd3b33332333323333333333333333333333344444444a44444434444444444444423232"
), oc = qs(
  /** @type {UnicodeDataEncoding} */
  "1sl,10,1ug,7,1vc,7,1w5,j,1wq,6,1wy,,1x2,3,1y4,1,1y7,,1yo,1,239,j,23u,6,242,1,245,4,261,,26t,j,27e,6,27m,1,27p,4,28s,1,28v,,29d,,2dx,j,2ei,f,2fs,2,2l1,11"
);
function* gc(i) {
  if (i === "")
    return;
  let A = 0, e = i.length, t = null, o = null, g = null, r = [
    0,
    0,
    2
    /* GC_Control */
  ], n = 0, s = !1, a = !1, I = !1, C = !1, c = (
    /** @type number */
    i.codePointAt(A)
  ), Q = 0, d = "";
  for (; ; ) {
    if (d += i[A++], ic(c) || (d += i[A++]), t = o, t === null && (t = dr(c, r), g = t), !a && t === 0 ? a = hr(c) : t === 3 && (I = rc(c)), A < e)
      c = /** @type {number} */
      i.codePointAt(A), o = dr(c, r);
    else {
      yield {
        segment: d,
        index: Q,
        input: i,
        _catBegin: (
          /** @type {typeof catBefore} */
          g
        ),
        _catEnd: t
      };
      return;
    }
    t === 10 ? n += 1 : (n = 0, o === 14 && (t === 3 || t === 4) ? s = !0 : o === 0 && (C = a && I && (a = hr(c)), I = I && !a)), nc(t, o, n, s, C) && (yield {
      segment: d,
      index: Q,
      input: i,
      _catBegin: (
        /** @type {typeof catBefore} */
        g
      ),
      _catEnd: t
    }, Q = A, d = "", s = !1, C = !1, g = o);
  }
}
function* po(i) {
  for (let A of gc(i)) yield A.segment;
}
function dr(i, A) {
  if (i < 127)
    return i >= 32 ? 0 : i === 10 ? 6 : i === 13 ? 1 : 2;
  if (i < A[0] || i > A[1]) {
    let e = Ls(i, lr);
    if (e < 0)
      return 0;
    let t = lr[e];
    A[0] = t[0], A[1] = t[1], A[2] = t[2];
  }
  return A[2];
}
function hr(i) {
  return Ls(i, oc) >= 0;
}
function rc(i) {
  return i === 2381 || i === 2509 || i === 2765 || i === 2893 || i === 3149 || i === 3405;
}
function nc(i, A, e, t, o) {
  return i === 1 && A === 6 ? !1 : i === 1 || i === 2 || i === 6 || A === 1 || A === 2 || A === 6 ? !0 : i === 5 && (A === 5 || A === 7 || A === 8 || A === 13) || (i === 7 || i === 13) && (A === 12 || A === 13) || A === 12 && (i === 8 || i === 12) || A === 3 || A === 14 || A === 11 || i === 9 || A === 0 && o ? !1 : i === 14 && A === 4 ? !t : i === 10 && A === 10 ? e % 2 === 0 : !0;
}
const $o = {
  MAX_RECOMMENDED_TX_SIZE: 100 * 1024
}, Pe = {
  MAX_RETRIES: 1,
  TIMEOUT: 6e4,
  RETRY_DELAY: 3e3,
  MAX_IN_FLIGHT_LOADS_PER_PEER: 1e3
}, sc = {
  INCOMING_MESSAGES_TIME_BUDGET: 50
}, ur = {
  MAX_AGE: 1e3 * 60 * 10,
  // 10 minutes
  INTERVAL: 1e3 * 60 * 5
  // 5 minutes
}, ac = {
  MAX_OUTGOING_MESSAGES_CHUNK_BYTES: 25e3
};
function fr(i) {
  return `${i.sessionID}:${i.txIndex}:${i.changeIdx}`;
}
class Mg extends kt {
  constructor(A, e) {
    super(A, e), this.type = "coplaintext", this._cachedMapping = /* @__PURE__ */ new WeakMap();
  }
  get mapping() {
    const A = this.entries();
    let e = this._cachedMapping.get(A);
    if (e)
      return e;
    e = {
      opIDbeforeIdx: [],
      opIDafterIdx: [],
      idxAfterOpID: {},
      idxBeforeOpID: {}
    };
    let t = 0;
    for (const o of A) {
      const g = t + 1;
      e.opIDafterIdx[t] = o.opID, e.opIDbeforeIdx[g] = o.opID, e.idxAfterOpID[fr(o.opID)] = g, e.idxBeforeOpID[fr(o.opID)] = t, t = g;
    }
    return this._cachedMapping.set(A, e), e;
  }
  toString() {
    return this.entries().map((A) => A.value).join("");
  }
  atTime(A) {
    return new Mg(this.core, A);
  }
  /**
   * Inserts `text` before the character at index `idx`.
   * If idx is 0, inserts at the start of the text.
   *
   * @param idx - The index of the character to insert before
   * @param text - The text to insert
   * @param privacy - Whether the operation should be private or trusting
   * @category 2. Editing
   */
  insertBefore(A, e, t = "private") {
    const o = Array.from(po(e));
    if (A === 0) {
      const g = o[0];
      g && this.prepend(g, 0, t), o.length > 1 && this.appendChars(o.slice(1), 0, t);
    } else
      this.appendChars(o, A - 1, t);
  }
  appendChars(A, e, t = "private") {
    const o = Ic(A);
    for (const g of o)
      this.appendItems(g, e, t), e += g.length;
  }
  /**
   * Inserts `text` after the character at index `idx`.
   *
   * @param idx - The index of the character to insert after
   * @param text - The text to insert
   * @param privacy - Whether the operation should be private or trusting
   * @category 2. Editing
   */
  insertAfter(A, e, t = "private") {
    const o = Array.from(po(e));
    A >= this.entries().length ? this.appendChars(o, A - 1, t) : this.appendChars(o, A, t);
  }
  deleteRange({ from: A, to: e }, t = "private") {
    const o = [];
    for (let g = A; g < e; ) {
      const r = this.mapping.opIDafterIdx[g];
      if (!r)
        throw new Error("Invalid idx to delete " + g);
      o.push({
        op: "del",
        insertion: r
      });
      let n = g + 1;
      for (; !this.mapping.opIDbeforeIdx[n] && n < e; )
        n++;
      g = n;
    }
    this.core.makeTransaction(o, t), this.processNewTransactions();
  }
  /** @internal Helper method to split text into graphemes */
  toGraphemes(A) {
    return [...po(A)];
  }
  /** @internal Helper method to join graphemes into a string */
  fromGraphemes(A) {
    return A.join("");
  }
}
function Ic(i) {
  const A = Math.ceil($o.MAX_RECOMMENDED_TX_SIZE / 200), e = [];
  for (let t = 0; t < i.length; t += A)
    e.push(i.slice(t, t + A));
  return e;
}
function Cc(i, A) {
  return i.verified.header.type === "comap" ? i.verified.header.ruleset.type === "group" ? i.verified.header.meta?.type === "account" && !A?.ignorePrivateTransactions ? new Ng(i) : new Sg(i, A) : new mg(i) : i.verified.header.type === "coplaintext" ? new Mg(i) : i.verified.header.type === "colist" ? new kt(i) : i.verified.header.type === "costream" ? i.verified.header.meta && i.verified.header.meta.type === "binary" ? new Ys(i) : new Ks(i) : new pC(i);
}
function Gg(i, A = /* @__PURE__ */ new Set()) {
  return i.ruleset.type === "ownedByGroup" && A.add(i.ruleset.group), i.meta?.source && A.add(i.meta.source), A;
}
function xs(i, A) {
  for (const e of i) {
    const t = vA(e);
    Dg(t) && A.add(t);
  }
}
function kg(i, A = /* @__PURE__ */ new Set()) {
  for (const e of i) {
    if (e.privacy !== "trusting")
      continue;
    const t = Qc(e.changes);
    for (const o of t)
      if (o && typeof o == "object" && "op" in o && o.op === "set" && "key" in o && o.key) {
        const g = UC(o.key);
        g && A.add(g);
      }
  }
  return A;
}
function cc(i, A, e, t) {
  const o = /* @__PURE__ */ new Set();
  if (Gg(A, o), xs(e, o), A.ruleset.type === "group")
    for (const g of t)
      kg(g, o);
  return o.delete(i), o;
}
function Bc(i, A) {
  const e = /* @__PURE__ */ new Set();
  A.header && Gg(A.header, e);
  const t = Object.keys(A.new);
  if (xs(t, e), (i.verified?.header ?? A.header)?.ruleset.type === "group")
    for (const { newTransactions: g } of Object.values(A.new))
      kg(g, e);
  return e.delete(i.id), e;
}
function Qc(i) {
  try {
    return ji(i);
  } catch {
    return [];
  }
}
function ke(i) {
  return {
    id: i,
    header: !1,
    sessions: {}
  };
}
function Do(i) {
  return {
    id: i.id,
    header: i.header,
    sessions: i.sessions
  };
}
function mo(i, A) {
  return ze(i.sessions, A.sessions), A.header && !i.header && (i.header = !0), i;
}
function ze(i, A) {
  for (const [e, t] of Object.entries(A)) {
    const o = i[e] || 0;
    t > o && (i[e] = t);
  }
  return i;
}
function So(i, A, e) {
  i[A] = e;
}
function wr(i, A, e) {
  i[A] = Math.max(i[A] || 0, e);
}
function ue(i) {
  return {
    id: i.id,
    header: i.header,
    sessions: { ...i.sessions }
  };
}
function Ts(i, A) {
  for (const [e, t] of Object.entries(i)) {
    const o = A[e] ?? 0;
    if (t !== o)
      return !1;
  }
  return !0;
}
function Zo(i, A) {
  for (const [e, t] of Object.entries(i)) {
    const o = A[e] ?? 0;
    if (t > o)
      return !1;
  }
  return !0;
}
function Ec(i, A) {
  return !A || !A.header && i.header ? !1 : Zo(i.sessions, A.sessions);
}
function Os(i, A) {
  const e = {};
  for (const [t, o] of Object.entries(i)) {
    const g = A[t] ?? 0;
    o > g && (e[t] = o);
  }
  return e;
}
const KA = {
  HIGH: 0,
  MEDIUM: 3,
  LOW: 6
};
function lc(i) {
  return typeof i == "boolean" || !i ? KA.MEDIUM : i.meta?.type === "account" || i.ruleset.type === "group" ? KA.HIGH : i.type === "costream" && i.meta?.type === "binary" ? KA.LOW : KA.MEDIUM;
}
function dt(i, A, e = !0) {
  return {
    action: "content",
    id: i,
    header: e ? A : void 0,
    priority: lc(A),
    new: {}
  };
}
function No(i, A, e, t, o) {
  const g = i.new[e];
  g ? (g.newTransactions.push(A), g.lastSignature = t) : i.new[e] = {
    after: o,
    newTransactions: [A],
    lastSignature: t
  };
}
function eo(i) {
  return i.privacy === "private" ? i.encryptedChanges.length : i.changes.length;
}
function Wi(i, A) {
  return A === void 0 ? i > $o.MAX_RECOMMENDED_TX_SIZE : i + A > $o.MAX_RECOMMENDED_TX_SIZE;
}
function Ht(i) {
  const A = ke(i.id);
  A.header = !!i.header;
  for (const [e, t] of Object.entries(i.new))
    A.sessions[e] = t.after + t.newTransactions.length;
  return A;
}
function dc(i) {
  return Object.values(i.new).reduce((A, e) => A + e.newTransactions.reduce((t, o) => t + eo(o), 0), 0);
}
function Mo(i) {
  return Object.entries(i.new).map(([A, e]) => `Session: ${A} After: ${e.after} New: ${e.newTransactions.length}`);
}
function hc(i, A, e) {
  const t = A.sessions[e] ?? 0, o = i.after;
  if (t < o)
    return;
  const g = t - o;
  return i.newTransactions.slice(g);
}
function uc(i) {
  return Object.entries(i.new);
}
class to {
  constructor(A, e, t) {
    this.id = A, this.crypto = e, this.isDeleted = !1, this.sessions = /* @__PURE__ */ new Map(), this.knownState = { id: this.id, header: !0, sessions: {} }, t && (this.streamingKnownState = { ...t }, this.knownStateWithStreaming = {
      id: this.id,
      header: !0,
      sessions: { ...t }
    });
  }
  markAsDeleted() {
    this.isDeleted = !0, this.knownState = { id: this.id, header: !0, sessions: {} }, this.knownStateWithStreaming = void 0, this.streamingKnownState = void 0, this.invalidateKnownStateCache();
    for (const [A, e] of this.sessions.entries())
      Ne(A) && (this.knownState.sessions[A] = e.transactions.length);
  }
  setStreamingKnownState(A) {
    if (this.isDeleted || Zo(A, this.knownState.sessions))
      return;
    const e = Os(A, this.knownState.sessions);
    this.streamingKnownState ? ze(this.streamingKnownState, e) : this.streamingKnownState = e, this.knownStateWithStreaming || (this.knownStateWithStreaming = ue(this.knownState)), ze(this.knownStateWithStreaming.sessions, e);
  }
  invalidateKnownStateCache() {
    this.immutableKnownState = void 0, this.immutableKnownStateWithStreaming = void 0;
  }
  getImmutableKnownState() {
    return this.immutableKnownState || (this.immutableKnownState = ue(this.knownState)), this.immutableKnownState;
  }
  getImmutableKnownStateWithStreaming() {
    return this.knownStateWithStreaming ? (this.immutableKnownStateWithStreaming || (this.immutableKnownStateWithStreaming = ue(this.knownStateWithStreaming)), this.immutableKnownStateWithStreaming) : this.getImmutableKnownState();
  }
  get(A) {
    return this.sessions.get(A);
  }
  getOrCreateSessionLog(A, e) {
    let t = this.sessions.get(A);
    return t || (t = {
      signerID: e,
      impl: this.crypto.createSessionLog(this.id, A, e),
      transactions: [],
      lastSignature: void 0,
      signatureAfter: {},
      txSizeSinceLastInbetweenSignature: 0,
      sessionID: A
    }, this.sessions.set(A, t)), t;
  }
  addTransaction(A, e, t, o, g = !1) {
    if (this.isDeleted && !Ne(A))
      throw new Error("Cannot add transactions to a deleted coValue");
    const r = this.getOrCreateSessionLog(A, e);
    r.impl.tryAdd(t, o, g), this.addTransactionsToJsLog(r, t, o);
  }
  makeNewPrivateTransaction(A, e, t, o, g, r, n) {
    if (this.isDeleted)
      throw new Error("Cannot make new private transaction on a deleted coValue");
    const s = this.getOrCreateSessionLog(A, e.currentSignerID()), a = s.impl.addNewPrivateTransaction(e, t, o, g, n, r);
    return this.addTransactionsToJsLog(s, [a.transaction], a.signature), a;
  }
  makeNewTrustingTransaction(A, e, t, o, g) {
    if (this.isDeleted)
      throw new Error("Cannot make new trusting transaction on a deleted coValue");
    const r = this.getOrCreateSessionLog(A, e.currentSignerID()), n = r.impl.addNewTrustingTransaction(e, t, g, o);
    return this.addTransactionsToJsLog(r, [n.transaction], n.signature), n;
  }
  addTransactionsToJsLog(A, e, t) {
    for (const g of e)
      A.transactions.push(g);
    A.lastSignature = t, A.txSizeSinceLastInbetweenSignature += e.reduce((g, r) => g + (r.privacy === "private" ? r.encryptedChanges.length : r.changes.length), 0);
    const o = A.transactions.length;
    Wi(A.txSizeSinceLastInbetweenSignature) && (A.signatureAfter[o - 1] = t, A.txSizeSinceLastInbetweenSignature = 0), wr(this.knownState.sessions, A.sessionID, o), this.streamingKnownState && Zo(this.streamingKnownState, this.knownState.sessions) && (this.streamingKnownState = void 0, this.knownStateWithStreaming = void 0), this.knownStateWithStreaming && wr(this.knownStateWithStreaming.sessions, A.sessionID, o), this.invalidateKnownStateCache();
  }
  decryptTransaction(A, e, t) {
    const o = this.sessions.get(A);
    if (!o)
      return;
    const g = o.impl.decryptNextTransactionChangesJson(e, t);
    if (g)
      return ji(g);
  }
  decryptTransactionMeta(A, e, t) {
    const o = this.sessions.get(A);
    if (!o?.transactions[e]?.meta)
      return;
    const g = o.impl.decryptNextTransactionMetaJson(e, t);
    if (g)
      return ji(g);
  }
  get size() {
    return this.sessions.size;
  }
  entries() {
    return this.sessions.entries();
  }
  values() {
    return this.sessions.values();
  }
  keys() {
    return this.sessions.keys();
  }
  clone() {
    const A = new to(this.id, this.crypto);
    for (const [e, t] of this.sessions)
      A.sessions.set(e, {
        impl: t.impl.clone(),
        transactions: t.transactions.slice(),
        lastSignature: t.lastSignature,
        signatureAfter: { ...t.signatureAfter },
        txSizeSinceLastInbetweenSignature: t.txSizeSinceLastInbetweenSignature,
        signerID: t.signerID,
        sessionID: e
      });
    return A.streamingKnownState = this.streamingKnownState ? { ...this.streamingKnownState } : void 0, A.knownState = ue(this.knownState), A.knownStateWithStreaming = this.knownStateWithStreaming ? ue(this.knownStateWithStreaming) : void 0, A;
  }
}
class Fg {
  constructor(A, e, t, o) {
    this.isDeleted = !1, this.id = A, this.crypto = e, this.header = t, this.sessions = o ?? new to(A, e), this.branchSourceId = t.meta?.source, this.branchName = t.meta?.branch;
  }
  clone() {
    return new Fg(this.id, this.crypto, this.header, this.sessions.clone());
  }
  markAsDeleted() {
    this.isDeleted = !0, this.sessions.markAsDeleted();
  }
  tryAddTransactions(A, e, t, o, g = !1) {
    this.sessions.addTransaction(A, e, t, o, g);
  }
  makeNewTrustingTransaction(A, e, t, o, g) {
    return this.sessions.makeNewTrustingTransaction(A, e, t, o, g);
  }
  makeNewPrivateTransaction(A, e, t, o, g, r, n) {
    return this.sessions.makeNewPrivateTransaction(A, e, t, o, g, r, n);
  }
  getLastSignatureCheckpoint(A) {
    const e = this.sessions.get(A);
    return e?.signatureAfter ? Object.keys(e.signatureAfter).reduce((t, o) => Math.max(t, parseInt(o)), -1) : -1;
  }
  setStreamingKnownState(A) {
    this.sessions.setStreamingKnownState(A);
  }
  newContentSince(A) {
    let e = dt(this.id, this.header, !1);
    const t = [e];
    let o = 0;
    const g = () => {
      e = dt(this.id, this.header, !1), t.push(e), o = 0;
    }, r = (C) => {
      const c = e.new[C];
      if (!c)
        throw new Error("Session content not found", {
          cause: {
            sessionID: C,
            currentPiece: e
          }
        });
      delete e.new[C];
      const Q = dt(this.id, this.header, !1);
      Q.new[C] = c, t.splice(t.length - 1, 0, Q);
    }, n = A?.sessions;
    for (const [C, c] of this.sessions.sessions) {
      if (this.isDeleted && !Ne(C))
        continue;
      const Q = n?.[C] ?? 0;
      let d = 0;
      for (let f = Q; f < c.transactions.length; f++) {
        const h = f === c.transactions.length - 1, l = c.transactions[f];
        d += eo(l);
        const B = c.signatureAfter[f];
        if (B)
          No(e, l, C, B, f), r(C), d = 0;
        else if (h) {
          if (!c.lastSignature)
            throw new Error("All the SessionLogs sent must have a lastSignature", {
              cause: c
            });
          No(e, l, C, c.lastSignature, f), Wi(d) ? (Go(C, e), r(C)) : Wi(o, d) ? (Go(C, e), g()) : o += d;
        } else
          No(e, l, C, void 0, f);
      }
      Go(C, e);
    }
    const s = t[0];
    if (!s)
      throw new Error("First piece not found", {
        cause: t
      });
    !A?.header && (s.header = this.header);
    const I = t.filter((C) => C.header || Object.keys(C.new).length > 0);
    if ((I.length > 1 || this.isStreaming()) && (A ? s.expectContentUntil = Os(this.knownStateWithStreaming().sessions, A.sessions) : s.expectContentUntil = {
      ...this.knownStateWithStreaming().sessions
    }), I.length !== 0)
      return I;
  }
  knownState() {
    return this.sessions.knownState;
  }
  knownStateWithStreaming() {
    return this.sessions.knownStateWithStreaming ?? this.knownState();
  }
  immutableKnownState() {
    return this.sessions.getImmutableKnownState();
  }
  immutableKnownStateWithStreaming() {
    return this.sessions.getImmutableKnownStateWithStreaming();
  }
  isStreaming() {
    return !!this.sessions.knownStateWithStreaming;
  }
  decryptTransaction(A, e, t) {
    return this.sessions.decryptTransaction(A, e, t);
  }
  decryptTransactionMeta(A, e, t) {
    return this.sessions.decryptTransactionMeta(A, e, t);
  }
}
function Go(i, A) {
  if (A.new[i] && !A.new[i].lastSignature)
    throw new Error("The SessionContent sent must have a lastSignature", {
      cause: A.new[i]
    });
}
function Ps({ type: i, branchName: A, ownerId: e, sourceId: t }) {
  return {
    type: i,
    // Branch name and source id are stored in the meta field
    // and used to generate the unique id for the branch
    meta: {
      branch: A,
      source: t
    },
    ruleset: {
      type: "ownedByGroup",
      // The owner is part of the id generation, making it possible to have multiple branches with the same name
      // but different owners
      group: e
    },
    // The meta is enough to have reproducible unique id for the branch
    uniqueness: ""
  };
}
function js(i) {
  return i.verified?.header.ruleset.type === "ownedByGroup";
}
function fc(i, A, e) {
  if (!i.verified)
    throw new Error("CoValueCore: getBranchId called on coValue without verified state");
  const t = e ?? Rg(i);
  if (!t)
    return i.id;
  const o = Ps({
    type: i.verified.header.type,
    branchName: A,
    ownerId: t,
    sourceId: i.id
  });
  return pt(o, i.node.crypto);
}
function Rg(i) {
  if (!i.verified)
    throw new Error("CoValueCore: getBranchOwnerId called on coValue without verified state");
  const A = i.verified.header;
  if (A.ruleset.type === "ownedByGroup")
    return A.ruleset.group;
}
function wc(i, A, e) {
  if (!i.verified)
    throw new Error("CoValueCore: createBranch called on coValue without verified state");
  const t = e ?? Rg(i);
  if (!t)
    return i;
  const o = i.safeGetGroup()?.myRole();
  if (!o || o === "reader" && !e)
    return Z.warn("Trying to create a branch without enough access rights, returning the source coValue"), i;
  const g = o === "reader" ? "trusting" : "private", r = Ps({
    type: i.verified.header.type,
    branchName: A,
    ownerId: t,
    sourceId: i.id
  }), n = i.node.createCoValue(r), s = { ...i.knownState().sessions };
  return n.makeTransaction([], "private", {
    from: s
  }), i.makeTransaction([], g, {
    branch: A,
    ownerId: e
  }), n;
}
function Vs(i) {
  if (!i.verified)
    return;
  const A = i.getCurrentBranchSourceId();
  if (!A)
    return;
  const e = i.node.getCoValue(A);
  if (e.isAvailable())
    return e;
}
function yc(i) {
  if (!i.verified)
    throw new Error("CoValueCore: mergeBranch called on coValue without verified state");
  if (!js(i))
    return i;
  const A = Vs(i);
  if (!A)
    throw new Error("CoValueCore: unable to find source branch");
  let e = {};
  for (const C of A.getMergeCommits())
    C.branch === i.id && ze(e, C.merged);
  const t = i.getValidTransactions({
    from: e,
    ignorePrivateTransactions: !1,
    skipBranchSource: !0
  }).filter((C) => C.changes.length > 0);
  if (t.length === 0)
    return A;
  let o, g, r = 0;
  const n = Date.now();
  for (const C of t) {
    const c = {
      mi: C.txID.txIndex
    };
    C.madeAt !== r && (c.t = n - C.madeAt), o !== C.txID.sessionID && (c.s = C.txID.sessionID), g !== C.txID.branch && (c.b = C.txID.branch), A.makeTransaction(C.changes, C.tx.privacy, c, n), o = C.txID.sessionID, g = C.txID.branch, r = C.madeAt;
  }
  const s = i.knownState().sessions, a = e, I = {};
  for (const [C, c] of Object.entries(s))
    (a[C] ?? 0) < c && (I[C] = c);
  return A.makeTransaction([], "private", {
    merged: I,
    branch: i.id
  }), A;
}
function pc(i, A) {
  if (!A.isValid || A.tx.privacy === "trusting")
    return;
  const e = !A.changes, t = !A.meta && A.tx.meta;
  if (!e && !t)
    return;
  const o = i.getReadKey(A.tx.keyUsed);
  if (o) {
    if (e) {
      const g = i.verified.decryptTransaction(A.txID.sessionID, A.txID.txIndex, o);
      g && (A.changes = g);
    }
    if (t) {
      const g = i.verified.decryptTransactionMeta(A.txID.sessionID, A.txID.txIndex, o);
      g && (A.meta = g);
    }
  }
}
var RA = function(i, A, e, t) {
  if (e === "a" && !t) throw new TypeError("Private accessor was defined without a getter");
  if (typeof A == "function" ? i !== A || !t : !A.has(i)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return e === "m" ? t : e === "a" ? t.call(i) : t ? t.value : A.get(i);
}, FA = function(i, A, e, t, o) {
  if (t === "m") throw new TypeError("Private method is not writable");
  if (t === "a" && !o) throw new TypeError("Private accessor was defined without a setter");
  if (typeof A == "function" ? i !== A || !o : !A.has(i)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return t === "a" ? o.call(i, e) : o ? o.value = e : A.set(i, e), e;
}, ye, Ee, le, Ws, _o, yr, pr, It, Ct, ct;
function Dc(i) {
  if (typeof i == "number" && !Number.isInteger(i))
    return {
      isOk: !1,
      message: "Uniqueness cannot be a non-integer number, got " + i
    };
  if (Array.isArray(i))
    return {
      isOk: !1,
      message: "Uniqueness cannot be an array, got " + i
    };
  if (typeof i == "object" && i !== null) {
    for (let [A, e] of Object.entries(i))
      if (typeof e != "string")
        return {
          isOk: !1,
          message: "Uniqueness object values must be a string, got " + e + " for key " + A
        };
  }
  return { isOk: !0 };
}
function pt(i, A) {
  return `co_z${A.shortHash(i).slice(11)}`;
}
class mc {
  constructor(A, e, t, o, g, r, n, s) {
    this.isValidated = !1, this.isValid = !1, this.validationErrorMessage = void 0, this.dispatchTransaction = s, this.author = vA(e);
    const a = g ? {
      sessionID: e,
      txIndex: t,
      branch: g
    } : {
      sessionID: e,
      txIndex: t
    };
    this.coValueId = A, this.currentTxID = a, this.sourceTxID = void 0, this.tx = o, this.currentMadeAt = o.madeAt, this.sourceTxMadeAt = void 0, this.previous = n, r ? (this.changes = r.changes, this.meta = r.meta) : this.tx.privacy === "trusting" && (this.changes = zo(this.tx.changes), this.tx.meta && (this.meta = zo(this.tx.meta)));
  }
  // The TxID that refers to the current position in the session map
  // If this is a merged transaction, the txID is the TxID of the merged transaction
  get txID() {
    return this.sourceTxID ?? this.currentTxID;
  }
  // The madeAt that refers to the time when the transaction was made
  // If this is a merged transaction, the madeAt is the time when the transaction has been made in the branch
  get madeAt() {
    return this.sourceTxMadeAt ?? this.currentMadeAt;
  }
  isValidTransactionWithChanges() {
    return !!(this.isValid && this.changes);
  }
  markValid() {
    this.isValid = !0, this.validationErrorMessage = void 0, this.isValidated || (this.isValidated = !0, this.dispatchTransaction(this));
  }
  markInvalid(A, e) {
    this.isValidated = !0, this.isValid = !1, this.validationErrorMessage = A;
  }
}
class Dr {
  /** Holds the fundamental syncable content of a CoValue,
   * consisting of the header (verified by hash -> RawCoID)
   * and the sessions (verified by signature).
   *
   * It does not do any *validation* or *decryption* and as such doesn't
   * depend on other CoValues or the LocalNode.
   *
   * `CoValueCore.verified` may be null when a CoValue is requested to be
   * loaded but no content has been received from storage or peers yet.
   * In this case, it acts as a centralised entry to keep track of peer loading
   * state and to subscribe to its content when it does become available. */
  get verified() {
    return this._verified;
  }
  constructor(A, e) {
    ye.add(this), this.isDeleted = !1, this.loadingStatuses = /* @__PURE__ */ new Map(), Ee.set(this, void 0), le.set(this, void 0), this.listeners = /* @__PURE__ */ new Set(), this.missingDependencies = /* @__PURE__ */ new Set(), this.newContentQueue = [], It.set(this, !1), Ct.set(this, !1), ct.set(this, !1), this.mergeCommits = [], this.branches = [], this.earliestTxMadeAt = Number.MAX_SAFE_INTEGER, this.latestTxMadeAt = 0, this.verifiedTransactions = [], this.toValidateTransactions = [], this.toDecryptTransactions = [], this.toParseMetaTransactions = [], this.toProcessTransactions = [], this.verifiedTransactionsKnownSessions = {}, this.lastVerifiedTransactionBySessionID = {}, this.parsingCache = /* @__PURE__ */ new Map(), this.dispatchTransaction = (t) => {
      if (!t.isValidated) {
        this.toValidateTransactions.push(t);
        return;
      }
      t.changes ? this.toProcessTransactions.push(t) : this.toDecryptTransactions.push(t), t.meta && this.toParseMetaTransactions.push(t);
    }, this.dependencies = /* @__PURE__ */ new Set(), this.incompleteDependencies = /* @__PURE__ */ new Set(), this.dependant = /* @__PURE__ */ new Set(), this.readKeyCache = /* @__PURE__ */ new Map(), this.crypto = e.crypto, this.id = A, this._verified = null, this.node = e, this.counter = te.getMeter("cojson").createUpDownCounter("jazz.covalues.loaded", {
      description: "The number of covalues in the system",
      unit: "covalue",
      valueType: qA.INT
    }), this.updateCounter(null);
  }
  get loadingState() {
    if (this.verified)
      return "available";
    for (const A of this.loadingStatuses.values())
      if (A.type === "pending")
        return "loading";
    if (RA(this, Ee, "f"))
      return RA(this, Ee, "f");
    if (this.loadingStatuses.size === 0)
      return "unknown";
    for (const A of this.loadingStatuses.values())
      if (A.type === "unknown")
        return "unknown";
    return "unavailable";
  }
  hasMissingDependencies() {
    return this.missingDependencies.size > 0;
  }
  isAvailable() {
    return this.hasVerifiedContent();
  }
  isCompletelyDownloaded() {
    return !(!this.hasVerifiedContent() || this.isStreaming() || this.incompleteDependencies.size > 0);
  }
  isStreaming() {
    return this.verified?.isStreaming() ?? !1;
  }
  hasVerifiedContent() {
    return !!this.verified;
  }
  /**
   * Returns the CoValue data as NewContentMessage objects, excluding the transactions that are part of the given known state.
   *
   * Used to serialize the CoValue data to send it to peers and storage.
   */
  newContentSince(A) {
    return this.verified?.newContentSince(A);
  }
  isErroredInPeer(A) {
    return this.getLoadingStateForPeer(A) === "errored";
  }
  getErroredInPeerError(A) {
    const e = this.loadingStatuses.get(A);
    if (e?.type === "errored")
      return e.error;
  }
  waitFor(A) {
    const { predicate: e, onSuccess: t } = A;
    this.subscribe((o, g) => {
      e(o) && (g(), t(o));
    }, !0);
  }
  waitForAsync(A) {
    return new Promise((e) => {
      this.waitFor({ predicate: A, onSuccess: e });
    });
  }
  waitForAvailableOrUnavailable() {
    return this.waitForAsync((A) => A.isAvailable() || A.loadingState === "unavailable");
  }
  waitForAvailable() {
    return this.waitForAsync((A) => A.isAvailable());
  }
  waitForFullStreaming() {
    return this.waitForAsync((A) => A.isAvailable() && !A.isStreaming());
  }
  getLoadingStateForPeer(A) {
    return this.loadingStatuses.get(A)?.type ?? "unknown";
  }
  updateCounter(A) {
    const e = this.loadingState;
    A !== e && (A && this.counter.add(-1, { state: A }), this.counter.add(1, { state: e }));
  }
  /**
   * Removes the CoValue content from memory but keeps a shell with cached knownState.
   * This enables accurate LOAD requests during peer reconciliation.
   *
   * @returns true if the coValue was successfully unmounted, false otherwise
   */
  unmount() {
    return this.node.internalUnmountCoValue(this.id);
  }
  /**
   * Decrements the counter for the current loading state.
   * Used during unmount to properly track state transitions.
   * @internal
   */
  decrementLoadingStateCounter() {
    this.counter.add(-1, { state: this.loadingState });
  }
  markNotFoundInPeer(A) {
    const e = this.loadingState;
    this.loadingStatuses.set(A, { type: "unavailable" }), this.updateCounter(e), this.scheduleNotifyUpdate();
  }
  markFoundInPeer(A, e) {
    this.loadingStatuses.set(A, { type: "available" }), this.updateCounter(e), this.scheduleNotifyUpdate();
  }
  /**
   * Clean up cached state when CoValue becomes available.
   * Called after the CoValue transitions from garbageCollected/onlyKnownState to available.
   */
  cleanupLastKnownState() {
    FA(this, Ee, void 0, "f"), FA(this, le, void 0, "f");
  }
  /**
   * Initialize this CoValueCore as a garbageCollected shell.
   * Called when creating a replacement CoValueCore after unmounting.
   */
  setGarbageCollectedState(A) {
    if (!this.node.storage)
      return;
    const e = this.loadingState;
    FA(this, Ee, "garbageCollected", "f"), FA(this, le, A, "f"), this.updateCounter(e);
  }
  isCircularDependency(A) {
    if (A.id === this.id)
      return !0;
    const e = /* @__PURE__ */ new Set(), t = [A];
    for (; t.length > 0; ) {
      const o = t.pop();
      if (!o)
        return !1;
      e.add(o.id);
      for (const g of o.dependencies) {
        if (g === this.id)
          return !0;
        e.has(g) || t.push(this.node.getCoValue(g));
      }
    }
    return !1;
  }
  /**
   * Add a new content to the queue and handle it when the dependencies are available
   */
  addNewContentToQueue(A, e) {
    const t = this.newContentQueue.length > 0;
    this.newContentQueue.push({ msg: A, from: e }), !t && this.waitFor({
      predicate: (o) => !o.hasMissingDependencies(),
      onSuccess: () => {
        const o = this.newContentQueue;
        this.newContentQueue = [];
        for (const { msg: g, from: r } of o)
          this.node.syncManager.handleNewContent(g, r);
      }
    });
  }
  addDependencyFromHeader(A) {
    for (const e of Gg(A))
      this.addDependency(e);
  }
  provideHeader(A, e, t) {
    if (!t) {
      const o = Dc(A.uniqueness);
      if (!o.isOk)
        return Z.error("Invalid uniqueness", {
          header: A,
          errorMessage: o.message
        }), !1;
      const g = pt(A, this.node.crypto);
      if (this.id !== g)
        return !1;
    }
    if (this.addDependencyFromHeader(A), this._verified?.sessions.size)
      throw new Error("CoValueCore: provideHeader called on coValue with verified sessions present!");
    return this._verified = new Fg(this.id, this.node.crypto, A, new to(this.id, this.node.crypto, e)), this.isAvailable() && this.cleanupLastKnownState(), !0;
  }
  markErrored(A, e) {
    const t = this.loadingState;
    this.loadingStatuses.set(A, { type: "errored", error: e }), this.updateCounter(t), this.scheduleNotifyUpdate();
  }
  markPending(A) {
    const e = this.loadingState;
    this.loadingStatuses.set(A, { type: "pending" }), this.updateCounter(e), this.scheduleNotifyUpdate();
  }
  contentInClonedNodeWithDifferentAccount(A) {
    return this.node.loadCoValueAsDifferentAgent(this.id, A.agentSecret, A.id).then((e) => e.getCurrentContent());
  }
  /**
   * Returns the known state considering the known state of the streaming source
   *
   * Used to correctly manage the content & subscriptions during the content streaming process
   */
  knownStateWithStreaming() {
    return this.verified ? this.verified.immutableKnownStateWithStreaming() : this.knownState();
  }
  /**
   * Returns the known state of the CoValue
   *
   * The return value identity is going to be stable as long as the CoValue is not modified.
   *
   * On change the knownState is invalidated and a new object is returned.
   *
   * For garbageCollected/onlyKnownState CoValues, returns the cached knownState.
   */
  knownState() {
    return this.verified ? this.verified.immutableKnownState() : RA(this, le, "f") ? RA(this, le, "f") : ke(this.id);
  }
  /**
   * Returns a known state message to signal to the peer that the coValue doesn't need to be synced anymore
   *
   * Implemented to be backward compatible with clients that don't support deleted coValues
   */
  stopSyncingKnownStateMessage(A) {
    if (!A)
      return {
        action: "known",
        ...this.knownState()
      };
    const e = ue(this.knownState());
    return ze(e.sessions, A.sessions), {
      action: "known",
      ...e
    };
  }
  get meta() {
    return this.verified?.header.meta ?? null;
  }
  nextTransactionID() {
    if (!this.verified)
      throw new Error("CoValueCore: nextTransactionID called on coValue without verified state");
    const A = this.verified.header.meta?.type === "account" ? this.node.currentSessionID.replace(this.node.getCurrentAgent().id, this.node.getCurrentAgent().currentAgentID()) : this.node.currentSessionID;
    return {
      sessionID: A,
      txIndex: this.verified.sessions.get(A)?.transactions.length || 0
    };
  }
  addDependenciesFromContentMessage(A) {
    const e = Bc(this, A);
    for (const t of e)
      this.addDependency(t);
  }
  /**
   * Apply new transactions that were not generated by the current node to the CoValue
   */
  tryAddTransactions(A, e, t, o = !1) {
    if (e.length === 0)
      return;
    let g;
    if (this.isDeleted && !Ne(A))
      return {
        type: "CoValueDeleted",
        id: this.id,
        error: new Error("Cannot add transactions to a deleted coValue")
      };
    if (!o) {
      const n = this.node.resolveAccountAgent(vA(A), "Expected to know signer of transaction");
      if (n.error || !n.value)
        return {
          type: "ResolveAccountAgentError",
          id: this.id,
          error: n.error
        };
      g = this.crypto.getAgentSignerID(n.value);
    }
    if (!this.verified)
      return {
        type: "TriedToAddTransactionsWithoutVerifiedState",
        id: this.id,
        error: void 0
      };
    const r = RA(this, ye, "m", Ws).call(this, A, e, o);
    if (r.err)
      return r.err;
    try {
      this.verified.tryAddTransactions(A, g, e, t, o), r.value && RA(this, ye, "m", _o).call(this), this.processNewTransactions(), this.scheduleNotifyUpdate(), this.invalidateDependants();
    } catch (n) {
      return { type: "InvalidSignature", id: this.id, error: n };
    }
  }
  notifyDependants() {
    if (this.isGroup())
      for (const A of this.dependant)
        this.node.getCoValue(A).scheduleNotifyUpdate(), this.node.getCoValue(A).notifyDependants();
  }
  invalidateDependants() {
    if (this.isGroup())
      for (const A of this.dependant)
        this.node.getCoValue(A).resetParsedTransactions(), this.node.getCoValue(A).invalidateDependants();
  }
  processNewTransactions() {
    this._cachedContent && this._cachedContent.processNewTransactions();
  }
  scheduleNotifyUpdate() {
    this.listeners.size !== 0 && (FA(this, Ct, !0, "f"), RA(this, It, "f") || (FA(this, It, !0, "f"), queueMicrotask(() => {
      FA(this, It, !1, "f"), RA(this, Ct, "f") && this.notifyUpdate();
    })));
  }
  pauseNotifyUpdate() {
    FA(this, ct, !0, "f");
  }
  resumeNotifyUpdate() {
    FA(this, ct, !1, "f"), this.notifyUpdate();
  }
  notifyUpdate() {
    if (!(this.listeners.size === 0 || RA(this, ct, "f"))) {
      FA(this, Ct, !1, "f");
      for (const A of this.listeners)
        try {
          A(this, () => {
            this.listeners.delete(A);
          });
        } catch (e) {
          Z.error("Error in listener for coValue " + this.id, { err: e });
        }
    }
  }
  subscribe(A, e = !0) {
    return this.listeners.add(A), e && A(this, () => {
      this.listeners.delete(A);
    }), () => {
      this.listeners.delete(A);
    };
  }
  validateDeletePermissions() {
    if (!this.verified)
      return {
        ok: !1,
        reason: "CannotVerifyPermissions",
        message: "Cannot verify delete permissions without verified state"
      };
    if (this.isGroupOrAccount())
      return {
        ok: !1,
        reason: "CoValueNotDeletable",
        message: "Cannot delete Group or Account coValues"
      };
    const A = this.safeGetGroup();
    return A ? A.myRole() !== "admin" ? {
      ok: !1,
      reason: "NotAdmin",
      message: "The current account lacks admin permissions to delete this coValue"
    } : { ok: !0 } : {
      ok: !1,
      reason: "CannotVerifyPermissions",
      message: "Cannot verify delete permissions for coValues not owned by a group"
    };
  }
  /**
   * Creates a delete marker transaction for this CoValue and sets the coValue as deleted
   *
   * Constraints:
   * - Account and Group CoValues cannot be deleted.
   * - Only admins can delete a coValue.
   */
  deleteCoValue() {
    if (this.isDeleted)
      return;
    const A = this.validateDeletePermissions();
    if (!A.ok)
      throw new Error(A.message);
    this.makeTransaction(
      [],
      // Empty changes array
      "trusting",
      // Unencrypted
      { deleted: this.id }
    );
  }
  /**
   * Creates a new transaction with local changes and syncs it to all peers
   */
  makeTransaction(A, e, t, o) {
    if (!this.verified)
      throw new Error("CoValueCore: makeTransaction called on coValue without verified state");
    const g = !!t?.deleted;
    if (this.isDeleted && !g)
      return Z.error("Cannot make transaction on a deleted coValue", {
        id: this.id
      }), !1;
    let r = this.verified.header.meta?.type === "account" ? this.node.currentSessionID.replace(this.node.getCurrentAgent().id, this.node.getCurrentAgent().currentAgentID()) : this.node.currentSessionID;
    g && (r = this.crypto.newDeleteSessionID(this.node.getCurrentAccountOrAgentID()));
    const n = this.node.getCurrentAgent();
    let s;
    const a = this.knownState();
    if (e === "private") {
      const { secret: C, id: c } = this.getCurrentReadKey();
      if (!C)
        throw new Error("Can't make transaction without read key secret");
      s = this.verified.makeNewPrivateTransaction(r, n, A, c, C, t, o ?? Date.now());
    } else
      s = this.verified.makeNewTrustingTransaction(r, n, A, t, o ?? Date.now());
    g && RA(this, ye, "m", _o).call(this);
    const { transaction: I } = s;
    return this.parsingCache.set(I, { changes: A, meta: t }), this.node.syncManager.recordTransactionsSize([I], "local"), this.processNewTransactions(), this.addDependenciesFromNewTransaction(I), this.notifyUpdate(), this.node.syncManager.syncLocalTransaction(this.verified, a), o === void 0 ? this.notifyDependants() : this.invalidateDependants(), !0;
  }
  addDependenciesFromNewTransaction(A) {
    if (this.verified?.header.ruleset.type === "group")
      for (const e of kg([
        A
      ]))
        this.addDependency(e);
  }
  getCurrentContent(A) {
    if (!this.verified)
      throw new Error("CoValueCore: getCurrentContent called on coValue without verified state");
    if (!A?.ignorePrivateTransactions && this._cachedContent)
      return this._cachedContent;
    const e = Cc(this, A);
    return A?.ignorePrivateTransactions || (this._cachedContent = e), e;
  }
  // Reset the parsed transactions and branches, to validate them again from scratch when the group is updated
  resetParsedTransactions() {
    const A = this.verifiedTransactions;
    if (A.length === 0)
      return;
    this.branchStart = void 0, this.mergeCommits = [];
    const e = new Array(A.length);
    this.verifiedTransactions.forEach((o, g) => {
      o.isValidated = !1, e[g] = o.isValidTransactionWithChanges();
    }), this.toValidateTransactions = A.slice(), this.toProcessTransactions = [], this.toDecryptTransactions = [], this.toParseMetaTransactions = [], this.parseNewTransactions(!1), e.every((o, g) => o === A[g]?.isValidTransactionWithChanges()) || this._cachedContent?.rebuildFromCore(), this.scheduleNotifyUpdate();
  }
  /**
     * Loads the new transaction from the SessionMap into verifiedTransactions as a VerifiedTransaction.
     *
     * If the transaction is already loaded from the SessionMap in the past, it will not be loaded again.
     *
     * Used to have a fast way to iterate over the CoValue transactions, and track their validation/decoding state.
  
    * @internal
     * */
  loadVerifiedTransactionsFromLogs() {
    if (!this.verified)
      return;
    const A = this.isBranched();
    for (const [e, t] of this.verified.sessions.entries()) {
      const o = this.verifiedTransactionsKnownSessions[e] ?? 0;
      for (let g = o; g < t.transactions.length; g++) {
        const r = t.transactions[g];
        if (!r)
          continue;
        const n = this.parsingCache.get(r);
        n && this.parsingCache.delete(r);
        const s = new mc(this.id, e, g, r, A ? this.id : void 0, n, this.lastVerifiedTransactionBySessionID[e], this.dispatchTransaction);
        s.madeAt > this.latestTxMadeAt && (this.latestTxMadeAt = s.madeAt), s.madeAt < this.earliestTxMadeAt && (this.earliestTxMadeAt = s.madeAt), this.verifiedTransactions.push(s), this.dispatchTransaction(s), this.lastVerifiedTransactionBySessionID[e] = s;
      }
      this.verifiedTransactionsKnownSessions[e] = t.transactions.length;
    }
  }
  /**
   * Iterates over the verifiedTransactions and marks them as valid or invalid, based on the group membership of the authors of the transactions  .
   */
  determineValidTransactions() {
    qC(this), this.toValidateTransactions = [];
  }
  /**
   * Parses the meta information of a transaction, and set the branchStart and mergeCommits.
   */
  parseMetaInformation(A) {
    if (A.meta) {
      if (this.isBranched() && "from" in A.meta) {
        const e = A.meta;
        this.branchStart ? this.branchStart = ze(this.branchStart, e.from) : this.branchStart = e.from;
      }
      if ("branch" in A.meta) {
        const e = A.meta;
        this.branches.push(e);
      }
      if ("merged" in A.meta) {
        const e = A.meta;
        this.mergeCommits.push(e);
      }
      if ("mi" in A.meta) {
        const e = A.meta, t = A.previous, o = e.s ?? t?.txID.sessionID;
        e.t ? A.sourceTxMadeAt = A.currentMadeAt - e.t : t && (A.sourceTxMadeAt = t.madeAt), A.sourceTxMadeAt && A.sourceTxMadeAt > A.currentMadeAt && A.markInvalid("Transaction sourceMadeAt is after the currentMadeAt", {
          sourceTxMadeAt: A.sourceTxMadeAt,
          currentMadeAt: A.currentMadeAt
        }), o ? A.sourceTxID = {
          sessionID: o,
          txIndex: e.mi,
          branch: e.b ?? t?.txID.branch
        } : Z.error("Merge commit without session ID", {
          txID: A.txID,
          prevTxID: t?.txID ?? null
        });
      }
    }
  }
  /**
   * Loads the new transactions from SessionMap and:
   * - Validates each transaction based on the group membership of the authors
   * - Decodes the changes & meta for each transaction
   * - Parses the meta information of the transaction
   */
  parseNewTransactions(A) {
    if (!this.isAvailable())
      return;
    if (this.loadVerifiedTransactionsFromLogs(), this.determineValidTransactions(), !A) {
      const t = this.toDecryptTransactions;
      this.toDecryptTransactions = [];
      for (const o of t)
        pc(this, o), this.dispatchTransaction(o);
    }
    const e = this.toParseMetaTransactions;
    this.toParseMetaTransactions = [];
    for (const t of e)
      this.parseMetaInformation(t);
  }
  /**
   * Returns the valid transactions matching the criteria specified in the options
   */
  getValidTransactions(A) {
    if (!this.verified)
      return [];
    this.parseNewTransactions(A?.ignorePrivateTransactions ?? !1);
    const e = [], t = Vs(this), o = A?.from, g = A?.to, r = A?.knownTransactions?.[this.id] ?? 0;
    for (let n = r; n < this.toProcessTransactions.length; n++) {
      const s = this.toProcessTransactions[n];
      if (!s.isValidTransactionWithChanges())
        continue;
      const a = s.currentTxID, I = o?.[a.sessionID] ?? -1, C = g?.[a.sessionID] ?? 1 / 0;
      I > a.txIndex || C < a.txIndex || e.push(s);
    }
    if (A?.knownTransactions !== void 0 && (A.knownTransactions[this.id] = this.toProcessTransactions.length), t && this.branchStart && !A?.skipBranchSource) {
      const n = t.getValidTransactions({
        knownTransactions: A?.knownTransactions,
        to: this.branchStart,
        ignorePrivateTransactions: A?.ignorePrivateTransactions ?? !1
      });
      for (const s of n)
        e.push(s);
    }
    return e;
  }
  addDependency(A) {
    const e = this.node.getCoValue(A);
    this.isCircularDependency(e) || this.dependencies.has(A) || (this.dependencies.add(A), e.addDependant(this.id), e.isCompletelyDownloaded() || (this.incompleteDependencies.add(e.id), e.waitFor({
      predicate: (t) => t.isCompletelyDownloaded(),
      onSuccess: () => {
        this.incompleteDependencies.delete(e.id), this.incompleteDependencies.size === 0 && this.notifyUpdate();
      }
    })), e.isAvailable() || (this.missingDependencies.add(e.id), e.waitFor({
      predicate: (t) => t.isAvailable(),
      onSuccess: () => {
        this.missingDependencies.delete(e.id), this.missingDependencies.size === 0 && this.notifyUpdate();
      }
    })));
  }
  addDependant(A) {
    this.dependant.add(A);
  }
  isGroupOrAccount() {
    return this.verified ? this.verified.header.ruleset.type === "group" : !1;
  }
  isGroup() {
    return !(!this.verified || this.verified.header.ruleset.type !== "group" || this.verified.header.meta?.type === "account");
  }
  createBranch(A, e) {
    return wc(this, A, e);
  }
  mergeBranch() {
    return yc(this);
  }
  getBranch(A, e) {
    return this.node.getCoValue(fc(this, A, e));
  }
  getCurrentBranchName() {
    return this.verified?.branchName;
  }
  getCurrentBranchSourceId() {
    return this.verified?.branchSourceId;
  }
  isBranched() {
    return !!this.verified?.branchSourceId;
  }
  hasBranch(A, e) {
    this.parseNewTransactions(!1);
    const t = Rg(this);
    return this.branches.some((o) => {
      if (o.branch !== A)
        return !1;
      if (o.ownerId === e)
        return !0;
      if (!e)
        return o.ownerId === t;
      if (!o.ownerId)
        return e === t;
    });
  }
  getMergeCommits() {
    return this.mergeCommits;
  }
  getValidSortedTransactions(A) {
    const e = this.getValidTransactions(A);
    return e.sort(this.compareTransactions), e;
  }
  compareTransactions(A, e) {
    return A.madeAt !== e.madeAt ? A.madeAt - e.madeAt : A.txID.sessionID === e.txID.sessionID ? A.txID.txIndex - e.txID.txIndex : 0;
  }
  getCurrentReadKey() {
    if (!this.verified)
      throw new Error("CoValueCore: getCurrentReadKey called on coValue without verified state");
    if (this.isGroupOrAccount())
      return DA(this.getCurrentContent()).getCurrentReadKey();
    if (this.verified.header.ruleset.type === "ownedByGroup")
      return this.node.expectCoValueLoaded(this.verified.header.ruleset.group).getCurrentReadKey();
    throw new Error("Only groups or values owned by groups have read secrets");
  }
  getReadKey(A) {
    const e = this.readKeyCache.get(A);
    if (e)
      return e;
    if (!this.verified)
      throw new Error("CoValueCore: getUncachedReadKey called on coValue without verified state");
    if (this.isGroup())
      return DA(
        // Private transactions are not considered valid in groups, so we don't need to pass
        // ignorePrivateTransactions: true to safely load the content
        this.getCurrentContent()
      ).getReadKey(A);
    if (this.isGroupOrAccount())
      return DA(
        // Old accounts might have private transactions, because we were encrypting the root id in the past
        // So we need to load the account without private transactions, because we can't decrypt them without the read key
        this.getCurrentContent({ ignorePrivateTransactions: !0 })
      ).getReadKey(A);
    if (this.verified.header.ruleset.type === "ownedByGroup")
      return DA(this.node.expectCoValueLoaded(this.verified.header.ruleset.group).getCurrentContent()).getReadKey(A);
    throw new Error("Only groups or values owned by groups have read secrets");
  }
  safeGetGroup() {
    if (!this.verified)
      throw new Error("CoValueCore: getGroup called on coValue without verified state");
    if (this.verified.header.ruleset.type === "ownedByGroup")
      return DA(this.node.expectCoValueLoaded(this.verified.header.ruleset.group).getCurrentContent());
  }
  getGroup() {
    const A = this.safeGetGroup();
    if (!A)
      throw new Error("Only values owned by groups have groups");
    return A;
  }
  getTx(A) {
    return this.verified?.sessions.get(A.sessionID)?.transactions[A.txIndex];
  }
  getDependedOnCoValues() {
    return this.dependencies;
  }
  waitForSync(A) {
    return this.node.syncManager.waitForSync(this.id, A?.timeout);
  }
  load(A, e) {
    this.loadFromStorage((t) => {
      t || this.loadFromPeers(A, e);
    });
  }
  loadFromStorage(A) {
    const e = this.node;
    if (!e.storage) {
      A?.(!1);
      return;
    }
    const t = this.getLoadingStateForPeer("storage");
    if (t === "pending") {
      if (!A)
        return;
      this.subscribe((g, r) => {
        const n = g.getLoadingStateForPeer("storage");
        n === "available" || g.isAvailable() ? (r(), A(!0)) : (n === "errored" || n === "unavailable") && (r(), A(!1));
      });
      return;
    }
    const o = this.loadingState;
    if (t !== "unknown" && o !== "garbageCollected" && o !== "onlyKnownState") {
      A?.(t === "available");
      return;
    }
    this.markPending("storage"), e.storage.load(this.id, (g) => {
      e.syncManager.handleNewContent(g, "storage");
    }, (g) => {
      A?.(g), g || this.markNotFoundInPeer("storage");
    });
  }
  /**
   * Lazily load only the knownState from storage without loading full transaction data.
   * This is useful for checking if a peer needs new content before committing to a full load.
   *
   * If found in storage, marks the CoValue as onlyKnownState and caches the knownState.
   * This enables accurate LOAD requests during peer reconciliation.
   *
   * @param done - Callback with the storage knownState, or undefined if not found in storage
   */
  getKnownStateFromStorage(A) {
    if (!this.node.storage) {
      A(void 0);
      return;
    }
    const e = this.knownState();
    if (e.header) {
      A(e);
      return;
    }
    this.node.storage.loadKnownState(this.id, (t) => {
      if (t && !this.isAvailable()) {
        const o = this.loadingState;
        FA(this, Ee, "onlyKnownState", "f"), FA(this, le, t, "f"), this.updateCounter(o);
      }
      A(t);
    });
  }
  loadFromPeers(A, e) {
    if (A.length !== 0)
      for (const t of A) {
        const o = this.getLoadingStateForPeer(t.id);
        (o === "unknown" || o === "unavailable") && (this.markPending(t.id), this.internalLoadFromPeer(t, e));
      }
  }
  internalLoadFromPeer(A, e) {
    if (A.closed && !A.persistent) {
      this.markNotFoundInPeer(A.id);
      return;
    }
    const t = () => {
      this.getLoadingStateForPeer(A.id) === "pending" && (Z.warn("Timeout waiting for peer to load coValue", {
        id: this.id,
        peerID: A.id
      }), this.markNotFoundInPeer(A.id));
    }, o = A.persistent ? void 0 : A.addCloseListener(t);
    A.closed || A.sendLoadRequest(this, e), this.subscribe((g, r) => {
      const n = g.getLoadingStateForPeer(A.id);
      (g.isAvailable() || // might have become available from another peer e.g. through handleNewContent
      n === "available" || n === "errored" || n === "unavailable") && (r(), o?.());
    }, !0);
  }
}
Ee = /* @__PURE__ */ new WeakMap(), le = /* @__PURE__ */ new WeakMap(), It = /* @__PURE__ */ new WeakMap(), Ct = /* @__PURE__ */ new WeakMap(), ct = /* @__PURE__ */ new WeakMap(), ye = /* @__PURE__ */ new WeakSet(), Ws = function(A, e, t) {
  if (!this.verified)
    return {
      value: !1
    };
  let o;
  if (Ne(A)) {
    if ((this.verified.sessions.get(A)?.transactions.length ?? 0) > 0 || e.length > 1)
      return {
        value: !0,
        err: {
          type: "DeleteTransactionRejected",
          id: this.id,
          sessionID: A,
          reason: "InvalidDeleteTransaction",
          error: new Error("Delete transaction must be the only transaction in the session")
        }
      };
    const r = e[0], n = r && RA(this, ye, "m", yr).call(this, r);
    if (n && (o = r, n.deleted !== this.id))
      return {
        value: !0,
        err: {
          type: "DeleteTransactionRejected",
          id: this.id,
          sessionID: A,
          reason: "InvalidDeleteTransaction",
          error: new Error(`Delete transaction ID mismatch: expected ${this.id}, got ${n.deleted}`)
        }
      };
    if (this.isGroupOrAccount())
      return {
        value: !0,
        err: {
          type: "DeleteTransactionRejected",
          id: this.id,
          sessionID: A,
          reason: "CoValueNotDeletable",
          error: new Error("Cannot delete Group or Account coValues")
        }
      };
  }
  if (!t && o) {
    const g = vA(A), r = RA(this, ye, "m", pr).call(this, g, o.madeAt);
    if (!r.ok)
      return {
        value: !0,
        err: {
          type: "DeleteTransactionRejected",
          id: this.id,
          sessionID: A,
          author: g,
          reason: r.reason,
          error: new Error(r.message)
        }
      };
  }
  return {
    value: !!o
  };
}, _o = function() {
  this.isDeleted = !0, this.verified?.markAsDeleted();
}, yr = function(A) {
  if (A.privacy !== "trusting" || !A.meta)
    return;
  const e = zo(A.meta);
  return e && typeof e.deleted == "string" ? e : void 0;
}, pr = function(A, e) {
  if (!this.verified)
    return {
      ok: !1,
      reason: "CannotVerifyPermissions",
      message: "Cannot verify delete permissions without verified state"
    };
  if (this.isGroupOrAccount())
    return {
      ok: !1,
      reason: "CoValueNotDeletable",
      message: "Cannot delete Group or Account coValues"
    };
  const t = this.safeGetGroup();
  return t ? t.atTime(e).roleOfInternal(A) !== "admin" ? {
    ok: !1,
    reason: "NotAdmin",
    message: "Delete transaction rejected: author is not an admin"
  } : { ok: !0 } : {
    ok: !1,
    reason: "CannotVerifyPermissions",
    message: "Cannot verify delete permissions for coValues not owned by a group"
  };
};
class Sc {
  constructor(A) {
    this.node = A, this.interval = setInterval(() => {
      this.collect();
    }, ur.INTERVAL);
  }
  getCurrentTime() {
    return performance.now();
  }
  trackCoValueAccess({ verified: A }) {
    A && (A.lastAccessed = this.getCurrentTime());
  }
  collect() {
    const A = this.getCurrentTime();
    for (const e of this.node.allCoValues()) {
      const { verified: t } = e;
      if (!t?.lastAccessed)
        continue;
      A - t.lastAccessed > ur.MAX_AGE && this.node.internalUnmountCoValue(e.id);
    }
  }
  stop() {
    clearInterval(this.interval);
  }
}
class bg {
  constructor(A, e) {
    this.id = A, this.peerId = e, this.knownState = ke(A);
  }
  cloneWithoutOptimistic() {
    const A = new bg(this.id, this.peerId);
    return A.set(this.knownState), A;
  }
  updateHeader(A) {
    this.knownState.header = A, this.optimisticKnownState && (this.optimisticKnownState.header = A);
  }
  combineWith(A) {
    mo(this.knownState, A), this.optimisticKnownState && mo(this.optimisticKnownState, A);
  }
  combineOptimisticWith(A) {
    this.optimisticKnownState || (this.optimisticKnownState = ue(this.knownState)), mo(this.optimisticKnownState, A);
  }
  /**
   * Aligns the CoValue known state with the defined payload
   */
  set(A) {
    A === "empty" ? (this.knownState.header = !1, this.knownState.sessions = {}) : (this.knownState.header = A.header, this.knownState.sessions = { ...A.sessions }), this.optimisticKnownState = void 0;
  }
  value() {
    return this.knownState;
  }
  optimisticValue() {
    return this.optimisticKnownState ?? this.knownState;
  }
}
class io {
  constructor(A) {
    this.meter = A, this.head = void 0, this.tail = void 0, this.length = 0;
  }
  push(A) {
    const e = { value: A, prev: void 0, next: void 0 };
    if (this.head === void 0)
      this.head = e, this.tail = e;
    else if (this.tail)
      e.prev = this.tail, this.tail.next = e, this.tail = e;
    else
      throw new Error("LinkedList is corrupted");
    return this.length++, this.meter?.push(), e;
  }
  shift() {
    if (!this.head)
      return;
    const A = this.head, e = A.value;
    return this.head = A.next, A.next = void 0, this.head === void 0 ? this.tail = void 0 : this.head.prev = void 0, this.length--, this.meter?.pull(), e;
  }
  /**
   * Remove a specific node from the list in O(1) time.
   * The node must be a valid node that was returned by push().
   */
  remove(A) {
    A.prev ? A.prev.next = A.next : this.head = A.next, A.next ? A.next.prev = A.prev : this.tail = A.prev, A.prev = void 0, A.next = void 0, this.length--, this.meter?.pull();
  }
  isEmpty() {
    return this.head === void 0;
  }
}
class Nc {
  constructor(A, e) {
    this.attrs = e, this.pullCounter = te.getMeter("cojson").createCounter(`${A}.pulled`, {
      description: "Number of messages pulled from the queue",
      valueType: qA.INT,
      unit: "1"
    }), this.pushCounter = te.getMeter("cojson").createCounter(`${A}.pushed`, {
      description: "Number of messages pushed to the queue",
      valueType: qA.INT,
      unit: "1"
    }), this.pullCounter.add(0, this.attrs), this.pushCounter.add(0, this.attrs);
  }
  pull() {
    this.pullCounter.add(1, this.attrs);
  }
  push() {
    this.pushCounter.add(1, this.attrs);
  }
}
function ht(i, A) {
  return new io(new Nc("jazz.messagequeue." + i, A));
}
class Mc {
  constructor(A) {
    this.peerId = A, this.inFlightLoads = /* @__PURE__ */ new Map(), this.highPriorityPending = ht("load-requests-queue", { priority: "high" }), this.lowPriorityPending = ht("load-requests-queue", { priority: "low" }), this.lowPriorityNodes = /* @__PURE__ */ new Map(), this.highPriorityNodes = /* @__PURE__ */ new Map(), this.timeoutHandle = null, this.processing = !1;
  }
  /**
   * Check if we can send another load request.
   */
  canSend() {
    return this.inFlightLoads.size < Pe.MAX_IN_FLIGHT_LOADS_PER_PEER;
  }
  /**
   * Track that a load request has been sent.
   */
  trackSent(A) {
    const e = performance.now();
    this.inFlightLoads.set(A, e), this.scheduleTimeoutCheck(Pe.TIMEOUT);
  }
  /**
   * Schedule a timeout check if not already scheduled.
   * Uses a single timer to check all in-flight loads.
   */
  scheduleTimeoutCheck(A) {
    this.timeoutHandle === null && (this.timeoutHandle = setTimeout(() => {
      this.timeoutHandle = null, this.checkTimeouts();
    }, A));
  }
  /**
   * Check all in-flight loads for timeouts and handle them.
   */
  checkTimeouts() {
    const A = performance.now();
    let e;
    for (const [t, o] of this.inFlightLoads.entries()) {
      const g = o + Pe.TIMEOUT;
      A >= g ? (t.isAvailable() ? t.isStreaming() && Z.warn("Content streaming is taking more than " + Pe.TIMEOUT / 1e3 + "s", {
        id: t.id,
        peerId: this.peerId,
        knownState: t.knownState().sessions,
        streamingTarget: t.knownStateWithStreaming().sessions
      }) : (Z.warn("Load request timed out", {
        id: t.id,
        peerId: this.peerId
      }), t.markNotFoundInPeer(this.peerId)), this.inFlightLoads.delete(t), this.processQueue()) : e = Math.min(e ?? 1 / 0, g - A);
    }
    e && this.scheduleTimeoutCheck(e);
  }
  trackUpdate(A) {
    this.inFlightLoads.has(A) && this.inFlightLoads.set(A, performance.now());
  }
  /**
   * Track that a load request has completed.
   * Triggers processing of pending requests.
   */
  trackComplete(A) {
    this.inFlightLoads.has(A) && (A.isStreaming() || (this.inFlightLoads.delete(A), this.processQueue()));
  }
  /**
   * Enqueue a load request.
   * Immediately processes the queue to send requests if capacity is available.
   * Skips CoValues that are already in-flight or pending.
   *
   * @param coValue - The CoValue to load
   * @param sendCallback - Callback to send the request when ready
   * @param mode - Optional mode: "low-priority" for background loads, "immediate" to bypass queue
   */
  enqueue(A, e, t = "high-priority") {
    if (this.inFlightLoads.has(A))
      return;
    const o = this.lowPriorityNodes.get(A.id), g = this.highPriorityNodes.get(A.id);
    switch (t) {
      case "immediate":
        o && (this.lowPriorityPending.remove(o), this.lowPriorityNodes.delete(A.id)), g && (this.highPriorityPending.remove(g), this.highPriorityNodes.delete(A.id)), this.trackSent(A), e();
        break;
      case "high-priority":
        if (g)
          return;
        o && (this.lowPriorityPending.remove(o), this.lowPriorityNodes.delete(A.id)), this.highPriorityNodes.set(A.id, this.highPriorityPending.push({ value: A, sendCallback: e })), this.processQueue();
        break;
      case "low-priority":
        if (o || g)
          return;
        this.lowPriorityNodes.set(A.id, this.lowPriorityPending.push({ value: A, sendCallback: e })), this.processQueue();
        break;
    }
  }
  /**
   * Process all pending load requests while capacity is available.
   * High-priority requests are processed first, then low-priority.
   */
  processQueue() {
    if (!(this.processing || !this.canSend())) {
      for (this.processing = !0; this.canSend(); ) {
        let A = this.highPriorityPending.shift();
        if (A ? this.highPriorityNodes.delete(A.value.id) : (A = this.lowPriorityPending.shift(), A && this.lowPriorityNodes.delete(A.value.id)), !A)
          break;
        this.trackSent(A.value), A.sendCallback();
      }
      this.processing = !1;
    }
  }
  /**
   * Clear all state. Called on disconnect.
   * Clears the timeout and all pending/in-flight loads.
   */
  clear() {
    for (this.timeoutHandle !== null && (clearTimeout(this.timeoutHandle), this.timeoutHandle = null), this.inFlightLoads.clear(); this.highPriorityPending.shift(); )
      ;
    for (; this.lowPriorityPending.shift(); )
      ;
    this.highPriorityNodes.clear(), this.lowPriorityNodes.clear();
  }
  /**
   * Get the number of in-flight loads (for testing/debugging).
   */
  get inFlightCount() {
    return this.inFlightLoads.size;
  }
  /**
   * Get the number of pending loads (for testing/debugging).
   */
  get pendingCount() {
    return this.highPriorityPending.length + this.lowPriorityPending.length;
  }
  /**
   * Get the number of high-priority pending loads (for testing/debugging).
   */
  get highPriorityPendingCount() {
    return this.highPriorityPending.length;
  }
  /**
   * Get the number of low-priority pending loads (for testing/debugging).
   */
  get lowPriorityPendingCount() {
    return this.lowPriorityPending.length;
  }
}
class Kg {
  constructor(A, e) {
    this.peer = A, this.toldKnownState = /* @__PURE__ */ new Set(), this.loadRequestSent = /* @__PURE__ */ new Set(), this.listeners = /* @__PURE__ */ new Set(), this.closed = !1, this.closeListeners = /* @__PURE__ */ new Set(), this._knownStates = e ?? /* @__PURE__ */ new Map(), this.loadQueue = new Mc(A.id);
  }
  getKnownState(A) {
    return this._knownStates.get(A)?.value();
  }
  getOptimisticKnownState(A) {
    return this._knownStates.get(A)?.optimisticValue();
  }
  isCoValueSubscribedToPeer(A) {
    return this._knownStates.has(A);
  }
  /**
   * Closes the current peer state and creates a new one from a given peer,
   * keeping the same known states.
   *
   * This is used to create a new peer state when a peer reconnects.
   */
  newPeerStateFrom(A) {
    this.closed || this.gracefulShutdown();
    const e = /* @__PURE__ */ new Map();
    for (const t of this._knownStates.values())
      e.set(t.id, t.cloneWithoutOptimistic());
    return new Kg(A, e);
  }
  sendLoadRequest(A, e) {
    this.toldKnownState.add(A.id), this.loadRequestSent.add(A.id), this.loadQueue.enqueue(A, () => {
      this.pushOutgoingMessage({
        action: "load",
        ...A.knownStateWithStreaming()
      });
    }, e);
  }
  trackLoadRequestUpdate(A) {
    this.loadQueue.trackUpdate(A);
  }
  trackLoadRequestComplete(A) {
    this.loadQueue.trackComplete(A);
  }
  trackToldKnownState(A) {
    this.toldKnownState.add(A);
  }
  getOrCreateKnownState(A) {
    let e = this._knownStates.get(A);
    return e || (e = new bg(A, this.peer.id), this._knownStates.set(A, e)), e;
  }
  updateHeader(A, e) {
    const t = this.getOrCreateKnownState(A);
    t.updateHeader(e), this.triggerUpdate(A, t);
  }
  combineWith(A, e) {
    const t = this.getOrCreateKnownState(A);
    t.combineWith(e), this.triggerUpdate(A, t);
  }
  combineOptimisticWith(A, e) {
    const t = this.getOrCreateKnownState(A);
    t.combineOptimisticWith(e), this.triggerUpdate(A, t);
  }
  setKnownState(A, e) {
    const t = this.getOrCreateKnownState(A);
    t.set(e), this.triggerUpdate(A, t);
  }
  /**
   * Emit a change event for a given coValue.
   *
   * This is used to notify subscribers that the known state of a coValue has changed,
   * but the known state of the peer has not.
   */
  emitCoValueChange(A) {
    if (this.peer.role === "client" && !this.isCoValueSubscribedToPeer(A))
      return;
    const e = this.getOrCreateKnownState(A);
    this.triggerUpdate(A, e);
  }
  triggerUpdate(A, e) {
    for (const t of this.listeners)
      t(A, e);
  }
  subscribeToKnownStatesUpdates(A) {
    return this.listeners.add(A), () => {
      this.listeners.delete(A);
    };
  }
  get id() {
    return this.peer.id;
  }
  get role() {
    return this.peer.role;
  }
  get priority() {
    return this.peer.priority;
  }
  get incoming() {
    return this.peer.incoming;
  }
  get persistent() {
    return this.peer.persistent;
  }
  pushOutgoingMessage(A) {
    this.peer.outgoing.push(A);
  }
  addCloseListener(A) {
    return this.closed ? (A(), () => {
    }) : (this.closeListeners.add(A), () => {
      this.closeListeners.delete(A);
    });
  }
  emitClose() {
    for (const A of this.closeListeners)
      A();
    this.closeListeners.clear();
  }
  gracefulShutdown() {
    this.closed || (Z.debug("Gracefully closing", {
      peerId: this.id,
      peerRole: this.role
    }), this.closed = !0, this.loadQueue.clear(), this.peer.outgoing.push("Disconnected"), this.peer.outgoing.close(), this.peer.incoming.close(), this.emitClose());
  }
}
class Gc {
  constructor(A) {
    this.syncManager = A, this.listeners = /* @__PURE__ */ new Set(), this.listenersByCoValues = /* @__PURE__ */ new Map(), this.listenersByPeersAndCoValues = /* @__PURE__ */ new Map();
  }
  subscribeToUpdates(A) {
    return this.listeners.add(A), () => {
      this.listeners.delete(A);
    };
  }
  subscribeToCoValueUpdates(A, e) {
    let t = this.listenersByCoValues.get(A);
    return t || (t = /* @__PURE__ */ new Set(), this.listenersByCoValues.set(A, t)), t.add(e), () => {
      t.delete(e), t.size === 0 && this.listenersByCoValues.delete(A);
    };
  }
  subscribeToPeerUpdates(A, e, t) {
    let o = this.listenersByPeersAndCoValues.get(A);
    o || (o = /* @__PURE__ */ new Map(), this.listenersByPeersAndCoValues.set(A, o));
    let g = o.get(e);
    return g || (g = /* @__PURE__ */ new Set(), o.set(e, g)), g.add(t), () => {
      g.delete(t), g.size === 0 && (o.delete(e), o.size === 0 && this.listenersByPeersAndCoValues.delete(A));
    };
  }
  triggerUpdate(A, e, t) {
    const o = this.listeners, g = this.listenersByCoValues.get(e), n = this.listenersByPeersAndCoValues.get(A.id)?.get(e);
    if (!o.size && !g?.size && !n?.size)
      return;
    const s = {
      uploaded: this.getIsCoValueFullyUploadedIntoPeer(t, e)
    };
    for (const a of this.listeners)
      a(A, t, s);
    if (g)
      for (const a of g)
        a(A, t, s);
    if (n)
      for (const a of n)
        a(t, s);
  }
  isSynced(A, e) {
    const t = A.getKnownState(e);
    return t ? this.getIsCoValueFullyUploadedIntoPeer(t, e) : !1;
  }
  getIsCoValueFullyUploadedIntoPeer(A, e) {
    const t = this.syncManager.local.getCoValue(e);
    if (!t.hasVerifiedContent())
      return !1;
    const o = t.verified.knownState();
    return Ts(o.sessions, A.sessions);
  }
}
const mr = "any";
let kc = 200;
class Fc {
  constructor() {
    this.unsynced = /* @__PURE__ */ new Map(), this.coValueListeners = /* @__PURE__ */ new Map(), this.globalListeners = /* @__PURE__ */ new Set(), this.pendingUpdates = [];
  }
  /**
   * Add a CoValue as unsynced to a specific peer.
   * Triggers persistence if storage is available.
   * @returns true if the CoValue was already tracked, false otherwise.
   */
  add(A, e = mr) {
    this.unsynced.has(A) || this.unsynced.set(A, /* @__PURE__ */ new Set());
    const t = this.unsynced.get(A), o = t.has(e);
    return o || (t.add(e), this.schedulePersist(A, e, !1), this.notifyCoValueListeners(A, !1), this.notifyGlobalListeners(!1)), o;
  }
  /**
   * Remove a CoValue from being unsynced to a specific peer.
   * Triggers persistence if storage is available.
   */
  remove(A, e = mr) {
    const t = this.unsynced.get(A);
    if (!t || !t.has(e))
      return;
    t.delete(e), t.size === 0 && this.unsynced.delete(A), this.schedulePersist(A, e, !0);
    const o = !this.unsynced.has(A);
    this.notifyCoValueListeners(A, o), this.notifyGlobalListeners(this.isAllSynced());
  }
  /**
   * Remove all tracking for a CoValue (all peers).
   * Triggers persistence if storage is available.
   */
  removeAll(A) {
    const e = this.unsynced.get(A);
    if (!e)
      return;
    const t = Array.from(e);
    for (const o of t)
      this.remove(A, o);
  }
  forcePersist() {
    return this.flush();
  }
  schedulePersist(A, e, t) {
    this.storage && (this.pendingUpdates.push({ id: A, peerId: e, synced: t }), this.flushTimer || (this.flushTimer = setTimeout(() => {
      this.flush();
    }, kc)));
  }
  /**
   * Flush all pending persistence updates in a batch
   */
  flush() {
    if (this.flushTimer && (clearTimeout(this.flushTimer), this.flushTimer = void 0), this.pendingUpdates.length === 0)
      return;
    const A = this.storage;
    if (!A)
      return;
    const e = this.simplifyPendingUpdates(this.pendingUpdates);
    return this.pendingUpdates = [], new Promise((t) => {
      try {
        A.trackCoValuesSyncState(e, () => t());
      } catch (o) {
        Z.warn("Failed to persist batched unsynced CoValue tracking", {
          err: o
        }), t();
      }
    });
  }
  /**
   * Get all CoValue IDs that have at least one unsynced peer.
   */
  getAll() {
    return Array.from(this.unsynced.keys());
  }
  /**
   * Check if all CoValues are synced
   */
  isAllSynced() {
    return this.unsynced.size === 0;
  }
  /**
   * Check if a specific CoValue is tracked as unsynced.
   */
  has(A) {
    return this.unsynced.has(A);
  }
  subscribe(A, e) {
    if (typeof A == "string" && e) {
      const o = A;
      this.coValueListeners.has(o) || this.coValueListeners.set(o, /* @__PURE__ */ new Set()), this.coValueListeners.get(o).add(e);
      const g = !this.unsynced.has(o);
      return e(g), () => {
        const r = this.coValueListeners.get(o);
        r && (r.delete(e), r.size === 0 && this.coValueListeners.delete(o));
      };
    }
    const t = A;
    return this.globalListeners.add(t), t(this.isAllSynced()), () => {
      this.globalListeners.delete(t);
    };
  }
  setStorage(A) {
    this.storage = A;
  }
  removeStorage() {
    this.storage = void 0;
  }
  /**
   * Notify all listeners for a specific CoValue about sync status change.
   */
  notifyCoValueListeners(A, e) {
    const t = this.coValueListeners.get(A);
    if (t)
      for (const o of t)
        o(e);
  }
  /**
   * Notify all global listeners about "all synced" status change.
   */
  notifyGlobalListeners(A) {
    for (const e of this.globalListeners)
      e(A);
  }
  /**
   * Keep only the last update for each (id, peerId) combination
   */
  simplifyPendingUpdates(A) {
    const e = /* @__PURE__ */ new Map();
    for (const t of A)
      e.set(`${t.id}|${t.peerId}`, t);
    return Array.from(e.values());
  }
}
class Rc {
  constructor(A) {
    this.processQueues = A, this.currentQueue = 0, this.pullCounter = te.getMeter("cojson").createCounter("jazz.messagequeue.incoming.pulled", {
      description: "Number of messages pulled from the queue",
      valueType: qA.INT,
      unit: "1"
    }), this.pushCounter = te.getMeter("cojson").createCounter("jazz.messagequeue.incoming.pushed", {
      description: "Number of messages pushed to the queue",
      valueType: qA.INT,
      unit: "1"
    }), this.pullCounter.add(0, {
      peerRole: "client"
    }), this.pushCounter.add(0, {
      peerRole: "client"
    }), this.pullCounter.add(0, {
      peerRole: "server"
    }), this.pushCounter.add(0, {
      peerRole: "server"
    }), this.queues = [], this.peerToQueue = /* @__PURE__ */ new WeakMap();
  }
  push(A, e) {
    const t = this.peerToQueue.get(e);
    if (t)
      t.push(A);
    else {
      const o = new io();
      this.peerToQueue.set(e, o), this.queues.push([o, e]), o.push(A);
    }
    this.pushCounter.add(1, {
      peerRole: e.role
    }), this.processQueues();
  }
  pull() {
    const A = this.queues[this.currentQueue];
    if (!A)
      return;
    const [e, t] = A, o = e.shift();
    if (e.isEmpty() ? (this.queues.splice(this.currentQueue, 1), this.peerToQueue.delete(t)) : this.currentQueue++, this.currentQueue >= this.queues.length && (this.currentQueue = 0), o)
      return this.pullCounter.add(1, {
        peerRole: t.role
      }), { msg: o, peer: t };
  }
}
class bc {
  constructor(A) {
    this.sync = A, this.batch = [], this.syncTransaction = (e, t) => {
      const o = this.lastUpdatedValue, g = this.lastUpdatedValueKnownState;
      if (o && g) {
        if (o.id === e.id)
          return;
        this.addContentToBatch(o, g);
      }
      this.lastUpdatedValue = e, this.lastUpdatedValueKnownState = t;
      for (const r of this.dirtyCoValuesTrackingSets)
        r.add(e.id);
      this.scheduleNextBatch();
    }, this.nextBatchScheduled = !1, this.dirtyCoValuesTrackingSets = /* @__PURE__ */ new Set(), this.trackDirtyCoValues = () => {
      const e = /* @__PURE__ */ new Set();
      return this.dirtyCoValuesTrackingSets.add(e), {
        done: () => (this.dirtyCoValuesTrackingSets.delete(e), e)
      };
    };
  }
  addContentToBatch(A, e) {
    const t = A.newContentSince(e);
    if (t)
      for (const o of t)
        this.batch.push(o);
  }
  scheduleNextBatch() {
    this.nextBatchScheduled || (this.nextBatchScheduled = !0, queueMicrotask(() => {
      this.lastUpdatedValue && this.lastUpdatedValueKnownState && this.addContentToBatch(this.lastUpdatedValue, this.lastUpdatedValueKnownState);
      const A = this.batch;
      this.lastUpdatedValue = void 0, this.lastUpdatedValueKnownState = void 0, this.batch = [], this.nextBatchScheduled = !1;
      for (const e of A)
        this.sync(e);
    }));
  }
}
function Sr(i) {
  return i.role === "server" && (i.persistent ?? !1);
}
class Kc {
  ignoreUnknownCoValuesFromServers() {
    this._ignoreUnknownCoValuesFromServers = !0;
  }
  constructor(A) {
    this.peers = {}, this.skipVerify = !1, this._ignoreUnknownCoValuesFromServers = !1, this.peersCounter = te.getMeter("cojson").createUpDownCounter("jazz.peers", {
      description: "Amount of connected peers",
      valueType: qA.INT,
      unit: "peer"
    }), this.messagesQueue = new Rc(() => this.processQueues()), this.processing = !1, this.syncQueue = new bc((e) => this.syncContent(e)), this.syncLocalTransaction = this.syncQueue.syncTransaction, this.trackDirtyCoValues = this.syncQueue.trackDirtyCoValues, this.local = A, this.syncState = new Gc(this), this.unsyncedTracker = new Fc(), this.transactionsSizeHistogram = te.getMeter("cojson").createHistogram("jazz.transactions.size", {
      description: "The size of transactions in a covalue",
      unit: "bytes",
      valueType: qA.INT
    });
  }
  disableTransactionVerification() {
    this.skipVerify = !0;
  }
  getPeers(A) {
    return this.getServerPeers(A).concat(this.getClientPeers());
  }
  getClientPeers() {
    return Object.values(this.peers).filter((A) => A.role === "client");
  }
  getServerPeers(A, e) {
    const t = Object.values(this.peers).filter((o) => o.role === "server" && o.id !== e);
    return this.serverPeerSelector ? this.serverPeerSelector(A, t) : t;
  }
  getPersistentServerPeers(A) {
    return this.getServerPeers(A).filter((e) => e.persistent);
  }
  handleSyncMessage(A, e) {
    if (!ks(A.id)) {
      const t = A.id ? "invalid" : "undefined";
      Z.warn(`Received sync message with ${t} id`, {
        msg: A
      });
      return;
    }
    if (e.role === "server" && this._ignoreUnknownCoValuesFromServers && !this.local.hasCoValue(A.id)) {
      Z.warn(`Ignoring message ${A.action} on unknown coValue ${A.id} from peer ${e.id}`);
      return;
    }
    if (this.local.getCoValue(A.id).isErroredInPeer(e.id)) {
      Z.warn(`Skipping message ${A.action} on errored coValue ${A.id} from peer ${e.id}`);
      return;
    }
    switch (A.action) {
      case "load":
        return this.handleLoad(A, e);
      case "known":
        return A.isCorrection ? this.handleCorrection(A, e) : this.handleKnownState(A, e);
      case "content":
        return this.handleNewContent(A, e);
      case "done":
        return;
      default:
        throw new Error(`Unknown message type ${A.action}`);
    }
  }
  sendNewContent(A, e, t = /* @__PURE__ */ new Set()) {
    if (t.has(A))
      return;
    t.add(A);
    const o = this.local.getCoValue(A);
    if (!o.isAvailable())
      return;
    if (e.role !== "server")
      for (const n of o.getDependedOnCoValues())
        this.sendNewContent(n, e, t);
    const r = o.newContentSince(e.getOptimisticKnownState(A));
    if (r) {
      for (const n of r)
        this.trySendToPeer(e, n);
      e.combineOptimisticWith(A, o.knownState());
    } else e.toldKnownState.has(A) || (o.isDeleted ? this.trySendToPeer(e, o.stopSyncingKnownStateMessage(e.getKnownState(A))) : this.trySendToPeer(e, {
      action: "known",
      ...o.knownStateWithStreaming()
    }));
    e.trackToldKnownState(A);
  }
  reconcileServerPeers() {
    const A = Object.values(this.peers).filter((e) => e.role === "server");
    for (const e of A)
      this.startPeerReconciliation(e);
  }
  async resumeUnsyncedCoValues() {
    this.local.storage && await new Promise((A, e) => {
      this.local.storage?.getUnsyncedCoValueIDs((t) => {
        const o = t.filter((s) => !this.local.hasCoValue(s));
        if (o.length === 0) {
          A();
          return;
        }
        const g = 10;
        let r = 0;
        const n = async () => {
          const s = o.slice(r, r + g);
          await Promise.all(s.map(async (a) => new Promise((I) => {
            try {
              this.local.storage?.stopTrackingSyncState(a), this.trackSyncState(a), this.local.getCoValue(a).loadFromStorage((c) => {
                c || this.unsyncedTracker.removeAll(a), I();
              });
            } catch (C) {
              Z.warn(`Failed to resume sync for CoValue ${a}:`, {
                err: C,
                coValueId: a
              }), this.unsyncedTracker.removeAll(a), I();
            }
          }))), r += s.length, r < o.length ? n().catch(e) : A();
        };
        n().catch(e);
      });
    });
  }
  startPeerReconciliation(A) {
    Sr(A) && this.resumeUnsyncedCoValues().catch((g) => {
      Z.warn("Failed to resume unsynced CoValues:", g);
    });
    const e = [], t = /* @__PURE__ */ new Set(), o = (g) => {
      if (!t.has(g.id) && (t.add(g.id), this.getServerPeers(g.id).find((r) => r.id === A.id) !== void 0)) {
        for (const r of g.getDependedOnCoValues()) {
          const n = this.local.getCoValue(r);
          n.isAvailable() && o(n);
        }
        e.push(g);
      }
    };
    for (const g of this.local.allCoValues()) {
      if (g.isAvailable())
        o(g);
      else {
        if (g.loadingState === "unknown")
          continue;
        A.loadRequestSent.has(g.id) || A.sendLoadRequest(g, "low-priority");
      }
      A.getKnownState(g.id) || A.setKnownState(g.id, "empty");
    }
    for (const g of e)
      A.sendLoadRequest(g, "low-priority");
  }
  pushMessage(A, e) {
    this.messagesQueue.push(A, e);
  }
  /**
   * Get the storage streaming queue if available.
   * Returns undefined if storage doesn't have a streaming queue.
   */
  getStorageStreamingQueue() {
    const A = this.local.storage;
    if (A && "streamingQueue" in A)
      return A.streamingQueue;
  }
  /**
   * Unified queue processing that coordinates both incoming messages
   * and storage streaming entries.
   *
   * Processes items from both queues with priority ordering:
   * - Incoming messages are processed via round-robin across peers
   * - Storage streaming entries are processed by priority (MEDIUM before LOW)
   *
   * Implements time budget scheduling to avoid blocking the main thread.
   */
  async processQueues() {
    if (this.processing)
      return;
    this.processing = !0;
    let A = performance.now();
    const e = this.getStorageStreamingQueue();
    for (; ; ) {
      const t = this.messagesQueue.pull();
      if (t)
        try {
          this.handleSyncMessage(t.msg, t.peer);
        } catch (r) {
          Z.error("Error processing message", { err: r });
        }
      const o = e?.pull();
      if (o)
        try {
          o();
        } catch (r) {
          Z.error("Error processing storage streaming entry", {
            err: r
          });
        }
      if (!t && !o)
        break;
      performance.now() - A > sc.INCOMING_MESSAGES_TIME_BUDGET && (await zs(), A = performance.now());
    }
    this.processing = !1;
  }
  addPeer(A, e = !1) {
    const t = this.peers[A.id], o = t ? t.newPeerStateFrom(A) : new Kg(A, void 0);
    this.peers[A.id] = o, this.peersCounter.add(1, { role: A.role });
    const g = o.subscribeToKnownStatesUpdates((r, n) => {
      this.syncState.triggerUpdate(A, r, n.value());
    });
    !e && o.role === "server" && this.startPeerReconciliation(o), o.incoming.onMessage((r) => {
      if (r === "Disconnected") {
        o.gracefulShutdown();
        return;
      }
      this.pushMessage(r, o);
    }), o.addCloseListener(() => {
      g(), this.peersCounter.add(-1, { role: A.role }), !A.persistent && this.peers[A.id] === o && this.removePeer(A.id);
    });
  }
  removePeer(A) {
    const e = this.peers[A];
    e && (e.closed || e.gracefulShutdown(), delete this.peers[e.id]);
  }
  trySendToPeer(A, e) {
    return A.pushOutgoingMessage(e);
  }
  /**
   * Handles the load message from a peer.
   *
   * Differences with the known state message:
   * - The load message triggers the CoValue loading process on the other peer
   * - The peer known state is stored as-is instead of being merged
   * - The load message always replies with a known state message
   */
  handleLoad(A, e) {
    e.setKnownState(A.id, Do(A));
    const t = this.local.getCoValue(A.id);
    if (t.isAvailable()) {
      this.sendNewContent(A.id, e);
      return;
    }
    const o = e.getOptimisticKnownState(A.id);
    if (!o?.header) {
      this.loadFromStorageAndRespond(A.id, e, t);
      return;
    }
    t.getKnownStateFromStorage((g) => {
      if (t.isAvailable()) {
        this.sendNewContent(A.id, e);
        return;
      }
      if (!g) {
        this.loadFromPeersAndRespond(A.id, e, t);
        return;
      }
      if (Ec(g, o)) {
        e.trackToldKnownState(A.id), this.trySendToPeer(e, {
          action: "known",
          ...g
        });
        return;
      }
      this.loadFromStorageAndRespond(A.id, e, t);
    });
  }
  /**
   * Helper to load from storage and respond appropriately.
   * Falls back to peers if not found in storage.
   */
  loadFromStorageAndRespond(A, e, t) {
    t.loadFromStorage((o) => {
      o && t.isAvailable() ? this.sendNewContent(A, e) : this.loadFromPeersAndRespond(A, e, t);
    });
  }
  /**
   * Helper to load from peers and respond appropriately.
   */
  loadFromPeersAndRespond(A, e, t) {
    const o = this.getServerPeers(A, e.id);
    t.loadFromPeers(o);
    const g = () => {
      if (t.isAvailable()) {
        this.sendNewContent(A, e);
        return;
      }
      this.handleLoadNotFound(A, e);
    };
    o.length > 0 ? t.waitForAvailableOrUnavailable().then(g) : g();
  }
  /**
   * Handle case when CoValue is not found.
   */
  handleLoadNotFound(A, e) {
    e.trackToldKnownState(A), this.trySendToPeer(e, {
      action: "known",
      id: A,
      header: !1,
      sessions: {}
    });
  }
  /**
   * Request full content from a peer when we don't have the CoValue.
   */
  requestFullContent(A, e) {
    e ? this.trySendToPeer(e, {
      action: "known",
      isCorrection: !0,
      id: A,
      header: !1,
      sessions: {}
    }) : Z.error("Received new content with no header on a missing CoValue", {
      id: A
    });
  }
  handleKnownState(A, e) {
    const t = this.local.getCoValue(A.id);
    e.combineWith(A.id, Do(A)), e.getOptimisticKnownState(A.id)?.header || t.markNotFoundInPeer(e.id), t.isAvailable() && this.sendNewContent(A.id, e), e.trackLoadRequestComplete(t);
  }
  recordTransactionsSize(A, e) {
    for (const t of A) {
      const o = eo(t);
      this.transactionsSizeHistogram.record(o, {
        source: e
      });
    }
  }
  handleNewContent(A, e) {
    const t = this.local.getCoValue(A.id), o = e === "storage" || e === "import" ? void 0 : e, g = e === "storage" ? "storage" : e === "import" ? "import" : o?.role;
    if (o?.role === "client" && A.expectContentUntil && (A = {
      ...A,
      expectContentUntil: void 0
    }), o?.trackLoadRequestUpdate(t), t.addDependenciesFromContentMessage(A), !this.skipVerify && t.hasMissingDependencies()) {
      t.addNewContentToQueue(A, e);
      for (const I of t.missingDependencies) {
        const C = this.local.getCoValue(I);
        if (!C.hasVerifiedContent()) {
          const c = this.getServerPeers(I);
          o?.role === "client" && c.push(o), C.load(c, "immediate");
        }
      }
      return;
    }
    if (t.hasVerifiedContent())
      A.expectContentUntil && t.verified.setStreamingKnownState(A.expectContentUntil);
    else {
      if (!A.header) {
        if (e === "storage") {
          Z.warn("Received content from storage without header - CoValue may have been garbage collected mid-stream", {
            id: A.id,
            from: e
          });
          return;
        }
        t.loadFromStorage((c) => {
          c ? this.handleNewContent(A, e) : this.requestFullContent(A.id, o);
        });
        return;
      }
      const I = t.loadingState;
      if (!t.provideHeader(A.header, A.expectContentUntil, this.skipVerify)) {
        Z.error("Failed to provide header", {
          id: A.id,
          header: A.header
        });
        return;
      }
      t.markFoundInPeer(o?.id ?? "storage", I), o?.updateHeader(A.id, !0), A.expectContentUntil && o?.combineWith(A.id, {
        id: A.id,
        header: !0,
        sessions: A.expectContentUntil
      });
    }
    if (!t.hasVerifiedContent())
      throw new Error("Unreachable: CoValue should always have a verified state at this point");
    let r = !1;
    const n = {
      action: "content",
      id: A.id,
      priority: A.priority,
      header: A.header,
      new: {}
    };
    let s = t.isDeleted;
    for (const [I, C] of uc(A)) {
      if (s && !Ne(I))
        continue;
      const c = hc(C, t.knownState(), I);
      if (c === void 0) {
        r = !0;
        continue;
      }
      if (c.length === 0)
        continue;
      const Q = t.tryAddTransactions(I, c, C.lastSignature, this.skipVerify);
      if (Q) {
        o ? (Z.error("Failed to add transactions", {
          peerId: o.id,
          peerRole: o.role,
          id: A.id,
          errorType: Q.type,
          err: Q.error,
          sessionID: I,
          msgKnownState: Ht(A).sessions,
          msgSummary: Mo(A),
          knownState: t.knownState().sessions
        }), t.markErrored(o.id, Q)) : Z.error("Failed to add transactions from storage", {
          id: A.id,
          err: Q.error,
          sessionID: I,
          errorType: Q.type
        });
        continue;
      }
      g && g !== "import" && this.recordTransactionsSize(c, g), !s && t.isDeleted && (s = !0, n.new = {}), n.new[I] = C;
    }
    o && (t.isDeleted ? o.combineWith(A.id, Ht(A)) : o.combineWith(A.id, Ht(n))), r ? o ? (this.trySendToPeer(o, {
      action: "known",
      isCorrection: !0,
      ...t.knownState()
    }), o.trackToldKnownState(A.id)) : Z.error("Invalid state assumed when handling new content from storage", {
      id: A.id,
      content: Mo(A),
      knownState: t.knownState()
    }) : o && (t.isDeleted ? this.trySendToPeer(o, t.stopSyncingKnownStateMessage(o.getKnownState(A.id))) : this.trySendToPeer(o, {
      action: "known",
      ...t.knownState()
    }), o.trackToldKnownState(A.id));
    const a = n.header || Object.keys(n.new).length > 0;
    e !== "storage" && a && (this.storeContent(n), e === "import" && this.trackSyncState(t.id)), o?.trackLoadRequestComplete(t);
    for (const I of this.getPeers(t.id)) {
      if (I.closed || t.isErroredInPeer(I.id)) {
        I.emitCoValueChange(t.id);
        continue;
      }
      I.isCoValueSubscribedToPeer(t.id) ? this.sendNewContent(t.id, I) : I.role === "server" && I.sendLoadRequest(t);
    }
  }
  handleCorrection(A, e) {
    return e.setKnownState(A.id, Do(A)), this.sendNewContent(A.id, e);
  }
  syncContent(A) {
    const e = this.local.getCoValue(A.id);
    this.storeContent(A), this.trackSyncState(e.id);
    const t = Ht(A);
    for (const o of this.getPeers(e.id))
      if (!(o.role === "client" && !o.isCoValueSubscribedToPeer(e.id))) {
        if (o.closed || e.isErroredInPeer(o.id)) {
          o.emitCoValueChange(A.id);
          continue;
        }
        this.trySendToPeer(o, A), o.combineOptimisticWith(e.id, t), o.trackToldKnownState(e.id);
      }
  }
  trackSyncState(A) {
    const e = this.getPersistentServerPeers(A);
    if (this.local.syncWhen !== "never" && e.length === 0) {
      this.unsyncedTracker.add(A);
      const o = this.syncState.subscribeToCoValueUpdates(A, (g, r, n) => {
        Sr(g) && n.uploaded && (this.unsyncedTracker.remove(A), o());
      });
      return;
    }
    for (const o of e) {
      if (this.syncState.isSynced(o, A) || this.unsyncedTracker.add(A, o.id))
        continue;
      const r = this.syncState.subscribeToPeerUpdates(o.id, A, (n, s) => {
        s.uploaded && (this.unsyncedTracker.remove(A, o.id), r());
      });
    }
  }
  storeContent(A) {
    const e = this.local.storage;
    if (!e)
      return;
    const t = this.local.getCoValue(A.id);
    t.isDeleted && e.markDeleteAsValid(t.id), e.store(A, (o) => {
      if (!t.verified) {
        Z.error("Correction requested for a CoValue with no verified content", {
          id: A.id,
          content: Mo(A),
          correction: o,
          state: t.loadingState
        });
        return;
      }
      return t.newContentSince(o);
    });
  }
  /**
   * Returns true if the local CoValue changes have been synced to all persistent server peers.
   *
   * Used during garbage collection to determine if the coValue is pending sync.
   */
  isSyncedToServerPeers(A) {
    return this.getPersistentServerPeers(A).every((e) => this.syncState.isSynced(e, A));
  }
  waitForSyncWithPeer(A, e, t) {
    const o = this.peers[A];
    if (o) {
      if (o.isCoValueSubscribedToPeer(e)) {
        if (this.syncState.isSynced(o, e))
          return;
      } else if (o.role === "client")
        return;
      return new Promise((g, r) => {
        const n = this.syncState.subscribeToPeerUpdates(A, e, (a, I) => {
          I.uploaded && (g(!0), n?.(), clearTimeout(s));
        }), s = setTimeout(() => {
          const a = this.local.getCoValue(e), I = a.getErroredInPeerError(A), C = a.knownState().sessions, c = o.getKnownState(e)?.sessions ?? {};
          let Q = `Timeout on waiting for sync with peer ${A} for coValue ${e}:
  Known state: ${JSON.stringify(C)}
  Peer state: ${JSON.stringify(c)}
`;
          I && (Q += `
Marked as errored: "${I}"`), r(new Error(Q)), n?.();
        }, t);
      });
    }
  }
  waitForStorageSync(A) {
    return this.local.storage?.waitForSync(A, this.local.getCoValue(A));
  }
  waitForSync(A, e = 6e4) {
    const t = this.getPeers(A);
    return Promise.all(t.map((o) => this.waitForSyncWithPeer(o.id, A, e)).concat(this.waitForStorageSync(A)));
  }
  waitForAllCoValuesSync(A = 6e4) {
    const e = this.local.allCoValues(), t = Array.from(e).filter((o) => o.loadingState === "available" || o.loadingState === "loading");
    return Promise.all(t.map((o) => this.waitForSync(o.id, A)));
  }
  setStorage(A) {
    this.unsyncedTracker.setStorage(A);
    const e = this.getStorageStreamingQueue();
    e && e.setListener(() => {
      this.processQueues();
    });
  }
  removeStorage() {
    this.unsyncedTracker.removeStorage();
  }
  /**
   * Closes all the peer connections and ensures the list of unsynced coValues is persisted to storage.
   * @returns Promise of the current pending store operation, if any.
   */
  gracefulShutdown() {
    for (const A of Object.values(this.peers))
      A.gracefulShutdown();
    return this.unsyncedTracker.forcePersist();
  }
}
let zs = () => new Promise((i) => queueMicrotask(i));
typeof setImmediate == "function" && (zs = () => new Promise((i) => setImmediate(i)));
function Yc(i, A, { peer1role: e = "client", peer2role: t = "client", persistent: o = !1 } = {}) {
  const g = new Xo(), r = new Xo();
  return [{
    id: i,
    incoming: g,
    outgoing: r,
    role: e,
    persistent: o
  }, {
    id: A,
    incoming: r,
    outgoing: g,
    role: t,
    persistent: o
  }];
}
let Xo = class {
  constructor() {
    this.buffer = [], this.listeners = /* @__PURE__ */ new Set(), this.closed = !1, this.closeListeners = /* @__PURE__ */ new Set();
  }
  push(A) {
    if (!this.listeners.size) {
      this.buffer.push(A);
      return;
    }
    for (const e of this.listeners)
      e(A);
  }
  close() {
    this.closed = !0;
    for (const A of this.closeListeners)
      A();
    this.closeListeners.clear(), this.listeners.clear();
  }
  onMessage(A) {
    if (this.buffer.length) {
      for (const e of this.buffer)
        A(e);
      this.buffer = [];
    }
    this.listeners.add(A);
  }
  onClose(A) {
    this.closeListeners.add(A);
  }
};
class pe {
  /** @category 3. Low-level */
  constructor(A, e, t, o) {
    this.syncWhen = o, this.coValues = /* @__PURE__ */ new Map(), this.syncManager = new Kc(this), this.garbageCollector = void 0, this.crashed = void 0, this.agentSecret = A, this.currentSessionID = e, this.crypto = t;
  }
  enableGarbageCollector() {
    this.garbageCollector || (this.garbageCollector = new Sc(this));
  }
  setStorage(A) {
    this.storage = A, this.syncManager.setStorage(A);
  }
  removeStorage() {
    this.storage?.close(), this.storage = void 0, this.syncManager.removeStorage();
  }
  /**
   * Enable background erasure of deleted coValues (space reclamation).
   *
   * Deleted coValues are immediately blocked from syncing via tombstones; this feature
   * only reclaims local storage space by deleting historical content while preserving
   * the tombstone (header + delete session).
   *
   * This is opt-in and affects only the currently configured storage (if any)
   *
   * @category 3. Low-level
   */
  enableDeletedCoValuesErasure() {
    this.storage?.enableDeletedCoValuesErasure();
  }
  hasCoValue(A) {
    const e = this.coValues.get(A);
    if (!e)
      return !1;
    const t = e.loadingState;
    return t !== "unknown" && t !== "garbageCollected" && t !== "onlyKnownState";
  }
  getCoValue(A) {
    let e = this.coValues.get(A);
    return e || (e = new Dr(A, this), this.coValues.set(A, e)), this.garbageCollector?.trackCoValueAccess(e), e;
  }
  allCoValues() {
    return this.coValues.values();
  }
  /**
   * Simple delete of a CoValue from memory.
   * Used for testing and forced cleanup scenarios.
   * @internal
   */
  internalDeleteCoValue(A) {
    this.coValues.delete(A), this.storage?.onCoValueUnmounted(A);
  }
  /**
   * Unmount a CoValue from memory, keeping a shell with cached knownState.
   * This enables accurate LOAD requests during peer reconciliation.
   *
   * @returns true if the coValue was successfully unmounted, false otherwise
   */
  internalUnmountCoValue(A) {
    const e = this.coValues.get(A);
    if (!e || e.listeners.size > 0)
      return !1;
    for (const g of e.dependant)
      if (this.hasCoValue(g))
        return !1;
    if (!this.syncManager.isSyncedToServerPeers(A))
      return !1;
    const t = e.knownState();
    e.decrementLoadingStateCounter();
    const o = new Dr(A, this);
    return o.setGarbageCollectedState(t), this.coValues.set(A, o), this.storage?.onCoValueUnmounted(A), !0;
  }
  getCurrentAccountOrAgentID() {
    return vA(this.currentSessionID);
  }
  getCurrentAgent() {
    if (!this._cachedCurrentAgent) {
      const A = this.getCurrentAccountOrAgentID();
      Oe(A) ? this._cachedCurrentAgent = new Qr(this.agentSecret, this.crypto) : this._cachedCurrentAgent = new tc(Er(this.expectCoValueLoaded(A).getCurrentContent()), this.agentSecret);
    }
    return this._cachedCurrentAgent;
  }
  expectCurrentAccountID(A) {
    const e = this.getCurrentAccountOrAgentID();
    if (Oe(e))
      throw new Error("Current account is an agent, but expected an account: " + A);
    return e;
  }
  expectCurrentAccount(A) {
    const e = this.expectCurrentAccountID(A);
    return Er(this.expectCoValueLoaded(e).getCurrentContent());
  }
  static internalCreateAccount(A) {
    const { crypto: e, initialAgentSecret: t = e.newRandomAgentSecret(), peers: o = [], syncWhen: g } = A, r = Hs(t, e), n = pt(r, e), s = new pe(t, e.newRandomSessionID(n), e, g);
    A.storage && s.setStorage(A.storage);
    for (const Q of o)
      s.syncManager.addPeer(Q);
    const a = e.getAgentID(t), I = DA(s.createCoValue(r).getCurrentContent());
    I.set(a, "admin", "trusting");
    const C = e.newRandomKeySecret(), c = e.seal({
      message: C.secret,
      from: e.getAgentSealerSecret(t),
      to: e.getAgentSealerID(a),
      nOnceMaterial: {
        in: I.id,
        tx: I.core.nextTransactionID()
      }
    });
    return I.set(`${C.id}_for_${a}`, c, "trusting"), I.set("readKey", C.id, "trusting"), s.expectCurrentAccount("after creation");
  }
  /** @category 2. Node Creation */
  static async withNewlyCreatedAccount({ creationProps: A, peers: e, syncWhen: t, migration: o, crypto: g, initialAgentSecret: r = g.newRandomAgentSecret(), storage: n }) {
    const s = pe.internalCreateAccount({
      crypto: g,
      initialAgentSecret: r,
      peers: e,
      syncWhen: t,
      storage: n
    }), a = s.core.node;
    if (o)
      await o(s, a, A);
    else {
      const C = a.createGroup();
      C.addMember("everyone", "reader");
      const c = C.createMap({
        name: A.name
      });
      s.set("profile", c.id, "trusting");
    }
    const I = s.get("profile");
    if (!I)
      throw new Error("Must set account profile in initial migration");
    return a.storage && await Promise.all([
      a.syncManager.waitForStorageSync(s.id),
      a.syncManager.waitForStorageSync(I)
    ]), {
      node: a,
      accountID: s.id,
      accountSecret: r,
      sessionID: a.currentSessionID
    };
  }
  /** @category 2. Node Creation */
  static async withLoadedAccount({ accountID: A, accountSecret: e, sessionID: t, peers: o, syncWhen: g, crypto: r, migration: n, storage: s }) {
    try {
      const a = r.getAgentID(e), I = new pe(e, t || r.newRandomSessionID(A), r, g);
      s && I.setStorage(s);
      for (const d of o)
        I.syncManager.addPeer(d);
      const C = await I.load(A);
      if (C === "unavailable")
        throw new Error("Account unavailable from all peers");
      if (C.currentAgentID() !== a)
        throw new Error("Account secret does not match expected agent ID in account");
      const c = C.get("profile");
      if (!c)
        throw new Error("Account has no profile");
      const Q = C.get("root");
      return Q && (C.getRaw("root")?.trusting || C.set("root", Q, "trusting")), await I.load(c), n && await n(C, I), I;
    } catch (a) {
      throw Z.error("Error withLoadedAccount", { err: a }), a;
    }
  }
  /** @internal */
  createCoValue(A) {
    if (this.crashed)
      throw new Error("Trying to create CoValue after node has crashed", {
        cause: this.crashed
      });
    const e = pt(A, this.crypto), t = this.getCoValue(e);
    if (t.provideHeader(A), !t.hasVerifiedContent())
      throw new Error("CoValue not available after providing header");
    return this.garbageCollector?.trackCoValueAccess(t), this.syncManager.syncLocalTransaction(t.verified, ke(e)), t;
  }
  /** @internal */
  async loadCoValueCore(A, e, t) {
    if (!ks(A))
      throw new TypeError(`Trying to load CoValue with invalid id ${Array.isArray(A) ? JSON.stringify(A) : A}`);
    if (this.crashed)
      throw new Error("Trying to load CoValue after node has crashed", {
        cause: this.crashed
      });
    let o = 0;
    for (; ; ) {
      const g = this.getCoValue(A);
      if (g.isAvailable())
        return g;
      if (g.loadingState === "unknown" || g.loadingState === "unavailable" || g.loadingState === "garbageCollected" || g.loadingState === "onlyKnownState") {
        const n = this.syncManager.getServerPeers(A, e);
        if (!this.storage && n.length === 0)
          return g.markNotFoundInPeer("storage"), g;
        g.load(n);
      }
      const r = await g.waitForAvailableOrUnavailable();
      if (r.isAvailable() || t || o >= Pe.MAX_RETRIES)
        return r;
      await Promise.race([
        new Promise((n) => setTimeout(n, Pe.RETRY_DELAY)),
        g.waitForAvailable()
        // Stop waiting if the coValue becomes available
      ]), o++;
    }
  }
  /**
   * Loads a CoValue's content, syncing from peers as necessary and resolving the returned
   * promise once a first version has been loaded. See `coValue.subscribe()` and `node.useTelepathicData()`
   * for listening to subsequent updates to the CoValue.
   *
   * @category 3. Low-level
   */
  async load(A, e) {
    const t = await this.loadCoValueCore(A, void 0, e);
    return t.isAvailable() ? t.getCurrentContent() : "unavailable";
  }
  /**
   * Loads a branch from a group coValue, creating a new one if it doesn't exist.
   *
   * Returns "unavailable" in case of errors or missing source.
   */
  async checkoutBranch(A, e, t) {
    const o = await this.loadCoValueCore(A);
    if (!o.isAvailable())
      return "unavailable";
    if (!js(o))
      return o.getCurrentContent();
    const g = o.getBranch(e, t);
    return g.isAvailable() ? g.getCurrentContent() : !o.hasBranch(e, t) || (await this.loadCoValueCore(g.id), !g.isAvailable()) ? o.createBranch(e, t).getCurrentContent() : g.getCurrentContent();
  }
  getLoaded(A) {
    const e = this.getCoValue(A);
    if (e.isAvailable())
      return e.getCurrentContent();
  }
  /** @category 3. Low-level */
  subscribe(A, e, t) {
    let o = !1, g;
    return this.load(A, t).then((r) => {
      if (!o) {
        if (r === "unavailable") {
          e("unavailable");
          return;
        }
        g = r.subscribe(e);
      }
    }).catch((r) => {
      Z.error("Subscription error", {
        id: A,
        err: r
      });
    }), () => {
      o = !0, g?.();
    };
  }
  async acceptInvite(A, e) {
    const t = await this.load(A);
    if (t === "unavailable")
      throw new Error("Trying to accept invite: Group/owned value unavailable from all peers");
    const o = t.core.verified.header.ruleset;
    let g;
    if (o.type === "unsafeAllowAll")
      throw new Error("Can only accept invites to values owned by groups");
    if (o.type === "ownedByGroup") {
      const d = await this.load(o.group);
      if (d === "unavailable")
        throw new Error("Trying to accept invite: CoValue owner unavailable from all peers");
      g = DA(d);
    } else
      g = DA(t);
    if (g.core.verified.header.meta?.type === "account")
      throw new Error("Can't accept invites to values owned by accounts");
    const r = this.crypto.agentSecretFromSecretSeed(ec(e)), n = this.crypto.getAgentID(r), s = await new Promise((d, f) => {
      g.subscribe((h) => {
        const l = h.get(n);
        l && d(l);
      }), setTimeout(() => f(new Error("Couldn't find invite before timeout")), 2e3);
    });
    if (!s)
      throw new Error("No invite found");
    const a = this.getCurrentAgent(), I = g.get(a.id);
    if (I === "admin" || I === "writer" && s === "writerInvite" || I === "writer" && s === "reader" || I === "reader" && s === "readerInvite" || I && s === "writeOnlyInvite") {
      Z.debug("Not accepting invite that would replace or downgrade role");
      return;
    }
    const C = await this.loadCoValueAsDifferentAgent(g.id, r), c = DA(C.getCurrentContent());
    c.addMemberInternal(a, s === "adminInvite" ? "admin" : s === "managerInvite" ? "manager" : s === "writerInvite" ? "writer" : s === "writeOnlyInvite" ? "writeOnly" : "reader");
    const Q = c.core.newContentSince(g.core.knownState()) ?? [];
    for (const d of Q)
      this.syncManager.handleNewContent(d, "import");
  }
  /** @internal */
  expectCoValueLoaded(A, e) {
    const t = this.getCoValue(A);
    if (!t.isAvailable())
      throw new Error(`${e ? e + ": " : ""}CoValue ${A} not yet loaded.`);
    return t;
  }
  /** @internal */
  expectProfileLoaded(A, e) {
    const t = this.expectCoValueLoaded(A, e), o = DA(t.getCurrentContent()).get("profile");
    if (!o)
      throw new Error(`${e ? e + ": " : ""}Account ${A} has no profile`);
    return this.expectCoValueLoaded(o, e).getCurrentContent();
  }
  /** @internal */
  resolveAccountAgent(A, e) {
    if (Oe(A))
      return { value: A, error: void 0 };
    let t;
    try {
      t = this.expectCoValueLoaded(A, e);
    } catch (g) {
      return { value: void 0, error: g };
    }
    if (t.verified.header.type !== "comap" || t.verified.header.ruleset.type !== "group" || !t.verified.header.meta || !("type" in t.verified.header.meta) || t.verified.header.meta.type !== "account")
      return {
        value: void 0,
        error: new Error(`Unexpectedly not account: ${e}`)
      };
    const o = t.verified.header.ruleset.initialAdmin;
    return Oe(o) ? { value: o, error: void 0 } : {
      value: void 0,
      error: new Error(`Unexpectedly not account: ${e}`)
    };
  }
  createGroup(A = this.crypto.createdNowUnique()) {
    const e = this.getCurrentAgent(), t = this.createCoValue({
      type: "comap",
      ruleset: { type: "group", initialAdmin: e.id },
      meta: null,
      ...A.createdAt !== void 0 ? { createdAt: A.createdAt } : {},
      uniqueness: A.uniqueness
    }), o = DA(t.getCurrentContent());
    o.set(e.id, "admin", "trusting");
    const g = this.crypto.newRandomKeySecret();
    return o.set(`${g.id}_for_${e.id}`, this.crypto.seal({
      message: g.secret,
      from: e.currentSealerSecret(),
      to: e.currentSealerID(),
      nOnceMaterial: {
        in: t.id,
        tx: t.nextTransactionID()
      }
    }), "trusting"), o.set("readKey", g.id, "trusting"), o;
  }
  async loadCoValueAsDifferentAgent(A, e, t) {
    const o = new Qr(e, this.crypto), g = new pe(e, this.crypto.newRandomSessionID(t || o.id), this.crypto);
    return await g.loadVerifiedStateFrom(this, A), g.expectCoValueLoaded(A);
  }
  /** @internal */
  async loadVerifiedStateFrom(A, e) {
    const t = Yc("source-" + e, "target-" + e, {
      peer1role: "server",
      peer2role: "client"
    });
    this.syncManager.addPeer(t[0], !0), A.syncManager.addPeer(t[1], !0);
    const o = this.getCoValue(e), g = this.syncManager.peers[t[0].id];
    if (!g)
      throw new Error("Peer state not found");
    o.loadFromPeers([g]), await o.waitForAvailable(), g.gracefulShutdown();
  }
  /**
   * Closes all the peer connections, drains all the queues and closes the storage.
   *
   * @returns Promise of the current pending store operation, if any.
   */
  async gracefulShutdown() {
    return this.garbageCollector?.stop(), await this.syncManager.gracefulShutdown(), this.storage?.close();
  }
}
function vc({ newTxsInSession: i, contentMessage: A, sessionRow: e, firstNewTxIdx: t, signature: o }) {
  let g = A.new[e.sessionID];
  g ? g.lastSignature = o : (g = {
    after: t,
    lastSignature: o,
    newTransactions: []
  }, A.new[e.sessionID] = g);
  for (const r of i)
    g.newTransactions.push(r.tx);
}
function Uc(i, A) {
  const e = A.id, t = Object.keys(A.new), o = Object.values(A.new).map((g) => g.newTransactions);
  return cc(e, i, t, o);
}
function Jc(i) {
  return i.reduce((A, e) => A + eo(e), 0);
}
const Hc = {
  [KA.HIGH]: 0,
  [KA.MEDIUM]: 1,
  [KA.LOW]: 2
};
class qc {
  constructor(A, e, t) {
    this.defaultPriority = A, this.queues = [
      ht(e, { priority: KA.HIGH, ...t }),
      ht(e, { priority: KA.MEDIUM, ...t }),
      ht(e, { priority: KA.LOW, ...t })
    ];
  }
  getQueue(A) {
    return this.queues[Hc[A]];
  }
  push(A) {
    const e = "priority" in A ? A.priority : this.defaultPriority;
    this.getQueue(e).push(A);
  }
  pull() {
    const A = this.queues.findIndex((e) => e.length > 0);
    return this.queues[A]?.shift();
  }
}
var Dt;
(function(i) {
  i[i.Pending = 0] = "Pending", i[i.Done = 1] = "Done";
})(Dt || (Dt = {}));
class Lc {
  constructor() {
    this.knownStates = /* @__PURE__ */ new Map(), this.waitForSyncRequests = /* @__PURE__ */ new Map();
  }
  getKnownState(A) {
    const e = this.knownStates.get(A);
    if (!e) {
      const t = ke(A);
      return this.knownStates.set(A, t), t;
    }
    return e;
  }
  /**
   * Get a cached knownState if it exists and has a header.
   * Unlike getKnownState, this doesn't create an empty state if one doesn't exist.
   */
  getCachedKnownState(A) {
    const e = this.knownStates.get(A);
    if (e?.header)
      return e;
  }
  setKnownState(A, e) {
    this.knownStates.set(A, e);
  }
  handleUpdate(A, e) {
    const t = this.waitForSyncRequests.get(A);
    if (t)
      for (const o of t)
        Nr(o.knownState, e) && (o.resolve(), t.delete(o));
  }
  waitForSync(A, e) {
    const t = e.knownState();
    if (Nr(t, this.getKnownState(A)))
      return Promise.resolve();
    const o = this.waitForSyncRequests.get(A) || /* @__PURE__ */ new Set();
    return this.waitForSyncRequests.set(A, o), new Promise((g) => {
      const r = e.subscribe((a) => {
        s.knownState = a.knownState(), this.handleUpdate(A, this.getKnownState(A));
      }, !1), s = { knownState: t, resolve: () => {
        g(), r();
      } };
      o.add(s);
    });
  }
}
function Nr(i, A) {
  return !A.header && i.header ? !1 : Ts(i.sessions, A.sessions);
}
const xc = {
  throttleMs: 6e4,
  startupDelayMs: 1e3,
  followUpDelayMs: 1e3
};
class Tc {
  isDisposed() {
    return this.state === "disposed";
  }
  constructor({ run: A, opts: e }) {
    this.state = "idle", this.runCallback = A, this.opts = e || xc;
  }
  scheduleStartupDrain() {
    this.isDisposed() || this.state === "idle" && this.scheduleTimer("startup_scheduled", this.opts.startupDelayMs);
  }
  onEnqueueDeletedCoValue() {
    this.isDisposed() || this.state === "idle" && this.scheduleTimer("throttle_scheduled", this.opts.throttleMs);
  }
  dispose() {
    this.isDisposed() || (this.state = "disposed", this.scheduledTimeout && clearTimeout(this.scheduledTimeout), this.scheduledTimeout = void 0);
  }
  scheduleTimer(A, e) {
    this.isDisposed() || this.scheduledTimeout || (this.state = A, this.scheduledTimeout = setTimeout(() => {
      this.scheduledTimeout = void 0, this.run();
    }, e));
  }
  async run() {
    if (this.isDisposed())
      return;
    this.state = "running";
    let A;
    try {
      A = await this.runCallback();
    } catch (e) {
      Z.error("Error running deleted co values eraser scheduler", {
        err: e
      }), this.isDisposed() || (this.state = "idle");
      return;
    }
    if (!this.isDisposed()) {
      if (A.hasMore) {
        this.scheduleTimer("followup_scheduled", this.opts.followUpDelayMs);
        return;
      }
      this.state = "idle";
    }
  }
}
class Oc {
  constructor() {
    this.backlog = new io(), this.processing = !1;
  }
  async schedule(A, e) {
    if (this.backlog.push({ queue: A, callback: e }), !this.processing) {
      for (this.processing = !0; this.backlog.head; )
        await this.backlog.head.value.callback(), this.backlog.shift();
      this.processing = !1;
    }
  }
}
class oo {
  constructor() {
    this.queue = new io(), this.closed = !1, this.processing = !1;
  }
  push(A, e) {
    this.closed || this.queue.push({ data: A, correctionCallback: e });
  }
  pull() {
    return this.queue.shift();
  }
  processQueue(A) {
    if (!this.processing)
      return this.processing = !0, oo.manager.schedule(this, async () => {
        let e;
        for (; e = this.pull(); ) {
          const { data: t, correctionCallback: o } = e;
          try {
            this.lastCallback = A(t, o), await this.lastCallback;
          } catch (g) {
            Z.error("Error processing message in store queue", { err: g });
          }
        }
        this.lastCallback = void 0, this.processing = !1;
      });
  }
  close() {
    for (this.closed = !0; this.pull(); )
      ;
    return this.lastCallback;
  }
}
oo.manager = new Oc();
class $s {
  constructor(A) {
    this.inMemoryCoValues = /* @__PURE__ */ new Set(), this.pendingKnownStateLoads = /* @__PURE__ */ new Map(), this.knownStates = new Lc(), this.storeQueue = new oo(), this.deletedValues = /* @__PURE__ */ new Set(), this.dbClient = A;
  }
  getKnownState(A) {
    return this.knownStates.getKnownState(A);
  }
  loadKnownState(A, e) {
    const t = this.knownStates.getCachedKnownState(A);
    if (t) {
      e(t);
      return;
    }
    const o = this.pendingKnownStateLoads.get(A);
    if (o) {
      o.then(e, () => e(void 0));
      return;
    }
    const g = this.dbClient.getCoValueKnownState(A).then((r) => (r && this.knownStates.setKnownState(A, r), r)).catch((r) => {
      Z.warn("Failed to load knownState from storage", { id: A, err: r });
    }).finally(() => {
      this.pendingKnownStateLoads.delete(A);
    });
    this.pendingKnownStateLoads.set(A, g), g.then(e);
  }
  async load(A, e, t) {
    await this.loadCoValue(A, e, t);
  }
  async loadCoValue(A, e, t) {
    this.interruptEraser("load");
    const o = await this.dbClient.getCoValue(A);
    if (!o) {
      t?.(!1);
      return;
    }
    const g = await this.dbClient.getCoValueSessions(o.rowID), r = /* @__PURE__ */ new Map();
    let n = !1;
    await Promise.all(g.map(async (C) => {
      const c = await this.dbClient.getSignatures(C.rowID, 0);
      c.length > 0 && (n = !0, r.set(C.sessionID, c));
    }));
    const s = this.knownStates.getKnownState(o.id);
    s.header = !0;
    for (const C of g)
      So(s.sessions, C.sessionID, C.lastIdx);
    this.inMemoryCoValues.add(o.id);
    let a = dt(o.id, o.header);
    n && (a.expectContentUntil = s.sessions);
    for (const C of g) {
      const c = r.get(C.sessionID) || [];
      let Q = 0;
      c[c.length - 1]?.signature !== C.lastSignature && c.push({
        idx: C.lastIdx,
        signature: C.lastSignature
      });
      for (const f of c) {
        const h = await this.dbClient.getNewTransactionInSession(C.rowID, Q, f.idx);
        vc({
          newTxsInSession: h,
          contentMessage: a,
          sessionRow: C,
          firstNewTxIdx: Q,
          signature: f.signature
        }), Q = f.idx + 1, c.length > 1 && (await this.pushContentWithDependencies(o, a, e), a = dt(o.id, o.header));
      }
    }
    (Object.keys(a.new).length > 0 || !n) && await this.pushContentWithDependencies(o, a, e), this.knownStates.handleUpdate(o.id, s), t?.(!0);
  }
  async pushContentWithDependencies(A, e, t) {
    const o = Uc(A.header, e), g = [];
    for (const r of o)
      this.inMemoryCoValues.has(r) || g.push(new Promise((n) => {
        this.loadCoValue(r, t, n);
      }));
    await Promise.all(g), t(e);
  }
  async store(A, e) {
    this.storeQueue.push(A, e), this.storeQueue.processQueue(async (t, o) => (this.interruptEraser("store"), this.storeSingle(t, o)));
  }
  interruptEraser(A) {
    this.eraserController && (this.eraserController.abort(A), this.eraserController = void 0);
  }
  async eraseAllDeletedCoValues() {
    const A = await this.dbClient.getAllCoValuesWaitingForDelete();
    this.eraserController = new AbortController();
    const e = this.eraserController.signal;
    for (const t of A) {
      if (e.aborted)
        return;
      await this.dbClient.eraseCoValueButKeepTombstone(t);
    }
  }
  /**
   * This function is called when the storage lacks the information required to store the incoming content.
   *
   * It triggers a `correctionCallback` to ask the syncManager to provide the missing information.
   *
   * The correction is applied immediately, to ensure that, when applicable, the dependent content in the queue won't require additional corrections.
   */
  async handleCorrection(A, e) {
    const t = e(A);
    if (!t)
      return Z.error("Correction callback returned undefined", {
        knownState: A,
        correction: t ?? null
      }), !1;
    for (const o of t)
      if (!await this.storeSingle(o, (r) => {
        Z.error("Double correction requested", {
          msg: o,
          knownState: r
        });
      }))
        return !1;
    return !0;
  }
  async storeSingle(A, e) {
    if (this.interruptEraser("store"), this.storeQueue.closed)
      return !1;
    const t = A.id, o = await this.dbClient.upsertCoValue(t, A.header);
    if (!o) {
      const n = ke(t);
      return this.knownStates.setKnownState(t, n), this.handleCorrection(n, e);
    }
    const g = this.knownStates.getKnownState(t);
    g.header = !0;
    let r = !1;
    for (const n of Object.keys(A.new))
      await this.dbClient.transaction(async (s) => {
        const a = await s.getSingleCoValueSession(o, n);
        this.deletedValues.has(t) && Ne(n) && await s.markCoValueAsDeleted(t), a && So(g.sessions, a.sessionID, a.lastIdx);
        const I = a?.lastIdx || 0, C = A.new[n]?.after || 0;
        if (I < C)
          r = !0;
        else {
          const c = await this.putNewTxs(s, A, n, a, o);
          So(g.sessions, n, c);
        }
      });
    return this.inMemoryCoValues.add(t), this.knownStates.handleUpdate(t, g), r ? this.handleCorrection(g, e) : !0;
  }
  async putNewTxs(A, e, t, o, g) {
    const r = e.new[t]?.newTransactions || [], n = o?.lastIdx || 0, s = n - (e.new[t]?.after || 0), a = r.slice(s);
    if (a.length === 0)
      return n;
    let I = o?.bytesSinceLastSignature || 0;
    const C = Jc(a), c = n + a.length;
    let Q = !1;
    Wi(I, C) ? (Q = !0, I = 0) : I += C;
    const d = n;
    if (!e.new[t])
      throw new Error("Session ID not found");
    const f = {
      coValue: g,
      sessionID: t,
      lastIdx: c,
      lastSignature: e.new[t].lastSignature,
      bytesSinceLastSignature: I
    }, h = await A.addSessionUpdate({
      sessionUpdate: f,
      sessionRow: o
    });
    return Q && await A.addSignatureAfter({
      sessionRowID: h,
      idx: c - 1,
      signature: e.new[t].lastSignature
    }), await Promise.all(a.map((l, B) => A.addTransaction(h, d + B, l))), c;
  }
  markDeleteAsValid(A) {
    this.deletedValues.add(A), this.deletedCoValuesEraserScheduler && this.deletedCoValuesEraserScheduler.onEnqueueDeletedCoValue();
  }
  enableDeletedCoValuesErasure() {
    this.deletedCoValuesEraserScheduler || (this.deletedCoValuesEraserScheduler = new Tc({
      run: async () => (await this.eraseAllDeletedCoValues(), { hasMore: (await this.dbClient.getAllCoValuesWaitingForDelete()).length > 0 })
    }), this.deletedCoValuesEraserScheduler.scheduleStartupDrain());
  }
  waitForSync(A, e) {
    return this.knownStates.waitForSync(A, e);
  }
  trackCoValuesSyncState(A, e) {
    this.dbClient.trackCoValuesSyncState(A).then(() => e?.());
  }
  getUnsyncedCoValueIDs(A) {
    this.dbClient.getUnsyncedCoValueIDs().then(A);
  }
  stopTrackingSyncState(A) {
    this.dbClient.stopTrackingSyncState(A);
  }
  onCoValueUnmounted(A) {
    this.inMemoryCoValues.delete(A);
  }
  close() {
    return this.deletedCoValuesEraserScheduler?.dispose(), this.inMemoryCoValues.clear(), this.storeQueue.close();
  }
}
const Yg = {
  accountHeaderForInitialAgentSecret: Hs,
  idforHeader: pt,
  CO_VALUE_PRIORITY: KA,
  ConnectedPeerChannel: Xo,
  getContentMessageSize: dc,
  WEBSOCKET_CONFIG: ac
};
let Y, X = 0, Bt = null;
function Ve() {
  return (Bt === null || Bt.byteLength === 0) && (Bt = new Uint8Array(Y.memory.buffer)), Bt;
}
const Li = typeof TextEncoder < "u" ? new TextEncoder("utf-8") : { encode: () => {
  throw Error("TextEncoder not available");
} }, Pc = typeof Li.encodeInto == "function" ? function(i, A) {
  return Li.encodeInto(i, A);
} : function(i, A) {
  const e = Li.encode(i);
  return A.set(e), {
    read: i.length,
    written: e.length
  };
};
function BA(i, A, e) {
  if (e === void 0) {
    const n = Li.encode(i), s = A(n.length, 1) >>> 0;
    return Ve().subarray(s, s + n.length).set(n), X = n.length, s;
  }
  let t = i.length, o = A(t, 1) >>> 0;
  const g = Ve();
  let r = 0;
  for (; r < t; r++) {
    const n = i.charCodeAt(r);
    if (n > 127) break;
    g[o + r] = n;
  }
  if (r !== t) {
    r !== 0 && (i = i.slice(r)), o = e(o, t, t = r + i.length * 3, 1) >>> 0;
    const n = Ve().subarray(o + r, o + t), s = Pc(i, n);
    r += s.written, o = e(o, t, r, 1) >>> 0;
  }
  return X = r, o;
}
let de = null;
function qt() {
  return (de === null || de.buffer.detached === !0 || de.buffer.detached === void 0 && de.buffer !== Y.memory.buffer) && (de = new DataView(Y.memory.buffer)), de;
}
function Qt(i) {
  const A = Y.__externref_table_alloc();
  return Y.__wbindgen_export_4.set(A, i), A;
}
function ot(i, A) {
  try {
    return i.apply(this, A);
  } catch (e) {
    const t = Qt(e);
    Y.__wbindgen_exn_store(t);
  }
}
const Zs = typeof TextDecoder < "u" ? new TextDecoder("utf-8", { ignoreBOM: !0, fatal: !0 }) : { decode: () => {
  throw Error("TextDecoder not available");
} };
typeof TextDecoder < "u" && Zs.decode();
function HA(i, A) {
  return i = i >>> 0, Zs.decode(Ve().subarray(i, i + A));
}
function Ae(i) {
  return i == null;
}
function Ag(i) {
  const A = typeof i;
  if (A == "number" || A == "boolean" || i == null)
    return `${i}`;
  if (A == "string")
    return `"${i}"`;
  if (A == "symbol") {
    const o = i.description;
    return o == null ? "Symbol" : `Symbol(${o})`;
  }
  if (A == "function") {
    const o = i.name;
    return typeof o == "string" && o.length > 0 ? `Function(${o})` : "Function";
  }
  if (Array.isArray(i)) {
    const o = i.length;
    let g = "[";
    o > 0 && (g += Ag(i[0]));
    for (let r = 1; r < o; r++)
      g += ", " + Ag(i[r]);
    return g += "]", g;
  }
  const e = /\[object ([^\]]+)\]/.exec(toString.call(i));
  let t;
  if (e && e.length > 1)
    t = e[1];
  else
    return toString.call(i);
  if (t == "Object")
    try {
      return "Object(" + JSON.stringify(i) + ")";
    } catch {
      return "Object";
    }
  return i instanceof Error ? `${i.name}: ${i.message}
${i.stack}` : t;
}
function pA(i) {
  const A = Y.__wbindgen_export_4.get(i);
  return Y.__externref_table_dealloc(i), A;
}
function dA(i, A) {
  const e = A(i.length * 1, 1) >>> 0;
  return Ve().set(i, e / 1), X = i.length, e;
}
function Ie(i, A) {
  return i = i >>> 0, Ve().subarray(i / 1, i / 1 + A);
}
function jc() {
  const i = Y.newEd25519SigningKey();
  var A = Ie(i[0], i[1]).slice();
  return Y.__wbindgen_free(i[0], i[1] * 1, 1), A;
}
function Vc(i) {
  let A, e;
  try {
    const g = dA(i, Y.__wbindgen_malloc), r = X, n = Y.getSignerId(g, r);
    var t = n[0], o = n[1];
    if (n[3])
      throw t = 0, o = 0, pA(n[2]);
    return A = t, e = o, HA(t, o);
  } finally {
    Y.__wbindgen_free(A, e, 1);
  }
}
function Wc(i, A) {
  let e, t;
  try {
    const r = dA(i, Y.__wbindgen_malloc), n = X, s = dA(A, Y.__wbindgen_malloc), a = X, I = Y.sign(r, n, s, a);
    var o = I[0], g = I[1];
    if (I[3])
      throw o = 0, g = 0, pA(I[2]);
    return e = o, t = g, HA(o, g);
  } finally {
    Y.__wbindgen_free(e, t, 1);
  }
}
function zc(i, A, e) {
  const t = dA(i, Y.__wbindgen_malloc), o = X, g = dA(A, Y.__wbindgen_malloc), r = X, n = dA(e, Y.__wbindgen_malloc), s = X, a = Y.verify(t, o, g, r, n, s);
  if (a[2])
    throw pA(a[1]);
  return a[0] !== 0;
}
function $c(i) {
  const A = dA(i, Y.__wbindgen_malloc), e = X, t = Y.blake3HashOnce(A, e);
  var o = Ie(t[0], t[1]).slice();
  return Y.__wbindgen_free(t[0], t[1] * 1, 1), o;
}
function Zc(i, A) {
  const e = dA(i, Y.__wbindgen_malloc), t = X, o = dA(A, Y.__wbindgen_malloc), g = X, r = Y.blake3HashOnceWithContext(e, t, o, g);
  var n = Ie(r[0], r[1]).slice();
  return Y.__wbindgen_free(r[0], r[1] * 1, 1), n;
}
function _c(i, A, e, t) {
  const o = dA(i, Y.__wbindgen_malloc), g = X, r = BA(A, Y.__wbindgen_malloc, Y.__wbindgen_realloc), n = X, s = BA(e, Y.__wbindgen_malloc, Y.__wbindgen_realloc), a = X, I = dA(t, Y.__wbindgen_malloc), C = X, c = Y.unseal(o, g, r, n, s, a, I, C);
  if (c[3])
    throw pA(c[2]);
  var Q = Ie(c[0], c[1]).slice();
  return Y.__wbindgen_free(c[0], c[1] * 1, 1), Q;
}
function Xc(i, A, e, t) {
  const o = dA(i, Y.__wbindgen_malloc), g = X, r = BA(A, Y.__wbindgen_malloc, Y.__wbindgen_realloc), n = X, s = BA(e, Y.__wbindgen_malloc, Y.__wbindgen_realloc), a = X, I = dA(t, Y.__wbindgen_malloc), C = X, c = Y.seal(o, g, r, n, s, a, I, C);
  if (c[3])
    throw pA(c[2]);
  var Q = Ie(c[0], c[1]).slice();
  return Y.__wbindgen_free(c[0], c[1] * 1, 1), Q;
}
function AB(i, A, e) {
  const t = dA(i, Y.__wbindgen_malloc), o = X, g = BA(A, Y.__wbindgen_malloc, Y.__wbindgen_realloc), r = X, n = dA(e, Y.__wbindgen_malloc), s = X, a = Y.encrypt(t, o, g, r, n, s);
  if (a[3])
    throw pA(a[2]);
  var I = Ie(a[0], a[1]).slice();
  return Y.__wbindgen_free(a[0], a[1] * 1, 1), I;
}
function eB(i, A, e) {
  const t = dA(i, Y.__wbindgen_malloc), o = X, g = BA(A, Y.__wbindgen_malloc, Y.__wbindgen_realloc), r = X, n = dA(e, Y.__wbindgen_malloc), s = X, a = Y.decrypt(t, o, g, r, n, s);
  if (a[3])
    throw pA(a[2]);
  var I = Ie(a[0], a[1]).slice();
  return Y.__wbindgen_free(a[0], a[1] * 1, 1), I;
}
function tB(i) {
  let A, e;
  try {
    const g = dA(i, Y.__wbindgen_malloc), r = X, n = Y.getSealerId(g, r);
    var t = n[0], o = n[1];
    if (n[3])
      throw t = 0, o = 0, pA(n[2]);
    return A = t, e = o, HA(t, o);
  } finally {
    Y.__wbindgen_free(A, e, 1);
  }
}
function iB() {
  const i = Y.newX25519PrivateKey();
  var A = Ie(i[0], i[1]).slice();
  return Y.__wbindgen_free(i[0], i[1] * 1, 1), A;
}
typeof FinalizationRegistry > "u" || new FinalizationRegistry((i) => Y.__wbg_blake3hasher_free(i >>> 0, 1));
const ko = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((i) => Y.__wbg_sessionlog_free(i >>> 0, 1));
class zi {
  static __wrap(A) {
    A = A >>> 0;
    const e = Object.create(zi.prototype);
    return e.__wbg_ptr = A, ko.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const A = this.__wbg_ptr;
    return this.__wbg_ptr = 0, ko.unregister(this), A;
  }
  free() {
    const A = this.__destroy_into_raw();
    Y.__wbg_sessionlog_free(A, 0);
  }
  /**
   * Commit pending transactions to the main state.
   * If skip_validate is false, validates the signature first.
   * If skip_validate is true, commits without validation.
   * @param {string} new_signature_str
   * @param {boolean} skip_validate
   */
  commitTransactions(A, e) {
    const t = BA(A, Y.__wbindgen_malloc, Y.__wbindgen_realloc), o = X, g = Y.sessionlog_commitTransactions(this.__wbg_ptr, t, o, e);
    if (g[1])
      throw pA(g[0]);
  }
  /**
   * @param {string} changes_json
   * @param {string} signer_secret
   * @param {string} encryption_key
   * @param {string} key_id
   * @param {number} made_at
   * @param {string | null} [meta]
   * @returns {string}
   */
  addNewPrivateTransaction(A, e, t, o, g, r) {
    let n, s;
    try {
      const Q = BA(A, Y.__wbindgen_malloc, Y.__wbindgen_realloc), d = X, f = BA(e, Y.__wbindgen_malloc, Y.__wbindgen_realloc), h = X, l = BA(t, Y.__wbindgen_malloc, Y.__wbindgen_realloc), B = X, u = BA(o, Y.__wbindgen_malloc, Y.__wbindgen_realloc), y = X;
      var a = Ae(r) ? 0 : BA(r, Y.__wbindgen_malloc, Y.__wbindgen_realloc), I = X;
      const E = Y.sessionlog_addNewPrivateTransaction(this.__wbg_ptr, Q, d, f, h, l, B, u, y, g, a, I);
      var C = E[0], c = E[1];
      if (E[3])
        throw C = 0, c = 0, pA(E[2]);
      return n = C, s = c, HA(C, c);
    } finally {
      Y.__wbindgen_free(n, s, 1);
    }
  }
  /**
   * @param {string} changes_json
   * @param {string} signer_secret
   * @param {number} made_at
   * @param {string | null} [meta]
   * @returns {string}
   */
  addNewTrustingTransaction(A, e, t, o) {
    let g, r;
    try {
      const C = BA(A, Y.__wbindgen_malloc, Y.__wbindgen_realloc), c = X, Q = BA(e, Y.__wbindgen_malloc, Y.__wbindgen_realloc), d = X;
      var n = Ae(o) ? 0 : BA(o, Y.__wbindgen_malloc, Y.__wbindgen_realloc), s = X;
      const f = Y.sessionlog_addNewTrustingTransaction(this.__wbg_ptr, C, c, Q, d, t, n, s);
      var a = f[0], I = f[1];
      if (f[3])
        throw a = 0, I = 0, pA(f[2]);
      return g = a, r = I, HA(a, I);
    } finally {
      Y.__wbindgen_free(g, r, 1);
    }
  }
  /**
   * Add an existing private transaction to the staging area.
   * The transaction is NOT committed until commitTransactions() succeeds.
   * Note: made_at uses f64 because JavaScript's number type is f64.
   * @param {string} encrypted_changes
   * @param {string} key_used
   * @param {number} made_at
   * @param {string | null} [meta]
   */
  addExistingPrivateTransaction(A, e, t, o) {
    const g = BA(A, Y.__wbindgen_malloc, Y.__wbindgen_realloc), r = X, n = BA(e, Y.__wbindgen_malloc, Y.__wbindgen_realloc), s = X;
    var a = Ae(o) ? 0 : BA(o, Y.__wbindgen_malloc, Y.__wbindgen_realloc), I = X;
    const C = Y.sessionlog_addExistingPrivateTransaction(this.__wbg_ptr, g, r, n, s, t, a, I);
    if (C[1])
      throw pA(C[0]);
  }
  /**
   * Add an existing trusting transaction to the staging area.
   * The transaction is NOT committed until commitTransactions() succeeds.
   * Note: made_at uses f64 because JavaScript's number type is f64.
   * @param {string} changes
   * @param {number} made_at
   * @param {string | null} [meta]
   */
  addExistingTrustingTransaction(A, e, t) {
    const o = BA(A, Y.__wbindgen_malloc, Y.__wbindgen_realloc), g = X;
    var r = Ae(t) ? 0 : BA(t, Y.__wbindgen_malloc, Y.__wbindgen_realloc), n = X;
    const s = Y.sessionlog_addExistingTrustingTransaction(this.__wbg_ptr, o, g, e, r, n);
    if (s[1])
      throw pA(s[0]);
  }
  /**
   * @param {number} tx_index
   * @param {string} encryption_key
   * @returns {string | undefined}
   */
  decryptNextTransactionMetaJson(A, e) {
    const t = BA(e, Y.__wbindgen_malloc, Y.__wbindgen_realloc), o = X, g = Y.sessionlog_decryptNextTransactionMetaJson(this.__wbg_ptr, A, t, o);
    if (g[3])
      throw pA(g[2]);
    let r;
    return g[0] !== 0 && (r = HA(g[0], g[1]).slice(), Y.__wbindgen_free(g[0], g[1] * 1, 1)), r;
  }
  /**
   * @param {number} tx_index
   * @param {string} encryption_key
   * @returns {string}
   */
  decryptNextTransactionChangesJson(A, e) {
    let t, o;
    try {
      const n = BA(e, Y.__wbindgen_malloc, Y.__wbindgen_realloc), s = X, a = Y.sessionlog_decryptNextTransactionChangesJson(this.__wbg_ptr, A, n, s);
      var g = a[0], r = a[1];
      if (a[3])
        throw g = 0, r = 0, pA(a[2]);
      return t = g, o = r, HA(g, r);
    } finally {
      Y.__wbindgen_free(t, o, 1);
    }
  }
  /**
   * @param {string} co_id
   * @param {string} session_id
   * @param {string | null} [signer_id]
   */
  constructor(A, e, t) {
    const o = BA(A, Y.__wbindgen_malloc, Y.__wbindgen_realloc), g = X, r = BA(e, Y.__wbindgen_malloc, Y.__wbindgen_realloc), n = X;
    var s = Ae(t) ? 0 : BA(t, Y.__wbindgen_malloc, Y.__wbindgen_realloc), a = X;
    const I = Y.sessionlog_new(o, g, r, n, s, a);
    return this.__wbg_ptr = I >>> 0, ko.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * @returns {SessionLog}
   */
  clone() {
    const A = Y.sessionlog_clone(this.__wbg_ptr);
    return zi.__wrap(A);
  }
}
async function oB(i, A) {
  if (typeof Response == "function" && i instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming == "function")
      try {
        return await WebAssembly.instantiateStreaming(i, A);
      } catch (t) {
        if (i.headers.get("Content-Type") != "application/wasm")
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", t);
        else
          throw t;
      }
    const e = await i.arrayBuffer();
    return await WebAssembly.instantiate(e, A);
  } else {
    const e = await WebAssembly.instantiate(i, A);
    return e instanceof WebAssembly.Instance ? { instance: e, module: i } : e;
  }
}
function _s() {
  const i = {};
  return i.wbg = {}, i.wbg.__wbg_String_8f0eb39a4a4c2f66 = function(A, e) {
    const t = String(e), o = BA(t, Y.__wbindgen_malloc, Y.__wbindgen_realloc), g = X;
    qt().setInt32(A + 4, g, !0), qt().setInt32(A + 0, o, !0);
  }, i.wbg.__wbg_buffer_609cc3eee51ed158 = function(A) {
    return A.buffer;
  }, i.wbg.__wbg_call_672a4d21634d4a24 = function() {
    return ot(function(A, e) {
      return A.call(e);
    }, arguments);
  }, i.wbg.__wbg_call_7cccdd69e0791ae2 = function() {
    return ot(function(A, e, t) {
      return A.call(e, t);
    }, arguments);
  }, i.wbg.__wbg_crypto_574e78ad8b13b65f = function(A) {
    return A.crypto;
  }, i.wbg.__wbg_getRandomValues_b8f5dbd5f3995a9e = function() {
    return ot(function(A, e) {
      A.getRandomValues(e);
    }, arguments);
  }, i.wbg.__wbg_msCrypto_a61aeb35a24c1329 = function(A) {
    return A.msCrypto;
  }, i.wbg.__wbg_new_a12002a7f91c75be = function(A) {
    return new Uint8Array(A);
  }, i.wbg.__wbg_newnoargs_105ed471475aaf50 = function(A, e) {
    return new Function(HA(A, e));
  }, i.wbg.__wbg_newwithbyteoffsetandlength_d97e637ebe145a9a = function(A, e, t) {
    return new Uint8Array(A, e >>> 0, t >>> 0);
  }, i.wbg.__wbg_newwithlength_a381634e90c276d4 = function(A) {
    return new Uint8Array(A >>> 0);
  }, i.wbg.__wbg_node_905d3e251edff8a2 = function(A) {
    return A.node;
  }, i.wbg.__wbg_process_dc0fbacc7c1c06f7 = function(A) {
    return A.process;
  }, i.wbg.__wbg_randomFillSync_ac0988aba3254290 = function() {
    return ot(function(A, e) {
      A.randomFillSync(e);
    }, arguments);
  }, i.wbg.__wbg_require_60cc747a6bc5215a = function() {
    return ot(function() {
      return module.require;
    }, arguments);
  }, i.wbg.__wbg_set_65595bdd868b3009 = function(A, e, t) {
    A.set(e, t >>> 0);
  }, i.wbg.__wbg_static_accessor_GLOBAL_88a902d13a557d07 = function() {
    const A = typeof globalThis > "u" ? null : globalThis;
    return Ae(A) ? 0 : Qt(A);
  }, i.wbg.__wbg_static_accessor_GLOBAL_THIS_56578be7e9f832b0 = function() {
    const A = typeof globalThis > "u" ? null : globalThis;
    return Ae(A) ? 0 : Qt(A);
  }, i.wbg.__wbg_static_accessor_SELF_37c5d418e4bf5819 = function() {
    const A = typeof self > "u" ? null : self;
    return Ae(A) ? 0 : Qt(A);
  }, i.wbg.__wbg_static_accessor_WINDOW_5de37043a91a9c40 = function() {
    const A = typeof window > "u" ? null : window;
    return Ae(A) ? 0 : Qt(A);
  }, i.wbg.__wbg_subarray_aa9065fa9dc5df96 = function(A, e, t) {
    return A.subarray(e >>> 0, t >>> 0);
  }, i.wbg.__wbg_versions_c01dfd4722a88165 = function(A) {
    return A.versions;
  }, i.wbg.__wbindgen_debug_string = function(A, e) {
    const t = Ag(e), o = BA(t, Y.__wbindgen_malloc, Y.__wbindgen_realloc), g = X;
    qt().setInt32(A + 4, g, !0), qt().setInt32(A + 0, o, !0);
  }, i.wbg.__wbindgen_error_new = function(A, e) {
    return new Error(HA(A, e));
  }, i.wbg.__wbindgen_init_externref_table = function() {
    const A = Y.__wbindgen_export_4, e = A.grow(4);
    A.set(0, void 0), A.set(e + 0, void 0), A.set(e + 1, null), A.set(e + 2, !0), A.set(e + 3, !1);
  }, i.wbg.__wbindgen_is_function = function(A) {
    return typeof A == "function";
  }, i.wbg.__wbindgen_is_object = function(A) {
    const e = A;
    return typeof e == "object" && e !== null;
  }, i.wbg.__wbindgen_is_string = function(A) {
    return typeof A == "string";
  }, i.wbg.__wbindgen_is_undefined = function(A) {
    return A === void 0;
  }, i.wbg.__wbindgen_memory = function() {
    return Y.memory;
  }, i.wbg.__wbindgen_string_new = function(A, e) {
    return HA(A, e);
  }, i.wbg.__wbindgen_throw = function(A, e) {
    throw new Error(HA(A, e));
  }, i;
}
function Xs(i, A) {
  return Y = i.exports, Aa.__wbindgen_wasm_module = A, de = null, Bt = null, Y.__wbindgen_start(), Y;
}
function gB(i) {
  if (Y !== void 0) return Y;
  typeof i < "u" && (Object.getPrototypeOf(i) === Object.prototype ? { module: i } = i : console.warn("using deprecated parameters for `initSync()`; pass a single object instead"));
  const A = _s();
  i instanceof WebAssembly.Module || (i = new WebAssembly.Module(i));
  const e = new WebAssembly.Instance(i, A);
  return Xs(e, i);
}
async function Aa(i) {
  if (Y !== void 0) return Y;
  if (typeof i < "u" && (Object.getPrototypeOf(i) === Object.prototype ? { module_or_path: i } = i : console.warn("using deprecated parameters for the initialization function; pass a single object instead")), typeof i > "u")
    throw new Error();
  const A = _s();
  (typeof i == "string" || typeof Request == "function" && i instanceof Request || typeof URL == "function" && i instanceof URL) && (i = fetch(i));
  const { instance: e, module: t } = await oB(await i, A);
  return Xs(e, t);
}
const ea = "data:application/wasm;base64,AGFzbQEAAAAB4wM9YAJ/fwF/YAN/f38Bf2ACf38AYAN/f38AYAF/AGAABH9/f39gAX8Bf2AFf39/f38AYAACf39gAAF/YAR/f39/AGACf38Ef39/f2ABbwFvYAAAYAV/f39+fwBgB39/f39/f38AYAV/f39/fwF/YAR/f39/AX9gBH9/f38Ef39/f2ABbwF/YAZ/f39/f38Bf2AAA39/f2ACf38Bb2AGf39/f39/AGACf28AYAABb2ACb28AYANvf38Bb2ACf34AYAh/f39/f39/fwR/f39/YAZ/f39/f38Ef39/f2AGf39/f39/A39/f2AEf39/fwJ/f2ACf38Cf39gA29vfwBgAX8Bb2ACb28Bb2ADb29vAW9gBn9/f39+fwBgCH9/f39/f35/AGACfH8Bf2AHf39/fn9/fwF/YAR/f39+AGAJf39/f39/fn5+AGACfn8AYAd/f39/f39/AX9gC39/f39/f39/f39/AX9gA39+fgBgAAF+YAR/fn5/AGAMf39/f39/f39/fH9/BH9/f39gCH9/f39/fH9/BH9/f39gCH9/f39/fH9/An9/YAZ/f398f38Cf39gAX8Cf39gBX9/fH9/AGAEf3x/fwBgBX9/fn9/AGAEf35/fwBgBX9/fX9/AGAEf31/fwACogkgA3diZxVfX3diaW5kZ2VuX3N0cmluZ19uZXcAFgN3YmcUX193YmluZGdlbl9lcnJvcl9uZXcAFgN3YmcUX193YmluZGdlbl9pc19vYmplY3QAEwN3YmcdX193YmdfU3RyaW5nXzhmMGViMzlhNGE0YzJmNjYAGAN3YmcdX193YmdfY3J5cHRvXzU3NGU3OGFkOGIxM2I2NWYADAN3YmceX193YmdfcHJvY2Vzc19kYzBmYmFjYzdjMWMwNmY3AAwDd2JnH19fd2JnX3ZlcnNpb25zX2MwMWRmZDQ3MjJhODgxNjUADAN3YmcbX193Ymdfbm9kZV85MDVkM2UyNTFlZGZmOGEyAAwDd2JnFF9fd2JpbmRnZW5faXNfc3RyaW5nABMDd2JnHl9fd2JnX3JlcXVpcmVfNjBjYzc0N2E2YmM1MjE1YQAZA3diZxZfX3diaW5kZ2VuX2lzX2Z1bmN0aW9uABMDd2JnH19fd2JnX21zQ3J5cHRvX2E2MWFlYjM1YTI0YzEzMjkADAN3YmclX193YmdfcmFuZG9tRmlsbFN5bmNfYWMwOTg4YWJhMzI1NDI5MAAaA3diZyZfX3diZ19nZXRSYW5kb21WYWx1ZXNfYjhmNWRiZDVmMzk5NWE5ZQAaA3diZyBfX3diZ19uZXdub2FyZ3NfMTA1ZWQ0NzE0NzVhYWY1MAAWA3diZxpfX3diZ19uZXdfYTEyMDAyYTdmOTFjNzViZQAMA3diZx1fX3diZ19idWZmZXJfNjA5Y2MzZWVlNTFlZDE1OAAMA3diZzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9kOTdlNjM3ZWJlMTQ1YTlhABsDd2JnGl9fd2JnX3NldF82NTU5NWJkZDg2OGIzMDA5ACIDd2JnJF9fd2JnX25ld3dpdGhsZW5ndGhfYTM4MTYzNGU5MGMyNzZkNAAjA3diZx9fX3diZ19zdWJhcnJheV9hYTkwNjVmYTlkYzVkZjk2ABsDd2JnMl9fd2JnX3N0YXRpY19hY2Nlc3Nvcl9HTE9CQUxfVEhJU181NjU3OGJlN2U5ZjgzMmIwAAkDd2JnF19fd2JpbmRnZW5faXNfdW5kZWZpbmVkABMDd2JnG19fd2JnX2NhbGxfNjcyYTRkMjE2MzRkNGEyNAAkA3diZytfX3diZ19zdGF0aWNfYWNjZXNzb3JfU0VMRl8zN2M1ZDQxOGU0YmY1ODE5AAkDd2JnLV9fd2JnX3N0YXRpY19hY2Nlc3Nvcl9HTE9CQUxfODhhOTAyZDEzYTU1N2QwNwAJA3diZy1fX3diZ19zdGF0aWNfYWNjZXNzb3JfV0lORE9XXzVkZTM3MDQzYTkxYTljNDAACQN3YmcbX193YmdfY2FsbF83Y2NjZGQ2OWUwNzkxYWUyACUDd2JnEV9fd2JpbmRnZW5fbWVtb3J5ABkDd2JnEF9fd2JpbmRnZW5fdGhyb3cAAgN3YmcXX193YmluZGdlbl9kZWJ1Z19zdHJpbmcAGAN3YmcfX193YmluZGdlbl9pbml0X2V4dGVybnJlZl90YWJsZQANA4kDhwMDJg4GJwAKAigDAgMCAAYDAgMHAgICAykDAgIDAgMDDwMAARwEAgYDKgMDFAMEDgMCDwMBAQICAwIAAxwCAAoBAQIDAAAPAQoDFAMKAwMDAgoDDw8CAgMHDgIDBAIrAQIsBwAELQQCCQMDAxcAAgMJAgQDAAACAgAEAAMABwIBEBEOAAAGAAIEBAQEAAYAAAkQAAYAAgAADQ0UAAABEQACBAMEBAcCFwcuBwQGAwcXAgADAwQABAABAAMABAIEAAoBAC8EAwIHAAAOAgMAAAICAgQDBAAAMDEDBAACAAAABAIBAQECBgEAAAADAwMyAAAAAAEAAgQCAgoDBAQAMx0dAAACEB4eBgoAAAQ0EhISHxIfEjULCwsLCwsLCwAJAgIgIAEhIRE2FAgIBxA3OTsECgAAAQAEAAICAgICAAQEBAQEAAAGAAAGAwEABwARAAACAAIEAAACAAAGAwQEAAAAAAAAAAAAAAAAAAAAAAAAAg0NAgAAAAACAAACAQAAAAAAAgQNBgkDBAsCcAG1AbUBbwCAAQUDAQASBgkBfwFBgIDAAAsH+AgxBm1lbW9yeQIAFV9fd2JnX3Nlc3Npb25sb2dfZnJlZQBYKHNlc3Npb25sb2dfYWRkRXhpc3RpbmdQcml2YXRlVHJhbnNhY3Rpb24AqwIpc2Vzc2lvbmxvZ19hZGRFeGlzdGluZ1RydXN0aW5nVHJhbnNhY3Rpb24AswIjc2Vzc2lvbmxvZ19hZGROZXdQcml2YXRlVHJhbnNhY3Rpb24AjQIkc2Vzc2lvbmxvZ19hZGROZXdUcnVzdGluZ1RyYW5zYWN0aW9uAJ0CEHNlc3Npb25sb2dfY2xvbmUArAEdc2Vzc2lvbmxvZ19jb21taXRUcmFuc2FjdGlvbnMAwAIsc2Vzc2lvbmxvZ19kZWNyeXB0TmV4dFRyYW5zYWN0aW9uQ2hhbmdlc0pzb24ArQIpc2Vzc2lvbmxvZ19kZWNyeXB0TmV4dFRyYW5zYWN0aW9uTWV0YUpzb24ArAIOc2Vzc2lvbmxvZ19uZXcAuQELZWQyNTUxOVNpZ24ArgIZZWQyNTUxOVNpZ25hdHVyZUZyb21CeXRlcwC2AhplZDI1NTE5U2lnbmluZ0tleUZyb21CeXRlcwC1AhllZDI1NTE5U2lnbmluZ0tleVRvUHVibGljALQCDWVkMjU1MTlWZXJpZnkArwITZWQyNTUxOVZlcmlmeWluZ0tleQC3AhxlZDI1NTE5VmVyaWZ5aW5nS2V5RnJvbUJ5dGVzALgCFG5ld0VkMjU1MTlTaWduaW5nS2V5AMgCFWVkMjU1MTlTaWduaW5nS2V5U2lnbgCuAgtnZXRTaWduZXJJZAC5AgRzaWduALACBnZlcmlmeQCxAhdfX3diZ19ibGFrZTNoYXNoZXJfZnJlZQDPAQ5ibGFrZTNIYXNoT25jZQDEAhlibGFrZTNIYXNoT25jZVdpdGhDb250ZXh0AMECEmJsYWtlM2hhc2hlcl9jbG9uZQBGFWJsYWtlM2hhc2hlcl9maW5hbGl6ZQDGAhBibGFrZTNoYXNoZXJfbmV3AIcBE2JsYWtlM2hhc2hlcl91cGRhdGUAzAEPZGVjcnlwdFhzYWxzYTIwAKQCD2VuY3J5cHRYc2Fsc2EyMACkAg1nZW5lcmF0ZU5vbmNlAMMCB2RlY3J5cHQApQIHZW5jcnlwdAClAgRzZWFsAJ8CBnVuc2VhbACeAgtnZXRTZWFsZXJJZAC7AhNuZXdYMjU1MTlQcml2YXRlS2V5AMkCE3gyNTUxOURpZmZpZUhlbGxtYW4AsgIPeDI1NTE5UHVibGljS2V5ALoCEV9fd2JpbmRnZW5fbWFsbG9jALwCEl9fd2JpbmRnZW5fcmVhbGxvYwDFAhRfX3diaW5kZ2VuX2V4bl9zdG9yZQDzAhdfX2V4dGVybnJlZl90YWJsZV9hbGxvYwCPARNfX3diaW5kZ2VuX2V4cG9ydF80AQEZX19leHRlcm5yZWZfdGFibGVfZGVhbGxvYwD/AQ9fX3diaW5kZ2VuX2ZyZWUA6AIQX193YmluZGdlbl9zdGFydAAfCe0CAQBBAQu0Af4C1QKBAqIB/wL9Ao4CqAL9AaACjwLVAoECogGAA6gC7gKFA90BsQGbAtQB+QGMAaEC0AGIAo0D0gKoAqEC1gGfA4QDggODA/UC7AHdAYYDjgPlAuYChwPVAoECogGKA4gDiQObAu4C1QKBAqIBiwPtAYkC1QKQAtUCgQKiAYwDqAKgAu4C7wLsApsBjgPYAdUC1QKRAqADqAL+AZkB7wL6AfoB0wG7AdoBoQPXAvACoQOmA/ECoQLvAvwB6gK2AboBoQPYAvICpgOUAagC8QKpAssCzgHKAs4CzQLKAswCygLQAssCxwLTAt0C3gLfAuACrwHhAu4C1gL0ApcB7AKrAe8C1QKBAqIBlAOTA9UCgQKiAdECkwG+Aa0B8QKTArwB1AKVA/AB7gLvAtUCggKjAZYD9QKXAvYClwPPAt4BpgHFAaED2gLZApkD1QKG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IgkgA3NBGHciAyAmczYAPCAAICUgAiANIBRzQRh3IiYgDmoiCCASc0EZdyINIB4gJGpqIiRqIBUgJHNBEHciAiARaiIVIA1zQRR3IiRqIh4gAnNBGHciAnM2ADggACAnIAEgCyAfaiIfIBhzQRl3IhggIiAjamoiImogBSAic0EQdyIBIAhqIiMgGHNBFHciGGoiESABc0EYdyIBczYANCAAICggISAXIBxzQRl3IgUgDyAgamoiIGogBSAgICZzQRB3IgUgH2oiIHNBFHciF2oiHyAFc0EYdyIFczYAMCAAICsgBSAgaiIgczYALCAAICwgAyAHaiIiczYAKCAAICkgAiAVaiIVczYAJCAAICogASAjaiIcczYAICAAIB4gIHM2AAwgACARICJzNgAIIAAgFSAfczYABCAAIAkgHHM2AAAgACAYIBxzQRl3IANzNgAcIAAgFyAgc0EZdyACczYAGCAAIAogInNBGXcgAXM2ABQgACAVICRzQRl3IAVzNgAQC4kbASB/IAAgACgCGCIdIAEoABAiJCAAKAIIamoiGyABKAAUIhVqIB0gGyACQf8BcXNBEHciAkHy5rvjA2oiHXNBFHciG2oiIiACc0EYdyIJIB1qIhwgG3NBGXciDyAAKAIUIhsgASgACCICIAAoAgRqaiIZIAEoAAwiHWogGSADQiCIp3NBEHciHkH7ouGkBGsiICAbc0EUdyIGaiIKIAEoACgiG2pqIiMgASgALCIZaiAPICMgACgCECIhIAEoAAAiDyAAKAIAamoiCCABKAAEIh9qICEgCCADp3NBEHciIUHnzKfQBmoiCHNBFHciB2oiDiAhc0EYdyINc0EQdyILIAAoAhwiBSABKAAYIiMgACgCDGpqIgwgASgAHCIhaiAFIAwgBEH/AXFzQRB3IgRBxpXA1QVrIgVzQRR3IgxqIhEgBHNBGHciECAFaiIFaiISc0EUdyIUaiITIB1qIAYgICAKIB5zQRh3IiBqIgZzQRl3IgogDiABKAAgIgRqaiIOIAEoACQiHmogCiAcIA4gEHNBEHciHGoiCnNBFHciDmoiECAcc0EYdyIWIApqIgogDnNBGXciHGoiDiAbaiAcIA4gBSAMc0EZdyIFICIgASgAMCIcamoiDCABKAA0IiJqIAwgIHNBEHciICAIIA1qIghqIg0gBXNBFHciBWoi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jOjEACABNgIAC0GQ6MQAQf8fNgIAQdzlxAAgBzYCAEHU5cQAIAQ2AgBB0OXEACABNgIAQezlxABB4OXEADYCAEH05cQAQejlxAA2AgBB6OXEAEHg5cQANgIAQfzlxABB8OXEADYCAEHw5cQAQejlxAA2AgBBhObEAEH45cQANgIAQfjlxABB8OXEADYCAEGM5sQAQYDmxAA2AgBBgObEAEH45cQANgIAQZTmxABBiObEADYCAEGI5sQAQYDmxAA2AgBBnObEAEGQ5sQANgIAQZDmxABBiObEADYCAEGk5sQAQZjmxAA2AgBBmObEAEGQ5sQANgIAQazmxABBoObEADYCAEGg5sQAQZjmxAA2AgBBqObEAEGg5sQANgIAQbTmxABBqObEADYCAEGw5sQAQajmxAA2AgBBvObEAEGw5sQANgIAQbjmxABBsObEADYCAEHE5sQAQbjmxAA2AgBBwObEAEG45sQANgIAQczmxABBwObEADYCAEHI5sQAQcDmxAA2AgBB1ObEAEHI5sQANgIAQdDmxABByObEADYCAEHc5sQAQdDmxAA2AgBB2ObEAEHQ5sQANgIAQeTmxABB2ObEADYCAEHg5sQAQdjmxAA2AgBB7ObEAEHg5sQANgIAQfTmxABB6ObEADYCAEHo5sQAQeDmxAA2AgBB/ObEAEHw5sQANgIAQfDmxABB6ObEADYCAEGE58QAQfjmxAA2AgBB+ObEAEHw5sQANgIAQYznxABBgOfEADYCAEGA58QAQfjmxAA2AgBBlOfEAEGI58QANgIAQYjnxABBgOfEADYCAEGc58QAQZDnxAA2AgBBkOfEAEGI58QANgIAQaTnxABBmOfEADYCAEGY58QAQZDnxAA2AgBBrOfEAEGg58QANgIAQaDnxABBmOfEADYCAEG058QAQajnxAA2AgBBqOfEAEGg58QANgIAQbznxABBsOfEADYCAEGw58QAQajnxAA2AgBBxOfEAEG458QANgIAQbjnxABBsOfEADYCAEHM58QAQcDnxAA2AgBBwOfEAEG458QANgIAQdTnxABByOfEADYCAEHI58QAQcDnxAA2AgBB3OfEAEHQ58QANgIAQdDnxABByOfEADYCAEHk58QAQdjnxAA2AgBB2OfEAEHQ58QANgIAQfznxAAgAUEPakF4cSIAQQhrIgI2AgBB4OfEAEHY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akEJdyAMcyIMIAVqQQ13IA9zIg8gDGpBEncgCHMhCCAQIBQgFWpBEncgB3MiB2pBB3cgCXMiCSAHakEJdyANcyINIAlqQQ13IBBzIhAgDWpBEncgB3MhByATQQFrIhMNAAsgACkCICEpIAAoAgAhEyAAKAIEIRIgACgCCCERIAAoAgwhFCAAKAIQIRUgACgCFCEcIAAoAhghGiAAKAIcIR0gACgCICEeIAAoAiQhHyAAKAIoISAgACgCLCEhIAAoAjAhIiAAKAI0ISMgACgCOCEkIAAgACgCPCABajYCfCAAIBYgJGo2AnggACAOICNqNgJ0IAAgBiAiajYCcCAAIAIgIWo2AmwgACAEICBqNgJoIAAgFyAfajYCZCAAIAsgHmo2AmAgACAMIB1qNgJcIAAgBSAaajYCWCAAIAggHGo2AlQgACAPIBVqNgJQIAAgECAUajYCTCAAIA0gEWo2AkggACAJIBJqNgJEIAAgByATajYCQCAAIClCAXwiKT4CICAAIClCIIg+AiQgCkEBcSECQQAhASAbQQFGDQEgCkE+cSEKA0AgASAZaiIGIAAgAWoiBEFAay0AACABIBhqIgUtAABzOgAAIAZBAWogBEHBAGotAAAgBUEBai0AAHM6AAAgCiABQQJqIgFHDQALDAELAkAgCkUNACABKAIEIQAgASgCACECQQAhASAKQQFHBEAgCkF+cSEGA0AgACABaiIFIAEgCGoiB0FAay0AACABIAJqIg4tAABzOgAAIAVBAWogB0HBAGotAAAgDkEBai0AAHM6AAAgBiABQQJqIgFHDQALCyAKQQFxRQ0AIAAgAWogASAJai0AACABIAJqLQAAczoAAAsgBCAKaiEbDAELIAJFDQAgASAZaiAAQUBrIAFqLQAAIAEgGGotAABzOgAACyAlIBs6AABBAAsgA0HAAWokAAuQMQITfyR+IwBB4AVrIgQkACAEQeAAaiIFQQBB4AD8CwAgBEHYAGoiByABQdgBaikCADcDACAEQdAAaiIGIAFB0AFqKQIANwMAIARBkANqIghBsN/AACkDADcDACAEQZgDaiIJQbjfwAApAwA3AwAgBEGgA2pBwN/AACkDADcDACAEQagDakHI38AAKQMANwMAIARBsANqQdDfwAApAwA3AwAgBEG4A2pB2N/AACkDADcDACAEIAFByAFqKQIANwNIIAQgASkCwAE3A0AgBEGg38AAKQMANwOAAyAEQajfwAApAwA3A4gDIARCADcDyAMgBEIANwPAAyAEQdADaiINIARBQGsiCkGAAfwKAAAgBEGoBWoiDkIANwMAIARBsAVqIg9CADcDACAEQbgFaiILQgA3AwAgBEHABWoiDEIANwMAIARByAVqIhBCADcDACAEQdAFaiIRQgA3AwAgBEHYBWoiEkIANwMAIARBIDoA0AQgBEIANwOgBSAEQYADaiITIA0gBEGgBWoQOCAJIAspAwA3AwAgCCAPKQMANwMAIARBiANqIA4pAwA3AwAgBCAEKQOgBSIXNwOAAyAEIBenQfgBcToAgAMgBCAELQCfA0E/cUHAAHI6AJ8DIAQgExD7ASAEQThqIgggEikDADcAACAEQTBqIgkgESkDADcAACAEQShqIg0gECkDADcAACAEIAwpAwA3ACAgBEH4AGpB6N3AACkDADcDACAEQfAAakHg3cAAKQMANwMAIARB6ABqQdjdwAApAwA3AwAgBUHQ3cAAKQMANwMAIAdByN3AACkDADcDACAGQcDdwAApAwA3AwAgBEIANwOIASAEQgA3A4ABIARBuN3AACkDADcDSCAEQbDdwAApAwA3A0AgBEGwAWoiBUEAQeAA/AsAIARBqAFqIAgpAAA3AwAgBEGgAWogCSkAADcDACAEQZgBaiANKQAANwMAIARBIDoAkAIgBCAEKQAgNwOQASAEQZABaiEHAkAgA0HgAE8EQCAFIAJB4AD8CgAAIARCADcDiAEgBEIBNwOAASAKIAdBARAgIAJB4ABqIQggA0HgAGsiBkH/AHEhBSAGQYABTwRAIAQgBCkDgAEiFyAGQQd2IgmtfCIYNwOAASAEIAQpA4gBIBcgGFatfDcDiAEgCiAIIAkQIAsgBUUNASAHIAggBkGAf3FqIAX8CgAADAELIAMEQCAEQbABaiACIAP8CgAACyADQSBqIQULIAQgBToAkAIgBEGAA2oiBSAEQUBrQeAB/AoAACAEQdgFaiIGQgA3AwAgBEHQBWoiCkIANwMAIARByAVqIghCADcDACAEQcAFaiIJQgA3AwAgBEG4BWoiDUIANwMAIARBsAVqIg5CADcDACAEQagFaiIPQgA3AwAgBEIANwOgBSAFIARB0ANqIARBoAVqEDggBEGYBWogBikDADcD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//8BcTYCbCABIAEoAkwgASgCKCACQR12amoiAkH/////AXE2AnAgASABKAJQIAEoAiwgAkEddmpqIgJB/////wFxNgJ0IAEgASgCVCABKAIwIAJBHXZqaiICQf////8BcTYCeCABIAEoAlggASgCNCACQR12amoiAkH/////AXE2AnwgASABKAJcIAEoAjggAkEddmpqIgJB/////wFxNgKAASABIAEoAmAgASgCPCACQR12amoiAkH/////AXE2AoQBIAEgASgCZCABKAJAIAJBHXZqaiICQf////8BcTYCiAEgASABKAJoIAEoAkQgAkEddmpqQf////8BcTYCjAEgASABQewAakHg4cAAEGggBEGgA2oiAiABEH8gAUGQAWokACAPIARByAJqKQAAIhc3AwAgDiAEQdACaikAACIYNwMAIA0gBEHYAmopAAAiGzcDACAAIAQpAMACIhw3AAEgAEEJaiAXNwAAIABBEWogGDcAACAAQRlqIBs3AAAgAEEhaiACKQMANwAAIABBKWogBEGoA2opAwA3AAAgAEExaiAEQbADaikDADcAACAAQTlqIARBuANqKQMANwAAIAQgHDcDgAMgAEEAOgAAIAQQwgEgBEEAOgAgIARBADoAISAEQQA6ACIgBEEAOgAjIARBADoAJCAEQQA6ACUgBEEAOgAmIARBADoAJyAEQQA6ACggBEEAOgApIARBADoAKiAEQQA6ACsgBEEAOgAsIARBADoALSAEQQA6AC4gBEEAOgAvIARBADoAMCAEQQA6ADEgBEEAOgAyIARBADoAMyAEQQA6ADQgBEEAOgA1IARBADoANiAEQQA6ADcgBEEAOgA4IARBADoAOSAEQQA6ADogBEEAOgA7IARBADoAPCAEQQA6AD0gBEEAOgA+IARBADoAPyAEQeAFaiQAC/QZAhl/BH4jAEGwB2siAiQAIwBBIGsiBCQAIAIgAS0AACIDQQR2OgABIAIgA0EPcSIGOgAAIAIgAS0AASIDQQR2OgADIAIgA0EPcToAAiACIAEtAAIiA0EEdjoABSACIANBD3E6AAQgAiABLQADIgNBBHY6AAcgAiADQQ9xOgAGIAIgAS0ABCIDQQR2OgAJIAIgA0EPcToACCACIAEtAAUiA0EEdjoACyACIANBD3E6AAogAiABLQAGIgNBBHY6AA0gAiADQQ9xOgAMIAIgAS0AByIDQQR2OgAPIAIgA0EPcToADiACIAEtAAgiA0EEdjoAESACIANBD3E6ABAgAiABLQAJIgNBBHY6ABMgAiADQQ9xOgASIAIgAS0ACiIDQQR2OgAVIAIgA0EPcToAFCACIAEtAAsiA0EEdjoAFyACIANBD3E6ABYgAiABLQAMIgNBBHY6ABkgAiADQQ9xOgAYIAIgAS0ADSIDQQR2OgAbIAIgA0EPcToAGiACIAEtAA4iA0EEdjoAHSACIANBD3E6ABwgAiABLQAPIgNBBHY6AB8gAiADQQ9xOgAeIAIgAS0AECIDQQR2OgAhIAIgA0EPcToAICACIAEtABEiA0EPcToAIiACIANBBHY6ACMgAiABLQASIgNBBHY6ACUgAiADQQ9xOgAkIAIgAS0AEyIDQQR2OgAnIAIgA0EPcToAJiACIAEtABQiA0EEdjoAKSACIANBD3E6ACggAiABLQAVIgNBBHY6ACsgAiADQQ9xOgAqIAIgAS0AFiIDQQR2OgAtIAIgA0EPcToALCACIAEtABciA0EEdjoALyACIANBD3E6AC4gAiABLQAYIgNBBHY6ADEgAiADQQ9xOgAwIAIgAS0AGSIDQQR2OgAzIAIgA0EPcToAMiACIAEtABoiA0EEdjoANSACIANBD3E6ADQgAiABLQAbIgNBBHY6ADcgAiADQQ9xOgA2IAIgAS0AHCIDQQR2OgA5IAIgA0EPcToAOCACIAEtAB0iA0EEdjoAOyACIANBD3E6ADogAiABLQAeIgNBBHY6AD0gAiADQQ9xOgA8IAIgAS0AHyIBQQR2OgA/IAIgAUEPcToAPgNAIAIgBWoiCCAGIAZBCGoiAUHwAXFrOgAAIAhBAWoiAyADLQAAIAHAQQR1aiIBOgAAIAVBPkcEQCADIAEgAUEIaiIDQfABcWs6AAAgCEECaiIBIAEtAAAgA8BBBHVqIgY6AAAgBUECaiEFDAELCyAEQSBqJAAgAkHgAGpCADcDACACQdgAakIANwMAIAJB0ABqQgA3AwAgAkHIAGpCADcDAEEAIQEgAkHwAGpBoOPAACkCACIcNwMAIAJB+ABqQajjwAApAgAiHTcDACACQYABakGw48AAKQIAIh43AwAgAkGIAWpBuOPAACkCACIbNwMAIAJBmAFqIBw3AwAgAkGgAWogHTcDACACQagBaiAeNwMAIAJBsAFqIBs3AwAgAkIANwNAIAJBmOPAACkCACIbNwNoIAIgGzcDkAEgAkHYAWpCADcDACACQdABakIANwMAIAJByAFqQgA3AwAgAkHAAWpCADcDACACQgA3A7gBIAJB+ANqIQwgAkHQA2ohDSACQagDaiEOIAJB6AVqIQsgAkHABWohBSACQZAGaiEGIAJBkAFqIQ8gAkHoAGohEANAAkACQCABQcAARwRAIAFBAXENAQwCCyACQegEaiAQQSBqKQIANwMAIAJB4ARqIBBBGGopAgA3AwAgAkHYBGogEEEQaikCADcDACACQdAEaiAQQQhqKQIANwMAIAJB+ARqIA9BCGopAgA3AwAgAkGABWogD0EQaikCADcDACACQYgFaiAPQRhqKQIANwMAIAJBkAVqIA9BIGopAgA3AwAgAiAQKQIANwPIBCACIA8pAgA3A/AEIAJBwARqIAJB4ABqKQMANwMAIAJBuARqIAJB2ABqKQMANwMAIAJBsARqIAJB0ABqKQMANwMAIAJBqARqIAJByABqKQMANwMAIAIgAikDQDcDoAQgAkGYBWoiAyACQaAEahAsQQAiAUUEQCACQYADaiADQaAB/AoAAAsgAkGYBWoiByACQYADaiITIAJB+ANqIgkQNiACQYgHaiIVIAJBqANqIhEgAkHQA2oiChA2IAJB4AFqIhQgCiAJEDYgAkHgBWoiGiACQagHaiIWKQIANwIAIAJB2AVqIgwgAkGgB2oiFykCADcCACACQdAFaiINIAJBmAdqIhgpAgA3AgAgAkHIBWoiDiACQZAHaiIZKQIANwIAIAJB8AVqIg8gAkHoAWoiECkCADcCACACQfgFaiILIAJB8AFqIgUpAgA3AgAgAkGABmoiBiACQfgBaiIIKQIANwIAIAJBiAZqIgQgAkGAAmoiAykCADcCACACIAIpAogHNwLABSACIAIpAuABNwLoBSACQaAEaiISIAdB+AD8CgAAIAcgEhAsIBMgB0GgAfwKAAAgByATIAkQNiAVIBEgChA2IBQgCiAJEDYgGiAWKQIANwIAIAwgFykCADcCACANIBgpAgA3AgAgDiAZKQIANwIAIA8gECkCADcCACALIAUpAgA3AgAgBiAIKQIANwIAIAQgAykCADcCACACIAIpAogHNwLABSACIAIpAuABNwLoBSASIAdB+AD8CgAAIAcgEhAsIBMgB0GgAfwKAAAgByATIAkQNiAVIBEgChA2IBQgCiAJEDYgGiAWKQIANwIAIAwgFykCADcCACANIBgpAgA3AgAgDiAZKQIANwIAIA8gECkCADcCACALIAUpAgA3AgAgBiAIKQIANwIAIAQgAykCADcCACACIAIpAogHNwLABSACIAIpAuABNwLoBSASIAdB+AD8CgAAIAcgEhAsIBQgByACQZAGaiILEDYgAkG4BmogAkHABWoiBSACQegFaiIGEDYgAkHgBmogBiALEDYgFSAHIAUQNiACQagCaiACQdgGaikCADcCACACQaACaiACQdAGaikCADcCACACQZgCaiACQcgGaikCADcCACACQZACaiACQcAGaikCADcCACACQbgCaiACQegGaikCADcCACACQcACaiACQfAGaikCADcCACACQcgCaiACQfgGaikCADcCACACQdACaiACQYAHaikCADcCACACIAIpArgGNwKIAiACIAIpAuAGNwKwAiACQfgCaiAWKQIANwIAIAJB8AJqIBcpAgA3AgAgAkHoAmogGCkCADcCACACQeACaiAZKQIANwIAIAIgAikCiAc3AtgCIAJBQGsgFEGgAfwKAAADQAJAAkAgAUHAAEcEQCABQQFxRQ0BDAILIAAgAkFAa0GgAfwKAAAgAkGwB2okAA8LIAFBAXYhBCABQcAASQRAIAJB4AFqIgMgBEHAB2xBuKHBAGogASACai0AABBiIAJBmAVqIgggAkFAayIEIAMQQCACQYADaiIDIAggCxA2IAJB4AZqIAUgBhA2IAJBiAdqIAYgCxA2IAJBoARqIAggBRA2IBFBIGogAkGAB2opAgA3AgAgEUEYaiACQfgGaikCADcCACARQRBqIAJB8AZqKQIANwIAIBFBCGogAkHoBmopAgA3AgAgESACKQLgBjcCACAKIAIpAogHNwIAIApBCGogAkGQB2opAgA3AgAgCkEQaiACQZgHaikCADcCACAKQRhqIAJBoAdqKQIANwIAIApBIGogAkGoB2opAgA3AgAgCUEgaiACQcAEaikCADcCACAJQRhqIAJBuARqKQIANwIAIAlBEGogAkGwBGopAgA3AgAgCUEIaiACQagEaikCADcCACAJIAIpAqAENwIAIAQgA0GgAfwKAAAgAUEBaiEBDAILIARBIEHA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ASASQgA3AwAgE0IANwMAIBRCADcDACAVQgA3AwAgF0IANwMAIBhCADcDACAZQgA3AwAgDiAAQQhqKQMANwMAIBAgAEEQaikDADcDACARIABBGGopAwA3AwAgA0IANwOAASADIAApAwA3A8ABIAApA4ABIRsgBSAaQeAA/AoAACAAQQA7AYgBIAAgG0IBfDcDgAEgASAKaiEBCyACQYEITwRAIABBnAFqIQ8gACkDgAEhGyADQdAAaiEMIANBwAFqIQkgA0GgAWohCgNAIBtCCoYhHEF/IAJBAXZndkEBaiEEA0AgBCIFQQF2IQQgHCAFQQFrrYNCAFINAAsgBUEKdq0hHAJAAkAgBUGBCE8EQCACIAVPDQFBACAFIAJB7NrAABCYAgALIANBiAFqQgA3AwAgA0GQAWpCADcDACADQZgBakIANwMAIApCADcDACADQagBakIANwMAIANBsAFqQgA3AwAgA0G4AWpCADcDACAJIAApAwA3AwAgCUEIaiIHIABBCGopAwA3AwAgCUEQaiIGIABBEGopAwA3AwAgCUEYaiIIIABBGGopAwA3AwAgA0IANwOAASADQQA7AegBIAMgGzcD4AEgAyAALQCKAToA6gEgA0GAAWogASAFEH4hBCAMIAkpAwA3AwAgDEEIaiAHKQMANwMAIAxBEGogBikDADcDACAMQRhqIAgpAwA3AwAgA0EYaiAEQQhqKQMANwMAIANBIGogBEEQaikDADcDACADQShqIARBGGopAwA3AwAgA0EwaiAEQSBqKQMANwMAIANBOGogBEEoaikDADcDACADQUBrIARBMGopAwA3AwAgA0HIAGogBEE4aikDADcDACADIAQpAwA3AxAgAy0A6gEhBCADLQDpASELIAMgAy0A6AEiDToAeCADIAMpA+ABIhs3A3AgAyAEIAtFckECciIEOgB5IANBiAJqIgsgCCkCADcDACADQYACaiIIIAYpAgA3AwAgA0H4AWoiDiAHKQIANwMAIAMgCSkCADcD8AEgA0HwAWogA0EQaiANIBsgBBAiIAsoAgAhByAIKAIAIQYgDigCACEIIAMoAowCIQsgAygChAIhDSADKAL8ASEOIAMoAvQBIRAgAygC8AEhESAAIAApA4ABEEMgACgCmAEiBEE3Tw0HIAAgBEEBajYCmAEgDyAEQQV0aiIEIAs2Ahwg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KAKYAygCmAMoApgDKAKYAygCmAMoApgDKAKYAygCmAMhBSAEQQhrIgQNAAsLIAUhBEEAIQULAkAgBC8BkgMgCUsEQCAEIQEMAQsDQCAEKAKIAiIBRQ0NIAVBAWohBSAELwGQAyEJIAkgASIELwGSA08NAAsLIAlBAWohBwJAIAVFBEAgASEEDAELIAEgB0ECdGpBmANqIQICQCAFQQdxIgdFBEAgBSEGDAELIAUhBgNAIAZBAWshBiACKAIAIgRBmANqIQIgB0EBayIHDQALC0EAIQcgBUEISQ0AA0AgAigCACgCmAMoApgDKAKYAygCmAMoApgDKAKYAygCmAMiBEGYA2ohAiAGQQhrIgYNAAsLAn8gASAJQQxsakGMAmohBiABIAlBGGxqIQUjAEEQayILJAAgA0HID2oiCS0AAEEBRwRAIAYoAgghAiAGKAIEIQEgCSgCBCENIAktAAFBAUcEQCANKAIAIgwoAgAgDCgCCCIGRgRAIAwgBkEBQQFBARDJASAMKAIIIQYLIAwgBkEBajYCCCAMKAIEIAZqQSw6AAALIAlBAjoAASALIA0gASACEGcCfyALLQAAQQRHBEAgCyALKQMANwMIIAtBCGoQpgIMAQsgDSgCACICKAIAIAIoAggiAUYEQCACIAFBAUEBQQEQyQEgAigCCCEBCyACIAFBAWo2AgggAigCBCABakE6OgAAIAUgDRAtCyALQRBqJAAMAQtB3dTAAEEoQYjVwAAQmQIACyIFDQNBACEFIA5BAWsiDg0ACyADKALIDyIBQQFxDQkgAUGA/gNxRQ0BIAMoAswPBSABCygCACIBKAIAIAEoAggiBUYEQCABIAVBAUEBQQEQyQEgASgCCCEFCyABIAVBAWo2AgggASgCBCAFakH9ADoAAAsgAygCNCEFIAMoAjAiD0GAgICAeEYNASADKAI4IQQgA0GAEGpCADcDACADQfgPakIANwMAIANB8A9qQgA3AwAgA0HoD2pCADcDACADQeAPakIANwMAIANB2A9qQgA3AwAgA0HQD2pCADcDACADQZAQakHotsAAKQIAIhM3AwAgA0GYEGpB8LbAACkCACISNwMAIANBoBBqQfi2wAApAgAiETcDACADQThqIBM3AwAgA0FAayASNwMAIANByABqIBE3AwAgA0IANwPIDyADQeC2wAApAgAiETcDiBAgAyARNwMwIANB0ABqIANByA9qIgJB4AD8CgAAIANBtwFqQQA2AAAgA0EANgLIASADQgA3A8ABIANCADcDsAEgA0EwaiIBIAUgBBApIANBwA9qIgtCADcDACADQbgPaiIMQgA3AwAgA0IANwOwDyMAQSBrIgQkAAJAIAEpA5ABUARAIAIgARAwIAJBADoAcCAEQSBqJAAMAQsgBEIANwIUIARCgYCAgMAANwIMIARBzNnAADYCCCABQZABakGI18AAIARBCGpB1NnAABCnAgALIANBsA9qIQFBGCEKIwBBQGoiCCQAAkACQCACIgQtAHAiAgR/IAggBEFAayAEIAQtAGggBCkDYCIRIAQtAGlBCHIQISACQcAASw0BQRhBwAAgAmsiBiAGQRhPGyIGBEAgASACIAhqIAb8CgAACyAEIAIgBmoiAjoAcCABIAZqIQFBGCAGayEKIAJB/wFxQcAARgR/IARBADoAcCAEIBFCAXw3A2BBAAUgAgsFQQALIQ0gCkE/SwRAIARBQGshDkEAIApBQHEiCWshECAELQBpQQhyIQcgBC0AaCEGIAQpA2AiESESIAEhAgNAIAggDiAEIAYgEiAHECEgAkE4aiAIQThqKQAANwAAIAJBMGogCEEwaikAADcAACACQShqIAhBKGopAAA3AAAgAkEgaiAIQSBqKQAANwAAIAJBGGogCEEYaikAADcAACACQRBqIAhBEGopAAA3AAAgAkEIaiAIQQhqKQAANwAAIAIgCCkAADcAACASQgF8IRIgAkFAayECIBBBQGsiEA0ACyAEIBEgCkEGdq18NwNgIApBP3EhCiABIAlqIQELAkAgCkUNACAIIARBQGsgBCAELQBoIAQpA2AgBC0AaUEIchAhIA1B/wFxIgJBwABNBEBBwAAgAmsiBiAKIAYgCkkbIgYEQCABIAIgCGogBvwKAAALIAQgBC0AcCAGaiIBOgBwIAFB/wFxQcAARw0BIARBADoAcCAEIAQpA2BCAXw3A2AMAQsMAQsgCEFAayQADAELIAJBwABBwABBpNfAABCYAgALIABBEGogCykDADcAACAAQQhqIAwpAwA3AAAgACADKQOwDzcAACAPBEAgBSAPQQEQ+gILIANBBHIQRCADQcAQaiQADwsgAygCMCIARQ0AIAMoAjQgAEEBEPoCCyADIAU2AjBBkLfAAEErIANBMGpBgLfAAEG8t8AAEOYBAAtBAUECENsCAAtBAUEJENsCAAtBAUEHENsCAAtBAUECENsCAAtBAUGAARDbAgALQfC4wABBKEGYucAAEJkCAAtB/LfAABD8AgALow8CKH8IfiMAQfACayICJAAgAkGgAmoiAyABEFAgAiACKQPoAiACKQPgAiACKQPYAiACKQPQAiACKQPIAiACKQPAAiIqQhqIfCIsQhmIfCIrQhqIfCIvQhmIfCIwQhqIfCItQhmIQhN+IAIpA6ACIi5C////H4N8IjGnQf///x9xIgQ2AgggAiACKQOoAiAuQhqIfCIuQv///w+DIDFCGoh8pyIINgIMIAIgLEL///8PgyAqQv///x+DIAIpA7gCIAIpA7ACIC5CGYh8IipCGoh8IixCGYh8Ii5CGoh8pyIJNgIcIAIgLqdB////H3EiBTYCGCACICynQf///w9xIgo2AhQgAiAvp0H///8PcSILNgIkIAIgLadB////D3EiDDYCLCACICqnQf///x9xIg02AhAgAiArp0H///8fcSIGNgIgIAIgMKdB////H3EiBzYCKCADIAFBKGoQUCACIAIpA+gCIAIpA+ACIAIpA9gCIAIpA9ACIAIpA8gCIAIpA8ACIipCGoh8IixCGYh8IitCGoh8Ii9CGYh8IjBCGoh8Ii1CGYhCE34gAikDoAIiLkL///8fg3wiMadB////H3EiDjYCMCACIAIpA6gCIC5CGoh8Ii5C////D4MgMUIaiHynIg82AjQgAiAsQv///w+DICpC////H4MgAikDuAIgAikDsAIgLkIZiHwiKkIaiHwiLEIZiHwiLkIaiHynIhA2AkQgAiAup0H///8fcSIRNgJAIAIgLKdB////D3EiEjYCPCACIC+nQf///w9xIhM2AkwgAiAtp0H///8PcSIUNgJUIAIgKqdB////H3EiFTYCOCACICunQf///x9xIhY2AkggAiAwp0H///8fcSIXNgJQIAMgAUHQAGoQUCACIAIpA9ACQgGGIAIpA8gCQgGGIAIpA8ACQgGGIipCGoh8IixCGYh8IiunQf///x9xNgJwIAIgAikDsAJCAYYgAikDqAJCAYYgAikDoAJCAYYiL0IaiHwiMEIZiHwiLadB////H3E2AmAgAiACKQPYAkIBhiArQhqIfCIrp0H///8PcTYCdCACIAIpA7gCQgGGIC1CGoh8Ii2nQf///w9xNgJkIAIgAikD4AJCAYYgK0IZiHwiK6dB////H3E2AnggAiAsQv///w+DICpC/v//H4MgLUIZiHwiKkIaiHw+AmwgAiAqp0H///8fcTYCaCACIAIpA+gCQgGGICtCGoh8IiqnQf///w9xNgJ8IAIgMEL///8PgyAqQhmIQhN+IC9C/v//H4N8IipCGoh8PgJcIAIgKqdB////H3E2AlggASgCKCEYIAEoAgAhGSABKAIsIRogASgCBCEbIAEoAjAhHCABKAIIIR0gASgCNCEeIAEoAgwhHyABKAI4ISAgASgCECEhIAEoAjwhIiABKAIUISMgASgCQCEkIAEoAhghJSABKAJEISYgASgCHCEnIAEoAkghKCABKAIgISkgAiABKAJMIAEoAiRqNgKkASACICggKWo2AqABIAIgJiAnajYCnAEgAiAkICVqNgKYASACICIgI2o2ApQBIAIgICAhajYCkAEgAiAeIB9qNgKMASACIBwgHWo2AogBIAIgGiAbajYChAEgAiAYIBlqNgKAASADIAJBgAFqEFAgAiACKQPQAiACKQPIAiACKQPAAiIqQhqIfCIsQhmIfCIrp0H///8fcTYCwAEgAiACKQOwAiACKQOoAiACKQOgAiIvQhqIfCIwQhmIfCItp0H///8fcTYCsAEgAiACKQPYAiArQhqIfCIrp0H///8PcTYCxAEgAiACKQO4AiAtQhqIfCItp0H///8PcTYCtAEgAiACKQPgAiArQhmIfCIrp0H///8fcTYCyAEgAiAsQv///w+DICpC////H4MgLUIZiHwiKkIaiHw+ArwBIAIgKqdB////H3E2ArgBIAIgAikD6AIgK0IaiHwiKqdB////D3E2AswBIAIgMEL///8PgyAqQhmIQhN+IC9C////H4N8IipCGoh8PgKsASACICqnQf///x9xNgKoASACQfABaiIBIAcgF2o2AgAgAkHoAWoiByAGIBZqNgIAIAJB4AFqIgYgBSARajYCACACQdgBaiIFIA0gFWo2AgAgAiAMIBRqNgL0ASACIAsgE2o2AuwBIAIgCSAQajYC5AEgAiAKIBJqNgLcASACIAggD2o2AtQBIAIgBCAOajYC0AEgAkH4AWoiBCACQTBqIAJBCGoQeiAAIAJBqAFqIAJB0AFqEHogAyACQdgAaiAEEHogAEHIAGogASkCADcCACAAQUBrIAcpAgA3AgAgAEE4aiAGKQIANwIAIABBMGogBSkCADcCACAAIAIpAtABNwIoIAAgAikC+AE3AlAgAEHYAGogAkGAAmopAgA3AgAgAEHgAGogAkGIAmopAgA3AgAgAEHoAGogAkGQAmopAgA3AgAgAEHwAGogAkGYAmopAgA3AgAgAEGYAWogAkHAAmopAgA3AgAgAEGQAWogAkG4AmopAgA3AgAgAEGIAWogAkGwAmopAgA3AgAgAEGAAWogAkGoAmopAgA3AgAgACACKQKgAjcCeCACQfACaiQAC50OAQp/IwBBEGsiCCQAAkACQAJAAkACQAJAAkACQCAALQAAQQFrDgUBAgMEBQALIAEoAgAiACgCACAAKAIIIgJrQQNNBEAgACACQQRBAUEBEMkBIAAoAgghAgsgACACQQRqNgIIIAAoAgQgAmpB7uqx4wY2AAAMBQsgASgCACEBIAAtAAFFBEAgASgCACABKAIIIgBrQQRNBEAgASAAQQVBAUEBEMkBIAEoAgghAAsgASAAQQVqNgIIIAEoAgQgAGoiAEGw0sAAKAAANgAAIABBBGpBtNLAAC0AADoAAAwGCyABKAIAIAEoAggiAGtBA00EQCABIABBBEEBQQEQyQEgASgCCCEACyABIABBBGo2AgggASgCBCAAakH05NWrBjYAAAwECyAAQQhqIAEQPAwDCyAIIAEgACgCCCAAKAIMEGcgCC0AAEEERg0DIAggCCkDADcDCCAIQQhqEKYCIQIMAwsgACgCDCEEIAAoAgghByABKAIAIgAoAgAgACgCCCICRgRAIAAgAkEBQQFBARDJASAAKAIIIQILIAAgAkEBajYCCCAAKAIEIAJqQdsAOgAAAkAgBEUNACAHIAEQLSICDQMgBEEBRg0AIARBGGxBGGshBiAHQRhqIQMDQCAAKAIIIgIgACgCAEYEQCAAIAJBAUEBQQEQyQEgACgCCCECCyAAIAJBAWo2AgggACgCBCACakEsOgAAIAMgARAtIgINBCADQRhqIQMgBkEYayIGDQALCyAAKAIIIgIgACgCAEYEQCAAIAJBAUEBQQEQyQEgACgCCCECCyAAIAJBAWo2AgggACgCBCACakHdADoAAAwBCyAAKAIMIQogASgCACIFKAIAIAUo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CyAGIBN6p0EDdiACaiAKcSICaiwAAEEATgRAIAYpAwBCgIGChIiQoMCAf4N6p0EDdiECCyACIAdrIAUgB2tzIApxQQhPBEAgAiAGaiIHLQAAIAcgEEEZdiIHOgAAIAkgAkEIayAKcWogBzoAACAGIAJBA3RrQQhrIQJB/wFGDQIgAigAACEHIAIgBCgAADYAACAEIAc2AAAgBCgABCEHIAQgAigABDYABCACIAc2AAQMAQsLIA8gEEEZdiICOgAAIAkgBUEIayAKcWogAjoAAAwBCyAPQf8BOgAAIAkgBUEIayAKcWpB/wE6AAAgAiAEKQAANwAACyAIIAggDEkiAmohBCACDQALCyABIA4gDWs2AghBgYCAgHghCQwBCwwBCyAAIA42AgQgACAJNgIAIANBQGskAA8LIANBADYCECADQQE2AgQgA0G4wMAANgIAIANCBDcCCCADQcDAwAAQvwIAC8cMAhJ/BH4jAEHQAWsiAiQAAkAgASgCmAEiBEUEQCAAIAEpA2A3A0AgACABKQMgNwMAIABByABqIAFB6ABqKQMANwMAIABB0ABqIAFB8ABqKQMANwMAIABB2ABqIAFB+ABqKQMANwMAIABBCGogAUEoaikDADcDACAAQRBqIAFBMGopAwA3AwAgAEEYaiABQThqKQMANwMAIABBIGogAUFAaykDADcDACAAQShqIAFByABqKQMANwMAIABBMGogAUHQAGopAwA3AwAgAEE4aiABQdgAaikDADcDACABLQCKASEEIAEtAIkBIQMgACABLQCIAToAaCAAIAEpA4ABNwNgIAAgBCADRXJBAnI6AGkMAQsCQAJAAkACQCABLQCIASIHIAEtAIkBIgZyBEAgAkG4AWogAUHoAGopAwA3AwAgAkHAAWogAUHwAGopAwA3AwAgAkHIAWogAUH4AGopAwA3AwAgAkH4AGogAUEoaikDADcDACACQYABaiABQTBqKQMANwMAIAJBiAFqIAFBOGopAwA3AwAgAkGQAWogAUFAaykDADcDACACQZgBaiABQcgAaikDADcDACACQaABaiABQdAAaikDADcDACACQagBaiABQdgAaikDADcDACACIAEpA2A3A7ABIAIgASkDIDcDcCABLQCKASEDIAEpA4ABIRQgAiACQfAAakHgAPwKAAAgAiADIAZFckECciIFOgBp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IQVBACEJAkAgB0EESQRAQQAhCAwBCyAHQXxxIQpBACEIA0BCASADIAhqIgZBA2oxAACGQgEgBjEAAIYgD4RCASAGQQFqMQAAhoRCASAGQQJqMQAAhoSEIQ8gCiAIQQRqIghHDQALCyAFRQ0AIAMgCGohBgNAQgEgBjEAAIYgD4QhDyAGQQFqIQYgBUEBayIFDQALCyAECyEGIAAgBDYCPCAAIAM2AjggACACNgI0IAAgATYCMCAAIAY2AiggACAJNgIkIAAgAjYCICAAQQA2AhwgACAHNgIYIAAgDDYCFCAAIA02AhAgACAPNwMIIABBATYCAA8LIAUgBEHg0MQAEPIBAAsgBSAEQeDQxAAQ8gEAC0EAIA0gBEGg0cQAEJgCAAsgByAFIARBkNHEABCYAgALIAUgBEHw0MQAEPIBAAsgCyAEQYDRxAAQ8gEACyAFIARB8NDEABDyAQALIAggBEGA0cQAEPIBAAuHDAIGfwZ+IwBBoAZrIgIkACACQdAFaiIFIAEQUCACIAIpA4AGIAIpA/gFIAIpA/AFIghCGoh8IgtCGYh8IgmnQf///x9xNgIYIAIgAikD4AUgAikD2AUgAikD0AUiDEIaiHwiDUIZiHwiCqdB////H3E2AgggAiACKQOIBiAJQhqIfCIJp0H///8PcTYCHCACIAIpA+gFIApCGoh8IgqnQf///w9xNgIMIAIgAikDkAYgCUIZiHwiCadB////H3E2AiAgAiALQv///w+DIAhC////H4MgCkIZiHwiCEIaiHw+AhQgAiAIp0H///8fcTYCECACIAIpA5gGIAlCGoh8IginQf///w9xNgIkIAIgDUL///8PgyAIQhmIQhN+IAxC////H4N8IghCGoh8PgIEIAIgCKdB////H3E2AgAgBSACEFAgAiACKQOABiACKQP4BSACKQPwBSIIQhqIfCILQhmIfCIJp0H///8fcTYCwAUgAiACKQPgBSACKQPYBSACKQPQBSIMQhqIfCINQhmIfCIKp0H///8fcTYCsAUgAiACKQOIBiAJQhqIfCIJp0H///8PcTYCxAUgAiACKQPoBSAKQhqIfCIKp0H///8PcTYCtAUgAiACKQOQBiAJQhmIfCIJp0H///8fcTYCyAUgAiALQv///w+DIAhC////H4MgCkIZiHwiCEIaiHw+ArwFIAIgCKdB////H3E2ArgFIAIgAikDmAYgCUIaiHwiCKdB////D3E2AswFIAIgDUL///8PgyAIQhmIQhN+IAxC////H4N8IghCGoh8PgKsBSACIAinQf///x9xNgKoBSAFIAJBqAVqIgYQUCACIAIpA4AGIAIpA/gFIAIpA/AFIghCGoh8IgtCGYh8IgmnQf///x9xNgJAIAIgAikD4AUgAikD2AUgAikD0AUiDEIaiHwiDUIZiHwiCqdB////H3E2AjAgAiACKQOIBiAJQhqIfCIJp0H///8PcTYCRCACIAIpA+gFIApCGoh8IgqnQf///w9xNgI0IAIgAikDkAYgCUIZiHwiCadB////H3E2AkggAiALQv///w+DIAhC////H4MgCkIZiHwiCEIaiHw+AjwgAiAIp0H///8fcTYCOCACIAIpA5gGIAlCGoh8IginQf///w9xNgJMIAIgDUL///8PgyAIQhmIQhN+IAxC////H4N8IghCGoh8PgIsIAIgCKdB////H3E2AiggAkHQAGoiBCABIAJBKGoQNiACQfgAaiIBIAIgBBA2IAUgARBQIAIgAikDgAYgAikD+AUgAikD8AUiCEIaiHwiC0IZiHwiCadB////H3E2ArgBIAIgAikD4AUgAikD2AUgAikD0AUiDEIaiHwiDUIZiHwiCqdB////H3E2AqgBIAIgAikDiAYgCUIaiHwiCadB////D3E2ArwBIAIgAikD6AUgCkIaiHwiCqdB////D3E2AqwBIAIgAikDkAYgCUIZiHwiCadB////H3E2AsABIAIgC0L///8PgyAIQv///x+DIApCGYh8IghCGoh8PgK0ASACIAinQf///x9xNgKwASACIAIpA5gGIAlCGoh8IginQf///w9xNgLEASACIA1C////D4MgCEIZiEITfiAMQv///x+DfCIIQhqIfD4CpAEgAiAIp0H///8fcTYCoAEgAkHIAWoiAyAEIAJBoAFqEDYgAkHwAWoiBCADQQUQTCACQZgCaiIBIAQgAxA2IAJBwAJqIgMgAUEKEEwgAkHoAmoiBCADIAEQNiACQZADaiIDIARBFBBMIAJBuANqIgcgAyAEEDYgAkHgA2oiAyAHQQoQTCACQYgEaiIEIAMgARA2IAJBsARqIgMgBEEyEEwgAkHYBGoiASADIAQQNiACQYAFaiIDIAFB5AAQTCAGIAMg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fnwgECAafnwgGyAgfnwgAyAOfnwgCSAYfnwgBiALfnwgBSAHfnwgCCAMfnwgCiAdfnwgJUIaiHwiBKdB////D3E2AgwgACASIBR+IBEgE358IA4gFX58IAsgFn58IAMgAa0iDH58IAUgF358IAYgHn58IAcgD358IAggDX58IAkgCn58IB9CGYh8IgWnQf///x9xNgIgIAAgI0L///8PgyAiQv///x+DIARCGYh8IgRCGoh8PgIUIAAgBKdB////H3E2AhAgACAYIB5+IAwgGX58IA8gHH58IA0gGn58IAMgLa1+fCAJIBt+fCAGIBF+fCAHIBR+fCAIIA5+fCAKIAt+fCAFQhqIfCIDp0H///8PcTYCJCAAICRC////D4MgA0IZiEITfiAhQv///x+DfCIDQhqIfD4CBCAAIAOnQf///x9xNgIAC90MAg1/AX4jAEGgAmsiByQAAkACQAJAAkACQCABQYAITQRAIAdBADYCiAEgASABQQAgAUGACEcbIgxrIg5BgAhPBEAgB0EBNgKIASAHIAA2AowBQQEhCgsgB0GMAWohCyADIRQgBSEBIwBBIGsiCCQAIAZBBXYiCSAKIAkgCkkbIg0EQCAEQQJyIQ8gBEEBciEQA0AgCygCACEJIAhBGGoiESACQRhqKQIANwMAIAhBEGoiEiACQRBqKQIANwMAIAhBCGoiEyACQQhqKQIANwMAIAggAikCADcDACAIIAlBwAAgFCAQECIgCCAJQUBrQcAAIBQgBBAiIAggCUGAAWpBwAAgFCAEECIgCCAJQcABakHAACAUIAQQIiAIIAlBgAJqQcAAIBQgBBAiIAggCUHAAmpBwAAgFCAEECIgCCAJQYADakHAACAUIAQQIiAIIAlBwANqQcAAIBQgBBAiIAggCUGABGpBwAAgFCAEECIgCCAJQcAEakHAACAUIAQQIiAIIAlBgAVqQcAAIBQgBBAiIAggCUHABWpBwAAgFCAEECIgCCAJQYAGakHAACAUIAQQIiAIIAlBwAZqQcAAIBQgBBAiIAggCUGAB2pBwAAgFCAEECIgCCAJQcAHakHAACAUIA8QIiABQRhqIBEpAwA3AAAgAUEQaiASKQMANwAAIAFBCGogEykDADcAACABIAgpAwA3AAAgC0EEaiELIAFBIGohASAUQgF8IRQgDUEBayINDQALCyAIQSBq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BjcDCCAAIAZCP4g3AwAMEgsgACABMgEEIgY3AwggACAGQj+INwMADBELIAAgATQCBCIGNwMIIAAgBkI/iDcDAAwQCyAAIAEpAwgiBjcDCCAAIAZCP4g3AwAMDwsgASoCBLsiB71C////////////AINCgICAgICAgPj/AFoEQCAAQbXSwABBERDhATYCCCAAQgM3AwAMDwsgACAHOQMIIABCAjcDAAwOCyABKwMIIge9Qv///////////wCDQoCAgICAgID4/wBaBEAgAEG10sAAQREQ4QE2AgggAEIDNwMADA4LIAAgBzkDCCAAQgI3AwAMDQsgASgCBCEBIAJBADYCBCABQYABSQ0KIAFBP3FBgH9yIQMgAUEGdiEEIAFBgBBJBEAgAiADOgAFIAIgBEHAAXI6AARBAgwMCyABQQx2IQUgBEE/cUGAf3IhBCABQf//A00EQCACIAM6AAYgAiAEOgAFIAIgBUHgAXI6AARBAwwMCyACIAM6AAcgAiAEOgAGIAIgBUE/cUGAf3I6AAUgAiABQRJ2QXByOgAEQQQMCwsgASkDCCEGIAJBBToACCACIAY3AgwgAkEIaiACQR9qQaDSwAAQ1wEhASAAQgM3AwAgACABNgIIDAsLIAEpAgQhBiACQQU6AAggAiAGNwIMIAJBCGogAkEfakGg0sAAENcBIQEgAEIDNwMAIAAgATYCCAwKCyABKQMIIQYgAkEGOgAIIAIgBjcCDCACQQhqIAJBH2pBoNLAABDXASEBIABCAzcDACAAIAE2AggMCQsgASkCBCEGIAJBBjoACCACIAY3AgwgAkEIaiACQR9qQaDSwAAQ1wEhASAAQgM3AwAgACABNgIIDAgLIAJBCDoACCACQQhqIAJBH2pBoNLAABDXASEBIABCAzcDACAAIAE2AggMBwsgAkEIOgAIIAJBCGogAkEfakGg0sAAENcBIQEgAEIDNwMAIAAgATYCCAwGCyACQQc6AAggAkEIaiACQR9qQaDSwAAQ1wEhASAAQgM3AwAgACABNgIIDAULIAJBCToACCACQQhqIAJBH2pBoNLAABDXASEBIABCAzcDACAAIAE2AggMBAsgAkEKOgAIIAJBCGogAkEfakGg0sAAENcBIQEgAEIDNwMAIAAgATYCCAwDCyACQQs6AAggAkEIaiACQR9qQaDSwAAQ1wEhASAAQgM3AwAgACABNgIIDAILIAIgAToABEEBCzYCECACQQU6AAggAiACQQRqNgIMIAJBCGogAkEfakGg0sAAENcBIQEgAEIDNwMAIAAgATYCCAsgAkEgaiQAC5oHAQ1/IwBBoAFrIgMkACADQQA2AgwgA0KAgICAEDcCBCADQRBqIAEgAkGtq8AAQQEQMiADQYgBaiADQcgAaikDADcDACADQYABaiADQUBrKQMANwMAIANB+ABqIANBOGopAwA3AwAgA0HwAGogA0EwaikDADcDACADQegAaiADQShqKQMANwMAIANB4ABqIANBIGopAwA3AwAgA0HYAGoiDyADQRhqKQMANwMAIAMgAykDEDcDUEEBIQsCQANAAkACQAJAAkACQCADKAJQQQFGBEAgAygCjAEhBSADKAKIASEEIAMoAoQBIQcgAygCgAEhCCADKAJ0QX9GDQEgA0GUAWogDyAIIAcgBCAFQQAQcgwFCyADLQBeRQRAIAMtAFwhDCADKAKEASEEIAMoAoABIQgCQCADKAJUIgVFDQAgBCAFTQRAIAQgBUYNAQwJCyAFIAhqLAAAQUBIDQgLIAQgBUcEQAJ/IAUgCGoiDSwAACIHQQBIBEAgDS0AAUE/cSEKIAdBH3EhDiAOQQZ0IApyIAdBYEkNARogDS0AAkE/cSAKQQZ0ciEKIAogDkEMdHIgB0FwSQ0BGiAOQRJ0QYCA8ABxIA0tAANBP3EgCkEGdHJyDAELIAdB/wFxCyEHIAxBAXENAwJAAn9BASAHQYABSQ0AGkECIAdBgBBJDQAaQQNBBCAHQYCABEkbCyAFaiIFRQ0AIAQgBU0EQCAEIAVHDQoMAQsgBSAIaiwAAEFASA0JCyAEIAVGDQQgBSAIaiwAABoMAwsgAyAMQX9zQQFxOgBcIAUhBCAMQQFxDQQgA0EBOgBeCyADQQA2ApQBDAQLIANBlAFqIA8gCCAHIAQgBUEBEHIMAwsgBSEECyADQQA6AFwgAyAENgJUCyADIAQ2ApwBIAMgBDYCmAEgA0EBNgKUAQsgAygClAFBAUYEQCADKAKcASADKAKYASAJayIEIAMoAgQgBmtLBEAgA0EEaiAGIARBAUEBEMkBIAMoAgghCyADKAIMIQYLIAQEQCAGIAtqIAEgCWogBPwKAAALIAMgBCAGaiIGNgIMIQkMAQsLIAIgCWsiAiADKAIEIAZrSwRAIANBBGogBiACQQFBARDJASADKAIIIQsgAygCDCEGCyACBEAgBiALaiABIAlqIAL8CgAACyAAQQhqIAIgBmo2AgAgACADKQIENwIAIANBoAFqJAAPCyAIIAQgBSAEQfSxwAAQ6wIAC9QHAwR/A34BfCMAQTBrIgMkACABKAIAIQICQAJAAkACQAJAAkAgACgCAEEBaw4CAQIAC0EUIQEgACkDCCIHQpDOAFQEQCAHIQYMBAsDQCADQQhqIAFqIgBBBGsgByAHQpDOAIAiBkKQzgB+faciBEH//wNxQeQAbiIFQQF0LwDG0kA7AAAgAEECayAEIAVB5ABsa0H//wNxQQF0LwDG0kA7AAAgAUEEayEBIAdC/8HXL1YgBiEHDQALDAMLQRQhASAAKQMIIgggCEI/hyIGhSAGfSIHQpDOAFQEQCAHIQYMAgsDQCADQQhqIAFqIgBBBGsgByAHQpDOAIAiBkKQzgB+faciBEH//wNxQeQAbiIFQQF0LwDG0kA7AAAgAEECayAEIAVB5ABsa0H//wNxQQF0LwDG0kA7AAAgAUEEayEBIAdC/8HXL1YgBiEHDQALDAELIAArAwgiCb1C////////////AINCgICAgICAgPj/AFoEQCACKAIAIAIoAggiAWtBA00EQCACIAFBBEEBQQEQyQEgAigCCCEBCyACIAFBBGo2AgggAigCBCABakHu6rHjBjYAAAwDCyAJIANBCGoQKCIBIAIoAgAgAigCCCIAa0sEQCACIAAgAUEBQQEQyQEgAigCCCEACyABBEAgAigCBCAAaiADQQhqIAH8CgAACyACIAAgAWo2AggMAgsgBkLjAFYEQCABQQJrIgEgA0EIamogBqciACAAQf//A3FB5ABuIgBB5ABsa0H//wNxQQF0LwDG0kA7AAAgAK0hBgsCQCAGQgpaBEAgAUECayIAIANBCGpqIAanQQF0LwDG0kA7AAAMAQsgAUEBayIAIANBCGpqIAanQTByOgAACyAIQgBTBEAgAEEBayIAIANBCGpqQS06AAALQRQgAGsiBCACKAIAIAIoAggiAWtLBEAgAiABIARBAUEBEMkBIAIoAgghAQsgBARAIAIoAgQgAWogA0EIaiAAaiAE/AoAAAsgAiABIARqNgIIDAELIAZC4wBWBEAgAUECayIBIANBCGpqIAan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KALoAUEBdCIMNgKQAiADIAMoAuwBQQF0Ig02ApQCIAAgBSAGEHogAygCxAEhBSADKAJ4IQYgAygCUCEOIAMoAnwhDyADKAJUIRAgAygCgAEhESADKAJYIRIgAygChAEhEyADKAJcIRQgAygCiAEhFSADKAJgIRcgAygCjAEhGCADKAJkIRkgAygCkAEhGiADKAJoIRsgAygClAEhHCADKAJsIR0gAygCmAEhHiADKAJwIR8gAygCnAEhICADKAJ0ISEgAygCoAEhIiADKAKkASEjIAMoAqgBISQgAygCrAEhJSADKAKwASEmIAMoArQBIScgAygCuAEhKCADKAK8ASEpIAMoAsABISogA0GYAmogA0HwAWogFhB6IAAgBSANajYCdCAAIAwgKmo2AnAgACALIClqNgJsIAAgCiAoajYCaCAAIAkgJ2o2AmQgACAIICZqNgJgIAAgByAlajYCXCAAIAQgJGo2AlggACACICNqNgJUIAAgASAiajYCUCAAICAgIWo2AkwgACAeIB9qNgJIIAAgHCAdajYCRCAAIBogG2o2AkAgACAYIBlqNgI8IAAgFSAXajYCOCAAIBMgFGo2AjQgACARIBJqNgIwIAAgDyAQajYCLCAAIAYgDmo2AiggAEGYAWogA0G4AmopAgA3AgAgAEGQAWogA0GwAmopAgA3AgAgAEGIAWogA0GoAmopAgA3AgAgAEGAAWogA0GgAmopAgA3AgAgACADKQKYAjcCeCADQcACaiQAC9kIAgd/AX4jAEHAA2siByQAAkACQCACQSBGBEAgAUECai0AACELIAEoAAMhCSABKAAHIQIgASgACyEMIAEpAA8hDiABLwAAIQ0gB0HrAWogAUEfai0AADoAACAHIAs6AM4BIAcgDTsBzAEgByAONwDbASAHIAw2ANcBIAcgAjYA0wEgByAJNgDPASAHIAEpABc3AOMBIAdBmAJqIgggB0HMAWoiChBWIAcoApgCRQRAIAdBADYCmAIgByAIEJQCIAcoAgAhAiAHIAcoAgQiAzYCkAIgByACNgKMAiAHQQA2AtQBIAdCgICAgBA3AswBIAdB4LzAADYCnAIgB0KggICADjcCoAIgByAKNgKYAiAHQYwCaiEEIwBBMGsiASQAAn9BASAIQdKewwBBDxDpAg0AGkEAIAQoAgBFDQAaIAEgBDYCDCABQQE2AhQgAUHknsMANgIQIAFCATcCHCABIAFBDGqtQoCAgIDQD4Q3AyggASABQShqNgIYIAgoAgAgCCgCBCABQRBqEGALIAFBMGokAA0CIAcvAdABIAdB0gFqLQAAQRB0ciEBIActANcBIQQgBygA0wEhBSAHKALMASEGAkAgAkUNACADKAIAIggEQCACIAgRBAALIAMoAgQiCEUNACACIAggAygCCBD6AgsgACABOwEIIAAgBDoADyAAIAU2AAsgACAGNgIEIABBBDYCACAAQQpqIAFBEHY6AAAMAwsgB0E4aiAHQagCaigCADYCACAHIAcpAqACNwIwIAcoApwCIQggB0E8aiAHQawCakGQAfwKAAAgB0EraiABQRdqIgFBCGotAAA6AAAgB0EWaiACQRh2OgAAIAcgDjwAGyAHIA5CKIinIgo7ASAgB0EiaiAKQRB2OgAAIAcgASkAADcAIyAHIAJBCHY7ARQgByAINgIsIAcgDDYAFyAHIAJBGHQgCUEIdnI2AhAgByANIAtBEHRyIAlBGHRyNgIMIAcgDkIIiD4CHCAGQcAARgRAIAdBzgFqIAVBAmotAAA6AAAgB0HrAWogBUEfaikAADcAACAHQfMBaiAFQSdqKQAANwAAIAdB+wFqIAVBL2opAAA3AAAgB0GDAmogBUE3aikAADcAACAHQYsCaiAFQT9qLQAAOgAAIAcgBS8AADsBzAEgByAFKQAXNwDjASAFKAADIQEgB0HbAWogBUEPaikAADcAACAHIAE2AM8BIAcgBSkABzcA0wEgB0GYAmoiASAHQcwBahDqASAHQYwCaiAHQQxqIAMgBCABEIEBIABBCjYCACAAIAcoAowCIgBBAXM6AAQgAEUNAyAHKAKQAiIARQ0DIAcoApQCIgEoAgAiAgRAIAAgAhEEAAsgASgCBCICRQ0DIAAgAiABKAIIEPoCDAMLIABBAzYCAAwCCyAAIAI2AgggAEKAgICAgAQ3AgAMAQtBiL3AAEE3IAdBvwNqQfi8wABBwL3AABDmAQALIAdBwANqJAAL/wcBKH8jAEGgAmsiAyQAIAEoAgAhBCABKAIoIQcgASgCBCEIIAEoAiwhCSABKAIIIQogASgCMCELIAEoAgwhDCABKAI0IQ0gASgCECEFIAEoAjghBiABKAIUIQ4gASgCPCEPIAEoAhghECABKAJAIREgASgCHCESIAEoAkQhEyABKAIgIRQgASgCSCEVIAMgASgCJCABKAJMajYCLCADIBQgFWo2AiggAyASIBNqNgIkIAMgECARajYCICADIA4gD2o2AhwgAyAFIAZqNgIYIAMgDCANajYCFCADIAogC2o2AhAgAyAIIAlqNgIMIAMgBCAHajYCCCADQTBqIgQgAUEoaiABEHogA0HYAGoiBSADQQhqIAIQNiADQYABaiIGIAQgAkEoahA2IANBqAFqIhYgAUH4AGogAkHQAGoQNiADIAEoAlBBAXQiAjYC0AEgAyABKAJUQQF0IgQ2AtQBIAMgASgCWEEBdCIHNgLYASADIAEoAlxBAXQiCDYC3AEgAyABKAJgQQF0Igk2AuABIAMgASgCZEEBdCIKNgLkASADIAEoAmhBAXQiCzYC6AEgAyABKAJsQQF0Igw2AuwBIAMgASgCcEEBdCINNgLwASADIAEoAnRBAXQiATYC9AEgACAFIAYQeiADKALMASEFIAMoAoABIQYgAygCWCEOIAMoAoQBIQ8gAygCXCEQIAMoAogBIREgAygCYCESIAMoAowBIRMgAygCZCEUIAMoApABIRUgAygCaCEXIAMoApQBIRggAygCbCEZIAMoApgBIRogAygCcCEbIAMoApwBIRwgAygCdCEdIAMoAqABIR4gAygCeCEfIAMoAqQBISAgAygCfCEhIAMoAqgBISIgAygCrAEhIyADKAKwASEkIAMoArQBISUgAygCuAEhJiADKAK8ASEnIAMoAsABISggAygCxAEhKSADKALIASEqIANB+AFqIANB0AFqIBYQeiAAIAEgBWo2AnQgACANICpqNgJwIAAgDCApajYCbCAAIAsgKGo2AmggACAKICdqNgJkIAAgCSAmajYCYCAAIAggJWo2AlwgACAHICRqNgJYIAAgBCAjajYCVCAAIAIgImo2AlAgACAgICFqNgJMIAAgHiAfajYCSCAAIBwgHWo2AkQgACAaIBtqNgJAIAAgGCAZajYCPCAAIBUgF2o2AjggACATIBRqNgI0IAAgESASajYCMCAAIA8gEGo2AiwgACAGIA5qNgIoIABBmAFqIANBmAJqKQIANwIAIABBkAFqIANBkAJqKQIANwIAIABBiAFqIANBiAJqKQIANwIAIABBgAFqIANBgAJqKQIANwIAIAAgAykC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B0ECa0E3SSEWA0AgACAINgKYASAQIAAgDmoiA0GEAWopAAA3AwAgESADQYwBaikAADcDACASIANBlAFqKQAANwMAIAIgA0H8AGopAAA3AwAgCEUNAiAAIAhBAWsiBzYCmAEgAkGoAWoiBCADQfQAaiIXKQAANwMAIAJBoAFqIgUgA0HsAGoiGCkAADcDACACQZgBaiIGIANB5ABqIhkpAAA3AwAgAiADQdwAaiIaKQAANwOQASAJQRhqIBIpAwA3AAAgCUEQaiARKQMANwAAIAlBCGogECkDADcAACAJIAIpAwA3AAAgCiAAKQMANwMAIApBCGogAEEIaiILKQMANwMAIApBEGogAEEQaiIMKQMANwMAIApBGGogAEEYaiINKQMANwMAIAJBKGogBikDADcDACACQTBqIAUpAwA3AwAgAkE4aiAEKQMANwMAIAJBQGsgCSkDADcDACACQcgAaiACQbgBaikDADcDACACQdAAaiACQcABaikDADcDACACQdgAaiACQcgBaikDADcDACACIAIpA5ABNwMgIAJBwAA6AIgBIAIgDzoAiQEgAkIANwOAASAEIA0pAgA3AwAgBSAMKQIANwMAIAYgCykCADcDACACIAApAgA3A5ABIAJBkAFqIAJBIGpBwABCACAPECIgBCgCACEEIAUoAgAhBSAGKAIAIQYgAigCrAEhCyACKAKkASEMIAIoApwBIQ0gAigClAEhEyACKAKQASEUIBZFDQMgGiAUNgIAIANB+ABqIAs2AgAgFyAENgIAIANB8ABqIAw2AgAgGCAFNgIAIANB6ABqIA02AgAgGSAGNgIAIANB4ABqIBM2AgAgACAINgKYASAOQSBrIQ4gByIIIBVPDQALCyACQdABaiQADwtB5NnAABD8AgALIAIgCzYCrAEgAiAENgKoASACIAw2AqQBIAIgBTYCoAEgAiANNgKcASACIAY2ApgBIAIgEzYClAEgAiAUNgKQAUGs28AAQSsgAkGQAWpBnNzAAEH02cAAEOYBAAvuBgEHfyAAKAIAIgEEQCAAKAIEIQICQCAAKAIIIgcEfwNAAkAgBARAIAEhACAEIQEMAQtBACEAAkAgAkUNACACIQUgAkEHcSIDBEADQCAFQQFrIQUgASgCmAMhASADQQFrIgMNAAsLIAJBCEkNAANAIAEoApgDKAKYAygCmAMo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IAEgBGo2AhAgA0EEaiADQRBqEJ0BIAMoAgRBgICAgHhGBEAgACADKQIINwIEIABBiICAgHg2AgAMAQsgACADKQIENwIEIABBDGogA0EMaigCADYCACAAQYqAgIB4NgIACyADQdAAaiQADwsgCCAFIAQgBUHgzsAAEOsCAAvdBQEBfyAAQQAgAkH/AXFrIgIgACgCACIDIAEoAgBzcSADczYCACAAIAAoAgQiAyABKAIEcyACcSADczYCBCAAIAAoAggiAyABKAIIcyACcSADczYCCCAAIAAoAgwiAyABKAIMcyACcSADczYCDCAAIAAoAhAiAyABKAIQcyACcSADczYCECAAIAAoAhQiAyABKAIUcyACcSADczYCFCAAIAAoAhgiAyABKAIYcyACcSADczYCGCAAIAAoAhwiAyABKAIccyACcSADczYCHCAAIAAoAiAiAyABKAIgcyACcSADczYCICAAIAAoAiQiAyABKAIkcyACcSADczYCJCAAIAAoAigiAyABKAIocyACcSADczYCKCAAIAAoAiwiAyABKAIscyACcSADczYCLCAAIAAoAjAiAyABKAIwcyACcSADczYCMCAAIAAoAjQiAyABKAI0cyACcSADczYCNCAAIAAoAjgiAyABKAI4cyACcSADczYCOCAAIAAoAjwiAyABKAI8cyACcSADczYCPCAAIAAoAkAiAyABKAJAcyACcSADczYCQCAAIAAoAkQiAyABKAJEcyACcSADczYCRCAAIAAoAkgiAyABKAJIcyACcSADczYCSCAAIAAoAkwiAyABKAJMcyACcSADczYCTCAAIAAoAlAiAyABKAJQcyACcSADczYCUCAAIAAoAlQiAyABKAJUcyACcSADczYCVCAAIAAoAlgiAyABKAJYcyACcSADczYCWCAAIAAoAlwiAyABKAJccyACcSADczYCXCAAIAAoAmAiAyABKAJgcyACcSADczYCYCAAIAAoAmQiAyABKAJkcyACcSADczYCZCAAIAAoAmgiAyABKAJocyACcSADczYCaCAAIAAoAmwiAyABKAJscyACcSADczYCbCAAIAAoAnAiAyABKAJwcyACcSADczYCcCAAIAAoAnQiACABKAJ0cyACcSAAczYCdAvaBQIHfwF+An8gAUUEQCAAKAIIIQdBLSELIAVBAWoMAQtBK0GAgMQAIAAoAggiB0GAgIABcSIBGyELIAFBFXYgBWoLIQkCQCAHQYCAgARxRQRAQQAhAgwBCwJAIANBEE8EQCACIAMQQSEBDAELIANFBEBBACEBDAELIANBA3EhCgJAIANBBEkEQEEAIQEMAQsgA0EMcSEMQQAhAQNAIAEgAiAIaiIGLAAAQb9/SmogBkEBaiwAAEG/f0pqIAZBAmosAABBv39KaiAGQQNqLAAAQb9/SmohASAMIAhBBGoiCEcNAAsLIApFDQAgAiAIaiEGA0AgASAGLAAAQb9/SmohASAGQQFqIQYgCkEBayIKDQALCyABIAlqIQkLAkAgAC8BDCIIIAlLBEACQAJAIAdBgICACHFFBEAgCCAJayEIQQAhAUEAIQkCQAJAAkAgB0EddkEDcUEBaw4DAAEAAgsgCCEJDAELIAhB/v8DcUEBdiEJCyAHQf///wBxIQogACgCBCEHIAAoAgAhAANAIAFB//8DcSAJQf//A3FPDQJBASEGIAFBAWohASAAIAogBygCEBEAAEUNAAsMBAsgACAAKQIIIg2nQYCAgP95cUGwgICAAnI2AghBASEGIAAoAgAiByAAKAIEIgogCyACIAMQowINA0EAIQEgCCAJa0H//wNxIQIDQCABQf//A3EgAk8NAiABQQFqIQEgB0EwIAooAhARAABFDQALDAMLQQEhBiAAIAcgCyACIAMQowINAiAAIAQgBSAHKAIMEQEADQJBACEBIAggCWtB//8DcSECA0AgAUH//wNxIgMgAkkhBiACIANNDQMgAUEBaiEBIAAgCiAHKAIQEQAARQ0ACwwCCyAHIAQgBSAKKAIMEQEADQEgACANNwIIQQAPC0EBIQYgACgCACIBIAAoAgQiACALIAIgAxCjAg0AIAEgBCAFIAAoAgwRAQAhBgsgBgvABQIBfwZ+IwBBgAFrIgMkACADQTBqIAEQUCADIAMpA2AgAykDWCADKQNQIgRCGoh8IgdCGYh8IgWnQf///x9xNgIgIAMgAykDQCADKQM4IAMpAzAiCEIaiHwiCUIZiHwiBqdB////H3E2AhAgAyADKQNoIAVCGoh8IgWnQf///w9xNgIkIAMgAykDSCAGQhqIfCIGp0H///8PcTYCFCADIAMpA3AgBUIZiHwiBadB////H3E2AiggAyAHQv///w+DIARC////H4MgBkIZiHwiBEIaiHw+AhwgAyAEp0H///8fcTYCGCADIAMpA3ggBUIaiHwiBKdB////D3E2AiwgAyAJQv///w+DIARCGYhCE34gCEL///8fg3wiBEIaiHw+AgwgAyAEp0H///8fcTYCCCACQQJPBEAgAkEBayECA0AgA0EwaiADQQhqEFAgAyADKQNgIAMpA1ggAykDUCIEQhqIfCIHQhmIfCIFp0H///8fcTYCICADIAMpA0AgAykDOCADKQMwIghCGoh8IglCGYh8IganQf///x9xNgIQIAMgAykDaCAFQhqIfCIFp0H///8PcTYCJCADIAMpA0ggBkIaiHwiBqdB////D3E2AhQgAyADKQNwIAVCGYh8IgWnQf///x9xNgIoIAMgB0L///8PgyAEQv///x+DIAZCGYh8IgRCGoh8PgIcIAMgBKdB////H3E2AhggAyADKQN4IAVCGoh8IgSnQf///w9xNgIsIAMgCUL///8PgyAEQhmIQhN+IAhC////H4N8IgRCGoh8PgIMIAMgBKdB////H3E2AgggAkEBayICDQALCyAAIAMpAgg3AgAgAEEgaiADQShqKQIANwIAIABBGGogA0EgaikCADcCACAAQRBqIANBGGopAgA3AgAgAEEIaiADQRBqKQIANwIAIANBgAFqJAALlwYBBX8gAEEIayIBIABBBGsoAgAiA0F4cSIAaiECAkACQCADQQFxDQAgA0ECcUUNASABKAIAIgMgAGohACABIANrIgFB+OfEACgCAEYEQCACKAIEQQNxQQNHDQFB8OfEACAANgIAIAIgAigCBEF+cTYCBCABIABBAXI2AgQgAiAANgIADwsgASADEIYBCwJAAkACQAJAAkAgAigCBCIDQQJxRQRAIAJB/OfEACgCAEYNAiACQfjnxAAoAgBGDQMgAiADQXhxIgIQhgEgASAAIAJqIgBBAXI2AgQgACABaiAANgIAIAFB+OfEACgCAEcNAUHw58QAIAA2AgAPCyACIANBfnE2AgQgASAAQQFyNgIEIAAgAWogADYCAAsgAEGAAkkNAiABIAAQlQFBACEBQZDoxABBkOjEACgCAEEBayIANgIAIAANBEHY5cQAKAIAIgAEQANAIAFBAWohASAAKAIIIgANAAsLQZDoxABB/x8gASABQf8fTRs2AgAPC0H858QAIAE2AgBB9OfEAEH058QA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AmoiCiAFQQxsaiIJQQhqKAIANgIAIAJBQGsgByAFQRhsaiIDQQhqKQMANwMAIAJByABqIANBEGopAwA3AwAgAiAJKQIANwMoIAIgAykDADcDOCAEQQxPDQEgBUEBaiEDIARBDGwiCQRAIAZBjAJqIAogA0EMbGogCfwKAAALIARBGGwiBARAIAYgByADQRhsaiAE/AoAAAsgByAFOwGSAyACQQhqIAJBMGooAgA2AgAgAkEYaiACQUBrKQMANwMAIAJBIGogAkHIAGopAwA3AwAgAiACKQMoNwMAIAIgAikDODcDECAGLwGSAyIEQQFqIQMgBEEMTw0CIAggBWsgA0cNAyAGQZgDaiEIIANBAnQiAwRAIAggByAFQQJ0akGcA2ogA/wKAAALIAEoAgQhBUEAIQEDQAJAIAggAUECdGooAgAiAyABOwGQAyADIAY2AogCIAEgBE8NACABIAEgBElqIgEgBE0NAQsLIAAgBTYCLCAAIAc2AiggACACKQMANwMAIAAgBTYCNCAAIAY2AjAgAEEIaiACQQhqKQMANwMAIABBEGogAkEQaikDADcDACAAQRhqIAJBGGopAwA3AwAgAEEgaiACQSBqKQMANwMAIAJB0ABqJAAPC0EIQcgDEJoDAAtBACAEQQtB6LXAABCYAgALQQAgA0EMQfi1wAAQmAIAC0GwtcAAQShB2LXAABCZAgALuCACFX8IfiMAQaADayIEJAAgBEGoAWoiAiABEG8gBEHwAWpBkOXAACkCADcDACAEQegBakGI5cAAKQIANwMAIARB4AFqQYDlwAApAgA3AwAgBEHYAWpB+OTAACkCADcDACAEQfDkwAApAgA3A9ABIwBB0ABrIgMkACADIAIQUCAEQfwBaiICIAMpAzAgAykDKCADKQMgIhdCGoh8IhtCGYh8IhinQf///x9xNgIYIAIgAykDECADKQMIIAMpAwAiHEIaiHwiGkIZiHwiGadB////H3E2AgggAiADKQM4IBhCGoh8IhinQf///w9xNgIcIAIgAykDGCAZQhqIfCIZp0H///8PcTYCDCACIAMpA0AgGEIZiHwiGKdB////H3E2AiAgAiAbQv///w+DIBdC////H4MgGUIZiHwiF0IaiHw+AhQgAiAXp0H///8fcTYCECACIAMpA0ggGEIaiHwiF6dB////D3E2AiQgAiAaQv///w+DIBdCGYhCE34gHEL///8fg3wiF0IaiHw+AgQgAiAXp0H///8fcTYCACADQdAAaiQAIARBpAJqIgMgAiAEQdABahB6IARB2ABqIAJByOTAABA2IAQgBCgCfDYC8AIgBCAEKQJ0NwLoAiAEIAQpAmw3AuACIAQgBCkCZDcC2AIgBCAEKQJcNwLQAiAEIAQoAlhBAWo2AswCIARB9AJqIQkjAEHwAmsiAiQAIAJBoAJqIgUgBEHMAmoiCBBQIAIgAikD0AIgAikDyAIgAikDwAIiF0IaiHwiG0IZiHwiGKdB////H3E2ApACIAIgAikDsAIgAikDqAIgAikDoAIiHEIaiHwiGkIZiHwiGadB////H3E2AoACIAIgAikD2AIgGEIaiHwiGKdB////D3E2ApQCIAIgAikDuAIgGUIaiHwiGadB////D3E2AoQCIAIgAikD4AIgGEIZiHwiGKdB////H3E2ApgCIAIgG0L///8PgyAXQv///x+DIBlCGYh8IhdCGoh8PgKMAiACIBenQf///x9xNgKIAiACIAIpA+gCIBhCGoh8IhenQf///w9xNgKcAiACIBpC////D4MgF0IZiEITfiAcQv///x+DfCIXQhqIfD4C/AEgAiAXp0H///8fcTYC+AEgAkEIaiIHIAJB+AFqIgYgCBA2IAUgBxBQIAIgAikD0AIgAikDyAIgAikDwAIiF0IaiHwiG0IZiHwiGKdB////H3E2ApACIAIgAikDsAIgAikDqAIgAikDoAIiHEIaiHwiGkIZiHwiGadB////H3E2AoACIAIgAikD2AIgGEIaiHwiGKdB////D3E2ApQCIAIgAikDuAIgGUIaiHwiGadB////D3E2AoQCIAIgAikD4AIgGEIZiHwiGKdB////H3E2ApgCIAIgG0L///8PgyAXQv///x+DIBlCGYh8IhdCGoh8PgKMAiACIBenQf///x9xNgKIAiACIAIpA+gCIBhCGoh8IhenQf///w9xNgKcAiACIBpC////D4MgF0IZiEITfiAcQv///x+DfCIXQhqIfD4C/AEgAiAXp0H///8fcTYC+AEgAkEwaiIKIAYgCBA2IAJBgAFqIgsgAyAHEDYgAkHQAWoiByADIAoQNiAFIAcQMyACQZgCaiACQcACaikCADcDACACQZACaiACQbgCaikCADcDACACQYgCaiACQbACaikCADcDACACQYACaiACQagCaikCADcDACACIAIpAqACNwP4ASAFIAZBAhBMIAJBqAFqIgogByAFEDYgAkHYAGoiDCALIAoQNiAFIAwQUCACIAIpA9ACIAIpA8gCIAIpA8ACIhdCGoh8IhtCGYh8IhinQf///x9xNgKQAiACIAIpA7ACIAIpA6gCIAIpA6ACIhxCGoh8IhpCGYh8IhmnQf///x9xNgKAAiACIAIpA9gCIBhCGoh8IhinQf///w9xNgKUAiACIAIpA7gCIBlCGoh8IhmnQf///w9xNgKEAiACIAIpA+ACIBhCGYh8IhinQf///x9xNgKYAiACIBtC////D4MgF0L///8fgyAZQhmIfCIXQhqIfD4CjAIgAiAXp0H///8fcTYCiAIgAiACKQPoAiAYQhqIfCIXp0H///8PcTYCnAIgAiAaQv///w+DIBdCGYhCE34gHEL///8fg3wiF0IaiHw+AvwBIAIgF6dB////H3E2AvgBIAcgCCAGEDYgBiAHEEUgBSADEEVBACEFQQEhBgNAIAJB+AFqIgcgBWotAAAgAkGgAmoiCCAFai0AAEYQ5wIgBnEhBiAFQQFqIgVBIEcNAAsgBhDnAiEVIAJB8P///wMgAygCGGutQfD///8BIAMoAhRrrUHw////AyADKAIQa60iF0IaiHwiG0IZiHwiGKdB////H3EiCjYCuAIgAkHw////AyADKAIIa61B8P///wEgAygCBGutQdD9//8DIAMoAgBrrSIcQhqIfCIaQhmIfCIZp0H///8fcSILNgKoAiACQfD///8BIAMoAhxrrSAYQhqIfCIYp0H///8PcSIMNgK8AiACQfD///8BIAMoAgxrrSAZQhqIfCIZp0H///8PcSINNgKsAiACQfD///8DIAMoAiBrrSAYQhmIfCIYp0H///8fcSIONgLAAiACIBdC////H4MgGUIZiHwiF6dB////H3EiDzYCsAIgAiAbQv///w+DIBdCGoh8pyIQNgK0AiACQfD///8BIAMoAiRrrSAYQhqIfCIXp0H///8PcSITNgLEAiACIBdCGYhCE34gHEL///8fg3wiF6dB////H3EiETYCoAIgAiAaQv///w+DIBdCGoh8pyISNgKkAiACQagBaiACQdABahBFIAcgCBBFQQAhBUEBIQYDQCACQagBaiIHIAVqLQAAIAJB+AFqIgMgBWotAABGEOcCIAZxIQYgBUEBaiIFQSBHDQALIAYQ5wIhFCACIBM2AsQCIAIgDjYCwAIgAiAMNgK8AiACIAo2ArgCIAIgEDYCtAIgAiAPNgKwAiACIA02AqwCIAIgCzYCqAIgAiASNgKkAiACIBE2AqACIAMgAkGgAmpB+OPAABA2IAJBgAFqIAJB0AFqEEUgByADEEVBACEFQQEhBgNAIAJBgAFqIAVqLQAAIAJBqAFqIAVqLQAARhDnAiAGcSEGIAVBAWoiBUEgRw0ACyAGEOcCIQMgAkGgAmpB+OPAACACQdgAaiIWEDYgAkHgAGoiBUEAIAMgFHIQ5wJB/wFxayIDIAUoAgAiBiACKAKoAnNxIAZzIgY2AgAgAkHoAGoiByAHKAIAIgggAigCsAJzIANxIAhzIgg2AgAgAkHwAGoiCiAKKAIAIgsgAigCuAJzIANxIAtzIgs2AgAgAiACKAJkIgwgAigCrAJzIANxIAxzIgw2AmQgAiACKAJcIg0gAigCpAJzIANxIA1zIg02AlwgAiACKAJYIg4gAigCoAJzIANxIA5zIg42AlggAiACKAJsIg8gAigCtAJzIANxIA9zIg82AmwgAiACKAJ0IhAgAigCvAJzIANxIBBzIhA2AnQgAkH4AGoiEyATKAIAIhEgAigCwAJzIANxIBFzIhE2AgAgAiADIAIoAnwiEiACKALEAnNxIBJzIhI2AnwgAkH4AWogFhBFIBNBACACLQD4AUEBcRDnAkH/AXFrIgNB8P///wMgEWutQfD///8BIBBrrUHw////AyALa61B8P///wEgD2utQfD///8DIAhrrSIXQhqIfCIbQhmIfCIYQhqIfCIcQhmIfCIap0H///8fcSARc3EgEXM2AgAgCiAYp0H///8fcSALcyADcSALczYCACAHIBdC////H4NB8P///wEgDGutQfD///8DIAZrrUHw////ASANa61B0P3//wMgDmutIhdCGoh8IhhCGYh8IhlCGoh8Ih1CGYh8Ih6nQf///x9xIAhzIANxIAhzNgIAIAUgGadB////H3EgBnMgA3EgBnM2AgAgAkHw////ASASa60gGkIaiHwiGqdB////D3EgEnMgA3EgEnM2AnwgAiAcp0H///8PcSAQcyADcSAQczYCdCACIA8gG0L///8PgyAeQhqIfKdzIANxIA9zNgJsIAIgHadB////D3EgDHMgA3EgDHM2AmQgAiAaQhmIQhN+IBdC////H4N8IhenQf///x9xIA5zIANxIA5zNgJYIAIgDSAYQv///w+DIBdCGoh8p3MgA3EgDXM2AlwgCSAUIBVyEOcCOgAAIAkgAikCWDcCBCAJQQxqIAUpAgA3AgAgCUEUaiAHKQIANwIAIAlBHGogCikCADcCACAJQSRqIBMpAgA3AgAgAkHwAmokACAEQeAAaiIDIARBgANqKQIANwMAIARB6ABqIgIgBEGIA2opAgA3AwAgBEHwAGoiBSAEQZADaikCADcDACAEQfgAaiIGIARBmANqKQIANwMAIARBiAFqIgkgBEGwAWopAgA3AwAgBEGQAWoiByAEQbgBaikCADcDACAEQZgBaiIIIARBwAFqKQIANwMAIARBoAFqIgogBEHIAWopAgA3AwAgBCAEKQL4AjcDWCAEIAQpAqgBNwOAASAELQD0AiELIARBKGogBikDADcDACAEQSBqIAUpAwA3AwAgBEEYaiACKQMANwMAIARBEGogAykDADcDACAEIAQpA1g3AwggBEHQAGogCikDADcDACAEQcgAaiAIKQMANwMAIARBQGsgBykDADcDACAEQThqIAkpAwA3AwAgBCAEKQOAATcDMCAAIAsEfyMAQTBrIgMkACABLQAfQQd2EOcCIQIgA0EIaiAEQQhqIgEQkAEgAUEAIAJB/wFxayICIAEoAgAiBSADKAIIc3EgBXM2AgAgASABKAIEIgUgAygCDHMgAnEgBXM2AgQgAUEIaiIFIAUoAgAiBiADKAIQcyACcSAGczYCACABIAEoAgwiBiADKAIUcyACcSAGczYCDCABQRBqIgYgBigCACIJIAMoAhhzIAJxIAlzNgIAIAEgASgCFCIJIAMoAhxzIAJxIAlzNgIUIAFBGGoiCSAJKAIAIgcgAygCIHMgAnEgB3M2AgAgASABKAIcIgcgAygCJHMgAnEgB3M2AhwgAUEgaiIHIAcoAgAiCCADKAIocyACcSAIczYCACABIAIgASgCJCIIIAMoAixzcSAIczYCJCAAQQRqIgBBIGogBykCADcCACAAQRhqIAkpAgA3AgAgAEEQaiAGKQIANwIAIABBCGogBSkCADcCACAAIAEpAgA3AgAgAEH4AGogASAE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EGoiDSAHNgIAIAIgAzYCHCACQRhqIgcgETYCACACIA42AiQgAkEgaiIDIA82AgAgAiALNgIsIAJBKGoiCyAWNgIAIAIgDDYCNCACQTBqIgwgFzYCACACIAk2AjwgAkE4aiIJIAo2AgAgAiAjNwMAIARBEGogEykDADcDACAEQRhqIA0pAwA3AwAgBEEgaiAHKQMANwMAIARBKGogAykDADcDACAEQTBqIAspAwA3AwAgBEE4aiAMKQMANwMAIARBQGsgCSkDADcDACAEICM3AwggBkEFRg0JIARBBTYCTCAGQfv///8AakH/////AHFBBWogBEHMAGpBwLTAABDgASEGIAJCAzcDACACIAY2AgggASgCECIGBEAgASgCFCAGQQEQ+gILIAEoAhwiBgRAIAEoAiAgBkEBEPoCCyABKAI0IgZBgICAgHhGIAZFckUEQCABKAI4IAZBARD6AgsgASgCKCIGBEAgASgCLCAGQQEQ+gILDAkLQQJB7LPAAEH0s8AAEOABCyEBIAJCAzcDACACIAE2AggMBAtBA0Hss8AAQfSzwAAQ4AEhCgsgAkIDNwMAIAIgCjYCCAwCC0EEQeyzwABB9LPAABDgAQshASACQgM3AwAgAiABNgIIIAxBgICAgHhyQYCAgIB4Rg0AIAogDEEBEPoCCyADRQ0AIA8gA0EBEPoCCyAHRQ0BIA0gB0EBEPoCDAELAkACQAJAAn8CfwJAIAUoAggiAUUEQEGBgICAeCENQYCAgIB4IQoMAQsgAUEFdCEgIAUoAgQhIUGBgICAeCENQYCAgIB4IQpBgICAgHghDEIDISMDQCABIQYCQAJAAkACQAJAAkACQAJAQRUgDyAhaiIDKAIAIg5BgICAgHhzIA5BAE4bQQFrDg8BAAACAAAAAAAAAAMEBQYACyADIARBzABqQYizwAAQwgIhDiAEQQE6AAggBCAONgIMDAYLIARBADoACCAEQQUgA0EEai0AACIOIA5BBU8bOgAJDAULIARBADoACCAEQgUgA0EIaikDACIkICRCBVobPAAJDAQLIARBCGogA0EIaigCACADQQxqKAIAEOQBDAMLIARBCGogA0EEaigCACADQQhqKAIAEOQBDAILIARBCGogA0EIaigCACADQQxqKAIAEHYMAQsgBEEIaiADQQRqKAIAIANBCGooAgAQdgsCQAJA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/////wFxIAZB/////wFxIAVB/////wFxIAJB/////wFxIAxB7afX5wFxIARB/////wFxaiICQR12aiANQdKxzARxaiIDQR12aiAOQZbrnO8BcWoiBEEddmogD0HF+s7vAXFqIgVBHXZqIBBBzQJxaiIGQR12aiIHQR12aiIIQR12aiIJQf////8BcTYCHCAAIAhB/////wFxNgIYIAAgB0H/////AXE2AhQgACAGQf////8BcTYCECAAIAVB/////wFxNgIMIAAgBEH/////AXE2AgggACADQf////8BcTYCBCAAIAJB/////wFxNgIAIAAgCUEddiALaiABQYCAwABxakH/////AXE2AiAL0QQBCn8jAEEwayIGJAACQCABQcABcSIKRQ0AIAZBCGogADYCACAKQcAARgRAQQEhBwwBCyAGIABBQGs2AgwgCkGAAUYEQEECIQcMAQsgBiAAQYABajYCEEGs28AAQSsgBkEQakGM3MAAQbjYwAAQ5gEACyAFQQV2IgkgByAHIAlLGyIIBEAgBkEIaiEJIANBBHIhCyAIQQV0IQxBACEDA0AgCSgCACEIIAZBKGoiDSACQRhqKQIANwMAIAZBIGoiDiACQRBqKQIANwMAIAZBGGoiDyACQQhqKQIANwMAIAYgAikCADcDECAGQRBqIAhBwABCACALECIgAyAEaiIIQRhqIA0pAwA3AAAgCEEQaiAOKQMANwAAIAhBCGogDykDADcAACAIIAYpAxA3AAAgCUEEaiEJIAwgA0EgaiIDRw0ACwsCQAJAAkAgAUE/cSICBEAgBSAHQQV0IgFJDQEgBSABayIDQR9NDQIgAkEgRw0DIAEgBGoiASAAIApqIgApAAA3AAAgAUEYaiAAQRhqKQAANwAAIAFBEGogAEEQaikAADcAACABQQhqIABBCGopAAA3AAAgB0EBaiEHCyAGQTBqJAAgBw8LIAEgBSAFQajYwAAQmAIAC0EAQSAgA0GI2MAAEJgCAAsjAEEwayIAJAAgAEEgNgIEIAAgAjYCACAAQQM2AgwgAEGE0sQANgIIIABCAjcCFCAAIABBBGqtQoCAgIDgCIQ3AyggACAArUKAgICA4AiENwMgIAAgAEEgajYCECAAQQhqQZjYwAAQvwIAC4cEAQV/IAAoAggiBCAAKAIARgRAIAAgBEEBQQFBARDJASAA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IAAoAjRBAEGAgIAIIAIbaiABKAAMQQh2aq0iCCAAKAIcIgJBBWytIgl+fCAAKAIwIAEoAAlBBnZqrSIKIAAoAiAiAUEFbK0iBH58IAMgB34gBSALfnwgBCAGfnwgCCARQQVsrSIMfnwgCSAKfnwgAyAEfiAFIAd+fCAGIAl+fCAIIBBBBWytfnwgCiAMfnwiCUIaiEL/////D4N8IgxCGohC/////w+DfCIOp0H///8fcTYCLCAAIAMgDX4gBSACrSIPfnwgBiALfnwgBCAIfnwgByAKfnwgDkIaiEL/////D4N8IgSnQf///x9xNgIwIAAgAyAPfiAFIAGtfnwgBiANfnwgByAIfnwgCiALfnwgBEIaiEL/////D4N8IgOnQf///x9xNgI0IAAgA0IaiKdBBWwgCadB////H3FqIgFB////H3E2AiQgACAMp0H///8fcSABQRp2ajYCKAvlAwIYfgF/IAExAAghCCABMQAHIQkgATEACSECIAExAAshCiABMQAKIQsgATEAFSEMIAExABQhDSABMQAWIQMgATEAGCEOIAExABchDyABMQAZIQQgATEAGyEQIAExABohESABMQAGIQUgATEABSESIAExAAQhEyABMQAPIRQgATEADiEVIAExAA0hFiABMQAMIQYgATEAHyEXIAExAB4hGCABMQAdIRkgATEAHCEHIAEoAAAhGiAAIAEoABAiAUH///8PcTYCFCAAIBpB////H3E2AgAgACAXQhKGQoCA8A+DIBlCAoYgB0IGiIQgGEIKhoSEPgIkIAAgFkIChiAGQgaIhCAVQgqGhCAUQhKGhD4CECAAIAVCFoZCgICADoMgGkEadq0gE0IGhoQgEkIOhoSEPgIEIAAgEEIMhiARQgSGhCAEQgSIhCAHQhSGhKdB////H3E2AiAgACAOQg2GIA9CBYaEIANCA4iEIARCFYaEp0H///8PcTYCHCAAIAFBGXatIAxCD4YgDUIHhoSEIANCF4aEp0H///8fcTYCGCAAIApCC4YgC0IDhoQgAkIFiIQgBkIThoSnQf///w9xNgIMIAAgCEINhiAJQgWGhCAFQgOIhCACQhWGhKdB////H3E2AggLqyQCE38CfiMAQTBrIhAkAAJAAkACQAJ/IAEoAgAiDQRAIAIoAgghCyACKAIEIQkgASgCBCEFAkADQCANQYwC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eHMgBiAFQQBKIAQgBkpzGwwBCyAEIAVqIgZBH3VBgICAgHhzIAYgBUEASCAEIAZKcxsLEKEBCyAHQSBqJAALsgMBB38jAEEwayIEJAACQAJAAkACQCABKAIEIgIEQCABKAIAIQYgAkEDcSEFAkAgAkEESQRAQQAhAgwBCyAGQRxqIQMgAkF8cSEIQQAhAgNAIAMoAgAgA0EIaygCACADQRBrKAIAIANBGGsoAgAgAmpqamohAiADQSBqIQMgCCAHQQRqIgdHDQALCyAFBEAgB0EDdCAGakEEaiEDA0AgAygCACACaiECIANBCGohAyAFQQFrIgUNAAsLIAEoAgxFDQIgAkEPSw0BIAYoAgQNAQwDC0EAIQIgASgCDEUNAgsgAkEAIAJBAEobQQF0IQILQQAhAyACQQBOBEAgAkUNAUEBIQMgAkEBEIEDIgUNAgsgAyACENsCAAtBASEFQQAhAgsgBEEANgIMIAQgBTYCCCAEIAI2AgQgBEEgaiABQRBqKQIANwMAIARBGGogAUEIaikCADcDACAEIAEpAgA3AxAgBEEEakHYrcQAIARBEGoQYEUEQCAAIAQpAgQ3AgAgAEEIaiAEQQxqKAIANgIAIARBMGokAA8LQcSsxABB1gAgBEEvakG0rMQAQZytxAAQ5gEAC+EDAgZ+Dn8gAigCJCEJIAEoAiQhCiACKAIgIQsgASgCICEMIAIoAgwhDSABKAIMIQ4gAigCHCEPIAEoAhwhECACKAIIIREgASgCCCESIAIoAgQhEyABKAIEIRQgAigCACEVIAEoAgAhFiAAIAEoAhggAigCGGtB8P///wNqrSABKAIUIAIoAhRrQfD///8Baq0gASgCECACKAIQa0Hw////A2qtIgNCGoh8IgZCGYh8IgSnQf///x9xNgIYIAAgEiARa0Hw////A2qtIBQgE2tB8P///wFqrSAWIBVrQdD9//8Daq0iB0IaiHwiCEIZiHwiBadB////H3E2AgggACAQIA9rQfD///8Baq0gBEIaiHwiBKdB////D3E2AhwgACAOIA1rQfD///8Baq0gBUIaiHwiBadB////D3E2AgwgACAMIAtrQfD///8Daq0gBEIZiHwiBKdB////H3E2AiAgACAGQv///w+DIANC////H4MgBUIZiHwiA0IaiHw+AhQgACADp0H///8fcTYCECAAIAogCWtB8P///wFqrSAEQhqIfCIDp0H///8PcTYCJCAAIAhC////D4MgA0IZiEITfiAHQv///x+DfCIDQhqIfD4CBCAAIAOnQf///x9xNgIAC8kDAQN/IAAoAgAiASgCqAEEQCABQQA2AqgBCyABKAKcECICBEAgASgCmBAhAANAIAAoAgAiAwRAIABBBGooAgAgA0EBEPoCCyAAQQxqIQAgAkEBayICDQALCyABKAKUECIABEAgASgCmBAgAEEMbEEEEPoCCyABKAKIECIAQYCAgIB4RiAARXJFBEAgASgCjBAgAEEBEPoCCyABKALwDyIABEAgASgC9A8gAEEBEPoCCyABKAL8DyIABEAgASgCgBAgAEEBEPoCCyABQZgPaiICEJEBAkAgASgCnA8iAEUNACAAIABBA3RBD2pBeHEiA2pBCWoiAEUNACACKAIAIANrIABBCBD6AgsgAUHID2oiAhCFAQJAIAEoAswPIgBFDQAgACAAQQN0QQ9qQXhxIgNqQQlqIgBFDQAgAigCACADayAAQQgQ+gILIAEoAqgQIgIEQCABKAKkECEAA0AgACgCACIDBEAgAEEEaigCACADQQEQ+gILIABBDGohACACQQFrIgINAAsLIAEoAqAQIgAEQCABKAKkECAAQQxsQQQQ+gILAkAgAUF/Rg0AIAEgASgCBEEBayIANgIEIAANACABQfARQQgQ+gILC+cCAQV/IwBB8AFrIgIkACACQaABaiIDIAFB0ABqEDMgAkHwAGogAkHAAWopAgA3AwAgAkHoAGogAkG4AWopAgA3AwAgAkHgAGogAkGwAWopAgA3AwAgAkHYAGogAkGoAWopAgA3AwAgAiACKQKgATcDUCACQZgBaiACQegBaikCADcDACACQZABaiACQeABaikCADcDACACQYgBaiACQdgBaikCADcDACACQYABaiACQdABaikCADcDACACIAIpAsgBNwN4IAMgAkHQAGoiBkEFEEwgAkEIaiIEIAMgAkH4AGoiBRA2IAUgASAEEDYgAyABQShqIAQQNiACQTBqIAMQRSAGIAUQRSACLQBQQQFxEOcCIQEgACACKQAwNwAAIABBCGogAkE4aikAADcAACAAQRBqIAJBQGspAAA3AAAgAiACLQBPIAFBB3RzOgBPIABBGGogAkHIAGopAAA3AAAgAkHwAWokAAuWAwEEfwJAAkACQAJAAkACQCAHIAhWBEAgByAIfSAIWA0DIAYgByAGfVQgByAGQgGGfSAIQgGGWnENAiAGIAhYDQYgByAGIAh9IgZ9IAZWDQYgAiADTw0BQQAgAyACQcDExAAQmAIACyAAQQA2AgAPCyABIANqIQwgASEKAkACQAJAA0AgAyAJRg0BIAlBAWohCSAKQQFrIgogA2oiCy0AAEE5Rg0ACyALIAstAABBAWo6AAAgAyAJa0EBaiIFIANNDQEgBSADIANB/LnEABCYAgALAkAgA0UEQEExIQkMAQsgAUExOgAAQTAhCSADQQFrIgpFDQAgAUEBakEwIAr8CwALIARBAWrBIgQgBcFMIAIgA01yDQEgDCAJOgAAIANBAWohAwwBCyAJQQFrIgVFDQAgC0EBakEwIAX8CwALIAIgA0kNAgwDCyACIANPDQJBACADIAJB0MTEABCYAgALIABBADYCAA8LQQAgAyACQbDExAAQmAIACyAAIAQ7AQggACADNgIEIAAgATYCAA8LIABBADYCAAuZAwECfwJAAkACQCAALQBoIgMEQCADQcEATw0DIAJBwAAgA2siBCACIARJGyIEBEAgACADaiABIAT8CgAACyAAIAAtAGggBGoiAzoAaCABIARqIQEgAiAEayICRQRAQQAhAgwCCyAAQUBrIABBwAAgACkDYCAALQBqIAAtAGlFchAiIABCADcDACAAQQA6AGggAEEIakIANwMAIABBEGpCADcDACAAQRhqQgA3AwAgAEEgakIANwMAIABBKGpCADcDACAAQTBqQgA3AwAgAEE4akIANwMAIAAgAC0AaUEBajoAaQtBACEDIAJBwQBJDQEgAEFAayEEIAAtAGkhAwNAIAQgAUHAACAAKQNgIAAtAGogA0H/AXFFchAiIAAgAC0AaUEBaiIDOgBpIAFBQGshASACQUBqIgJBwABLDQALIAAtAGghAwsgA0H/AXEiA0HBAE8NAQsgAkHAACADayIEIAIgBEkbIgIEQCAAIANqIAEgAvwKAAALIAAgAC0AaCACajoAaCAADwsgA0HAAEHAAEGU18AAEJgCAAuVAwEHfyAAIAEoAiAiAjoAHSAAIAEoAgAiBToAACAAIAJBEHY6AB8gACACQQh2OgAeIAAgASgCHCIGQRV2OgAcIAAgBkENdjoAGyAAIAZB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KAI8ISIgBigCHCEYIAYoAkQhGSABIAYoAiQgBigCTGo2AowOIAEgFSAXajYCiA4gASAYIBlqNgKEDiABIA0gEmo2AoAOIAEgISAiajYC/A0gASAKIAxqNgL4DSABIB8gIGo2AvQNIAEgAyAHajYC8A0gASAeICVqNgLsDSABIBYgHWo2AugNIAFBkA5qIgcgBkEoaiAGEHogAUHYDmogBkHwAGoiFSkCADcCACABQdAOaiAGQegAaiIXKQIANwIAIAFByA5qIAZB4ABqIhIpAgA3AgAgAUHADmogBkHYAGoiFikCADcCACABIAYpAlA3ArgOIAFBCGoiSiIDIAZB+ABqQdDjwAAQNiABQYAPaiABQShqKQIANwIAIAFB+A5qIAFBIGopAgA3AgAgAUHwDmogAUEYaikCADcCACABQegOaiABQRBqKQIANwIAIAEgASkCCDcC4A4gAyABQegNaiIDQaAB/AoAACABQagBaiInIANBoAH8CgAAIAFByAJqIjggA0GgAfwKAAAgAUHoA2oiQSADQaAB/AoAACABQYgFaiJFIANBoAH8CgAAIAFBqAZqIkcgA0GgAfwKAAAgAUHIB2oiSyADQaAB/AoAACABQegIaiJNIANBoAH8CgAAIAFBkA1qIgogECkCADcDACABQYgNaiIMIBQpAgA3AwAgAUGADWoiDSARKQIANwMAIAFB+AxqIhEgEykCADcDACABQaANaiITIBYpAgA3AwAgAUGoDWoiFCASKQIANwMAIAFBsA1qIhIgFykCADcDACABQbgNaiIXIBUpAgA3AwAgASAGKQIoNwPwDCABIAYpAlA3A5gNIAFB6AxqIA8pAgA3AwAgAUHgDGogDikCADcDACABQdgMaiAaKQIANwMAIAFB0AxqIAkpAgA3AwAgASAGKQIANwPIDCADIAFByAxqIhoQLCABQYgKaiIdIAMgAUHgDmoiBhA2IAFBsA9qIh4gByABQbgOaiIJEDYgAUHYD2oiDiAJIAYQNiABQagLaiIlIAMgBxA2IAFB0ApqIAFB0A9qIh8pAgA3AgAgAUHICmogAUHID2oiICkCADcCACABQcAKaiABQcAPaiIhKQIANwIAIAFBuApqIAFBuA9qIiIpAgA3AgAgAUHgCmogAUHgD2oiDykCADcCACABQegKaiABQegPaiIQKQIANwIAIAFB8ApqIAFB8A9qIhUpAgA3AgAgAUH4CmogAUH4D2oiFikCADcCACABIAEpArAPNwKwCiABIAEpAtgPNwLYCiABQaALaiABQcgLaikCADcCACABQZgLaiABQcALaikCADcCACABQZALaiABQbgLaikCADcCACABQYgLaiABQbALaikCADcCACABIAEpAqgLNwKACyADIB0gShA+IBogAyAGEDYgAUGID2oiGCAHIAkQNiAeIAkgBhA2IA4gAyAHEDYgCiABQagPaiIZKQIANwIAIAwgAUGgD2oiGykCADcCACANIAFBmA9qIhwpAgA3AgAgESABQZAPaiIjKQIANwIAIBMgIikCADcCACAUICEpAgA3AgAgEiAgKQIANwIAIBcgHykCADcCACABIAEpAogPNwLwDCABIAEpArAPNwKYDSABQeANaiIkIBYpAgA3AgAgAUHYDWoiJiAVKQIANwIAIAFB0A1qIjkgECkCADcCACABQcgNaiI6IA8pAgA3AgAgASABKQLYDzcCwA0gESgCACEoIA0oAgAhKSAMKAIAISogCigCACErIAEoAsgMISwgASgC8AwhLSABKALMDCEuIAEoAvQMIS8gASgC0AwhMCABKALUDCFCIAEoAvwMIUMgASgC2AwhMSABKALcDCEyIAEoAoQNITMgASgC4AwhNCABKALkDCE1IAEoAowNITYgASgC6AwhNyABIAEoAuwMIAEoApQNajYCzAsgASArIDdqNgLICyABIDUgNmo2AsQLIAEgKiA0ajYCwAsgASAyIDNqNgK8CyABICkgMWo2ArgLIAEgQiBDajYCtAsgASAoIDBqNgKwCyABIC4gL2o2AqwLIAEgLCAtajYCqAsgAUHQC2oiKCABQfAMaiIpIBoQeiABQZgMaiIqIBcpAgA3AgAgAUGQDGoiKyASKQIANwIAIAFBiAxqIiwgFCkCADcCACABQYAMaiItIBMpAgA3AgAgASABKQKYDTcC+AsgDiABQcANaiIuQdDjwAAQNiABQcAMaiIvIBYpAgA3AgAgAUG4DGoiMCAVKQIANwIAIAFBsAxqIkIgECkCADcCACABQagMaiJDIA8pAgA3AgAgASABKQLYDzcCoAwgJyAlQaAB/AoAACADIB0gJxA+IBogAyAGEDYgGCAHIAkQNiAeIAkgBhA2IA4gAyAHEDYgCiAZKQIANwIAIAwgGykCADcCACANIBwpAgA3AgAgESAjKQIANwIAIBMgIikCADcCACAUICEpAgA3AgAgEiAgKQIANwIAIBcgHykCADcCACABIAEpAogPNwLwDCABIAEpArAPNwKYDSAkIBYpAgA3AgAgJiAVKQIANwIAIDkgECkCADcCACA6IA8pAgA3AgAgASABKQLYDzcCwA0gESgCACEnIA0oAgAhMSAMKAIAITIgCigCACEzIAEoAsgMITQgASgC8AwhNSABKALMDCE2IAEoAvQMITcgASgC0AwhOyABKALUDCE8IAEoAvwMIT0gASgC2AwhPiABKALcDCE/IAEoAoQNIUAgASgC4AwhRCABKALkDCFGIAEoAowNIUggASgC6AwhTiABIAEoAuwMIAEoApQNajYCzAsgASAzIE5qNgLICyABIEYgSGo2AsQLIAEgMiBEajYCwAsgASA/IEBqNgK8CyABIDEgPmo2ArgLIAEgPCA9ajYCtAsgASAnIDtqNgKwCyABIDYgN2o2AqwLIAEgNCA1ajYCqAsgKCApIBoQeiAqIBcpAgA3AgAgKyASKQIANwIAICwgFCkCADcCACAtIBMpAgA3AgAgASABKQKYDTcC+AsgDiAuQdDjwAAQNiAvIBYpAgA3AgAgMCAVKQIANwIAIEIgECkCADcCACBDIA8pAgA3AgAgASABKQLYDzcCoAwgOCAlQaAB/AoAACADIB0gOBA+IBogAyAGEDYgGCAHIAkQNiAeIAkgBhA2IA4gAyAHEDYgCiAZKQIANwIAIAwgGykCADcCACANIBwpAgA3AgAgESAjKQIANwIAIBMgIikCADcCACAUICEpAgA3AgAgEiAgKQIANwIAIBcgHykCADcCACABIAEpAogPNwLwDCABIAEpArAPNwKYDSAkIBYpAgA3AgAgJiAVKQIANwIAIDkgECkCADcCACA6IA8pAgA3AgAgASABKQLYDzcCwA0gESgCACEnIA0oAgAhOCAMKAIAITEgCigCACEyIAEoAsgMITMgASgC8AwhNCABKALMDCE1IAEoAvQMITYgASgC0AwhNyABKALUDCE7IAEoAvwMITwgASgC2AwhPSABKALcDCE+IAEoAoQNIT8gASgC4AwhQCABKALkDCFEIAEoAowNIUYgASgC6AwhSCABIAEoAuwMIAEoApQNajYCzAsgASAyIEhqNgLICyABIEQgRmo2AsQLIAEgMSBAajYCwAsgASA+ID9qNgK8CyABIDggPWo2ArgLIAEgOyA8ajYCtAsgASAnIDdqNgKwCyABIDUgNmo2AqwLIAEgMyA0ajYCqAsgKCApIBoQeiAqIBcpAgA3AgAgKyASKQIANwIAICwgFCkCADcCACAtIBMpAgA3AgAgASABKQKYDTcC+AsgDiAuQdDjwAAQNiAvIBYpAgA3AgAgMCAVKQIANwIAIEIgECkCADcCACBDIA8pAgA3AgAgASABKQLYDzcCoAwgQSAlQaAB/AoAACADIB0gQRA+IBogAyAGEDYgGCAHIAkQNiAeIAkgBhA2IA4gAyAHEDYgCiAZKQIANwIAIAwgGykCADcCACANIBwpAgA3AgAgESAjKQIANwIAIBMgIikCADcCACAUICEpAgA3AgAgEiAgKQIANwIAIBcgHykCADcCACABIAEpAogPNwLwDCABIAEpArAPNwKYDSAkIBYpAgA3AgAgJiAVKQIANwIAIDkgECkCADcCACA6IA8pAgA3AgAgASABKQLYDzcCwA0gESgCACEnIA0oAgAhOCAMKAIAIUEgCigCACExIAEoAsgMITIgASgC8AwhMyABKALMDCE0IAEoAvQMITUgASgC0AwhNiABKALUDCE3IAEoAvwMITsgASgC2AwhPCABKALcDCE9IAEoAoQNIT4gASgC4AwhPyABKALkDCFAIAEoAowNIUQgASgC6AwhRiABIAEoAuwMIAEoApQNajYCzAsgASAxIEZqNgLICyABIEAgRGo2AsQLIAEgPyBBajYCwAsgASA9ID5qNgK8CyABIDggPGo2ArgLIAEgNyA7ajYCtAsgASAnIDZqNgKwCyABIDQgNWo2AqwLIAEgMiAzajYCqAsgKCApIBoQeiAqIBcpAgA3AgAgKyASKQIANwIAICwgFCkCADcCACAtIBMpAgA3AgAgASABKQKYDTcC+AsgDiAuQdDjwAAQNiAvIBYpAgA3AgAgMCAVKQIANwIAIEIgECkCADcCACBDIA8pAgA3AgAgASABKQLYDzcCoAwgRSAlQaAB/AoAACADIB0gRRA+IBogAyAGEDYgGCAHIAkQNiAeIAkgBhA2IA4gAyAHEDYgCiAZKQIANwIAIAwgGykCADcCACANIBwpAgA3AgAgESAjKQIANwIAIBMgIikCADcCACAUICEpAgA3AgAgEiAgKQIANwIAIBcgHykCADcCACABIAEpAogPNwLwDCABIAEpArAPNwKYDSAkIBYpAgA3AgAgJiAVKQIANwIAIDkgECkCADcCACA6IA8pAgA3AgAgASABKQLYDzcCwA0gESgCACEnIA0oAgAhOCAMKAIAIUEgCigCACFFIAEoAsgMITEgASgC8AwhMiABKALMDCEzIAEoAvQMITQgASgC0AwhNSABKALUDCE2IAEoAvwMITcgASgC2AwhOyABKALcDCE8IAEoAoQNIT0gASgC4AwhPiABKALkDCE/IAEoAowNIUAgASgC6AwhRCABIAEoAuwMIAEoApQNajYCzAsgASBEIEVqNgLICyABID8gQGo2AsQLIAEgPiBBajYCwAsgASA8ID1qNgK8CyABIDggO2o2ArgLIAEgNiA3ajYCtAsgASAnIDVqNgKwCyABIDMgNGo2AqwLIAEgMSAyajYCqAsgKCApIBoQeiAqIBcpAgA3AgAgKyASKQIANwIAICwgFCkCADcCACAtIBMpAgA3AgAgASABKQKYDTcC+AsgDiAuQdDjwAAQNiAvIBYpAgA3AgAgMCAVKQIANwIAIEIgECkCADcCACBDIA8pAgA3AgAgASABKQLYDzcCoAwgRyAlQaAB/AoAACADIB0gRxA+IBogAyAGEDYgGCAHIAkQNiAeIAkgBhA2IA4gAyAHEDYgCiAZKQIANwIAIAwgGykCADcCACANIBwpAgA3AgAgESAjKQIANwIAIBMgIikCADcCACAUICEpAgA3AgAgEiAgKQIANwIAIBcgHykCADcCACABIAEpAogPNwLwDCABIAEpArAPNwKYDSAkIBYpAgA3AgAgJiAVKQIANwIAIDkgECkCADcCACA6IA8pAgA3AgAgASABKQLYDzcCwA0gESgCACEnIA0oAgAhOCAMKAIAIUEgCigCACFFIAEoAsgMIUcgASgC8AwhMSABKALMDCEyIAEoAvQMITMgASgC0AwhNCABKALUDCE1IAEoAvwMITYgASgC2AwhNyABKALcDCE7IAEoAoQNITwgASgC4AwhPSABKALkDCE+IAEoAowNIT8gASgC6AwhQCABIAEoAuwMIAEoApQNajYCzAsgASBAIEVqNgLICyABID4gP2o2AsQLIAEgPSBBajYCwAsgASA7IDxqNgK8CyABIDcgOGo2ArgLIAEgNSA2ajYCtAsgASAnIDRqNgKwCyABIDIgM2o2AqwLIAEgMSBHajYCqAsgKCApIBoQeiAqIBcpAgA3AgAgKyASKQIANwIAICwgFCkCADcCACAtIBMpAgA3AgAgASABKQKYDTcC+AsgDiAuQdDjwAAQNiAvIBYpAgA3AgAgMCAVKQIANwIAIEIgECkCADcCACBDIA8pAgA3AgAgASABKQLYDzcCoAwgSyAlQaAB/AoAACADIB0gSxA+IBogAyAGEDYgGCAHIAkQNiAeIAkgBhA2IA4gAyAHEDYgCiAZKQIANwIAIAwgGykCADcCACANIBwpAgA3AgAgESAjKQIANwIAIBMgIikCADcCACAUICEpAgA3AgAgEiAgKQIANwIAIBcgHykCADcCACABIAEpAogPNwLwDCABIAEpArAPNwKYDSAkIBYpAgA3AgAgJiAVKQIANwIAIDkgECkCADcCACA6IA8pAgA3AgAgASABKQLYDzcCwA0gESgCACEDIA0oAgAhBiAMKAIAIQcgCigCACEJIAEoAsgMIQogASgC8AwhDCABKALMDCENIAEoAvQMIREgASgC0AwhHSABKALUDCEeIAEoAvwMIR8gASgC2AwhICABKALcDCEhIAEoAoQNISIgASgC4AwhGCABKALkDCEZIAEoAowNIRsgASgC6AwhHCABIAEoAuwMIAEoApQNajYCzAsgASAJIBxqNgLICyABIBkgG2o2AsQLIAEgByAYajYCwAsgASAhICJqNgK8CyABIAYgIGo2ArgLIAEgHiAfajYCtAsgASADIB1qNgKwCyABIA0gEWo2AqwLIAEgCiAMajYCqAsgKCApIBoQeiAqIBcpAgA3AgAgKyASKQIANwIAICwgFCkCADcCACAtIBMpAgA3AgAgASABKQKYDTcC+AsgDiAuQdDjwAAQNiAvIBYpAgA3AgAgMCAVKQIANwIAIEIgECkCADcCACBDIA8pAgA3AgAgASABKQLYDzcCoAwgTSAlQaAB/AoAACAEQYAEaiBKQYAK/AoAACABQYAQaiQAIARBoA5qQgA3AwAgBEGYDmpCADcDACAEQZAOakIANwMAIARBiA5qQgA3AwAgBEGwDmpB+OTAACkCACJPNwMAIARBuA5qQYDlwAApAgAiUDcDACAEQcAOakGI5cAAKQIA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KAKwASEZIAMoArQBIRsgAygCuAEhHCADKAK8ASEjIAMoAsABISQgAygCxAEhJiABQfAAaiADQbgCaikCADcCACABQegAaiADQbACaikCADcCACABQeAAaiADQagCaikCADcCACABQdgAaiADQaACaikCADcCACABIAMpApgCNwJQIAEgIiAmajYCnAEgASAhICRqNgKYASABICAgI2o2ApQBIAEgHCAfajYCkAEgASAbICVqNgKMASABIBkgHmo2AogBIAEgGCAdajYChAEgASAQIBZqNgKAASABIA8gFWo2AnwgASAGIA5qNgJ4IANBwAJqJAAgBEH4DmogAUGgAfwKAAALAkACQAJAAkAgBEGAAmogAmosAAAiAUEASiABQQBIa0H/AXEOAgMBAAsgBEHYEmogBEH4DmoiAyAUEDYgBEH4E2ogEiATEDYgBEGYEGogEyAUEDYgBEG4EWogAyASEDYgCUEgaiAEQZgUaikCADcCACAJQRhqIARBkBRqKQIANwIAIAlBEGogBEGIFGopAgA3AgAgCUEIaiAEQYAUaikCADcCACAJIAQpAvgTNwIAIAcgBCkCmBA3AgAgB0EIaiAEQaAQaikCADcCACAHQRBqIARBqBBqKQIANwIAIAdBGGogBEGwEGopAgA3AgAgB0EgaiAEQbgQaikCADcCACAKQSBqIARB2BFqKQIANwIAIApBGGogBEHQEWopAgA3AgAgCkEQaiAEQcgRaikCADcCACAKQQhqIARBwBFqKQIANwIAIAogBCkCuBE3AgBBACABa8AiA0EBdiEBIANBAE4NASABQcAAQaihwQAQ8gEACyAEQdgSaiAEQfgOaiIDIBQQNiAEQfgTaiASIBMQNiAEQZgQaiATIBQQNiAEQbgRaiADIBIQNiAJQSBqIARBmBRqKQIANwIAIAlBGGogBEGQFGopAgA3AgAgCUEQaiAEQYgUaikCADcCACAJQQhqIARBgBRqKQIANwIAIAkgBCkC+BM3AgAgByAEKQKYEDcCACAHQQhqIARBoBBqKQIANwIAIAdBEGogBEGoEGopAgA3AgAgB0EYaiAEQbAQaikCADcCACAHQSBqIARBuBBqKQIANwIAIApBIGogBEHYEWopAgA3AgAgCkEYaiAEQdARaikCADcCACAKQRBqIARByBFqKQIANwIAIApBCGogBEHAEWopAgA3AgAgCiAEKQK4ETcCACABQQF2IQMgAUEASARAIANBwABBqKHBABDyAQALIARBmBBqIgEgA0H4AGxBmOXAAGpB+AD8CgAAIARBuBFqIgMgBEHYEmogARBAIARB+A5qIANBoAH8CgAADAELIARBmBBqIgYgAUH4AGxBmOXAAGpB+AD8CgAAIwBBoAJrIgEkACAEQdgSaiIDKAIAIQ4gAygCKCEPIAMoAgQhECADKAIsIRUgAygCCCEWIAMoAjAhHSADKAIMIR4gAygCNCElIAMoAhAhHyADKAI4ISAgAygCFCEhIAMoAjwhIiADKAIYIRggAygCQCEZIAMoAhwhGyADKAJEIRwgAygCICEjIAMoAkghJCABIAMoAiQgAygCTGo2AiwgASAjICRqNgIoIAEgGyAcajYCJCABIBggGWo2AiAgASAhICJqNgIcIAEgHyAgajYCGCABIB4gJWo2AhQgASAWIB1qNgIQIAEgECAVajYCDCABIA4gD2o2AgggAUEwaiIOIANBKGogAxB6IAFB2ABqIg8gAUEIaiAGQShqEDYgAUGAAWoiECAOIAYQNiABQagBaiIOIANB+ABqIAZB0ABqEDYgASADKAJQQQF0IgY2AtABIAEgAygCVEEBdCIVNgLUASABIAMoAlhBAXQiFjYC2AEgASADKAJcQQF0Ih02AtwBIAEgAygCYEEBdCIeNgLgASABIAMoAmRBAXQiJTYC5AEgASADKAJoQQF0Ih82AugBIAEgAygCbEEBdCIgNgLsASABIAMoAnBBAXQiITYC8AEgASADKAJ0QQF0IiI2AvQBIARBuBFqIgMgDyAQEHogASgCfCEPIAEoAqQBIRAgASgCgAEhGCABKAJYIRkgASgChAEhGyABKAJcIRwgASgCiAEhIyABKAJgISQgASgCjAEhJiABKAJkITkgASgCkAEhOiABKAJoISggASgClAEhKSABKAJsISogASgCmAEhKyABKAJwISwgASgCnAEhLSABKAJ0IS4gASgCoAEhLyABKAJ4ITAgAUH4AWogAUHQAWogDhB6IAMgDyAQajYCTCADIC8gMGo2AkggAyAtIC5qNgJEIAMgKyAsajYCQCADICkgKmo2AjwgAyAoIDpqNgI4IAMgJiA5ajYCNCADICMgJGo2AjAgAyAbIBxqNgIsIAMgGCAZajYCKCABKAKoASEOIAEoAqwBIQ8gASgCsAEhECABKAK0ASEYIAEoArgBIRkgASgCvAEhGyABKALAASEcIAEoAsQBISMgASgCyAEhJCABKALMASEmIANB8ABqIAFBmAJqKQIANwIAIANB6ABqIAFBkAJqKQIANwIAIANB4ABqIAFBiAJqKQIANwIAIANB2ABqIAFBgAJqKQIANwIAIAMgASkC+AE3AlAgAyAiICZqNgKcASADICEgJGo2ApgBIAMgICAjajYClAEgAyAcIB9qNgKQASADIBsgJWo2AowBIAMgGSAeajYCiAEgAyAYIB1qNgKEASADIBAgFmo2AoABIAMgDyAVajYCfCADIAYgDmo2AnggAUGgAmokACAEQfgOaiADQaAB/AoAAAsgBEHYEmoiASAEQfgOaiAUEDYgBEGYEGogEiATEDYgBEG4EWogEyAUEDYgCUEgaiAEQbgQaikCADcCACAJQRhqIARBsBBqKQIANwIAIAlBEGogBEGoEGopAgA3AgAgCUEIaiAEQaAQaikCADcCACAJIAQpApgQNwIAIAcgBCkCuBE3AgAgB0EIaiAEQcARaikCADcCACAHQRBqIARByBFqKQIANwIAIAdBGGogBEHQEWopAgA3AgAgB0EgaiAEQdgRaikCADcCACAEQYAOaiABQfgA/AoAACACBEAgAkEBayECDAELCyAIIARBgA5qIgEgFxA2IARBuBFqIBogFxA2IARB2BJqIgIgFxBQIAQpA6ATIVIgBCkDmBMhUSAEKQPwEiFTIAQpA5ATIVQgBCkD6BIhVSAEKQPgEiFWIAQpA9gSIU8gBCkDiBMhVyAEKQOAEyFYIAQpA/gSIVAgAiABIBoQNiAIQcgAaiAEQdgRaikCADcCACAIQUBrIARB0BFqKQIANwIAIAhBOGogBEHIEWopAgA3AgAgCEEwaiAEQcARaikCADcCACAIIAQpArgRNwIoIAggVyBYIFBCGoh8IlhCGYh8IlenQf///x9xNgJoIAggVSBWIE9CGoh8IlZCGYh8IlWnQf///x9xNgJYIAggVCBXQhqIfCJUp0H///8PcTYCbCAIIFMgVUIaiHwiU6dB////D3E2AlwgCCBRIFRCGYh8IlGnQf///x9xNgJwIAggWEL///8PgyBQQv///x+DIFNCGYh8IlBCGoh8PgJkIAggUKdB////H3E2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IQUDQCABIARqLQAAQS5GBEAgBCEDDAMLIAIgBEEBaiIERw0ACwtBACEFCyAHIAM2AgQgByAFNgIAIAYoAghBAUYhAwwBCyABLQAAQS5GIgMgAkEBRnINACABLQABQS5GIgMgAkECRnINACABLQACQS5GIgMgAkEDRnINACABLQADQS5GIgMgAkEERnINACABLQAEQS5GIgMgAkEFRnINACABLQAFQS5GIgMgAkEGRnINACABLQAGQS5GIQMLIAAgAyAALQAEcjoABCAAKAIAIAEgAhDpAiAGQRBqJAAL3wEBA38gAC0AAEEBRwRAIAAoAgQhBiAALQABQQFHBEAgBigCACIEKAIAIAQoAggiBUYEQCAEIAVBAUEBQQEQyQEgBCgCCCEFCyAEIAVBAWo2AgggBCgCBCAFakEsOgAACyAAQQI6AAEgBigCACABIAIQaiADKAIIIQEgAygCBCECIAYoAgAiACgCACAAKAIIIgNGBEAgACADQQFBAUEBEMkBIAAoAgghAwsgACADQQFqNgIIIAAoAgQgA2pBOjoAACAGKAIAIAIgARBqQQAPC0GkpMAAQShBzKTAABCZAgAL8gEBAn8jAEEwayICJAACQCAAKQMAQv///////////wCDQoCAgICAgID4/wBaBEAgAkEBNgIUIAJBsKDEADYCECACQgE3AhwgAiAArUKAgICAgBKENwMoIAIgAkEoajYCGCABKAIAIAEoAgQgAkEQahBgIQMMAQsgAkEAOgAMIAIgATYCCEEBIQMgAkEBNgIUIAJBsKDEADYCECACQgE3AhwgAiAArUKAgICAgBKENwMoIAIgAkEoajYCGCACQQhqQbygxAAgAkEQahBgDQAgAi0ADEUEQCABQbigxABBAhDpAg0BC0EAIQMLIAJBMGokACADC+EBAQN/IwBBkAFrIgIkACABKQOQAVAEQCACIAEQMCACQYgBaiIBIAJB2ABqKQMANwMAIAJBgAFqIgMgAkHQAGopAwA3AwAgAkH4AGoiBCACQcgAaikDADcDACACIAIpA0A3A3AgAkHwAGogAiACLQBoQgAgAi0AaUEIchAiIAAgASkDADcAGCAAIAMpAwA3ABAgACAEKQMANwAIIAAgAikDcDcAACACQZABaiQADwsgAkIANwIMIAJCgYCAgMAANwIEIAJBzNnAADYCACABQZABakGI18AAIAJBnNvAABCnAgAL5wEAIAAQwgEgAEEAOgAgIABBADoAISAAQQA6ACIgAEEAOgAjIABBADoAJCAAQQA6ACUgAEEAOgAmIABBADoAJyAAQQA6ACggAEEAOgApIABBADoAKiAAQQA6ACsgAEEAOgAsIABBADoALSAAQQA6AC4gAEEAOgAvIABBADoAMCAAQQA6ADEgAEEAOgAyIABBADoAMyAAQQA6ADQgAEEAOgA1IABBADoANiAAQQA6ADcgAEEAOgA4IABBADoAOSAAQQA6ADogAEEAOgA7IABBADoAPCAAQQA6AD0gAEEAOgA+IABBADoAPwvOAgEDfyMAQTBrIgMkACADQQxqIAEgAhBPAkACQCADKAIMQQFGBEAgAyACNgIgIAMgATYCHCADQQY6ABgjAEFAaiIBJAAgAUHguMAANgIEIAEgA0EvajYCACABQShqIANBGGoiAkEIaikDADcDACABIAIpAwA3AyAgAUECNgIMIAFBmLjDADYCCCABQgI3AhQgASABrUKAgICAgBCENwM4IAEgAUEgaq1CgICAgJAQhDcDMCABIAFBMGo2AhAgAUEIahCyASECIAFBQGskACAAQYCAgIB4NgIAIAAgAjYCBAwBC0EAIQEgAygCFCICQQBIDQEgAygCECEFAkAgAkUEQEEBIQQMAQtBASEBIAJBARCBAyIERQ0CCyACBEAgBCAFIAL8CgAACyAAIAI2AgggACAENgIEIAAgAjYCAAsgA0EwaiQADwsgASACENsCAAviAQAgAEEAOgAAIABBADoAASAAQQA6AAIgAEEAOgADIABBADoABCAAQQA6AAUgAEEAOgAGIABBADoAByAAQQA6AAggAEEAOgAJIABBADoACiAAQQA6AAsgAEEAOgAMIABBADoADSAAQQA6AA4gAEEAOgAPIABBADoAECAAQQA6ABEgAEEAOgASIABBADoAEyAAQQA6ABQgAEEAOgAVIABBADoAFiAAQQA6ABcgAEEAOgAYIABBADoAGSAAQQA6ABogAEEAOgAbIABBADoAHCAAQQA6AB0gAEEAOgAeIABBADoAHwuCAgAgAEEAOgDAASAAQQA6AMEBIABBADoAwgEgAEEAOgDDASAAQQA6AMQBIABBADoAxQEgAEEAOgDGASAAQQA6AMcBIABBADoAyAEgAEEAOgDJASAA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aikAADcDACAUQTBqIAFBEGopAAA3AwAgFEEoaiABQQhqKQAANwMAIBQgASkAADcDICMAQSBrIi0kACAUQSBqIgEgAS0AH0E/cUHAAHI6AB8gASABLQAAQfgBcToAACAtQQhqIAFBCGopAAA3AwAgLUEQaiABQRBqKQAANwMAIC1BGGogAUEYaikAADcDACAtIAEpAAA3AwAgACECQQAhASMAQaADayIDJAAgA0EIaiAUEG8gA0HQAGpB2JHDACkCACI3NwMAIANByABqQdCRwwApAgAiOTcDACADQUBrQciRwwApAgAiODcDACADQThqQcCRwwApAgAiOjcDACADQeAAakIANwMAIANB6ABqQgA3AwAgA0HwAGpCADcDACADQfgAakIANwMAIANBuJHDACkCACI7NwMwIANCADcDWCADQaABaiADQShqKQIANwMAIANBmAFqIANBIGopAgA3AwAgA0GQAWogA0EYaikCADcDACADQYgBaiADQRBqKQIANwMAIANBsAFqIDo3AwAgA0G4AWogODcDACADQcABaiA5NwMAIANByAFqIDc3AwAgAyADKQIINwOAASADIDs3A6gBIANBADoA1wEgA0EBNgLcAiADQoCAgICAIDcC1AIgAyAtNgLQAiADQdgAaiEvQQEhBgJAAkADQAJAAkAgBkUEQCADKALYAiIAIAMoAtQCTQ0CIAMgAEEBayIENgLYAiAEQQN2IQUgAEGBAk8NBCADKALQAiAFai0AACAEQQdxdkEBcSEADAELIANBADYC3AICf0EAIQAgA0HQAmoiBCgCBCIHIAQoAggiBSAFIAdLGyAFayEVAkACQAJAA0BBAiEIIAAgFUYNASAEIAAgBWoiE0EBazYCCCATQYECTw0CIAYgAEEBayIAag0ACyAHIAAgBWoiAE8NACAEIABBAWsiBTYCCCAFQQN2IQYgAEGBAk8NAiAEKAIAIAZqLQAAIAVBB3F2QQFxIQgLIAgMAgsgE0EBa0EDdkEgQYiSwwAQ8gEACyAGQSBBiJLDABDyAQALQf8BcSIAQQJGDQELIAAgAXMQ5wIhASADKAKAASEEIAMoAjAhBSADKAKEASEGIAMoAjQhByADKAKIASEIIAMoAjghEyADKAKMASEVIAMoAjwhICADKAKQASEhIAMoAkAhIiADKAKUASEWIAMoAkQhIyAD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KQOIBSA9QhqIfCI9Qv///w+DID5CGoh8pyILNgLMASABIDdC////H4MgASkDmAUgASkDkAUgPUIZiHwiN0IaiHwiPUIZiHwiPqdB////H3EiDDYC2AEgASA5Qv///w+DID5CGoh8pyINNgLcASABIDenQf///x9xIg42AtABIAEgPadB////D3EiDzYC1AEgASA4p0H///8fcSIQNgLgASABIDqnQf///w9xIhE2AuQBIAEgO6dB////H3EiEjYC6AEgASA8p0H///8PcSIaNgLsASABQfABaiIIIAFBoAFqIhsgAUHIAWoiHBB6IAFBmAJqIh0gASAJEDYgAUHAAmoiCSAHIAFB0ABqEDYgASgCmAIhByABKALAAiEeIAEoApwCIR8gASgCxAIhJiABKAKgAiEnIAEoAsgCISggASgCpAIhKSABKALMAiEqIAEoAqgCISsgASgC0AIhLCABKAKsAiEuIAEoAtQCITAgASgCsAIhMSABKALYAiEyIAEoArQCITMgASgC3AIhNCABKAK4AiE1IAEoAuACITYgASABKALkAiABKAK8Amo2AowDIAEgNSA2ajYCiAMgASAzIDRqNgKEAyABIDEgMmo2AoADIAEgLiAwajYC/AIgASArICxqNgL4AiABICkgKmo2AvQCIAEgJyAoajYC8AIgASAfICZqNgLsAiABIAcgHmo2AugCIAFBkANqIgcgHSAJEHogBiABQegCahBQIAEpA5gFITggASkDkAUhOiABKQOIBSE7IAEpA4AFITcgASkDyAUhPCABKQPABSE9IAEpA7gFIT4gASkDsAUhQSABKQOoBSFCIAEpA6AFITkgBiAHEFAgASABKQOwBSABKQOoBSABKQOgBSI/QhqIfCJEQhmIfCJAp0H///8fcTYC0AMgASABKQOQBSABKQOIBSABKQOABSJFQhqIfCJGQhmIfCJDp0H///8fcTYCwAMgASABKQO4BSBAQhqIfCJAp0H///8PcTYC1AMgASABKQOYBSBDQhqIfCJDp0H///8PcTYCxAMgASABKQPABSBAQhmIfCJAp0H///8fcTYC2AMgASBEQv///w+DID9C////H4MgQ0IZiHwiP0IaiHw+AswDIAEgP6dB////H3E2AsgDIAEgASkDyAUgQEIaiHwiP6dB////D3E2AtwDIAEgRkL///8PgyA/QhmIQhN+IEVC////H4N8Ij9CGoh8PgK8AyABID+nQf///x9xNgK4AyABQeADakHgkcMAIAgQNiABQYgEaiAbIBwQNiABIAEoAoQEIBpqNgKkBSABIAEoAoAEIBJqNgKgBSABIAEoAvwDIBFqNgKcBSABIAEoAvgDIBBqNgKYBSABIAEoAvQDIA1qNgKUBSABIAEoAvADIAxqNgKQBSABIAEoAuwDIA9qNgKMBSABIAEoAugDIA5qNgKIBSABIAEoAuQDIAtqNgKEBSABIAEoAuADIApqNgKABSABQbAEaiAIIAYQNiABQdgEaiADQQhqIAFBuANqEDYgJSABQagEaikCADcCACAjIAFBoARqKQIANwIAICEgAUGYBGopAgA3AgAgFSABQZAEaikCADcCACAFIAEpAogENwIAIAUgASkCsAQ3AiggEyABQbgEaikCADcCACAgIAFBwARqKQIANwIAICIgAUHIBGopAgA3AgAgJCABQdAEaikCADcCACAEIDwgPSA+IEEgQiA5QhqIfCJCQhmIfCJBQhqIfCI+QhmIfCI9QhqIfCI8p0H///8PcTYCJCAEID2nQf///x9xNgIgIAQgPqdB////D3E2AhwgBCBBp0H///8fcTYCGCAEIEJC////D4MgOUL///8fgyA4IDogOyA3QhqIfCI5QhmIfCI6QhqIfCI4QhmIfCI7QhqIfD4CFCAEIDunQf///x9xNgIQIAQgOKdB////D3E2AgwgBCA6p0H///8fcTYCCCAEIDlC////D4MgPEIZiEITfiA3Qv///x+DfCI3QhqIfD4CBCAEIDenQf///x9xNgIAIAQgASkC2AQ3AiggFiABQeAEaikCADcCACAXIAFB6ARqKQIANwIAIBggAUHwBGopAgA3AgAgGSABQfgEaikCADcCACABQdAFaiQAIAMgADoA1wEgAygC3AIhBiAAIQEMAQsLIAEQ5wIhACADKAKAASEBIAMoAjAhBCADKAKEASEFIAMoAjQhBiADKAKIASEHIAMoAjghCCADKAKMASETIAMoAjwhFSADKAKQASEgIAMoAkAhISADKAKUASEiIAMoAkQhFiADKAKYASEjIAMoAkghFyADKAKcASEkIAMoAkwhGCADKAKgASElIAMoAlAhCSADKAKkASEZIAMoAlQhCiADKAKoASELIAMoAlghDCADKAKsASENIAMoAlwhDiADKAKwASEPIAMoAmAhECADKAK0ASERIAMoAmQhEiADKAK4ASEaIAMoAmghGyADKAK8ASEcIAMoAmwhHSADKALAASEeIAMoAnAhHyADKALEASEmIAMoAnQhJyADKALIASEoIAMoAnghKSADQQAgAEH/AXFrIgAgAygCzAEiKiADKAJ8IitzcSIsICtzNgJ8IAMgKSAoIClzIABxIitzNgJ4IAMgJyAmICdzIABxIilzNgJ0IAMgHyAeIB9zIABxIidzNgJwIAMgHSAcIB1zIABxIh9zNgJsIAMgGyAaIBtzIABxIh1zNgJoIAMgEiARIBJzIABxIhtzNgJkIAMgECAPIBBzIABxIhJzNgJgIAMgDiANIA5zIABxIhBzNgJcIAMgDCALIAxzIABxIg5zNgJYIAMgCiAKIBlzIABxIgxzNgJUIAMgCSAJICVzIABxIgpzNgJQIAMgGCAYICRzIABxIglzNgJMIAMgFyAXICNzIABxIhhzNgJIIAMgFiAWICJzIABxIhdzNgJEIAMgISAgICFzIABxIhZzNgJAIAMgFSATIBVzIABxIiFzNgI8IAMgCCAHIAhzIABxIhVzNgI4IAMgBiAFIAZzIABxIghzNgI0IAMgBCABIARzIABxIgBzNgIwIAMgKiAsczYCzAEgAyAoICtzNgLIASADICYgKXM2AsQBIAMgHiAnczYCwAEgAyAcIB9zNgK8ASADIBogHXM2ArgBIAMgESAbczYCtAEgAyAPIBJzNgKwASADIA0gEHM2AqwBIAMgCyAOczYCqAEgAyAMIBlzNgKkASADIAogJXM2AqABIAMgCSAkczYCnAEgAyAYICNzNgKYASADIBcgInM2ApQBIAMgFiAgczYCkAEgAyATICFzNgKMASADIAcgFXM2AogBIAMgBSAIczYChAEgAyAAIAFzNgKAASADQQA6ANcBIANB0AJqIgAgLxAzIANBoAJqIANB8AJqKQIANwMAIANBmAJqIANB6AJqKQIANwMAIANBkAJqIANB4AJqKQIANwMAIANBiAJqIANB2AJqKQIANwMAIAMgAykC0AI3A4ACIANByAJqIANBmANqKQIANwMAIANBwAJqIANBkANqKQIANwMAIANBuAJqIANBiANqKQIANwMAIANBsAJqIANBgANqKQIANwMAIAMgAykC+AI3A6gCIAAgA0GAAmpBBRBMIANB2AFqIgEgACADQagCahA2IAAgA0EwaiABEDYgAiAAEEUgA0GgA2okAAwBCyAFQSBBiJLDABDyAQALIC1BIGokACAUQUBrJAALigEBAX8jAEEQayIDJAAgAiABIAJqIgFLBEBBAEEAENsCAAsgA0EEaiAAKAIAIgIgACgCBEEIIAEgAkEBdCICIAEgAksbIgEgAUEITRsiAUEBQQEQxgEgAygCBEEBRgRAIAMoAgggAygCDBDbAgALIAMoAgghAiAAIAE2AgAgACACNgIEIANBEGokAAumAQICfgF/IwBBEGsiAyQAIAAgA0EIaq0iAUKml8SJDX5CIIkgAUKs6/7GCX6FIgGnQdMAc60iAkKs6/7GCX4gAUIgiCIBQqaXxIkNfoUgAkKml8SJDX4gAUKs6/7GCX6FQiCJhSIBp0GI5MQAc60iAkKs6/7GCX4gAUIgiCIBQqaXxIkNfoUgAkKml8SJDX4gAUKs6/7GCX6FQiCJhRBbIANBEGokAAukAQECfyMAQTBrIgIkAEEBIQMCQCABQZiewwBBGxDpAg0AAkAgACgCAARAIAIgADYCDCACQQI2AhQgAkG8nsMANgIQIAJCATcCHCACIAJBDGqtQoCAgIDQD4Q3AyggAiACQShqNgIYIAEoAgAgASgCBCACQRBqEGBFDQEMAgsgAUHMnsMAQQQQ6QINAQsgAUHQnsMAQQIQ6QIhAwsgAkEwaiQAIAML1g0DDX8BfgFvIwBBMGsiByQAIAAhCUEgIQgjAEEQayIMJABBvOTEAC0AAEEBRwRAAkAjAEEwayIDJAAgAwJ/IwBBIGsiASQAAkACQAJAQcDkxAAtAAAEQEHE5MQAKAIAIQAMAQtB3OPEACgCACEAQdzjxABBADYCACAARQ0BIAARCQAhAEHA5MQALQAADQJBxOTEACAANgIAQcDkxABBAToAAAsgABD5AiABQSBqJAAMAgsgAUEANgIYIAFBATYCDCABQbSbwwA2AgggAUIENwIQIAFBCGpBvJvDABC/AgALIABBgwFLBEAgABD/AQsgAUEANgIYIAFBATYCDCABQdybwwA2AgggAUIENwIQIAFBCGpB5JvDABC/AgALIgs2AihBASEEIAslARAEIQ8QjwEiAiAPJgECQAJAIAIQpANBAUYEQCACIQAMAQsgCyUBEAUhDxCPASIFIA8mAQJAAkACQAJAIAUQpANBAUcNACAFJQEQBiEPEI8BIgYgDyYBIAYQpANBAUYEQCAGJQEQByEPEI8BIgEgDyYBIAElARAIIQAgAUGEAU8EQCABEP8BCyAGQYQBTwRAIAYQ/wELIAVBgwFNDQIgBRD/AQwCCyAGQYQBSQ0AIAYQ/wELIAVBhAFJDQEgBRD/AQwBCyAAQQFHDQAQCSEPEI8BIgEgDyYBQczkxAAoAgAhAEHI5MQAKAIAIQRByOTEAEIANwIAAkAgBEEBRwRAIAElARAKQQFGDQEgASEAC0ECIQRCjoCAgAghDiAAQYQBSQ0CIAAQ/wEMAgsgAyABNgIsIANB7JnDAEEGEOICIg02AhAgA0EsaigCACUBIANBKGooAgAlASADQRBqKAIAJQEQGyEPEI8BIgUgDyYBQczkxAAoAgAhBkHI5MQAKAIAIQBByOTEAEIANwIAIANBCGoiBCAGIAUgAEEBRiIAGzYCBCAEIAA2AgAgAygCDCEAAkAgAygCCEEBcUUEQCAArSEOQQAhBAwBC0ECIQRCjICAgAghDiAAQYQBSQ0AIAAQ/wELIA1BhAFPBEAgDRD/AQsgAUGEAUkNASABEP8BDAELIAslARALIQ8QjwEiACAPJgEgABCkA0EBRgRAIAJBhAFJDQIgAhD/AQwCC0ECIQRCh4CAgAghDiAAQYQBSQ0AIAAQ/wELIAJBhAFPBEAgAhD/AQsMAQtBgAIQEyEPEI8BIgEgDyYBIACtIAGtQiCGhCEOCyALQYQBTwRAIAsQ/wELAkACQAJAQbzkxAAtAABBAWsOAgACAQtBvOTEAEECOgAAQbDkxAAoAgAiAUECRg0AQbTkxAAoAgAhAAJAIAFFBEAgAEGDAUsNAQwCCyAAQYQBTwRAIAAQ/wELQbjkxAAoAgAiAEGEAUkNAQsgABD/AQtBvOTEAEEBOgAAQbTkxAAgDjcCAEGw5MQAIAQ2AgAgA0EwaiQADAELIANBADYCICADQQE2AhQgA0H0k8MANgIQIANCBDcCGCADQRBqQfyTwwAQvwIACwsCQEGw5MQAKAIAIgBBAkYEQEG05MQAKAIAIQoMAQsgAEEBcUUEQEG05MQAKAIAIQEDQCAIRQ0CEKUDIgYQ5AIiAiUBIAlB/////wcgCCAIQf////8HTxsiBBARIQ8QjwEiACAPJgEgBkGEAU8EQCAGEP8BCyACQYQBTwRAIAIQ/wELIAElASAAJQEgABD/ARAMQczkxAAoAgAhAkHI5MQAKAIAQcjkxABCADcCACAIIARrIQggBCAJaiEJQQFHDQALQY2AgIB4IQogAkGEAUkNASACEP8BDAELQbTkxAAoAgAhAQJAA0BBuOTEACgCACUBQQBBgAIgCCAIQYACTxsiBBAUIQ8QjwEiBSAPJgEgDCAFNgIMIAElASAFJQEQDUHM5MQAKAIAIQJByOTEACgCAEHI5MQAQgA3AgBBAUYNASAIIARrIQgQpQMiAhDkAiIAJQEQDyEPEI8BIgYgDyYBIABBhAFPBEAgABD/AQsgBiUBIAxBDGooAgAlASAJEBIgBkGEAU8EQCAGEP8BCyACQYQBTwRAIAIQ/wELIAVBhAFPBEAgBRD/AQsgBCAJaiEJIAgNAAsMAQsgAkGEAU8EQCACEP8BCyAFQYQBTwRAIAUQ/wELQYiAgIB4IQoLIAxBEGokAAJAIAoEQEEEQQQQgQMiAEUNASAAIAo2AgAgB0GAk8MANgIMIAcgADYCCCAHQQE2AhQgB0HYksMANgIQIAdCATcCHCAHIAdBCGqtQoCAgIDgC4Q3AyggByAHQShqNgIYIAdBEGpB4JLDABC/AgALIAdBMGokAA8LQQRBBBCaAwAL2QIBBH8jAEEQayICJAACfwJAAkACQEEBIAAoAgAiACgCACIDQYCAxABrIANB///DAE0bQQFrDgIBAgALIAFBgM/AAEEOEOkCDAILIAIgAEEEajYCCCABQbDPwABBEEHAz8AAQQkgAEGQz8AAQcnPwABBBSACQQhqQaDPwAAQyAEMAQsgAiAAQQRqNgIMIwBBEGsiACQAIAEoAgBBzs/AAEERIAEoAgQoAgwRAQAhAyAAQQA6AA0gACADOgAMIAAgATYCCCAAQQhqQcnPwABBBSACQQxqQaDPwAAQnwEhAyAALQANIgQgAC0ADCIFciEBAkAgBUEBcSAEQQFHcg0AIAMoAgAiAS0ACkGAAXFFBEAgASgCAEG9tsQAQQIgASgCBCgCDBEBACEBDAELIAEoAgBBvLbEAEEBIAEoAgQoAgwRAQAhAQsgAEEQaiQAIAFBAXELIAJBEGokAAuJAQEBfyMAQUBqIgMkACADIAI2AgQgAyABNgIAIANBKGogAEEIaikDADcDACADIAApAwA3AyAgA0ECNgIMIANB+LfDADYCCCADQgI3AhQgAyADrUKAgICAgBCENwM4IAMgA0Egaq1CgICAgJAQhDcDMCADIANBMGo2AhAgA0EIahCyASADQUBrJAALjQEBBH8jAEEQayICJAACf0EBIAEoAgAiA0EnIAEoAgQiBSgCECIBEQAADQAaIAIgACgCAEGBAhBSAkAgAi0ADSIAQYEBTwRAIAMgAigCACABEQAARQ0BQQEMAgsgAyACIAItAAwiBGogACAEayAFKAIMEQEARQ0AQQEMAQsgA0EnIAERAAALIAJBEGokAAuGAQEBfyMAQRBrIgMkACACIAEgAmoiAUsEQEEAQQAQ2wIACyADQQRqIAAoAgAiAiAAKAIEQQggASACQQF0IgIgASACSxsiASABQQhNGyIBEN8BIAMoAgRBAUYEQCADKAIIIAMoAgwQ2wIACyADKAIIIQIgACABNgIAIAAgAjYCBCADQRBqJAALpQEBAX8jAEEQayICJAACfwJAAkACQAJAAkAgACgCAEEBaw4EAQIDBAALIAFBqN7AAEESEOkCDAQLIAFBut7AAEEMEOkCDAMLIAIgAEEEajYCDCABQejewABBC0Hz3sAAQQQgAEEIakHI3sAAQffewABBBiACQQxqQdjewAAQyAEMAgsgAUH93sAAQQYQ6QIMAQsgAUGD38AAQREQ6QILIAJBEGokAAuHAQEEfyAAKAIEIQIgACgCCCIDBEAgAkEEaiEBA0ACQAJAAkACQCABQQRrLQAADgUDAwMBAgALIAEQRAwCCyABKAIAIgRFDQEgAUEEaigCACAEQQEQ+gIMAQsgARDbAQsgAUEYaiEBIANBAWsiAw0ACwsgACgCACIABEAgAiAAQRhsQQgQ+gILC3kAIAAgASkAADcAACAAQSBqIAEpACA3AAAgAEEIaiABQQhqKQAANwAAIABBEGogAUEQaikAADcAACAAQRhqIAFBGGopAAA3AAAgAEEoaiABQShqKQAANwAAIABBMGogAUEwaikAADcAACAAQThqIAFBOGopAAA3AAALiwEBBH8CQAJAAkAgACgCACIAKAIADgIAAQILIAAoAggiAUUNASAAKAIEIAFBARD6AgwBCyAALQAEQQNHDQAgACgCCCIBKAIAIQMgAUEEaigCACIEKAIAIgIE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AQsgAkECNgIEIAJBqJ7EADYCACACQgE3AgwgAiAArUKAgICA4AiENwMYIAIgAkEYajYCCCABKAIAIAEoAgQgAhBgCyACQSBqJAALvQMBB38jAEEQayIDJAAgACgCCCEFIAAoAgQhACABKAIAQb+2xABBASABKAIEKAIMEQEAIQQgA0EEaiICQQA6AAUgAiAEOgAEIAIgATYCACAFBEADQCADIAA2AgwgA0EMaiEHIwBBIGsiASQAQQEhBgJAIANBBGoiBC0ABA0AIAQtAAUhCAJAIAQoAgAiAi0ACkGAAXFFBEAgCEEBcUUNASACKAIAQZG2xABBAiACKAIEKAIMEQEARQ0BDAILIAhBAXFFBEAgAigCAEGTtsQAQQEgAigCBCgCDBEBAA0CCyABQQE6AA8gAUGctsQANgIUIAEgAikCADcCACABIAIpAgg3AhggASABQQ9qNgIIIAEgATYCECAHIAFBEGpBiNLAACgCABEAAA0BIAEoAhBBlLbEAEECIAEoAhQoAgwRAQAhBgwBCyAHIAJBiNLAACgCABEAACEGCyAEQQE6AAUgBCAGOgAEIAFBIGokACAAQQFqIQAgBUEBayIFDQALC0EBIQAgA0EEaiIBLQAERQRAIAEoAgAiACgCAEHAtsQAQQEgACgCBCgCDBEBACEACyABIAA6AAQgA0EQaiQAIAALugUBE38jAEHAAWsiAyQAIANBuAFqIAFBGGopAAA3AwAgA0GwAWogAUEQaikAADcDACADQagBaiABQQhqKQAANwMAIAMgASkAADcDoAEjAEEgayIBJAAgA0GgAWoiBCAELQAfQT9xQcAAcjoAHyAEIAQtAABB+AFxOgAAIAFBCGogBEEIaikAADcDACABQRBqIARBEGopAAA3AwAgAUEYaiAEQRhqKQAANwMAIAEgBCkAADcDACADIAEQJyABQSBqJAAjAEGgAmsiAiQAIAMoAighBSADKAJQIQYgAygCLCEHIAMoAlQhCCADKAIwIQkgAygCWCEKIAMoAjQhCyADKAJcIQwgAygCOCENIAMoAmAhDiADKAI8IQ8gAygCZCEQIAMoAkAhESADKAJoIRIgAygCRCETIAMoAmwhFCADKAJIIQQgAygCcCEBIAIgAygCTCADKAJ0ajYCLCACIAEgBGo2AiggAiATIBRqNgIkIAIgESASajYCICAC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AgggAygCDBCSAiEBIABBATsBACAAIAE2AgQgA0EQaiQAC0kBAX8jAEEQayIDJAAgA0EIaiABKAIAIAEoAgQgASgCCBBeIAIgAygCCCADKAIMEJICIQEgAEECNgIAIAAgATYCBCADQRBqJAALvw8CBn8CfiMAQRBrIg0kACMAQeAAayIMJAACQAJAAkACQCAABEAgAEEIayIPIA8oAgBBAWoiDjYCACAORQ0BIAAoAgANAiAAQX82AgAgDCAPNgJQIAwgADYCTCAMIAQ2AgwgDCADNgIIIAwgBDYCBCAMIAY2AhggDCAFNgIUIAwgBjYCECAMIAg2AiQgDCAHNgIgIAwgCDYCHCAMIABBCGoiBDYCSAJAIApFBEBBgICAgHghCwwBCyAMIAs2AjAgDCAKNgIsCyAMIAs2AiggDEE0aiEFIwBB0AFrIgMkACADQQhqIAxBHGoiBkEIaigCADYCACADQRRqIAxBEGoiB0EIaigCADYCACADIAYpAgA3AwAgAyAHKQIANwIMIANByAFqIAxBBGoiBkEIaigCADYCACADIAYpAgA3A8ABIANB8ABqIAQgASACIAMgA0HAAWogCfwHIAxBKGoQJAJAIAMpA4ABIhJCBFEEQCADQcgAaiADQZABaikDACISNwMAIANB0ABqIANBmAFqKAIAIgQ2AgAgAyADKQOIASITNwNAIAVBEGogBDYCACAFQQhqIBI3AgAgBSATNwIAIAMoAsABIgRFDQEgAygCxAEgBEEBEPoCDAELIANB4ABqIgQgA0GQAWopAwA3AwAgA0HoAGoiByADQZgBaigCADYCACADIAMpA4gBNwNYIAMoAnghCCADKAJ0IQogAygCcCEGIANBPGogA0G8AWooAgA2AgAgA0E0aiADQbQBaikCADcCACADQSxqIANBrAFqKQIANwIAIANBJGogA0GkAWopAgA3AgAgAyADKQKcATcCHCADQdAAaiILIAcoAgA2AgAgA0HIAGoiByAEKQMANwMAIAMgAykDWDcDQCADQRhqIAsoAgA2AgAgA0EQaiAHKQMANwMAIAMgAykDQDcDCCADIBI3AwAgAygCwAEiBARAIAMoAsQBIARBARD6AgsCQCASQgNSBEAgA0GEAWogA0EYaigCADYCACADIAg2AnggAyAKNgJ0IAMgBjYCcCADIAMpAxA3AnwgAyAD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KCACIAKtQoCAgIDgCIQ3AyAgAiACQSBqNgIQIAJBCGogAxC/AgALIwBBMGsiASQAIAEgAjYCBCABIAA2AgAgAUECNgIMIAFBqNPEADYCCCABQgI3AhQgASABQQRqrUKAgICA4AiENwMoIAEgAa1CgICAgOAIhDcDICABIAFBIGo2AhAgAUEIaiADEL8CAAsjAEEwayIAJAAgACACNgIEIAAgATYCACAAQQI2AgwgAEHQ0sQANgIIIABCAjcCFCAAIABBBGqtQoCAgIDgCIQ3AyggACAArUKAgICA4AiENwMgIAAgAEEgajYCECAAQQhqIAMQvwIAC0IBAX8jAEEgayIDJAAgA0EANgIQIANBATYCBCADQgQ3AgggAyABNgIcIAMgADYCGCADIANBGGo2AgAgAyACEL8CAAtBAQF/IAAoAgAiACgCqAEEQCAAQQA2AqgBCwJAIABBf0YNACAAIAAoAgRBAWsiATYCBCABDQAgAEGQD0EIEPoCCws9AQJ/AkAgACgCACICRQ0AIAAoAgQiACgCACIBBEAgAiABEQQACyAAKAIEIgFFDQAgAiABIAAoAggQ+gILCzkBAX8jAEEQayICJAAgAkEIaiAAKAIAIAAoAgQgACgCCBBeIAEgAigCCCACKAIMEJICIAJBEGokAAvfBwIEfwJ+IwBBEGsiCSQAIwBB0ABrIggkAAJAAkACQAJAIAAEQCAAQQhrIgsgCygCAEEBaiIKNgIAIApFDQEgACgCAA0CIABBfzYCACAIIAs2AkAgCCAANgI8IAggBDYCFCAIIAM2AhAgCCAENgIMIAggAEEIaiIKNgI4AkAgBkUEQEGAgICAeCEHDAELIAggBzYCICAIIAY2AhwLIAggBzYCGCAIQSRqIQQjAEGAAmsiAyQAIANBgICAgHg2AtgBIANB+AFqIAhBDGoiBkEIaigCADYCACADIAYpAgA3A/ABIANBiAFqIAogASACIANB2AFqIANB8AFqIAX8ByAIQRhqECQCQCADKQOYASINQgRRBEAgA0HgAGogA0GoAWopAwAiDTcDACADQegAaiADQbABaigCACIGNgIAIAMgAykDoAEiDDcDWCAEQRBqIAY2AgAgBEEIaiANNwIAIAQgDDcCACADKALwASIERQ0BIAMoAvQBIARBARD6AgwBCyADQRBqIgYgA0GQAWopAwA3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BUEKNgIAIAVBDGogAkEsaigCADYCACAHRQ0CIAogB0EBEPoCDAILIAVBDTYCECAFQdvCwAA2AgwgBUEONgIIIAVBzcLAADYCBCAFQQg2AgAMAQtByL7AAEErIAJB/wBqQbi+wABB9L7AABDmAQALIAJBgAFqJAAMAQtByMPAAEE3IAJB/wBqQbjDwABBgMTAABDmAQALIANBKGoiAiADQcQAaiIEKAIANgIAIAMgAykCPDcDICADKAI4IgdBCkcEQCADKAJIIQogBCACKAIANgIAIAMgAykDIDcCPCADIAo2AkggAyAHNgI4IAUQywEhAiAJQYCAgIB4NgIAIAkgAjYCBAwBCyAJIAMpAyA3AgAgCUEIaiACKAIANgIACyADQdAAaiQAIAEEQCAAIAFBARD6AgsCQAJAIAYCfyAIKAIEIgJBgICAgHhGBEBBACEBIAgoAgghAEEBDAELIAgoAgghAAJAIAgoAgwiCyACTwRAIAAhAQwBCyALRQRAQQEhASAAIAJBARD6AgwBCyAAIAJBASALEO0CIgFFDQILQQAhAEEACzYCDCAGIAA2AgggBiALNgIEIAYgATYCACAIQRBqJAAMAQtBASALENsCAAsgBigCACAGKAIEIAYoAgggBigCDCAGQRBqJAALlwQCB38CfiMAQRBrIgQkACMAQdAAayICJAAjAEEgayIDJAAgAkEoaiIFAn8gAUEgRgRAIANBAmogAEECai0AADoAACADQR9qIABBH2otAAA6AAAgAyAALwAAOwEAIAMgACkAFzcAFyADIAApAA83AA8gAyAAKAALNgALIAMgACkAAzcAAyAFQQFqIAMQ7gEgAxDCAUEADAELIAUgATYCDCAFQoCAgICABDcCBEEBCzoAACADQSBqJAACQAJAAkAgAi0AKCIGQQFGBEAgAkEbaiACQTxqKAIAIgM2AAAgAkETaiACQTRqKQIAIgk3AAAgAiACKQIsIgo3AAsgAkE4aiADNgIAIAJBMGogCTcDACACIAo3AyggBRDLASEDDAELIAJBIGoiByACQcEAaikAADcDACACQRhqIgggAkE5aikAADcDACACQRBqIgUgAkExaikAADcDACACIAIpACk3AwhBIEEBEIEDIgNFDQEgAyACKQMINwAAIANBGGogBykDADcAACADQRBqIAgpAwA3AAAgA0EIaiAF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IAAgARDcAkUNACAABEAgACABEIEDIgFFDQELIAEPCwALJwECfyMAQRBrIgAkACAAQQo2AgQgAEEEakEAQQAQkgIgAEEQaiQAC6QJAhJ/An4jAEEwayIPJAAgD0EMaiEQIwBBsAFrIgIkACACQThqQgA3AwAgAkEwakIANwMAIAJBKGpCADcDACACQSBqQgA3AwAgAkEYakIANwMAIAJBEGpCADcDACACQQhqQgA3AwAgAkIANwMAQQEhBwNAIAIgBWoiAyADKAIAIAEgBWoiAy0AAHIgA0EBai0AAEEIdHIgA0ECai0AAEEQdHIgA0EDai0AAEEYdHI2AgAgBUEEaiEFIAdBEEkgB0EBaiEHDQALIAJByABqIgEgAigCCCIKQQZ0IAIoAgQiBkEadnJB/////wFxNgIAIAJB0ABqIgUgAigCECILQQx0IAIoAgwiDEEUdnJB/////wFxNgIAIAJB2ABqIgcgAigCGCIEQRJ0IAIoAhQiDUEOdnJB/////wFxNgIAIAJB4ABqIgMgAigCICIOQRh0IAIoAhwiCEEIdnJB/////wFxNgIAIAIgAigCACIJQf////8BcTYCQCACIAZBA3QgCUEddnJB/////wFxNgJEIAIgDEEJdCAKQRd2ckH/////AXE2AkwgAiANQQ90IAtBEXZyQf////8BcTYCVCACIAhBFXQgBEELdnJB/////wFxNgJcIAJBiAFqIgogAigCPCIEQQ12NgIAIAJB8ABqIg0gAigCKCIIQQF0IAIoAiQiBkEfdnJB/////wFxNgIAIAJB+ABqIgsgAigCMCIJQQd0IAIoAiwiEUEZdnJB/////wFxNgIAIAJBgAFqIgwgAigCOCISQQ10IAIoAjQiE0ETdnJB/////wFxNgIAIAIgBkECdkH/////AXE2AmwgAiAGQRt0IA5BBXZyQf////8BcTYCaCACIBFBBHQgCEEcdnJB/////wFxNgJ0IAIgE0EKdCAJQRZ2ckH/////AXE2AnwgAiAEQRB0IBJBEHZyQf////8BcTYChAEgAkGMAWoiBiACQUBrQbzhwAAQMSADIAJBrAFqIgQoAgA2AgAgByACQaQBaiIOKQIANwMAIAUgAkGcAWoiCCkCADcDACABIAJBlAFqIgkpAgA3AwAgAiACKQKMATcDQCAGIAJB6ABqQZjhwAAQMSAKIAQoAgA2AgAgDCAOKQIANwMAIAsgCCkCADcDACANIAkpAgAiFDcDACACIAIpAowBIhU3A2ggAiACKAJAIBWnaiIEQf////8BcTYCjAEgAiACKAJEIAIoAmwgBEEddmpqIgRB/////wFxNgKQASACIAEoAgAgFKcgBEEddmpqIgFB/////wFxNgKUASACIAIoAkwgAigCdCABQR12amoiAUH/////AXE2ApgBIAIgBSgCACALKAIAIAFBHXZqaiIBQf////8BcTYCnAEgAiACKAJUIAIoAnwgAUEddmpqIgFB/////wFxNgKgASACIAcoAgAgDCgCACABQR12amoiAUH/////AXE2AqQBIAIgAigCXCACKAKEASABQR12amoiAUH/////AXE2AqgBIAIgAygCACAKKAIAIAFBHXZqakH/////AXE2AqwBIBAgBkHg4cAAEGggAkGwAWokACAAIBAQfyAPQTBqJAAL/AECAn8BfiMAQRBrIgIkACACQQE7AQwgAiABNgIIIAIgADYCBCMAQRBrIgEkACACQQRqIgApAgAhBCABIAA2AgwgASAENwIEIwBBEGsiACQAIAFBBGoiASgCACICKAIMIQMCQAJAAkACQCACKAIEDgIAAQILIAMNAUEBIQJBACEDDAILIAMNACACKAIAIgIoAgQhAyACKAIAIQIMAQsgAEGAgICAeDYCACAAIAE2AgwgAEH8p8QAIAEoAgQgASgCCCIALQAIIAAtAAkQxAEACyAAIAM2AgQgACACNgIAIABB4KfEACABKAIEIAEoAggiAC0ACCAALQAJEMQBAAu3FwIYfwd+IwBBEGsiEiQAIAEhFyMAQUBqIggkAAJAAkACQCAABEAgAEEIayITIBMoAgBBAWoiBDYCACAERQ0BIAAoAgANAiAAQX82AgAgCCATNgIMIAggADYCCCAIIABBCGoiBDYCBCAIIAI2AiggCCABNgIkIAggAjYCICAIQSxqIQ0gBCEBIAhBIGohFCMAQcAtayIEJAACQAJAIAMEQCABKAKUECEMIAEoApgQIQoMAQsgASgCmBAhCiABKAKUECEMIARBkBBqIAFBGGopAwA3AwAgBEGIEGogAUEQaikDADcDACAEQYAQaiABQQhqKQMANwMAIAQgASkDADcD+A8gBEHQH2ogAUH4AGopAwA3AwAgBEHIH2ogAUHwAGopAwA3AwAgBEHAH2ogAUHoAGopAwA3AwAgBEGAH2ogAUEoaikDADcDACAEQYgfaiABQTBqKQMANwMAIARBkB9qIAFBOGopAwA3AwAgBEGYH2ogAUFAaykDADcDACAEQaAfaiABQcgAaikDADcDACAEQagfaiABQdAAaikDADcDACAEQbAfaiABQdgAaikDADcDACAEIAEpA2A3A7gfIAQgASkDIDcD+B4gASkDgAEhHCABKQOQASEdIAEtAIoBIQsgAS0AiQEhCSABLQCIASERIAQgASgCmAEiDgR/IA5BBXQhByABQZwBaiEPIARB4B9qIRADQCAFQeANRgRAQfDOwAAQ+wILIAUgEGoiAyAFIA9qIgYpAgA3AgAgA0EYaiAGQRhqKQIANwIAIANBEGogBkEQaikCADcCACADQQhqIAZBCGopAgA3AgAgByAFQSBqIgVHDQALIAdBIGtBBXZBAWoFQQALNgLcHyAEQZARaiAEQdwfakHkDfwKAAAgBEGYEGogBEH4HmpB4AD8CgAAIAQgHTcDiBEgBCALOgCCESAEIAk6AIERIAQgEToAgBEgBCAcNwP4ECAKBEAgCkEMbCEDIAxBCGohBQNAIARB+A9qIAVBBGsoAgAgBSgCABApIAVBDGohBSADQQxrIgMNAAsLIARBCGoiBSAEQfgPaiIDQYAP/AoAACADIAUQvwEgBEEANgLkHyAEQoCAgIAQNwLcHyAEQSA2AvweIAQgAzYC+B4gBCAEQdwfaiIDNgKgDyAEIARBoA9qIgVBMCAEQfgeaiIGQeypwAAQnAECQAJAIAQoAgBBAXFFBEAgBEGAH2ogBEHkH2ooAgA2AgAgBCAEKQLcHzcD+B4gBCAGrUKAgICAkAKENwOgDyAEQgE3AugfIARBAjYC4B8gBEGwq8AANgLcHyAEIAU2AuQfIARBiA9qIAMQeSAEKAL4HiIDBEAgBCgC/B4gA0EBEPoCCyABKAKcEEUNASAEQfgPaiABQaAQakHAAfwKAAAgBCgCjA8hBSAEKAKQDyERIARB3B9qIQcjAEHwAGsiAyQAIAMgFCgCBCAUKAIIEEkgAygCDCEJIAMoAgghBiADKAIEIQsCQCADKAIAIg9BioCAgHhHBEAgAygCECEQIAcgCTYCECAHIAY2AgwgByALNgIIIAcgEDYCFCAHIA82AgQgB0EBOgAADAELIAlBwABGBEAgA0HuAGoiCSAGQQJqLQAAOgAAIANByABqIg8gBkEfaikAADcDACADQdAAaiIQIAZBJ2opAAA3AwAgA0HYAGoiFSAGQS9qKQAANwMAIANB4ABqIhYgBkE3aikAADcDACADQegAaiIYIAZBP2otAAA6AAAgAyAGLwAAOwFsIAMgBikAFzcDQCAGKQAPIRwgBigACyEZIAYoAAchGiAGKAADIRsgCwRAIAYgC0EBEPoCCyADQQJqIAktAAA6AAAgA0EfaiAPKQMANwAAIANBJ2ogECkDADcAACADQS9qIBUpAwA3AAAgA0E3aiAWKQMANwAAIANBP2ogGC0AADoAACADIAMvAWw7AQAgAyADKQNANwAXIAMgHDcADyADIBk2AAsgAyAaNgAHIAMgGzYAAyAHQQFqIAMQ6gEgB0EAOgAADAELIAsEQCAGIAtBARD6AgsgByAJNgIMIAdCh4CAgIgINwIEIAdBAToAAAsgA0HwAGokACAELQDcHwRAIARBix9qIARB8B9qKAIAIgE2AAAgBEGDH2ogBEHoH2opAgAiHDcAACAEIAQpAuAfIh03APseIA1BEGogATYAACANQQhqIBw3AAAgDSAdNwAADAMLIARBsB9qIARBlSBqKQAAIhw3AwAgBEGoH2ogBEGNIGopAAAiHTcDACAEQaAfaiAEQYUgaikAACIeNwMAIARBmB9qIARB/R9qKQAAIh83AwAgBEGQH2ogBEH1H2opAAAiIDcDACAEQYgfaiAEQe0faikAACIhNwMAIARBgB9qIARB5R9qKQAAIiI3AwAgBEGoD2ogIjcDACAEQbAPaiAhNwMAIARBuA9qICA3AwAgBEHAD2ogHzcDACAEQcgPaiAeNwMAIARB0A9qIB03AwAgBEHYD2ogHDcDACAEIAQpAN0fIhw3A/geIAQgHDcDoA8gBEGUD2ogBEH4D2ogBSARIARBoA9qEIEBIAQoApQPQQFGBEAgDUEEaiAFIBEQOyANQYWAgIB4NgIAIAQoApgPIgFFDQMgBCgCnA8iAygCACIGBEAgASAGEQQACyADKAIEIgZFDQMgASAGIAMoAggQ+gIMAwsgDgRAIAFBADYCmAELIAEgBEEIakGAD/wKAAAgBCgCiA8iA0UNAyAFIANBARD6AgwDC0HIvsAAQSsgBEH4HmpBuL7AAEH0vsAAEOYBAAsgDUEEaiAEKAKMDyIFIAQoApAPEDsgDUGFgICAeDYCAAsgBCgCiA8iAUUNASAFIAFBARD6AgwBCyABQQA2ApgQIARBADYC9A8gBCABQZAQajYC7A8gBCAKNgLwDyAEIAw2AuQPIAQgDCAKQQxsajYC6A8gBEHkD2oiBSgCBCIMIAUoAgAiCWsiDkEMbiIGIAFBhBBqIgcoAgAgBygCCCIDa0sEQCAHIAMgBkEEQQwQyQEgBygCCCEDCyAFKAIQIQogBSgCDCELIAUoAgghBgJAAkACQAJAAkAgCSAMRwRAIAlBDGohESAHKAIEIANBDGxqIQ8gDkEMayEQQQAhBQNAIAUgCWoiDigCACIVQYCAgIB4Rg0CIAUgD2oiFkEEaiAOQQRqKQIANwIAIBYgFTYCACAFQQxqIQUgA0EBaiEDIA5BDGogDEcNAAsLIAcgAzYCCAwBCyAHIAM2AgggDkEMaiAMRw0BCyAKRQ0CIAsgBigCCCIDRg0BIApBDGwiBUUNASAGKAIEIgcgA0EMbGogByALQQxsaiAF/AoAAAwBCyAQIAVrQQxuIQNBACAGKAIEIgdrIQwgByARaiAFaiEFA0AgBSAMaiIHKAIAIgkEQCAHQQRqKAIAIAlBARD6AgsgBUEMaiEFIANBAWsiAw0ACyAKRQ0BAkAgCyAGKAIIIgNGDQAgCkEMbCIFRQ0AIAYoAgQiByADQQxsaiAHIAtBDGxqIAX8CgAACyAGIAMgCmo2AggMAQsgBiADIApqNgIICyAEQfgPaiAUEO8BIAEoAvgPIgNBgICAgHhGIANFckUEQCABKAL8DyADQQEQ+gILIAFB+A9qIgEgBCkC+A83AgAgAUEIaiAEQYAQaigCADYCACANQYqAgIB4NgIACyAEQcAtaiQAQY2AgIB4IQEgCCgCLCIDQYqAgIB4RwRAIAhBGGogCEE4aikCADcDACAIIAgpAjA3AxAgAyEBCyACBEAgFyACQQEQ+gILQQAhAiAAQQA2AgAgEyATKAIAQQFrIgA2AgAgAEUEQCAIQQxqEHsLIAFBjYCAgHhHBEAgCEE4aiAIQRhqKQMANwIAIAggATYCLCAIIAgpAxA3AjBBASECIAhBLGoQpAEhAAsgEiACNgIEIBIgAEEAIAIbNgIAIAhBQGskAAwDCxCQAwsACxCRAwALIBIoAgAgEigCBCASQRBqJAAL+gMCBX8DfiMAQRBrIgYkACMAQRBrIgckACAHQQhqIQgjAEGAEGsiBCQAIARBOGpCADcDACAEQTBqQgA3AwAgBEEoakIANwMAIARBIGpCADcDACAEQRhqQgA3AwAgBEEQakIANwMAIARBCGpCADcDACAEQcgAakHAy8AAKQIAIgk3AwAgBEHQAGpByMvAACkCACIKNwMAIARB2ABqQdDLwAApAgAiCzcDACAEQYgPaiAJNwMAIARBkA9qIAo3AwAgBEGYD2ogCzcDACAEQgA3AwAgBEG4y8AAKQIAIgk3A0AgBCAJNwOADyAEQaAPaiAEQeAA/AoAACAEIARBgA9qIgVBgAH8CgAAIARBhwFqQQA2AAAgBEEANgKYASAEQgA3A5ABIARCADcDgAEgBCACIAMQKSAEIAAgARApIAUgBBC/AUEgQQEQgQMiBUUEQEEBQSAQ2wIACyAFIAQpAIAPNwAAIAVBGGogBEGYD2opAAA3AAAgBUEQaiAEQZAPaikAADcAACAFQQhqIARBiA9qKQAANwAAIAhBIDYCBCAIIAU2AgAgBEGAEGokACAHKAIMIQQgBygCCCEFIAMEQCACIANBARD6AgsgAQRAIAAgAUEBEPoCCyAGIAU2AgAgBiAENgIEIAdBEGokACAGKAIAIAYoAgQgBkEQaiQAC8sDAQN/IwBBEGsiAyQAQQghBAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQEEVIAAoAgAiBUGAgICAeHMgBUEAThtBAWsOFQECAwQFBgcICQoLDA0ODxQUEBESEwALIAMgAC0ABDoAASADQQA6AAAMFgsgAyAAMQAENwMIDBMLIAMgADMBBDcDCAwSCyADIAA1AgQ3AwgMEQsgAyAAKQMINwMIDBALIAMgADAABDcDCAwQCyADIAAyAQQ3AwgMDwsgAyAANAIENwMIDA4LIAMgACkDCDcDCAwNCyADIAAqAgS7OQMIIANBAzoAAAwNCyADIAArAwg5AwggA0EDOgAADAwLIAMgACgCBDYCBCADQQQ6AAAMCwsgAyAAKQMINwIEIANBBToAAAwKCyADIAApAgQ3AgQgA0EFOgAADAkLIAMgACkDCDcCBCADQQY6AAAMCAsgAyAAKQIENwIEIANBBjoAAAwHCyADQQc6AAAMBgsgA0EJOgAADAULIANBCjoAAAwEC0ELIQQLIAMgBDoAAAwCCyADQQE6AAAMAQsgA0ECOgAACyADIAEgAhDXASADQRBqJAALZAEEfyMAQRBrIgIkACMAQRBrIgMkACADQQhqIAAgARCJASADKAIMIQQgAygCCCEFIAEEQCAAIAFBARD6AgsgAiAFNgIAIAIgBDYCBCADQRBqJAAgAigCACACKAIEIAJBEGokAAvkAwIFfwN+IwBBEGsiBCQAIwBBEGsiBSQAIAVBCGohBiMAQYAQayICJAAgAkE4akIANwMAIAJBMGpCADcDACACQShqQgA3AwAgAkEgakIANwMAIAJBGGpCADcDACACQRBqQgA3AwAgAkEIakIANwMAIAJByABqQcDLwAApAgAiBzcDACACQdAAakHIy8AAKQIAIgg3AwAgAkHYAGpB0MvAACkCACIJNwMAIAJBiA9qIAc3AwAgAkGQD2ogCDcDACACQZgPaiAJNwMAIAJCADcDACACQbjLwAApAgAiBzcDQCACIAc3A4APIAJBoA9qIAJB4AD8CgAAIAIgAkGAD2oiA0GAAfwKAAAgAkGHAWpBADYAACACQQA2ApgBIAJCADcDkAEgAkIANwOAASACIAAgARApIAMgAhC/AUEgQQEQgQMiA0UEQEEBQSAQ2wIACyADIAIpAIAPNwAAIANBGGogAkGYD2opAAA3AAAgA0EQaiACQZAPaikAADcAACADQQhqIAJBiA9qKQAANwAAIAZBIDYCBCAGIAM2AgAgAkGAEGokACAFKAIMIQIgBSgCCCEDIAEEQCAAIAFBARD6AgsgBCADNgIAIAQgAjYCBCAFQRBqJAAgBCgCACAEKAIEIARBEGokAAshAAJAIAEgAxDcAgRAIAAgASADIAIQ7QIiAA0BCwALIAALogIBBH8jAEEQayIDJAAjAEEwayICJAACQAJAAkACQCAABEAgAEEIayIEIAQoAgBBAWoiATYCACABRQ0BIAAoAgAiAUF/Rg0CIAAgAUEBajYCACACIAQ2AgwgAiAANgIIIAIgAEEIaiIBNgIEIAJBEGogARC/AUEgQQEQgQMiAUUNAyABIAIpABA3AAAgAUEYaiACQShqKQAANwAAIAFBEGogAkEgaikAADcAACABQQhqIAJBGGopAAA3AAAgACAAKAIAQQFrNgIAIAQgBCgCAEEBayIANgIAIABFBEAgAkEMahCaAgsgA0EgNgIEIAMgATYCACACQTBqJAAMBAsQkAMLAAsQkQMAC0EBQSAQ2wIACyADKAIAIAMoAgQgA0EQaiQACyUAIABFBEBB9JvDAEEyEJIDAAsgACACIAMgBCAFIAEoAhAREAALxwIBCX8jAEEQayIDJAAjAEEQayIEJAAgBEEIaiEFIwBB0AJrIgAkACAAQYACaiICQgA3AwAgAEH4AWoiBkIANwMAIABB8AFqIgdCADcDACAAQgA3A+gBIABB6AFqIggQ1QEgAEGPAmoiASAIEDkgAEEIaiABEKICIAEQwAEgAEHQAWogBykDADcCACAAQdgBaiAGKQMANwIAIABB4AFqIAIpAwA3AgAgACAAKQPoATcCyAFBIEEBEIEDIgFFBEBBAUEgEJoDAAsgASAAQcgBaiICKQAANwAAIAFBGGogAkEYaikAADcAACABQRBqIAJBEGopAAA3AAAgAUEIaiACQQhqKQAANwAAIABBCGoQwwEgBUEgNgIEIAUgATYCACAAQdACaiQAIAMgBCkDCDcCACAEQRBqJAAgAygCACADKAIEIANBEGokAAulAgEIfyMAQRBrIgIkACMAQRBrIgMkACADQQhqIQQjAEEgayIBJAAjAEEwayIAJAAgAEEgaiIFQgA3AwAgAEEYaiIGQgA3AwAgAEEQaiIHQgA3AwAgAEIANwMIIABBCGoQ1QEgAUEYaiAFKQMANwAAIAFBEGogBikDADcAACABQQhqIAcpAwA3AAAgASAAKQMINwAAIABBMGokAEEgQQEQgQMiAEUEQEEBQSAQmgMACyAAIAEpAAA3AAAgAEEYaiABQRhqKQAANwAAIABBEGogAUEQaikAADcAACAAQQhqIAFBCGopAAA3AAAgARDCASAEQSA2AgQgBCAANgIAIAFBIGokACACIAMpAwg3AgAgA0EQaiQAIAIoAgAgAigCBCACQRBqJAALIwAgAEUEQEH0m8MAQTIQkgMACyAAIAIgAyAEIAEoAhARCgALIwAgAEUEQEH0m8MAQTIQkgMACyAAIAIgAyAEIAEoAhAREQALIwAgAEUEQEH0m8MAQTIQkgMACyAAIAIgAyAEIAEoAhAROAALIwAgAEUEQEH0m8MAQTIQkgMACyAAIAIgAyAEIAEoAhAROgALIwAgAEUEQEH0m8MAQTIQkgMACyAAIAIgAyAEIAEoAhARPAALKAEBfyAAKAIAIgFBgICAgHhyQYCAgIB4RwRAIAAoAgQgAUEBEPoCCwshACAARQRAQfSbwwBBMhCSAwALIAAgAiADIAEoAhARAwALIgAgAC0AAEUEQCABQZy0xABBBRBTDwsgAUGhtMQAQQQQUwsbACAAKAIAIgBBBGooAgAgAEEIaigCACABEEILHwAgAEUEQEH0m8MAQTIQkgMACyAAIAIgASgCEBEAAAscACAAIAAtAAQgAUEuRnI6AAQgACgCACABEOoCCxoBAX8gACgCACIBBEAgACgCBCABQQEQ+gILCxwAIAAoAgAiACgCACABIABBBGooAgAoAhARAAALHwAgAEEIakGg3sAAKQIANwIAIABBmN7AACkCADcCAAsfACAAQQhqQciSwwApAgA3AgAgAEHAksMAKQIANwIACx8AIABBCGpB5KDEACkCADcCACAAQdygxAApAgA3AgALHwAgAEEIakH0oMQAKQIANwIAIABB7KDEACkCADcCAAtFACAABEAgACABEJoDAAsjAEEgayIAJAAgAEEANgIYIABBATYCDCAAQcCtxAA2AgggAEIENwIQIABBCGpByK3EABC/AgALFQAgAWlBAUYgAEGAgICAeCABa01xCxcBAX8gABAVIgE2AgQgACABQQBHNgIACxcBAX8gABAYIgE2AgQgACABQQBHNgIACxcBAX8gABAZIgE2AgQgACABQQBHNgIACxcBAX8gABAaIgE2AgQgACABQQBHNgIACxwAIABBADYCECAAQgA3AgggAEKAgICAwAA3AgALFwEBbyAAIAEQACECEI8BIgAgAiYBIAALFwEBbyAAIAEQASECEI8BIgAgAiYBIAALFwEBbyAAJQEQECEBEI8BIgAgASYBIAALFgAgACgCACIAKAIEIAAoAgggARCbAwsWACAAKAIAIgAoAgAgACgCBCABEJsDCxUBAX8jAEEQayIBIAA6AA8gAS0ADwsQACABBEAgACABIAIQ+gILCxYAIAAoAgAgASACIAAoAgQoAgwRAQALFAAgACgCACABIAAoAgQoAhARAAALnAcBA38jAEHwAGsiBSQAIAUgAzYCDCAFIAI2AggCfwJAAkAgAUGBAk8EQEH9ASEGA0ACQCAAIAZqIgdBA2osAABBv39MBEAgB0ECaiwAAEG/f0wNASAGQQJqIQYMBQsgBkEDaiEGDAQLIAdBAWosAABBv39KDQIgBywAAEG/f0oNAyAGQQRrIgZBfUcNAAtBACEGDAILIAUgATYCFCAFIAA2AhBBAQwCCyAGQQFqIQYLIAUgADYCECAFIAY2AhRBBUEAIAEgBksiBhshB0GAz8QAQQEgBhsLIQYgBSAHNgIcIAUgBjYCGAJAAkAgBSABIAJPBH8gASADTw0BIAMFIAILNgIoIAVBAzYCNCAFQcjQxAA2AjAgBUIDNwI8IAUgBUEYaq1CgICAgLAVhDcDWCAFIAVBEGqtQoCAgICwFYQ3A1AgBSAFQShqrUKAgICA4AiENwNIDAELAn8CQAJAAkAgAiADTQRAIAJFIAEgAk1yRQRAIAVBDGogBUEIaiAAIAJqLAAAQb9/ShsoAgAhAwsgBSADNgIgIAEgA00NAkEAIQcgA0UNAQNAIAAgA2osAABBv39KBEAgAyEHDAMLIANBAWsiAw0ACwwBCyAFQQQ2AjQgBUGoz8QANgIwIAVCBDcCPCAFIAVBGGqtQoCAgICwFYQ3A2AgBSAFQRBqrUKAgICAsBWENwNYIAUgBUEMaq1CgICAgOAIhDcDUCAFIAVBCGqtQoCAgIDgCIQ3A0gMBAsgASAHRg0AAkAgACAHaiICLAAAIgNBAEgEQCACLQABQT9xIQAgA0EfcSEBIANBX0sNASABQQZ0IAByIQYMAwsgBSADQf8BcTYCJEEBDAMLIAItAAJBP3EgAEEGdHIhACADQXBJBEAgACABQQx0ciEGDAILIAFBEnRBgIDwAHEgAi0AA0E/cSAAQQZ0cnIiBkGAgMQARw0BCyAEEPwCAAsgBSAGNgIkQQEgBkGAAUkNABpBAiAGQYAQSQ0AGkEDQQQgBkGAgARJGwshACAFIAc2AiggBSAAIAdqNgIsIAVBBTYCNCAFQYjQxAA2AjAgBUIFNwI8IAUgBUEYaq1CgICAgLAVhDcDaCAFIAVBEGqtQoCAgICwFYQ3A2AgBSAFQShqrUKAgICAwBWENwNYIAUgBUEkaq1CgICAgIAJhDcDUCAFIAVBIGqtQoCAgIDgCIQ3A0gLIAUgBUHIAGo2AjggBUEwaiAEEL8CAAsUACAAKAIAIAEgACgCBCgCDBEAAAvtBgEFfwJ/AkACQAJAAkACQAJAAkAgAEEEayIHKAIAIghBeHEiBEEEQQggCEEDcSIFGyABak8EQCAFQQAgAUEnaiIGIARJGw0BAkAgAkEJTwRAIAIgAxCCASICDQFBAAwKC0EAIQIgA0HM/3tLDQhBECADQQtqQXhxIANBC0kbIQEgAEEIayEGIAVFBEAgBkUgAUGAAklyIAQgAWtBgIAISyABIARPcnINByAADAoLIAQgBmohBQJAIAEgBEsEQCAFQfznxAAoAgBGDQFB+OfEACgCACAFRwRAIAUoAgQiCEECcQ0JIAhBeHEiCCAEaiIEIAFJDQkgBSAIEIYBIAQgAWsiBUEQTwRAIAcgASAHKAIAQQFxckECcjYCACABIAZqIgEgBUEDcjYCBCAEIAZqIgQgBCgCBEEBcjYCBCABIAUQdQwJCyAHIAQgBygCAEEBcXJBAnI2AgAgBCAGaiIBIAEoAgRBAXI2AgQMCAtB8OfEACgCACAEaiIEIAFJDQgCQCAEIAFrIgVBD00EQCAHIAhBAXEgBHJBAnI2AgAgBCAGaiIBIAEoAgRBAXI2AgRBACEFQQAhAQwBCyAHIAEgCEEBcXJBAnI2AgAgASAGaiIBIAVBAXI2AgQgBCAGaiIEIAU2AgAgBCAEKAIEQX5xNgIEC0H458QAIAE2AgBB8OfEACAFNgIADAcLIAQgAWsiBEEPTQ0GIAcgASAIQQFxckECcjYCACABIAZqIgEgBEEDcjYCBCAFIAUoAgRBAXI2AgQgASAEEHUMBgtB9OfEACgCACAEaiIEIAFLDQQMBgsgAyABIAEgA0sbIgMEQCACIAAgA/wKAAALIAcoAgAiA0F4cSIHIAFBBEEIIANBA3EiAxtqSQ0CIANFIAYgB09yDQZBjKnEAEEuQbypxAAQmQIAC0HMqMQAQS5B/KjEABCZAgALQYypxABBLkG8qcQAEJkCAAtBzKjEAEEuQfyoxAAQmQIACyAHIAEgCEEBcXJBAnI2AgAgASAGaiIFIAQgAWsiAUEBcjYCBEH058QAIAE2AgBB/OfEACAFNgIACyAGRQ0AIAAMAwsgAxAjIgFFDQEgA0F8QXggBygCACICQQNxGyACQXhxaiICIAIgA0sbIgIEQCABIAAgAvwKAAALIAEhAgsgABBNCyACCwsRACAAKAIEIAAoAgggARCbAwsRACAAKAIAIAAoAgQgARCbAwsTACAAQSg2AgQgAEHw3cAANgIACxAAIAAoAgAgACgCBCABEEILEwAgAEEoNgIEIABBmJLDADYCAAsWAEHM5MQAIAA2AgBByOTEAEEBNgIACxAAIAAoAgQgACgCCCABEEILEQAgASAAKAIAIAAoAgQQ6QILEwAgAEG8qMQANgIEIAAgATYCAAsQACABIAAoAgAgACgCBBBTCxAAIAEoAgAgASgCBCAAEGALEQEBfxCPASIBIAAlASYBIAELYQEBfwJAAkAgAEEEaygCACICQXhxIgNBBEEIIAJBA3EiAhsgAWpPBEAgAkEAIAMgAUEnaksbDQEgABBNDAILQcyoxABBLkH8qMQAEJkCAAtBjKnEAEEuQbypxAAQmQIACwsPAEGs3MAAQS8gABCZAgALDwBBuNPEAEErIAAQmQIACw4AIAFB9KHAAEEFEOkCC6gBAQJ/IAAoAgAjAEEwayIAJAAoAgAhAiAAQgA3AyggAEEoaiIDIAIlARAeIAAgACgCLCICNgIkIAAgACgCKDYCICAAIAI2AhwgAEECNgIIIABBiJ7DADYCBCAAQgE3AhAgACAAQRxqrUKAgICAwA+ENwMoIAAgAzYCDCABKAIAIAEoAgQgAEEEahBgIAAoAhwiAgRAIAAoAiAgAkEBEPoCCyAAQTBqJAALDQAgAEGApcAAIAEQYAsOACABQfClwABBBRDpAgsaAAJ/IAFBCU8EQCABIAAQggEMAQsgABAjCwsOACABQc+uwABBGRDpAgsOACABQeiuwABBEBDpAgsOACABQfiuwABBGhDpAgsOACABQcSvwABBERDpAgsOACABQay4wABBERDpAgsOACABQfS5wABBERDpAgsOACABQdC9wABBBRDpAgsOACABQYS/wABBDhDpAgsNACAAQaDDwAAgARBgCw4AIAFBkMTAAEEFEOkCCw4AIAFB9MfAAEEFEOkCCwwAIAAoAgAgARCxAQsMACAAKAIAIAEQmwELCAAgACABECcLDQBBppzDAEEbEJIDAAsOAEHBnMMAQc8AEJIDAAsJACAAIAEQHQALDgAgAUHstsMAQQUQ6QILDQAgAEGsvcMAIAEQYAsNACAAQbygxAAgARBgCw0AIABByKfEACABEGALDAAgACABKQIANwMACw0AIABB2K3EACABEGALDgAgAUGsrMQAQQUQ6QILGgAgACABQZToxAAoAgAiAEGUASAAGxECAAALCgAgAiAAIAEQUwsNACAAQZy2xAAgARBgCw0AIAFB9uLEAEEYEFMLDQAgAUHU4sQAQSAQUwsOACABQdSgxABBCBDpAgsOACABQd7IwwBBDRDpAgsJACAAQQA2AgALTQEBfyMAQTBrIgEkACABQQE2AgwgAUHws8QANgIIIAFCATcCFCABIAFBL2qtQoCAgIDQFYQ3AyAgASABQSBqNgIQIAFBCGogABC/AgALUAEBfyMAQTBrIgAkACAAQQE2AgwgAEHws8QANgIIIABCATcCFCAAIABBL2qtQoCAgIDgFYQ3AyAgACAAQSBqNgIQIABBCGpB5J/AABC/AgALCAAgACUBEAILFQIBbwF/EBwhABCPASIBIAAmASABCwIACwur3wRAAEGAgMAAC4MfL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2FsbG9jL3NyYy9jb2xsZWN0aW9ucy9idHJlZS9tYXAvZW50cnkucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9iYXNlNjQtMC4yMi4xL3NyYy9lbmdpbmUvZ2VuZXJhbF9wdXJwb3NlL2RlY29kZV9zdWZmaXgucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9jdXJ2ZTI1NTE5LWRhbGVrLTQuMS4zL3NyYy93aW5kb3cucnMAbGlicmFyeS9jb3JlL3NyYy9udW0vZmx0MmRlYy9zdHJhdGVneS9ncmlzdS5ycwBsaWJyYXJ5L2FsbG9jL3NyYy9mbXQucnMAbGlicmFyeS9jb3JlL3NyYy9udW0vZGl5X2Zsb2F0LnJzAGNvanNvbi1jb3JlL3NyYy9jb3JlL2tleXMucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9yYW5kX2NvcmUtMC42LjQvc3JjL29zLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvY3VydmUyNTUxOS1kYWxlay00LjEuMy9zcmMvZWR3YXJkcy5ycwAvVXNlcnMvYW50b25pby5tdXNvbGluby8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvc3RkL3NyYy9zeXMvdGhyZWFkX2xvY2FsL25vX3RocmVhZHMucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9zZXJkZV9qc29uLTEuMC4xNDIvc3JjL2Vycm9yLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2Yvc2VyZGVfanNvbi0xLjAuMTQyL3NyYy9zZXIucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9zaWduYXR1cmUtMi4yLjAvc3JjL3NpZ25lci5ycwAvVXNlcnMvYW50b25pby5tdXNvbGluby8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL2N1cnZlMjU1MTktZGFsZWstNC4xLjMvc3JjL3NjYWxhci5ycwAvVXNlcnMvYW50b25pby5tdXNvbGluby8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvY29yZS9zcmMvc3RyL3BhdHRlcm4ucnMAbGlicmFyeS9jb3JlL3NyYy9udW0vZmx0MmRlYy9zdHJhdGVneS9kcmFnb24ucnMAbGlicmFyeS9jb3JlL3NyYy9udW0vYmlnbnVtLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvY2lwaGVyLTAuNC40L3NyYy9zdHJlYW0ucnMAY29qc29uLWNvcmUvc3JjL2NvcmUvc2Vzc2lvbl9sb2cucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2FsbG9jL3NyYy9zdHJpbmcucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2FsbG9jL3NyYy9jb2xsZWN0aW9ucy9idHJlZS9uYXZpZ2F0ZS5ycwBsaWJyYXJ5L2NvcmUvc3JjL3VuaWNvZGUvcHJpbnRhYmxlLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vL1dvcmtzcGFjZS9naXRodWIvamF6ei9jcmF0ZXMvY29qc29uLWNvcmUvc3JjL2NvcmUvY2FjaGUucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2FsbG9jL3NyYy9jb2xsZWN0aW9ucy9idHJlZS9ub2RlLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvYnM1OC0wLjUuMS9zcmMvZW5jb2RlLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvYmFzZTY0LTAuMjIuMS9zcmMvZW5jb2RlLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvYmFzZTY0LTAuMjIuMS9zcmMvZW5naW5lL2dlbmVyYWxfcHVycG9zZS9kZWNvZGUucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9iczU4LTAuNS4xL3NyYy9kZWNvZGUucnMAY29qc29uLWNvcmUvc3JjL2NvcmUvbm9uY2UucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9oYXNoYnJvd24tMC4xNS41L3NyYy9yYXcvbW9kLnJzAGxpYnJhcnkvY29yZS9zcmMvZm10L21vZC5ycwAvVXNlcnMvYW50b25pby5tdXNvbGluby8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL2Jhc2U2NC0wLjIyLjEvc3JjL2VuZ2luZS9nZW5lcmFsX3B1cnBvc2UvbW9kLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvYmFzZTY0LTAuMjIuMS9zcmMvZW5naW5lL21vZC5ycwBsaWJyYXJ5L2FsbG9jL3NyYy9yYXdfdmVjL21vZC5ycwBsaWJyYXJ5L2NvcmUvc3JjL251bS9mbHQyZGVjL21vZC5ycwAvVXNlcnMvYW50b25pby5tdXNvbGluby8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL3NlcmRlX2pzb24tMS4wLjE0Mi9zcmMvcmVhZC5ycwAvcnVzdC9kZXBzL2RsbWFsbG9jLTAuMi4xMC9zcmMvZGxtYWxsb2MucnMAbGlicmFyeS9zdGQvc3JjL2FsbG9jLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvYXJyYXl2ZWMtMC43LjYvc3JjL2FycmF5dmVjLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvZm9sZGhhc2gtMC4xLjUvc3JjL2xpYi5ycwAvVXNlcnMvYW50b25pby5tdXNvbGluby8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL29uY2VfY2VsbC0xLjIxLjMvc3JjL2xpYi5ycwAvVXNlcnMvYW50b25pby5tdXNvbGluby8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL2JsYWtlMy0xLjguMi9zcmMvbGliLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvbHJ1LTAuMTYuMS9zcmMvbGliLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvY3J5cHRvX3NlY3JldGJveC0wLjEuMS9zcmMvbGliLnJzAAAAAF8OEABiAAAAlAEAADYAAABIYXNoIHRhYmxlIGNhcGFjaXR5IG92ZXJmbG93RA8QABwAAABWChAAbAAAACUAAAAoAAAA//////////94DxAAQZCfwAALiQJ9RXhwZWN0ZWQgcHJpdmF0ZSB0cmFuc2FjdGlvbnNpZ25hdHVyZWVuY3J5cHRlZF9jaGFuZ2VzbWV0YUpzVmFsdWUgRXJyb3I6IAAAyw8QAA8AAACoBxAAUgAAAAgAAAARAAAAYXR0ZW1wdGVkIHRvIHRha2Ugb3duZXJzaGlwIG9mIFJ1c3QgdmFsdWUgd2hpbGUgaXQgd2FzIGJvcnJvd2VkSW52YWxpZCBzaWduYXR1cmUgbGVuZ3RoSW52YWxpZCBzaWduaW5nIGtleSBsZW5ndGhJbnZhbGlkIHZlcmlmeWluZyBrZXkgbGVuZ3RoAAAAAgAAAAwAAAAEAAAAAwAAAAQAAAAFAEGkocAAC/EDAQAAAAYAAABhIERpc3BsYXkgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3IgdW5leHBlY3RlZGx5AH4GEAB3AAAASwsAAA4AAABFcnJvckludmFsaWQgVVRGLTggaW4gc2VjcmV0OiAAAPkQEAAZAAAASW52YWxpZCBVVEYtOCBpbiBzaWduYXR1cmU6IBwREAAcAAAASW52YWxpZCBVVEYtOCBpbiBpZDogAAAAQBEQABUAAAAAAAAABAAAAAQAAAAIAAAAAAAAAAQAAAAEAAAACQAAAFV0ZjhFcnJvcnZhbGlkX3VwX3RvZXJyb3JfbGVuYXR0ZW1wdGVkIHRvIHRha2Ugb3duZXJzaGlwIG9mIFJ1c3QgdmFsdWUgd2hpbGUgaXQgd2FzIGJvcnJvd2VkZ+YJaoWuZ7ty8248OvVPpX9SDlGMaAWbq9mDHxnN4Fu+DBAAawAAAHsEAAAPAAAAAAAAAAQAAAAEAAAACgAAAE5vbmVTb21laW50ZXJuYWwgZXJyb3I6IGVudGVyZWQgdW5yZWFjaGFibGUgY29kZd8DEABqAAAAgQIAACoAAABJbnZhbGlkIFVURi04IGluIHNlY3JldDogAAAAXBIQABkAAAAMAAAADAAAAAQAAAANAAAADgAAAAUAQaClwAAL/wMBAAAADwAAAGEgRGlzcGxheSBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvciB1bmV4cGVjdGVkbHkAfgYQAHcAAABLCwAADgAAAEVycm9yAAAAAAAAAAQAAAAEAAAAEAAAAAAAAAAEAAAABAAAAAkAAABVdGY4RXJyb3J2YWxpZF91cF90b2Vycm9yX2xlblZlcmlmeWluZ0tleX0BAAFBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1f////////////////////////////////////////////////////////////Pv//NDU2Nzg5Ojs8Pf////////8AAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGf////8//xobHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIz/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////2VuY3J5cHRlZF9VhRQQAAsAAABwcml2YXRlAEGoqcAAC50JAQAAABIAAABjYWxsZWQgYFJlc3VsdDo6dW53cmFwKClgIG9uIGFuIGBFcnJgIHZhbHVlAPIFEABnAAAAeAAAACcAAAD/////////////////////////////////////////////////////////////////AAECAwQFBgcI/////////wkKCwwNDg8Q/xESExQV/xYXGBkaGxwdHh8g////////ISIjJCUmJygpKiv/LC0uLzAxMjM0NTY3ODn//////zEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXoiaGFzaF96IgAAphUQAAcAAACtFRAAAQAAABMAAAAEAAAABAAAABQAAABaBhAAIwAAANEAAAA2AAAAWgYQACMAAADAAQAAOAAAAFoGEAAjAAAAlQEAADQAAABn5glqha5nu3Lzbjw69U+lf1IOUYxoBZur2YMfGc3gWxUAAAAIAAAABAAAABYAAABJbnZhbGlkIHB1YmxpYyBrZXkAAFoGEAAjAAAAagAAABIAAAAXAAAAFAAAAAQAAAAYAAAAWgYQACMAAABnAAAAGgAAAFByaXZhdGVUcmFuc2FjdGlvbmVuY3J5cHRlZENoYW5nZXNrZXlVc2VkbWFkZUF0bWV0YXByaXZhY3kAAIYWEAAQAAAAlhYQAAcAAACdFhAABgAAAKMWEAAEAAAApxYQAAcAAABUcnVzdGluZ1RyYW5zYWN0aW9uY2hhbmdlcwAA6xYQAAcAAACdFhAABgAAAKMWEAAEAAAApxYQAAcAAABkYXRhIGRpZCBub3QgbWF0Y2ggYW55IHZhcmlhbnQgb2YgdW50YWdnZWQgZW51bSBUcmFuc2FjdGlvbnN0cnVjdCBQcml2YXRl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C7UBAQAAADEAAABhIERpc3BsYXkgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3IgdW5leHBlY3RlZGx5AH4GEAB3AAAASwsAAA4AAABFcnJvcgAAAN0HEAAdAAAAGQAAADEAAADdBxAAHQAAACcAAAA4AAAAgwgQAGUAAADRAQAAEAAAAIMIEABlAAAA0AEAABsAAACDCBAAZQAAAMwBAAAJAAAAgwgQAGUAAAC5AQAAIABBwL7AAAv1BAEAAAAyAAAAY2FsbGVkIGBSZXN1bHQ6OnVud3JhcCgpYCBvbiBhbiBgRXJyYCB2YWx1ZQCDCBAAZQAAAD0BAAAgAAAAQnVmZmVyVG9vU21hbGwAADMAAAAIAAAABAAAABYAAABzaWduYXR1cmUgb3BlcmF0aW9uIGZhaWxlZAAASgQQAGoAAAAQAAAAHAAAAHVzaXplIG92ZXJmbG93IHdoZW4gY2FsY3VsYXRpbmcgYjY0IGxlbmd0aAAA6QgQAGgAAABXAAAACgAAAOkIEABoAAAAUAAAADMAAABIYXNoIHRhYmxlIGNhcGFjaXR5IG92ZXJmbG93HCAQABwAAABWChAAbAAAACUAAAAoAAAAc2VhbGVyU2VjcmV0X3pzZWFsZXIgc2VjcmV0/////////////////////////////////////////////////////////////////wABAgMEBQYHCP////////8JCgsMDQ4PEP8REhMUFf8WFxgZGhscHR4fIP///////yEiIyQlJicoKSor/ywtLi8wMTIzNDU2Nzg5//////8xMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6c2VhbGVyX3oAAAAlIRAACAAAAGtleVNlY3JldF96a2V5IHNlY3JldHNpZ25lclNlY3JldF96c2lnbmVyIHNlY3JldHNpZ25lcl96aCEQAAgAAABzaWduYXR1cmVfegB4IRAACwAAAHNpZ25hdHVyZXNpZ25lciBJRAAANQAAAAwAAAAEAAAANgAAADcAAAAwAEHAw8AAC9kDAQAAADgAAABhIERpc3BsYXkgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3IgdW5leHBlY3RlZGx5AH4GEAB3AAAASwsAAA4AAABFcnJvcgAAADUAAAAMAAAABAAAADkAAAAAAAAABAAAAAQAAAA6AAAARnJvbVV0ZjhFcnJvcmJ5dGVzZXJyb3IAOwAAABQAAAAEAAAAPAAAAGNhbGxlZCBgUmVzdWx0Ojp1bndyYXAoKWAgb24gYW4gYEVycmAgdmFsdWUAgwgQAGUAAACTAAAAKwAAAHNlYWxlclNlY3JldF96c2VhbGVyIHNlY3JldP////////////////////////////////////////////////////////////////8AAQIDBAUGBwj/////////CQoLDA0ODxD/ERITFBX/FhcYGRobHB0eHyD///////8hIiMkJSYnKCkqK/8sLS4vMDEyMzQ1Njc4Of//////MTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5enNlYWxlcl96c2VhbGVyIElEAAA9AAAADAAAAAQAAAA+AAAAPwAAADAAQaTHwAAL4Q8BAAAAQAAAAGEgRGlzcGxheSBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvciB1bmV4cGVjdGVkbHkAfgYQAHcAAABLCwAADgAAAEVycm9yAAAAAAAAAAQAAAAEAAAAQQAAAAAAAAAEAAAABAAAAEIAAABJbnZhbGlkQnl0ZQAAAAAABAAAAAQAAAAfAAAASW52YWxpZExlbmd0aEludmFsaWRMYXN0U3ltYm9sSW52YWxpZFBhZGRpbmf/////////////////////////////////////////////////////////////////AAECAwQFBgcI/////////wkKCwwNDg8Q/xESExQV/xYXGBkaGxwdHh8g////////ISIjJCUmJygpKiv/LC0uLzAxMjM0NTY3ODn//////zEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpzaWduYXR1cmVfegAAAB4lEAALAAAAbWlzc2luZyBmaWVsZCBgYDQlEAAPAAAAQyUQAAEAAABpbnZhbGlkIGxlbmd0aCAsIGV4cGVjdGVkIAAAVCUQAA8AAABjJRAACwAAAGR1cGxpY2F0ZSBm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cmU6IFZ4V29ya3MgUk5HIG1vZHVsZSBpcyBub3QgaW5pdGlhbGl6ZWROb2RlLmpzIGNyeXB0byBDb21tb25KUyBtb2R1bGUgaXMgdW5hdmFpbGFibGVDYWxsaW5nIE5vZGUuanMgQVBJIGNyeXB0by5yYW5kb21GaWxsU3luYyBmYWlsZWROb2RlLmpzIEVTIG1vZHVsZXMgYXJlIG5vdCBkaXJlY3RseSBzdXBwb3J0ZWQsIHNlZSBodHRwczovL2RvY3MucnMvZ2V0cmFuZG9tI25vZGVqcy1lcy1tb2R1bGUtc3VwcG9ydAAAAAAAAAQAAAAEAAAAZwAAAGludGVybmFsX2NvZGUAAAAAAAAACAAAAAQAAABoAAAAZGVzY3JpcHRpb251bmtub3duX2NvZGUAAAAAAAQAAAAEAAAAaQAAAG9zX2Vycm9yVW5rbm93biBFcnJvcjogAMDMEAAPAAAAT1MgRXJyb3I6IAAA2MwQAAoAAABjcnlwdG8AABHKEAA4yhAAXsoQAHLKEACkyhAA0coQAADLEAAhyxAAPssQAEGgmsMACzFryxAAnMsQAMnLEAD5yxAAJwAAACYAAAAUAAAAMgAAAC0AAAAvAAAAIQAAAB0AAAAtAEHcmsMAC70GMQAAAC0AAAAwAAAAZQAAAKwxEQC4MREAxDERANAxEQByZXR1cm4gdGhpc0xhenkgaW5zdGFuY2UgaGFzIHByZXZpb3VzbHkgYmVlbiBwb2lzb25lZAAAAIfNEAAqAAAAkQ0QAGgAAAAIAwAAGQAAAHJlZW50cmFudCBpbml0AADMzRAADgAAAJENEABoAAAAegIAAA0AAABjbG9zdXJlIGludm9rZWQgcmVjdXJzaXZlbHkgb3IgYWZ0ZXIgYmVpbmcgZHJvcHBlZG51bGwgcG9pbnRlciBwYXNzZWQgdG8gcnVzdHJlY3Vyc2l2ZSB1c2Ugb2YgYW4gb2JqZWN0IGRldGVjdGVkIHdoaWNoIHdvdWxkIGxlYWQgdG8gdW5zYWZlIGFsaWFzaW5nIGluIHJ1c3RMYXp5IGluc3RhbmNlIGhhcyBwcmV2aW91c2x5IGJlZW4gcG9pc29uZWQAAJDOEAAqAAAAkQ0QAGgAAAAIAwAAGQAAAHJlZW50cmFudCBpbml0AADUzhAADgAAAJENEABoAAAAegIAAA0A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ZiByYW5nZWludmFsaWQgdW5pY29kZSBjb2RlIHBvaW50Y29udHJvbCBjaGFyYWN0ZXIgKFx1MDAwMC1cdTAwMUYpIGZvdW5kIHdoaWxlIHBhcnNpbmcgYSBzdHJpbmdrZXkgbXVzdCBiZSBhIHN0cmluZ2ludmFsaWQgdmFsdWU6IGV4cGVjdGVkIGtleSB0byBiZSBhIG51bWJlciBpbiBxdW90ZXNmbG9hdCBrZXkgbXVzdCBiZSBmaW5pdGUgKGdvdCBOYU4gb3IgKy8taW5mKWxvbmUgbGVhZGluZyBzdXJyb2dhdGUgaW4gaGV4IGVzY2FwZXRyYWlsaW5nIGNvbW1hdHJhaWxpbmcgY2hhcmFjdGVyc3VuZXhwZWN0ZWQgZW5kIG9mIGhleCBlc2NhcGVyZWN1cnNpb24gbGltaXQgZXhjZWVkZWQBAAAAAAAAAEjaEAAJAAAAdNoQAAgAAABmbG9hdGluZyBwb2ludCBgYAAAAHTeEAAQAAAAhN4QAAEAAABudWxsJwUQAHsAAAC9BAAAJAAAAIgAAAAMAAAABAAAAIkAAACKAAAAhgAAAP///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////wAAAQACAAMABAAFAAYABwAIAAkA//////////////////8KAAsADAANAA4ADwD/////////////////////////////////////////////////////////////////////CgALAAwADQAOAA8A////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////AAAQACAAMABAAFAAYABwAIAAkAD//////////////////6AAsADAANAA4ADwAP////////////////////////////////////////////////////////////////////+gALAAwADQAOAA8AD///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8ODBAAawAAALMBAAAaAAAADgwQAGsAAAAAAgAAEwAAAA4MEABrAAAABQIAADMAAAAODBAAawAAAAkCAAA+AAAADgwQAGsAAAAPAgAAOgAAAA4MEABrAAAAqwEAAD0AAAAODBAAawAAAKYBAABFAAAADgwQAGsAAABuAgAAGQAAAGluZi1pbmZOYU51dXV1dXV1dWJ0bnVmcnV1dXV1dXV1dXV1dXV1dXV1dQAAIgBBqsfDAAsBXABBzsjDAAvlATAxMjM0NTY3ODlhYmNkZWZhIEpTT04gbnVtYmVyMDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5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ZyBwb2ludCBgcA8RABAAAAA4DxEAAQAAAGNoYXJhY3RlciBgAJAPEQALAAAAOA8RAAEAAABzdHJpbmcgAKwPEQAHAAAAYnl0ZSBhcnJheXVuaXQgdmFsdWVPcHRpb24gdmFsdWVuZXd0eXBlIHN0cnVjdHNlcXVlbmNlbWFwZW51bXVuaXQgdmFyaWFudG5ld3R5cGUgdmFyaWFudHR1cGxlIHZhcmlhbnRzdHJ1Y3QgdmFyaWFudAABAAAAAAAAAC4wAAAAAAAACAAAAAQAAACRAAAAkgAAAJMAAABhIHN0cmluZ3z9izJX5lf5At9Ev+NI569tXcvWLFDrY3hBpldxG4u5AQAAAAAAAABlbnRpdHkgbm90IGZvdW5kcGVybWlzc2lvbiBkZW5pZWRjb25uZWN0aW9uIHJlZnVzZWRjb25uZWN0aW9uIHJlc2V0aG9zdCB1bnJlYWNoYWJsZW5ldHdvcmsgdW5yZWFjaGFibGVjb25uZWN0aW9uIGFib3J0ZWRub3QgY29ubmVjdGVkYWRkcmVzcyBpbiB1c2VhZGRyZXNzIG5vdCBhdmFpbGFibGVuZXR3b3JrIGRvd25icm9rZW4gcGlwZWVudGl0eSBhbHJlYWR5IGV4aXN0c29wZXJhdGlvbiB3b3VsZCBibG9ja25vdCBhIGRpcmVjdG9yeWlzIGEgZGlyZWN0b3J5ZGlyZWN0b3J5IG5vdCBlbXB0eXJlYWQtb25seSBmaWxlc3lzdGVtIG9yIHN0b3JhZ2UgbWVkaXVtZmlsZXN5c3RlbSBsb29wIG9yIGluZGlyZWN0aW9uIGxpbWl0IChlLmcuIHN5bWxpbmsgbG9vcClzdGFsZSBuZXR3b3JrIGZpbGUgaGFuZGxlaW52YWxpZCBpbnB1dCBwYXJhbWV0ZXJpbnZhbGlkIGRhdGF0aW1lZCBvdXR3cml0ZSB6ZXJvbm8gc3RvcmFnZSBzcGFjZXNlZWsgb24gdW5zZWVrYWJsZSBmaWxlcXVvdGEgZXhjZWVkZWRmaWxlIHRvbyBsYXJnZXJlc291cmNlIGJ1c3lleGVjdXRhYmxlIGZpbGUgYnVzeWRlYWRsb2NrY3Jvc3MtZGV2aWNlIGxpbmsgb3IgcmVuYW1ldG9vIG1hbnkgbGlua3NpbnZhbGlkIGZpbGVuYW1lYXJndW1lbnQgbGlz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";
async function rB() {
  const A = await (await fetch(ea)).arrayBuffer();
  return await Aa({ module_or_path: A });
}
function nB(i) {
  if (typeof Buffer < "u")
    return Buffer.from(i, "base64").buffer;
  if (typeof globalThis < "u" && typeof globalThis.atob == "function") {
    const A = globalThis.atob(i), e = new Uint8Array(A.length);
    for (let t = 0; t < A.length; t++) e[t] = A.charCodeAt(t);
    return e.buffer;
  }
  throw new Error("Unable to decode base64 WASM payload: no atob() or Buffer available.");
}
function sB() {
  const i = ea.split(",")[1], A = nB(i);
  return gB({ module: A });
}
function ta() {
  return (
    // @ts-ignore
    !!(typeof navigator < "u" && // @ts-ignore
    navigator?.userAgent?.includes("Cloudflare"))
  );
}
const aB = () => {
  if (ta())
    return !1;
  try {
    const i = Function;
    return new i(""), !0;
  } catch {
    return !1;
  }
};
let ia = rB, Mr = sB;
const oa = (i) => `Critical Error: Failed to load WASM module

${aB() ? i.message : `You need to add \`import "jazz-tools/load-edge-wasm";\` on top of your entry module to make Jazz work with ${ta() ? "Cloudflare workers" : "this runtime"}`}

A native crypto module is required for Jazz to work. See https://jazz.tools/docs/react/reference/performance#use-the-best-crypto-implementation-for-your-platform for possible alternatives.`;
async function IB() {
  try {
    await ia();
  } catch (i) {
    throw new Error(oa(i), { cause: i });
  }
}
class ie extends KC {
  constructor() {
    super();
  }
  static setInit(A) {
    ia = A;
  }
  static setInitSync(A) {
    Mr = A;
  }
  static createSync() {
    try {
      Mr();
    } catch (A) {
      throw new Error(oa(A), { cause: A });
    }
    return new ie();
  }
  // TODO: Remove this method and use createSync instead, this is not necessary since we can use createSync in the browser and in the worker.
  // @deprecated
  static async create() {
    return await IB(), new ie();
  }
  blake3HashOnce(A) {
    return $c(A);
  }
  blake3HashOnceWithContext(A, { context: e }) {
    return Zc(A, e);
  }
  newEd25519SigningKey() {
    return jc();
  }
  getSignerID(A) {
    return Vc(fA.encode(A));
  }
  sign(A, e) {
    return Wc(fA.encode(bA(e)), fA.encode(A));
  }
  verify(A, e, t) {
    return zc(fA.encode(A), fA.encode(bA(e)), fA.encode(t));
  }
  newX25519StaticSecret() {
    return iB();
  }
  getSealerID(A) {
    return tB(fA.encode(A));
  }
  encrypt(A, e, t) {
    return `encrypted_U${Po(AB(fA.encode(bA(A)), e, fA.encode(bA(t))))}`;
  }
  decryptRaw(A, e, t) {
    return Cr.decode(eB(Oo(A.substring(11)), e, fA.encode(bA(t))));
  }
  seal({ message: A, from: e, to: t, nOnceMaterial: o }) {
    return `sealed_U${Po(Xc(fA.encode(bA(A)), e, t, fA.encode(bA(o))))}`;
  }
  unseal(A, e, t, o) {
    const g = Cr.decode(_c(Oo(A.substring(8)), e, t, fA.encode(bA(o))));
    try {
      return JSON.parse(g);
    } catch (r) {
      Z.error("Failed to decrypt/parse sealed message", { err: r });
      return;
    }
  }
  createSessionLog(A, e, t) {
    return new vg(new zi(A, e, t));
  }
}
class vg {
  constructor(A) {
    this.sessionLog = A;
  }
  tryAdd(A, e, t) {
    for (const o of A)
      o.privacy === "private" ? this.sessionLog.addExistingPrivateTransaction(o.encryptedChanges, o.keyUsed, o.madeAt, o.meta) : this.sessionLog.addExistingTrustingTransaction(o.changes, o.madeAt, o.meta);
    this.sessionLog.commitTransactions(e, t);
  }
  addNewPrivateTransaction(A, e, t, o, g, r) {
    const n = this.sessionLog.addNewPrivateTransaction(
      // We can avoid stableStringify because it will be encrypted.
      JSON.stringify(e),
      A.currentSignerSecret(),
      o,
      t,
      g,
      // We can avoid stableStringify because it will be encrypted.
      r ? JSON.stringify(r) : void 0
    ), s = JSON.parse(n), a = {
      privacy: "private",
      madeAt: g,
      encryptedChanges: s.encrypted_changes,
      keyUsed: t,
      meta: s.meta
    };
    return { signature: s.signature, transaction: a };
  }
  addNewTrustingTransaction(A, e, t, o) {
    const g = JSON.stringify(e), r = o ? JSON.stringify(o) : void 0;
    return { signature: this.sessionLog.addNewTrustingTransaction(g, A.currentSignerSecret(), t, r), transaction: {
      privacy: "trusting",
      madeAt: t,
      changes: g,
      meta: r
    } };
  }
  decryptNextTransactionChangesJson(A, e) {
    return this.sessionLog.decryptNextTransactionChangesJson(A, e);
  }
  decryptNextTransactionMetaJson(A, e) {
    return this.sessionLog.decryptNextTransactionMetaJson(A, e);
  }
  free() {
    this.sessionLog.free();
  }
  clone() {
    return new vg(this.sessionLog.clone());
  }
}
const ga = { comap: { description: "CoMap - CRDT-based collaborative map/object", type: "object", properties: {}, additionalProperties: { anyOf: [{ type: "string", description: "Standard string value" }, { type: "number", description: "Standard number value" }, { type: "integer", description: "Standard integer value" }, { type: "boolean", description: "Standard boolean value" }, { type: "null", description: "Null value" }, { type: "object", description: "Nested object value" }, { type: "array", description: "Array value" }, { type: "string", pattern: "^co_z[a-zA-Z0-9]+$", description: "Co-id reference to another CoValue" }, { type: "string", pattern: "^key_[a-zA-Z0-9_]+$", description: "Key reference" }, { type: "string", pattern: "^sealed_", description: "Sealed/encrypted value" }] } }, costream: { description: "CoStream - CRDT-based append-only stream", type: "array", items: { anyOf: [{ type: "object", description: "Stream item object" }, { type: "string", description: "Stream item string" }, { type: "number", description: "Stream item number" }, { type: "boolean", description: "Stream item boolean" }, { type: "null", description: "Stream item null" }] } }, colist: { description: "CoList - CRDT-based collaborative list/array", type: "array", items: { anyOf: [{ type: "object", description: "List item object" }, { type: "string", description: "List item string (can be co-id reference)" }, { type: "number", description: "List item number" }, { type: "integer", description: "List item integer" }, { type: "boolean", description: "List item boolean" }, { type: "null", description: "List item null" }, { type: "array", description: "Nested array" }] } } }, Ft = {
  $defs: ga
}, CB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  $defs: ga,
  default: Ft
}, Symbol.toStringTag, { value: "Module" }));
let mA = class {
  constructor(A) {
    this._value = A, this._subscribers = /* @__PURE__ */ new Set(), this._unsubscribe = null;
  }
  /**
   * Get current value
   * @returns {any} Current store value
   */
  get value() {
    return this._value;
  }
  /**
   * Subscribe to value changes
   * Callback is called immediately with current value, then on every update
   * Automatically calls _unsubscribe() when the last subscriber unsubscribes
   * @param {Function} callback - Function called with new value
   * @param {Object} [options] - Subscription options
   * @param {boolean} [options.skipInitial=false] - If true, don't call callback immediately with current value
   * @returns {Function} Unsubscribe function
   */
  subscribe(A, e = {}) {
    return this._subscribers.add(A), e.skipInitial || A(this._value), () => {
      this._subscribers.delete(A), this._subscribers.size === 0 && this._unsubscribe && this._unsubscribe();
    };
  }
  /**
   * Internal method to update store value
   * Notifies all subscribers of the change
   * @param {any} newValue - New value to set
   * @private
   */
  _set(A) {
    this._value = A, this._subscribers.forEach((e) => e(A));
  }
};
async function cB(i, A) {
  return !A || typeof A != "string" ? null : await oA(i, A, { returnType: "coId" });
}
async function ra(i, A) {
  const e = await cB(i, A);
  if (!e)
    return console.warn(`[getSchemaIndexColistId]  Failed to resolve schema "${A.substring(0, 30)}..." to co-id`), null;
  const t = i.account.get("os");
  if (!t)
    return console.warn("[getSchemaIndexColistId]  account.os not found"), null;
  const o = await IA(i, t);
  if (!o || !i.isAvailable(o))
    return console.warn(`[getSchemaIndexColistId]  account.os not available (loaded: ${!!o}, available: ${o ? i.isAvailable(o) : !1})`), null;
  const g = i.getCurrentContent(o);
  if (!g || typeof g.get != "function")
    return console.warn("[getSchemaIndexColistId]  account.os content not available"), null;
  const r = g.get("indexes");
  if (!r)
    return console.warn("[getSchemaIndexColistId]  account.os.indexes not found"), null;
  const n = await IA(i, r);
  if (!n || !i.isAvailable(n))
    return console.warn(`[getSchemaIndexColistId]  account.os.indexes not available (loaded: ${!!n}, available: ${n ? i.isAvailable(n) : !1})`), null;
  const s = i.getCurrentContent(n);
  if (!s || typeof s.get != "function")
    return console.warn("[getSchemaIndexColistId]  account.os.indexes content not available"), null;
  let a = s.get(e);
  if (a && typeof a == "string" && a.startsWith("co_"))
    return a;
  try {
    const { ensureSchemaIndexColist: I } = await Promise.resolve().then(() => mu), C = await I(i, e);
    return C && C.id ? C.id : null;
  } catch {
    return null;
  }
}
async function Ug(i, A) {
  return !A || typeof A != "string" ? null : !A.startsWith("co_z") && !A.startsWith("@schema/") ? (console.warn(`[getCoListId]  Invalid collection identifier: "${A}". Must be schema co-id (co_z...) or namekey (@schema/...). Use schema registry to resolve collection names.`), null) : await ra(i, A);
}
async function IA(i, A, e = {}) {
  const { waitForAvailable: t = !1, timeoutMs: o = 2e3 } = e;
  if (!A || !A.startsWith("co_"))
    return null;
  const g = i.getCoValue(A);
  return g ? (g.isAvailable() || (i.node.loadCoValueCore(A).catch((r) => {
    console.error(`[CoJSONBackend] Failed to load CoValue ${A}:`, r);
  }), t && await new Promise((r, n) => {
    let s;
    const a = setTimeout(() => {
      console.warn(`[CoJSONBackend] Timeout waiting for CoValue ${A} to load`), s(), n(new Error(`Timeout waiting for CoValue ${A} to load after ${o}ms`));
    }, o);
    s = g.subscribe((I) => {
      I.isAvailable() && (clearTimeout(a), s(), r());
    });
  })), g) : null;
}
function Jg(i, A, e = null) {
  const t = i.getCurrentContent(A), o = i.getHeader(A), g = o?.meta || null, r = A.ruleset || o?.ruleset, n = t?.type || "unknown";
  let s = g?.$schema || null;
  if (e === "@group" || r && r.type === "group" ? s = "@group" : e === "@account" || g && g.type === "account" ? s = "@account" : (e === "@meta-schema" || s === "GenesisSchema") && (s = "@meta-schema"), n === "colist" && t && t.toJSON)
    try {
      const a = t.toJSON();
      return {
        id: A.id,
        $schema: s,
        // Use $schema for consistency with headerMeta.$schema
        type: "colist",
        items: a
        // Items ARE the CoList content (not a property)
        // No properties array - CoLists don't have custom key-value properties, only items
      };
    } catch {
      return {
        id: A.id,
        $schema: s,
        // Use $schema for consistency with headerMeta.$schema
        type: "colist",
        items: []
      };
    }
  else if (n === "costream" && t)
    try {
      const a = t.toJSON(), I = [];
      if (a && typeof a == "object" && !(a instanceof Uint8Array))
        for (const C in a)
          Array.isArray(a[C]) && I.push(...a[C]);
      return console.log(`[CoJSONBackend]  Read CoStream ${A.id} (${I.length} items)`), I.length > 0 ? console.log("[CoJSONBackend]   First item:", JSON.stringify(I[0]).substring(0, 100)) : (console.log("[CoJSONBackend]   Stream data type:", typeof a, a instanceof Uint8Array ? "Uint8Array" : "object"), a && typeof a == "object" && !(a instanceof Uint8Array) && (console.log("[CoJSONBackend]   Session keys:", Object.keys(a)), console.log("[CoJSONBackend]   Session counts:", Object.fromEntries(Object.entries(a).map(([C, c]) => [C, Array.isArray(c) ? c.length : "not array"]))))), {
        id: A.id,
        schema: s,
        type: "costream",
        items: I
        // Items ARE the CoStream content (not a property)
        // No properties array - CoStreams don't have custom key-value properties, only items
      };
    } catch (a) {
      return console.error(`[CoJSONBackend]  Error reading CoStream ${A.id.substring(0, 12)}...:`, a), {
        id: A.id,
        $schema: s,
        // Use $schema for consistency with headerMeta.$schema
        type: "costream",
        items: []
      };
    }
  else if (t && t.get && typeof t.get == "function") {
    const a = g?.type || null, I = {
      id: A.id,
      // Always add id field (derived from co-id)
      $schema: s,
      // Use $schema for consistency with headerMeta.$schema
      type: n,
      // Add type for DB viewer
      displayName: a === "account" ? "Account" : s || "CoMap",
      // Display name for DB viewer
      properties: []
      // Properties array for DB viewer
    };
    a && (I.headerMeta = { type: a });
    const C = t.keys && typeof t.keys == "function" ? t.keys() : Object.keys(t);
    for (const c of C)
      try {
        const Q = t.get && typeof t.get == "function" ? t.get(c) : t[c];
        let d = typeof Q, f = Q;
        typeof Q == "string" && Q.startsWith("co_") ? d = "co-id" : typeof Q == "string" && Q.startsWith("key_") ? d = "key" : typeof Q == "string" && Q.startsWith("sealed_") ? (d = "sealed", f = "sealed_***") : Q === null ? d = "null" : Q === void 0 ? d = "undefined" : typeof Q == "object" && Q !== null ? (d = "object", f = JSON.stringify(Q)) : Array.isArray(Q) && (d = "array", f = JSON.stringify(Q)), I.properties.push({
          key: c,
          value: f,
          type: d
        });
      } catch (Q) {
        I.properties.push({
          key: c,
          value: `<error: ${Q.message}>`,
          type: "error"
        });
      }
    return I;
  }
  return {
    id: A.id,
    type: n,
    $schema: s,
    headerMeta: g
  };
}
function ut(i) {
  if (typeof i == "string" && (i.startsWith("{") || i.startsWith("[")))
    try {
      const A = JSON.parse(i);
      return ut(A);
    } catch {
      return i;
    }
  else {
    if (Array.isArray(i))
      return i.map((A) => ut(A));
    if (typeof i == "object" && i !== null) {
      const A = {};
      for (const [e, t] of Object.entries(i))
        A[e] = ut(t);
      return A;
    }
  }
  return i;
}
function ne(i, A, e = null) {
  const t = i.getHeader(A), o = t?.meta || null;
  A.ruleset || t?.ruleset;
  const g = e === "@account" || o && o.type === "account" || i.account && i.account.id === A.id;
  if (g && i.account && i.account.id === A.id) {
    const c = (i.getHeader(A)?.meta || null)?.$schema || null, Q = {
      id: i.account.id,
      type: "comap",
      // Accounts are CoMaps
      $schema: c
      // Include $schema for metadata lookup
    };
    try {
      const d = i.account.keys && typeof i.account.keys == "function" ? i.account.keys() : Object.keys(i.account);
      for (const f of d)
        try {
          Q[f] = i.account.get(f);
        } catch (h) {
          console.warn(`[CoJSONBackend] Failed to read account key ${f}:`, h);
        }
    } catch (d) {
      console.warn("[CoJSONBackend] Failed to extract account keys:", d);
    }
    return Q;
  }
  const r = i.getCurrentContent(A);
  if (!r) {
    if (g && i.account && i.account.id === A.id) {
      const f = (i.getHeader(A)?.meta || null)?.$schema || null, h = {
        id: i.account.id,
        type: "comap",
        $schema: f
      };
      try {
        const l = i.account.keys && typeof i.account.keys == "function" ? i.account.keys() : Object.keys(i.account);
        for (const B of l)
          h[B] = i.account.get(B);
      } catch {
      }
      return h;
    }
    const c = (i.getHeader(A)?.meta || null)?.$schema || null;
    return {
      id: A.id,
      type: "unknown",
      $schema: c
    };
  }
  const n = r?.type || "unknown", s = o?.$schema || null;
  if (n === "colist" && r && r.toJSON)
    try {
      const I = r.toJSON();
      return {
        id: A.id,
        type: "colist",
        $schema: s,
        items: I
      };
    } catch {
      return {
        id: A.id,
        type: "colist",
        $schema: s,
        items: []
      };
    }
  if (n === "costream" && r)
    try {
      const I = r.toJSON(), C = [];
      if (I && typeof I == "object" && !(I instanceof Uint8Array))
        for (const c in I)
          Array.isArray(I[c]) && C.push(...I[c]);
      return {
        id: A.id,
        type: "costream",
        $schema: s,
        items: C
      };
    } catch (I) {
      return console.error(`[CoJSONBackend] Error extracting CoStream ${A.id.substring(0, 12)}...:`, I), {
        id: A.id,
        type: "costream",
        $schema: s,
        items: []
      };
    }
  if (r && r.get && typeof r.get == "function") {
    const I = r.get("cotype"), C = r.get("title"), c = r.get("properties"), Q = r.get("items"), f = {
      // Only include 'id' and 'type' for non-schema co-values
      // Schemas are content-addressable by co-ID and use 'cotype', not 'type'
      ...s === "GenesisSchema" || I || C || c || Q ? {} : {
        id: A.id,
        type: n === "comap" ? "comap" : n
      },
      $schema: s
      // Include $schema for metadata lookup
    }, h = r.keys && typeof r.keys == "function" ? r.keys() : Object.keys(r);
    for (const l of h) {
      let B = r.get(l);
      (l === "allMessages" || s && s.includes("context")) && console.log(`[extractCoValueDataFlat]  Raw value for key "${l}":`, {
        type: typeof B,
        isString: typeof B == "string",
        isObject: typeof B == "object" && B !== null,
        startsWithBrace: typeof B == "string" && B.startsWith("{"),
        valueSample: typeof B == "string" ? B.substring(0, 200) : typeof B == "object" ? JSON.stringify(B).substring(0, 200) : B,
        hasOptions: typeof B == "object" && B !== null ? "options" in B : !1,
        optionsType: typeof B == "object" && B !== null && "options" in B ? typeof B.options : "N/A"
      });
      const u = ["error", "message", "content"];
      if (typeof B == "string" && (B.startsWith("{") || B.startsWith("[")) && !u.includes(l))
        try {
          const y = JSON.parse(B);
          console.log(`[extractCoValueDataFlat]  Parsed JSON string for "${l}":`, {
            parsedType: typeof y,
            parsedKeys: typeof y == "object" && y !== null ? Object.keys(y) : [],
            hasOptions: typeof y == "object" && y !== null ? "options" in y : !1,
            optionsType: typeof y == "object" && y !== null && "options" in y ? typeof y.options : "N/A",
            parsedSample: JSON.stringify(y).substring(0, 300)
          }), B = ut(y), console.log(`[extractCoValueDataFlat]  After recursive parse for "${l}":`, {
            finalType: typeof B,
            finalKeys: typeof B == "object" && B !== null ? Object.keys(B) : [],
            hasOptions: typeof B == "object" && B !== null ? "options" in B : !1,
            optionsKeys: typeof B == "object" && B !== null && "options" in B && typeof B.options == "object" ? Object.keys(B.options) : [],
            hasMap: typeof B == "object" && B !== null && "options" in B && typeof B.options == "object" ? "map" in B.options : !1,
            finalSample: JSON.stringify(B).substring(0, 400)
          });
        } catch (y) {
          console.warn(`[extractCoValueDataFlat] Failed to parse JSON string for "${l}":`, y);
        }
      else if (typeof B == "object" && B !== null && !Array.isArray(B)) {
        if (l === "allMessages" || s && s.includes("context")) {
          const w = "options" in B, p = w ? typeof B.options : "N/A", N = w && typeof B.options == "string" && (B.options.startsWith("{") || B.options.startsWith("["));
          console.log(`[extractCoValueDataFlat]  Before recursive parse for "${l}":`, {
            hasOptions: w,
            optionsType: p,
            optionsIsString: N,
            optionsValue: w ? typeof B.options == "string" ? B.options.substring(0, 200) : JSON.stringify(B.options).substring(0, 200) : "N/A",
            allKeys: Object.keys(B)
          });
        }
        const y = JSON.stringify(B).substring(0, 200);
        B = ut(B);
        const E = JSON.stringify(B).substring(0, 200);
        if (l === "allMessages" || s && s.includes("context")) {
          const w = "options" in B, p = w ? typeof B.options : "N/A", N = w && typeof B.options == "object" && B.options !== null ? "map" in B.options : !1;
          console.log(`[extractCoValueDataFlat]  After recursive parse for "${l}":`, {
            hasOptions: w,
            optionsType: p,
            hasMap: N,
            optionsKeys: w && typeof B.options == "object" && B.options !== null ? Object.keys(B.options) : [],
            mapKeys: N ? Object.keys(B.options.map) : [],
            changed: y !== E,
            finalSample: JSON.stringify(B).substring(0, 400)
          });
        }
      }
      f[l] = B;
    }
    try {
      if (typeof i.getGroupInfo == "function") {
        const l = i.getGroupInfo(A);
        l && (f.groupInfo = l);
      }
    } catch (l) {
      console.warn("[extractCoValueDataFlat] Failed to get group info:", l);
    }
    return f;
  }
  const a = {
    id: A.id,
    type: n,
    $schema: s
  };
  try {
    if (typeof i.getGroupInfo == "function") {
      const I = i.getGroupInfo(A);
      I && (a.groupInfo = I);
    }
  } catch {
  }
  return a;
}
async function $e(i, A, e = {}, t = /* @__PURE__ */ new Set(), o = 10, g = 0) {
  const { fields: r = null, schemas: n = null, timeoutMs: s = 2e3 } = e;
  if (g > o || A == null)
    return A;
  if (typeof A != "object")
    return typeof A == "string" && A.startsWith("co_z") ? await Gr(i, A, e, t, o, g) : A;
  if (Array.isArray(A))
    return Promise.all(A.map(
      (I) => $e(i, I, e, t, o, g + 1)
    ));
  const a = {};
  for (const [I, C] of Object.entries(A)) {
    if (I === "id" || I === "$schema" || I === "type" || I === "loading" || I === "error") {
      a[I] = C;
      continue;
    }
    const c = r === null || r.includes(I);
    if (C == null) {
      a[I] = C;
      continue;
    }
    if (c && typeof C == "string" && C.startsWith("co_z")) {
      const Q = await Gr(i, C, { ...e, timeoutMs: s, maxDepth: o, currentDepth: g }, t, o, g + 1);
      a[I] = Q;
    } else
      a[I] = await $e(i, C, e, t, o, g + 1);
  }
  return a;
}
async function Gr(i, A, e = {}, t = /* @__PURE__ */ new Set(), o = 10, g = 0) {
  const { schemas: r = null, timeoutMs: n = 2e3 } = e;
  if (t.has(A))
    return { id: A };
  const s = i.subscriptionCache, a = {
    deepResolve: !1,
    // We don't need deep resolution here
    resolveReferences: e,
    // Use the same resolution options
    map: null,
    // No map transform in resolveCoId
    maxDepth: o,
    timeoutMs: n
  }, I = s.getResolvedData(A, a);
  if (I) {
    if (r !== null && r.length > 0) {
      const C = I.$schema;
      if (!r.includes(C))
        return { id: A };
    }
    return I;
  }
  try {
    const { waitForStoreReady: C } = await Promise.resolve().then(() => wB), c = await i.read(null, A, null, null, {
      deepResolve: !1,
      // Don't deep resolve here - we'll resolve nested refs ourselves
      timeoutMs: n
    });
    if (!c)
      return console.warn(`[resolveCoId] No store returned for ${A.substring(0, 12)}...`), { id: A };
    try {
      await C(c, A, n);
    } catch (h) {
      return console.warn(`[resolveCoId] Store not ready for ${A.substring(0, 12)}...:`, h.message), { id: A };
    }
    const Q = c.value;
    if (!Q)
      return console.warn(`[resolveCoId] No data in store for ${A.substring(0, 12)}...`), { id: A };
    if (Q.error)
      return console.warn(`[resolveCoId] Store has error for ${A.substring(0, 12)}...:`, Q.error), { id: A, error: Q.error };
    if (typeof Q != "object" || Array.isArray(Q))
      return console.warn(`[resolveCoId] Invalid data type for ${A.substring(0, 12)}...:`, typeof Q), { id: A };
    if (r !== null && r.length > 0) {
      const h = Q.$schema;
      if (!r.includes(h))
        return { id: A };
    }
    t.add(A);
    const d = await $e(
      i,
      Q,
      e,
      t,
      o,
      g + 1
    ), f = {
      ...d,
      id: d.id || Q.id || A
    };
    return s.setResolvedData(A, a, f), f;
  } catch (C) {
    return console.error(`[resolveCoId]  Error resolving ${A.substring(0, 12)}...:`, C), { id: A };
  }
}
function BB(i, A) {
  const e = i.getCurrentContent(A), o = i.getHeader(A)?.meta || null;
  if ((e?.type || "unknown") !== "costream" || !e)
    return null;
  if (e.items && typeof e.items == "object") {
    const r = {};
    for (const [n, s] of Object.entries(e.items))
      Array.isArray(s) && (r[n] = s.map((a) => typeof a.value == "string" && a.value.startsWith("co_z") ? {
        _coId: a.value,
        // Message CoMap co-id (native co-id)
        _sessionID: n,
        // Internal metadata: session ID
        _madeAt: a.madeAt,
        // Internal metadata: CRDT madeAt timestamp
        _tx: a.tx
        // Internal metadata: transaction ID
      } : {
        ...a.value,
        // Message data (type, payload, from, id)
        _sessionID: n,
        // Internal metadata: session ID
        _madeAt: a.madeAt,
        // Internal metadata: CRDT madeAt timestamp
        _tx: a.tx
        // Internal metadata: transaction ID
      }));
    return {
      id: A.id,
      type: "costream",
      $schema: o?.$schema || null,
      sessions: r
      // Preserve session structure: { sessionID: [messages...] }
    };
  }
  return {
    id: A.id,
    type: "costream",
    $schema: o?.$schema || null,
    sessions: {}
  };
}
function QB(i) {
  if (!i) return null;
  const A = i.type || "unknown", e = {};
  if (i.get && typeof i.get == "function") {
    const o = i.keys && typeof i.keys == "function" ? i.keys() : Object.keys(i);
    for (const g of o)
      e[g] = i.get(g);
  } else {
    const o = Object.keys(i);
    for (const g of o)
      e[g] = i[g];
  }
  let t = null;
  if (A === "colist" && i.toJSON)
    try {
      t = i.toJSON();
    } catch {
    }
  return {
    id: i.id,
    type: A,
    properties: e,
    items: t,
    content: i
  };
}
function Hg(i, A) {
  if (Array.isArray(i))
    return i.some((e) => {
      for (const [t, o] of Object.entries(A))
        if (e[t] !== o)
          return !1;
      return !0;
    });
  if (i && typeof i == "object") {
    for (const [e, t] of Object.entries(A))
      if (i[e] !== t)
        return !1;
    return !0;
  }
  return !1;
}
class eg {
  /**
   * Create a new unified cache
   * 
   * @param {number} cleanupTimeout - Time in ms before cleaning up unused entries (default: 5000)
   */
  constructor(A = 5e3) {
    this.cache = /* @__PURE__ */ new Map(), this.cleanupTimeout = A, this.cleanupTimers = /* @__PURE__ */ new Map();
  }
  /**
   * Get existing entry or create new one (unified getOrCreate for all types)
   * 
   * @param {string} key - Cache key (MUST be namespaced: `subscription:${id}`, `store:${key}`, etc.)
   * @param {Function} factory - Function that creates new entry
   * @returns {any} Cached or newly created entry
   */
  getOrCreate(A, e) {
    const t = this.cache.get(A);
    if (t)
      return this.cancelCleanup(A), t;
    const o = e();
    return this.cache.set(A, o), o;
  }
  /**
   * Get existing subscription or create new one (backward compatibility)
   * 
   * @param {string} id - CoValue ID
   * @param {Function} factory - Function that creates new subscription
   * @returns {Object} Subscription object
   */
  getOrCreateSubscription(A, e) {
    return this.getOrCreate(`subscription:${A}`, e);
  }
  /**
   * Get existing store or create new one
   * 
   * @param {string} key - Store cache key (schema+filter+options)
   * @param {Function} factory - Function that creates new ReactiveStore
   * @returns {ReactiveStore} ReactiveStore instance
   */
  getOrCreateStore(A, e) {
    return this.getOrCreate(`store:${A}`, e);
  }
  /**
   * Get existing resolution promise or create new one
   * 
   * @param {string} coId - CoValue ID
   * @param {Function} factory - Function that creates resolution Promise
   * @returns {Promise|true} Resolution promise or true if already resolved
   */
  getOrCreateResolution(A, e) {
    const t = `resolution:${A}`, o = this.cache.get(t);
    if (o === !0)
      return !0;
    if (o && typeof o.then == "function")
      return o;
    const g = e();
    return this.cache.set(t, g), g;
  }
  /**
   * Mark resolution as completed
   * 
   * @param {string} coId - CoValue ID
   */
  markResolved(A) {
    this.cache.set(`resolution:${A}`, !0);
  }
  /**
   * Check if CoValue is already resolved or being resolved
   * 
   * @param {string} coId - CoValue ID
   * @returns {boolean} True if already resolved or being resolved
   */
  isResolved(A) {
    const e = this.cache.get(`resolution:${A}`);
    return e === !0 || e && typeof e.then == "function";
  }
  /**
   * Get cached resolved+mapped data
   * 
   * @param {string} coId - CoValue ID
   * @param {Object} options - Options object (for cache key)
   * @returns {any|null} Cached resolved data or null
   */
  getResolvedData(A, e) {
    const t = `resolved:${A}:${JSON.stringify(e || {})}`, o = this.cache.get(t);
    return o && typeof o.then == "function" ? null : o || null;
  }
  /**
   * Get or create resolved data (prevents concurrent processing)
   * 
   * @param {string} coId - CoValue ID
   * @param {Object} options - Options object (for cache key)
   * @param {Function} factory - Async function that creates/resolves the data
   * @returns {Promise<any>} Resolved data (from cache or factory)
   */
  async getOrCreateResolvedData(A, e, t) {
    const o = `resolved:${A}:${JSON.stringify(e || {})}`;
    let g = this.cache.get(o);
    if (g && typeof g.then != "function")
      return g;
    if (g && typeof g.then == "function")
      try {
        return await g;
      } catch {
        this.cache.delete(o);
      }
    const r = (async () => {
      try {
        const n = await t();
        return this.cache.set(o, n), n;
      } catch (n) {
        throw this.cache.delete(o), n;
      }
    })();
    return this.cache.set(o, r), r;
  }
  /**
   * Cache resolved+mapped data
   * 
   * @param {string} coId - CoValue ID
   * @param {Object} options - Options object (for cache key)
   * @param {any} data - Resolved+mapped data to cache
   */
  setResolvedData(A, e, t) {
    const o = `resolved:${A}:${JSON.stringify(e || {})}`;
    this.cache.set(o, t);
  }
  /**
   * Invalidate all cached resolved data for a CoValue
   * Used when CoValue changes to force re-processing
   * 
   * @param {string} coId - CoValue ID
   */
  invalidateResolvedData(A) {
    const e = `resolved:${A}:`, t = [];
    for (const o of this.cache.keys())
      o.startsWith(e) && t.push(o);
    for (const o of t)
      this.cache.delete(o);
  }
  /**
   * Schedule cleanup for unused entry
   * 
   * @param {string} key - Cache key (MUST be namespaced)
   */
  scheduleCleanup(A) {
    this.cancelCleanup(A);
    const e = setTimeout(() => {
      this.destroy(A);
    }, this.cleanupTimeout);
    this.cleanupTimers.set(A, e);
  }
  /**
   * Cancel scheduled cleanup
   * 
   * @param {string} key - Cache key (MUST be namespaced)
   */
  cancelCleanup(A) {
    const e = this.cleanupTimers.get(A);
    e && (clearTimeout(e), this.cleanupTimers.delete(A));
  }
  /**
   * Manually destroy entry and remove from cache
   * 
   * @param {string} key - Cache key (MUST be namespaced)
   */
  destroy(A) {
    const e = this.cache.get(A);
    if (e) {
      if (e && typeof e == "object") {
        if (e.unsubscribe && typeof e.unsubscribe == "function")
          try {
            e.unsubscribe();
          } catch {
          }
        if (e._unsubscribe && typeof e._unsubscribe == "function")
          try {
            e._unsubscribe();
          } catch {
          }
      }
      this.cache.delete(A), this.cancelCleanup(A);
    }
  }
  /**
   * Check if entry exists in cache
   * 
   * @param {string} key - Cache key (MUST be namespaced)
   * @returns {boolean}
   */
  has(A) {
    return this.cache.has(A);
  }
  /**
   * Get entry from cache without creating
   * 
   * @param {string} key - Cache key (MUST be namespaced)
   * @returns {any|null} Entry or null
   */
  get(A) {
    return this.cache.get(A) || null;
  }
  /**
   * Get cache size (number of active entries)
   * 
   * @returns {number}
   */
  get size() {
    return this.cache.size;
  }
  /**
   * Clear all entries and timers
   * 
   * Useful for cleanup on app shutdown or context switch
   * CRITICAL: Properly unsubscribes from all entries before clearing
   */
  clear() {
    const A = Array.from(this.cache.keys());
    for (const e of A)
      this.destroy(e);
    this.cache.clear(), this.cleanupTimers.clear();
  }
}
let Ke = null, Fo = null;
function na(i, A) {
  if (!i)
    throw new Error("[getGlobalCoCache] node is required for node-aware caching");
  return Fo !== i ? (Ke && Ke.clear(), Fo = i, Ke = new eg(A)) : Ke || (Fo = i, Ke = new eg(A)), Ke;
}
function tg(i, A = /* @__PURE__ */ new Set(), e = 0, t = 10) {
  const o = /* @__PURE__ */ new Set();
  if (e > t || !i || typeof i != "object")
    return o;
  if (Array.isArray(i)) {
    for (const g of i)
      tg(g, A, e + 1, t).forEach((n) => {
        A.has(n) || o.add(n);
      });
    return o;
  }
  for (const [g, r] of Object.entries(i))
    g === "id" || g === "$schema" || g === "type" || g === "loading" || g === "error" || (typeof r == "string" && r.startsWith("co_") ? A.has(r) || o.add(r) : typeof r == "object" && r !== null && tg(r, A, e + 1, t).forEach((s) => {
      A.has(s) || o.add(s);
    }));
  return o;
}
async function We(i, A, e = /* @__PURE__ */ new Set(), t = {}) {
  const {
    maxDepth: o = 10,
    timeoutMs: g = 5e3,
    // Kept for API compatibility but not used in progressive mode
    currentDepth: r = 0
  } = t, n = `[DeepResolution:depth${r}]`;
  if (r > o) {
    console.warn(`${n}  Max depth ${o} reached, stopping recursion`);
    return;
  }
  const s = tg(A, e, r, o);
  if (s.size === 0)
    return;
  const a = Array.from(s).map(async (I) => {
    if (!e.has(I)) {
      e.add(I);
      try {
        const C = i.getCoValue(I);
        if (!C)
          return;
        if (!i.isAvailable(C)) {
          IA(i, I, { waitForAvailable: !1 }).catch((f) => {
          });
          const d = C.subscribe(async (f) => {
            if (i.isAvailable(f))
              try {
                const h = ne(i, f);
                await We(i, h, e, {
                  maxDepth: o,
                  timeoutMs: g,
                  currentDepth: r + 1
                });
                const l = f.subscribe(() => {
                });
                i.subscriptionCache.getOrCreate(`subscription:${I}`, () => ({ unsubscribe: l })), d();
              } catch {
              }
          });
          return;
        }
        const c = ne(i, C);
        await We(i, c, e, {
          maxDepth: o,
          timeoutMs: g,
          currentDepth: r + 1
        });
        const Q = C.subscribe(async (d) => {
          if (i.isAvailable(d))
            try {
              const f = ne(i, d);
              We(i, f, e, {
                maxDepth: o,
                timeoutMs: g,
                currentDepth: r + 1
              }).catch((h) => {
              });
            } catch {
            }
        });
        i.subscriptionCache.getOrCreate(`subscription:${I}`, () => ({ unsubscribe: Q }));
      } catch {
      }
    }
  });
  Promise.all(a).catch((I) => {
  });
}
async function EB(i, A, e = {}) {
  const {
    deepResolve: t = !0,
    maxDepth: o = 10,
    timeoutMs: g = 5e3
  } = e;
  if (`${A.substring(0, 12)}`, !t)
    return;
  const r = i.subscriptionCache;
  if (r.isResolved(A))
    return;
  const n = r.getOrCreateResolution(A, () => (async () => {
    try {
      const s = Date.now();
      await IA(i, A, { waitForAvailable: !0, timeoutMs: g });
      const a = i.getCoValue(A);
      if (!a || !i.isAvailable(a))
        throw new Error(`CoValue ${A} failed to load`);
      const I = ne(i, a);
      We(i, I, /* @__PURE__ */ new Set([A]), {
        maxDepth: o,
        timeoutMs: g,
        currentDepth: 0
      }).catch((c) => {
      }), r.markResolved(A);
    } catch (s) {
      throw r.destroy(`resolution:${A}`), s;
    }
  })());
  n !== !0 && await n;
}
async function lB(i, A, e = {}) {
  return await We(i, A, /* @__PURE__ */ new Set(), e);
}
async function sa(i, A, e, t = {}) {
  if (!e || typeof e != "object")
    return A;
  const { timeoutMs: o = 2e3 } = t;
  let g = A;
  try {
    g = await $e(i, A, {
      fields: null,
      // Resolve all co-id fields
      timeoutMs: o || 5e3
      // Increase timeout for deep resolution
    }, /* @__PURE__ */ new Set(), 20, 0);
  } catch (C) {
    console.warn("[applyMapTransform] Failed to resolve references:", C), g = A;
  }
  const { Evaluator: r } = await Promise.resolve().then(() => Of), n = new r(), s = {
    context: {},
    // No context needed for map transformations
    item: g
    // The resolved item is available via $$ shortcut
  }, a = { ...g }, I = /* @__PURE__ */ new Set();
  for (const [C, c] of Object.entries(e))
    try {
      if (typeof c != "string" || !c.startsWith("$$"))
        throw new Error(`Map expression for "${C}" must use strict $$ syntax. Got: "${c}". Expected format: "$$property.path"`);
      const Q = c, d = c.substring(2).split(".")[0];
      if (d && d in A) {
        const h = A[d];
        h && typeof h == "string" && h.startsWith("co_z") && I.add(d);
      }
      let f;
      try {
        if (f = await n.evaluate(Q, s), f === void 0) {
          const l = c.substring(2).split(".");
          let B = g;
          for (const u of l)
            if (B && typeof B == "object" && u in B)
              B = B[u];
            else {
              B = void 0;
              break;
            }
          B !== void 0 && (console.warn(`[applyMapTransform]  Evaluator returned undefined, using direct access for "${C}" = "${c}"`), f = B);
        }
        a[C] = f;
      } catch (h) {
        const l = c.substring(2), B = l.split(".");
        let u = g;
        for (const y of B)
          if (u && typeof u == "object" && y in u)
            u = u[y];
          else {
            u = void 0;
            break;
          }
        console.warn(`[applyMapTransform]  Evaluation failed for "${C}" = "${c}":`, {
          error: h.message,
          processedExpression: Q,
          propertyPath: l,
          directValue: u,
          resolvedItemKeys: Object.keys(g)
        }), a[C] = u !== void 0 ? u : void 0;
      }
    } catch (Q) {
      console.warn(`[applyMapTransform] Failed to evaluate expression "${c}" for field "${C}":`, Q), console.warn("[applyMapTransform] Resolved item keys:", Object.keys(g)), a[C] = void 0;
    }
  for (const C of I)
    delete a[C];
  return a;
}
async function cA(i, A = null, e = null, t = null, o = null, g = {}) {
  const {
    deepResolve: r = !0,
    maxDepth: n = 10,
    timeoutMs: s = 5e3,
    resolveReferences: a = null,
    map: I = null,
    onChange: C = null
  } = g, c = { deepResolve: r, maxDepth: n, timeoutMs: s, resolveReferences: a, map: I, onChange: C };
  return A ? await hB(i, A, o || e, c) : e ? await uB(i, e, t, c) : await fB(i, t, { deepResolve: r, maxDepth: n, timeoutMs: s });
}
async function dB(i, A, e = {}) {
  const t = new mA({}), o = /* @__PURE__ */ new Map(), g = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map(), { timeoutMs: n = 5e3, onChange: s } = e;
  let a = null, I = null;
  const C = () => {
    I || (I = queueMicrotask(() => {
      I = null;
      const h = { ...A.value || {} };
      delete h["@stores"];
      const l = {};
      for (const [y, E] of g.entries())
        l[y] = E;
      Object.keys(l).length > 0 && (h.$op = l);
      for (const [y, E] of o.entries())
        E && typeof E.subscribe == "function" && "value" in E && (delete h[y], h[y] = E.value);
      const B = JSON.stringify(h), u = a ? JSON.stringify(a) : null;
      B !== u && (a = h, t._set(h));
    }));
  }, c = async (f) => {
    if (!f || typeof f != "object" || Array.isArray(f)) {
      C();
      return;
    }
    const h = /* @__PURE__ */ new Set();
    for (const [l, B] of Object.entries(f))
      if (!(l === "$schema" || l === "$id" || l === "@stores" || l === "properties" || l === "items" || l === "$defs" || l === "cotype" || l === "indexing" || l === "title" || l === "description") && B && typeof B == "object" && !Array.isArray(B) && B.schema) {
        h.add(l);
        const u = o.get(l);
        try {
          let y = B.schema;
          if (y && typeof y == "object" && y.$id && (y = y.$id), typeof y != "string") {
            console.error(`[createUnifiedStore] Invalid schema type for query "${l}": expected string, got ${typeof y}`, y);
            continue;
          }
          if (y.startsWith("co_z")) {
            if (y && typeof y == "string" && y.startsWith("co_z")) {
              const E = {
                ...e,
                timeoutMs: n,
                ...B.options || {}
              }, w = await cA(i, null, y, B.filter || null, null, E);
              if (g.set(l, {
                schema: B.schema,
                ...B.options ? { options: B.options } : {},
                ...B.filter ? { filter: B.filter } : {}
              }), !u || u !== w) {
                u && u._queryUnsubscribe && u._queryUnsubscribe();
                const p = w.subscribe(() => {
                  C();
                });
                w._queryUnsubscribe = p, o.set(l, w);
              }
            }
          } else if (y.startsWith("@schema/")) {
            const w = ee(i, y, { timeoutMs: n }).subscribe(async (p) => {
              if (p.loading) {
                if (!o.has(l)) {
                  const v = new mA([]);
                  o.set(l, v), g.set(l, {
                    schema: B.schema,
                    ...B.options ? { options: B.options } : {},
                    ...B.filter ? { filter: B.filter } : {}
                  }), C();
                }
                return;
              }
              if (p.error || !p.schemaCoId) {
                console.error(`[createUnifiedStore] Failed to resolve schema ${B.schema} for query "${l}": ${p.error || "Schema not found"}`), w();
                return;
              }
              const N = p.schemaCoId;
              try {
                const v = {
                  ...e,
                  timeoutMs: n,
                  ...B.options || {}
                }, U = await cA(i, null, N, B.filter || null, null, v);
                g.set(l, {
                  schema: B.schema,
                  ...B.options ? { options: B.options } : {},
                  ...B.filter ? { filter: B.filter } : {}
                });
                const L = U.subscribe(() => {
                  C();
                });
                U._queryUnsubscribe = L, o.set(l, U), C(), w();
              } catch (v) {
                console.error(`[createUnifiedStore] Failed to execute query "${l}" after schema resolution:`, v), w();
              }
            });
            r.set(l, w);
            continue;
          } else {
            console.error(`[createUnifiedStore] Invalid schema format for query "${l}": ${y}`);
            continue;
          }
        } catch (y) {
          console.error(`[createUnifiedStore] Failed to resolve query "${l}":`, y);
        }
      }
    for (const [l, B] of o.entries())
      h.has(l) || (B._queryUnsubscribe && (B._queryUnsubscribe(), delete B._queryUnsubscribe), o.delete(l), g.delete(l));
    for (const [l, B] of r.entries())
      h.has(l) || (B && B(), r.delete(l));
    C();
  }, Q = A.subscribe(async (f) => {
    await c(f);
  }), d = t._unsubscribe;
  return t._unsubscribe = () => {
    d && d(), Q();
    for (const f of r.values())
      f && f();
    r.clear();
    for (const f of o.values())
      f._queryUnsubscribe && (f._queryUnsubscribe(), delete f._queryUnsubscribe);
    o.clear();
  }, await c(A.value), t;
}
async function kr(i, A, e, t, o = /* @__PURE__ */ new Set()) {
  const {
    deepResolve: g = !0,
    maxDepth: r = 10,
    timeoutMs: n = 5e3,
    resolveReferences: s = null,
    map: a = null
  } = t;
  let I = ne(i, A, e);
  if (g)
    try {
      EB(i, A.id, { deepResolve: g, maxDepth: r, timeoutMs: n }).catch((C) => {
      });
    } catch {
    }
  if (s)
    try {
      const C = { ...s, timeoutMs: n };
      I = await $e(i, I, C, o, r, 0);
    } catch {
    }
  if (a)
    try {
      I = await sa(i, I, a, { timeoutMs: n });
    } catch (C) {
      console.warn("[processCoValueData] Failed to apply map transform:", C);
    }
  return I;
}
async function hB(i, A, e = null, t = {}) {
  const {
    deepResolve: o = !0,
    maxDepth: g = 10,
    timeoutMs: r = 5e3,
    resolveReferences: n = null,
    map: s = null
  } = t, a = i.subscriptionCache, I = { deepResolve: o, resolveReferences: n, map: s, maxDepth: g, timeoutMs: r }, C = a.getResolvedData(A, I);
  if (C) {
    const B = new mA(C), u = i.getCoValue(A);
    if (u) {
      const y = u.subscribe(async (w) => {
        if (w.isAvailable()) {
          const p = await kr(i, w, e, t, /* @__PURE__ */ new Set());
          a.setResolvedData(A, I, p), B._set(p);
        }
      });
      i.subscriptionCache.getOrCreate(`subscription:${A}`, () => ({ unsubscribe: y }));
      const E = B._unsubscribe;
      B._unsubscribe = () => {
        E && E(), i.subscriptionCache.scheduleCleanup(`subscription:${A}`);
      };
    }
    return B;
  }
  const c = new mA(null), Q = i.getCoValue(A);
  if (!Q)
    return c._set({ error: "CoValue not found", id: A }), c;
  const d = /* @__PURE__ */ new Set(), f = async (B) => {
    const u = await kr(i, B, e, t, d);
    return a.setResolvedData(A, I, u), u;
  }, h = Q.subscribe(async (B) => {
    if (!B.isAvailable()) {
      c._set({ id: A, loading: !0 });
      return;
    }
    const u = await f(B);
    if (u && typeof u == "object" && Object.values(u).some(
      (E) => E && typeof E == "object" && !Array.isArray(E) && E.schema
    )) {
      c._set(u);
      return;
    }
    c._set(u);
  });
  if (i.subscriptionCache.getOrCreate(`subscription:${A}`, () => ({ unsubscribe: h })), Q.isAvailable()) {
    const B = await f(Q);
    return B && typeof B == "object" && Object.values(B).some(
      (y) => y && typeof y == "object" && !Array.isArray(y) && y.schema
    ) ? (c._set(B), await dB(i, c, t)) : (c._set(B), c);
  } else
    c._set({ id: A, loading: !0 }), IA(i, A).then(async () => {
    }).catch((B) => {
      c._set({ error: B.message, id: A });
    });
  const l = c._unsubscribe;
  return c._unsubscribe = () => {
    l && l(), i.subscriptionCache.scheduleCleanup(`subscription:${A}`);
  }, c;
}
async function uB(i, A, e = null, t = {}) {
  const {
    deepResolve: o = !0,
    maxDepth: g = 10,
    timeoutMs: r = 5e3,
    resolveReferences: n = null,
    map: s = null
  } = t, a = t && (t.map || t.resolveReferences) ? JSON.stringify({ map: t.map || null, resolveReferences: t.resolveReferences || null }) : "", I = `${A}:${JSON.stringify(e || {})}:${a}`, C = i.subscriptionCache.getOrCreateStore(I, () => new mA([])), c = await Ug(i, A);
  if (!c)
    return C;
  let Q = i.getCoValue(c);
  if (!Q)
    return C;
  const d = /* @__PURE__ */ new Set(), f = /* @__PURE__ */ new Set(), h = i.subscriptionCache;
  let l = async () => {
  };
  if (!i.isAvailable(Q)) {
    if (IA(i, c, { waitForAvailable: !1 }).catch((E) => {
      console.warn(`[readCollection] Failed to load CoList ${c.substring(0, 12)}...:`, E);
    }), Q) {
      const E = Q.subscribe((w) => {
        w && i.isAvailable(w) && l().catch((p) => {
          console.warn("[readCollection] Error updating store after colist load:", p);
        });
      });
      i.subscriptionCache.getOrCreate(`subscription:${c}`, () => ({ unsubscribe: E }));
    }
    return C;
  }
  const B = (E) => {
    if (d.has(E))
      return;
    d.add(E);
    const w = i.getCoValue(E);
    if (!w || !i.isAvailable(w)) {
      IA(i, E, { waitForAvailable: !0, timeoutMs: 2e3 }).then(() => {
        const N = i.getCoValue(E);
        if (N && i.isAvailable(N)) {
          const v = N.subscribe(() => {
            h.invalidateResolvedData(E), l && l().catch((U) => {
              console.warn("[CoJSONBackend] Error updating store:", U);
            });
          });
          i.subscriptionCache.getOrCreate(`subscription:${E}`, () => ({ unsubscribe: v })), l && l().catch((U) => {
            console.warn("[CoJSONBackend] Error updating store after item load:", U);
          });
        }
      }).catch((N) => {
        console.error(`[CoJSONBackend] Failed to load item ${E}:`, N);
      });
      return;
    }
    const p = w.subscribe(() => {
      h.invalidateResolvedData(E), l && l().catch((N) => {
        console.warn("[CoJSONBackend] Error updating store:", N);
      });
    });
    i.subscriptionCache.getOrCreate(`subscription:${E}`, () => ({ unsubscribe: p }));
  };
  l = async () => {
    const E = [];
    if (!i.isAvailable(Q)) {
      IA(i, c).catch((p) => {
        console.error("[readCollection] Failed to reload CoList:", p);
      });
      return;
    }
    const w = i.getCurrentContent(Q);
    if (!(!w || !w.toJSON)) {
      try {
        const p = w.toJSON();
        let N = 0, v = 0;
        for (const U of p) {
          if (typeof U != "string" || !U.startsWith("co_"))
            continue;
          B(U);
          const L = i.getCoValue(U);
          if (!L) {
            v++;
            continue;
          }
          if (i.isAvailable(L)) {
            N++;
            const P = { deepResolve: o, resolveReferences: n, map: s, maxDepth: g, timeoutMs: r }, V = i.getCoValue(U);
            if (!V || !i.isAvailable(V))
              continue;
            const W = await h.getOrCreateResolvedData(U, P, async () => {
              let aA = ne(i, V);
              if (Object.keys(aA).filter(
                (gA) => !["id", "type", "$schema"].includes(gA)
              ).length === 0 && aA.type === "comap")
                return aA;
              if (o && !h.isResolved(U))
                try {
                  await We(i, aA, f, {
                    maxDepth: g,
                    timeoutMs: r,
                    currentDepth: 0
                  });
                } catch {
                }
              if (n)
                try {
                  const gA = { ...n, timeoutMs: r }, kA = await $e(i, aA, gA, f, g, 0);
                  Object.assign(aA, kA);
                } catch {
                }
              if (s)
                try {
                  aA = await sa(i, aA, s, { timeoutMs: r });
                } catch (gA) {
                  console.warn("[readCollection] Failed to apply map transform:", gA);
                }
              return aA;
            });
            if (Object.keys(W).filter(
              (aA) => !["id", "type", "$schema"].includes(aA)
            ).length === 0 && W.type === "comap")
              continue;
            (!e || Hg(W, e)) && E.push(W);
          } else
            v++;
        }
      } catch (p) {
        console.warn("[readCollection] Error reading CoList items:", p);
      }
      C._set(E);
    }
  };
  const u = Q.subscribe(() => {
    l().catch((E) => {
      console.warn("[CoJSONBackend] Error updating store:", E);
    });
  });
  if (i.subscriptionCache.getOrCreate(`subscription:${c}`, () => ({ unsubscribe: u })), i.isAvailable(Q)) {
    const E = i.getCurrentContent(Q);
    if (E && E.toJSON)
      try {
        const w = E.toJSON();
        for (const p of w)
          if (typeof p == "string" && p.startsWith("co_")) {
            const N = i.getCoValue(p);
            N && !i.isAvailable(N) && IA(i, p).catch((v) => {
              console.error(`[CoJSONBackend] Failed to load item ${p}:`, v);
            });
          }
      } catch {
      }
  }
  await l();
  const y = C._unsubscribe;
  return C._unsubscribe = () => {
    i.subscriptionCache.scheduleCleanup(`store:${I}`), y && y(), i.subscriptionCache.scheduleCleanup(`subscription:${c}`);
    for (const E of d)
      i.subscriptionCache.scheduleCleanup(`subscription:${E}`);
  }, C;
}
async function fB(i, A = null, e = {}) {
  const {
    deepResolve: t = !0,
    maxDepth: o = 10,
    timeoutMs: g = 5e3
  } = e, r = new mA([]), n = /* @__PURE__ */ new Set();
  let s = async () => {
  };
  const a = (C, c) => {
    if (n.has(C))
      return;
    n.add(C);
    const Q = c.subscribe(() => {
      s();
    });
    i.subscriptionCache.getOrCreate(`subscription:${C}`, () => ({ unsubscribe: Q }));
  };
  s = async () => {
    const C = i.getAllCoValues(), c = [];
    for (const [Q, d] of C.entries()) {
      if (!Q || typeof Q != "string" || !Q.startsWith("co_"))
        continue;
      if (a(Q, d), !i.isAvailable(d)) {
        IA(i, Q).catch((l) => {
          console.error(`[CoJSONBackend] Failed to load CoValue ${Q}:`, l);
        });
        continue;
      }
      const f = ne(i, d);
      if (!(Object.keys(f).filter(
        (l) => !["id", "type", "$schema"].includes(l)
      ).length === 0 && f.type === "comap")) {
        if (t)
          try {
            await lB(i, f, { maxDepth: o, timeoutMs: g });
          } catch {
          }
        (!A || Hg(f, A)) && c.push(f);
      }
    }
    r._set(c);
  }, await s();
  const I = r._unsubscribe;
  return r._unsubscribe = () => {
    I && I();
    for (const C of n)
      i.subscriptionCache.scheduleCleanup(`subscription:${C}`);
  }, r;
}
async function YA(i, A, e = 5e3) {
  const t = i.value;
  if (!(t && !t.loading && !t.error && (t.hasProperties !== !1 || t.properties || typeof t == "object" && Object.keys(t).length > 0 && t.id))) {
    if (t?.error)
      throw new Error(`CoValue error (co-id: ${A}): ${t.error}`);
    return new Promise((g, r) => {
      let n = !1, s;
      s = i.subscribe((I) => {
        if (n) return;
        if (I?.error) {
          n = !0, s(), r(new Error(`CoValue error (co-id: ${A}): ${I.error}`));
          return;
        }
        !I?.loading && I !== null && (I?.hasProperties !== !1 || I?.properties || typeof I == "object" && Object.keys(I).length > 0 && I.id) && (n = !0, s(), g());
      });
      const a = i.value;
      a?.error ? (n = !0, s(), r(new Error(`CoValue error (co-id: ${A}): ${a.error}`))) : !a?.loading && a !== null && (a?.hasProperties !== !1 || a?.properties || typeof a == "object" && Object.keys(a).length > 0 && a.id) && (n = !0, s(), g()), setTimeout(() => {
        n || (n = !0, s(), r(new Error(`CoValue timeout loading (co-id: ${A}). Make sure the CoValue was seeded correctly.`)));
      }, e);
    });
  }
}
const wB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  waitForStoreReady: YA
}, Symbol.toStringTag, { value: "Module" }));
function fe(i, A = {}) {
  const { timeoutMs: e = 1e4 } = A;
  return new Promise((t, o) => {
    let g;
    const r = setTimeout(() => {
      g && g(), o(new Error(`Timeout waiting for reactive resolution after ${e}ms`));
    }, e);
    g = i.subscribe((n) => {
      n.loading || (clearTimeout(r), g && g(), n.error ? o(new Error(n.error)) : t(n));
    });
  });
}
function ft(i, A, e = {}) {
  const { timeoutMs: t = 1e4 } = e, o = new mA({ loading: !0 });
  if (A.startsWith("co_z"))
    return o._set({ loading: !1, schemaCoId: A }), o;
  let g = null, r = null;
  const n = async () => {
    if (!i.account || typeof i.account.get != "function") {
      o._set({ loading: !1, error: "Account not available" });
      return;
    }
    const s = i.account.get("os");
    if (!s || typeof s != "string" || !s.startsWith("co_z")) {
      o._set({ loading: !1, error: "account.os not found" });
      return;
    }
    g = (await cA(i, s, null, null, null, {
      deepResolve: !1,
      timeoutMs: t
    })).subscribe(async (C) => {
      if (!C || C.error)
        return;
      const c = C.schematas;
      !c || typeof c != "string" || !c.startsWith("co_z") || r || (r = (await cA(i, c, null, null, null, {
        deepResolve: !1,
        timeoutMs: t
      })).subscribe((d) => {
        if (!d || d.error)
          return;
        const f = A.startsWith("@schema/") ? A : `@schema/${A}`, h = d[f] || d[A];
        h && typeof h == "string" && h.startsWith("co_z") && (o._set({ loading: !1, schemaCoId: h }), r && (r(), r = null), g && (g(), g = null));
      }));
    });
    const I = o._unsubscribe;
    o._unsubscribe = () => {
      I && I(), r && (r(), r = null), g && (g(), g = null);
    };
  };
  return oA(i, A, { returnType: "coId", timeoutMs: 2e3 }).then((s) => {
    s && s.startsWith("co_z") ? o._set({ loading: !1, schemaCoId: s }) : n().catch((a) => {
      o._set({ loading: !1, error: a.message });
    });
  }).catch(() => {
    n().catch((s) => {
      o._set({ loading: !1, error: s.message });
    });
  }), o;
}
function ig(i, A, e = {}) {
  const t = new mA({ loading: !0 });
  if (!A || !A.startsWith("co_z"))
    return t._set({ loading: !1, error: "Invalid co-id" }), t;
  const o = i.getCoValue(A);
  if (!o)
    return t._set({ loading: !1, error: "CoValueCore not found" }), t;
  if (i.isAvailable(o))
    return t._set({ loading: !1, coValueCore: o }), t;
  IA(i, A, { waitForAvailable: !1 }).catch((n) => {
  });
  const g = o.subscribe((n) => {
    i.isAvailable(n) && (t._set({ loading: !1, coValueCore: n }), g());
  }), r = t._unsubscribe;
  return t._unsubscribe = () => {
    r && r(), g();
  }, t;
}
function aa(i, A, e = {}) {
  const t = new mA({ loading: !0, items: [] });
  if (!A || !A.schema)
    return t._set({ loading: !1, items: [], error: "Invalid query definition" }), t;
  const g = ft(i, A.schema, e).subscribe(async (r) => {
    if (!r.loading) {
      if (r.error || !r.schemaCoId) {
        t._set({ loading: !1, items: [], error: r.error || "Schema not found" }), g();
        return;
      }
      try {
        const s = (await cA(
          i,
          null,
          r.schemaCoId,
          A.filter || null,
          null,
          {
            ...e,
            ...A.options || {}
          }
        )).subscribe((I) => {
          const C = Array.isArray(I) ? I : I?.items || [];
          t._set({ loading: !1, items: C });
        }), a = t._unsubscribe;
        t._unsubscribe = () => {
          a && a(), s(), g();
        };
      } catch (n) {
        t._set({ loading: !1, items: [], error: n.message }), g();
      }
    }
  });
  return t;
}
function yB(i, A, e = {}) {
  if (A && typeof A == "object" && !Array.isArray(A)) {
    if (A.schema)
      return aa(i, A, e);
    if (A.fromCoValue) {
      const o = ig(i, A.fromCoValue, e), g = new mA({ loading: !0 });
      let r, n, s;
      r = o.subscribe(async (I) => {
        if (I.loading)
          return;
        if (I.error || !I.coValueCore) {
          g._set({ loading: !1, error: I.error || "CoValue not found" }), r && r();
          return;
        }
        const Q = (i.getHeader(I.coValueCore)?.meta || null)?.$schema || null;
        Q && typeof Q == "string" && Q.startsWith("co_z") ? n = ft(i, Q, e).subscribe((f) => {
          g._set(f), f.loading || (n && n(), r && r());
        }) : s = I.coValueCore.subscribe((d) => {
          const l = (i.getHeader(d)?.meta || null)?.$schema || null;
          l && typeof l == "string" && l.startsWith("co_z") && (n = ft(i, l, e).subscribe((u) => {
            g._set(u), u.loading || (n && n(), s && s(), r && r());
          }));
        });
      });
      const a = g._unsubscribe;
      return g._unsubscribe = () => {
        a && a(), r && r(), n && n(), s && s();
      }, g;
    }
  }
  return typeof A == "string" ? A.startsWith("co_z") ? ig(i, A, e) : ft(i, A, e) : new mA({ loading: !1, error: "Invalid identifier" });
}
function og(i, A = !1) {
  if (i == null || typeof i != "object")
    return i;
  if (Array.isArray(i))
    return i.map((t) => og(t, A));
  const e = {};
  for (const [t, o] of Object.entries(i))
    if (!(t === "id" && !A))
      if (o != null && typeof o == "object") {
        const g = t === "properties" || t === "items";
        e[t] = og(o, g || A);
      } else
        e[t] = o;
  return e;
}
async function oA(i, A, e = {}) {
  const {
    returnType: t = "schema",
    deepResolve: o = !1,
    timeoutMs: g = 5e3
  } = e;
  if (!i)
    throw new Error("[resolve] backend is required");
  if (A && typeof A == "object" && !Array.isArray(A)) {
    if (A.fromCoValue) {
      if (!A.fromCoValue.startsWith("co_z"))
        throw new Error(`[resolve] fromCoValue must be a valid co-id (co_z...), got: ${A.fromCoValue}`);
      const r = await cA(i, A.fromCoValue, null, null, null, {
        deepResolve: !1,
        timeoutMs: g
      });
      try {
        await YA(r, A.fromCoValue, g);
      } catch {
        return null;
      }
      const n = r.value;
      if (!n || n.error)
        return null;
      const s = n.$schema || null;
      return s ? t === "coId" ? s : await oA(i, s, { returnType: t, deepResolve: o, timeoutMs: g }) : null;
    }
    throw new Error('[resolve] Invalid identifier object. Expected { fromCoValue: "co_z..." }');
  }
  if (typeof A != "string")
    throw new Error(`[resolve] Invalid identifier type. Expected string or object, got: ${typeof A}`);
  if (A.startsWith("co_z")) {
    const r = await cA(i, A, null, null, null, {
      deepResolve: o,
      timeoutMs: g
    });
    try {
      await YA(r, A, g);
    } catch {
      return null;
    }
    const n = r.value;
    if (!n || n.error)
      return null;
    if (t === "coValue")
      return r;
    if (t === "coId")
      return A;
    const s = n.cotype, a = n.properties, I = n.items, C = n.title;
    if (s || a || I || C) {
      const { id: Q, type: d, ...f } = n;
      return {
        ...og(f),
        $id: A
        // Ensure $id is set
      };
    }
    return null;
  }
  if (A.startsWith("@schema/") || A.startsWith("@vibe/") || !A.startsWith("@") && !A.startsWith("co_z")) {
    let r = A;
    if (!r.startsWith("@schema/") && !r.startsWith("@vibe/") && !r.startsWith("@") && (r = `@schema/${r}`), !i.account || typeof i.account.get != "function")
      return console.warn("[resolve] Account not available for registry lookup"), null;
    if (r.startsWith("@schema/")) {
      const s = i.account.get("os");
      if (!s || typeof s != "string" || !s.startsWith("co_z"))
        return null;
      const a = await cA(i, s, null, null, null, {
        deepResolve: !1,
        timeoutMs: g
      });
      try {
        await YA(a, s, g);
      } catch {
        return null;
      }
      const I = a.value;
      if (!I || I.error)
        return null;
      const C = I.schematas;
      if (!C || typeof C != "string" || !C.startsWith("co_z"))
        return null;
      const c = await cA(i, C, null, null, null, {
        deepResolve: !1,
        timeoutMs: g
      });
      try {
        await YA(c, C, g);
      } catch {
        return null;
      }
      const Q = c.value;
      if (!Q || Q.error)
        return null;
      const d = Q[r] || Q[A];
      return d && typeof d == "string" && d.startsWith("co_z") ? t === "coId" ? d : await oA(i, d, { returnType: t, deepResolve: o, timeoutMs: g }) : (r.startsWith("@schema/index/") || console.warn(`[resolve] Schema "${A}" not found in registry`), null);
    } else if (A.startsWith("@vibe/") || !A.startsWith("@")) {
      const s = i.account.get("vibes");
      if (!s || typeof s != "string" || !s.startsWith("co_z"))
        return null;
      const a = await cA(i, s, null, null, null, {
        deepResolve: !1,
        timeoutMs: g
      });
      try {
        await YA(a, s, g);
      } catch {
        return null;
      }
      const I = a.value;
      if (!I || I.error)
        return null;
      const C = A.startsWith("@vibe/") ? A.replace("@vibe/", "") : A, c = I[C];
      return c && typeof c == "string" && c.startsWith("co_z") ? t === "coId" ? c : await oA(i, c, { returnType: t, deepResolve: o, timeoutMs: g }) : null;
    }
  }
  return null;
}
function ee(i, A, e = {}) {
  const { returnType: t = "coId" } = e, o = yB(i, A, e);
  if (t === "schema" || t === "coValue") {
    const g = new ReactiveStore({ loading: !0 }), r = o.subscribe(async (s) => {
      if (s.loading) {
        g._set({ loading: !0 });
        return;
      }
      if (s.error) {
        g._set({ loading: !1, error: s.error }), r();
        return;
      }
      if (s.schemaCoId)
        if (t === "coId")
          g._set({ loading: !1, schemaCoId: s.schemaCoId }), r();
        else
          try {
            const a = await oA(i, s.schemaCoId, { returnType: t });
            a ? g._set({ loading: !1, [t === "schema" ? "schema" : "coValue"]: a }) : g._set({ loading: !1, error: "Schema not found" }), r();
          } catch (a) {
            g._set({ loading: !1, error: a.message }), r();
          }
      else if (s.coValueCore)
        if (t === "coId") {
          const C = (i.getHeader(s.coValueCore)?.meta || null)?.$schema || null;
          C ? g._set({ loading: !1, schemaCoId: C }) : g._set({ loading: !1, error: "Schema not found in headerMeta" }), r();
        } else
          g._set({ loading: !1, coValue: s.coValueCore }), r();
    }), n = g._unsubscribe;
    return g._unsubscribe = () => {
      n && n(), r();
    }, g;
  }
  return o;
}
async function xi(i, A, e) {
  const t = await oA(i, A, { returnType: "schema" });
  if (!t)
    throw new Error(`[checkCotype] Schema ${A} not found`);
  return (t.cotype || "comap") === e;
}
const pB = {
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $id: "https://maia.city/AccountSchema",
  title: "Account",
  description: "Schema for account CoMap (special CoMap with authentication properties)",
  allOf: [
    { $ref: "#/$defs/comap" }
  ],
  properties: {
    sealer: {
      type: "string",
      pattern: "^sealer_",
      description: "Sealer key for encryption"
    },
    signer: {
      type: "string",
      pattern: "^signer_",
      description: "Signer key for signing"
    },
    readKey: {
      type: "string",
      description: "Read key for decryption"
    },
    profile: {
      allOf: [
        {
          type: "string",
          pattern: "^co_z[a-zA-Z0-9]+$",
          description: "Co-id reference to Profile CoMap"
        },
        {
          $ref: "https://maia.city/ProfileSchema"
        }
      ]
    },
    examples: {
      type: "string",
      pattern: "^co_z[a-zA-Z0-9]+$",
      description: "Co-id reference to Examples CoMap (optional)"
    }
  },
  required: ["profile"],
  $defs: Ft.$defs
}, DB = {
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $id: "https://maia.city/GroupSchema",
  title: "Group",
  description: "Schema for group CoMap (special CoMap with member management)",
  allOf: [
    { $ref: "#/$defs/comap" }
  ],
  properties: {
    // Groups can have members (co-ids) and permissions
    // Structure depends on cojson's group implementation
  },
  $defs: Ft.$defs
}, mB = {
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $id: "https://maia.city/ProfileSchema",
  title: "Profile",
  description: "Schema for profile CoMap",
  allOf: [
    { $ref: "#/$defs/comap" }
  ],
  properties: {
    name: {
      type: "string",
      minLength: 1,
      description: "User's display name"
    },
    group: {
      type: "string",
      pattern: "^co_z[a-zA-Z0-9]+$",
      description: "Co-id reference to universal group (set by migration)"
    }
  },
  required: ["name"],
  $defs: Ft.$defs
}, qg = {
  AccountSchema: pB,
  GroupSchema: DB,
  ProfileSchema: mB
};
function go() {
  return { ...qg };
}
function Rt(i) {
  return ["@account", "@group", "GenesisSchema"].includes(i) ? !0 : i in qg;
}
const GA = {
  ACCOUNT: "@account",
  GROUP: "@group",
  META_SCHEMA: "GenesisSchema"
};
function se(i) {
  return i === GA.ACCOUNT || i === GA.GROUP || i === GA.META_SCHEMA;
}
function Xe(i) {
  return !se(i) && !i.startsWith("co_z") && !Rt(i) && console.warn(`[createSchemaMeta] Schema '${i}' not found in registry`), {
    $schema: i
    // Schema name, co-id, or exception schema
  };
}
function Ia(i) {
  return i.headerMeta?.$schema || null;
}
function Ca(i) {
  return Ia(i);
}
const SB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  EXCEPTION_SCHEMAS: GA,
  SCHEMA_REGISTRY: qg,
  createSchemaMeta: Xe,
  getAllSchemas: go,
  getSchema: Ca,
  getSchemaFromCoValue: Ia,
  hasSchemaInRegistry: Rt,
  isExceptionSchema: se
}, Symbol.toStringTag, { value: "Module" }));
async function Lg(i, A, e) {
  const t = "passkey";
  let o = i.get("profile"), g, r;
  if (o) {
    const n = A.getCoValue(o);
    if (n && n.type === "comap") {
      const s = A.getCoValue(o)?.getCurrentContent?.();
      if (s && typeof s.get == "function") {
        g = s;
        const a = g.get("group");
        if (a) {
          const I = A.getCoValue(a);
          if (I && I.type === "group") {
            const C = I.getCurrentContent?.();
            C && typeof C.createMap == "function" && (r = C);
          }
        }
      }
    }
  }
  if (r || (r = A.createGroup()), g) {
    g.get("group") || g.set("group", r.id);
    const n = g.get("name");
    n !== t && (g.set("name", t), console.log(`    Updated profile name from "${n}" to "${t}"`));
  } else {
    const n = Xe("ProfileSchema");
    g = i.createMap({
      name: t,
      // Hardcoded: "passkey" (represents EOA identity)
      group: r.id
      // Reference to universal group (single source of truth)
    }, n), i.set("profile", g.id);
  }
}
function NB(i) {
  i.addKeyword({
    keyword: "$co",
    macro: (A) => ({
      type: "string",
      pattern: "^co_z[a-zA-Z0-9]+$",
      _schemaRef: A
      // Store schema co-id for metadata
    }),
    metaSchema: {
      type: "string",
      anyOf: [
        {
          pattern: "^co_z[a-zA-Z0-9]+$",
          description: "Co-id reference (after transformation)"
        },
        {
          pattern: "^@schema/",
          description: "Human-readable schema ID (before transformation)"
        }
      ],
      description: "Reference to schema that this property value must conform to (human-readable ID or co-id)"
    }
  }), i.addKeyword({
    keyword: "cotype",
    validate: (A, e) => e === null || typeof e != "object" ? !0 : A === "comap" ? !Array.isArray(e) : A === "colist" || A === "costream" ? !!(Array.isArray(e) || typeof e == "object" && e !== null && Array.isArray(e.items)) : !1,
    metaSchema: {
      enum: ["comap", "colist", "costream"]
    }
  }), i.addKeyword({
    keyword: "indexing",
    validate: () => !0,
    // Always pass - it's metadata, not a validation rule
    metaSchema: {
      type: "boolean",
      description: "Whether instances of this schema should be indexed in account.os.{schemaCoId}"
    }
  });
}
const MB = "https://json-schema.org/draft/2020-12/schema", GB = "@schema/meta", kB = { "https://json-schema.org/draft/2020-12/vocab/core": !0, "https://json-schema.org/draft/2020-12/vocab/applicator": !0, "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0, "https://json-schema.org/draft/2020-12/vocab/validation": !0, "https://json-schema.org/draft/2020-12/vocab/meta-data": !0, "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0, "https://json-schema.org/draft/2020-12/vocab/content": !0, "https://maiaos.dev/vocab/cojson": !0 }, FB = [{ $ref: "https://json-schema.org/draft/2020-12/schema" }], RB = "@schema/meta", bB = ["object", "boolean"], KB = !1, YB = { title: { type: "string", description: "Human-readable schema title (required)" }, cotype: { enum: ["comap", "colist", "costream"], description: "CRDT type at schema root. Schemas can be comap (with properties), colist (with items), or costream (with items). CoText is modeled as colist with string items." }, $co: { type: "string", anyOf: [{ pattern: "^co_z[a-zA-Z0-9]+$", description: "Co-id reference (after transformation)" }, { pattern: "^@schema/", description: "Human-readable schema ID (before transformation)" }], description: "Reference to schema that this property value must conform to (human-readable ID or co-id). Use $co in properties to reference separate CoValues, never use cotype in properties." }, indexing: { type: "boolean", default: !1, description: "Whether instances of this schema should be indexed in account.os.{schemaCoId}" } }, vB = ["title", "cotype"], UB = { comap: { description: "CoMap - CRDT-based collaborative map/object", type: "object", properties: {}, additionalProperties: { anyOf: [{ type: "string", description: "Standard string value" }, { type: "number", description: "Standard number value" }, { type: "integer", description: "Standard integer value" }, { type: "boolean", description: "Standard boolean value" }, { type: "null", description: "Null value" }, { type: "object", description: "Nested object value" }, { type: "array", description: "Array value" }, { type: "string", pattern: "^co_z[a-zA-Z0-9]+$", description: "Co-id reference to another CoValue" }, { type: "string", pattern: "^key_[a-zA-Z0-9_]+$", description: "Key reference" }, { type: "string", pattern: "^sealed_", description: "Sealed/encrypted value" }] } }, costream: { description: "CoStream - CRDT-based append-only stream", type: "array", items: { anyOf: [{ type: "object", description: "Stream item object" }, { type: "string", description: "Stream item string" }, { type: "number", description: "Stream item number" }, { type: "boolean", description: "Stream item boolean" }, { type: "null", description: "Stream item null" }] } }, colist: { description: "CoList - CRDT-based collaborative list/array", type: "array", items: { anyOf: [{ type: "object", description: "List item object" }, { type: "string", description: "List item string (can be co-id reference)" }, { type: "number", description: "List item number" }, { type: "integer", description: "List item integer" }, { type: "boolean", description: "List item boolean" }, { type: "null", description: "List item null" }, { type: "array", description: "Nested array" }] } } }, Ti = {
  $schema: MB,
  $id: GB,
  $vocabulary: kB,
  allOf: FB,
  title: RB,
  type: bB,
  indexing: KB,
  properties: YB,
  required: vB,
  $defs: UB
};
class Me {
  constructor(A = {}) {
    this.ajv = null, this.ajvPromise = null, this.initialized = !1, this.schemas = /* @__PURE__ */ new Map(), this.schemaResolver = null, this.registrySchemas = A.registrySchemas || null;
  }
  /**
   * Set schema resolver function for resolving $schema references from IndexedDB
   * @param {Function} resolver - Async function that takes a schema key and returns the schema
   */
  setSchemaResolver(A) {
    this.schemaResolver = A;
  }
  /**
   * Initialize AJV (loads from CDN in browser, uses import in Node/Bun)
   * @returns {Promise<void>}
   */
  async initialize() {
    if (!this.initialized) {
      if (this.ajvPromise) {
        await this.ajvPromise;
        return;
      }
      this.ajvPromise = (async () => {
        let A;
        try {
          const e = await Promise.resolve().then(() => Yp);
          A = e.default || e.Ajv2020 || e;
        } catch {
          try {
            A = (await Promise.resolve().then(() => Vp)).default;
          } catch {
            try {
              const o = await import("https://esm.sh/ajv@8.12.0/dist/2020.js");
              A = o.default || o.Ajv2020 || o;
            } catch {
              const g = await import("https://esm.sh/ajv@8.12.0");
              A = g.default || g;
            }
          }
        }
        this.ajv = new A({
          allErrors: !0,
          // Collect all errors, not just first
          verbose: !0,
          // Include schema and data paths in errors
          strict: !1,
          // Be permissive initially
          validateSchema: !0,
          // Validate schemas themselves (meta-schema will be loaded)
          validateFormats: !0,
          // Enable format validation
          removeAdditional: !1,
          // Don't remove extra properties
          useDefaults: !1,
          // Don't add defaults
          coerceTypes: !1,
          // Don't coerce types
          loadSchema: async (e) => {
            if (e.startsWith("co_z")) {
              if (this.schemaResolver)
                try {
                  let t = await this.schemaResolver(e);
                  return t && t.$coId && !t.$schema && (t = await this.schemaResolver(t.$coId)), t || void 0;
                } catch (t) {
                  console.warn(`[ValidationEngine] loadSchema failed for ${e}:`, t);
                  return;
                }
              return;
            }
          }
        }), this.ajv.addFormat("uri-reference", {
          type: "string",
          validate: (e) => {
            if (!e || typeof e != "string") return !1;
            if (e === "") return !0;
            try {
              return new URL(e), !0;
            } catch {
              return !0;
            }
          }
        }), this.ajv.addFormat("regex", {
          type: "string",
          validate: (e) => {
            if (!e || typeof e != "string") return !1;
            try {
              return new RegExp(e), !0;
            } catch {
              return !1;
            }
          }
        }), this._loadMetaSchema(), this._loadCoJsonMetaSchema(), NB(this.ajv), await this._loadCoTypeDefinitions(), this.registrySchemas && await this.registerAllSchemas(this.registrySchemas), this.initialized = !0;
      })(), await this.ajvPromise;
    }
  }
  /**
   * Get the CoJSON custom meta-schema (extends JSON Schema Draft 2020-12)
   * @returns {Object} Meta schema object
   */
  static getMetaSchema() {
    return Ti;
  }
  /**
   * Get the base JSON Schema Draft 2020-12 meta-schema
   * @returns {Object} Meta schema object
   */
  static getBaseMetaSchema() {
    return Ti;
  }
  /**
   * Load JSON Schema Draft 2020-12 meta-schema (hardcoded)
   * @private
   */
  _loadMetaSchema() {
    const A = "https://json-schema.org/draft/2020-12/schema", e = "@schema/meta-schema", t = Me.getBaseMetaSchema();
    try {
      _A(this.ajv, () => {
        if (this.ajv.getSchema(A) || this.ajv.addMetaSchema(t, t.$id), !this.ajv.getSchema(e)) {
          const o = JSON.parse(JSON.stringify(t));
          o.$id = e, this.ajv.addMetaSchema(o, e);
        }
      });
    } catch (o) {
      if (!o.message || !o.message.includes("already exists")) {
        console.warn("[ValidationEngine] Failed to add meta-schema:", o.message);
        return;
      }
    }
  }
  /**
   * Load CoJSON custom meta-schema
   * @private
   */
  _loadCoJsonMetaSchema() {
    const A = "@schema/meta";
    try {
      _A(this.ajv, () => {
        this.ajv.getSchema(A) || this.ajv.addMetaSchema(Ti, A);
      });
    } catch (e) {
      (!e.message || !e.message.includes("already exists")) && console.warn("[ValidationEngine] Failed to add CoJSON meta-schema:", e.message);
    }
  }
  /**
   * Resolve meta-schema ID from co-id or return as-is
   * @private
   * @param {string} schemaMetaSchemaId - Meta-schema ID (may be co-id)
   * @returns {Promise<{resolvedMetaSchemaId: string, metaSchemaObject: Object|null}>}
   */
  async _resolveMetaSchemaId(A) {
    let e = A, t = null;
    if (A.startsWith("co_z"))
      if (this.schemaResolver)
        if (t = await this.schemaResolver(A), t && t.$id)
          e = t.$id;
        else if (this.ajv.getSchema(A))
          e = A;
        else
          throw new Error(`[ValidationEngine] Could not resolve meta-schema co-id '${A}'. Schema resolver returned null or undefined.`);
      else if (this.ajv.getSchema(A))
        e = A;
      else
        throw new Error(`[ValidationEngine] Meta-schema co-id '${A}' not found and no schema resolver available.`);
    return { resolvedMetaSchemaId: e, metaSchemaObject: t };
  }
  /**
   * Determine meta-schema type (CoJSON vs standard JSON Schema)
   * @private
   * @param {Object} metaSchemaObject - Resolved meta-schema object
   * @returns {string} Target meta-schema ID ('@schema/meta' or standard meta-schema ID)
   */
  _determineMetaSchemaType(A) {
    const e = A.properties && A.properties.cotype && A.properties.cotype.enum && Array.isArray(A.properties.cotype.enum) && A.properties.cotype.enum.includes("comap"), t = A.$vocabulary && A.$vocabulary["https://maiaos.dev/vocab/cojson"] === !0;
    return e || t ? "@schema/meta" : A.$vocabulary ? "https://json-schema.org/draft/2020-12/schema" : "@schema/meta";
  }
  /**
   * Get meta-schema validator, registering if necessary
   * @private
   * @param {string} resolvedMetaSchemaId - Resolved meta-schema ID
   * @param {Object|null} metaSchemaObject - Resolved meta-schema object (if available)
   * @returns {Function|null} Meta-schema validator function
   */
  _getMetaSchemaValidator(A, e) {
    if (A === "@schema/meta" || A === "@schema/meta-schema")
      return this.ajv.getSchema("@schema/meta");
    if (A === "https://json-schema.org/draft/2020-12/schema")
      return this.ajv.getSchema("https://json-schema.org/draft/2020-12/schema");
    if (A.startsWith("co_z")) {
      let t = this.ajv.getSchema(A);
      if (!t && e) {
        const o = this._determineMetaSchemaType(e);
        if (t = this.ajv.getSchema(o), !t && e)
          try {
            _A(this.ajv, () => {
              this.ajv.addSchema(e, A), o !== A && this.ajv.addSchema(e, o), t = this.ajv.getSchema(o);
            });
          } catch {
            t = this.ajv.getSchema(o);
          }
      }
      if (!t)
        throw new Error(`[ValidationEngine] Meta-schema validator not found for co-id '${A}'. Make sure the meta-schema is registered in AJV.`);
      return t;
    } else
      throw new Error(`[ValidationEngine] Unknown meta schema (resolved to '${A}'). Expected '@schema/meta' or standard JSON Schema meta schema.`);
  }
  /**
   * Validate a schema against its meta-schema
   * @param {Object} schema - Schema to validate
   * @returns {{valid: boolean, errors: Array|null}} Validation result
   */
  async validateSchemaAgainstMeta(A) {
    await this.initialize();
    const e = A.$schema;
    if (!e)
      throw new Error("[ValidationEngine] Schema missing required $schema field. All schemas must declare their meta schema.");
    const { resolvedMetaSchemaId: t, metaSchemaObject: o } = await this._resolveMetaSchemaId(e), g = this._getMetaSchemaValidator(t, o);
    if (!g)
      return console.warn(`[ValidationEngine] Meta schema '${e}' not available, skipping schema validation`), { valid: !0, errors: null };
    const r = "https://json-schema.org/draft/2020-12/schema";
    if (A.$id === r || A.$id === "@schema/meta" || A.$schema === r && A.$id && A.$id.includes("schema"))
      return _A(this.ajv, () => {
        if (g(A))
          return { valid: !0, errors: null };
        const c = g.errors || [];
        return {
          valid: !1,
          errors: me(c)
        };
      });
    if (g(A))
      return { valid: !0, errors: null };
    const a = g.errors || [];
    return {
      valid: !1,
      errors: me(a)
    };
  }
  /**
   * Load a schema for a given type
   * @param {string} type - Schema type identifier (e.g., 'actor', 'context', 'state')
   * @param {object} schema - JSON Schema object
   */
  async loadSchema(A, e) {
    if (await this.initialize(), !A || typeof A != "string")
      throw new Error("Schema type must be a non-empty string");
    if (!e || typeof e != "object")
      throw new Error("Schema must be an object");
    if (this.schemas.has(A))
      return this.schemas.get(A);
    if (await this._resolveAndRegisterSchemaDependencies(e), e.$id) {
      const t = this.ajv.getSchema(e.$id);
      if (t)
        return this.schemas.set(A, t), t;
    }
    try {
      const t = this.ajv.compile(e);
      return this.schemas.set(A, t), t;
    } catch (t) {
      if (t.message && t.message.includes("already exists") && e.$id) {
        const o = this.ajv.getSchema(e.$id);
        if (o)
          return this.schemas.set(A, o), o;
      }
      throw new Error(`Failed to load schema for type '${A}': ${t.message}`);
    }
  }
  /**
   * Resolve $schema reference (co-id) and register meta-schema
   * @private
   * @param {string} coId - Co-id of the meta-schema
   * @param {Set} resolvedSchemas - Set of already resolved schema co-ids
   * @param {Set} resolvingSchemas - Set of schemas currently being resolved
   * @param {Function} resolveRecursive - Recursive resolution function
   * @returns {Promise<void>}
   */
  async _resolveSchemaReference(A, e, t, o) {
    if (!(e.has(A) || t.has(A))) {
      t.add(A);
      try {
        let g = await this.schemaResolver(A);
        g && g.$coId && !g.$schema && (g = await this.schemaResolver(g.$coId)), g ? (await o(g), g.$id && (this.ajv.getSchema(g.$id) || this.ajv.addMetaSchema(g, g.$id)), this.ajv.getSchema(A) || this.ajv.addMetaSchema(g, A), e.add(A)) : console.warn(`[ValidationEngine] Schema resolver returned null for $schema co-id ${A}`);
      } catch (g) {
        throw console.error(`[ValidationEngine] Failed to resolve $schema co-id ${A}:`, g), g;
      } finally {
        t.delete(A);
      }
    }
  }
  /**
   * Register a resolved schema in AJV
   * @private
   * @param {Object} schema - Schema to register
   * @param {string} ref - Reference ID (should be co-id after transformation)
   * @param {string} coId - Co-id of the schema
   */
  _registerResolvedSchema(A, e, t) {
    if (e && e.startsWith("@schema/") && console.warn(`[ValidationEngine] Warning: Registering schema with @schema/ reference: ${e}. This should be a co-id after seeding. Schema may be from source files instead of database.`), e !== t && e && !this.ajv.getSchema(e))
      try {
        _A(this.ajv, () => {
          this.ajv.addSchema(A, e);
        });
      } catch (o) {
        if (!(o.message && o.message.includes("already exists"))) throw o;
      }
    if (t && !this.ajv.getSchema(t))
      try {
        _A(this.ajv, () => {
          this.ajv.addSchema(A, t);
        });
      } catch (o) {
        if (!(o.message && o.message.includes("already exists"))) throw o;
      }
  }
  /**
   * Resolve $co reference and register schema
   * @private
   * @param {string} ref - Reference (co-id or human-readable ID)
   * @param {Set} resolvedSchemas - Set of already resolved schema co-ids
   * @param {Set} resolvingSchemas - Set of schemas currently being resolved
   * @param {Function} resolveRecursive - Recursive resolution function
   * @returns {Promise<void>}
   */
  async _resolveCoReference(A, e, t, o) {
    if (!(e.has(A) || t.has(A))) {
      A && A.startsWith("@schema/") && console.warn(`[ValidationEngine] Warning: Resolving $co reference with @schema/ pattern: ${A}. This should be a co-id after seeding. The schema may not have been transformed correctly.`), t.add(A);
      try {
        let g = await this.schemaResolver(A);
        if (g && g.$coId && !g.$schema && (g = await this.schemaResolver(g.$coId)), !g) {
          const n = `[ValidationEngine] Schema resolver returned null for $co reference ${A}. This schema must be registered before it can be referenced. If this is an @schema/... reference, ensure schemas were transformed correctly during seeding.`;
          throw console.error(n), new Error(n);
        }
        const r = g.$id;
        if (r && e.has(r)) {
          t.delete(A);
          return;
        }
        await o(g), r && e.add(r), e.add(A), this._registerResolvedSchema(g, A, r);
      } catch (g) {
        if (g.message && g.message.includes("already exists"))
          console.warn(`[ValidationEngine] Duplicate registration handled for ${A}`);
        else
          throw console.error(`[ValidationEngine] Failed to resolve $co reference ${A}:`, g), g;
      } finally {
        t.delete(A);
      }
    }
  }
  /**
   * Resolve and register all schema dependencies ($schema and $co references)
   * @private
   * @param {Object} schema - Schema object
   */
  async _resolveAndRegisterSchemaDependencies(A) {
    !A || typeof A != "object" || !this.schemaResolver || await _A(this.ajv, async () => {
      const e = /* @__PURE__ */ new Set(), t = /* @__PURE__ */ new Set(), o = async (g) => {
        if (!(!g || typeof g != "object")) {
          g.$schema && typeof g.$schema == "string" && g.$schema.startsWith("co_z") && await this._resolveSchemaReference(g.$schema, e, t, o), g.$co && typeof g.$co == "string" && await this._resolveCoReference(g.$co, e, t, o);
          for (const r of Object.values(g))
            if (Array.isArray(r))
              for (const n of r)
                await o(n);
            else r && typeof r == "object" && await o(r);
        }
      };
      await o(A);
    });
  }
  /**
   * Check if a schema is loaded
   * @param {string} type - Schema type identifier
   * @returns {boolean} True if schema is loaded
   */
  hasSchema(A) {
    return this.schemas.has(A);
  }
  /**
   * Validate data against a schema
   * @param {string} type - Schema type identifier
   * @param {any} data - Data to validate
   * @returns {{valid: boolean, errors: Array|null}} Validation result
   */
  async validate(A, e) {
    if (await this.initialize(), !this.schemas.has(A))
      throw new Error(`Schema '${A}' not loaded. Call loadSchema() first.`);
    const t = this.schemas.get(A);
    if (t(e))
      return {
        valid: !0,
        errors: null
      };
    const g = t.errors || [];
    return {
      valid: !1,
      errors: me(g)
    };
  }
  /**
   * Validate data and throw if invalid
   * @param {string} type - Schema type identifier
   * @param {any} data - Data to validate
   * @param {string} context - Optional context for error message (e.g., file path)
   * @throws {Error} If validation fails
   */
  async validateOrThrow(A, e, t = "") {
    const o = await this.validate(A, e);
    if (!o.valid) {
      const g = t ? ` in ${t}` : "", r = o.errors.map((n) => `  - ${n.instancePath}: ${n.message}`).join(`
`);
      throw new Error(
        `Validation failed for '${A}'${g}:
${r}`
      );
    }
    return o;
  }
  /**
   * Load co-type definitions into AJV (REQUIRED for all CoValue validation)
   * @private
   */
  async _loadCoTypeDefinitions() {
    const e = {
      $id: "https://maia.city/schemas/co-types",
      $defs: (await Promise.resolve().then(() => CB)).$defs
    };
    if (!this.ajv.getSchema(e.$id))
      try {
        _A(this.ajv, () => {
          this.ajv.addSchema(e, e.$id);
        });
      } catch (t) {
        (!t.message || !t.message.includes("already exists")) && console.warn("[ValidationEngine] Failed to add co-type definitions:", t.message);
      }
  }
  /**
   * Register all schemas from registry into AJV (MIGRATIONS/SEEDING ONLY)
   * @param {Object} schemas - Map of schema names to schema definitions
   * @returns {Promise<void>}
   */
  async registerAllSchemas(A) {
    if (await this.initialize(), !A || typeof A != "object")
      return;
    const e = this.ajv, t = e.opts.validateSchema;
    e.opts.validateSchema = !1;
    try {
      for (const [o, g] of Object.entries(A))
        if (g && g.$id && !e.getSchema(g.$id))
          try {
            e.addSchema(g, g.$id);
          } catch (r) {
            r.message.includes("already exists") || console.warn(`[ValidationEngine] Failed to add schema ${o}:`, r);
          }
    } finally {
      e.opts.validateSchema = t;
    }
  }
  /**
   * Validate data against a schema by name (MIGRATIONS/SEEDING ONLY)
   * CRITICAL: This method is ONLY for migrations/seeding
   * Runtime validation MUST use validateAgainstSchema() with schema loaded from CoValue header metadata
   * 
   * @param {string} schemaName - Schema name (human-readable ID from registry)
   * @param {any} data - Data to validate
   * @returns {Promise<{valid: boolean, errors: Array|null}>} Validation result
   */
  async validateData(A, e) {
    if (await this.initialize(), !this.registrySchemas)
      throw new Error("[ValidationEngine] validateData() requires registrySchemas. This method is ONLY for migrations/seeding. Runtime validation must use validateAgainstSchema() with schema from CoValue header metadata.");
    const t = this.registrySchemas[A];
    if (!t)
      return {
        valid: !1,
        errors: [{ message: `Schema '${A}' not found in registry` }]
      };
    let o;
    if (t.$id && (o = this.ajv.getSchema(t.$id)), !o)
      try {
        await this._resolveAndRegisterSchemaDependencies(t), o = this.ajv.compile(t);
      } catch (g) {
        return {
          valid: !1,
          errors: [{ message: `Failed to compile schema '${A}': ${g.message}` }]
        };
      }
    try {
      if (o(e))
        return {
          valid: !0,
          errors: null
        };
      const r = o.errors || [];
      return {
        valid: !1,
        errors: me(r)
      };
    } catch (g) {
      return {
        valid: !1,
        errors: [{ message: `Validation error: ${g.message}` }]
      };
    }
  }
}
function ca(i, A, e = {}) {
  if (!i || typeof i != "object")
    return i;
  const t = i.$schema;
  if (t === "@schema/meta" || typeof t == "string" && t.startsWith("https://json-schema.org/") || typeof t == "string" && t.startsWith("https://"))
    return De(i, A);
  const g = i.actor !== void 0 || i.context !== void 0 || i.view !== void 0 || i.state !== void 0 || i.brand !== void 0 || i.style !== void 0 || i.inbox !== void 0 || i.subscribers !== void 0 || i.name !== void 0 && i.description !== void 0;
  return t && typeof t == "string" && t.startsWith("@schema/") && t !== "@schema/meta" || g ? Fr(i, A, e) : i.properties !== void 0 || i.$defs !== void 0 || i.items !== void 0 && typeof i.items == "object" && !Array.isArray(i.items) || i.cotype !== void 0 ? De(i, A) : Fr(i, A, e);
}
function De(i, A) {
  if (!i || typeof i != "object")
    return i;
  const e = JSON.parse(JSON.stringify(i));
  if (e.$schema) {
    const o = e.$schema;
    if (o.startsWith("@schema/")) {
      const g = A.get(o);
      g && (e.$schema = g);
    }
  }
  if (e.$id && typeof e.$id == "string" && (e.$id.startsWith("@schema/") || e.$id.startsWith("https://"))) {
    const o = A.get(e.$id);
    o && (e.$id = o);
  }
  if (e.properties && JB(e.properties, A), e.$defs)
    for (const [o, g] of Object.entries(e.$defs))
      e.$defs[o] = De(g, A);
  return gg(e, A, e.$id || "root") > 0 && e.$id, e.items && (e.items = De(e.items, A)), e.additionalProperties && typeof e.additionalProperties == "object" && (e.additionalProperties = De(e.additionalProperties, A)), ["allOf", "anyOf", "oneOf"].forEach((o) => {
    e[o] && Array.isArray(e[o]) && (e[o] = e[o].map(
      (g) => De(g, A)
    ));
  }), e;
}
function JB(i, A) {
  for (const [e, t] of Object.entries(i))
    t && typeof t == "object" && (i[e] = De(t, A));
}
function gg(i, A, e = "") {
  if (!i || typeof i != "object")
    return 0;
  let t = 0;
  if (i.$co && typeof i.$co == "string") {
    const o = i.$co;
    if (o.startsWith("co_z"))
      return 0;
    if (o.startsWith("@schema/")) {
      const g = A.get(o);
      if (g)
        i.$co = g, t++;
      else {
        const r = Array.from(A.keys()).filter((n) => n.startsWith("@schema/")).slice(0, 10).join(", ");
        throw console.error(`[SchemaTransformer]  No co-id found for $co reference at ${e || "root"}: ${o}. Available schema keys (first 10): ${r}`), new Error(`[SchemaTransformer] Failed to transform $co reference: ${o}. Schema must be registered before it can be referenced.`);
      }
    }
  }
  for (const [o, g] of Object.entries(i))
    if (!(o === "$schema" || o === "$id" || o.startsWith("$")))
      if (g && typeof g == "object" && !Array.isArray(g)) {
        const r = e ? `${e}.${o}` : o;
        t += gg(g, A, r);
      } else Array.isArray(g) && g.forEach((r, n) => {
        if (r && typeof r == "object") {
          const s = e ? `${e}.${o}[${n}]` : `${o}[${n}]`;
          t += gg(r, A, s);
        }
      });
  return t;
}
function Fr(i, A, e = {}) {
  if (!i || typeof i != "object")
    return i;
  const t = JSON.parse(JSON.stringify(i));
  if (t.$schema) {
    const g = t.$schema;
    if (g.startsWith("@schema/")) {
      const r = A.get(g);
      r && (t.$schema = r);
    }
  }
  if (t.$id && typeof t.$id == "string" && !t.$id.startsWith("co_z")) {
    const g = t.$id.startsWith("@schema/") || t.$id.startsWith("vibe/") || t.$id.startsWith("actor/") || t.$id.startsWith("view/") || t.$id.startsWith("context/") || t.$id.startsWith("state/") || t.$id.startsWith("interface/") || t.$id.startsWith("style/") || t.$id.startsWith("brand/") || t.$id.startsWith("tool/"), r = A.get(t.$id);
    r ? t.$id = r : g && console.warn(`[SchemaTransformer] No co-id found for $id: ${t.$id}`);
  }
  const o = ["actor", "context", "view", "state", "brand", "style", "inbox", "subscribers"];
  for (const g of o)
    if (t[g] && typeof t[g] == "string") {
      const r = t[g];
      if (r.startsWith("co_z"))
        continue;
      if (!r.startsWith("@"))
        throw new Error(`[SchemaTransformer] ${g} reference must use @maiatype/instance format, got: ${r}`);
      const n = A.get(r);
      if (n)
        t[g] = n;
      else {
        const s = Array.from(A.keys()).filter((a) => a.startsWith("@")).slice(0, 10).join(", ");
        throw new Error(
          `[SchemaTransformer] No co-id found for ${g} reference: ${r}. Make sure the referenced instance exists and has a unique $id. Available refs (first 10): ${s}`
        );
      }
    }
  if (t.actors && typeof t.actors == "object" && !Array.isArray(t.actors)) {
    for (const [g, r] of Object.entries(t.actors))
      if (typeof r == "string") {
        if (r.startsWith("co_z"))
          continue;
        if (!r.match(/^@[^/]+\/actor\//))
          throw new Error(`[SchemaTransformer] context.actors[${g}] must use @namespace/actor/instance format, got: ${r}`);
        const n = A.get(r);
        if (n)
          t.actors[g] = n;
        else
          throw new Error(
            `[SchemaTransformer] No co-id found for context.actors[${g}] reference: ${r}. Make sure the referenced actor exists and has a unique $id.`
          );
      }
  }
  if (t.children && typeof t.children == "object") {
    for (const [g, r] of Object.entries(t.children))
      if (typeof r == "string" && !r.startsWith("co_z")) {
        if (!r.match(/^@[^/]+\/actor\//))
          throw new Error(`[SchemaTransformer] children[${g}] reference must use @namespace/actor/instance format, got: ${r}`);
        const n = A.get(r);
        if (n)
          t.children[g] = n;
        else {
          const s = Array.from(A.keys()).filter((a) => a.startsWith("@actor/")).slice(0, 10).join(", ");
          throw new Error(
            `[SchemaTransformer] No co-id found for children[${g}] reference: ${r}. Available actors (first 10): ${s}`
          );
        }
      }
  }
  if (t.items && Array.isArray(t.items) && t.items.some(
    (r) => typeof r == "string" && r.startsWith("@") && !r.startsWith("co_z")
  ) && (t.items = t.items.map((r) => {
    if (typeof r == "string" && !r.startsWith("co_z")) {
      if (!r.startsWith("@"))
        throw new Error(`[SchemaTransformer] items array reference must use @maiatype/instance format, got: ${r}`);
      const n = A.get(r);
      if (n)
        return n;
      throw new Error(`[SchemaTransformer] No co-id found for items reference: ${r}. Make sure the referenced instance exists and has a unique $id.`);
    }
    return r;
  })), t.source && typeof t.source == "string" && !t.source.startsWith("co_z")) {
    if (!t.source.startsWith("@"))
      throw new Error(`[SchemaTransformer] source reference must use @actor/instance format, got: ${t.source}`);
    const g = A.get(t.source);
    if (g)
      t.source = g;
    else
      throw new Error(`[SchemaTransformer] No co-id found for source reference: ${t.source}`);
  }
  if (t.target && typeof t.target == "string" && !t.target.startsWith("co_z")) {
    if (!t.target.match(/^@[^/]+\/actor\//))
      throw new Error(`[SchemaTransformer] target reference must use @namespace/actor/instance format, got: ${t.target}`);
    const g = A.get(t.target);
    if (g)
      t.target = g;
    else
      throw new Error(`[SchemaTransformer] No co-id found for target reference: ${t.target}`);
  }
  if (t.states && typeof t.states == "object" && !Array.isArray(t.states)) {
    for (const [g, r] of Object.entries(t.states))
      if (!(!r || typeof r != "object")) {
        if (r.entry)
          if (r.entry.tool && r.entry.payload)
            St(r.entry.payload, A, JA);
          else if (r.entry.mapData && typeof r.entry.mapData == "object") {
            const n = r.entry.mapData;
            for (const [s, a] of Object.entries(n)) {
              if (a && typeof a == "object" && a.schema && typeof a.schema == "string") {
                const I = Ze(a.schema, A, `mapData.${s}.schema`);
                I && (a.schema = I);
              }
              a && typeof a == "object" && JA(a, A);
            }
          } else Array.isArray(r.entry) ? rg(r.entry, A, JA) : r.entry.payload && St(r.entry.payload, A, JA);
        if (r.on && typeof r.on == "object")
          for (const [n, s] of Object.entries(r.on))
            s && typeof s == "object" && Array.isArray(s.actions) && rg(s.actions, A, JA);
      }
  }
  return JA(t, A), t;
}
function Ze(i, A, e = "") {
  if (i.startsWith("@schema/") && !i.startsWith("co_z")) {
    const t = A.get(i);
    return t || (console.warn(`[SchemaTransformer] No co-id found for ${e} schema: ${i}. Make sure data collections are registered before transformation.`), null);
  }
  return i;
}
function mt(i, A, e = "") {
  if (i.match(/^@[^/]+\/actor\//) && !i.startsWith("co_z")) {
    const t = A.get(i);
    if (t)
      return t;
    {
      const o = Array.from(A.keys()).filter((s) => s.includes("actor") || s.includes("vibe") || s.includes("composite")), g = o.length, r = o.slice(0, e.includes("array") ? 10 : 20).join(", "), n = g > (e.includes("array") ? 10 : 20) ? "..." : "";
      return console.warn(`[SchemaTransformer]  No co-id found for ${e} target: ${i}. Available actor keys (${g}): ${r}${n}`), null;
    }
  }
  return i;
}
function HB(i, A) {
  if (!("key" in i && !("op" in i)) && i.schema && typeof i.schema == "string") {
    const e = Ze(i.schema, A, "query object");
    e && (i.schema = e);
  }
}
function St(i, A, e) {
  if (!(!i || typeof i != "object")) {
    if (e(i, A), i.schema && typeof i.schema == "string") {
      const t = Ze(i.schema, A, "tool payload");
      t && (i.schema = t);
    }
    if (i.target && typeof i.target == "string") {
      const t = mt(i.target, A, "tool payload");
      t && (i.target = t);
    }
  }
}
function Ba(i, A, e) {
  if (!(!i.payload || typeof i.payload != "object")) {
    if (i.payload.target && typeof i.payload.target == "string") {
      const t = mt(i.payload.target, A, "tool action");
      t && (i.payload.target = t);
    }
    e(i.payload, A);
  }
}
function rg(i, A, e) {
  for (let t = 0; t < i.length; t++) {
    const o = i[t];
    if (o && typeof o == "object")
      if (o.mapData && typeof o.mapData == "object")
        for (const [g, r] of Object.entries(o.mapData)) {
          if (r && typeof r == "object" && r.schema && typeof r.schema == "string") {
            const n = Ze(r.schema, A, `mapData.${g}.schema in array`);
            n && (r.schema = n);
          }
          r && typeof r == "object" && e(r, A);
        }
      else if (o.tool && typeof o.tool == "string" && o.payload && typeof o.payload == "object")
        Ba(o, A, e), St(o.payload, A, e);
      else if (o.payload && typeof o.payload == "object") {
        if (o.payload.target && typeof o.payload.target == "string") {
          const g = mt(o.payload.target, A, "action payload.target in array");
          g && (o.payload.target = g);
        }
        St(o.payload, A, e);
      } else
        e(o, A);
    else if (typeof o == "string" && o.startsWith("@actor/") && !o.startsWith("co_z")) {
      const g = A.get(o);
      g && (i[t] = g);
    }
  }
}
function JA(i, A, e = 0) {
  if (!(!i || typeof i != "object" || Array.isArray(i))) {
    for (const [t, o] of Object.entries(i))
      if (!(t === "$schema" || t === "$id" || t.startsWith("$"))) {
        if (t === "schema" && typeof o == "string") {
          const g = Ze(o, A, "top-level schema field");
          g && (i[t] = g);
          continue;
        }
        if (t === "@actors" && o && typeof o == "object" && !Array.isArray(o)) {
          for (const [g, r] of Object.entries(o))
            if (typeof r == "string") {
              if (r.startsWith("co_z"))
                continue;
              if (!r.match(/^@[^/]+\/actor\//))
                throw new Error(`[SchemaTransformer] context.@actors[${g}] must use @namespace/actor/instance format, got: ${r}`);
              const n = mt(r, A, `context.@actors[${g}]`);
              n && (o[g] = n);
            }
          continue;
        }
        if (t === "actors" && o && typeof o == "object" && !Array.isArray(o))
          throw new Error('[SchemaTransformer] Legacy "actors" property found. Please migrate to "@actors" system property.');
        if (t === "target" && typeof o == "string") {
          const g = mt(o, A, "target field");
          g && (i[t] = g);
          continue;
        }
        if (o && typeof o == "object" && !Array.isArray(o))
          if (o.mapData && typeof o.mapData == "object") {
            const g = o.mapData;
            for (const [r, n] of Object.entries(g)) {
              if (n && typeof n == "object" && n.schema && typeof n.schema == "string") {
                const s = Ze(n.schema, A, `mapData.${r}.schema`);
                s && (n.schema = s);
              }
              n && typeof n == "object" && JA(n, A, e + 1);
            }
            continue;
          } else o.schema && typeof o.schema == "string" && !("key" in o) && !("op" in o) ? HB(o, A) : o.payload && typeof o.payload == "object" ? St(o.payload, A, JA) : o.tool && typeof o.tool == "string" && o.payload && typeof o.payload == "object" ? Ba(o, A, JA) : JA(o, A, e + 1);
        else o && typeof o == "object" && Array.isArray(o) && rg(o, A, JA);
      }
  }
}
function $i(i, A = "", e = {}) {
  const { checkSchemaReferences: t = !0, checkNestedCoTypes: o = !0 } = e, g = [];
  if (!i || typeof i != "object")
    return g;
  if (t && (i.$co && typeof i.$co == "string" && i.$co.startsWith("@schema/") && g.push(`Found @schema/ reference in $co at ${A || "root"}: ${i.$co}. All $co references must be transformed to co-ids.`), i.$schema && typeof i.$schema == "string" && i.$schema.startsWith("@schema/") && g.push(`Found @schema/ reference in $schema at ${A || "root"}: ${i.$schema}. $schema must be transformed to co-id.`), i.$id && typeof i.$id == "string" && i.$id.startsWith("@schema/") && g.push(`Found @schema/ reference in $id at ${A || "root"}: ${i.$id}. $id must be transformed to co-id.`)), o && i.cotype && A !== "")
    return g.push(`Nested co-type detected at ${A}. Use \`$co\` keyword to reference a separate CoValue entity instead.`), g;
  for (const [r, n] of Object.entries(i))
    if (n && typeof n == "object" && !Array.isArray(n)) {
      const s = A ? `${A}.${r}` : r, a = $i(n, s, e);
      g.push(...a);
    } else Array.isArray(n) && n.forEach((s, a) => {
      if (s && typeof s == "object") {
        const I = A ? `${A}.${r}[${a}]` : `${r}[${a}]`, C = $i(s, I, e);
        g.push(...C);
      }
    });
  return g;
}
const Qa = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  transformForSeeding: ca,
  validateSchemaStructure: $i
}, Symbol.toStringTag, { value: "Module" }));
class Ea {
  constructor() {
    this.registry = /* @__PURE__ */ new Map(), this.reverseRegistry = /* @__PURE__ */ new Map();
  }
  /**
   * Register a co-id for a human-readable ID
   * @param {string} humanId - Human-readable ID (e.g., "@schema/actor", "actor_001")
   * @param {string} coId - Generated co-id
   */
  register(A, e) {
    if (this.registry.has(A)) {
      const t = this.registry.get(A);
      if (t !== e)
        throw new Error(`Co-id already registered for ${A}: ${t} (trying to register ${e})`);
      return;
    }
    this.registry.set(A, e), this.reverseRegistry.has(e) || this.reverseRegistry.set(e, A);
  }
  /**
   * Get co-id for a human-readable ID
   * @param {string} humanId - Human-readable ID
   * @returns {string|null} Co-id or null if not found
   */
  get(A) {
    return this.registry.get(A) || null;
  }
  /**
   * Get human-readable ID for a co-id
   * @param {string} coId - Co-id
   * @returns {string|null} Human-readable ID or null if not found
   */
  getHumanId(A) {
    return this.reverseRegistry.get(A) || null;
  }
  /**
   * Check if human-readable ID is registered
   * @param {string} humanId - Human-readable ID
   * @returns {boolean}
   */
  has(A) {
    return this.registry.has(A);
  }
  /**
   * Get all registered mappings
   * @returns {Map<string, string>} Map of human-readable ID  co-id
   */
  getAll() {
    return new Map(this.registry);
  }
  /**
   * Clear all registrations
   */
  clear() {
    this.registry.clear(), this.reverseRegistry.clear();
  }
}
const qB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CoIdRegistry: Ea
}, Symbol.toStringTag, { value: "Module" })), LB = "@schema/meta", xB = "@schema/actor", TB = "@schema/actor", OB = "Pure declarative actor specification", PB = "comap", jB = !0, VB = { role: { type: "string", description: "Actor role (e.g., 'kanban-view', 'vibe', 'composite', 'leaf')" }, context: { $co: "@schema/context", description: "Co-id reference to context definition" }, view: { $co: "@schema/view", description: "Co-id reference to view definition" }, state: { $co: "@schema/state", description: "Co-id reference to state machine definition" }, brand: { $co: "@schema/style", description: "Co-id reference to brand style definition (uses style schema)" }, style: { $co: "@schema/style", description: "Co-id reference to local style definition" }, inbox: { $co: "@schema/inbox", description: "Co-id reference to message inbox costream (append-only message feed)" }, messageTypes: { type: "array", items: { type: "string" }, description: "REQUIRED: Message types this actor accepts (exhaustive list - like sealed protocol). All actors must declare their message contracts." } }, WB = {
  $schema: LB,
  $id: xB,
  title: TB,
  description: OB,
  cotype: PB,
  indexing: jB,
  properties: VB
}, zB = "@schema/meta", $B = "@schema/context", ZB = "@schema/context", _B = "Runtime data for an actor (flexible JSON structure). The context itself is a comap CoValue (for CRDT sync/versioning), but all inner properties are plain JS objects/arrays/strings - NOT CoJSON types.", XB = "comap", AQ = !0, eQ = { description: "Any context fields (query objects, collections, UI state, form values, etc.). Query objects have schema + options properties. All inner properties are plain JS types (objects/arrays/strings/primitives) - NOT CoJSON types.", anyOf: [{ type: "object", description: "Query object for reactive subscription (has schema property). Can include nested options object with map, filter, etc.", properties: { schema: { type: "string", description: "Schema reference (e.g., '@schema/message' or co-id)" }, options: { type: "object", description: "Query options (map, filter, etc.)", properties: { map: { type: "object", description: "Map transformation expressions (e.g., { sender: '$$source.role' })", additionalProperties: { type: "string" } }, filter: { description: "Filter criteria", oneOf: [{ type: "object" }, { type: "null" }] } }, additionalProperties: !0 }, filter: { description: "Filter criteria (legacy - use options.filter instead)", oneOf: [{ type: "object" }, { type: "null" }] } }, required: ["schema"], additionalProperties: !0 }, { type: "array", description: "Array of data items (after SubscriptionEngine processes the query object)" }, { type: "string" }, { type: "number" }, { type: "boolean" }, { type: "null" }, { type: "object", description: "Any other nested object (UI state, form values, etc.)" }] }, tQ = {
  $schema: zB,
  $id: $B,
  title: ZB,
  description: _B,
  cotype: XB,
  indexing: AQ,
  additionalProperties: eQ
}, iQ = "@schema/meta", oQ = "@schema/state", gQ = "@schema/state", rQ = "XState-like state machine with states, transitions, guards, and actions", nQ = "comap", sQ = !0, aQ = ["initial", "states"], IQ = { initial: { type: "string", description: "Initial state name" }, states: { type: "object", description: "State definitions", additionalProperties: { type: "object", properties: { entry: { oneOf: [{ type: "object", description: "Inline tool action object", properties: { tool: { type: "string", description: "Tool identifier" }, payload: { type: "object", description: "Tool payload", additionalProperties: !0 } }, required: ["tool"] }, { type: "object", description: "Infrastructure context update action", properties: { updateContext: { type: "object", description: "Context updates (infrastructure, not a tool)", additionalProperties: !0 } }, required: ["updateContext"] }, { type: "object", description: "Map operations engine configs to context keys (universal API)", properties: { mapData: { type: "object", description: "Map operations engine configs to context keys (universal API)", additionalProperties: { type: "object", description: "Operations engine config (op, schema, filter, key, keys, etc.)", properties: { op: { type: "string", description: "Operation type (read, create, update, delete, schema, resolve, etc.)", default: "read" } }, additionalProperties: !0 } } }, required: ["mapData"] }, { type: "array", description: "Array of inline action objects", items: { oneOf: [{ type: "object", properties: { tool: { type: "string", description: "Tool identifier" }, payload: { type: "object", description: "Tool payload", additionalProperties: !0 } }, required: ["tool"] }, { type: "object", properties: { updateContext: { type: "object", description: "Context updates (infrastructure, not a tool)", additionalProperties: !0 } }, required: ["updateContext"] }, { type: "object", properties: { mapData: { type: "object", description: "Map operations engine configs to context keys (universal API)", additionalProperties: { type: "object", description: "Operations engine config (op, schema, filter, key, keys, etc.)", properties: { op: { type: "string", description: "Operation type (read, create, update, delete, schema, resolve, etc.)", default: "read" } }, additionalProperties: !0 } } }, required: ["mapData"] }] } }, { $co: "@schema/action", description: "Co-id reference to action CoValue" }, { type: "array", description: "Array of action co-id references", items: { $co: "@schema/action" } }] }, exit: { oneOf: [{ type: "object", description: "Inline tool action object", properties: { tool: { type: "string", description: "Tool identifier" }, payload: { type: "object", description: "Tool payload", additionalProperties: !0 } }, required: ["tool"] }, { type: "object", description: "Infrastructure context update action", properties: { updateContext: { type: "object", description: "Context updates (infrastructure, not a tool)", additionalProperties: !0 } }, required: ["updateContext"] }, { type: "object", description: "Map operations engine configs to context keys (universal API)", properties: { mapData: { type: "object", description: "Map operations engine configs to context keys (universal API)", additionalProperties: { type: "object", description: "Operations engine config (op, schema, filter, key, keys, etc.)", properties: { op: { type: "string", description: "Operation type (read, create, update, delete, schema, resolve, etc.)", default: "read" } }, additionalProperties: !0 } } }, required: ["mapData"] }, { type: "array", description: "Array of inline action objects", items: { oneOf: [{ type: "object", properties: { tool: { type: "string", description: "Tool identifier" }, payload: { type: "object", description: "Tool payload", additionalProperties: !0 } }, required: ["tool"] }, { type: "object", properties: { updateContext: { type: "object", description: "Context updates (infrastructure, not a tool)", additionalProperties: !0 } }, required: ["updateContext"] }, { type: "object", properties: { mapData: { type: "object", description: "Map operations engine configs to context keys (universal API)", additionalProperties: { type: "object", description: "Operations engine config (op, schema, filter, key, keys, etc.)", properties: { op: { type: "string", description: "Operation type (read, create, update, delete, schema, resolve, etc.)", default: "read" } }, additionalProperties: !0 } } }, required: ["mapData"] }] } }, { $co: "@schema/action", description: "Co-id reference to action CoValue" }, { type: "array", description: "Array of action co-id references", items: { $co: "@schema/action" } }] }, on: { type: "object", description: "Event handlers (transitions)", additionalProperties: { oneOf: [{ type: "string", description: "Simple target state name" }, { type: "object", description: "Inline transition object", properties: { target: { type: "string", description: "Target state name" }, guard: { type: "object", description: "Guard condition", additionalProperties: !0 }, actions: { type: "array", description: "Transition actions", items: { oneOf: [{ type: "object", properties: { tool: { type: "string", description: "Tool identifier" }, payload: { type: "object", additionalProperties: !0 } }, required: ["tool"] }, { type: "object", properties: { updateContext: { type: "object", description: "Context updates (infrastructure, not a tool)", additionalProperties: !0 } }, required: ["updateContext"] }, { $co: "@schema/action" }] } } }, required: ["target"] }, { $co: "@schema/transition", description: "Co-id reference to transition CoValue" }] } } }, additionalProperties: !1 } } }, CQ = {
  $schema: iQ,
  $id: oQ,
  title: gQ,
  description: rQ,
  cotype: nQ,
  indexing: sQ,
  required: aQ,
  properties: IQ
}, cQ = "@schema/meta", BQ = "@schema/view", QQ = "@schema/view", EQ = "UI structure definition with DOM tree, expressions, loops, and event handlers (recursive viewNode structure)", lQ = "comap", dQ = !0, hQ = { content: { type: "object", description: "View content structure (recursive viewNode)", $ref: "#/$defs/viewNode" } }, uQ = { viewNode: { type: "object", description: "Recursive DOM node structure", properties: { tag: { type: "string" }, class: { type: "string" }, text: { anyOf: [{ type: "string", pattern: "^\\$\\$" }, { type: "string", pattern: "^@" }, { type: "string", pattern: "^\\$[^$]" }, { type: "string" }, { type: "number" }, { type: "boolean" }, { type: "null" }] }, value: { anyOf: [{ type: "string", pattern: "^\\$\\$" }, { type: "string", pattern: "^@" }, { type: "string", pattern: "^\\$[^$]" }, { type: "string" }, { type: "number" }, { type: "boolean" }, { type: "null" }] }, attrs: { type: "object", additionalProperties: { anyOf: [{ type: "string", pattern: "^\\$\\$" }, { type: "string", pattern: "^@" }, { type: "string", pattern: "^\\$[^$]" }, { type: "string" }, { type: "number" }, { type: "boolean" }, { type: "null" }, { type: "object", additionalProperties: { anyOf: [{ type: "string", pattern: "^\\$\\$" }, { type: "string", pattern: "^@" }, { type: "string", pattern: "^\\$[^$]" }, { type: "string" }, { type: "number" }, { type: "boolean" }, { type: "null" }] } }] } }, children: { type: "array", items: { $ref: "#/$defs/viewNode" } }, $on: { type: "object", additionalProperties: { type: "object", properties: { send: { type: "string" }, payload: { type: "object", additionalProperties: !0 }, key: { type: "string" } }, required: ["send"] } }, $each: { type: "object", properties: { items: { anyOf: [{ type: "string", pattern: "^\\$\\$" }, { type: "string", pattern: "^@" }, { type: "string", pattern: "^\\$[^$]" }, { type: "string" }, { type: "number" }, { type: "boolean" }, { type: "null" }] }, template: { $ref: "#/$defs/viewNode" } }, required: ["items", "template"] }, $slot: { anyOf: [{ type: "string", pattern: "^\\$\\$" }, { type: "string", pattern: "^@" }, { type: "string", pattern: "^\\$[^$]" }, { type: "string" }, { type: "number" }, { type: "boolean" }, { type: "null" }] } }, additionalProperties: !1 } }, fQ = !1, wQ = {
  $schema: cQ,
  $id: BQ,
  title: QQ,
  description: EQ,
  cotype: lQ,
  indexing: dQ,
  properties: hQ,
  $defs: uQ,
  additionalProperties: fQ
}, yQ = "@schema/meta", pQ = "@schema/style", DQ = "@schema/style", mQ = "Style definition (brand or actor-specific). Brand styles typically include selectors, actor styles are overrides.", SQ = "comap", NQ = !0, MQ = { tokens: { type: "object", description: "Design tokens (colors, spacing, typography, etc.)", additionalProperties: !0 }, components: { type: "object", description: "Component styles", additionalProperties: !0 }, selectors: { type: "object", description: "CSS selector-based styles (typically used in brand styles)", additionalProperties: { type: "object", description: "CSS properties and values", additionalProperties: { oneOf: [{ type: "string" }, { type: "number" }, { type: "object", additionalProperties: !0 }] } } } }, Lt = {
  $schema: yQ,
  $id: pQ,
  title: DQ,
  description: mQ,
  cotype: SQ,
  indexing: NQ,
  properties: MQ
}, GQ = "@schema/meta", kQ = "@schema/tool", FQ = "@schema/tool", RQ = "Tool metadata (AI-compatible JSON schema)", bQ = "comap", KQ = !0, YQ = ["name", "description", "parameters"], vQ = { name: { type: "string", description: "Tool identifier (e.g., '@mutation/create')", pattern: "^@" }, description: { type: "string", description: "Tool description" }, parameters: { type: "object", description: "JSON Schema for tool parameters (standard JSON Schema format)", properties: { type: { type: "string", enum: ["object", "array", "string", "number", "boolean", "null"] }, properties: { type: "object", additionalProperties: { type: "object", description: "Parameter property schema", properties: { type: { type: "string" }, description: { type: "string" }, required: { type: "boolean" }, properties: { type: "object", additionalProperties: !0 } }, additionalProperties: !0 } }, required: { type: "array", items: { type: "string" } } }, required: ["type"], additionalProperties: !0 } }, UQ = {
  $schema: GQ,
  $id: kQ,
  title: FQ,
  description: RQ,
  cotype: bQ,
  indexing: KQ,
  required: YQ,
  properties: vQ
}, JQ = "@schema/meta", HQ = "@schema/vibe", qQ = "@schema/vibe", LQ = "Vibe manifest/metadata", xQ = "comap", TQ = !0, OQ = ["name", "description", "actor"], PQ = { name: { type: "string", description: "Vibe name" }, description: { type: "string", description: "Vibe description" }, actor: { $co: "@schema/actor", description: "Co-id reference to actor definition (root actor for this vibe)" } }, jQ = {
  $schema: JQ,
  $id: HQ,
  title: qQ,
  description: LQ,
  cotype: xQ,
  indexing: TQ,
  required: OQ,
  properties: PQ
}, VQ = "@schema/meta", WQ = "@schema/message", zQ = "@schema/message", $Q = "Actor message for state machine transitions", ZQ = "comap", _Q = !0, XQ = ["type"], AE = { type: { type: "string", description: "Message type (event name)" }, payload: { type: "object", description: "Message payload data" }, source: { $co: "@schema/actor", description: "Co-id reference to source actor" }, target: { $co: "@schema/actor", description: "Co-id reference to target actor (required for direct messaging)" }, processed: { type: "boolean", description: "Whether this message has been processed", default: !1 } }, eE = {
  $schema: VQ,
  $id: WQ,
  title: zQ,
  description: $Q,
  cotype: ZQ,
  indexing: _Q,
  required: XQ,
  properties: AE
}, tE = "@schema/meta", iE = "@schema/guard", oE = "@schema/guard", gE = "JSON Schema guard for conditional logic - checks state/context conditions (NOT payload validation)", rE = "comap", nE = !0, sE = ["schema"], aE = { schema: { type: "object", description: "JSON Schema to validate against current state/context (for conditional logic only, NOT payload validation)", additionalProperties: !0 } }, IE = !1, CE = {
  $schema: tE,
  $id: iE,
  title: oE,
  description: gE,
  cotype: rE,
  indexing: nE,
  required: sE,
  properties: aE,
  additionalProperties: IE
}, cE = "@schema/meta", BE = "@schema/action", QE = "@schema/action", EE = "Action (tool invocation, context update, or data mapping)", lE = "comap", dE = !0, hE = [{ type: "object", properties: { tool: { type: "string", description: "Tool identifier (e.g., '@mutation/create')" }, payload: { description: "Tool payload (can contain expressions)", type: "object", additionalProperties: !0 } }, required: ["tool"] }, { type: "object", properties: { updateContext: { type: "object", description: "Context updates (infrastructure, not a tool)", additionalProperties: !0 } }, required: ["updateContext"] }, { type: "object", properties: { mapData: { type: "object", description: "Map operations engine configs to context keys (universal API)", additionalProperties: { type: "object", description: "Operations engine config (op, schema, filter, key, keys, etc.)", properties: { op: { type: "string", description: "Operation type (read, create, update, delete, schema, resolve, etc.)", default: "read" } }, additionalProperties: !0 } } }, required: ["mapData"] }], uE = {
  $schema: cE,
  $id: BE,
  title: QE,
  description: EE,
  cotype: lE,
  indexing: dE,
  oneOf: hE
}, fE = "@schema/meta", wE = "@schema/transition", yE = "@schema/transition", pE = "State machine transition", DE = "comap", mE = !0, SE = { target: { type: "string", description: "Target state name" }, guard: { $co: "@schema/guard" }, actions: { type: "array", items: { $co: "@schema/action" } } }, NE = ["target"], ME = {
  $schema: fE,
  $id: wE,
  title: yE,
  description: pE,
  cotype: DE,
  indexing: mE,
  properties: SE,
  required: NE
}, GE = "@schema/meta", kE = "@schema/messagePayload", FE = "@schema/messagePayload", RE = "Message payload definition", bE = "comap", KE = !0, YE = {}, vE = !0, UE = {
  $schema: GE,
  $id: kE,
  title: FE,
  description: RE,
  cotype: bE,
  indexing: KE,
  properties: YE,
  additionalProperties: vE
}, JE = "@schema/meta", HE = "@schema/messageType", qE = "@schema/messageType", LE = "Message type schemas are standard JSON Schemas that validate message payloads. The schema ID (e.g., '@schema/message/CREATE_BUTTON') identifies the message type.", xE = "comap", TE = !0, OE = "object", PE = !0, jE = {
  $schema: JE,
  $id: HE,
  title: qE,
  description: LE,
  cotype: xE,
  indexing: TE,
  type: OE,
  additionalProperties: PE
}, VE = "@schema/meta", WE = "@schema/maia-script-expression", zE = "@schema/maia-script-expression", $E = "comap", ZE = !1, _E = "JSON-based DSL expression schema for MaiaScript runtime logic. Supports data access, comparisons, logical operations, control flow, and nested expressions.", XE = [{ description: "Primitive value", type: ["number", "boolean", "null"] }, { description: "String value (including shortcut syntax $key or $$key)", type: "string" }, { $ref: "#/$defs/expressionObject" }], Al = { expressionObject: { description: "MaiaScript expression object (DSL operation)", type: "object", oneOf: [{ description: "$context operation - access context data", properties: { $context: { type: "string", description: "Dot-separated path in context object (e.g., 'user.name')", pattern: "^[a-zA-Z_][a-zA-Z0-9_]*(\\.[a-zA-Z_][a-zA-Z0-9_]*)*$" } }, required: ["$context"], additionalProperties: !1 }, { description: "$item operation - access item data", properties: { $item: { type: "string", description: "Dot-separated path in item object (e.g., 'id', 'status.value')", pattern: "^[a-zA-Z_][a-zA-Z0-9_]*(\\.[a-zA-Z_][a-zA-Z0-9_]*)*$" } }, required: ["$item"], additionalProperties: !1 }, { description: "$eq operation - equality comparison", properties: { $eq: { type: "array", description: "Array of two expressions to compare", items: { $ref: "#" }, minItems: 2, maxItems: 2 } }, required: ["$eq"], additionalProperties: !1 }, { description: "$ne operation - inequality comparison", properties: { $ne: { type: "array", description: "Array of two expressions to compare", items: { $ref: "#" }, minItems: 2, maxItems: 2 } }, required: ["$ne"], additionalProperties: !1 }, { description: "$not operation - logical NOT (negate boolean)", properties: { $not: { $ref: "#", description: "Expression to negate (evaluated to boolean, then negated)" } }, required: ["$not"], additionalProperties: !1 }, { description: "$and operation - logical AND (all operands must be truthy)", properties: { $and: { type: "array", description: "Array of expressions to evaluate (all must be truthy)", items: { $ref: "#" }, minItems: 1 } }, required: ["$and"], additionalProperties: !1 }, { description: "$or operation - logical OR (at least one operand must be truthy)", properties: { $or: { type: "array", description: "Array of expressions to evaluate (at least one must be truthy)", items: { $ref: "#" }, minItems: 1 } }, required: ["$or"], additionalProperties: !1 }, { description: "$trim operation - trim whitespace from string", properties: { $trim: { $ref: "#", description: "Expression to trim (evaluated to string, then trimmed of leading/trailing whitespace)" } }, required: ["$trim"], additionalProperties: !1 }, { description: "$gt operation - greater than comparison", properties: { $gt: { type: "array", description: "Array of two expressions to compare (left > right)", items: { $ref: "#" }, minItems: 2, maxItems: 2 } }, required: ["$gt"], additionalProperties: !1 }, { description: "$length operation - get array or string length", properties: { $length: { $ref: "#", description: "Expression to get length of (evaluated to array or string)" } }, required: ["$length"], additionalProperties: !1 }, { description: "$concat operation - concatenate arrays", properties: { $concat: { type: "array", description: "Array of expressions, arrays, or objects to concatenate (all evaluated to arrays, then flattened)", items: { anyOf: [{ $ref: "#" }, { type: ["array", "object", "string", "number", "boolean", "null"] }] }, minItems: 1 } }, required: ["$concat"], additionalProperties: !1 }, { description: "$map operation - map over array", properties: { $map: { type: "object", description: "Map configuration object", properties: { array: { $ref: "#", description: "Expression evaluating to array to map over" }, as: { type: "string", description: "Variable name for each item in the array (default: 'item')" }, return: { description: "Expression, object, or array to evaluate for each item (result becomes item in returned array). 'do' is also supported as an alias.", anyOf: [{ $ref: "#" }, { type: ["object", "array", "string", "number", "boolean", "null"] }] }, do: { description: "Alias for 'return' - expression, object, or array to evaluate for each item", anyOf: [{ $ref: "#" }, { type: ["object", "array", "string", "number", "boolean", "null"] }] } }, required: ["array"], additionalProperties: !1 } }, required: ["$map"], additionalProperties: !1 }, { description: "$if operation - conditional expression", properties: { $if: { type: "object", description: "Conditional expression object", properties: { condition: { $ref: "#", description: "Condition expression (evaluated to boolean)" }, then: { $ref: "#", description: "Expression to evaluate if condition is true" }, else: { $ref: "#", description: "Expression to evaluate if condition is false" } }, required: ["condition", "then", "else"], additionalProperties: !1 } }, required: ["$if"], additionalProperties: !1 }] } }, el = {
  $schema: VE,
  $id: WE,
  title: zE,
  cotype: $E,
  indexing: ZE,
  description: _E,
  anyOf: XE,
  $defs: Al
}, tl = "@schema/meta", il = "@schema/subscribers", ol = "@schema/subscribers", gl = "A colist of actor co-ids subscribed to a topic", rl = "colist", nl = !0, sl = { $co: "@schema/actor", description: "Each item is a co-id reference to an actor subscribed to this topic" }, al = {
  $schema: tl,
  $id: il,
  title: ol,
  description: gl,
  cotype: rl,
  indexing: nl,
  items: sl
}, Il = "@schema/meta", Cl = "@schema/inbox", cl = "@schema/inbox", Bl = "A costream (append-only stream) of messages received by this actor", Ql = "costream", El = !0, ll = { $co: "@schema/message", description: "Each item is a co-id reference to a message" }, dl = {
  $schema: Il,
  $id: Cl,
  title: cl,
  description: Bl,
  cotype: Ql,
  indexing: El,
  items: ll
}, hl = "@schema/meta", ul = "@schema/children", fl = "@schema/children", wl = "A comap of child actors (namekey  actor co-id)", yl = "comap", pl = !0, Dl = {}, ml = { $co: "@schema/actor", description: "Each value is a co-id reference to a child actor" }, Sl = {
  $schema: hl,
  $id: ul,
  title: fl,
  description: wl,
  cotype: yl,
  indexing: pl,
  properties: Dl,
  additionalProperties: ml
}, Nl = "@schema/meta", Ml = "@schema/os/schematas-registry", Gl = "@schema/os/schematas-registry", kl = "Schema registry CoMap - maps schema namekeys (e.g., @schema/data/todos) to schema co-ids (co_z...). Stored in account.os.schematas", Fl = "comap", Rl = !1, bl = { "@schema/meta": { type: "string", description: "Metaschema co-id (co_z...)" } }, Kl = { type: "string", description: "Schema namekey  schema co-id mapping (e.g., @schema/data/todos  co_z123...)" }, Yl = {
  $schema: Nl,
  $id: Ml,
  title: Gl,
  description: kl,
  cotype: Fl,
  indexing: Rl,
  properties: bl,
  additionalProperties: Kl
}, vl = "@schema/data/todos", Ul = "@schema/meta", Jl = "@schema/data/todos", Hl = "comap", ql = !0, Ll = { text: { type: "string", minLength: 1, pattern: ".*\\S.*", description: "The todo item text content (must contain at least one non-whitespace character)" }, done: { type: "boolean", description: "Whether the todo item is completed" } }, xl = ["text", "done"], Tl = !1, Ol = {
  $id: vl,
  $schema: Ul,
  title: Jl,
  cotype: Hl,
  indexing: ql,
  properties: Ll,
  required: xl,
  additionalProperties: Tl
}, Pl = "@schema/data/chat", jl = "@schema/meta", Vl = "@schema/data/chat", Wl = "comap", zl = !0, $l = { role: { type: "string", enum: ["user", "assistant", "system"], description: "The role of the message sender" }, content: { type: "string", minLength: 1, description: "The message content" } }, Zl = ["role", "content"], _l = !1, Xl = {
  $id: Pl,
  $schema: jl,
  title: Vl,
  cotype: Wl,
  indexing: zl,
  properties: $l,
  required: Zl,
  additionalProperties: _l
}, Ad = "@schema/meta", ed = "@schema/message/CREATE_BUTTON", td = "@schema/message/CREATE_BUTTON", id = "Message type for creating a new todo item", od = "comap", gd = !0, rd = "object", nd = { text: { type: "string", minLength: 1, pattern: "^\\S", description: "Todo text (required, non-empty, must contain at least one non-whitespace character)" } }, sd = ["text"], ad = !1, Id = {
  $schema: Ad,
  $id: ed,
  title: td,
  description: id,
  cotype: od,
  indexing: gd,
  type: rd,
  properties: nd,
  required: sd,
  additionalProperties: ad
}, Cd = "@schema/meta", cd = "@schema/message/TOGGLE_BUTTON", Bd = "@schema/message/TOGGLE_BUTTON", Qd = "Message type for toggling a todo item's done status", Ed = "comap", ld = !0, dd = "object", hd = { id: { type: "string", pattern: "^co_z", description: "Todo item co-id (required)" }, done: { type: "boolean", description: "Current done status (optional, will be toggled)" } }, ud = ["id"], fd = !1, wd = {
  $schema: Cd,
  $id: cd,
  title: Bd,
  description: Qd,
  cotype: Ed,
  indexing: ld,
  type: dd,
  properties: hd,
  required: ud,
  additionalProperties: fd
}, yd = "@schema/meta", pd = "@schema/message/DELETE_BUTTON", Dd = "@schema/message/DELETE_BUTTON", md = "Message type for deleting a todo item", Sd = "comap", Nd = !0, Md = "object", Gd = { id: { type: "string", pattern: "^co_z", description: "Todo item co-id (required)" } }, kd = ["id"], Fd = !1, Rd = {
  $schema: yd,
  $id: pd,
  title: Dd,
  description: md,
  cotype: Sd,
  indexing: Nd,
  type: Md,
  properties: Gd,
  required: kd,
  additionalProperties: Fd
}, bd = "@schema/meta", Kd = "@schema/message/UPDATE_INPUT", Yd = "@schema/message/UPDATE_INPUT", vd = "Message type for updating input field value", Ud = "comap", Jd = !0, Hd = "object", qd = { newTodoText: { type: "string", description: "New input text value" } }, Ld = !1, xd = {
  $schema: bd,
  $id: Kd,
  title: Yd,
  description: vd,
  cotype: Ud,
  indexing: Jd,
  type: Hd,
  properties: qd,
  additionalProperties: Ld
}, Td = "@schema/meta", Od = "@schema/message/SWITCH_VIEW", Pd = "@schema/message/SWITCH_VIEW", jd = "Message type for switching view mode", Vd = "comap", Wd = !0, zd = "object", $d = { viewMode: { type: "string", enum: ["list", "logs"], description: "View mode to switch to (required)" } }, Zd = ["viewMode"], _d = !1, Xd = {
  $schema: Td,
  $id: Od,
  title: Pd,
  description: jd,
  cotype: Vd,
  indexing: Wd,
  type: zd,
  properties: $d,
  required: Zd,
  additionalProperties: _d
}, Ah = "@schema/meta", eh = "@schema/message/SUCCESS", th = "@schema/message/SUCCESS", ih = "Message type for successful operation completion", oh = "comap", gh = !0, rh = "object", nh = { result: { description: "Tool execution result (optional, can be any type - object, boolean, string, etc.)" }, text: { type: "string", description: "Original event payload property (optional, for CREATE_BUTTON)" }, id: { type: "string", pattern: "^co_z", description: "Original event payload property (optional, for TOGGLE_BUTTON, DELETE_BUTTON)" }, done: { type: "boolean", description: "Original event payload property (optional, for TOGGLE_BUTTON)" }, viewMode: { type: "string", enum: ["list", "logs"], description: "Original event payload property (optional, for SWITCH_VIEW)" }, newTodoText: { type: "string", description: "Original event payload property (optional, for UPDATE_INPUT)" } }, sh = !0, ah = {
  $schema: Ah,
  $id: eh,
  title: th,
  description: ih,
  cotype: oh,
  indexing: gh,
  type: rh,
  properties: nh,
  additionalProperties: sh
}, Ih = "@schema/meta", Ch = "@schema/message/ERROR", ch = "@schema/message/ERROR", Bh = "Message type for operation errors", Qh = "comap", Eh = !0, lh = "object", dh = { error: { type: "string", description: "Error message (optional)" } }, hh = !1, uh = {
  $schema: Ih,
  $id: Ch,
  title: ch,
  description: Bh,
  cotype: Qh,
  indexing: Eh,
  type: lh,
  properties: dh,
  additionalProperties: hh
}, fh = "@schema/meta", wh = "@schema/message/SEND_MESSAGE", yh = "@schema/message/SEND_MESSAGE", ph = "Message type for sending a chat message", Dh = "comap", mh = !0, Sh = "object", Nh = { inputText: { type: "string", minLength: 1, description: "Message text (required, non-empty)" } }, Mh = ["inputText"], Gh = !1, kh = {
  $schema: fh,
  $id: wh,
  title: yh,
  description: ph,
  cotype: Dh,
  indexing: mh,
  type: Sh,
  properties: Nh,
  required: Mh,
  additionalProperties: Gh
}, Fh = "@schema/meta", Rh = "@schema/message/RETRY", bh = "@schema/message/RETRY", Kh = "Message type for retrying a failed operation", Yh = "comap", vh = !0, Uh = "object", Jh = {}, Hh = !1, qh = {
  $schema: Fh,
  $id: Rh,
  title: bh,
  description: Kh,
  cotype: Yh,
  indexing: vh,
  type: Uh,
  properties: Jh,
  additionalProperties: Hh
}, Lh = "@schema/meta", xh = "@schema/message/DISMISS", Th = "@schema/message/DISMISS", Oh = "Message type for dismissing an error or notification", Ph = "comap", jh = !0, Vh = "object", Wh = {}, zh = !1, $h = {
  $schema: Lh,
  $id: xh,
  title: Th,
  description: Oh,
  cotype: Ph,
  indexing: jh,
  type: Vh,
  properties: Wh,
  additionalProperties: zh
}, Zh = "@schema/meta", _h = "@schema/message/SELECT_NAV", Xh = "@schema/message/SELECT_NAV", Au = "Message type for selecting a navigation item", eu = "comap", tu = !0, iu = "object", ou = { navId: { type: "string", description: "Navigation item ID (required)" } }, gu = ["navId"], ru = !1, nu = {
  $schema: Zh,
  $id: _h,
  title: Xh,
  description: Au,
  cotype: eu,
  indexing: tu,
  type: iu,
  properties: ou,
  required: gu,
  additionalProperties: ru
}, su = "@schema/meta", au = "@schema/message/SELECT_ROW", Iu = "@schema/message/SELECT_ROW", Cu = "Message type for selecting a table row", cu = "comap", Bu = !0, Qu = "object", Eu = { rowId: { type: "string", description: "Row ID (required)" } }, lu = ["rowId"], du = !1, hu = {
  $schema: su,
  $id: au,
  title: Iu,
  description: Cu,
  cotype: cu,
  indexing: Bu,
  type: Qu,
  properties: Eu,
  required: lu,
  additionalProperties: du
};
function ng() {
  return Me.getMetaSchema();
}
const la = {
  actor: WB,
  context: tQ,
  state: CQ,
  view: wQ,
  style: Lt,
  brand: Lt,
  "brand.style": Lt,
  "actor.style": Lt,
  tool: UQ,
  vibe: jQ,
  message: eE,
  // Extracted $defs as separate schemas (expression is inline type definition, not a CoValue)
  guard: CE,
  action: uE,
  transition: ME,
  messagePayload: UE,
  messageType: jE,
  // MaiaScript expression schema (for validating DSL expressions)
  "maia-script-expression": el,
  // CoValue schemas (separate CoValues referenced via $co)
  subscribers: al,
  inbox: dl,
  children: Sl,
  // OS infrastructure schemas
  "os/schematas-registry": Yl
}, da = {
  "data/todos": Ol,
  "data/chat": Xl
}, sg = {
  "message/CREATE_BUTTON": Id,
  "message/TOGGLE_BUTTON": wd,
  "message/DELETE_BUTTON": Rd,
  "message/UPDATE_INPUT": xd,
  "message/SWITCH_VIEW": Xd,
  "message/SUCCESS": ah,
  "message/ERROR": uh,
  "message/SEND_MESSAGE": kh,
  "message/RETRY": qh,
  "message/DISMISS": $h,
  "message/SELECT_NAV": nu,
  "message/SELECT_ROW": hu
};
function uu(i) {
  if (i.startsWith("message/"))
    return sg[i] || null;
  if (i.startsWith("@schema/message/")) {
    const A = i.replace("@schema/message/", "");
    return sg[`message/${A}`] || null;
  }
  return la[i] || da[i] || null;
}
function ag() {
  const i = {};
  for (const [A, e] of Object.entries(sg))
    i[`@schema/${A}`] = e;
  return { ...la, ...da, ...i };
}
const ha = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CoIdRegistry: Ea,
  ValidationEngine: Me,
  coTypesDefs: Ft,
  getAllSchemas: ag,
  getMetaSchema: ng,
  getSchema: uu,
  getValidationEngine: ro,
  resolve: oA,
  setSchemaResolver: ua,
  transformForSeeding: ca,
  validateAgainstSchema: bt,
  validateAgainstSchemaOrThrow: Fe,
  validateSchemaStructure: $i
}, Symbol.toStringTag, { value: "Module" }));
function me(i) {
  return i.map((A) => ({
    instancePath: A.instancePath || "/",
    schemaPath: A.schemaPath || "",
    keyword: A.keyword || "",
    message: A.message || "",
    params: A.params || {}
  }));
}
async function _A(i, A) {
  const e = i.opts.validateSchema;
  i.opts.validateSchema = !1;
  try {
    return await A();
  } finally {
    i.opts.validateSchema = e;
  }
}
let OA = null, Ig = null;
function ua(i) {
  if (!i || typeof i != "object")
    throw new Error("[setSchemaResolver] Options object required: { dbEngine }");
  const { dbEngine: A } = i;
  if (!A)
    throw new Error("[setSchemaResolver] dbEngine is REQUIRED. No fallbacks allowed.");
  const e = async (t) => {
    try {
      if (!A.backend)
        throw new Error("[SchemaResolver] dbEngine.backend is required");
      const { resolve: o } = await Promise.resolve().then(() => so), g = await o(A.backend, t, { returnType: "schema" });
      if (!g)
        throw new Error(`[SchemaResolver] Schema ${t} not found`);
      return g;
    } catch (o) {
      throw new Error(`[SchemaResolver] Failed to load schema ${t}: ${o.message}`);
    }
  };
  Ig = e, OA && OA.setSchemaResolver(e);
}
async function ro(i = null) {
  let A = null;
  i && typeof i == "object" && (A = i.registrySchemas || null);
  let e = null;
  return Ig && (e = Ig), OA ? A && !OA.registrySchemas && (OA = new Me({ registrySchemas: A })) : OA = new Me({ registrySchemas: A }), e && !OA.schemaResolver && OA.setSchemaResolver(e), await OA.initialize(), OA;
}
async function bt(i, A, e = "", t = !1) {
  const o = await ro();
  await o.initialize();
  try {
    await o._resolveAndRegisterSchemaDependencies(i);
    let g;
    if (i.$id) {
      const a = o.ajv.getSchema(i.$id);
      a ? g = a : g = o.ajv.compile(i);
    } else
      g = o.ajv.compile(i);
    if (g(A))
      return { valid: !0, errors: null };
    const n = g.errors || [], s = me(n);
    if (t) {
      const a = e ? ` for '${e}'` : "", I = s.map((C) => `  - ${C.instancePath}: ${C.message}`).join(`
`);
      throw new Error(
        `Validation failed${a}:
${I}`
      );
    }
    return {
      valid: !1,
      errors: s
    };
  } catch (g) {
    if (g.message && g.message.includes("already exists") && i.$id) {
      const r = o.ajv.getSchema(i.$id);
      if (r) {
        if (r(A))
          return { valid: !0, errors: null };
        const s = r.errors || [], a = me(s);
        if (t) {
          const I = e ? ` for '${e}'` : "", C = a.map((c) => `  - ${c.instancePath}: ${c.message}`).join(`
`);
          throw new Error(
            `Validation failed${I}:
${C}`
          );
        }
        return {
          valid: !1,
          errors: a
        };
      }
    }
    throw new Error(`[Validation] Failed to compile schema for ${e}: ${g.message}`);
  }
}
async function Fe(i, A, e = "") {
  return await bt(i, A, e, !0);
}
function fa(i, A) {
  if (!Array.isArray(A))
    throw new Error("[validateItems] Items must be an array");
  if (i.items && i.items.$co) {
    for (const e of A)
      if (typeof e != "string" || !e.startsWith("co_z"))
        throw new Error(`[validateItems] Items must be co-ids when schema.items.$co is specified, got: ${e}`);
  }
}
function ae(i, A) {
  if (!i)
    throw new Error(`[${A}] coId required`);
  if (!i.startsWith("co_z"))
    throw new Error(`[${A}] coId must be a valid co-id (co_z...), got: ${i}`);
}
function VA(i, A, e) {
  if (i == null)
    throw new Error(`[${e}] ${A} required`);
}
function Kt(i, A, e = "") {
  if (!i) {
    const t = e ? ` (${e})` : "";
    throw new Error(`[${A}] dbEngine required${t}`);
  }
}
async function Re(i, A, e, t, o = {}) {
  const { dbEngine: g, registrySchemas: r, getAllSchemas: n } = o, { resolve: s } = await Promise.resolve().then(() => so);
  if (A.startsWith("co_z")) {
    if (!g)
      throw new Error(`[${t}] dbEngine is REQUIRED for co-id schema validation. Schema: ${A}. Pass dbEngine in options.`);
    const a = await s(i, A, { returnType: "schema" });
    if (!a)
      throw new Error(`[${t}] Schema not found in database: ${A}`);
    return await Fe(a, e, `${t} for schema ${A}`), a;
  } else {
    if (!n || typeof n != "function")
      throw new Error(`[${t}] getAllSchemas function is REQUIRED for name-based schema validation. Schema: ${A}. This is only for migrations/seeding.`);
    const a = n(), C = await (await ro({
      registrySchemas: r || a
    })).validateData(A, e);
    if (!C.valid) {
      const Q = C.errors.map((d) => `  - ${d.instancePath}: ${d.message}`).join(`
`);
      throw new Error(`[${t}] Data validation failed for schema '${A}':
${Q}`);
    }
    return (r || a)[A];
  }
}
async function wa(i, A, e) {
  const t = i.getCoValue(A);
  if (!t)
    throw new Error(`[${e}] CoValue not found: ${A}`);
  if (!t.isAvailable()) {
    await i.node.loadCoValueCore(A);
    let o = 0;
    for (; !t.isAvailable() && o < 10; )
      await new Promise((g) => setTimeout(g, 100)), o++;
    if (!t.isAvailable())
      throw new Error(`[${e}] CoValue ${A} is not available (may still be loading)`);
  }
  return t;
}
const fu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ensureCoValueAvailable: wa,
  formatValidationErrors: me,
  getValidationEngine: ro,
  loadSchemaAndValidate: Re,
  requireDbEngine: Kt,
  requireParam: VA,
  setSchemaResolver: ua,
  validateAgainstSchema: bt,
  validateAgainstSchemaOrThrow: Fe,
  validateCoId: ae,
  validateItems: fa,
  withSchemaValidationDisabled: _A
}, Symbol.toStringTag, { value: "Module" }));
async function ya(i, A = {}, e, t = null, o = null) {
  let g = i;
  if (i && typeof i.createMap == "function")
    g = i;
  else if (i && typeof i.get == "function") {
    const s = i.get("profile");
    if (s) {
      if (!t)
        throw new Error("[createCoMap] Node parameter required when passing account");
      let a = t.getCoValue(s);
      if (a || (console.log(`[createCoMap] Loading profile ${s.substring(0, 12)}...`), a = await t.loadCoValueCore(s)), (!a || !a.isAvailable()) && (console.log(`[createCoMap] Waiting for profile ${s.substring(0, 12)}... to be available...`), await new Promise((h, l) => {
        let B = null;
        const u = setTimeout(() => {
          B && B(), l(new Error(`Timeout waiting for profile ${s} to be available. The profile may not exist or may not be synced yet.`));
        }, 1e4);
        if (!a) {
          clearTimeout(u), l(new Error(`Profile core not found: ${s}. Ensure the account has a valid profile.`));
          return;
        }
        B = a.subscribe((y) => {
          y && y.isAvailable() && (clearTimeout(u), B && B(), h());
        }), t.loadCoValueCore(s).catch((y) => {
          clearTimeout(u), B && B(), l(y);
        });
      }), a = t.getCoValue(s)), !a || a.type !== "comap")
        throw new Error(`[createCoMap] Profile not available or invalid type: ${s}. Expected comap, got ${a?.type || "null"}. Ensure the account has a valid profile.`);
      const I = a.getCurrentContent?.();
      if (!I || typeof I.get != "function")
        throw new Error(`[createCoMap] Profile content not available: ${s}`);
      const C = I.get("group");
      if (!C)
        throw new Error("[createCoMap] Universal group not found in profile.group. Ensure identity migration has run.");
      let c = t.getCoValue(C);
      if (c || (console.log(`[createCoMap] Loading universal group ${C.substring(0, 12)}...`), c = await t.loadCoValueCore(C)), c.isAvailable() || (console.log(`[createCoMap] Waiting for universal group ${C.substring(0, 12)}... to be available...`), await new Promise((h, l) => {
        let B = null;
        const u = setTimeout(() => {
          B && B(), l(new Error(`Timeout waiting for universal group ${C} to be available`));
        }, 1e4);
        B = c.subscribe((y) => {
          y.isAvailable() && (clearTimeout(u), B && B(), h());
        }), t.loadCoValueCore(C).catch((y) => {
          clearTimeout(u), B && B(), l(y);
        });
      }), c = t.getCoValue(C)), !c)
        throw new Error(`[createCoMap] Universal group core not found: ${C}`);
      const Q = c.verified?.header, d = c.ruleset || Q?.ruleset;
      if (!d || d.type !== "group")
        throw new Error(`[createCoMap] Universal group is not a group type (ruleset.type !== 'group'): ${C}`);
      const f = c.getCurrentContent?.();
      if (!f || typeof f.createMap != "function")
        throw new Error(`[createCoMap] Universal group content not available: ${C}`);
      g = f, console.log(`[createCoMap] Using universal group via account.profile.group: ${C}`);
    }
  }
  if (!e || typeof e != "string")
    throw new Error('[createCoMap] Schema name is REQUIRED. Provide a valid schema name (e.g., "ProfileSchema", "@meta-schema")');
  if (e === "GenesisSchema") {
    const s = { $schema: "GenesisSchema" }, a = g.createMap(A, s);
    return console.log(" CoMap created (GenesisSchema):", a.id), console.log("   Schema:", e), console.log("   HeaderMeta:", a.headerMeta), a;
  }
  if (!se(e) && !e.startsWith("co_z") && !Rt(e))
    throw new Error(`[createCoMap] Schema '${e}' not found in registry. Available schemas: AccountSchema, GroupSchema, ProfileSchema`);
  se(e) || await Re(
    o?.backend || null,
    e,
    A,
    "createCoMap",
    { dbEngine: o, getAllSchemas: go }
  );
  const r = Xe(e);
  return g.createMap(A, r);
}
async function pa(i, A = [], e, t = null, o = null) {
  let g = i;
  if (i && typeof i.get == "function") {
    const s = i.get("profile");
    if (s) {
      if (!t)
        throw new Error("[createCoList] Node parameter required when passing account");
      const a = t.getCoValue(s);
      if (!a || a.type !== "comap")
        throw new Error(`[createCoList] Profile not available: ${s}`);
      const I = a.getCurrentContent?.();
      if (!I || typeof I.get != "function")
        throw new Error(`[createCoList] Profile content not available: ${s}`);
      const C = I.get("group");
      if (!C)
        throw new Error("[createCoList] Universal group not found in profile.group. Ensure identity migration has run.");
      const c = t.getCoValue(C);
      if (!c)
        throw new Error(`[createCoList] Universal group core not found: ${C}`);
      const Q = c.verified?.header, d = c.ruleset || Q?.ruleset;
      if (!d || d.type !== "group")
        throw new Error(`[createCoList] Universal group is not a group type (ruleset.type !== 'group'): ${C}`);
      const f = c.getCurrentContent?.();
      if (!f || typeof f.createList != "function")
        throw new Error(`[createCoList] Universal group content not available: ${C}`);
      g = f, console.log(`[createCoList] Using universal group via account.profile.group: ${C}`);
    }
  }
  if (!e || typeof e != "string")
    throw new Error('[createCoList] Schema name is REQUIRED. Provide a valid schema name (e.g., "NotesSchema") or co-id (e.g., "co_z123...")');
  if (!se(e) && !e.startsWith("co_z") && !Rt(e))
    throw new Error(`[createCoList] Schema '${e}' not found in registry. Available schemas: AccountSchema, GroupSchema, ProfileSchema`);
  se(e) || await Re(
    o?.backend || null,
    e,
    A,
    "createCoList",
    { dbEngine: o, getAllSchemas: go }
  );
  const r = Xe(e), n = g.createList(A, r);
  return console.log(" CoList created:", n.id), console.log("   Schema:", e), console.log("   HeaderMeta:", n.headerMeta), console.log("   Initial items:", A.length), n;
}
function Da(i, A, e = null) {
  let t = i;
  if (i && typeof i.get == "function") {
    const r = i.get("profile");
    if (r) {
      if (!e)
        throw new Error("[createCoStream] Node parameter required when passing account");
      const n = e.getCoValue(r);
      if (!n || n.type !== "comap")
        throw new Error(`[createCoStream] Profile not available: ${r}`);
      const s = n.getCurrentContent?.();
      if (!s || typeof s.get != "function")
        throw new Error(`[createCoStream] Profile content not available: ${r}`);
      const a = s.get("group");
      if (!a)
        throw new Error("[createCoStream] Universal group not found in profile.group. Ensure identity migration has run.");
      const I = e.getCoValue(a);
      if (!I)
        throw new Error(`[createCoStream] Universal group core not found: ${a}`);
      const C = I.verified?.header, c = I.ruleset || C?.ruleset;
      if (!c || c.type !== "group")
        throw new Error(`[createCoStream] Universal group is not a group type (ruleset.type !== 'group'): ${a}`);
      const Q = I.getCurrentContent?.();
      if (!Q || typeof Q.createStream != "function")
        throw new Error(`[createCoStream] Universal group content not available: ${a}`);
      t = Q, console.log(`[createCoStream] Using universal group via account.profile.group: ${a}`);
    }
  }
  if (!A || typeof A != "string")
    throw new Error('[createCoStream] Schema name is REQUIRED. Provide a valid schema name (e.g., schema co-id or "@meta-schema")');
  if (!Rt(A))
    throw new Error(`[createCoStream] Schema '${A}' not found in registry. Available schemas: AccountSchema, GroupSchema, ProfileSchema`);
  const o = Xe(A), g = t.createStream(o);
  return console.log(" CoStream created:", g.id), console.log("   Schema:", A), console.log("   HeaderMeta:", g.headerMeta), g;
}
async function wu(i, A, e) {
  try {
    const t = await IA(i, A, { waitForAvailable: !0 });
    if (t && i.isAvailable(t)) {
      const o = i.getCurrentContent(t);
      if (o && o.get) {
        const g = o.get("definition");
        if (g && g.cotype) {
          if (g.cotype === "cotext" || g.cotype === "coplaintext")
            throw new Error(`[CoJSONBackend] CoText (cotext) support has been eliminated. Schema ${A} specifies cotext, which is no longer supported.`);
          return g.cotype;
        }
      }
    }
  } catch (t) {
    console.warn(`[CoJSONBackend] Failed to load schema ${A} for cotype:`, t);
  }
  if (Array.isArray(e))
    return "colist";
  if (typeof e == "string")
    throw new Error(`[CoJSONBackend] Cannot determine cotype from data type for schema ${A}. String data type is not supported (CoText/cotext support has been eliminated). Use CoMap or CoList instead.`);
  if (typeof e == "object" && e !== null)
    return "comap";
  throw new Error(`[CoJSONBackend] Cannot determine cotype from data type for schema ${A}`);
}
async function xg(i, A, e) {
  const t = await wu(i, A, e);
  if (!i.account)
    throw new Error("[CoJSONBackend] Account required for create");
  const o = await i.getDefaultGroup();
  let g;
  switch (t) {
    case "comap":
      if (!e || typeof e != "object" || Array.isArray(e))
        throw new Error("[CoJSONBackend] Data must be object for comap");
      g = await ya(o, e, A, i.node, i.dbEngine);
      break;
    case "colist":
      if (!Array.isArray(e))
        throw new Error("[CoJSONBackend] Data must be array for colist");
      g = await pa(o, e, A, i.node, i.dbEngine);
      break;
    case "costream":
      g = Da(o, A, i.node);
      break;
    default:
      throw new Error(`[CoJSONBackend] Unsupported cotype: ${t}`);
  }
  const r = i.node.getCoValue(g.id);
  if (r && i.isAvailable(r)) {
    const n = i.getCurrentContent(r);
    if (n && typeof n.get == "function") {
      const a = { id: g.id, ...e }, I = n.keys && typeof n.keys == "function" ? n.keys() : Object.keys(n);
      for (const C of I)
        a[C] = n.get(C);
      return a;
    }
    const s = Jg(i, r);
    return { ...e, id: g.id, ...s };
  }
  return {
    id: g.id,
    ...e,
    // Include original data to ensure text and other properties are available
    type: t,
    schema: A
  };
}
const ma = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  create: xg
}, Symbol.toStringTag, { value: "Module" }));
async function Tg(i) {
  if (!i.account)
    throw new Error("[SchemaIndexManager] Account required");
  let A = i.account.get("os");
  if (A)
    try {
      const g = await cA(i, A, null, null, null, {
        deepResolve: !1,
        // Don't need deep resolution for infrastructure
        timeoutMs: 1e4
        // 10 second timeout for critical infrastructure
      });
      if (!g || g.value?.error)
        return console.warn(`[SchemaIndexManager] account.os CoValue not found or error: ${A.substring(0, 12)}...`), null;
      const r = i.getCoValue(A);
      if (!r || !r.isAvailable())
        return console.warn(`[SchemaIndexManager] account.os (${A.substring(0, 12)}...) is not available after read()`), null;
      const n = r.getCurrentContent?.();
      if (!n)
        return console.warn(`[SchemaIndexManager] account.os (${A.substring(0, 12)}...) is available but getCurrentContent() returned nothing`), null;
      const s = n.cotype || n.type, C = (i.getHeader(r)?.meta || null)?.$schema || null;
      return s === "comap" && typeof n.get == "function" ? n : (console.warn(`[SchemaIndexManager] account.os (${A.substring(0, 12)}...) is not a CoMap (cotype: ${s}, schema: ${C}, has get: ${typeof n.get})`), null);
    } catch (g) {
      return console.warn(`[SchemaIndexManager] Failed to load account.os (${A.substring(0, 12)}...):`, g.message), null;
    }
  const e = await i.getDefaultGroup(), t = { $schema: GA.META_SCHEMA }, o = e.createMap({}, t);
  return i.account.set("os", o.id), o;
}
async function no(i) {
  const A = await Tg(i);
  if (!A)
    return null;
  const e = A.get("indexes");
  if (e)
    try {
      const r = await cA(i, e, null, null, null, {
        deepResolve: !1,
        timeoutMs: 1e4
      });
      if (!r || r.value?.error)
        return console.warn(`[SchemaIndexManager] account.os.indexes CoValue not found or error: ${e.substring(0, 12)}...`), null;
      const n = i.getCoValue(e);
      if (!n || !n.isAvailable())
        return console.warn(`[SchemaIndexManager] account.os.indexes (${e.substring(0, 12)}...) is not available after read()`), null;
      const s = n.getCurrentContent?.();
      if (!s)
        return console.warn(`[SchemaIndexManager] account.os.indexes (${e.substring(0, 12)}...) is available but getCurrentContent() returned nothing`), null;
      const a = s.cotype || s.type, c = (i.getHeader(n)?.meta || null)?.$schema || null;
      return a === "comap" && typeof s.get == "function" ? s : (console.warn(`[SchemaIndexManager] account.os.indexes (${e.substring(0, 12)}...) is not a CoMap (cotype: ${a}, schema: ${c}, has get: ${typeof s.get})`), null);
    } catch (r) {
      return console.warn(`[SchemaIndexManager] Failed to load account.os.indexes (${e.substring(0, 12)}...):`, r.message), null;
    }
  const t = await i.getDefaultGroup();
  let o = await oA(i, "@schema/os/indexes-registry", { returnType: "coId" }), g;
  if (o && typeof o == "string" && o.startsWith("co_z") && i.dbEngine) {
    const { create: r } = await Promise.resolve().then(() => ma);
    g = (await r(i, o, {})).id;
  } else {
    const r = { $schema: GA.META_SCHEMA };
    g = t.createMap({}, r).id;
  }
  A.set("indexes", g);
  try {
    const r = await cA(i, g, null, null, null, {
      deepResolve: !1,
      timeoutMs: 5e3
    });
    if (r && !r.value?.error) {
      const n = i.getCoValue(g);
      if (n && i.isAvailable(n)) {
        const s = n.getCurrentContent?.();
        if (s && typeof s.get == "function")
          return s;
      }
    }
  } catch (r) {
    console.warn("[SchemaIndexManager] Failed to load newly created account.os.indexes:", r.message);
  }
  return null;
}
async function yu(i, A, e = null) {
  if (!A || !A.startsWith("co_z"))
    throw new Error(`[SchemaIndexManager] Invalid schema co-id: ${A}`);
  if (!e) {
    const a = i.getCoValue(A);
    a && (e = i.getHeader(a)?.meta?.$schema, e && !e.startsWith("co_z") && (e = await oA(i, e, { returnType: "coId" }))), (!e || !e.startsWith("co_z")) && (e = await Sa(i));
  }
  if (!e || !e.startsWith("co_z"))
    return console.warn("[SchemaIndexManager] Cannot create schema-specific index colist schema - metaSchema not available"), null;
  const t = await oA(i, A, { returnType: "schema" });
  if (!t)
    return console.warn(`[SchemaIndexManager] Cannot load schema definition for ${A.substring(0, 12)}...`), null;
  const o = t.title || t.$id;
  if (!o || typeof o != "string" || !o.startsWith("@schema/"))
    return console.warn(`[SchemaIndexManager] Schema ${A.substring(0, 12)}... has invalid title: ${o}`), null;
  const r = `@schema/index/${o.replace("@schema/", "")}`, n = await oA(i, r, { returnType: "coId" });
  if (n && n.startsWith("co_z"))
    return n;
  const s = {
    title: r,
    description: `Schema-specific index colist for ${o} - only allows instances of this schema`,
    cotype: "colist",
    indexing: !1,
    // Index colist schemas themselves should not be indexed
    items: {
      $co: o
      // Enforces type safety - only co-ids referencing the target schema are allowed
    }
  };
  try {
    const I = (await xg(i, e, s)).id, C = await Na(i);
    return C && C.set(r, I), I;
  } catch (a) {
    return console.error(`[SchemaIndexManager] Failed to create schema-specific index colist schema for ${o}:`, a), null;
  }
}
async function Og(i, A, e = null) {
  if (!A || typeof A != "string" || !A.startsWith("co_z"))
    throw new Error(`[SchemaIndexManager] Invalid schema co-id: expected string starting with 'co_z', got ${typeof A}: ${A}`);
  const t = await oA(i, A, { returnType: "schema" });
  if (!t)
    return console.warn(`[SchemaIndexManager] Cannot load schema definition for ${A.substring(0, 12)}...`), null;
  if (t.indexing !== !0)
    return null;
  const o = await no(i);
  if (!o)
    return console.warn("[SchemaIndexManager] Cannot create index colist - account.os.indexes not available"), null;
  let g = o.get(A);
  if (g) {
    try {
      const C = await cA(i, g, null, null, null, {
        deepResolve: !1,
        // Don't need deep resolution for index colists
        timeoutMs: 5e3
      });
      if (C && !C.value?.error) {
        const c = i.getCoValue(g);
        if (c && c.isAvailable()) {
          const Q = c.getCurrentContent?.();
          if (Q && typeof Q.append == "function" && (Q.cotype || Q.type) === "colist")
            return Q;
        }
      }
    } catch (C) {
      console.warn(`[SchemaIndexManager] Failed to read index colist (${g.substring(0, 12)}...):`, C.message);
    }
    return console.warn(`[SchemaIndexManager] Index colist (${g.substring(0, 12)}...) exists but could not be loaded. Skipping to prevent overwriting.`), null;
  }
  const r = await yu(i, A, e);
  if (!r)
    return console.warn(`[SchemaIndexManager] Cannot create index colist - schema-specific index colist schema not available for ${A.substring(0, 12)}...`), null;
  const n = await i.getDefaultGroup(), s = { $schema: r }, a = n.createList([], s);
  g = a.id, o.set(A, g);
  const I = i.node.getCoValue(g);
  if (I && I.type === "colist") {
    const C = I.getCurrentContent?.();
    if (C && typeof C.append == "function")
      return C;
  }
  return a;
}
async function Pg(i) {
  const A = await Tg(i);
  if (!A)
    return console.warn("[SchemaIndexManager] Cannot create unknown colist - account.os not available"), null;
  const e = A.get("unknown");
  if (e) {
    const r = i.node.getCoValue(e);
    if (r && r.type === "colist") {
      const n = r.getCurrentContent?.();
      if (n && typeof n.append == "function")
        return n;
    }
  }
  const t = await i.getDefaultGroup(), o = { $schema: GA.META_SCHEMA }, g = t.createList([], o);
  return A.set("unknown", g.id), g;
}
async function pu(i, A) {
  if (!i.account || !A)
    return !1;
  const e = i.account.get("os");
  if (A === e)
    return !0;
  if (e) {
    const t = i.node.getCoValue(e);
    if (t && t.type === "comap") {
      const o = t.getCurrentContent?.();
      if (o && typeof o.get == "function") {
        const g = o.get("schematas");
        if (A === g)
          return !0;
        const r = o.get("unknown");
        if (A === r)
          return !0;
        const n = o.get("indexes");
        if (A === n)
          return !0;
        if (n) {
          const s = i.node.getCoValue(n);
          if (s && s.type === "comap") {
            const a = s.getCurrentContent?.();
            if (a && typeof a.get == "function") {
              const I = a.keys && typeof a.keys == "function" ? a.keys() : Object.keys(a);
              for (const C of I)
                if (a.get(C) === A)
                  return !0;
            }
          }
        }
      }
    }
  }
  return !1;
}
async function jg(i, A) {
  if (!A)
    return { shouldIndex: !1, schemaCoId: null };
  if (await pu(i, A.id))
    return { shouldIndex: !1, schemaCoId: null };
  const t = i.getHeader(A);
  if (!t || !t.meta)
    return { shouldIndex: !1, schemaCoId: null };
  const o = t.meta, g = o.$schema;
  if (GA.ACCOUNT === g || GA.GROUP === g || GA.META_SCHEMA === g)
    return { shouldIndex: !1, schemaCoId: null };
  if (o.type === "account" || g === GA.ACCOUNT)
    return { shouldIndex: !1, schemaCoId: null };
  const r = A.ruleset || t?.ruleset;
  if (r && r.type === "group")
    return { shouldIndex: !1, schemaCoId: null };
  if (g && typeof g == "string" && g.startsWith("co_z")) {
    try {
      const n = await oA(i, g, { returnType: "schema" });
      if (n && n.indexing !== !0)
        return { shouldIndex: !1, schemaCoId: g };
    } catch {
    }
    return { shouldIndex: !0, schemaCoId: g };
  }
  return g ? { shouldIndex: !1, schemaCoId: null } : { shouldIndex: !1, schemaCoId: null };
}
async function Sa(i) {
  if (!i.account)
    return null;
  const A = i.account.get("os");
  if (!A)
    return null;
  const e = i.node.getCoValue(A);
  if (!e || e.type !== "comap")
    return null;
  const t = e.getCurrentContent?.();
  if (!t || typeof t.get != "function")
    return null;
  const o = t.get("schematas");
  if (!o)
    return null;
  const g = i.node.getCoValue(o);
  if (!g || g.type !== "comap")
    return null;
  const r = g.getCurrentContent?.();
  if (!r || typeof r.get != "function")
    return null;
  const n = r.get("@schema/meta");
  return n && typeof n == "string" && n.startsWith("co_z") ? n : null;
}
async function Na(i) {
  const A = await Tg(i);
  if (!A)
    return console.warn("[SchemaIndexManager] Cannot create schematas registry - account.os not available"), null;
  const e = A.get("schematas");
  if (e) {
    try {
      const n = await cA(i, e, null, null, null, {
        deepResolve: !1,
        // Don't need deep resolution for registry
        timeoutMs: 5e3
      });
      if (n && !n.value?.error) {
        const s = i.getCoValue(e);
        if (s && s.isAvailable()) {
          const a = s.getCurrentContent?.();
          if (a && typeof a.set == "function" && (a.cotype || a.type) === "comap")
            return a;
        }
      }
    } catch (n) {
      console.warn(`[SchemaIndexManager] Failed to read schematas registry (${e.substring(0, 12)}...):`, n.message);
    }
    return console.warn(`[SchemaIndexManager] account.os.schematas (${e.substring(0, 12)}...) exists but could not be loaded. Skipping to prevent overwriting.`), null;
  }
  const t = await i.getDefaultGroup();
  let o = await oA(i, "@schema/os/schematas-registry", { returnType: "coId" });
  const g = o ? { $schema: o } : { $schema: GA.META_SCHEMA }, r = t.createMap({}, g);
  return A.set("schematas", r.id), r;
}
async function Ma(i, A) {
  if (!A || !A.id)
    return;
  const e = i.getCurrentContent(A);
  if (!e || typeof e.get != "function")
    return;
  const t = e.get("title");
  if (!t || typeof t != "string" || !t.startsWith("@schema/"))
    return;
  const o = await Na(i);
  if (!o)
    return;
  const g = o.get(t);
  if (g === A.id || g && g !== A.id || (o.set(t, A.id), e.get("indexing") !== !0))
    return;
  let a = i.getHeader(A)?.meta?.$schema;
  a && !a.startsWith("co_z") && (a = await oA(i, a, { returnType: "coId" })), await Og(i, A.id, a);
}
async function Ga(i, A) {
  if (!A)
    return !1;
  const e = i.getHeader(A);
  if (!e || !e.meta)
    return !1;
  const o = e.meta.$schema;
  if (!o)
    return !1;
  if (o === GA.META_SCHEMA) {
    const g = i.getCurrentContent(A);
    return !!(g && typeof g.get == "function" && g.get("title") === "@schema/meta");
  }
  if (o && typeof o == "string" && o.startsWith("co_z")) {
    try {
      const r = await cA(i, o, null, null, null, {
        deepResolve: !1,
        // Don't need deep resolution for schema detection
        timeoutMs: 5e3
        // 5 second timeout - metaschema should be available but may need more time during seeding
      });
      if (r && !r.value?.error) {
        const n = i.getCoValue(o);
        if (n && n.isAvailable()) {
          const s = i.getCurrentContent(n);
          if (s && typeof s.get == "function" && s.get("title") === "@schema/meta")
            return !0;
        }
      }
    } catch {
    }
    const g = await Sa(i);
    if (g && o === g)
      return !0;
  }
  return !1;
}
const Ro = /* @__PURE__ */ new Set();
async function ka(i, A) {
  let e = A, t = null;
  if (typeof A == "string") {
    if (t = A, e = i.getCoValue(t), !e || !i.isAvailable(e))
      return;
  } else
    t = A?.id;
  if (!(!e || !t) && !Ro.has(t)) {
    Ro.add(t);
    try {
      const { shouldIndex: o, schemaCoId: g } = await jg(i, e);
      if (o && g) {
        const r = await Og(i, g);
        if (!r)
          return;
        const a = i.getHeader(e)?.meta?.$schema;
        if (!a || a !== g)
          return;
        try {
          const I = r.toJSON ? r.toJSON() : [];
          if (Array.isArray(I) && I.includes(t))
            return;
        } catch {
        }
        try {
          r.append(t);
        } catch {
          return;
        }
      } else {
        const r = await Pg(i);
        if (!r)
          return;
        try {
          const n = r.toJSON ? r.toJSON() : [];
          if (Array.isArray(n) && n.includes(t))
            return;
        } catch {
        }
        r.append(t);
      }
    } finally {
      Ro.delete(t);
    }
  }
}
async function Du(i, A) {
  if (!A || !A.startsWith("co_z") || !i.account)
    return null;
  const e = await no(i);
  if (!e)
    return null;
  const t = e.get(A);
  if (!t || typeof t != "string" || !t.startsWith("co_"))
    return null;
  try {
    const o = await cA(i, t, null, null, null, {
      deepResolve: !1,
      // Don't need deep resolution for removal
      timeoutMs: 2e3
    });
    if (o && !o.value?.error) {
      const g = i.getCoValue(t);
      if (g && i.isAvailable(g)) {
        const r = i.getCurrentContent(g);
        if (r && typeof r.toJSON == "function" && typeof r.delete == "function" && (r.cotype || r.type) === "colist")
          return r;
      }
    }
  } catch {
  }
  return null;
}
async function Fa(i, A, e = null) {
  if (!(!A || !A.startsWith("co_z"))) {
    if (!e) {
      const t = i.getCoValue(A);
      if (t && i.isAvailable(t)) {
        const o = i.getHeader(t);
        o && o.meta && (e = o.meta.$schema);
      }
    }
    if (e && typeof e == "string" && e.startsWith("co_z")) {
      const t = await Du(i, e);
      if (t && typeof t.toJSON == "function" && typeof t.delete == "function") {
        const g = t.toJSON().indexOf(A);
        g !== -1 && t.delete(g);
      }
    } else {
      const t = await Pg(i);
      if (t && typeof t.toJSON == "function" && typeof t.delete == "function") {
        const g = t.toJSON().indexOf(A);
        g !== -1 && t.delete(g);
      }
    }
  }
}
const mu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ensureIndexesCoMap: no,
  ensureSchemaIndexColist: Og,
  ensureUnknownColist: Pg,
  indexCoValue: ka,
  isSchemaCoValue: Ga,
  registerSchemaCoValue: Ma,
  removeFromIndex: Fa,
  shouldIndexCoValue: jg
}, Symbol.toStringTag, { value: "Module" }));
async function Oi(i, A, e) {
  const t = await IA(i, e, { waitForAvailable: !0 });
  if (!t)
    throw new Error(`[CoJSONBackend] CoValue not found: ${e}`);
  if (!i.isAvailable(t))
    throw new Error(`[CoJSONBackend] CoValue not available: ${e}`);
  const o = i.getCurrentContent(t), g = o?.cotype || o?.type, s = (i.getHeader(t)?.meta || null)?.$schema || A;
  await Fa(i, e, s);
  let a = !1;
  if (g === "comap" && o.set) {
    if (o.keys && typeof o.keys == "function") {
      const I = Array.from(o.keys());
      for (const C of I)
        typeof o.delete == "function" && o.delete(C);
    } else if (typeof o.delete == "function") {
      const I = Object.keys(o);
      for (const C of I)
        o.delete(C);
    }
    a = !0;
  } else if (g === "colist" && o.delete) {
    if (typeof o.toJSON == "function") {
      const I = o.toJSON();
      for (let C = I.length - 1; C >= 0; C--)
        typeof o.delete == "function" && o.delete(C);
    }
    a = !0;
  } else if (g === "costream")
    a = !0;
  else if (g === "coplaintext" && o.delete) {
    if (typeof o.toString == "function") {
      const I = o.toString();
      for (let C = I.length - 1; C >= 0; C--)
        typeof o.delete == "function" && o.delete(C, 1);
    }
    a = !0;
  } else
    throw new Error(`[CoJSONBackend] Delete not supported for type: ${g}. Supported types: comap, colist, costream, coplaintext`);
  return a && i.node.storage && await i.node.syncManager.waitForStorageSync(e), a;
}
async function Su(i, A, e) {
  let t = 0, o = 0;
  try {
    const g = i.get("os");
    if (!g)
      return { deleted: 0, errors: 0 };
    const r = await IA(e, g, {
      waitForAvailable: !0,
      timeoutMs: 5e3
    });
    if (!r || !e.isAvailable(r))
      return { deleted: 0, errors: 0 };
    const n = e.getCurrentContent(r);
    if (!n || typeof n.get != "function")
      return { deleted: 0, errors: 0 };
    const s = n.get("schematas"), a = /* @__PURE__ */ new Set();
    if (s) {
      const E = await IA(e, s, {
        waitForAvailable: !0,
        timeoutMs: 5e3
      });
      if (E && e.isAvailable(E)) {
        const w = e.getCurrentContent(E);
        if (w && typeof w.get == "function") {
          const p = w.keys && typeof w.keys == "function" ? w.keys() : Object.keys(w);
          for (const N of p) {
            const v = w.get(N);
            v && typeof v == "string" && v.startsWith("co_z") && a.add(v);
          }
        }
      }
    }
    const I = n.get("metaSchema");
    I && typeof I == "string" && I.startsWith("co_z") && a.add(I);
    const C = /* @__PURE__ */ new Set();
    let c = null;
    const Q = n.get("indexes");
    if (Q)
      try {
        const E = await IA(e, Q, {
          waitForAvailable: !0,
          timeoutMs: 5e3
        });
        if (E && e.isAvailable(E) && (c = e.getCurrentContent(E), c && typeof c.get == "function")) {
          const w = c.keys && typeof c.keys == "function" ? c.keys() : Object.keys(c);
          console.log(`[Seed] Found ${w.length} schema index colists in account.os.indexes`);
          for (const p of w)
            if (p.startsWith("co_z")) {
              const N = c.get(p);
              if (N)
                try {
                  const v = await IA(e, N, {
                    waitForAvailable: !0,
                    timeoutMs: 2e3
                  });
                  if (v && e.isAvailable(v)) {
                    const U = e.getCurrentContent(v);
                    if (U && typeof U.toJSON == "function") {
                      const L = U.toJSON();
                      for (const P of L)
                        P && typeof P == "string" && P.startsWith("co_z") && C.add(P);
                    }
                  }
                } catch (v) {
                  console.warn(`[Seed] Failed to read index colist ${p ? p.substring(0, 12) : "undefined"}...:`, v.message), o++;
                }
            }
        }
      } catch (E) {
        console.warn("[Seed] Failed to read account.os.indexes:", E.message), o++;
      }
    let d = null;
    const f = n.get("unknown");
    if (f)
      try {
        const E = await IA(e, f, {
          waitForAvailable: !0,
          timeoutMs: 2e3
        });
        if (E && e.isAvailable(E) && (d = e.getCurrentContent(E), d && typeof d.toJSON == "function")) {
          const w = d.toJSON();
          console.log(`[Seed] Found ${w.length} co-values in account.os.unknown`);
          for (const p of w)
            p && typeof p == "string" && p.startsWith("co_z") && C.add(p);
        }
      } catch (E) {
        console.warn("[Seed] Failed to read unknown colist:", E.message), o++;
      }
    const h = Array.from(C).filter((E) => !a.has(E));
    console.log(`[Seed] Deleting ${h.length} co-values (filtered from ${C.size} total, preserving ${a.size} schemas)`);
    for (const E of h)
      try {
        const w = e.getCoValue(E);
        if (!w)
          continue;
        const v = (e.getHeader(w)?.meta || null)?.$schema;
        if (v && a.has(E))
          continue;
        try {
          await Oi(e, v || null, E), t++;
        } catch (U) {
          if (U.message && (U.message.includes("Cannot access") || U.message.includes("before initialization") || U.message.includes("ReferenceError")))
            t++;
          else
            throw U;
        }
      } catch (w) {
        console.warn(`[Seed] Failed to delete co-value ${E ? E.substring(0, 12) : "undefined"}...:`, w.message), o++;
      }
    let l = null;
    const B = i.get("vibes");
    if (B)
      try {
        const E = await IA(e, B, {
          waitForAvailable: !0,
          timeoutMs: 2e3
        });
        if (E && e.isAvailable(E) && (l = e.getCurrentContent(E), l && typeof l.get == "function")) {
          const w = l.keys && typeof l.keys == "function" ? l.keys() : Object.keys(l);
          console.log(`[Seed] Deleting ${w.length} vibes from account.vibes`);
          for (const p of w) {
            const N = l.get(p);
            if (N && typeof N == "string" && N.startsWith("co_z"))
              try {
                const v = e.getCoValue(N);
                if (v) {
                  const P = (e.getHeader(v)?.meta || null)?.$schema;
                  await Oi(e, P || null, N), t++;
                }
              } catch (v) {
                console.warn(`[Seed] Failed to delete vibe ${N ? N.substring(0, 12) : "undefined"}...:`, v.message), o++;
              }
          }
          for (const p of w)
            typeof l.delete == "function" && l.delete(p);
        }
      } catch (E) {
        console.warn("[Seed] Failed to delete vibes:", E.message), o++;
      }
    const u = [];
    let y = null;
    if (c)
      y = c;
    else {
      const E = n.get("indexes");
      if (E)
        try {
          const w = await IA(e, E, {
            waitForAvailable: !0,
            timeoutMs: 5e3
          });
          w && e.isAvailable(w) && (y = e.getCurrentContent(w));
        } catch (w) {
          console.warn("[Seed] Failed to read account.os.indexes for index colist deletion:", w.message), o++;
        }
    }
    if (y && typeof y.get == "function") {
      const E = y.keys && typeof y.keys == "function" ? y.keys() : Object.keys(y);
      console.log(`[Seed] Deleting ${E.length} index colists from account.os.indexes`);
      for (const w of E)
        if (w.startsWith("co_z")) {
          const p = y.get(w);
          if (p && typeof p == "string" && p.startsWith("co_z")) {
            const N = w;
            u.push({ schemaCoId: N, indexColistId: p });
          }
        }
    }
    for (const { schemaCoId: E, indexColistId: w } of u)
      try {
        const p = await oA(e, E, { returnType: "schema" });
        if (!p || !p.title) {
          console.warn(`[Seed] Cannot get schema title for ${E ? E.substring(0, 12) : "undefined"}..., skipping index colist deletion`);
          continue;
        }
        const N = p.title;
        if (!N.startsWith("@schema/")) {
          console.warn(`[Seed] Invalid schema title format: ${N}, skipping index colist deletion`);
          continue;
        }
        const U = `@schema/index/${N.replace("@schema/", "")}`, L = await oA(e, U, { returnType: "coId" });
        if (!L) {
          console.warn(`[Seed] Cannot resolve index colist schema ${U}, skipping index colist deletion`);
          continue;
        }
        try {
          await Oi(e, L, w), t++, y && typeof y.delete == "function" && y.delete(E);
        } catch (P) {
          if (P.message && (P.message.includes("Cannot access") || P.message.includes("before initialization") || P.message.includes("ReferenceError")))
            t++, y && typeof y.delete == "function" && y.delete(E);
          else
            throw P;
        }
      } catch (p) {
        console.warn(`[Seed] Failed to delete index colist ${w ? w.substring(0, 12) : "undefined"}...:`, p.message), o++;
      }
    if (y && typeof y.delete == "function")
      try {
        const E = y.keys && typeof y.keys == "function" ? Array.from(y.keys()) : Object.keys(y);
        if (E.length > 0) {
          console.log(`[Seed] Clearing ${E.length} remaining entries from account.os.indexes`);
          for (const w of E)
            y.delete(w);
        }
      } catch (E) {
        console.warn("[Seed] Failed to clear account.os.indexes:", E.message), o++;
      }
    if (d && typeof d.delete == "function")
      try {
        const E = d.toJSON ? d.toJSON() : [];
        E.length > 0 && console.log(`[Seed] Clearing ${E.length} remaining entries from account.os.unknown`);
      } catch (E) {
        console.warn("[Seed] Failed to clear account.os.unknown:", E.message), o++;
      }
    if (l && typeof l.get == "function") {
      const E = l.keys && typeof l.keys == "function" ? Array.from(l.keys()) : Object.keys(l);
      E.length > 0 ? console.warn(`[Seed] Warning: ${E.length} entries still remain in account.vibes after clearing`) : console.log("[Seed] account.vibes cleared successfully");
    }
    return console.log(`[Seed] Cleanup complete: deleted ${t} co-values, ${o} errors`), { deleted: t, errors: o };
  } catch (g) {
    return console.error("[Seed] Error during cleanup:", g), { deleted: t, errors: o + 1 };
  }
}
function bo(i) {
  const A = i ? `https://maia.city/${i}` : "https://json-schema.org/draft/2020-12/schema";
  return {
    definition: {
      ...Ti,
      $id: A,
      $schema: A
    }
  };
}
async function Nu(i, A, e, t, o, g = null) {
  const { CoJSONBackend: r } = await Promise.resolve().then(() => Ya), n = g || new r(A, i);
  try {
    const S = i.get("os");
    if (S) {
      const G = await IA(n, S, {
        waitForAvailable: !0,
        timeoutMs: 2e3
      });
      if (G && n.isAvailable(G)) {
        const F = n.getCurrentContent(G);
        if (F && typeof F.get == "function") {
          const J = F.get("schematas");
          if (J) {
            const x = await IA(n, J, {
              waitForAvailable: !0,
              timeoutMs: 2e3
            });
            if (x && n.isAvailable(x)) {
              const z = n.getCurrentContent(x);
              if (z && typeof z.get == "function" && (z.keys && typeof z.keys == "function" ? z.keys() : Object.keys(z)).length > 0 && (!e || !e.vibes?.length && Object.keys(e.actors || {}).length === 0))
                return console.log("  Account already seeded and no configs provided, skipping"), { skipped: !0, reason: "already_seeded_no_configs" };
            }
          }
        }
      }
    }
  } catch (S) {
    console.warn("[Seed] Idempotency check failed, proceeding with seeding:", S.message);
  }
  function s(S, G = !1) {
    if (S == null || typeof S != "object")
      return S;
    if (Array.isArray(S))
      return S.map((J) => s(J, G));
    const F = {};
    for (const [J, x] of Object.entries(S))
      if (!(J === "id" && !G))
        if (x != null && typeof x == "object") {
          const z = J === "properties" || J === "items";
          F[J] = s(x, z || G);
        } else
          F[J] = x;
    return F;
  }
  const { CoIdRegistry: a } = await Promise.resolve().then(() => qB), { transformForSeeding: I, validateSchemaStructure: C } = await Promise.resolve().then(() => Qa), c = new a(), Q = i.get("os");
  if (Q)
    try {
      const S = await IA(n, Q, {
        waitForAvailable: !0,
        timeoutMs: 2e3
      });
      if (S && n.isAvailable(S)) {
        const G = n.getCurrentContent(S);
        if (G && typeof G.get == "function" && G.get("schematas")) {
          console.log(" Cleaning up existing seeded data before reseeding...");
          const J = await Su(i, A, n);
          console.log(`[Seed] Cleanup complete: deleted ${J.deleted} co-values, ${J.errors} errors`);
        }
      }
    } catch (S) {
      console.warn("[Seed] Cleanup check failed, proceeding with seeding:", S.message);
    }
  const d = i.get("profile");
  if (!d)
    throw new Error("[CoJSONSeed] Profile not found on account. Ensure identity migration has run.");
  const f = await n.read(null, d);
  if (f.loading && await new Promise((S, G) => {
    let F;
    const J = setTimeout(() => {
      G(new Error(`Timeout waiting for profile ${d} to be available`));
    }, 1e4);
    F = f.subscribe(() => {
      f.loading || (clearTimeout(J), F(), S());
    });
  }), f.error || !f.value)
    throw new Error(`[CoJSONSeed] Profile not available: ${d}`);
  const h = f.value;
  if (!h.group || typeof h.group != "string")
    throw new Error("[CoJSONSeed] Universal group not found in profile.group. Ensure identity migration has run.");
  const l = h.group, B = await n.read("@group", l);
  if (B.loading && await new Promise((S, G) => {
    let F;
    const J = setTimeout(() => {
      G(new Error(`Timeout waiting for universal group ${l} to be available`));
    }, 1e4);
    F = B.subscribe(() => {
      B.loading || (clearTimeout(J), F(), S());
    });
  }), B.error || !B.value)
    throw new Error(`[CoJSONSeed] Universal group not available: ${l}`);
  const u = A.getCoValue(l);
  if (!u)
    throw new Error(`[CoJSONSeed] Universal group core not found: ${l}`);
  const y = u.verified?.header, E = u.ruleset || y?.ruleset;
  if (!E || E.type !== "group")
    throw new Error(`[CoJSONSeed] Universal group is not a group type (ruleset.type !== 'group'): ${l}`);
  const w = u.getCurrentContent?.();
  if (!w || typeof w.createMap != "function")
    throw new Error(`[CoJSONSeed] Universal group content not available: ${l}`);
  const p = /* @__PURE__ */ new Map();
  for (const [S, G] of Object.entries(t)) {
    const F = G.$id || `@schema/${S}`;
    p.has(F) || p.set(F, { name: S, schema: G });
  }
  const N = (S, G = /* @__PURE__ */ new Set()) => {
    const F = /* @__PURE__ */ new Set();
    if (!S || typeof S != "object" || G.has(S))
      return F;
    G.add(S), S.$co && typeof S.$co == "string" && S.$co.startsWith("@schema/") && F.add(S.$co);
    for (const J of Object.values(S))
      if (J && typeof J == "object")
        if (Array.isArray(J))
          for (const x of J)
            x && typeof x == "object" && N(x, G).forEach(($) => F.add($));
        else
          N(J, G).forEach((z) => F.add(z));
    return F;
  }, v = /* @__PURE__ */ new Map();
  for (const [S, { schema: G }] of p) {
    const F = N(G);
    v.set(S, F);
  }
  const U = [], L = /* @__PURE__ */ new Set(), P = /* @__PURE__ */ new Set(), V = (S) => {
    if (L.has(S) || P.has(S))
      return;
    P.add(S);
    const G = v.get(S) || /* @__PURE__ */ new Set();
    for (const F of G)
      F.startsWith("@schema/") && p.has(F) && V(F);
    P.delete(S), L.add(S), U.push(S);
  };
  for (const S of p.keys())
    S !== "@schema/meta" && V(S);
  await Gu(i, A, w, n);
  let W = null;
  const QA = i.get("os");
  if (QA) {
    const S = await IA(n, QA, {
      waitForAvailable: !0,
      timeoutMs: 2e3
    });
    if (S && n.isAvailable(S)) {
      const G = n.getCurrentContent(S);
      if (G && typeof G.get == "function" && !W) {
        const F = G.get("schematas");
        if (F) {
          const J = await IA(n, F, {
            waitForAvailable: !0,
            timeoutMs: 2e3
          });
          if (J && n.isAvailable(J)) {
            const x = n.getCurrentContent(J);
            x && typeof x.get == "function" && (W = x.get("@schema/meta"));
          }
        }
      }
    }
  }
  if (W) {
    const S = bo(W), { $schema: G, $id: F, id: J, ...x } = S.definition || S, z = s(x), $ = await IA(n, W, {
      waitForAvailable: !0,
      timeoutMs: 2e3
    });
    if ($ && n.isAvailable($)) {
      const _ = n.getCurrentContent($);
      if (_ && typeof _.set == "function")
        for (const [O, sA] of Object.entries(z))
          _.set(O, sA);
    }
  } else {
    const S = { $schema: "GenesisSchema" }, G = bo("co_zTEMP"), F = {
      definition: s(G.definition || G)
    }, J = w.createMap(
      F,
      // Will update $id after creation
      S
    ), x = J.id, z = bo(x), { $schema: $, $id: _, id: O, ...sA } = z.definition || z, rA = s(sA);
    for (const [EA, hA] of Object.entries(rA))
      J.set(EA, hA);
    W = x;
  }
  if (!c.has("@schema/meta"))
    c.register("@schema/meta", W);
  else {
    const S = c.get("@schema/meta");
    S !== W && (console.warn(`[Seed] Metaschema already registered with different co-id: ${S}, using existing instead of ${W}`), W = S);
  }
  const aA = /* @__PURE__ */ new Map(), wA = /* @__PURE__ */ new Map(), gA = await Promise.resolve().then(() => ma), kA = await Promise.resolve().then(() => cf), q = /* @__PURE__ */ new Map();
  if (QA) {
    const S = await IA(n, QA, {
      waitForAvailable: !0,
      timeoutMs: 2e3
    });
    if (S && n.isAvailable(S)) {
      const G = n.getCurrentContent(S);
      if (G && typeof G.get == "function") {
        const F = G.get("schematas");
        if (F) {
          const J = await IA(n, F, {
            waitForAvailable: !0,
            timeoutMs: 2e3
          });
          if (J && n.isAvailable(J)) {
            const x = n.getCurrentContent(J);
            if (x && typeof x.get == "function") {
              const z = x.keys && typeof x.keys == "function" ? x.keys() : Object.keys(x);
              for (const $ of z) {
                const _ = x.get($);
                _ && typeof _ == "string" && _.startsWith("co_z") && q.set($, _);
              }
            }
          }
        }
      }
    }
  }
  for (const S of U) {
    const { name: G, schema: F } = p.get(S), { $schema: J, $id: x, id: z, ...$ } = F, _ = s($), O = q.get(S);
    let sA;
    O ? (await kA.update(n, W, O, _), sA = O) : sA = (await gA.create(n, W, _)).id, aA.set(S, sA);
    const rA = n.getCoValue(sA);
    if (rA && n.isAvailable(rA)) {
      const EA = n.getCurrentContent(rA);
      EA && typeof EA.set == "function" && wA.set(S, EA);
    }
    c.register(S, sA);
  }
  W && !aA.has("@schema/meta") && aA.set("@schema/meta", W);
  const k = /* @__PURE__ */ new Map();
  for (const S of U) {
    const { name: G, schema: F } = p.get(S), J = aA.get(S), x = wA.get(S), z = I(F, aA);
    z.$id = `https://maia.city/${J}`;
    const $ = C(z, S, { checkSchemaReferences: !0, checkNestedCoTypes: !1 });
    if ($.length > 0) {
      const hA = `[Seed] Schema ${S} still contains @schema/ references after transformation:
${$.join(`
`)}`;
      throw console.error(hA), new Error(hA);
    }
    k.set(S, z);
    const { $schema: _, $id: O, id: sA, ...rA } = z, EA = s(rA);
    for (const [hA, WA] of Object.entries(EA))
      x.set(hA, WA);
  }
  const H = [];
  for (const S of U) {
    const { name: G } = p.get(S), F = aA.get(S), J = wA.get(S);
    H.push({
      name: G,
      key: S,
      coId: F,
      coMapId: J.id
    });
  }
  const K = /* @__PURE__ */ new Map();
  let m = await (async () => {
    const S = /* @__PURE__ */ new Map(), G = i.get("os");
    if (G) {
      const F = A.getCoValue(G);
      if (F && F.type === "comap") {
        const J = F.getCurrentContent?.();
        if (J && typeof J.get == "function") {
          const x = J.get("schematas");
          if (x) {
            const z = A.getCoValue(x);
            if (z && z.type === "comap") {
              const $ = z.getCurrentContent?.();
              if ($ && typeof $.get == "function") {
                const _ = $.keys();
                for (const O of _) {
                  const sA = $.get(O);
                  sA && typeof sA == "string" && sA.startsWith("co_z") && S.set(O, sA);
                }
                S.size > 0;
              }
            }
          }
        }
      }
    }
    if (S.size === 0) {
      for (const [F, J] of aA.entries())
        S.set(F, J);
      W && S.set("@schema/meta", W);
    }
    return S;
  })();
  if (o)
    for (const [S] of Object.entries(o)) {
      const G = `@schema/${S}`, F = `@schema/data/${S}`, J = m.get(F);
      J && (m.set(G, J), c.register(G, J));
    }
  let R = { configs: [], count: 0 };
  const j = (S, G) => {
    if (!S || typeof S != "object")
      return S;
    const F = JSON.parse(JSON.stringify(S));
    if (F.$schema && F.$schema.startsWith("@schema/")) {
      const J = G.get(F.$schema);
      J && (F.$schema = J);
    }
    return F;
  }, T = () => {
    const S = new Map(m);
    for (const [G, F] of K.entries())
      F && typeof F == "string" && F.startsWith("co_z") && S.set(G, F);
    for (const [G, F] of c.getAll())
      F && typeof F == "string" && F.startsWith("co_z") && S.set(G, F);
    return S;
  }, eA = async (S, G, F) => {
    if (!G || typeof G != "object")
      return { configs: [], count: 0 };
    const J = {};
    for (const [$, _] of Object.entries(G))
      J[$] = j(_, m);
    const x = { [S]: J }, z = await Rr(i, A, w, x, K, wA, aA);
    for (const $ of z.configs || []) {
      const _ = $.coId, O = $.path, sA = $.expectedCoId;
      K.set(O, _), sA && (K.set(sA, _), m.set(sA, _), c.register(sA, _)), c.register(O, _);
    }
    return z;
  };
  if (e) {
    const S = await eA("styles", e.styles);
    R.configs.push(...S.configs || []), R.count += S.count || 0, m = T();
    const G = await eA("actors", e.actors);
    R.configs.push(...G.configs || []), R.count += G.count || 0, m = T();
    const F = await eA("views", e.views);
    R.configs.push(...F.configs || []), R.count += F.count || 0, m = T();
    const J = await eA("contexts", e.contexts);
    R.configs.push(...J.configs || []), R.count += J.count || 0, m = T();
    const x = await eA("states", e.states);
    R.configs.push(...x.configs || []), R.count += x.count || 0, m = T();
    const z = await eA("interfaces", e.interfaces);
    R.configs.push(...z.configs || []), R.count += z.count || 0, m = T();
    const $ = await eA("subscriptions", e.subscriptions);
    R.configs.push(...$.configs || []), R.count += $.count || 0, m = T();
    const _ = await eA("inboxes", e.inboxes);
    R.configs.push(..._.configs || []), R.count += _.count || 0, m = T();
    const O = await eA("children", e.children);
    R.configs.push(...O.configs || []), R.count += O.count || 0, m = T();
    const sA = await eA("tool", e.tool);
    R.configs.push(...sA.configs || []), R.count += sA.count || 0, m = T();
  }
  const AA = async (S, G) => {
    if (!S || !G)
      return 0;
    const F = T();
    let J = 0;
    for (const x of S) {
      x.coId;
      const z = x.expectedCoId, $ = z && G ? Object.values(G).find((rA) => rA.$id === z) : null;
      if (!$)
        continue;
      const _ = I($, F), O = x.coMap, sA = x.cotype || "comap";
      if (sA === "colist") {
        if (O && typeof O.append == "function") {
          const rA = _.items || [];
          for (const EA of rA)
            O.append(EA);
          J++;
        }
      } else if (sA === "costream") {
        if (O && typeof O.push == "function") {
          const rA = _.items || [];
          for (const EA of rA)
            O.push(EA);
          J++;
        }
      } else if (O && typeof O.set == "function") {
        const { $id: rA, $schema: EA, ...hA } = _;
        hA.states && hA.states;
        for (const [WA, At] of Object.entries(hA))
          O.set(WA, At);
        J++;
      }
    }
    return J;
  };
  if (e) {
    const S = R.configs.filter((O) => O.type === "subscription");
    await AA(S, e.subscriptions);
    const G = R.configs.filter((O) => O.type === "inbox");
    await AA(G, e.inboxes);
    const F = R.configs.filter((O) => O.type === "children");
    await AA(F, e.children), T();
    const J = R.configs.filter((O) => O.type === "actor");
    await AA(J, e.actors);
    const x = R.configs.filter((O) => O.type === "view");
    await AA(x, e.views);
    const z = R.configs.filter((O) => O.type === "context");
    await AA(z, e.contexts);
    const $ = R.configs.filter((O) => O.type === "state");
    await AA($, e.states);
    const _ = R.configs.filter((O) => O.type === "interface");
    await AA(_, e.interfaces);
  }
  const M = e?.vibes || [];
  if (M.length > 0) {
    m = T();
    let S = i.get("vibes"), G;
    if (S) {
      const F = A.getCoValue(S);
      if (F && F.type === "comap") {
        const J = F.getCurrentContent?.();
        J && typeof J.set == "function" && (G = J);
      }
    }
    if (!G) {
      const F = { $schema: "GenesisSchema" };
      G = w.createMap({}, F), i.set("vibes", G.id);
    }
    for (const F of M) {
      const J = F.actor;
      if (J && !J.startsWith("co_z") && !m.get(J)) {
        const rA = Array.from(m.keys()).filter((EA) => EA.startsWith("@actor/")).slice(0, 10).join(", ");
        console.warn(`[CoJSONSeed] Actor reference ${J} not found in registry for vibe ${F.$id || F.name}. Available actor keys (first 10): ${rA}`);
      }
      const x = I(F, m);
      x.actor && !x.actor.startsWith("co_z") && (console.error(`[CoJSONSeed]  Vibe actor transformation failed! Expected co-id, got: ${x.actor}`), console.error(`[CoJSONSeed] Original actor: ${F.actor}, Registry has: ${m.has(F.actor)}`));
      const z = F.$id || "", $ = z.startsWith("@vibe/") ? z.replace("@vibe/", "") : (F.name || "default").toLowerCase().replace(/\s+/g, "-"), O = await Rr(i, A, w, { vibe: x }, K, wA, aA);
      if (R.configs.push(...O.configs || []), R.count += O.count || 0, O.configs && O.configs.length > 0) {
        const rA = O.configs[0].coId;
        if (G && typeof G.set == "function") {
          G.set($, rA);
          const hA = G.get($);
          hA !== rA && console.warn(`[CoJSONSeed] Vibe ${$} storage verification failed! Expected ${rA}, got ${hA}`);
        } else
          console.error(`[CoJSONSeed]  Cannot store vibe ${$}: vibes CoMap not available`);
        const EA = F.$id;
        EA && (K.set(EA, rA), m.set(EA, rA), c.register(EA, rA));
      }
    }
    if (G && typeof G.get == "function")
      for (const F of M) {
        const J = F.$id || "", x = J.startsWith("@vibe/") ? J.replace("@vibe/", "") : (F.name || "default").toLowerCase().replace(/\s+/g, "-");
        G.get(x) || console.error(`[CoJSONSeed] Missing: ${x} not found in account.vibes!`);
      }
  }
  const b = await Mu(i, A, w, o, c);
  return await ku(i, A, w, c, aA), {
    metaSchema: W,
    schemas: H,
    configs: R,
    data: b,
    registry: c.getAll()
  };
}
async function Rr(i, A, e, t, o, g, r) {
  const n = [];
  let s = 0;
  const a = async (C, c, Q) => {
    const d = C.$schema;
    if (!d || !d.startsWith("co_z"))
      throw new Error(`[CoJSONSeed] Config ${c}:${Q} has invalid $schema: ${d}`);
    let f = "comap", h = null;
    for (const [p, N] of r.entries())
      if (N === d) {
        h = g.get(p);
        break;
      }
    if (!h) {
      const p = A.getCoValue(d);
      p && p.type === "comap" && (h = p.getCurrentContent?.());
    }
    h && typeof h.get == "function" ? f = h.get("cotype") || "comap" : console.warn(`     Cannot read schema CoMap for ${d ? d.substring(0, 12) : "undefined"}... (config: ${Q}), schemaCoMap type: ${typeof h}`);
    const { $id: l, $schema: B, ...u } = C, y = { $schema: d };
    let E, w;
    if (f === "colist")
      E = e.createList([], y), w = E.id;
    else if (f === "costream")
      E = e.createStream(y), w = E.id;
    else {
      E = e.createMap({}, y), w = E.id;
      for (const [p, N] of Object.entries(u))
        E.set(p, N);
    }
    return l && (o.set(Q, w), o.set(l, w)), {
      type: c,
      path: Q,
      coId: w,
      expectedCoId: l || void 0,
      // Use $id from config (line 899), or undefined if not present
      coMapId: w,
      coMap: E,
      // Store the actual CoValue reference (CoMap, CoList, or CoStream)
      cotype: f
      // Store the type for reference
    };
  };
  if (t.vibe) {
    const C = await a(t.vibe, "vibe", "vibe");
    n.push(C), s++;
  }
  const I = async (C, c) => {
    if (!c || typeof c != "object")
      return 0;
    let Q = 0;
    for (const [d, f] of Object.entries(c))
      if (f && typeof f == "object" && f.$schema) {
        const h = await a(f, C, d);
        n.push(h), Q++;
      }
    return Q;
  };
  return s += await I("style", t.styles), s += await I("actor", t.actors), s += await I("view", t.views), s += await I("context", t.contexts), s += await I("state", t.states), s += await I("interface", t.interfaces), s += await I("subscription", t.subscriptions), s += await I("inbox", t.inboxes), s += await I("children", t.children), {
    count: s,
    types: [...new Set(n.map((C) => C.type))],
    configs: n
  };
}
async function Mu(i, A, e, t, o) {
  const { transformForSeeding: g } = await Promise.resolve().then(() => Qa);
  if (!t || Object.keys(t).length === 0)
    return {
      collections: [],
      totalItems: 0
    };
  const r = [];
  let n = 0;
  for (const [s, a] of Object.entries(t)) {
    if (!Array.isArray(a)) {
      console.warn(`[CoJSONSeed] Skipping ${s}: not an array`);
      continue;
    }
    const I = `data/${s}`, C = `@schema/data/${s}`, c = `@schema/${s}`, Q = o.registry.get(I) || o.registry.get(C) || o.registry.get(c);
    if (!Q) {
      console.warn(`[CoJSONSeed] No schema found for collection ${s} (tried: ${I}, ${C}, ${c}), skipping`);
      continue;
    }
    let d = 0;
    for (const f of a) {
      const h = g(f, o.getAll()), { $id: l, ...B } = h, u = { $schema: Q };
      e.createMap(B, u), d++;
    }
    r.push({
      name: s,
      schemaCoId: Q,
      itemCount: d
    }), n += d;
  }
  return {
    collections: r,
    totalItems: n
  };
}
async function Gu(i, A, e, t) {
  let o = i.get("os");
  if (o) {
    let s = A.getCoValue(o);
    if (!s && A.loadCoValueCore && (await A.loadCoValueCore(o), s = A.getCoValue(o)), s && s.isAvailable())
      return;
  }
  const g = { $schema: "GenesisSchema" }, r = e.createMap({}, g);
  if (i.set("os", r.id), A.storage && A.syncManager)
    try {
      await A.syncManager.waitForStorageSync(r.id), await A.syncManager.waitForStorageSync(i.id);
    } catch (s) {
      console.warn("[Seed] Storage sync wait failed for account.os:", s);
    }
  let n = A.getCoValue(r.id);
  if (n && !n.isAvailable() && await new Promise((s) => {
    let a;
    const I = setTimeout(s, 5e3);
    a = n.subscribe((C) => {
      C && C.isAvailable() && (clearTimeout(I), a(), s());
    });
  }), n = A.getCoValue(r.id), n && n.isAvailable()) {
    const s = n.getCurrentContent?.();
    if (s && typeof s.get == "function") {
      if (!s.get("schematas")) {
        const C = { $schema: "GenesisSchema" }, c = e.createMap({}, C);
        if (s.set("schematas", c.id), A.storage && A.syncManager)
          try {
            await A.syncManager.waitForStorageSync(c.id), await A.syncManager.waitForStorageSync(r.id);
          } catch (Q) {
            console.warn("[Seed] Storage sync wait failed for account.os.schematas:", Q);
          }
      }
      !s.get("indexes") && t && await no(t);
    }
  }
}
async function ku(i, A, e, t, o, g, r, n) {
  const s = i.get("os");
  if (!s) {
    console.warn("[Seed] account.os not found - should have been created in Phase 0");
    return;
  }
  let a = A.getCoValue(s);
  if (!a && A.loadCoValueCore && (await A.loadCoValueCore(s), a = A.getCoValue(s)), !a || !a.isAvailable()) {
    console.warn(`[Seed] account.os (${s ? s.substring(0, 12) : "undefined"}...) not available`);
    return;
  }
  const I = a.getCurrentContent?.();
  if (!I || typeof I.get != "function") {
    console.warn("[Seed] account.os content not available");
    return;
  }
  let C = I.get("schematas"), c;
  if (C) {
    const d = A.getCoValue(C);
    if (d && d.isAvailable()) {
      const f = d.getCurrentContent?.();
      f && typeof f.set == "function" && (c = f);
    }
  }
  if (!c) {
    let d = null;
    o && o.has("@schema/os/schematas-registry") && (d = o.get("@schema/os/schematas-registry"));
    const f = d ? { $schema: d } : { $schema: "GenesisSchema" };
    if (c = e.createMap({}, f), I.set("schematas", c.id), A.storage && A.syncManager)
      try {
        await A.syncManager.waitForStorageSync(c.id), await A.syncManager.waitForStorageSync(s);
      } catch (h) {
        console.warn("[Seed] Storage sync wait failed for account.os.schematas:", h);
      }
  }
  const Q = t.get("@schema/meta");
  if (Q) {
    const d = c.get("@schema/meta");
    d ? d !== Q && console.warn(`[Seed] Metaschema already registered with different co-id: ${d ? d.substring(0, 12) : "undefined"}... (new: ${Q ? Q.substring(0, 12) : "undefined"}...). Skipping.`) : c.set("@schema/meta", Q);
  }
}
const Fu = [
  "coValues",
  "sessions",
  "transactions",
  "signatureAfter",
  "deletedCoValues"
];
class Ru {
  constructor(A, e = Fu) {
    this.db = A, this.storeNames = e, this.pendingRequests = [], this.rejectHandlers = [], this.id = Math.random(), this.running = !1, this.failed = !1, this.done = !1, this.refresh();
  }
  refresh() {
    this.tx = this.db.transaction(this.storeNames, "readwrite"), this.tx.oncomplete = () => {
      this.done = !0;
    }, this.tx.onabort = () => {
      this.done = !0;
    };
  }
  rollback() {
    this.tx.abort();
  }
  getObjectStore(A) {
    try {
      return this.tx.objectStore(A);
    } catch {
      return this.refresh(), this.tx.objectStore(A);
    }
  }
  pushRequest(A) {
    const e = () => {
      const t = this.pendingRequests.shift();
      t ? t(this) : (this.running = !1, this.done = !0);
    };
    return this.running ? new Promise((t, o) => {
      this.rejectHandlers.push(o), this.pendingRequests.push(async () => {
        try {
          const g = await A(this, e);
          t(g);
        } catch (g) {
          o(g);
        }
      });
    }) : (this.running = !0, A(this, e));
  }
  handleRequest(A) {
    return this.pushRequest((e, t) => new Promise((o, g) => {
      const r = A(e);
      r.onerror = () => {
        this.failed = !0, this.tx.abort(), console.error(r.error), g(r.error);
        for (const n of this.rejectHandlers)
          n();
      }, r.onsuccess = () => {
        o(r.result), t();
      };
    }));
  }
  commit() {
    this.done || this.tx.commit();
  }
}
function Ye(i, A, e) {
  return new Promise((t, o) => {
    const g = i.transaction(A, "readonly"), r = e(g.objectStore(A));
    r.onerror = () => {
      o(r.error);
    }, r.onsuccess = () => {
      t(r.result), g.commit();
    };
  });
}
function bu(i, A, e) {
  return new Promise((t, o) => {
    const g = i.transaction(A, "readwrite"), r = g.objectStore(A).put(e);
    r.onerror = () => {
      o(r.error);
    }, r.onsuccess = () => {
      t(r.result), g.commit();
    };
  });
}
var br = function(i, A, e, t) {
  if (e === "a" && !t) throw new TypeError("Private accessor was defined without a getter");
  if (typeof A == "function" ? i !== A || !t : !A.has(i)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return e === "m" ? t : e === "a" ? t.call(i) : t ? t.value : A.get(i);
}, Pi, Cg;
class Ku {
  constructor(A) {
    Pi.add(this), this.tx = A;
  }
  async run(A) {
    return this.tx.handleRequest(A);
  }
  async getSingleCoValueSession(A, e) {
    return this.run((t) => t.getObjectStore("sessions").index("uniqueSessions").get([A, e]));
  }
  async markCoValueAsDeleted(A) {
    await this.run((e) => e.getObjectStore("deletedCoValues").put({
      coValueID: A,
      status: "pending"
    }));
  }
  async deleteCoValueContent(A) {
    const e = A.rowID, o = (await this.run((r) => r.getObjectStore("sessions").index("sessionsByCoValue").getAll(e))).filter((r) => !r.sessionID.endsWith("$")).map((r) => r.rowID), g = [];
    for (const r of o)
      g.push(br(this, Pi, "m", Cg).call(this, "transactions", r), br(this, Pi, "m", Cg).call(this, "signatureAfter", r), this.run((n) => n.getObjectStore("sessions").delete(r)));
    g.push(this.run((r) => r.getObjectStore("deletedCoValues").put({
      coValueID: A.id,
      status: "done"
    }))), await Promise.all(g);
  }
  async addSessionUpdate({ sessionUpdate: A, sessionRow: e }) {
    return this.run((t) => t.getObjectStore("sessions").put(e?.rowID ? {
      rowID: e.rowID,
      ...A
    } : A));
  }
  async addTransaction(A, e, t) {
    await this.run((o) => o.getObjectStore("transactions").add({
      ses: A,
      idx: e,
      tx: t
    }));
  }
  async addSignatureAfter({ sessionRowID: A, idx: e, signature: t }) {
    return this.run((o) => o.getObjectStore("signatureAfter").put({
      ses: A,
      idx: e,
      signature: t
    }));
  }
  /**
   * Get an unsynced CoValue record by coValueId and peerId.
   */
  async getUnsyncedCoValueRecord(A, e) {
    return this.run((t) => t.getObjectStore("unsyncedCoValues").index("uniqueUnsyncedCoValues").get([A, e]));
  }
  /**
   * Get all unsynced CoValue records for a given coValueId.
   */
  async getAllUnsyncedCoValueRecords(A) {
    return this.run((e) => e.getObjectStore("unsyncedCoValues").index("byCoValueId").getAll(A));
  }
  /**
   * Delete an unsynced CoValue record by rowID.
   */
  async deleteUnsyncedCoValueRecord(A) {
    await this.run((e) => e.getObjectStore("unsyncedCoValues").delete(A));
  }
  /**
   * Insert or update an unsynced CoValue record.
   */
  async putUnsyncedCoValueRecord(A) {
    await this.run((e) => e.getObjectStore("unsyncedCoValues").put(A));
  }
}
Pi = /* @__PURE__ */ new WeakSet(), Cg = async function(A, e) {
  const t = IDBKeyRange.bound([e, 0], [e, Number.POSITIVE_INFINITY]), o = await this.run((g) => g.getObjectStore(A).getAllKeys(t));
  for (const g of o)
    await this.run((r) => r.getObjectStore(A).delete(g));
};
class Yu {
  constructor(A) {
    this.db = A;
  }
  async getCoValue(A) {
    return Ye(this.db, "coValues", (e) => e.index("coValuesById").get(A));
  }
  async getCoValueRowID(A) {
    return this.getCoValue(A).then((e) => e?.rowID);
  }
  async getCoValueSessions(A) {
    return Ye(this.db, "sessions", (e) => e.index("sessionsByCoValue").getAll(A));
  }
  async getNewTransactionInSession(A, e, t) {
    return Ye(this.db, "transactions", (o) => o.getAll(IDBKeyRange.bound([A, e], [A, t])));
  }
  async getSignatures(A, e) {
    return Ye(this.db, "signatureAfter", (t) => t.getAll(IDBKeyRange.bound([A, e], [A, Number.POSITIVE_INFINITY])));
  }
  async upsertCoValue(A, e) {
    return e ? bu(this.db, "coValues", {
      id: A,
      header: e
    }).catch(() => this.getCoValueRowID(A)) : this.getCoValueRowID(A);
  }
  async getAllCoValuesWaitingForDelete() {
    return (await Ye(this.db, "deletedCoValues", (e) => e.index("deletedCoValuesByStatus").getAll("pending"))).map((e) => e.coValueID);
  }
  async transaction(A, e) {
    const t = new Ru(this.db, e);
    try {
      await A(new Ku(t)), t.commit();
    } catch {
      t.rollback();
    }
  }
  async trackCoValuesSyncState(A) {
    A.length !== 0 && await this.transaction(async (e) => {
      await Promise.all(A.map(async (t) => {
        const o = await e.getUnsyncedCoValueRecord(t.id, t.peerId);
        t.synced ? o && await e.deleteUnsyncedCoValueRecord(o.rowID) : await e.putUnsyncedCoValueRecord(o ? {
          rowID: o.rowID,
          coValueId: t.id,
          peerId: t.peerId
        } : {
          coValueId: t.id,
          peerId: t.peerId
        });
      }));
    }, ["unsyncedCoValues"]);
  }
  async eraseCoValueButKeepTombstone(A) {
    const e = await this.getCoValue(A);
    if (!e) {
      console.warn(`CoValue ${A} not found, skipping deletion`);
      return;
    }
    await this.transaction((t) => t.deleteCoValueContent(e));
  }
  async getUnsyncedCoValueIDs() {
    const A = await Ye(this.db, "unsyncedCoValues", (t) => t.getAll()), e = /* @__PURE__ */ new Set();
    for (const t of A)
      e.add(t.coValueId);
    return Array.from(e);
  }
  async stopTrackingSyncState(A) {
    await this.transaction(async (e) => {
      const t = e, o = await t.getAllUnsyncedCoValueRecords(A);
      await Promise.all(o.map((g) => t.deleteUnsyncedCoValueRecord(g.rowID)));
    }, ["unsyncedCoValues"]);
  }
  async getCoValueKnownState(A) {
    const e = await this.getCoValue(A);
    if (!e)
      return;
    const t = await this.getCoValueSessions(e.rowID), o = {
      id: A,
      header: !0,
      sessions: {}
    };
    for (const g of t)
      o.sessions[g.sessionID] = g.lastIdx;
    return o;
  }
}
let vu = "jazz-storage";
async function Uu(i = vu) {
  const e = await new Promise((t, o) => {
    const g = indexedDB.open(i, 6);
    g.onerror = () => {
      o(g.error);
    }, g.onsuccess = () => {
      t(g.result);
    }, g.onupgradeneeded = async (r) => {
      const n = g.result;
      if (r.oldVersion === 0) {
        n.createObjectStore("coValues", {
          autoIncrement: !0,
          keyPath: "rowID"
        }).createIndex("coValuesById", "id", {
          unique: !0
        });
        const a = n.createObjectStore("sessions", {
          autoIncrement: !0,
          keyPath: "rowID"
        });
        a.createIndex("sessionsByCoValue", "coValue"), a.createIndex("uniqueSessions", ["coValue", "sessionID"], {
          unique: !0
        }), n.createObjectStore("transactions", {
          keyPath: ["ses", "idx"]
        });
      }
      if (r.oldVersion <= 1 && n.createObjectStore("signatureAfter", {
        keyPath: ["ses", "idx"]
      }), r.oldVersion <= 4) {
        const s = n.createObjectStore("unsyncedCoValues", {
          autoIncrement: !0,
          keyPath: "rowID"
        });
        s.createIndex("byCoValueId", "coValueId"), s.createIndex("uniqueUnsyncedCoValues", ["coValueId", "peerId"], {
          unique: !0
        });
      }
      r.oldVersion <= 5 && n.createObjectStore("deletedCoValues", {
        keyPath: "coValueID"
      }).createIndex("deletedCoValuesByStatus", "status", {
        unique: !1
      });
    };
  });
  return new $s(new Yu(e));
}
async function Ju() {
  try {
    return await Uu();
  } catch (i) {
    console.warn("  [STORAGE] IndexedDB unavailable, running without persistence:", i), console.warn("   This may happen in incognito mode or unsupported browsers");
    return;
  }
}
const Kr = {
  1: [
    `CREATE TABLE IF NOT EXISTS transactions (
      ses INTEGER,
      idx INTEGER,
      tx TEXT NOT NULL,
      PRIMARY KEY (ses, idx)
    );`,
    `CREATE TABLE IF NOT EXISTS sessions (
      "rowID" SERIAL PRIMARY KEY,
      "coValue" INTEGER NOT NULL,
      "sessionID" TEXT NOT NULL,
      "lastIdx" INTEGER,
      "lastSignature" TEXT,
      UNIQUE ("sessionID", "coValue")
    );`,
    'CREATE INDEX IF NOT EXISTS sessionsByCoValue ON sessions ("coValue");',
    `CREATE TABLE IF NOT EXISTS coValues (
      "rowID" SERIAL PRIMARY KEY,
      id TEXT NOT NULL UNIQUE,
      header TEXT NOT NULL
    );`,
    "CREATE INDEX IF NOT EXISTS coValuesByID ON coValues (id);"
  ],
  3: [
    `CREATE TABLE IF NOT EXISTS signatureAfter (
      ses INTEGER,
      idx INTEGER,
      signature TEXT NOT NULL,
      PRIMARY KEY (ses, idx)
    );`,
    'ALTER TABLE sessions ADD COLUMN IF NOT EXISTS "bytesSinceLastSignature" INTEGER;'
  ],
  4: [
    `CREATE TABLE IF NOT EXISTS unsynced_covalues (
      "rowID" SERIAL PRIMARY KEY,
      "co_value_id" TEXT NOT NULL,
      "peer_id" TEXT NOT NULL,
      UNIQUE ("co_value_id", "peer_id")
    );`,
    'CREATE INDEX IF NOT EXISTS idx_unsynced_covalues_co_value_id ON unsynced_covalues("co_value_id");'
  ],
  5: [
    `CREATE TABLE IF NOT EXISTS deletedCoValues (
      "coValueID" TEXT PRIMARY KEY,
      status INTEGER NOT NULL DEFAULT 0
    );`,
    "CREATE INDEX IF NOT EXISTS deletedCoValuesByStatus ON deletedCoValues (status);"
  ]
};
async function Hu(i) {
  try {
    return (await i.query("SELECT version FROM schema_version ORDER BY version DESC LIMIT 1")).rows[0]?.version || 0;
  } catch {
    return 0;
  }
}
async function qu(i, A) {
  await i.exec(`
    CREATE TABLE IF NOT EXISTS schema_version (
      version INTEGER PRIMARY KEY,
      applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
    INSERT INTO schema_version (version) VALUES (${A})
    ON CONFLICT (version) DO NOTHING;
  `);
}
async function Lu(i) {
  const A = await Hu(i), e = Object.keys(Kr).map((t) => parseInt(t, 10)).filter((t) => t > A).sort((t, o) => t - o);
  for (const t of e) {
    const o = Kr[t];
    for (const g of o)
      await i.exec(g);
    await qu(i, t);
  }
}
class xu {
  constructor(A) {
    this.db = A;
  }
  async getSingleCoValueSession(A, e) {
    const o = (await this.db.query(
      'SELECT * FROM sessions WHERE "coValue" = $1 AND "sessionID" = $2',
      [A, e]
    )).rows[0];
    if (o)
      return {
        rowID: o.rowID || o.rowid,
        coValue: o.coValue || o.covalue,
        sessionID: o.sessionID || o.sessionid,
        lastIdx: o.lastIdx || o.lastidx,
        lastSignature: o.lastSignature || o.lastsignature,
        bytesSinceLastSignature: o.bytesSinceLastSignature || o.bytessincelastsignature
      };
  }
  async markCoValueAsDeleted(A) {
    await this.db.query(
      "INSERT INTO deletedCoValues (coValueID, status) VALUES ($1, $2) ON CONFLICT (coValueID) DO NOTHING",
      [A, Dt.Pending]
    );
  }
  async addSessionUpdate({ sessionUpdate: A, sessionRow: e }) {
    if (e)
      return (await this.db.query(
        `UPDATE sessions 
         SET "lastIdx" = $1, "lastSignature" = $2, "bytesSinceLastSignature" = $3
         WHERE "rowID" = $4
         RETURNING "rowID"`,
        [
          A.lastIdx,
          A.lastSignature,
          A.bytesSinceLastSignature,
          e.rowID
        ]
      )).rows[0]?.rowID || e.rowID;
    {
      const t = await this.db.query(
        `INSERT INTO sessions ("coValue", "sessionID", "lastIdx", "lastSignature", "bytesSinceLastSignature") 
         VALUES ($1, $2, $3, $4, $5)
         ON CONFLICT ("sessionID", "coValue") 
         DO UPDATE SET "lastIdx" = EXCLUDED."lastIdx", "lastSignature" = EXCLUDED."lastSignature", "bytesSinceLastSignature" = EXCLUDED."bytesSinceLastSignature"
         RETURNING "rowID"`,
        [
          A.coValue,
          A.sessionID,
          A.lastIdx,
          A.lastSignature,
          A.bytesSinceLastSignature
        ]
      );
      if (!t.rows[0])
        throw new Error("Failed to add session update");
      return t.rows[0].rowID;
    }
  }
  async addTransaction(A, e, t) {
    await this.db.query(
      "INSERT INTO transactions (ses, idx, tx) VALUES ($1, $2, $3)",
      [A, e, JSON.stringify(t)]
    );
  }
  async addSignatureAfter({ sessionRowID: A, idx: e, signature: t }) {
    await this.db.query(
      "INSERT INTO signatureAfter (ses, idx, signature) VALUES ($1, $2, $3)",
      [A, e, t]
    );
  }
}
class Tu {
  constructor(A) {
    this.db = A;
  }
  async getCoValue(A) {
    const e = await this.db.query(
      "SELECT * FROM coValues WHERE id = $1",
      [A]
    );
    if (!e.rows[0]) return;
    const t = e.rows[0];
    try {
      const o = typeof t.header == "string" ? JSON.parse(t.header) : t.header;
      return {
        rowID: t.rowID || t.rowid,
        id: t.id,
        header: o
      };
    } catch (o) {
      Z.warn(`Invalid JSON in header: ${t.header}`, {
        id: A,
        err: o
      });
      return;
    }
  }
  async upsertCoValue(A, e) {
    if (!e) {
      const g = await this.db.query(
        'SELECT "rowID" FROM coValues WHERE id = $1',
        [A]
      );
      return g.rows[0]?.rowID || g.rows[0]?.rowid;
    }
    const t = await this.db.query(
      `INSERT INTO coValues (id, header) VALUES ($1, $2)
       ON CONFLICT (id) DO NOTHING
       RETURNING "rowID"`,
      [A, JSON.stringify(e)]
    );
    if (t.rows[0])
      return t.rows[0].rowID || t.rows[0].rowid;
    const o = await this.db.query(
      'SELECT "rowID" FROM coValues WHERE id = $1',
      [A]
    );
    return o.rows[0]?.rowID || o.rows[0]?.rowid;
  }
  async getAllCoValuesWaitingForDelete() {
    return (await this.db.query(
      'SELECT "coValueID" FROM deletedCoValues WHERE status = $1',
      [Dt.Pending]
    )).rows.map((e) => e.coValueID || e.covalueid);
  }
  async getCoValueSessions(A) {
    return (await this.db.query(
      'SELECT * FROM sessions WHERE "coValue" = $1',
      [A]
    )).rows.map((t) => ({
      rowID: t.rowID || t.rowid,
      coValue: t.coValue || t.covalue,
      sessionID: t.sessionID || t.sessionid,
      lastIdx: t.lastIdx || t.lastidx,
      lastSignature: t.lastSignature || t.lastsignature,
      bytesSinceLastSignature: t.bytesSinceLastSignature || t.bytessincelastsignature
    }));
  }
  async getNewTransactionInSession(A, e, t) {
    return (await this.db.query(
      "SELECT * FROM transactions WHERE ses = $1 AND idx >= $2 AND idx <= $3 ORDER BY idx",
      [A, e, t]
    )).rows.map((g) => {
      try {
        return {
          ses: g.ses,
          idx: g.idx,
          tx: typeof g.tx == "string" ? JSON.parse(g.tx) : g.tx
        };
      } catch (r) {
        return Z.warn("Invalid JSON in transaction", { err: r }), null;
      }
    }).filter(Boolean);
  }
  async getSignatures(A, e) {
    return (await this.db.query(
      "SELECT * FROM signatureAfter WHERE ses = $1 AND idx >= $2 ORDER BY idx",
      [A, e]
    )).rows.map((o) => ({
      ses: o.ses,
      idx: o.idx,
      signature: o.signature
    }));
  }
  async transaction(A) {
    await this.db.exec("BEGIN");
    try {
      const e = new xu(this.db);
      await A(e), await this.db.exec("COMMIT");
    } catch (e) {
      throw await this.db.exec("ROLLBACK"), e;
    }
  }
  async trackCoValuesSyncState(A) {
    for (const e of A)
      e.synced ? await this.db.query(
        'DELETE FROM unsynced_covalues WHERE "co_value_id" = $1 AND "peer_id" = $2',
        [e.id, e.peerId]
      ) : await this.db.query(
        'INSERT INTO unsynced_covalues ("co_value_id", "peer_id") VALUES ($1, $2) ON CONFLICT ("co_value_id", "peer_id") DO NOTHING',
        [e.id, e.peerId]
      );
  }
  async getUnsyncedCoValueIDs() {
    return (await this.db.query(
      'SELECT DISTINCT "co_value_id" FROM unsynced_covalues'
    )).rows.map((e) => e.co_value_id);
  }
  async stopTrackingSyncState(A) {
    await this.db.query(
      'DELETE FROM unsynced_covalues WHERE "co_value_id" = $1',
      [A]
    );
  }
  async eraseCoValueButKeepTombstone(A) {
    const e = await this.db.query(
      'SELECT "rowID" FROM coValues WHERE id = $1',
      [A]
    );
    if (!e.rows[0]) {
      Z.warn(`CoValue ${A} not found, skipping deletion`);
      return;
    }
    const t = e.rows[0].rowID || e.rows[0].rowid;
    await this.transaction(async (o) => {
      await this.db.query(
        `DELETE FROM transactions
         WHERE ses IN (
           SELECT "rowID" FROM sessions
           WHERE "coValue" = $1 AND "sessionID" NOT LIKE '%$'
         )`,
        [t]
      ), await this.db.query(
        `DELETE FROM signatureAfter
         WHERE ses IN (
           SELECT "rowID" FROM sessions
           WHERE "coValue" = $1 AND "sessionID" NOT LIKE '%$'
         )`,
        [t]
      ), await this.db.query(
        `DELETE FROM sessions
         WHERE "coValue" = $1 AND "sessionID" NOT LIKE '%$'`,
        [t]
      ), await this.db.query(
        `INSERT INTO deletedCoValues ("coValueID", status) VALUES ($1, $2)
         ON CONFLICT ("coValueID") DO UPDATE SET status = $2`,
        [A, Dt.Done]
      );
    });
  }
  async getCoValueKnownState(A) {
    const e = await this.db.query(
      'SELECT "rowID" FROM coValues WHERE id = $1',
      [A]
    );
    if (!e.rows[0])
      return;
    const t = e.rows[0].rowID || e.rows[0].rowid, o = await this.db.query(
      'SELECT "sessionID", "lastIdx" FROM sessions WHERE "coValue" = $1',
      [t]
    ), g = ke(A);
    g.header = !0;
    for (const r of o.rows) {
      const n = r.sessionID || r.sessionid, s = r.lastIdx || r.lastidx;
      g.sessions[n] = s;
    }
    return g;
  }
}
async function Ou(i) {
  if (typeof window < "u" || typeof process > "u" || !process.versions?.node)
    throw new Error("[STORAGE] PGlite is only available in Node.js/server environments");
  console.log(`[STORAGE] Initializing PGlite at ${i}...`);
  try {
    let A;
    try {
      const r = await import("@electric-sql/pglite");
      A = r.PGlite || r.default?.PGlite || r.default;
    } catch (r) {
      throw typeof window < "u" ? new Error("[STORAGE] PGlite cannot be imported in browser environment. This is a server-only module.") : r;
    }
    if (!A)
      throw new Error("[STORAGE] Failed to import PGlite - module structure may have changed");
    const e = await Promise.resolve().then(() => hs), o = (await Promise.resolve().then(() => hs)).dirname(i);
    try {
      await e.mkdir(o, { recursive: !0 }), console.log(`[STORAGE] Ensured directory exists: ${o}`);
    } catch (r) {
      r.code !== "EEXIST" && console.warn(`[STORAGE] Could not create directory ${o}:`, r.message);
    }
    console.log("[STORAGE] Creating PGlite instance...");
    const g = await A.create(i);
    return console.log(`[STORAGE] PGlite initialized successfully at ${i}`), console.log("[STORAGE] Running PGlite migrations..."), await Lu(g), console.log("[STORAGE] PGlite migrations completed"), new Tu(g);
  } catch (A) {
    throw console.error(`[STORAGE] PGlite initialization error at ${i}:`, A), console.error("[STORAGE] Error details:", {
      message: A?.message,
      stack: A?.stack,
      name: A?.name,
      cause: A?.cause
    }), A;
  }
}
async function Pu(i) {
  try {
    const A = await Ou(i), e = new $s(A);
    return e.enableDeletedCoValuesErasure(), console.log("[STORAGE] PGlite storage adapter ready"), e;
  } catch (A) {
    throw console.error("[STORAGE] Failed to initialize PGlite storage:", A), console.error("[STORAGE] Error type:", A?.constructor?.name), console.error("[STORAGE] Error message:", A?.message), A?.stack && console.error("[STORAGE] Stack trace:", A.stack), A;
  }
}
async function oe() {
}
const gt = { BASE_URL: "/", DEV: !1, MODE: "production", PROD: !0, SSR: !1 };
function ju() {
  return typeof EdgeRuntime < "u" || typeof Deno < "u" ? "edge" : typeof process < "u" && process.versions && process.versions.node ? "node" : "browser";
}
function Vu(i, A = null) {
  const e = A ? `${A}_${i}` : i;
  if (typeof import.meta < "u" && gt)
    return gt[e] || gt[i] || gt[`VITE_${e}`] || gt[`VITE_${i}`];
  if (typeof process < "u" && process.env)
    return process.env[e] || process.env[i];
}
async function be(i = {}) {
  const { mode: A = "human", dbPath: e, inMemory: t, servicePrefix: o } = i, g = ju(), r = Vu("MAIA_STORAGE", o);
  if ((g === "node" || g === "browser" && typeof window < "u") && console.log(`[STORAGE] Runtime: ${g}, Mode: ${A}, Storage Type: ${r || "(default)"}, dbPath: ${e || "(none)"}`), t === !0)
    return console.log("[STORAGE] Using in-memory storage (explicit inMemory=true)"), await oe();
  if (g === "edge")
    return console.log("[STORAGE] Edge runtime detected - using in-memory storage (no persistence)"), await oe();
  if (r === "in-memory")
    return console.log("[STORAGE] Using in-memory storage (explicit MAIA_STORAGE=in-memory)"), await oe();
  if (g === "browser") {
    if (r === "indexeddb" || !r && A === "human") {
      const n = await Ju();
      return n ? (console.log("[STORAGE] Using IndexedDB storage"), n) : (console.warn("[STORAGE] IndexedDB unavailable, falling back to in-memory"), await oe());
    }
    return await oe();
  }
  if (g === "node") {
    const n = e || typeof process < "u" && process.env?.DB_PATH;
    if ((n && !t || r === "pglite" && !t && n) && n)
      try {
        const a = await Pu(n);
        return console.log(`[STORAGE] Using PGlite storage at ${n}`), a;
      } catch (a) {
        if (r === "pglite")
          throw new Error(
            `[STORAGE] PGlite storage initialization FAILED at ${n}. Storage type is explicitly set to 'pglite' via MAIA_STORAGE env var - refusing to fall back to in-memory. Original error: ${a?.message || a}. Check logs above for detailed initialization errors.`
          );
        return console.warn("[STORAGE] PGlite initialization failed, falling back to in-memory"), console.warn("[STORAGE] Fallback reason:", a?.message || a), await oe();
      }
    if (!r || r === "in-memory" || A === "agent" && !n)
      return console.log("[STORAGE] Using in-memory storage (Node.js default)"), await oe();
  }
  return await oe();
}
const Yr = { BASE_URL: "/", DEV: !1, MODE: "production", PROD: !0, SSR: !1 };
async function Vg({ agentSecret: i, name: A = "Maia", peers: e = [], storage: t = void 0, skipAutoSeeding: o = !1 }) {
  if (!i)
    throw new Error("agentSecret is required. Use signInWithPasskey() to get agentSecret.");
  const g = await ie.create(), r = t !== void 0 ? t : await be({ mode: "human" }), n = await pe.withNewlyCreatedAccount({
    creationProps: { name: A },
    crypto: g,
    initialAgentSecret: i,
    // Use provided secret from passkey!
    peers: e,
    // Use provided sync peers
    storage: r,
    // Use centralized storage if not provided
    migration: Lg
    // Handles profile + schemata + Data
  }), s = n.node.expectCurrentAccount("oID/createAccountWithSecret"), a = s.get("profile");
  if (!a)
    throw new Error("Profile not created by account creation migration");
  if (o)
    console.log("  Auto-seeding skipped (agent mode/server account)");
  else
    try {
      const I = typeof import.meta < "u" ? Yr?.VITE_SEED_VIBES || Yr?.SEED_VIBES : null, C = I ? I === "all" ? "all" : I.split(",").map((U) => U.trim()) : "all", { getAllVibeRegistries: c, filterVibesForSeeding: Q } = await Promise.resolve().then(() => vD), d = await c(), f = Q(d, C);
      if (f.length === 0)
        return d.length === 0 ? console.log("  No vibe registries found, skipping auto-seeding") : console.log(`  Seeding config filters out all vibes (config: ${JSON.stringify(C)}), skipping vibe seeding`), {
          node: n.node,
          account: s,
          accountID: s.id,
          profile: a,
          group: null
        };
      console.log(` Auto-seeding ${f.length} vibe(s) based on config: ${JSON.stringify(C)}`);
      const h = {
        styles: {},
        actors: {},
        views: {},
        contexts: {},
        states: {},
        inboxes: {},
        vibes: f.map((U) => U.vibe),
        // Pass vibes as array
        data: {}
      };
      for (const U of f)
        Object.assign(h.styles, U.styles || {}), Object.assign(h.actors, U.actors || {}), Object.assign(h.views, U.views || {}), Object.assign(h.contexts, U.contexts || {}), Object.assign(h.states, U.states || {}), Object.assign(h.inboxes, U.inboxes || {}), Object.assign(h.data, U.data || {});
      const { CoJSONBackend: l } = await Promise.resolve().then(() => Ya), B = new l(n.node, s), { DBEngine: u } = await Promise.resolve().then(() => of), y = new u(B);
      B.dbEngine = y;
      const { getAllToolDefinitions: E } = await Promise.resolve().then(() => Ha), w = E(), p = {
        ...h,
        tool: w
        // Add tool definitions under 'tool' key
      }, { getAllSchemas: N } = await Promise.resolve().then(() => ha), v = N();
      await y.execute({
        op: "seed",
        configs: p,
        schemas: v,
        data: h.data || {}
      });
    } catch (I) {
      console.error("[createAccountWithSecret] Auto-seeding failed (non-blocking):", I);
    }
  return {
    node: n.node,
    account: s,
    accountID: s.id,
    profile: a,
    group: null
    // No group in minimal setup
  };
}
async function Wg({ accountID: i, agentSecret: A, peers: e = [], storage: t = void 0 }) {
  if (!A)
    throw new Error("agentSecret is required. Use signInWithPasskey() to get agentSecret.");
  if (!i)
    throw new Error("accountID is required.");
  const o = await ie.create(), g = t !== void 0 ? t : await be({ mode: "human" }), r = performance.now();
  console.log("   Sync peers:", e.length > 0 ? `${e.length} peer(s)` : "none"), console.log("   Storage:", t ? "IndexedDB available (local-first)" : "no storage (sync-only)"), performance.now();
  const n = performance.now();
  t && console.log("    Storage available - will check IndexedDB first"), performance.now() - n;
  let s = null;
  const a = async (B, u) => (s = Lg(B, u).catch((y) => {
    console.error("[loadAccount] Migration error (non-blocking):", y);
  }), Promise.resolve()), I = performance.now(), C = 3e3, c = pe.withLoadedAccount({
    crypto: o,
    accountID: i,
    accountSecret: A,
    sessionID: o.newRandomSessionID(i),
    peers: e,
    // Use provided sync peers (sync happens in background if storage has data)
    storage: g,
    // Use centralized storage if not provided - enables local-first loading
    migration: a
    //  Runs after account loads, non-blocking
  }).catch((B) => {
    if (B?.message?.includes("Account unavailable from all peers") && e.length === 0 && g) {
      const u = new Error("Account not found in storage (first-time setup - will be created)");
      throw u.originalError = B, u.isAccountNotFound = !0, u;
    }
    throw B;
  }), Q = new Promise((B) => {
    setTimeout(() => {
      performance.now() - I, B(null);
    }, C);
  }), d = await Promise.race([c, Q]).then((B) => B === null ? c : B);
  if (performance.now(), s) {
    const B = performance.now();
    s.then(() => {
      performance.now() - B;
    }).catch(() => {
    });
  }
  const f = d.expectCurrentAccount("oID/loadAccount");
  performance.now();
  const h = f.get("profile");
  if (h) {
    const B = d.getCoValue(h);
    B && !B.isAvailable() && await d.load(h), performance.now();
  }
  performance.now();
  const l = f.get("os");
  if (l && typeof l == "string" && l.startsWith("co_z")) {
    const B = d.getCoValue(l);
    B && !B.isAvailable() ? d.loadCoValueCore(l).catch((u) => {
      console.warn("[loadAccount] Failed to prefetch account.os:", u);
    }) : B && B.isAvailable();
  }
  return performance.now() - r, {
    node: d,
    account: f,
    accountID: f.id
  };
}
async function Nt(i, A, e) {
  if (typeof i == "string" && i.startsWith("$"))
    return await A.evaluate(i, e);
  if (i === null || typeof i != "object")
    return i;
  if (Array.isArray(i))
    return Promise.all(i.map((g) => Nt(g, A, e)));
  const t = Object.keys(i);
  if (t.length === 1 && t[0].startsWith("$"))
    return await A.evaluate(i, e);
  const o = {};
  for (const [g, r] of Object.entries(i))
    r && typeof r == "object" ? A.isDSLOperation(r) ? o[g] = await A.evaluate(r, e) : o[g] = await Nt(r, A, e) : o[g] = await A.evaluate(r, e);
  return o;
}
function _e(i) {
  if (i == null)
    return !1;
  if (typeof i == "string")
    return !!(i.startsWith("$") || i.includes("?") && i.includes(":"));
  if (typeof i != "object")
    return !1;
  if (Array.isArray(i))
    return i.some((e) => _e(e));
  const A = Object.keys(i);
  if (A.length === 1 && A[0].startsWith("$"))
    return !0;
  for (const [e, t] of Object.entries(i))
    if (_e(t))
      return !0;
  return !1;
}
async function zg(i, A, e) {
  try {
    const t = await oA(i, { fromCoValue: A }, { returnType: "coId" });
    return t || null;
  } catch {
    return null;
  }
}
async function vr(i, A, e) {
  return e ? await Nt(i, e, { context: { existing: A }, item: {} }) : i;
}
function Wu(i, A) {
  if (!i || i.error) return null;
  const e = {};
  if (i.properties?.length) {
    for (const a of i.properties)
      if (a?.key !== void 0) {
        let I = a.value;
        if (typeof I == "string" && (I.startsWith("{") || I.startsWith("[")))
          try {
            I = JSON.parse(I);
          } catch {
          }
        e[a.key] = I;
      }
  } else Object.assign(e, i);
  const { id: t, loading: o, error: g, type: r, ...n } = e;
  if (n.definition) {
    const { id: a, type: I, ...C } = n.definition;
    return { ...C, $id: A };
  }
  return n.cotype || n.properties || n.items || n.title || n.description ? { ...n, $id: A } : null;
}
async function zu(i, A) {
  const { schema: e, key: t, keys: o, filter: g, options: r } = A;
  if (e && !e.startsWith("co_z") && !["@account", "@group", "@meta-schema"].includes(e))
    throw new Error(`[ReadOperation] Schema must be a co-id (co_z...) or special schema hint (@account, @group, @meta-schema), got: ${e}. Runtime code must use co-ids only, not '@schema/...' patterns.`);
  if (o !== void 0 && !Array.isArray(o)) throw new Error("[ReadOperation] keys parameter must be an array of co-ids");
  if (t && o) throw new Error("[ReadOperation] Cannot provide both key and keys parameters");
  return await i.read(e, t, o, g, r);
}
async function $u(i, A, e) {
  const { schema: t, data: o } = e;
  VA(t, "schema", "CreateOperation"), VA(o, "data", "CreateOperation"), Kt(A, "CreateOperation", "runtime schema validation");
  const g = await oA(i, t, { returnType: "coId" });
  if (!g) throw new Error(`[CreateOperation] Could not resolve schema: ${t}`);
  return await Re(i, g, o, "CreateOperation", { dbEngine: A }), await i.create(g, o);
}
async function Zu(i, A, e, t) {
  const { id: o, data: g } = t;
  VA(o, "id", "UpdateOperation"), ae(o, "UpdateOperation"), VA(g, "data", "UpdateOperation"), Kt(A, "UpdateOperation", "schema validation");
  const r = await i.getRawRecord(o);
  if (!r) throw new Error(`[UpdateOperation] Record not found: ${o}`);
  const n = await zg(i, o);
  if (n) {
    const { $schema: c, ...Q } = r, d = await vr(g, Q, e), f = { ...Q, ...d };
    await Re(i, n, f || d, "UpdateOperation", { dbEngine: A });
  }
  const s = n || r.$schema || null, { $schema: a, ...I } = r, C = await vr(g, I, e);
  return await i.update(s, o, C);
}
async function _u(i, A, e) {
  const { id: t } = e;
  VA(t, "id", "DeleteOperation"), ae(t, "DeleteOperation"), Kt(A, "DeleteOperation", "extract schema from CoValue headerMeta");
  const o = await zg(A.backend, t);
  return await i.delete(o, t);
}
async function Xu(i, A) {
  const { configs: e, schemas: t, data: o } = A;
  if (!e) throw new Error("[SeedOperation] Configs required");
  if (!t) throw new Error("[SeedOperation] Schemas required");
  return await i.seed(e, t, o || {});
}
async function Af(i, A, e) {
  const { coId: t, fromCoValue: o } = e, g = [t, o].filter(Boolean).length;
  if (g === 0) throw new Error("[SchemaOperation] One of coId or fromCoValue must be provided");
  if (g > 1) throw new Error("[SchemaOperation] Only one of coId or fromCoValue can be provided");
  let r = t ? (ae(t, "SchemaOperation"), t) : null;
  if (o && (ae(o, "SchemaOperation"), r = await oA(i, { fromCoValue: o }, { returnType: "coId" }), !r))
    return console.warn(`[SchemaOperation] Could not extract schema co-id from CoValue ${o} headerMeta`), new mA(null);
  const n = await i.read(null, r), s = new mA(null), a = (c) => s._set(Wu(c, r)), I = n.subscribe(a);
  a(n.value);
  const C = s._unsubscribe;
  return s._unsubscribe = () => {
    C && C(), I();
  }, s;
}
async function ef(i, A) {
  const { humanReadableKey: e } = A;
  if (VA(e, "humanReadableKey", "ResolveOperation"), typeof e != "string") throw new Error("[ResolveOperation] humanReadableKey must be a string");
  return (e.startsWith("@schema/") || e.startsWith("@actor/") || e.startsWith("@vibe/")) && console.warn(`[ResolveOperation] resolve() called with human-readable key: ${e}. This should only be used during seeding. At runtime, all IDs should already be co-ids.`), await oA(i, e, { returnType: "coId" });
}
async function Ur(i, A, e) {
  const { coId: t, item: o, items: g, cotype: r } = e;
  VA(t, "coId", "AppendOperation"), ae(t, "AppendOperation"), Kt(A, "AppendOperation", "check schema cotype");
  const n = await wa(i, t, "AppendOperation"), s = await zg(i, t);
  let a = r;
  if (!a) {
    const f = await xi(i, s, "colist"), h = await xi(i, s, "costream");
    if (f) a = "colist";
    else if (h) a = "costream";
    else throw new Error(`[AppendOperation] CoValue ${t} must be a CoList (colist) or CoStream (costream), got schema cotype: ${s}`);
  }
  if (!await xi(i, s, a)) throw new Error(`[AppendOperation] CoValue ${t} is not a ${a} (schema cotype check failed)`);
  const I = await oA(i, s, { returnType: "schema" });
  if (!I) throw new Error(`[AppendOperation] Schema ${s} not found`);
  const C = i.getCurrentContent(n), c = a === "colist" ? "append" : "push";
  if (!C || typeof C[c] != "function") throw new Error(`[AppendOperation] ${a === "colist" ? "CoList" : "CoStream"} ${t} doesn't have ${c} method`);
  const Q = g || (o ? [o] : []);
  if (Q.length === 0) throw new Error("[AppendOperation] At least one item required (use item or items parameter)");
  fa(I, Q);
  let d = 0;
  if (a === "colist") {
    let f = [];
    try {
      typeof C.toJSON == "function" && (f = C.toJSON() || []);
    } catch (h) {
      console.warn("[AppendOperation] Error checking existing items:", h);
    }
    for (const h of Q)
      f.includes(h) || (C.append(h), d++);
  } else
    for (const f of Q) C.push(f), d++;
  return i.node?.storage && await i.node.syncManager.waitForStorageSync(t), { success: !0, coId: t, [a === "colist" ? "itemsAppended" : "itemsPushed"]: d, ...a === "colist" && { itemsSkipped: Q.length - d } };
}
async function tf(i, A, e) {
  const { actorId: t, inboxCoId: o } = e;
  VA(t, "actorId", "ProcessInboxOperation"), VA(o, "inboxCoId", "ProcessInboxOperation"), ae(t, "ProcessInboxOperation"), ae(o, "ProcessInboxOperation");
  const { processInbox: g } = await Promise.resolve().then(() => so);
  return await g(i, t, o);
}
let $g = class {
  /**
   * Create a new DBEngine instance
   * @param {DBAdapter} backend - Backend adapter instance (must implement DBAdapter interface)
   * @param {Object} [options] - Optional configuration
   * @param {Object} [options.evaluator] - Optional MaiaScript evaluator for expression evaluation in updates
   */
  constructor(A, e = {}) {
    this.backend = A;
    const { evaluator: t } = e;
    A && typeof A.setDbEngine == "function" ? A.setDbEngine(this) : A && A.constructor.name === "CoJSONBackend" && (A.dbEngine = this), this.operations = {
      read: { execute: (o) => zu(this.backend, o) },
      create: { execute: (o) => $u(this.backend, this, o) },
      update: { execute: (o) => Zu(this.backend, this, t, o) },
      delete: { execute: (o) => _u(this.backend, this, o) },
      seed: { execute: (o) => Xu(this.backend, o) },
      schema: { execute: (o) => Af(this.backend, this, o) },
      resolve: { execute: (o) => ef(this.backend, o) },
      append: { execute: (o) => Ur(this.backend, this, o) },
      push: { execute: (o) => Ur(this.backend, this, { ...o, cotype: "costream" }) },
      processInbox: { execute: (o) => tf(this.backend, this, o) }
    };
  }
  /**
   * Execute a database operation
   * @param {Object} payload - Operation payload
   * @param {string} payload.op - Operation name (read, create, update, delete, seed)
   * @param {Object} payload params - Operation-specific parameters
   * @returns {Promise<any>} Operation result
   */
  async execute(A) {
    const { op: e, ...t } = A;
    if (!e)
      throw new Error('[DBEngine] Operation required: {op: "read|create|update|delete|seed|schema|resolve|append|push"}');
    if (e === "push")
      return await this.operations.append.execute({ ...t, cotype: "costream" });
    const o = this.operations[e];
    if (!o)
      throw new Error(`[DBEngine] Unknown operation: ${e}`);
    try {
      return await o.execute(t);
    } catch (g) {
      throw console.error(`[DBEngine] Operation ${e} failed:`, g), g;
    }
  }
  /**
   * Resolve a human-readable ID to a co-id
   * DEPRECATED: This method should only be used during seeding. At runtime, all IDs should already be co-ids.
   * @deprecated Use co-ids directly at runtime. This method is only for seeding/backward compatibility.
   * @param {string} humanReadableId - Human-readable ID (e.g., '@vibe/todos', 'vibe/vibe')
   * @returns {Promise<string|null>} Co-id (co_z...) or null if not found
   */
};
class Ra {
  /**
   * Read data from database
   * @param {string} schema - Schema co-id (co_z...)
   * @param {string} [key] - Specific key (co-id) for single item
   * @param {string[]} [keys] - Array of co-ids for batch reads
   * @param {Object} [filter] - Filter criteria for collection queries
   * @returns {Promise<ReactiveStore|ReactiveStore[]>} Reactive store(s) that hold current value and notify on updates
   */
  async read(A, e, t, o) {
    throw new Error("[DBAdapter] read() must be implemented by backend");
  }
  /**
   * Create new record
   * @param {string} schema - Schema co-id (co_z...) for data collections
   * @param {Object} data - Data to create
   * @returns {Promise<Object>} Created record with generated co-id
   */
  async create(A, e) {
    throw new Error("[DBAdapter] create() must be implemented by backend");
  }
  /**
   * Update existing record (unified for data collections and configs)
   * @param {string} schema - Schema co-id (co_z...) - MUST be a co-id, not '@schema/...'
   * @param {string} id - Record co-id to update
   * @param {Object} data - Data to update
   * @returns {Promise<Object>} Updated record
   */
  async update(A, e, t) {
    throw new Error("[DBAdapter] update() must be implemented by backend");
  }
  /**
   * Delete record
   * @param {string} schema - Schema co-id (co_z...)
   * @param {string} id - Record co-id to delete
   * @returns {Promise<boolean>} true if deleted successfully
   */
  async delete(A, e) {
    throw new Error("[DBAdapter] delete() must be implemented by backend");
  }
  /**
   * Get raw record from database (without normalization)
   * Used for validation - returns stored data as-is (with $schema metadata, without id)
   * @param {string} id - Record co-id
   * @returns {Promise<Object|null>} Raw stored record or null if not found
   */
  async getRawRecord(A) {
    throw new Error("[DBAdapter] getRawRecord() must be implemented by backend");
  }
  /**
   * Seed database with configs, schemas, and initial data (optional - backend-specific)
   * @param {Object} configs - Config registry
   * @param {Object} schemas - Schema definitions
   * @param {Object} data - Initial application data
   * @returns {Promise<void>}
   */
  async seed(A, e, t) {
    throw new Error("[DBAdapter] seed() is optional - backend may not implement this");
  }
}
const of = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DBAdapter: Ra,
  DBEngine: $g,
  ReactiveStore: mA
}, Symbol.toStringTag, { value: "Module" }));
async function gf(i, A) {
  const e = i.getCoValue(A);
  if (!e || !e?.isAvailable())
    return null;
  const t = e?.getCurrentContent();
  return !t || typeof t.addMember != "function" ? null : t;
}
async function rf(i) {
  if (i._cachedUniversalGroup)
    return i._cachedUniversalGroup;
  const A = await i.read(null, i.account.get("profile"));
  if (!A || A.error)
    throw new Error("[CoJSONBackend] Profile not found on account. Ensure the account has a valid profile.");
  await new Promise((s, a) => {
    if (!A.loading) {
      s();
      return;
    }
    let I;
    const C = setTimeout(() => {
      a(new Error("[CoJSONBackend] Timeout waiting for profile to be available"));
    }, 1e4);
    I = A.subscribe(() => {
      A.loading || (clearTimeout(C), I(), s());
    });
  });
  const e = A.value;
  if (!e)
    throw new Error("[CoJSONBackend] Profile data not available. Ensure the profile is properly loaded.");
  if (Object.keys(e).filter((s) => !["id", "type", "$schema"].includes(s)).length === 0 && (!e.properties || e.properties.length === 0))
    throw new Error("[CoJSONBackend] Profile CoMap is empty. This may indicate the identity migration has not run. Please ensure schemaMigration() has been called during account creation/loading.");
  let o;
  if (e.properties && Array.isArray(e.properties)) {
    const s = e.properties.find((a) => a.key === "group");
    if (!s || !s.value)
      throw new Error('[CoJSONBackend] Universal group not found in profile.group. The profile exists but does not have a "group" property. This indicates the identity migration may not have completed successfully. Please check that schemaMigration() sets profile.set("group", universalGroupId).');
    o = s.value;
  } else if (e.group && typeof e.group == "string")
    o = e.group;
  else
    throw new Error('[CoJSONBackend] Universal group not found in profile.group. The profile exists but does not have a "group" property. This indicates the identity migration may not have completed successfully. Please ensure schemaMigration() has been called and sets profile.set("group", universalGroupId).');
  if (!o || typeof o != "string" || !o.startsWith("co_z"))
    throw new Error(`[CoJSONBackend] Invalid universal group ID format: ${o}. Expected a valid co-id (co_z...). This may indicate a migration issue.`);
  const g = await i.read("@group", o);
  if (!g || g.error)
    throw new Error(`[CoJSONBackend] Universal group not available: ${o}. Ensure the group exists and is synced.`);
  await new Promise((s, a) => {
    if (!g.loading) {
      s();
      return;
    }
    let I;
    const C = setTimeout(() => {
      a(new Error(`[CoJSONBackend] Timeout waiting for universal group ${o} to be available`));
    }, 1e4);
    I = g.subscribe(() => {
      g.loading || (clearTimeout(C), I(), s());
    });
  });
  const r = i.getCoValue(o);
  if (!r)
    throw new Error(`[CoJSONBackend] Universal group core not found: ${o}. Ensure the group is loaded in the node.`);
  const n = i.getCurrentContent(r);
  if (!n || typeof n.createMap != "function")
    throw new Error(`[CoJSONBackend] Universal group content not available: ${o}. Ensure the group is properly initialized.`);
  return i._cachedUniversalGroup = n, n;
}
function nf(i) {
  const A = [], e = /* @__PURE__ */ new Set();
  try {
    if (typeof i.getMemberKeys == "function") {
      const t = i.getMemberKeys();
      for (const o of t) {
        if (e.has(o)) continue;
        e.add(o);
        let g = null;
        if (typeof i.roleOf == "function")
          try {
            g = i.roleOf(o);
          } catch {
            try {
              const n = i.get(o);
              n && n !== "revoked" && (g = n);
            } catch {
            }
          }
        else if (typeof i.get == "function") {
          const r = i.get(o);
          r && r !== "revoked" && (g = r);
        }
        if (g && g !== "revoked") {
          const r = i.get ? i.get(o) : null, n = r !== g && r !== "revoked";
          A.push({
            id: o,
            role: g,
            isInherited: n || !1
          });
        }
      }
    }
    if (A.length === 0 && i.members && typeof i.members[Symbol.iterator] == "function") {
      for (const t of i.members)
        if (t && t.account) {
          const o = t.account, g = typeof o == "string" ? o : o.id || o.$jazz && o.$jazz.id || "unknown";
          if (e.has(g)) continue;
          e.add(g);
          let r = null;
          if (typeof i.roleOf == "function")
            try {
              r = i.roleOf(g);
            } catch {
            }
          r && r !== "revoked" && A.push({
            id: g,
            role: r,
            isInherited: !1
          });
        }
    }
  } catch (t) {
    console.warn("[CoJSONBackend] Error extracting account members:", t);
  }
  return A;
}
function sf(i) {
  try {
    let A = null;
    if (typeof i.getRoleOf == "function")
      try {
        const e = i.getRoleOf("everyone");
        e && typeof e == "string" && e !== "revoked" && (A = e);
      } catch {
      }
    if (!A && typeof i.get == "function")
      try {
        const e = i.get("everyone");
        e && typeof e == "string" && e !== "revoked" && (A = e);
      } catch {
      }
    if (!A && i.everyone !== void 0) {
      const e = i.everyone;
      e && typeof e == "string" && e !== "revoked" && (A = e);
    }
    return A;
  } catch {
    return null;
  }
}
function af(i) {
  const A = [];
  try {
    if (typeof i.getParentGroups == "function") {
      const e = i.getParentGroups();
      if (e && typeof e[Symbol.iterator] == "function")
        for (const t of e) {
          const o = typeof t == "string" ? t : t.id || t.$jazz && t.$jazz.id || "unknown";
          let g = null;
          const r = `parent_${o}`;
          if (typeof i.get == "function")
            try {
              g = i.get(r);
            } catch {
            }
          let n = "";
          g === "extend" ? n = "Inherits roles from parent group" : g === "reader" ? n = "All parent members get reader access" : g === "writer" ? n = "All parent members get writer access" : g === "manager" ? n = "All parent members get manager access" : g === "admin" ? n = "All parent members get admin access" : g === "revoked" ? n = "Delegation revoked" : n = "Delegated access", A.push({
            id: o,
            role: g || "extend",
            roleDescription: n
          });
        }
    }
  } catch (e) {
    console.warn("[CoJSONBackend] Error extracting group members:", e);
  }
  return A;
}
function Jr(i) {
  if (!i || typeof i.addMember != "function")
    return null;
  try {
    const A = i.id || i.$jazz && i.$jazz.id;
    if (!A)
      return null;
    const e = nf(i), t = sf(i);
    t && (e.some((r) => r.id === "everyone") || e.push({
      id: "everyone",
      role: t
    }));
    const o = af(i);
    return {
      groupId: A,
      accountMembers: e,
      groupMembers: o
    };
  } catch (A) {
    return console.warn("[CoJSONBackend] Error getting group info from group:", A), null;
  }
}
async function ba(i, A, e, t) {
  if (typeof A.addMember != "function")
    throw new Error("[CoJSONBackend] Group does not support addMember");
  const o = i.getCoValue(e);
  if (!o)
    throw new Error(`[CoJSONBackend] Member not found: ${e}`);
  try {
    A.addMember(e, t);
  } catch (g) {
    const r = o?.getCurrentContent();
    if (r && r.account)
      A.addMember(r.account, t);
    else
      throw new Error(`[CoJSONBackend] Failed to add member: ${g.message}`);
  }
}
async function If(i, A) {
  if (typeof i.removeMember != "function")
    throw new Error("[CoJSONBackend] Group does not support removeMember");
  i.removeMember(A);
}
async function Cf(i, A, e, t) {
  if (typeof A.setRole == "function")
    A.setRole(e, t);
  else if (typeof A.removeMember == "function" && typeof A.addMember == "function")
    A.removeMember(e), await ba(i, A, e, t);
  else
    throw new Error("[CoJSONBackend] Group does not support role changes");
}
async function Ka(i, A, e, t) {
  const o = await IA(i, e, { waitForAvailable: !0 });
  if (!o)
    throw new Error(`[CoJSONBackend] CoValue not found: ${e}`);
  if (!i.isAvailable(o))
    throw new Error(`[CoJSONBackend] CoValue not available: ${e}`);
  const g = i.getCurrentContent(o), r = g?.type || "unknown";
  let n = null;
  try {
    n = await oA(i, { fromCoValue: e }, { returnType: "coId" });
  } catch (s) {
    console.log(`[Update] Skipping validation for ${e}: ${s.message}`);
  }
  if (n && i.dbEngine && n.startsWith("co_z")) {
    const { isExceptionSchema: s } = await Promise.resolve().then(() => SB);
    if (!s(n)) {
      const a = await i.getRawRecord(e);
      if (a) {
        const { $schema: I, ...C } = a, c = { ...C, ...t };
        try {
          await Re(
            i,
            n,
            c,
            `update for ${e}`,
            { dbEngine: i.dbEngine }
          );
        } catch (Q) {
          throw new Error(`[Update] Validation failed: ${Q.message}`);
        }
      }
    }
  }
  if (r === "comap" && g.set)
    for (const [s, a] of Object.entries(t))
      g.set(s, a);
  else
    throw new Error(`[CoJSONBackend] Update not supported for type: ${r}`);
  return Jg(i, o);
}
const cf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  update: Ka
}, Symbol.toStringTag, { value: "Module" }));
function Zg(i, A, e) {
  const t = A?.account && A.account.id === e, o = A?.account && A.account.get && A.account.get("profile") === e, g = i.header?.meta?.type === "account", n = i.header?.ruleset?.type === "group", s = A?.account && !i.header, a = t || g || s, I = n && !t && !g && !s, C = i.header?.meta?.$schema, c = C ? se(C) : !1;
  return {
    isAccount: a,
    isGroup: I,
    isProfile: o,
    isException: c
  };
}
function cg(i) {
  return !i || !i.header || !i.header.meta ? null : i.header.meta.$schema || null;
}
function Bf(i, A, e) {
  const t = Zg(i, A, e);
  return t.isAccount || t.isGroup || t.isProfile || t.isException;
}
const TA = /* @__PURE__ */ new Set();
function Qf(i, A) {
  if (!i || !A)
    return i;
  const e = i.store.bind(i), t = new Proxy(i, {
    get(g, r) {
      if (r === "store")
        return function(s, a) {
          return o.call(g, s, a, e);
        };
      const n = g[r];
      return typeof n == "function" ? n.bind(g) : n;
    }
  });
  function o(g, r, n) {
    const s = g.id, a = Zg(g, A, s);
    if (!a.isAccount && !a.isGroup && !a.isProfile) {
      if (!g.header || !g.header.meta)
        throw g.header ? console.warn(`[StorageHook] Co-value ${s} has header but no meta. Header structure:`, {
          type: g.header.type,
          ruleset: g.header.ruleset,
          hasMeta: !!g.header.meta,
          headerKeys: Object.keys(g.header || {})
        }) : console.warn(`[StorageHook] Co-value ${s} has no header at all. Message structure:`, {
          id: g.id,
          hasHeader: !!g.header,
          messageKeys: Object.keys(g || {})
        }), console.error(`[StorageHook] REJECTING co-value ${s}: Missing header.meta. Every co-value MUST have headerMeta.$schema (except groups, accounts, and profiles during account creation).`), new Error(`[StorageHook] Co-value ${s} missing header.meta. Every co-value MUST have headerMeta.$schema (except groups, accounts, and profiles during account creation).`);
      if (!cg(g) && !a.isException)
        throw console.error(`[StorageHook] REJECTING co-value ${s}: Missing $schema in headerMeta. Every co-value MUST have a schema (except @account, @group, GenesisSchema, and groups/accounts).`), new Error(`[StorageHook] Co-value ${s} missing $schema in headerMeta. Every co-value MUST have a schema (except @account, @group, GenesisSchema, and groups/accounts).`);
    }
    let I = Bf(g, A, s);
    if (I && cg(g) === "GenesisSchema" && (I = !1), !I && A.account) {
      const c = A.account.get("os");
      if (s === c)
        I = !0;
      else if (c) {
        const Q = A.node.getCoValue(c);
        if (Q && A.isAvailable(Q) && Q.type === "comap") {
          const d = Q.getCurrentContent?.();
          if (d && typeof d.get == "function") {
            const f = d.get("schematas");
            s === f && (I = !0);
            const h = d.get("unknown");
            s === h && (I = !0);
            const l = d.get("indexes");
            if (s === l && (I = !0), l && !I) {
              const B = A.node.getCoValue(l);
              if (B && A.isAvailable(B) && B.type === "comap") {
                const u = B.getCurrentContent?.();
                if (u && typeof u.get == "function")
                  try {
                    const y = u.keys && typeof u.keys == "function" ? u.keys() : Object.keys(u);
                    for (const E of y)
                      if (u.get(E) === s) {
                        I = !0;
                        break;
                      }
                  } catch {
                    I = !0;
                  }
              }
            }
          }
        } else (!Q || !A.isAvailable(Q)) && (I = !0);
      }
    }
    const C = n(g, r);
    return I || Promise.resolve(C).then(async () => {
      if (!TA.has(s)) {
        TA.add(s);
        try {
          let c = A.getCoValue(s);
          if ((!c || !A.isAvailable(c)) && (A.node && A.node.loadCoValueCore && A.node.loadCoValueCore(s).catch(() => {
          }), !c || !A.isAvailable(c)))
            return;
          const Q = A.getCoValue(s);
          if (!Q || !A.isAvailable(Q))
            return;
          if (await Ga(A, Q)) {
            setTimeout(() => {
              TA.has(s) && Ma(A, Q).then(() => {
                TA.delete(s);
              }).catch(() => {
                TA.delete(s);
              });
            }, 0);
            return;
          }
          const { shouldIndex: f } = await jg(A, Q);
          if (!f)
            return;
          setTimeout(() => {
            TA.has(s) && ka(A, Q).then(() => {
              TA.delete(s);
            }).catch(() => {
              TA.delete(s);
            });
          }, 0);
        } catch {
          TA.delete(s);
        }
      }
    }).catch(() => {
      const c = g.id;
      TA.delete(c);
    }), C;
  }
  return t;
}
async function Ef(i, A) {
  try {
    const e = i.getCoValue(A);
    if (!e || !i.isAvailable(e))
      return null;
    const t = i.getCurrentContent(e);
    return t ? t && typeof t.toJSON == "function" ? t.toJSON() : t : null;
  } catch (e) {
    return console.warn(`[ValidationHook] Failed to extract content for ${A}:`, e), null;
  }
}
async function lf(i, A, e = 5e3) {
  const t = Date.now();
  for (; Date.now() - t < e; ) {
    try {
      const o = await oA(i, A, { returnType: "schema" });
      if (o)
        return o;
    } catch {
    }
    await new Promise((o) => setTimeout(o, 100));
  }
  return null;
}
async function df(i, A, e) {
  const t = e.id, o = Zg(e, i, t);
  if (o.isGroup || o.isAccount || o.isProfile)
    return { valid: !0, error: null };
  const g = cg(e);
  if (!g)
    return {
      valid: !1,
      error: `Co-value ${t} missing $schema in headerMeta. Every co-value MUST have a schema (except @account, @group, GenesisSchema, and groups/accounts).`
    };
  if (se(g))
    return { valid: !0, error: null };
  if (!g.startsWith("co_z"))
    return {
      valid: !1,
      error: `Co-value ${t} has invalid schema format: ${g}. Schema must be a co-id (co_z...) or exception schema (@account, @group, GenesisSchema).`
    };
  let r = await oA(i, g, { returnType: "schema" });
  if (!r && (console.log(`[ValidationHook] Schema ${g} not available, waiting for sync...`), r = await lf(i, g, 5e3), !r))
    return {
      valid: !1,
      error: `Schema ${g} not available after timeout. Cannot validate remote transactions for ${t}.`
    };
  const n = await Ef(i, t);
  if (!n)
    return console.log(`[ValidationHook] Cannot extract content for ${t} (likely new co-value) - schema availability verified, allowing transactions`), { valid: !0, error: null };
  try {
    return await Re(
      i,
      g,
      n,
      `remote sync for ${t}`,
      { dbEngine: A }
    ), { valid: !0, error: null };
  } catch (s) {
    return {
      valid: !1,
      error: `Validation failed for remote transactions: ${s.message}`
    };
  }
}
function hf(i, A, e) {
  if (!i || !A)
    return i;
  const t = i.handleNewContent?.bind(i);
  return t && (i.handleNewContent = async function(o, g) {
    if (o && o.id && e) {
      const r = await df(A, e, o);
      if (!r.valid)
        throw console.error(`[ValidationHook] Rejecting remote transactions for ${o.id}: ${r.error}`), new Error(`[ValidationHook] Invalid remote transactions rejected: ${r.error}`);
    }
    return t(o, g);
  }), i;
}
class _g extends Ra {
  constructor(A, e, t = null) {
    super(), this.node = A, this.account = e, this.dbEngine = t, this.subscriptionCache = na(A), this._cachedUniversalGroup = null, A.storage && (A.storage = Qf(A.storage, this)), A.syncManager && t && hf(A.syncManager, this, t);
  }
  /**
   * Reset all subscription-related caches
   * 
   * Called when new backend is created to clear stale subscriptions from previous session.
   */
  _resetCaches() {
    this._cachedUniversalGroup && (this._cachedUniversalGroup = null);
  }
  /**
   * Get a CoValue by ID
   * @param {string} coId - CoValue ID
   * @returns {CoValueCore|null} CoValueCore or null if not found
   */
  getCoValue(A) {
    return this.node.getCoValue(A);
  }
  /**
   * Get all CoValues from the node
   * @returns {Map<string, CoValueCore>} Map of CoValue IDs to CoValueCore instances
   */
  getAllCoValues() {
    return this.node.coValues || /* @__PURE__ */ new Map();
  }
  /**
   * Check if CoValue is available (has verified state)
   * @param {CoValueCore} coValueCore - CoValueCore instance
   * @returns {boolean} True if available
   */
  isAvailable(A) {
    return A?.isAvailable() || !1;
  }
  /**
   * Get current content from CoValueCore
   * @param {CoValueCore} coValueCore - CoValueCore instance
   * @returns {RawCoValue|null} Current content or null
   */
  getCurrentContent(A) {
    return !A || !A.isAvailable() ? null : A.getCurrentContent();
  }
  /**
   * Get header from CoValueCore
   * @param {CoValueCore} coValueCore - CoValueCore instance
   * @returns {Object|null} Header object or null
   */
  getHeader(A) {
    return A?.verified?.header || null;
  }
  /**
   * Get account (for create operations)
   * @returns {RawAccount} Account CoMap
   */
  getAccount() {
    return this.account;
  }
  /**
   * Get current session ID from the node
   * @returns {string|null} Current session ID or null if node not available
   */
  getCurrentSessionID() {
    return !this.node || !this.node.currentSessionID ? null : this.node.currentSessionID;
  }
  /**
   * Read inbox CoStream with session structure and CRDT metadata preserved
   * Backend-to-backend method for inbox processing
   * @param {string} inboxCoId - Inbox CoStream co-id
   * @returns {Object|null} CoStream data with sessions and CRDT metadata, or null if not found/not a CoStream
   */
  readInboxWithSessions(A) {
    const e = this.getCoValue(A);
    return !e || !this.isAvailable(e) ? null : BB(this, e);
  }
  /**
   * Get default group from account (for create operations)
   * Returns universal group via account.profile.group using read() API
   * Uses @group exception since groups don't have $schema
   * Caches result after first resolution for performance
   * @returns {RawGroup|null} Universal group or account as fallback
   */
  async getDefaultGroup() {
    return await rf(this);
  }
  /**
   * Get group information for a CoValue
   * Extracts owner group, account members, and group members with roles
   * @param {CoValueCore} coValueCore - CoValueCore instance
   * @returns {Object|null} Group info object or null if no group found
   */
  getGroupInfo(A) {
    if (!A || !this.isAvailable(A))
      return null;
    try {
      const e = this.getHeader(A), t = this.getCurrentContent(A), o = A.ruleset || e?.ruleset;
      if (!o)
        return null;
      let g = null, r = null, n = null;
      if (o.type === "group")
        g = A.id, r = A, n = t;
      else if (o.type === "ownedByGroup" && o.group)
        g = o.group, r = this.getCoValue(g), r && this.isAvailable(r) && (n = this.getCurrentContent(r));
      else if (t && t.group) {
        const a = t.group;
        g = typeof a == "string" ? a : a.id || a.$jazz && a.$jazz.id, g && (r = this.getCoValue(g), r && this.isAvailable(r) && (n = this.getCurrentContent(r)));
      } else
        return null;
      if (!n || typeof n.addMember != "function")
        return null;
      const s = Jr(n);
      return s && g && (s.groupId = g), s;
    } catch (e) {
      return console.warn("[CoJSONBackend] Error getting group info:", e), null;
    }
  }
  /**
   * Get a Group CoValue by ID
   * @param {string} groupId - Group CoValue ID
   * @returns {Promise<RawGroup|null>} Group CoValue or null if not found
   */
  async getGroup(A) {
    return await gf(this.node, A);
  }
  /**
   * Get group info from a RawGroup
   * @param {RawGroup} group - RawGroup instance
   * @returns {Object|null} Group info object
   */
  getGroupInfoFromGroup(A) {
    return Jr(A);
  }
  /**
   * Add a member to a group
   * @param {RawGroup} group - Group CoValue
   * @param {string} memberId - Member ID (account or group Co-ID)
   * @param {string} role - Role name
   * @returns {Promise<void>}
   */
  async addGroupMember(A, e, t) {
    return await ba(this.node, A, e, t);
  }
  /**
   * Remove a member from a group
   * @param {RawGroup} group - Group CoValue
   * @param {string} memberId - Member ID to remove
   * @returns {Promise<void>}
   */
  async removeGroupMember(A, e) {
    return await If(A, e);
  }
  /**
   * Set a member's role in a group
   * @param {RawGroup} group - Group CoValue
   * @param {string} memberId - Member ID
   * @param {string} role - New role name
   * @returns {Promise<void>}
   */
  async setGroupMemberRole(A, e, t) {
    return await Cf(this.node, A, e, t);
  }
  // ============================================================================
  // DBAdapter Interface Implementation
  // ============================================================================
  /**
   * Read data from database - directly translates to CoJSON raw operations
   * @param {string} schema - Schema co-id (co_z...) or special exceptions:
   *   - '@group' - For groups (no $schema, use ruleset.type === 'group')
   *   - '@account' - For accounts (no $schema, use headerMeta.type === 'account')
   *   - '@meta-schema' or 'GenesisSchema' - For meta schema
   * @param {string} [key] - Specific key (co-id) for single item
   * @param {string[]} [keys] - Array of co-ids for batch reads
   * @param {Object} [filter] - Filter criteria for collection queries
   * @param {Object} [options] - Options for deep resolution
   * @param {boolean} [options.deepResolve=true] - Enable/disable deep resolution (default: true)
   * @param {number} [options.maxDepth=10] - Maximum depth for recursive resolution (default: 10)
   * @param {number} [options.timeoutMs=5000] - Timeout for waiting for nested CoValues (default: 5000)
   * @param {Object} [options.resolveReferences] - Configuration for resolving CoValue references (e.g., { fields: ['source', 'target'] })
   * @param {Object} [options.map] - Map transformation config (e.g., { sender: '$$source.role', recipient: '$$target.role' })
   * @returns {Promise<ReactiveStore|ReactiveStore[]>} Reactive store(s) that hold current value and notify on updates
   */
  async read(A, e, t, o, g = {}) {
    const {
      deepResolve: r = !0,
      maxDepth: n = 10,
      timeoutMs: s = 5e3,
      resolveReferences: a = null,
      map: I = null,
      onChange: C = null
    } = g, c = { deepResolve: r, maxDepth: n, timeoutMs: s, resolveReferences: a, map: I, onChange: C };
    return t && Array.isArray(t) ? await Promise.all(t.map((d) => cA(this, d, A, null, A, c))) : e ? await cA(this, e, A, null, A, c) : A ? await cA(this, null, A, o, null, c) : await cA(this, null, null, o, null, c);
  }
  /**
   * Read a single CoValue by ID and wrap in ReactiveStore
   * Waits for CoValue to be loaded before returning store (operations API abstraction)
   * @private
   * @param {string} coId - CoValue ID
   * @param {string} [schemaHint] - Schema hint for special types (@group, @account, @meta-schema)
   * @returns {Promise<ReactiveStore>} ReactiveStore with CoValue data (already loaded)
   */
  async _readSingleItem(A, e = null) {
    return await cA(this, A, e, null, e);
  }
  /**
   * Wait for a ReactiveStore to be ready (loaded and not in error state)
   * Used internally by _readSingleItem to ensure stores are ready before returning
   * @private
   * @param {ReactiveStore} store - Store to wait for
   * @param {string} coId - CoValue ID (for error messages)
   * @param {number} timeoutMs - Timeout in milliseconds (default: 5000)
   * @returns {Promise<void>} Resolves when store is ready, rejects on timeout or error
   */
  async _waitForStoreReady(A, e, t = 5e3) {
    return await YA(A, e, t);
  }
  /**
   * Get CoList ID from schema index (account.os.<schemaCoId>)
   * Supports schema co-ids, human-readable schema names, or collection names (legacy fallback)
   * @private
   * @param {string} collectionNameOrSchema - Collection name (e.g., "todos"), schema co-id (co_z...), or namekey (@schema/data/todos)
   * @returns {Promise<string|null>} CoList ID or null if not found
   */
  async _getCoListId(A) {
    return await Ug(this, A);
  }
  /**
   * Ensure CoValue is loaded from IndexedDB (jazz-tools pattern)
   * Generic method that works for ANY CoValue type (CoMap, CoList, CoStream, etc.)
   * After re-login, CoValues exist in IndexedDB but aren't loaded into node memory
   * This method explicitly loads them before accessing, just like jazz-tools does
   * @private
   * @param {string} coId - CoValue ID (co-id)
   * @param {Object} [options] - Options
   * @param {boolean} [options.waitForAvailable=false] - Wait for CoValue to become available
   * @param {number} [options.timeoutMs=2000] - Timeout in milliseconds
   * @returns {Promise<CoValueCore|null>} CoValueCore or null if not found
   */
  async _ensureCoValueLoaded(A, e = {}) {
    return await IA(this, A, e);
  }
  /**
   * Read a collection of CoValues by schema
   * @private
   * @param {string} schema - Schema co-id (co_z...)
   * @param {Object} [filter] - Filter criteria
   * @returns {Promise<ReactiveStore>} ReactiveStore with array of CoValue data
   */
  async _readCollection(A, e) {
    return await cA(this, null, A, e);
  }
  /**
   * Read all CoValues (no schema filter)
   * @private
   * @param {Object} [filter] - Filter criteria
   * @returns {Promise<ReactiveStore>} ReactiveStore with array of all CoValue data
   */
  async _readAllCoValues(A) {
    return await cA(this, null, null, A);
  }
  /**
   * Extract CoValue data from CoValueCore and normalize (match IndexedDB format)
   * @private
   * @param {CoValueCore} coValueCore - CoValueCore instance
   * @param {string} [schemaHint] - Schema hint for special types (@group, @account, @meta-schema)
   * @returns {Object} Normalized CoValue data (flattened properties, id field added)
   */
  _extractCoValueData(A, e = null) {
    return Jg(this, A, e);
  }
  /**
   * Extract CoValue data as flat object (for SubscriptionEngine and UI)
   * Returns flat objects like {id: '...', text: '...', done: false} instead of normalized format
   * @private
   * @param {CoValueCore} coValueCore - CoValueCore instance
   * @param {string} [schemaHint] - Schema hint for special types
   * @returns {Object|Array} Flat object or array of items
   */
  _extractCoValueDataFlat(A, e = null) {
    return ne(this, A, e);
  }
  /**
   * Extract CoValue data from RawCoValue content
   * @private
   * @param {RawCoValue} content - RawCoValue content
   * @returns {Object} Extracted data
   */
  _extractCoValueDataFromContent(A) {
    return QB(A);
  }
  /**
   * Check if CoValue data matches filter criteria
   * @private
   * @param {Object|Array} data - CoValue data (object for CoMap, array for CoList)
   * @param {Object} filter - Filter criteria
   * @returns {boolean} True if matches filter
   */
  _matchesFilter(A, e) {
    return Hg(A, e);
  }
  /**
   * Create new record - directly creates CoValue using CoJSON raw methods
   * @param {string} schema - Schema co-id (co_z...) for data collections
   * @param {Object} data - Data to create
   * @returns {Promise<Object>} Created record with generated co-id
   */
  async create(A, e) {
    return await xg(this, A, e);
  }
  /**
   * Update existing record - directly updates CoValue using CoJSON raw methods
   * @param {string} schema - Schema co-id (co_z...)
   * @param {string} id - Record co-id to update
   * @param {Object} data - Data to update
   * @returns {Promise<Object>} Updated record
   */
  async update(A, e, t) {
    return await Ka(this, A, e, t);
  }
  /**
   * Delete record - hard delete using CoJSON native operations
   * Removes item from CoList (hard delete) and clears CoMap content
   * @param {string} schema - Schema co-id (co_z...)
   * @param {string} id - Record co-id to delete
   * @returns {Promise<boolean>} true if deleted successfully
   */
  async delete(A, e) {
    return await Oi(this, A, e);
  }
  /**
   * Get raw record from database (without normalization)
   * Used for validation - returns stored data as-is (with $schema metadata, without id)
   * @param {string} id - Record co-id
   * @returns {Promise<Object|null>} Raw stored record or null if not found
   */
  async getRawRecord(A) {
    const e = this.getCoValue(A);
    if (!e || !this.isAvailable(e))
      return null;
    const t = this.getCurrentContent(e), r = (this.getHeader(e)?.meta || null)?.$schema || null;
    if (t && t.get && typeof t.get == "function") {
      const n = {
        $schema: r
        // Metadata for querying/validation
      }, s = t.keys && typeof t.keys == "function" ? t.keys() : Object.keys(t);
      for (const a of s)
        n[a] = t.get && typeof t.get == "function" ? t.get(a) : t[a];
      return n;
    }
    if (t && t.toJSON)
      try {
        return t.toJSON();
      } catch {
        return null;
      }
    return null;
  }
  /**
   * Seed database with configs, schemas, and initial data
   * @param {Object} configs - Config registry {vibe, styles, actors, views, contexts, states, interfaces}
   * @param {Object} schemas - Schema definitions
   * @param {Object} data - Initial application data {todos: [], ...}
   * @returns {Promise<Object>} Summary of what was seeded
   */
  async seed(A, e, t) {
    if (!this.account)
      throw new Error("[CoJSONBackend] Account required for seed");
    return await Nu(this.account, this.node, A, e, t || {}, this);
  }
  /**
   * Ensure account.os is loaded and ready for schema-dependent operations
   * 
   * Progressive loading: account.os is NOT required for account loading itself
   * It's only needed for schema resolution, which can happen progressively as account.os becomes available
   * 
   * This function is called non-blocking during boot - MaiaOS boots immediately without waiting
   * Schema resolution will return null until account.os is ready, then progressively start working
   * 
   * @param {Object} [options] - Options
   * @param {number} [options.timeoutMs=10000] - Timeout for waiting for account.os to be ready
   * @returns {Promise<boolean>} True if account.os is ready, false if failed
   */
  async ensureAccountOsReady(A = {}) {
    const { timeoutMs: e = 1e4 } = A;
    if (!this.account)
      return console.warn("[CoJSONBackend.ensureAccountOsReady] Account not available"), !1;
    const t = performance.now(), o = {
      getOsId: 0,
      createOs: 0,
      osReadRequest: 0,
      osReadResponse: 0,
      osWaitForReady: 0,
      osReadTotal: 0,
      getSchematasId: 0,
      createSchematas: 0,
      schematasReadRequest: 0,
      schematasReadResponse: 0,
      schematasWaitForReady: 0,
      schematasReadTotal: 0,
      total: 0
    }, g = performance.now();
    let r = this.account.get("os");
    if (o.getOsId = performance.now() - g, !r || typeof r != "string" || !r.startsWith("co_z")) {
      const y = performance.now(), E = await this.getDefaultGroup(), w = { $schema: "GenesisSchema" }, p = E.createMap({}, w);
      this.account.set("os", p.id), r = p.id, o.createOs = performance.now() - y;
    }
    const n = performance.now(), s = await cA(this, r, null, null, null, {
      deepResolve: !1,
      timeoutMs: e
    }), a = performance.now();
    o.osReadRequest = n - t, o.osReadResponse = a - t, o.osReadTotal = a - n;
    const I = performance.now();
    try {
      await YA(s, r, e);
      const y = performance.now();
      o.osWaitForReady = y - I;
    } catch (y) {
      const E = performance.now();
      return o.osWaitForReady = E - I, console.error(`[CoJSONBackend.ensureAccountOsReady] Timeout waiting for account.os to load: ${y.message}`), !1;
    }
    const C = s.value;
    if (!C || C.error)
      return console.error("[CoJSONBackend.ensureAccountOsReady] account.os data not available or has error"), !1;
    const c = performance.now();
    let Q = C.schematas;
    if (o.getSchematasId = performance.now() - c, !Q || typeof Q != "string" || !Q.startsWith("co_z")) {
      const y = performance.now(), E = this.getCoValue(r);
      if (!E || !E.isAvailable())
        return console.error("[CoJSONBackend.ensureAccountOsReady] account.os not available for creating schematas"), !1;
      const w = this.getCurrentContent(E);
      if (!w || typeof w.set != "function")
        return console.error("[CoJSONBackend.ensureAccountOsReady] account.os content not available for creating schematas"), !1;
      const p = await this.getDefaultGroup(), N = { $schema: "GenesisSchema" }, v = p.createMap({}, N);
      w.set("schematas", v.id), Q = v.id, o.createSchematas = performance.now() - y;
      const U = await cA(this, r, null, null, null, {
        deepResolve: !1,
        timeoutMs: 2e3
      });
      try {
        await YA(U, r, 2e3);
        const L = U.value;
        L && !L.error && (Q = L.schematas || Q);
      } catch {
      }
    }
    if (!Q || typeof Q != "string" || !Q.startsWith("co_z"))
      return console.error("[CoJSONBackend.ensureAccountOsReady] Failed to ensure schematas registry exists"), !1;
    const d = performance.now(), f = await cA(this, Q, null, null, null, {
      deepResolve: !1,
      timeoutMs: e
    }), h = performance.now();
    o.schematasReadRequest = d - t, o.schematasReadResponse = h - t, o.schematasReadTotal = h - d;
    const l = performance.now();
    try {
      await YA(f, Q, e);
      const y = performance.now();
      o.schematasWaitForReady = y - l;
    } catch (y) {
      const E = performance.now();
      return o.schematasWaitForReady = E - l, console.error(`[CoJSONBackend.ensureAccountOsReady] Timeout waiting for schematas registry to load: ${y.message}`), !1;
    }
    const B = f.value;
    if (!B || B.error)
      return console.error("[CoJSONBackend.ensureAccountOsReady] schematas registry data not available or has error"), !1;
    const u = performance.now();
    return o.total = u - t, !0;
  }
}
const Ya = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CoJSONBackend: _g
}, Symbol.toStringTag, { value: "Module" }));
function uf(i, A) {
  if (!i)
    throw new Error("[createCoJSONAPI] Node required");
  if (!A)
    throw new Error("[createCoJSONAPI] Account required");
  const e = new _g(i, A), t = new $g(e);
  return e.dbEngine = t, {
    /**
     * Execute a database operation
     * @param {Object} payload - Operation payload
     * @param {string} payload.op - Operation name (read, create, update, delete)
     * @param {Object} payload params - Operation-specific parameters
     * @returns {Promise<any>} Operation result
     */
    cojson: async (o) => await t.execute(o)
  };
}
async function Bg(i, A, e) {
  if (!i)
    throw new Error("[createAndPushMessage] dbEngine is required");
  if (!A || !A.startsWith("co_z"))
    throw new Error(`[createAndPushMessage] inboxCoId must be a valid co-id (co_z...), got: ${A}`);
  if (!e || typeof e != "object")
    throw new Error("[createAndPushMessage] messageData must be an object");
  let t = null;
  try {
    const a = (await i.execute({
      op: "schema",
      fromCoValue: A
    })).value;
    if (a && a.items && a.items.$co) {
      const I = a.items.$co;
      if (I.startsWith("co_z"))
        t = I;
      else if (I.startsWith("@schema/")) {
        const C = I.replace("@schema/", ""), Q = (await i.execute({
          op: "schema",
          schemaName: C
        })).value;
        Q && Q.$id && (t = Q.$id);
      }
    }
    if (t || (t = await i.execute({
      op: "resolve",
      humanReadableKey: "@schema/message"
    })), !t || !t.startsWith("co_z"))
      throw new Error(`[createAndPushMessage] Failed to get message schema co-id. Inbox schema items.$co: ${a?.items?.$co || "not found"}`);
  } catch (s) {
    throw new Error(`[createAndPushMessage] Failed to get message schema co-id: ${s.message}`);
  }
  const o = await oA(i.backend, t, { returnType: "schema" });
  if (!o)
    throw new Error(`[createAndPushMessage] Message schema not found: ${t}`);
  const g = {
    processed: !1,
    ...e
  };
  if (g.payload && _e(g.payload))
    throw new Error(`[createAndPushMessage] Payload contains unresolved expressions. Only resolved values can be persisted to CoJSON. Payload: ${JSON.stringify(g.payload).substring(0, 200)}`);
  await Fe(o, g, "createAndPushMessage");
  const r = await i.execute({
    op: "create",
    schema: t,
    data: g
  });
  if (!r || !r.id)
    throw new Error("[createAndPushMessage] Failed to create message CoMap - create operation returned no id");
  const n = r.id;
  if (!n.startsWith("co_z"))
    throw new Error(`[createAndPushMessage] Invalid message co-id returned: ${n}`);
  return await i.execute({
    op: "push",
    coId: A,
    item: n
    // Push co-id string, not plain object
  }), n;
}
async function ff(i, A, e) {
  if (!i || !A || !e)
    throw new Error("[processInbox] backend, actorId, and inboxCoId are required");
  if (!i.getCurrentSessionID())
    throw new Error("[processInbox] Cannot get current session ID from backend");
  const o = i.dbEngine;
  if (!o)
    throw new Error("[processInbox] Backend must have dbEngine set");
  let g = null;
  try {
    const a = (await o.execute({
      op: "schema",
      fromCoValue: e
    })).value;
    if (a && a.items && a.items.$co) {
      const I = a.items.$co;
      if (I.startsWith("co_z"))
        g = I;
      else if (I.startsWith("@schema/")) {
        const C = I.replace("@schema/", ""), Q = (await o.execute({
          op: "schema",
          schemaName: C
        })).value;
        Q && Q.$id ? g = Q.$id : console.warn(`[processInbox] Failed to resolve message schema reference ${I}`);
      } else
        console.warn(`[processInbox] Unknown message schema reference format: ${I}`);
    }
  } catch (s) {
    console.warn("[processInbox] Failed to get message schema:", s);
  }
  const r = i.readInboxWithSessions(e);
  if (!r || !r.sessions)
    return { messages: [] };
  const n = [];
  for (const [s, a] of Object.entries(r.sessions))
    for (const I of a) {
      if (I.type === "INIT" || I.from === "system")
        continue;
      const c = I._madeAt || 0, Q = I._coId;
      if (!Q) {
        console.error(
          `[processInbox]  REJECTED legacy plain object message in inbox ${e}. All messages must be CoMap references (co-id strings). Message data: ${JSON.stringify(I).substring(0, 200)}`
        );
        continue;
      }
      try {
        const d = await cA(i, Q, g);
        try {
          await YA(d, Q, 2e3);
        } catch (l) {
          console.warn(`[processInbox] Message CoMap not available: ${Q} - ${l.message}`);
          continue;
        }
        const f = d.value;
        if (!f || f.error) {
          console.warn(`[processInbox] Message CoMap error: ${Q} - ${f?.error || "unknown error"}`);
          continue;
        }
        if (!(f.processed === !0)) {
          try {
            await o.execute({
              op: "update",
              schema: g,
              id: Q,
              data: { processed: !0 }
            });
            try {
              const u = await cA(i, Q, g);
              await YA(u, Q, 1e3);
              const y = u.value;
              y && y.processed !== !0 && console.warn(`[processInbox] Update verification failed for ${Q} - processed flag is still false`);
            } catch (u) {
              console.warn(`[processInbox] Update verification failed for ${Q}:`, u.message);
            }
          } catch (u) {
            console.error(`[processInbox] Failed to mark message ${Q} as processed:`, u);
          }
          const l = {}, B = Object.keys(f);
          for (const u of B)
            u !== "processed" && !u.startsWith("_") && u !== "id" && u !== "$schema" && u !== "hasProperties" && u !== "properties" && (l[u] = f[u]);
          if (!l.type) {
            console.error(
              `[processInbox]  REJECTED message ${Q} - missing required 'type' field. Keys found: [${B.join(", ")}]. All values: ${JSON.stringify(f).substring(0, 300)}`
            );
            continue;
          }
          n.push({
            ...l,
            _coId: Q,
            // Keep co-id for reference
            _sessionID: s,
            _madeAt: c
          });
        }
      } catch (d) {
        console.error(`[processInbox] Failed to read message CoMap ${Q}:`, d);
      }
    }
  return n.sort((s, a) => (s._madeAt || 0) - (a._madeAt || 0)), {
    messages: n
  };
}
const wf = 1e5, yf = 10;
function Et(i) {
  return i.readyState === 1;
}
function Qg(i) {
  return i.bufferedAmount > wf && Et(i);
}
function pf(i) {
  return new Promise((A) => {
    i.readyState === 1 ? A() : i.addEventListener("open", () => A(), { once: !0 });
  });
}
async function Df(i) {
  for (; Qg(i); )
    await new Promise((A) => setTimeout(A, yf));
}
const { CO_VALUE_PRIORITY: mf, getContentMessageSize: Sf, WEBSOCKET_CONFIG: Hr } = Yg;
class Nf {
  constructor(A, e, t, o, g) {
    this.websocket = A, this.batching = e, this.meta = o, this.backlog = [], this.processing = !1, this.closed = !1, this.closeListeners = /* @__PURE__ */ new Set(), this.egressBytesCounter = (g ?? te.getMeter("cojson-transport-ws")).createCounter("jazz.usage.egress", {
      description: "Total egress bytes",
      unit: "bytes",
      valueType: qA.INT
    }), this.queue = new qc(mf.HIGH, "outgoing", {
      peerRole: t
    }), this.egressBytesCounter.add(0, this.meta);
  }
  push(A) {
    if (A === "Disconnected") {
      this.close();
      return;
    }
    if (!this.closed) {
      if (this.processing) {
        this.queue.push(A);
        return;
      }
      if (Et(this.websocket) && !Qg(this.websocket)) {
        this.processMessage(A, !0);
        return;
      }
      this.queue.push(A), this.processQueue().catch((e) => {
        Z.error("Error while processing sendMessage queue", { err: e });
      });
    }
  }
  async processQueue() {
    const { websocket: A } = this;
    this.processing = !0;
    let e = this.queue.pull();
    for (; e; ) {
      if (this.closed)
        return;
      Et(A) || await pf(A), Qg(A) && await Df(A), Et(A) && (this.processMessage(e), e = this.queue.pull());
    }
    this.sendMessagesInBulk(), this.processing = !1;
  }
  processMessage(A, e = !1) {
    A.action === "content" && this.egressBytesCounter.add(Sf(A), this.meta);
    const t = this.serializeMessage(A);
    if (!this.batching || e) {
      this.websocket.send(t);
      return;
    }
    const o = t.length, g = this.backlog.length + o;
    this.backlog.length > 0 && g > Hr.MAX_OUTGOING_MESSAGES_CHUNK_BYTES && this.sendMessagesInBulk(), this.appendMessage(t), o >= Hr.MAX_OUTGOING_MESSAGES_CHUNK_BYTES && this.sendMessagesInBulk();
  }
  serializeMessage(A) {
    return JSON.stringify(A);
  }
  appendMessage(A) {
    this.backlog.push(A);
  }
  sendMessagesInBulk() {
    this.backlog.length > 0 && Et(this.websocket) && (this.websocket.send(this.backlog.join(`
`)), this.backlog.length = 0);
  }
  drain() {
    for (; this.queue.pull(); )
      ;
  }
  setBatching(A) {
    this.batching = A;
  }
  onClose(A) {
    this.closeListeners.add(A);
  }
  close() {
    if (this.closed)
      return;
    let A = this.queue.pull();
    for (; A; )
      this.processMessage(A), A = this.queue.pull();
    this.closed = !0, this.sendMessagesInBulk();
    for (const e of this.closeListeners)
      e();
    this.closeListeners.clear();
  }
}
function Mf(i) {
  if (typeof i != "string")
    return {
      ok: !1,
      error: new Error("Expected a string")
    };
  try {
    return {
      ok: !0,
      messages: i.split(`
`).map((A) => JSON.parse(A))
    };
  } catch (A) {
    return Z.error("Error while deserializing messages", { err: A }), {
      ok: !1,
      error: A
    };
  }
}
const { ConnectedPeerChannel: Gf, getContentMessageSize: kf } = Yg;
function Ff(i, A, e) {
  if (!i)
    return {
      reset() {
      },
      clear() {
      }
    };
  let t = null;
  return {
    reset() {
      t && clearTimeout(t), t = setTimeout(() => {
        e();
      }, A);
    },
    clear() {
      t && clearTimeout(t);
    }
  };
}
function Rf(i = () => {
}) {
  let A = !1;
  return () => {
    A || (A = !0, i());
  };
}
function bf({ id: i, websocket: A, role: e, expectPings: t = !0, batchingByDefault: o = !0, deletePeerStateOnClose: g = !1, pingTimeout: r = 1e4, onSuccess: n, onClose: s, meter: a, meta: I }) {
  const C = (a ?? te.getMeter("cojson-transport-ws")).createCounter("jazz.usage.ingress", {
    description: "Total ingress bytes from peer",
    unit: "bytes",
    valueType: qA.INT
  });
  C.add(0, I);
  const c = new Gf(), Q = Rf(s);
  function d() {
    A.removeEventListener("message", y), A.removeEventListener("close", f), A.removeEventListener("error", h), l.clear(), B.drain();
  }
  function f() {
    c.push("Disconnected"), Q(), d();
  }
  function h(E) {
    E instanceof Error && E.message && Z.warn("WebSocket error", { err: E }), f();
  }
  A.addEventListener("close", f), A.addEventListener("error", h);
  const l = Ff(t, r, () => {
    f(), Z.warn("Ping timeout from peer", {
      peerId: i,
      peerRole: e
    });
  }), B = new Nf(A, o, e, I, a);
  let u = !0;
  function y(E) {
    if (l.reset(), E.data === "")
      return;
    const w = Mf(E.data);
    if (!w.ok) {
      Z.warn("Error while deserializing messages", { err: w.error });
      return;
    }
    u && (n?.(), u = !1);
    const { messages: p } = w;
    p.length > 1 && B.setBatching(!0);
    for (const N of p)
      N && "action" in N && (c.push(N), N.action === "content" && C.add(kf(N), I));
  }
  return A.addEventListener("message", y), B.onClose(() => {
    d(), Q(), A.readyState === 0 ? A.addEventListener("open", function() {
      A.close();
    }, { once: !0 }) : A.readyState === 1 && A.close();
  }), {
    id: i,
    incoming: c,
    outgoing: B,
    role: e,
    persistent: !g
  };
}
class Kf {
  constructor(A) {
    this.enabled = !1, this.closed = !0, this.connected = !1, this.currentPeer = void 0, this.unsubscribeNetworkChange = void 0, this.reconnectionAttempts = 0, this.onConnectionChangeListeners = /* @__PURE__ */ new Set(), this.waitUntilConnected = async () => {
      if (this.closed)
        return new Promise((e) => {
          const t = (o) => {
            o && (e(), this.onConnectionChangeListeners.delete(t));
          };
          this.onConnectionChangeListeners.add(t);
        });
    }, this.subscribe = (e) => {
      this.onConnectionChangeListeners.add(e), e(!this.closed);
    }, this.unsubscribe = (e) => {
      this.onConnectionChangeListeners.delete(e);
    }, this.startConnection = async () => {
      if (this.enabled) {
        if (this.currentPeer) {
          this.removePeer(this.currentPeer), this.currentPeer.outgoing.close(), this.reconnectionAttempts++;
          const e = this.reconnectionTimeout * this.reconnectionAttempts;
          Z.debug(`Websocket disconnected, trying to reconnect in ${e}ms`), await this.waitForOnline(e);
        }
        this.enabled && (this.currentPeer = bf({
          websocket: new this.WebSocketConstructor(this.peer),
          pingTimeout: this.pingTimeout,
          id: this.peer,
          role: "server",
          onClose: () => {
            this.closed = !0, this.connected = !1;
            for (const e of this.onConnectionChangeListeners)
              e(!1);
            this.startConnection();
          },
          onSuccess: () => {
            this.closed = !1, this.connected = !0;
            for (const e of this.onConnectionChangeListeners)
              e(!0);
            Z.debug("Websocket connection successful"), this.reconnectionAttempts = 0;
          }
        }), this.addPeer(this.currentPeer));
      }
    }, this.enable = () => {
      this.enabled || (this.connected = !0, this.enabled = !0, this.startConnection());
    }, this.disable = () => {
      this.enabled && (this.enabled = !1, this.reconnectionAttempts = 0, this.unsubscribeNetworkChange?.(), this.unsubscribeNetworkChange = void 0, this.currentPeer && (this.removePeer(this.currentPeer), this.currentPeer.outgoing.close(), this.currentPeer = void 0));
    }, this.peer = A.peer, this.reconnectionTimeout = A.reconnectionTimeout || 500, this.addPeer = A.addPeer, this.removePeer = A.removePeer, this.WebSocketConstructor = A.WebSocketConstructor || WebSocket, this.pingTimeout = A.pingTimeout || 1e4;
  }
  // Basic implementation for environments that don't support network change events (e.g. Node.js)
  // Needs to be extended to handle platform specific APIs
  onNetworkChange(A) {
    return () => {
    };
  }
  waitForOnline(A) {
    return new Promise((e) => {
      const t = this.onNetworkChange((r) => {
        r && o();
      });
      function o() {
        clearTimeout(g), t?.(), e();
      }
      const g = setTimeout(o, A);
    });
  }
}
const qr = {};
let re = {
  connected: !1,
  syncing: !1,
  error: null,
  status: null
  // 'authenticating' | 'loading-account' | 'syncing' | 'connected' | 'error'
};
const Eg = /* @__PURE__ */ new Set();
function Yf(i) {
  return Eg.add(i), i(re), () => Eg.delete(i);
}
function xt() {
  for (const i of Eg)
    i(re);
}
function Yt(i = null) {
  const A = typeof window < "u" && window.location.hostname === "localhost", e = i || typeof window < "u" && window.__PUBLIC_API_DOMAIN__ || qr?.PUBLIC_API_DOMAIN || typeof process < "u" && process.env?.PUBLIC_API_DOMAIN;
  let t;
  if (typeof window > "u") {
    if (!i)
      return { peers: [], setNode: () => {
      }, wsPeer: null };
    t = `${i.includes("localhost") || i.includes("127.0.0.1") ? "ws:" : "wss:"}//${i}/sync`;
  } else A ? t = `${window.location.protocol === "https:" ? "wss:" : "ws:"}//${window.location.host}/sync` : e ? t = `${window.location.protocol === "https:" ? "wss:" : "ws:"}//${e}/sync` : (console.warn(" [SYNC] Sync domain not set! Falling back to same origin. Sync may not work."), t = `${window.location.protocol === "https:" ? "wss:" : "ws:"}//${window.location.host}/sync`);
  A || (console.log(`   Sync Domain: ${e || "(not set - using same origin fallback)"}`), console.log(`   Source: ${i ? "kernel" : typeof window < "u" && window.__PUBLIC_API_DOMAIN__ ? "runtime env" : qr?.PUBLIC_API_DOMAIN ? "build-time env" : "fallback"}`));
  let o;
  const g = [];
  let r = null, n = !1, s = null;
  const a = new Promise((C) => {
    s = C;
  });
  if (!t)
    return { peers: [], setNode: () => {
    }, wsPeer: null };
  const I = new Kf({
    peer: t,
    reconnectionTimeout: 5e3,
    addPeer: (C) => {
      r && (clearTimeout(r), r = null), g.push(C), o && o.syncManager.addPeer(C);
    },
    removePeer: (C) => {
      const c = g.indexOf(C);
      c > -1 && g.splice(c, 1), re.connected && console.warn(" [SYNC] Peer removed, connection lost"), n = !1, re = { connected: !1, syncing: !1, error: "Disconnected", status: "error" }, xt();
    }
  });
  return I.subscribe((C) => {
    C && !n ? (n = !0, re = { connected: !0, syncing: !0, error: null, status: "syncing" }, xt(), s && (s(), s = null)) : !C && n && (console.warn(" [SYNC] WebSocket connection lost"), n = !1, re = { connected: !1, syncing: !1, error: "Offline", status: "error" }, xt());
  }), typeof window < "u" && (r = setTimeout(() => {
    re.connected || (console.error(" [SYNC] Connection timeout after 10s. Check:"), console.error(`   1. Sync service is running: curl https://${e || window.location.hostname}/health`), console.error(`   2. PUBLIC_API_DOMAIN is set correctly: ${e || "NOT SET"}`), console.error(`   3. WebSocket URL: ${t}`), re = { connected: !1, syncing: !1, error: "Connection timeout", status: "error" }, xt());
  }, 1e4)), I.enable(), {
    peers: g,
    wsPeer: I,
    // Wait for WebSocket to be actually connected (not just peer object created)
    waitForPeer: () => new Promise((C) => {
      if (n && g.length > 0) {
        C(!0);
        return;
      }
      let c = !1;
      const Q = setTimeout(() => {
        c || (c = !0, C(!1));
      }, 2e3);
      a.then(() => {
        !c && g.length > 0 && (c = !0, clearTimeout(Q), C(!0));
      }).catch(() => {
        c || (c = !0, clearTimeout(Q), C(!1));
      });
    }),
    setNode: (C) => {
      if (o = C, g.length > 0)
        for (const c of g)
          o.syncManager.addPeer(c);
    }
  };
}
const so = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CoCache: eg,
  CoJSONBackend: _g,
  checkCotype: xi,
  createAccountWithSecret: Vg,
  createAndPushMessage: Bg,
  createCoJSONAPI: uf,
  createCoList: pa,
  createCoMap: ya,
  createCoStream: Da,
  createSchemaMeta: Xe,
  ensureCoValueLoaded: IA,
  getAllSchemas: go,
  getCoListId: Ug,
  getGlobalCoCache: na,
  getSchema: Ca,
  getSchemaIndexColistId: ra,
  loadAccount: Wg,
  processInbox: ff,
  resolve: oA,
  resolveCoValueReactive: ig,
  resolveQueryReactive: aa,
  resolveReactive: ee,
  resolveSchemaReactive: ft,
  schemaMigration: Lg,
  setupSyncPeers: Yt,
  subscribeSyncState: Yf,
  waitForReactiveResolution: fe
}, Symbol.toStringTag, { value: "Module" })), lA = {
  INITIALIZING: "initializing",
  // Setting up subscriptions, loading initial data
  RENDERING: "rendering",
  // Currently rendering (prevents nested renders)
  READY: "ready",
  // Initial render complete, ready for updates
  UPDATING: "updating"
  // Data changed, queued for rerender
};
class vf {
  constructor(A, e, t, o, g = null) {
    this.styleEngine = A, this.viewEngine = e, this.registry = t, this.toolEngine = o, this.stateEngine = g, this.actors = /* @__PURE__ */ new Map(), this.pendingMessages = /* @__PURE__ */ new Map(), this.dbEngine = null, this.os = null, this._containerActors = /* @__PURE__ */ new Map(), this._vibeActors = /* @__PURE__ */ new Map(), this.viewEngine.setActorEngine(this), this.pendingRerenders = /* @__PURE__ */ new Set(), this.batchTimer = null;
  }
  async updateContextCoValue(A, e) {
    if (!A.contextCoId || !this.dbEngine) {
      A.contextCoId || console.warn(`[ActorEngine] Actor ${A.id} has no contextCoId`);
      return;
    }
    const t = A.contextSchemaCoId || await oA(this.dbEngine.backend, { fromCoValue: A.contextCoId }, { returnType: "coId" }), o = {};
    for (const [g, r] of Object.entries(e))
      o[g] = r === void 0 ? null : r;
    await this.dbEngine.execute({
      op: "update",
      schema: t,
      id: A.contextCoId,
      data: o
    });
  }
  async _loadActorConfigs(A) {
    if (!A.view) throw new Error("[ActorEngine] Actor config must have 'view' property");
    const e = A.id || "temp", t = ee(this.dbEngine.backend, { fromCoValue: A.view }, { returnType: "coId" }), o = await fe(t, { timeoutMs: 1e4 }), g = o.schemaCoId;
    if (!g)
      throw new Error(`[ActorEngine] Failed to extract schema co-id from view CoValue ${A.view}: ${o.error || "Schema not found"}`);
    await this.dbEngine.execute({ op: "read", schema: null, key: A.view });
    const r = await this.dbEngine.execute({ op: "read", schema: g, key: A.view }), n = r.value;
    r.subscribe((B) => {
      const u = this.actors.get(e);
      u && (u.viewDef = B, u._renderState === lA.READY && (u._renderState = lA.UPDATING, this._scheduleRerender(u.id)));
    }, { skipInitial: !0 });
    const s = [];
    let a = null;
    A.context && (a = (async () => {
      const B = A.context;
      let u = B;
      if (typeof B == "string" && !B.startsWith("co_z")) {
        const w = await this.dbEngine.execute({ op: "resolve", humanReadableKey: B });
        if (w && w.startsWith("co_z"))
          u = w;
        else
          throw new Error(`[ActorEngine] Failed to resolve context reference "${B}"`);
      }
      const y = await oA(this.dbEngine.backend, { fromCoValue: u }, { returnType: "coId" }), E = await this.dbEngine.execute({
        op: "read",
        schema: y,
        key: u
      });
      return { context: E, contextCoId: u, contextSchemaCoId: y, store: E };
    })(), s.push(a));
    let I = null, C = null;
    A.style && (I = (async () => {
      try {
        const B = await oA(this.dbEngine.backend, { fromCoValue: A.style }, { returnType: "coId" }), u = await this.dbEngine.execute({ op: "read", schema: B, key: A.style });
        return u.subscribe(async (y) => {
          const E = this.actors.get(e);
          if (E && this.styleEngine)
            try {
              const w = await this.styleEngine.getStyleSheets(E.config, E.id);
              E.shadowRoot.adoptedStyleSheets = w, E._renderState === lA.READY && (E._renderState = lA.UPDATING, this._scheduleRerender(E.id));
            } catch (w) {
              console.error("[ActorEngine] Failed to update stylesheets after style change:", w);
            }
        }, { skipInitial: !0 }), u;
      } catch (B) {
        return console.error("[ActorEngine] Failed to load style:", B), null;
      }
    })(), s.push(I)), A.brand && (C = (async () => {
      try {
        const B = await oA(this.dbEngine.backend, { fromCoValue: A.brand }, { returnType: "coId" }), u = await this.dbEngine.execute({ op: "read", schema: B, key: A.brand });
        return u.subscribe(async (y) => {
          const E = this.actors.get(e);
          if (E && this.styleEngine)
            try {
              const w = await this.styleEngine.getStyleSheets(E.config, E.id);
              E.shadowRoot.adoptedStyleSheets = w, E._renderState === lA.READY && (E._renderState = lA.UPDATING, this._scheduleRerender(E.id));
            } catch (w) {
              console.error("[ActorEngine] Failed to update stylesheets after brand change:", w);
            }
        }, { skipInitial: !0 }), u;
      } catch (B) {
        return console.error("[ActorEngine] Failed to load brand:", B), null;
      }
    })(), s.push(C));
    let c = null;
    A.inbox && (c = (async () => {
      const B = await oA(this.dbEngine.backend, { fromCoValue: A.inbox }, { returnType: "coId" });
      return await this.dbEngine.execute({ op: "read", schema: B, key: A.inbox });
    })(), s.push(c)), await Promise.all(s);
    let Q = null, d = null, f = null;
    if (a) {
      const B = await a;
      Q = B.store, d = B.contextCoId, f = B.contextSchemaCoId;
    }
    let h = null, l = null;
    return c && (l = A.inbox, h = await c), { viewDef: n, context: Q, contextCoId: d, contextSchemaCoId: f, inbox: h, inboxCoId: l };
  }
  /**
   * Set up reactive subscriptions for inbox costream
   * @param {Object} actor - Actor instance
   * @param {Object} actorConfig - The actor configuration
   * @returns {Promise<void>}
   * @private
   */
  async _setupMessageSubscriptions(A, e) {
    if (e.inbox)
      try {
        const t = await oA(this.dbEngine.backend, { fromCoValue: e.inbox }, { returnType: "coId" });
        (await this.dbEngine.execute({
          op: "read",
          schema: t,
          key: e.inbox
        })).subscribe((g) => {
          this.actors.has(A.id) && g?.items && this.processMessages(A.id);
        });
      } catch (t) {
        console.error("[ActorEngine] Failed to subscribe to inbox:", t);
      }
  }
  /**
   * Initialize actor state (state machine)
   * @param {Object} actor - Actor instance
   * @param {Object} actorConfig - The actor configuration
   * @returns {Promise<void>}
   * @private
   */
  async _initializeActorState(A, e) {
    if (this.stateEngine && e.state && !A.machine)
      try {
        const t = ee(this.dbEngine.backend, { fromCoValue: e.state }, { returnType: "coId" }), o = await fe(t, { timeoutMs: 1e4 }), g = o.schemaCoId;
        if (!g)
          throw new Error(`[ActorEngine] Failed to extract schema co-id from state CoValue ${e.state}: ${o.error || "Schema not found"}`);
        const r = await this.dbEngine.execute({
          op: "read",
          schema: g,
          key: e.state
        }), n = r.value, s = A.id;
        r.subscribe(async (a) => {
          const I = this.actors.get(s);
          if (I && this.stateEngine)
            try {
              I.machine && this.stateEngine.destroyMachine(I.machine.id), I.machine = await this.stateEngine.createMachine(a, I), I._renderState === lA.READY && (I._renderState = lA.UPDATING, this._scheduleRerender(s));
            } catch (C) {
              console.error("[ActorEngine] Failed to update state machine:", C);
            }
        }, { skipInitial: !0 }), A.machine = await this.stateEngine.createMachine(n, A);
      } catch (t) {
        console.error("[ActorEngine] Failed to load state machine:", t);
      }
  }
  // Query resolution handled by backend unified store automatically
  /**
   * Determine if an actor is a service actor (orchestrator) vs UI actor (presentation)
   * Service actors: Have role "agent" OR have minimal view (only renders child actors via $slot)
   * UI actors: Have full view (render actual UI components)
   * @param {Object} actorConfig - Actor configuration
   * @param {Object} viewDef - View definition (optional, will be loaded if not provided)
   * @returns {Promise<boolean>} True if service actor, false if UI actor
   * @private
   */
  async _isServiceActor(A, e = null) {
    if (A.role === "agent" || !A.view) return !0;
    if (!e)
      try {
        try {
          const g = ee(this.dbEngine.backend, { fromCoValue: A.view }, { returnType: "coId" });
          if (!(await fe(g, { timeoutMs: 1e4 })).schemaCoId)
            return !1;
        } catch {
          return !1;
        }
        e = (await this.dbEngine.execute({ op: "read", schema: viewSchemaCoId, key: A.view })).value;
      } catch {
        return !1;
      }
    const t = e.content || e.root || e;
    return !t || t.$slot && !t.children || t.children?.every((o) => o.$slot || o.children?.every((g) => g.$slot)) ? !0 : !(t.tag && (t.text || t.value || t.$on || t.children?.some((o) => o.tag && (o.text || o.value || o.$on))));
  }
  /**
   * Create a child actor lazily if it doesn't exist yet
   * Only creates the child actor when it's actually needed (referenced by context.currentView)
   * @param {Object} actor - Parent actor instance
   * @param {string} namekey - Child actor namekey (e.g., "list", "kanban")
   * @param {string} [vibeKey] - Optional vibe key for tracking child actors
   * @returns {Promise<Object|null>} The child actor instance, or null if not found/created
   * @private
   */
  async _createChildActorIfNeeded(A, e, t = null) {
    if (A.children?.[e]) return A.children[e];
    A.children || (A.children = {});
    const o = A.context.value;
    if (!o["@actors"]?.[e]) return null;
    const g = o["@actors"][e];
    if (!g.startsWith("co_z"))
      throw new Error(`[ActorEngine] Child actor ID must be co-id: ${g}`);
    try {
      const r = ee(this.dbEngine.backend, { fromCoValue: g }, { returnType: "coId" }), n = await fe(r, { timeoutMs: 1e4 }), s = n.schemaCoId;
      if (!s)
        throw new Error(`[ActorEngine] Failed to extract schema co-id from child actor CoValue ${g}: ${n.error || "Schema not found"}`);
      const I = (await this.dbEngine.execute({ op: "read", schema: s, key: g })).value;
      I.$id !== g && (I.$id = g);
      const C = document.createElement("div");
      C.dataset.namekey = e, C.dataset.childActorId = g;
      const c = await this.createActor(I, C, t);
      return c.namekey = e, A.children[e] = c, c;
    } catch (r) {
      return console.error("[ActorEngine] Failed to create child actor:", r), null;
    }
  }
  async createActor(A, e, t = null) {
    const o = A.$id || A.id;
    if (this.actors.has(o))
      return t ? await this.reuseActor(o, e, t) : this.actors.get(o);
    const g = e.attachShadow({ mode: "open" }), r = await this.styleEngine.getStyleSheets(A, o), { viewDef: n, context: s, contextCoId: a, contextSchemaCoId: I, inbox: C, inboxCoId: c, tempSubscriptions: Q } = await this._loadActorConfigs(A), d = await this._isServiceActor(A, n) ? "service" : "ui", f = {
      id: o,
      config: A,
      shadowRoot: g,
      context: s,
      contextCoId: a,
      contextSchemaCoId: I,
      containerElement: e,
      actorEngine: this,
      viewDef: n,
      actorType: d,
      vibeKey: t,
      inbox: C,
      inboxCoId: c,
      messageTypes: A.messageTypes || null,
      // REQUIRED: Message types this actor accepts
      _renderState: lA.INITIALIZING,
      // Start in INITIALIZING state
      children: {}
    };
    if (await this._setupMessageSubscriptions(f, A), this.actors.set(o, f), f.context && typeof f.context.subscribe == "function") {
      let h = JSON.stringify(f.context.value || {});
      f._contextUnsubscribe = f.context.subscribe((l) => {
        const B = JSON.stringify(l || {}), u = B !== h;
        h = B, f._renderState === lA.READY && u && (f._renderState = lA.UPDATING, this._scheduleRerender(o));
      }, { skipInitial: !0 });
    }
    if (e && (this._containerActors.has(e) || this._containerActors.set(e, /* @__PURE__ */ new Set()), this._containerActors.get(e).add(o)), t && this.registerActorForVibe(o, t), await this._initializeActorState(f, A), f._renderState = lA.RENDERING, await this.viewEngine.render(n, f.context, g, r, o), f._renderState = lA.READY, f._needsPostInitRerender && (delete f._needsPostInitRerender, this._scheduleRerender(o)), this.pendingMessages.has(o)) {
      for (const h of this.pendingMessages.get(o))
        await this.sendMessage(o, h);
      this.pendingMessages.delete(o);
    }
    return f;
  }
  /**
   * Schedule a rerender for an actor (batched via microtask queue)
   * Following Svelte's batching pattern: multiple updates in same tick = one rerender
   * CRITICAL: Set-based deduplication ensures each actor only rerenders once per batch
   * This prevents doubled rendering when multiple subscriptions fire simultaneously
   * @param {string} actorId - The actor ID to rerender
   */
  _scheduleRerender(A) {
    this.pendingRerenders.add(A), this.batchTimer || (this.batchTimer = queueMicrotask(async () => {
      this.batchTimer = null, await this._flushRerenders();
    }));
  }
  /**
   * Flush all pending rerenders in batch
   * Processes all actors that need rerendering in one microtask
   * CRITICAL: Set-based deduplication ensures each actor only rerenders once
   * This prevents doubled rendering when multiple subscriptions fire simultaneously
   */
  async _flushRerenders() {
    const A = Array.from(this.pendingRerenders);
    this.pendingRerenders.clear(), await Promise.all(A.map((e) => this.rerender(e)));
  }
  /**
   * Rerender an actor (private implementation - only called by _flushRerenders)
   * @param {string} actorId - The actor ID to rerender
   * @private
   */
  async rerender(A) {
    const e = this.actors.get(A);
    if (!e) {
      console.warn(`[ActorEngine] rerender called for non-existent actor: ${A}`);
      return;
    }
    if (e._renderState !== lA.UPDATING && e._renderState !== lA.READY)
      return;
    e._renderState = lA.RENDERING;
    const t = ee(this.dbEngine.backend, { fromCoValue: e.config.view }, { returnType: "coId" }), o = await fe(t, { timeoutMs: 1e4 }), g = o.schemaCoId;
    if (!g)
      throw new Error(`[ActorEngine] Failed to extract schema co-id from view CoValue ${e.config.view}: ${o.error || "Schema not found"}`);
    const n = (await this.dbEngine.execute({ op: "read", schema: g, key: e.config.view })).value, s = await this.styleEngine.getStyleSheets(e.config, A);
    await this.viewEngine.render(n, e.context, e.shadowRoot, s, A), e._renderState = lA.READY;
  }
  /**
   * Get actor by ID
   * @param {string} actorId - The actor ID
   * @returns {Object|undefined} The actor instance
   */
  getActor(A) {
    return this.actors.get(A);
  }
  /**
   * Register an actor with a vibe key for reuse tracking
   * @param {string} actorId - The actor ID
   * @param {string} vibeKey - The vibe key (e.g., 'todos')
   */
  registerActorForVibe(A, e) {
    e && (this._vibeActors.has(e) || this._vibeActors.set(e, /* @__PURE__ */ new Set()), this._vibeActors.get(e).add(A));
  }
  /**
   * Get all actors for a vibe
   * @param {string} vibeKey - The vibe key (e.g., 'todos')
   * @returns {Set<string>|undefined} Set of actor IDs for the vibe
   */
  getActorsForVibe(A) {
    return this._vibeActors.get(A);
  }
  /**
   * Reuse an existing actor by reattaching it to a new container
   * @param {string} actorId - The actor ID
   * @param {HTMLElement} containerElement - The new container to attach to
   * @param {string} vibeKey - The vibe key (e.g., 'todos')
   * @returns {Promise<Object>} The reused actor instance
   */
  async reuseActor(A, e, t) {
    const o = this.actors.get(A);
    if (!o) throw new Error(`[ActorEngine] Cannot reuse actor ${A}`);
    const g = o.containerElement;
    if (o.containerElement = e, g && this._containerActors.has(g)) {
      const r = this._containerActors.get(g);
      r.delete(A), r.size === 0 && this._containerActors.delete(g);
    }
    if (e && (this._containerActors.has(e) || this._containerActors.set(e, /* @__PURE__ */ new Set()), this._containerActors.get(e).add(A)), this.registerActorForVibe(A, t), o.shadowRoot) {
      const r = o.shadowRoot.host;
      r && r !== e && (r.parentNode && r.parentNode.removeChild(r), e.appendChild(r));
    } else
      o.shadowRoot = e.attachShadow({ mode: "open" });
    return o._initialRenderComplete && this._scheduleRerender(A), o;
  }
  /**
   * Destroy an actor
   * @param {string} actorId - The actor ID
   */
  destroyActor(A) {
    const e = this.actors.get(A);
    if (e) {
      if (e.shadowRoot.innerHTML = "", this.viewEngine && this.viewEngine.cleanupActor(A), e._contextUnsubscribe && typeof e._contextUnsubscribe == "function" && (e._contextUnsubscribe(), delete e._contextUnsubscribe), e.machine && this.stateEngine && this.stateEngine.destroyMachine(e.machine.id), e._processedMessageKeys && (e._processedMessageKeys.clear(), delete e._processedMessageKeys), e.containerElement && this._containerActors.has(e.containerElement)) {
        const t = this._containerActors.get(e.containerElement);
        t.delete(A), t.size === 0 && this._containerActors.delete(e.containerElement);
      }
      for (const [t, o] of this._vibeActors.entries())
        if (o.has(A)) {
          o.delete(A), o.size === 0 && this._vibeActors.delete(t);
          break;
        }
      this.actors.delete(A);
    }
  }
  /**
   * Destroy all actors for a given container
   * Used when unloading a vibe to clean up all actors associated with that container
   * @param {HTMLElement} containerElement - The container element
   */
  destroyActorsForContainer(A) {
    const e = this._containerActors.get(A);
    if (e?.size) {
      for (const t of Array.from(e))
        this.destroyActor(t);
      this._containerActors.delete(A);
    }
  }
  /**
   * Detach all actors for a vibe (hide UI, keep actors alive)
   * Used when navigating away from a vibe - preserves actors for reuse
   * @param {string} vibeKey - The vibe key (e.g., 'todos')
   */
  detachActorsForVibe(A) {
    const e = this._vibeActors.get(A);
    if (e?.size)
      for (const t of e) {
        const o = this.actors.get(t);
        if (o?.shadowRoot?.host?.parentNode && o.shadowRoot.host.parentNode.removeChild(o.shadowRoot.host), o?.containerElement && this._containerActors.has(o.containerElement)) {
          const g = this._containerActors.get(o.containerElement);
          g.delete(t), g.size === 0 && this._containerActors.delete(o.containerElement);
        }
      }
  }
  /**
   * Reattach all actors for a vibe to a new container
   * Used when navigating back to a vibe - reuses existing actors
   * @param {string} vibeKey - The vibe key (e.g., 'todos')
   * @param {HTMLElement} containerElement - The container element for the root actor
   * @returns {Promise<Object|undefined>} The root actor instance, or undefined if no actors found
   */
  async reattachActorsForVibe(A, e) {
    const t = this._vibeActors.get(A);
    if (!A || !e || !t?.size) return;
    const o = Array.from(t)[0], g = this.actors.get(o);
    if (g)
      return await this.reuseActor(o, e, A), g;
  }
  /**
   * Destroy all actors for a vibe (complete cleanup)
   * Used for explicit cleanup when needed (e.g., app shutdown)
   * @param {string} vibeKey - The vibe key (e.g., 'todos')
   */
  destroyActorsForVibe(A) {
    const e = this._vibeActors.get(A);
    if (!(!A || !e?.size)) {
      for (const t of Array.from(e))
        this.destroyActor(t);
      this._vibeActors.delete(A);
    }
  }
  // ============================================
  // MESSAGE PASSING SYSTEM (v0.2)
  // ============================================
  /**
   * Send a message to an actor's inbox
   * CRDT handles persistence and sync automatically - no MessageQueue needed
   * @param {string} actorId - Target actor ID
   * @param {Object} message - Message object { type, payload, from, timestamp }
   */
  async sendMessage(A, e) {
    if (e.payload && _e(e.payload))
      throw new Error(`[ActorEngine] Message payload contains unresolved expressions. Only resolved values can be sent between actors. Payload: ${JSON.stringify(e.payload).substring(0, 200)}`);
    const t = this.actors.get(A);
    if (!t) {
      this.pendingMessages.has(A) || this.pendingMessages.set(A, []);
      const o = this.pendingMessages.get(A), g = e.id || `${e.type}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      o.some((r) => r.id === g || !r.id && !e.id && r.type === e.type) || o.push(e);
      return;
    }
    if (t.inboxCoId && this.dbEngine)
      try {
        const o = {
          type: e.type,
          payload: e.payload || {},
          source: e.from || e.source,
          target: A,
          processed: !1
        };
        await Bg(this.dbEngine, t.inboxCoId, o);
      } catch (o) {
        console.error("[ActorEngine] Failed to send message:", o);
      }
  }
  async sendInternalEvent(A, e, t = {}) {
    if (_e(t))
      throw new Error(`[ActorEngine] Payload contains unresolved expressions. Views must resolve all expressions before sending to inbox. Payload: ${JSON.stringify(t).substring(0, 200)}`);
    const o = this.actors.get(A);
    if (!o || !o.inboxCoId || !this.dbEngine) {
      console.warn("[ActorEngine] Cannot send internal event:", {
        hasActor: !!o,
        hasInboxCoId: !!o?.inboxCoId,
        hasDbEngine: !!this.dbEngine
      });
      return;
    }
    try {
      await Bg(this.dbEngine, o.inboxCoId, {
        type: e,
        payload: t,
        source: A,
        target: A,
        processed: !1
      }), setTimeout(() => {
        this.processMessages(A).catch((g) => {
          console.error("[ActorEngine] Error processing deferred messages:", g);
        });
      }, 0);
    } catch (g) {
      console.error("[ActorEngine] Failed to send internal event:", g);
    }
  }
  /**
   * Validate message type against actor's message contract
   * @param {Object} actor - Actor instance
   * @param {string} messageType - Message type to validate
   * @returns {boolean} True if message type is accepted, false otherwise
   */
  _validateMessageType(A, e) {
    return !A.messageTypes || !Array.isArray(A.messageTypes) ? (console.error(`[ActorEngine] Actor "${A.id}" missing required "messageTypes" array. All actors must declare their message contracts.`), !1) : A.messageTypes.includes(e) ? !0 : (console.error(`[ActorEngine] Message type "${e}" not in actor's message contract. Actor: ${A.id}, Accepted types: ${A.messageTypes.join(", ")}`), !1);
  }
  /**
   * Load message type schema from registry
   * @param {string} messageType - Message type name (e.g., 'CREATE_BUTTON')
   * @returns {Promise<Object|null>} Message type schema or null if not found
   */
  async _loadMessageTypeSchema(A) {
    if (!this.dbEngine || !this.dbEngine.backend)
      return console.warn("[ActorEngine] Cannot load message type schema: dbEngine not available"), null;
    try {
      const e = `@schema/message/${A}`;
      return await oA(this.dbEngine.backend, e, { returnType: "schema" });
    } catch (e) {
      return console.error(`[ActorEngine] Message type schema not found for "${A}". All message types must have schemas registered.`, e), null;
    }
  }
  /**
   * Validate message payload against message type schema
   * Message type schema IS the payload schema (merged concept)
   * @param {Object} messageTypeSchema - Message type schema definition (this IS the payload schema)
   * @param {Object} payload - Message payload to validate
   * @param {string} messageType - Message type name (for error messages)
   * @returns {Promise<{valid: boolean, errors: Array|null}>} Validation result
   */
  async _validateMessagePayload(A, e, t) {
    if (!A)
      return { valid: !1, errors: [`Message type schema is required for ${t}`] };
    try {
      const { groupInfo: o, ...g } = A;
      return await bt(g, e || {}, `message payload for ${t}`);
    } catch (o) {
      return console.error(`[ActorEngine] Error validating message payload for ${t}:`, o), { valid: !1, errors: [o.message] };
    }
  }
  async processMessages(A) {
    const e = this.actors.get(A);
    if (!(!e || !e.inboxCoId || !this.dbEngine || e._isProcessing)) {
      e._isProcessing = !0;
      try {
        const o = (await this.dbEngine.execute({ op: "processInbox", actorId: A, inboxCoId: e.inboxCoId })).messages || [];
        for (const g of o)
          if (!(g.type === "INIT" || g.from === "system"))
            try {
              if (!this._validateMessageType(e, g.type)) {
                console.error(`[ActorEngine] Message type "${g.type}" rejected by actor "${A}" - not in message contract`);
                continue;
              }
              const r = await this._loadMessageTypeSchema(g.type);
              if (!r) {
                console.error(`[ActorEngine] Message type schema not found for "${g.type}". All message types must have schemas registered.`);
                continue;
              }
              const n = g.payload || {}, s = await this._validateMessagePayload(r, n, g.type);
              if (!s.valid) {
                const a = s.errors?.map((I) => `  - ${I.instancePath || I.path || "root"}: ${I.message || I}`).join(`
`) || "Unknown validation error";
                console.error(`[ActorEngine] Message payload validation failed for "${g.type}":
${a}
Payload:`, JSON.stringify(n, null, 2));
                continue;
              }
              e.machine && this.stateEngine ? await this.stateEngine.send(e.machine.id, g.type, n) : console.error(`[ActorEngine] Actor ${A} has no state machine. All actors must have state machines. Message type: ${g.type}`);
            } catch (r) {
              console.error("[ActorEngine] Failed to process message:", r);
            }
      } catch (t) {
        console.error("[ActorEngine] Error processing messages:", t);
      } finally {
        e._isProcessing = !1;
      }
    }
  }
}
function lg(i, A) {
  if (!i || typeof i != "object")
    return i;
  if (Array.isArray(i))
    return i.map((t) => lg(t, A));
  const e = {};
  for (const [t, o] of Object.entries(i))
    o === "@inputValue" ? e[t] = A.value || "" : o === "@dataColumn" ? e[t] = A.dataset.column || A.getAttribute("data-column") || null : typeof o == "object" && o !== null ? e[t] = lg(o, A) : e[t] = o;
  return e;
}
function Uf(i) {
  return i == null ? "" : String(i).replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;").replace(/\//g, "&#x2F;");
}
function Jf(i) {
  return typeof i != "string" ? !1 : [/<script/i, /javascript:/i, /on\w+\s*=/i, /<iframe/i, /<object/i, /<embed/i, /<link/i, /<meta/i, /<style/i].some((A) => A.test(i));
}
class Hf {
  constructor(A, e, t) {
    this.evaluator = A, this.actorEngine = e, this.moduleRegistry = t, this.dbEngine = null, this.actorInputCounters = /* @__PURE__ */ new Map();
  }
  async loadView(A) {
    const e = ee(this.dbEngine.backend, { fromCoValue: A }, { returnType: "coId" }), t = await fe(e, { timeoutMs: 1e4 }), o = t.schemaCoId;
    if (!o)
      throw new Error(`[ViewEngine] Failed to extract schema co-id from view CoValue ${A}: ${t.error || "Schema not found"}`);
    return await this.dbEngine.execute({
      op: "read",
      schema: null,
      key: A
    }), await this.dbEngine.execute({
      op: "read",
      schema: o,
      key: A
    });
  }
  async render(A, e, t, o, g) {
    this.actorInputCounters.set(g, 0), t.innerHTML = "", t.adoptedStyleSheets = o, this.currentActorId = g;
    const r = A.content || A;
    if (!e) {
      console.error(`[ViewEngine] Context is null/undefined for actor ${g}`);
      return;
    }
    const n = e.value || {}, s = await this.renderNode(r, { context: n }, g);
    s ? (s.dataset.actorId = g, t.appendChild(s)) : console.error(`[ViewEngine.render] renderNode returned null for actor ${g}`, {
      viewNode: r ? { tag: r.tag, hasContent: !!r.content } : null,
      contextKeys: Object.keys(n)
    });
  }
  async renderNode(A, e, t) {
    if (!A) return null;
    const o = A.tag || "div", g = document.createElement(o);
    if (await this._applyNodeAttributes(g, A, e, t), A.$each) {
      g.innerHTML = "";
      const r = await this.renderEach(A.$each, e, t);
      g.appendChild(r);
    }
    if (A.$on && this.attachEvents(g, A.$on, e, t), A.$slot)
      return await this._renderSlot(A, e, g, t), g;
    if (A.slot)
      throw new Error('[ViewEngine] Old "slot" syntax is no longer supported. Use "$slot" instead.');
    return A.$each || await this._renderNodeChildren(g, A, e, t), g;
  }
  async _applyNodeAttributes(A, e, t, o) {
    if (e.class) {
      if (typeof e.class == "object" && this._isDSLOperation(e.class)) {
        const r = Object.keys(e.class)[0];
        throw new Error(`[ViewEngine] Conditional logic (${r}) is not allowed in class property. Use state machines to compute boolean flags and reference them via context, then use data-attributes and CSS.`);
      }
      if (typeof e.class == "string" && e.class.includes("?") && e.class.includes(":"))
        throw new Error("[ViewEngine] Ternary operators are not allowed in class property. Use state machines to compute values and reference them via context.");
      const g = await this.evaluator.evaluate(e.class, t);
      g && (A.className = g);
    }
    if (e.attrs)
      for (const [g, r] of Object.entries(e.attrs))
        if (g === "data")
          await this._resolveDataAttributes(r, t, A);
        else {
          if (typeof r == "object" && this._isDSLOperation(r)) {
            const s = Object.keys(r)[0];
            throw new Error(`[ViewEngine] Conditional logic (${s}) is not allowed in attributes. Use state machines to compute values and reference them via context.`);
          }
          if (typeof r == "string" && r.includes("?") && r.includes(":"))
            throw new Error("[ViewEngine] Ternary operators are not allowed in attributes. Use state machines to compute values and reference them via context.");
          const n = await this.evaluator.evaluate(r, t);
          if (n != null)
            if (["disabled", "readonly", "checked", "selected", "autofocus", "required", "multiple"].includes(g.toLowerCase())) {
              const a = !!n;
              A[g] = a, a ? A.setAttribute(g, "") : A.removeAttribute(g);
            } else {
              let a = String(n);
              Jf(a) && (console.warn(`[ViewEngine] Potentially dangerous HTML detected in attribute ${g}, sanitizing`), a = Uf(a)), A.setAttribute(g, a);
            }
        }
    if (e.value !== void 0) {
      if (typeof e.value == "object" && this._isDSLOperation(e.value)) {
        const r = Object.keys(e.value)[0];
        throw new Error(`[ViewEngine] Conditional logic (${r}) is not allowed in value property. Use state machines to compute values and reference them via context.`);
      }
      if (typeof e.value == "string" && e.value.includes("?") && e.value.includes(":"))
        throw new Error("[ViewEngine] Ternary operators are not allowed in value property. Use state machines to compute values and reference them via context.");
      const g = await this.evaluator.evaluate(e.value, t);
      if (A.tagName === "INPUT" || A.tagName === "TEXTAREA") {
        const r = g || "";
        document.activeElement === A || (A.tagName === "INPUT" ? A.value = r : A.textContent = r), this.actorInputCounters.has(o) || this.actorInputCounters.set(o, 0);
        const s = this.actorInputCounters.get(o);
        this.actorInputCounters.set(o, s + 1), A.setAttribute("data-actor-input", `${o}_input_${s}`);
      }
    }
    if (e.text !== void 0) {
      if (typeof e.text == "object" && this._isDSLOperation(e.text)) {
        const r = Object.keys(e.text)[0];
        throw new Error(`[ViewEngine] Conditional logic (${r}) is not allowed in text property. Use state machines to compute values and reference them via context.`);
      }
      if (typeof e.text == "string" && e.text.includes("?") && e.text.includes(":"))
        throw new Error("[ViewEngine] Ternary operators are not allowed in text property. Use state machines to compute values and reference them via context.");
      const g = await this.evaluator.evaluate(e.text, t);
      if (g && typeof g == "object")
        if (g.role && g.id && g.id.startsWith("co_z")) {
          const r = g.id.substring(0, 15) + "...";
          A.textContent = `${g.role} (${r})`;
        } else
          try {
            A.textContent = JSON.stringify(g, null, 2);
          } catch {
            A.textContent = String(g);
          }
      else {
        let r = String(g || "");
        r.startsWith("co_z") && r.length > 15 && (r = r.substring(0, 15) + "..."), A.textContent = r;
      }
    }
  }
  async _renderNodeChildren(A, e, t, o) {
    if (e.children && Array.isArray(e.children))
      for (const g of e.children) {
        if (g && typeof g == "object" && this._isDSLOperation(g)) {
          const n = Object.keys(g)[0];
          throw new Error(`[ViewEngine] Conditional logic (${n}) is not allowed in view templates. Use state machines to compute boolean flags and reference them via context, then use data-attributes and CSS.`);
        }
        const r = await this.renderNode(g, t, o);
        r && A.appendChild(r);
      }
  }
  async _resolveDataAttributes(A, e, t) {
    if (typeof A == "string") {
      if (this._containsConditionalLogic(A))
        throw new Error(`[ViewEngine] Conditional logic is not allowed in data attributes. Use state machines to compute boolean flags and reference them via context. Found: ${A}`);
      if (A.includes(".$$")) {
        const [o, g] = A.split("."), r = await this.evaluator.evaluate(o, e), n = await this.evaluator.evaluate(g, e);
        if (r && typeof r == "object" && n) {
          const s = r[n];
          if (s != null) {
            const a = o.substring(1), I = `data-${this._toKebabCase(a)}`;
            t.setAttribute(I, String(s));
          }
        }
      } else {
        const o = await this.evaluator.evaluate(A, e);
        if (o != null) {
          const g = A.startsWith("$$") ? A.substring(2) : A.substring(1), r = `data-${this._toKebabCase(g)}`;
          t.setAttribute(r, String(o));
        }
      }
    } else if (typeof A == "object" && A !== null)
      for (const [o, g] of Object.entries(A)) {
        if (typeof g == "object" && g !== null && this._isDSLOperation(g))
          throw new Error(`[ViewEngine] Conditional logic (${Object.keys(g)[0]}) is not allowed in data attributes. Use state machines to compute boolean flags and reference them via context.`);
        if (typeof g == "string" && g.includes("?") && g.includes(":"))
          throw new Error("[ViewEngine] Ternary operators are not allowed in views. Use state machines to compute values and reference them via context.");
        let r;
        if (typeof g == "string" && g.includes(".$$")) {
          const [n, s] = g.split("."), a = await this.evaluator.evaluate(n, e), I = await this.evaluator.evaluate(s, e);
          a && typeof a == "object" && I && (r = a[I]);
        } else
          r = await this.evaluator.evaluate(g, e);
        if (r != null) {
          const n = `data-${this._toKebabCase(o)}`;
          t.setAttribute(n, String(r));
        }
      }
  }
  /**
   * Check if a value contains conditional logic (DSL operations or ternary operators)
   * Views should only contain simple context/item references
   */
  _containsConditionalLogic(A) {
    return typeof A != "string" ? !1 : !!(A.includes("?") && A.includes(":"));
  }
  /**
   * Check if a value is a DSL operation (conditional logic)
   */
  _isDSLOperation(A) {
    if (!A || typeof A != "object" || Array.isArray(A)) return !1;
    const e = Object.keys(A);
    if (e.length === 0) return !1;
    const t = e[0];
    return t.startsWith("$") ? ["$if", "$eq", "$ne", "$and", "$or", "$not", "$switch", "$gt", "$lt", "$gte", "$lte"].includes(t) : !1;
  }
  _toKebabCase(A) {
    return A.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
  }
  async _renderSlot(A, e, t, o) {
    const g = A.$slot;
    if (!g || !g.startsWith("$")) {
      console.warn(`[ViewEngine] Slot key must start with $: ${g}`);
      return;
    }
    const r = g.slice(1), n = e.context || {}, s = n[r];
    if (!s) {
      console.warn(`[ViewEngine] No context value for slot key: ${r}`, {
        actorId: o,
        availableKeys: Object.keys(n || {}),
        contextType: "ReactiveStore"
      });
      return;
    }
    let a;
    if (typeof s == "string" && s.startsWith("@")) {
      a = s.slice(1);
      const c = n["@actors"];
      c && !c[a] && console.warn(`[ViewEngine] Namekey "${a}" not found in context["@actors"]`, {
        actorId: o,
        contextKey: r,
        contextValue: n,
        availableActors: c ? Object.keys(c) : []
      });
    } else {
      t.textContent = String(n);
      return;
    }
    const I = this.actorEngine?.getActor(o);
    if (!I) {
      console.warn(`[ViewEngine] Parent actor not found: ${o}`);
      return;
    }
    let C = I.children?.[a];
    if (!C) {
      const c = I.vibeKey || null;
      if (C = await this.actorEngine._createChildActorIfNeeded(I, a, c), !C) {
        I._renderState === lA.READY && console.warn(`[ViewEngine] Failed to create child actor for namekey: ${a}`, {
          actorId: o,
          availableChildren: I?.children ? Object.keys(I.children) : [],
          contextValue: n,
          namekey: a
        });
        return;
      }
    }
    if (C.containerElement) {
      if (I?.children)
        for (const [c, Q] of Object.entries(I.children))
          c !== a && Q.actorType === "ui" && (this.actorEngine.destroyActor(Q.id), delete I.children[c]);
      C._renderState === lA.READY && this.actorEngine && (C._renderState = lA.UPDATING, this.actorEngine._scheduleRerender(C.id)), C.containerElement.parentNode !== t && (C.containerElement.parentNode && C.containerElement.parentNode.removeChild(C.containerElement), t.innerHTML = "", t.appendChild(C.containerElement));
    } else
      console.warn(`[ViewEngine] Child actor ${a} has no containerElement`, {
        actorId: o,
        namekey: a,
        childActorId: C.id
      });
  }
  async renderEach(A, e, t) {
    const o = document.createDocumentFragment(), g = await this.evaluator.evaluate(A.items, e);
    if (!g || !Array.isArray(g) || g.length === 0)
      return o;
    for (let r = 0; r < g.length; r++) {
      const n = g[r], s = {
        context: e.context,
        item: n,
        index: r
      }, a = await this.renderNode(A.template, s, t);
      a && o.appendChild(a);
    }
    return o;
  }
  attachEvents(A, e, t, o) {
    for (const [g, r] of Object.entries(e))
      A.addEventListener(g, async (n) => {
        try {
          await this._handleEvent(n, r, t, A, o);
        } catch (s) {
          console.error(`[ViewEngine] Error handling event ${g}:`, s);
        }
      });
  }
  async _handleEvent(A, e, t, o, g) {
    const r = e.send;
    let n = e.payload || {};
    if ((A.type === "dragover" || A.type === "drop" || A.type === "dragenter") && (A.preventDefault(), A.type === "dragover" && (A.dataTransfer.dropEffect = "move")), r === "STOP_PROPAGATION") {
      A.stopPropagation();
      return;
    }
    if (!(e.key && A.key !== e.key) && !(r === "UPDATE_INPUT" && A.type === "input"))
      if (this.actorEngine) {
        const s = this.actorEngine.getActor(g);
        if (s && s.machine) {
          n = lg(n, o);
          const a = s.context.value, I = {
            context: a,
            item: t.item || {},
            result: null
            // $$result not available in view events (only in state machine actions after tool execution)
          };
          if (n = await Nt(n, this.evaluator, I), _e(n))
            throw new Error(`[ViewEngine] Payload contains unresolved expressions. Views must resolve all expressions before sending to inbox. Payload: ${JSON.stringify(n).substring(0, 200)}`);
          if (r === "UPDATE_INPUT" && A.type === "blur" && n && typeof n == "object") {
            let C = !0;
            for (const [c, Q] of Object.entries(n)) {
              const d = a[c];
              if (Q !== d) {
                C = !1;
                break;
              }
            }
            if (C)
              return;
          }
          await this.actorEngine.sendInternalEvent(g, r, n), r !== "UPDATE_INPUT" && this._clearInputFields(o, g);
        } else
          console.warn(`Cannot send event ${r}: Actor has no state machine`);
      } else
        console.warn("No actorEngine set, cannot handle event:", r);
  }
  /**
   * Clear all input and textarea fields in the form containing the element
   * If no form found, clears inputs in the actor's shadow root
   * @param {HTMLElement} element - The element that triggered the event
   * @param {string} actorId - The actor ID
   * @private
   */
  _clearInputFields(A, e) {
    let t = A.closest("form");
    if (!t && this.actorEngine) {
      const g = this.actorEngine.getActor(e);
      g && g.shadowRoot && (t = g.shadowRoot);
    }
    if (!t) return;
    t.querySelectorAll("input, textarea").forEach((g) => {
      g.hasAttribute("data-actor-input") && (g.tagName === "INPUT" || g.tagName === "TEXTAREA") && (g.value = "");
    });
  }
  setActorEngine(A) {
    this.actorEngine = A;
  }
  cleanupActor(A) {
  }
}
function qf(i, A) {
  if (!(!i || !A))
    return A.split(".").reduce((e, t) => e?.[t], i);
}
class Lf {
  constructor() {
    this.cache = /* @__PURE__ */ new Map(), this.dbEngine = null;
  }
  resolveStyleRef(A) {
    if (!A || !A.startsWith("co_z"))
      throw new Error(`[StyleEngine] Style reference must be a co-id (starts with 'co_z'), got: ${A}`);
    return A;
  }
  deepMerge(A, e) {
    const t = { ...A };
    for (const o in e)
      e[o] instanceof Object && !Array.isArray(e[o]) && o in A ? t[o] = this.deepMerge(A[o], e[o]) : t[o] = e[o];
    return t;
  }
  _interpolateTokens(A, e) {
    return typeof A != "string" ? A : A.replace(/\{([^}]+)\}/g, (t, o) => {
      const g = qf(e, o);
      return g !== void 0 ? g : t;
    });
  }
  _toKebabCase(A) {
    return A.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
  }
  /**
   * Convert camelCase class selectors to kebab-case
   * Preserves special selectors (:host, @container, @media, pseudo-selectors)
   * @param {string} selector - CSS selector (e.g., ".todoCategory", ":host", ".buttonViewSwitch:hover")
   * @returns {string} Converted selector (e.g., ".todo-category", ":host", ".button-view-switch:hover")
   */
  _toKebabCaseSelector(A) {
    return !A || typeof A != "string" || A.startsWith(":host") || A.startsWith("@container") || A.startsWith("@media") || A.startsWith("@") ? A : A.replace(/\.([a-zA-Z][a-zA-Z0-9]*)/g, (e, t) => `.${t.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase()}`);
  }
  compileModifierStyles(A, e) {
    return typeof A != "object" || A === null || Array.isArray(A) ? "" : Object.entries(A).map(([t, o]) => {
      const g = t.replace(/([A-Z])/g, "-$1").toLowerCase(), r = this._interpolateTokens(o, e);
      return `  ${g}: ${r};`;
    }).join(`
`);
  }
  _flattenTokens(A, e = "") {
    const t = {};
    for (const [o, g] of Object.entries(A)) {
      const r = e ? `${e}-${o}` : o;
      typeof g == "object" && g !== null && !Array.isArray(g) ? Object.assign(t, this._flattenTokens(g, r)) : t[`--${r}`] = g;
    }
    return t;
  }
  compileTokensToCSS(A, e = null) {
    const t = this._flattenTokens(A), o = Object.entries(t).map(([n, s]) => `  ${n}: ${s};`).join(`
`);
    let g = "";
    A.typography?.fontFaces && Array.isArray(A.typography.fontFaces) && (g = A.typography.fontFaces.map((n) => `@font-face {
${Object.entries(n).map(([a, I]) => `  ${a.replace(/([A-Z])/g, "-$1").toLowerCase()}: ${I};`).join(`
`)}
}`).join(`

`) + `

`);
    let r = "";
    return e ? r = `  container-type: inline-size;
  container-name: ${e.replace(/[^a-zA-Z0-9-_]/g, "-").replace(/-+/g, "-")};
` : r = `  container-type: inline-size;
`, `${g}:host {
${r}${o}
}
`;
  }
  _compileDataAttributeSelectors(A, e, t, o = "") {
    const g = [];
    if (!e || typeof e != "object" || Array.isArray(e)) return g;
    for (const [r, n] of Object.entries(e)) {
      if (typeof n != "object" || n === null || Array.isArray(n)) continue;
      const s = this._toKebabCase(r);
      for (const [a, I] of Object.entries(n)) {
        if (typeof I != "object" || I === null || Array.isArray(I)) continue;
        const C = this._toKebabCase(a), c = `[data-${s}="${C}"]`, Q = `${A}${o}${c}`, d = {}, f = {};
        let h = null;
        for (const [l, B] of Object.entries(I))
          l === "data" ? h = B : l.startsWith(":") ? f[l] = B : d[l] = B;
        Object.keys(d).length > 0 && g.push(`${Q} {
${this.compileModifierStyles(d, t)}
}`);
        for (const [l, B] of Object.entries(f))
          g.push(`${Q}${l} {
${this.compileModifierStyles(B, t)}
}`);
        h && typeof h == "object" && !Array.isArray(h) && g.push(...this._compileDataAttributeSelectors(A, h, t, `${o}${c}`));
      }
    }
    return g;
  }
  compileComponentsToCSS(A, e) {
    if (!A || Object.keys(A).length === 0) return "";
    const t = [];
    for (const [o, g] of Object.entries(A)) {
      const r = o.replace(/([A-Z])/g, "-$1").toLowerCase(), n = g.data, s = { ...g };
      delete s.data;
      const a = {}, I = {};
      for (const [C, c] of Object.entries(s))
        C.startsWith(":") || C.startsWith("[") || typeof c == "object" && c !== null && !Array.isArray(c) ? I[C] = c : a[C] = c;
      if (Object.keys(a).length > 0) {
        const C = Object.entries(a).map(([Q, d]) => `  ${Q.replace(/([A-Z])/g, "-$1").toLowerCase()}: ${this._interpolateTokens(d, e)};`).join(`
`), c = `.${r} {
${C}
}`;
        t.push(c);
      }
      for (const [C, c] of Object.entries(I)) {
        let Q;
        C.startsWith(":") ? Q = `.${r}${C}` : C.startsWith("[") ? Q = `.${r}${C}` : C.includes(" ") ? Q = `.${r} ${C}` : Q = `.${r}[${C}]`, t.push(`${Q} {
${this.compileModifierStyles(c, e)}
}`);
      }
      n && typeof n == "object" && !Array.isArray(n) && t.push(...this._compileDataAttributeSelectors(`.${r}`, n, e));
    }
    return t.join(`

`);
  }
  compileSelectors(A, e) {
    if (!A || Object.keys(A).length === 0) return "";
    const t = [];
    for (const [o, g] of Object.entries(A)) {
      const r = this._interpolateTokens(o, e);
      if (r.startsWith("@container") || r.startsWith("@media")) {
        const s = [];
        for (const [a, I] of Object.entries(g))
          if (typeof I == "object" && I !== null && !Array.isArray(I))
            if (a.startsWith("@container") || a.startsWith("@media")) {
              const c = this._interpolateTokens(a, e), Q = this.compileSelectors({ [c]: I }, e);
              s.push(Q.split(`
`).map((d) => `  ${d}`).join(`
`));
            } else {
              const c = this._toKebabCaseSelector(a), Q = Object.entries(I).map(([d, f]) => `    ${d.replace(/([A-Z])/g, "-$1").toLowerCase()}: ${this._interpolateTokens(f, e)};`).join(`
`);
              s.push(`  ${c} {
${Q}
  }`);
            }
        t.push(`${r} {
${s.join(`
`)}
}`);
      } else {
        const s = this._toKebabCaseSelector(r), a = Object.entries(g).map(([I, C]) => `  ${I.replace(/([A-Z])/g, "-$1").toLowerCase()}: ${this._interpolateTokens(C, e)};`).join(`
`);
        t.push(`${s} {
${a}
}`);
      }
    }
    return t.join(`

`);
  }
  compileToCSS(A, e, t = {}, o = "", g = null) {
    let r = `${this.compileTokensToCSS(A, g)}
${this.compileComponentsToCSS(e, A)}`;
    const n = this.compileSelectors(t, A);
    return n && (r += `

/* State-based selectors */
${n}`), o && (r += `

/* Raw CSS fallback */
${o}`), r;
  }
  async getStyleSheets(A, e = null) {
    const t = A.brand, o = A.style;
    if (!t)
      throw new Error(`[StyleEngine] Actor config must have 'brand' property with co-id. Config keys: ${Object.keys(A).join(", ")}. Config: ${JSON.stringify(A, null, 2)}`);
    const g = e || A.$id || A.id || "actor", r = `${t}_${o || "none"}_${g}`;
    if (this.cache.has(r))
      return this.cache.get(r);
    const n = this.resolveStyleRef(t), s = await oA(this.dbEngine.backend, { fromCoValue: n }, { returnType: "coId" }), I = (await this.dbEngine.execute({ op: "read", schema: s, key: n })).value;
    let C = { tokens: {}, components: {} };
    if (o) {
      const w = this.resolveStyleRef(o), p = await oA(this.dbEngine.backend, { fromCoValue: w }, { returnType: "coId" });
      C = (await this.dbEngine.execute({ op: "read", schema: p, key: w })).value;
    }
    const c = g.replace(/[^a-zA-Z0-9-_]/g, "-").replace(/-+/g, "-"), Q = {
      containers: {
        xs: "240px",
        sm: "360px",
        md: "480px",
        lg: "640px",
        xl: "768px",
        "2xl": "1024px"
      },
      containerName: c
      // Inject container name so queries can reference root :host container
    }, d = this.deepMerge(Q, I.tokens || {}), f = this.deepMerge(d, C.tokens || {}), h = this.deepMerge(I.components || {}, C.components || {}), l = this.deepMerge(I.selectors || {}, C.selectors || {}), B = [I.rawCSS, C.rawCSS].filter(Boolean).join(`

`), u = this.compileToCSS(f, h, l, B, c), y = new CSSStyleSheet();
    y.replaceSync(u);
    const E = [y];
    return this.cache.set(r, E), E;
  }
  clearCache() {
    this.cache.clear();
  }
}
class xf {
  constructor(A, e, t = null) {
    this.toolEngine = A, this.evaluator = e, this.actorEngine = t, this.machines = /* @__PURE__ */ new Map(), this.dbEngine = null;
  }
  async createMachine(A, e) {
    const t = `${e.id}_machine`, o = {
      id: t,
      definition: A,
      actor: e,
      currentState: A.initial,
      history: [],
      eventPayload: {}
    };
    return this.machines.set(t, o), o._isInitialCreation = !0, await this._executeEntry(o, A.initial), o._isInitialCreation = !1, o;
  }
  async send(A, e, t = {}) {
    const o = this.machines.get(A);
    if (!o) {
      console.warn(`[StateEngine] Machine not found: ${A}`);
      return;
    }
    o.eventPayload = t || {};
    const g = o.definition.states[o.currentState];
    if (!g) {
      console.warn(`[StateEngine] State definition not found for state: ${o.currentState}`);
      return;
    }
    const r = (g.on || {})[e];
    if (!r) {
      console.warn(`[StateEngine] No transition handler for event '${e}' in state '${o.currentState}'`);
      return;
    }
    await this._executeTransition(o, r, e, t);
  }
  async _executeTransition(A, e, t, o) {
    A.eventPayload || (A.eventPayload = o || {}), t === "SUCCESS" && (A.lastToolResult = o.result || null);
    const g = typeof e == "string" ? e : e.target, r = typeof e == "object" ? e.guard : null, n = typeof e == "object" ? e.actions : null;
    if (r != null && !await this._evaluateGuard(r, A.actor.context, A.eventPayload, A.actor))
      return;
    await this._executeExit(A, A.currentState), n && await this._executeActions(A, n, A.eventPayload), A.history.push({ from: A.currentState, to: g, event: t, timestamp: Date.now() });
    const s = A.currentState;
    A.currentState = g;
    const a = A.eventPayload;
    s !== g && (A.eventPayload = a, await this._executeEntry(A, g)), s !== g && g !== "dragging" && !A._isInitialCreation && !(s === "init" && g === "idle") && A.actor._renderState === lA.READY && A.actor.actorEngine && (A.actor._renderState = lA.UPDATING, A.actor.actorEngine._scheduleRerender(A.actor.id));
  }
  /**
   * Clean tool result by removing CoJSON metadata (groupInfo)
   * Tool results from database operations include groupInfo which is metadata, not data
   * @param {any} result - Tool result (can be any type)
   * @returns {any} Cleaned result without groupInfo
   */
  _cleanToolResult(A) {
    if (!A || typeof A != "object")
      return A;
    if (Array.isArray(A))
      return A.map((g) => this._cleanToolResult(g));
    const { groupInfo: e, ...t } = A, o = {};
    for (const [g, r] of Object.entries(t))
      o[g] = this._cleanToolResult(r);
    return o;
  }
  /**
   * Evaluate guard using JSON Schema validation
   * Guards check state/context conditions (NOT payload validation)
   * 
   * CRITICAL ARCHITECTURAL SEPARATION:
   * - Guards are for CONDITIONAL LOGIC (should transition happen given current state/context?)
   * - Payload validation happens in ActorEngine BEFORE reaching state machine
   * 
   * @param {Object} guard - Guard definition with schema property
   * @param {ReactiveStore} context - Actor context (ReactiveStore)
   * @param {Object} payload - Event payload (NOT validated here - already validated in ActorEngine)
   * @param {Object} actor - Actor instance (for state access)
   * @returns {Promise<boolean>} True if guard passes, false otherwise
   */
  async _evaluateGuard(A, e, t, o = null) {
    if (typeof A == "boolean") return A;
    if (!A || typeof A != "object" || !A.schema)
      return console.warn('[StateEngine] Guard must be an object with a "schema" property. Guards are schema-based only (no MaiaScript expressions).', { guard: A }), !1;
    try {
      const g = e.value, r = {
        state: o?.machine?.currentState || null,
        ...g
      };
      return (await bt(A.schema, r, "guard")).valid;
    } catch (g) {
      return console.error("[StateEngine] Guard evaluation error:", g), !1;
    }
  }
  async _executeStateActions(A, e, t) {
    try {
      if (!A || !A.definition || !A.definition.states) {
        console.warn("[StateEngine] Invalid machine or definition in _executeStateActions", { machine: A, stateName: e, type: t });
        return;
      }
      if (!e || typeof e != "string") {
        console.warn("[StateEngine] Invalid stateName in _executeStateActions", { stateName: e, type: t });
        return;
      }
      const o = A.definition.states[e];
      if (!o || typeof o != "object") {
        console.warn("[StateEngine] State not found or invalid in definition", {
          stateName: e,
          stateDef: o,
          availableStates: Object.keys(A.definition.states || {})
        });
        return;
      }
      if (t == null || typeof t != "string") {
        console.warn("[StateEngine] Type is undefined/null or not a string in _executeStateActions", { stateName: e, type: t, typeOf: typeof t });
        return;
      }
      const g = o?.[t];
      if (!g)
        return;
      if (!A.actor) {
        console.warn("[StateEngine] Machine has no actor in _executeStateActions", { machineId: A.id, stateName: e, type: t });
        return;
      }
      if (g.tool) {
        const r = t === "entry", n = await this._invokeTool(A, g.tool, g.payload, !0, r);
        if (n && (A.lastToolResult = n), r && o.on?.SUCCESS && A.actor?.actorEngine) {
          const s = A.eventPayload || {}, I = {
            result: A.lastToolResult ? this._cleanToolResult(A.lastToolResult) : null,
            ...s
          };
          try {
            await A.actor.actorEngine.sendInternalEvent(A.actor.id, "SUCCESS", I);
          } catch (C) {
            console.error("[StateEngine]  Failed to send SUCCESS event:", C);
          }
        }
      } else if (Array.isArray(g)) {
        const r = A.eventPayload || {};
        if (await this._executeActions(A, g, A.eventPayload), t === "entry" && o.on?.SUCCESS && A.actor?.actorEngine) {
          const a = {
            result: A.lastToolResult ? this._cleanToolResult(A.lastToolResult) : null,
            ...r
          };
          try {
            await A.actor.actorEngine.sendInternalEvent(A.actor.id, "SUCCESS", a);
          } catch (I) {
            console.error("[StateEngine]  Failed to send SUCCESS event:", I);
          }
        }
      } else if (typeof g == "object" && g !== null) {
        const r = A.eventPayload || {};
        if (await this._executeActions(A, g, A.eventPayload), t === "entry" && o.on?.SUCCESS && A.actor?.actorEngine) {
          const s = {
            result: A.lastToolResult ? this._cleanToolResult(A.lastToolResult) : null,
            ...r
          };
          await A.actor.actorEngine.sendInternalEvent(A.actor.id, "SUCCESS", s);
        }
      }
    } catch (o) {
      console.error("[StateEngine] Error in _executeStateActions", {
        error: o.message,
        stack: o.stack,
        machineId: A?.id,
        stateName: e,
        type: t,
        machine: A ? { id: A.id, hasActor: !!A.actor, hasDefinition: !!A.definition } : null
      });
    }
  }
  async _executeEntry(A, e) {
    await this._executeStateActions(A, e, "entry");
  }
  async _executeExit(A, e) {
    await this._executeStateActions(A, e, "exit");
  }
  _sanitizeUpdates(A, e = {}) {
    return typeof A == "string" && A === "$$result" ? e : typeof A != "object" || A === null || Array.isArray(A) ? {} : Object.fromEntries(Object.entries(A).map(([t, o]) => [t, o === void 0 ? null : o]));
  }
  async _executeActions(A, e, t = {}) {
    if (!A || !A.actor) {
      console.warn("[StateEngine] Machine has no actor in _executeActions", { machineId: A?.id });
      return;
    }
    Array.isArray(e) || (e = [e]);
    const o = {};
    for (const g of e)
      if (typeof g == "string")
        await this._executeNamedAction(A, g, t);
      else if (g?.mapData)
        await this._executeMapData(A, g.mapData, t);
      else if (g?.updateContext) {
        const r = await this._evaluatePayload(g.updateContext, A.actor.context, t, A.lastToolResult, A.actor);
        Object.assign(o, this._sanitizeUpdates(r, A.lastToolResult || {}));
      } else if (g?.tool) {
        const r = await this._invokeTool(A, g.tool, g.payload, !1);
        if (r && (A.lastToolResult = r), g.onSuccess?.updateContext && r) {
          const n = await this._evaluatePayload(g.onSuccess.updateContext, A.actor.context, A.eventPayload, r, A.actor);
          Object.assign(o, this._sanitizeUpdates(n, r || {}));
        }
      }
    Object.keys(o).length > 0 && A.actor?.actorEngine && await A.actor.actorEngine.updateContextCoValue(A.actor, o);
  }
  /**
   * Execute mapData action - map operations engine configs to context keys
   * Universal API that supports any operation (read, create, update, etc.)
   * @param {Object} machine - State machine instance
   * @param {Object} mapData - Map of context keys to operation configs: { contextKey: { op: 'read', schema: '...', ... } }
   * @param {Object} payload - Event payload for expression evaluation
   */
  async _executeMapData(A, e, t = {}) {
    if (!A || !A.actor) {
      console.warn("[StateEngine] Machine has no actor in _executeMapData", { machineId: A?.id });
      return;
    }
    if (!this.dbEngine) {
      console.error("[StateEngine] Cannot execute mapData: dbEngine not available");
      return;
    }
    if (!e || typeof e != "object") {
      console.error("[StateEngine] mapData must be an object mapping context keys to operation configs", { mapData: e });
      return;
    }
    for (const [o, g] of Object.entries(e)) {
      if (!o || typeof o != "string") {
        console.error("[StateEngine] mapData context keys must be strings", { contextKey: o, operationConfig: g });
        continue;
      }
      if (!g || typeof g != "object") {
        console.error("[StateEngine] mapData operation config must be an object", { contextKey: o, operationConfig: g });
        continue;
      }
      const r = await this._evaluatePayload(
        g,
        A.actor.context,
        t,
        A.lastToolResult,
        A.actor
      ), { op: n = "read", ...s } = r;
      if (!n || typeof n != "string") {
        console.error('[StateEngine] mapData operation config must have an "op" property', { contextKey: o, operationConfig: g });
        continue;
      }
      if (s.schema && typeof s.schema == "string" && !s.schema.startsWith("co_z"))
        if (s.schema.startsWith("@schema/"))
          try {
            const a = await this.dbEngine.execute({ op: "resolve", humanReadableKey: s.schema });
            if (a?.startsWith("co_z"))
              s.schema = a;
            else {
              console.error(`[StateEngine] Failed to resolve schema ${s.schema} for context key ${o}`);
              continue;
            }
          } catch (a) {
            console.error(`[StateEngine] Error resolving schema ${s.schema} for context key ${o}:`, a);
            continue;
          }
        else {
          console.error(`[StateEngine] Invalid schema format for context key ${o}: ${s.schema}. Expected co-id or @schema/... pattern.`);
          continue;
        }
      try {
        const a = { op: n, ...s }, I = await this.dbEngine.execute(a);
        if (I && typeof I == "object" && typeof I.subscribe == "function" && "value" in I) {
          const C = A.actor;
          if (C && C.contextCoId && C.contextSchemaCoId && this.actorEngine) {
            const c = e[o];
            c && c.op === "read" && c.schema && await this.actorEngine.updateContextCoValue(C, {
              [o]: {
                schema: c.schema,
                filter: c.filter || null,
                options: c.options || null
              }
            });
          }
        } else
          console.warn(`[StateEngine] mapData operation "${n}" did not return a ReactiveStore. Mutations should use tool calls instead.`);
      } catch (a) {
        console.error(`[StateEngine] Failed to execute ${n} operation for context key ${o}:`, a);
      }
    }
  }
  async _executeNamedAction(A, e, t) {
    const g = {
      resetError: { error: null },
      setLoading: { isLoading: !0 },
      clearLoading: { isLoading: !1 }
    }[e];
    g && await A.actor.actorEngine.updateContextCoValue(A.actor, g);
  }
  async _invokeTool(A, e, t = {}, o = !0, g = !1) {
    try {
      const r = A.eventPayload || {}, n = await this._evaluatePayload(t, A.actor.context, A.eventPayload || {}, A.lastToolResult, A.actor), s = await this.toolEngine.execute(e, A.actor, n);
      if (o && !g && A.definition.states[A.currentState]?.on?.SUCCESS && A.actor?.actorEngine) {
        const I = s ? this._cleanToolResult(s) : null;
        await A.actor.actorEngine.sendInternalEvent(A.actor.id, "SUCCESS", {
          ...r,
          result: I
          // This must come last to override any result from originalEventPayload
        });
      }
      return s;
    } catch (r) {
      throw console.error(`[StateEngine] Tool execution failed: ${e}`, {
        error: r.message,
        stack: r.stack,
        currentState: A.currentState,
        autoTransition: o
      }), o && (A.definition.states[A.currentState].on?.ERROR ? await A.actor.actorEngine.sendInternalEvent(A.actor.id, "ERROR", { error: r.message }) : console.warn(`[StateEngine] No ERROR handler for ${e} in state ${A.currentState}`)), r;
    }
  }
  async _evaluatePayload(A, e, t = {}, o = null, g = null) {
    const r = e.value, n = t?.result || o || null, s = { context: r, item: t || {}, result: n };
    return await Nt(A, this.evaluator, s);
  }
  getCurrentState(A) {
    return this.machines.get(A)?.currentState || null;
  }
  getMachine(A) {
    return this.machines.get(A) || null;
  }
  destroyMachine(A) {
    this.machines.delete(A);
  }
}
class Tf {
  constructor(A) {
    this.moduleRegistry = A, this.tools = /* @__PURE__ */ new Map();
  }
  async registerTool(A, e, t = {}) {
    !t.definition || !t.function || this.tools.set(e, { definition: t.definition, function: t.function, namespacePath: A });
  }
  async execute(A, e, t) {
    const o = this.tools.get(A);
    if (!o) {
      const r = Array.from(this.tools.keys());
      throw console.error(`[ToolEngine] Tool not found: ${A}`, {
        availableTools: r,
        totalTools: r.length
      }), new Error(`Tool not found: ${A}. Available tools: ${r.join(", ")}`);
    }
    const g = o.definition.parameters || o.definition.params;
    return g && await Fe(this._normalizeToolSchema(g), t, "tool-payload"), await o.function.execute(e, t);
  }
  _normalizeToolSchema(A) {
    const e = (n) => {
      const s = {}, a = [];
      for (const [I, C] of Object.entries(n))
        if (C && typeof C == "object" && C.type !== "function") {
          const { required: c, type: Q, ...d } = C;
          s[I] = { type: Q, ...d }, c === !0 && a.push(I);
        } else C && typeof C == "object" && (s[I] = C);
      return { cleaned: s, required: a };
    };
    if (A.type === "object" && !A.properties) return A;
    const t = A.properties || A, { cleaned: o, required: g } = e(t), r = Array.isArray(A.required) ? A.required : [];
    return {
      type: "object",
      properties: o,
      required: [.../* @__PURE__ */ new Set([...r, ...g])]
    };
  }
  getToolDefinition(A) {
    return this.tools.get(A)?.definition || null;
  }
  getAllTools() {
    return Array.from(this.tools.values()).map((A) => A.definition);
  }
}
function Ce(i, A) {
  if (!(!i || !A))
    return A.split(".").reduce((e, t) => e?.[t], i);
}
class Xg {
  constructor(A = null, e = {}) {
    this.registry = A, this.maxDepth = e.maxDepth || 50, this.validateExpressions = e.validateExpressions !== !1, this.dbEngine = e.dbEngine || null;
  }
  /**
   * Evaluate a MaiaScript expression
   * @param {any} expression - The expression to evaluate
   * @param {Object} data - The data context { context, item }
   * @param {number} depth - Current recursion depth (internal)
   * @returns {Promise<any>} The evaluated result
   */
  async evaluate(A, e, t = 0) {
    if (t > this.maxDepth)
      throw new Error(`[Evaluator] Maximum recursion depth (${this.maxDepth}) exceeded. Expression may be malicious or too complex.`);
    if (this.validateExpressions && t === 0 && typeof A == "object" && A !== null && !Array.isArray(A))
      try {
        const { getSchema: o } = await Promise.resolve().then(() => ha), g = o("maia-script-expression");
        g && await Fe(g, A, "maia-script-expression");
      } catch (o) {
        throw console.error("[Evaluator] Expression validation failed:", o), new Error(`[Evaluator] Invalid MaiaScript expression: ${o.message}`);
      }
    if (typeof A == "number" || typeof A == "boolean" || A === null || A === void 0)
      return A;
    if (typeof A == "string" && A.startsWith("$"))
      return this.evaluateShortcut(A, e);
    if (typeof A != "object") return A;
    if ("$context" in A)
      return Ce(e.context, A.$context);
    if ("$item" in A)
      return Ce(e.item, A.$item);
    if ("$eq" in A) {
      const [o, g] = A.$eq, r = await this.evaluate(o, e, t + 1), n = await this.evaluate(g, e, t + 1);
      return r === n;
    }
    if ("$ne" in A) {
      const [o, g] = A.$ne, r = await this.evaluate(o, e, t + 1), n = await this.evaluate(g, e, t + 1);
      return r !== n;
    }
    if ("$not" in A)
      return !await this.evaluate(A.$not, e, t + 1);
    if ("$and" in A) {
      const o = Array.isArray(A.$and) ? A.$and : [A.$and];
      for (const g of o)
        if (!await this.evaluate(g, e, t + 1))
          return !1;
      return !0;
    }
    if ("$or" in A) {
      const o = Array.isArray(A.$or) ? A.$or : [A.$or];
      for (const g of o)
        if (await this.evaluate(g, e, t + 1))
          return !0;
      return !1;
    }
    if ("$trim" in A) {
      const o = await this.evaluate(A.$trim, e, t + 1);
      return typeof o == "string" ? o.trim() : o;
    }
    if ("$gt" in A) {
      const [o, g] = A.$gt, r = await this.evaluate(o, e, t + 1), n = await this.evaluate(g, e, t + 1);
      return r > n;
    }
    if ("$length" in A) {
      const o = await this.evaluate(A.$length, e, t + 1);
      return Array.isArray(o) || typeof o == "string" ? o.length : 0;
    }
    if ("$concat" in A) {
      const o = Array.isArray(A.$concat) ? A.$concat : [A.$concat];
      return (await Promise.all(o.map((n) => this.evaluate(n, e, t + 1)))).filter((n) => n != null).map((n) => Array.isArray(n) ? n : [n]).flat();
    }
    if ("$map" in A) {
      const o = A.$map, g = await this.evaluate(o.array, e, t + 1);
      if (!g || !Array.isArray(g))
        return [];
      const r = o.as || "item", n = o.return || o.do;
      if (!n)
        throw new Error('[Evaluator] $map operation requires either "return" or "do" property');
      const s = [];
      for (const a of g) {
        const I = {
          ...e,
          item: a
        }, C = await this.evaluateMapReturn(n, I, r, a, t + 1);
        s.push(C);
      }
      return s;
    }
    if ("$if" in A) {
      let o = A.$if.condition;
      return typeof o == "string" && o.startsWith("$") ? o = this.evaluateShortcut(o, e) : o = await this.evaluate(o, e, t + 1), o ? await this.evaluate(A.$if.then, e, t + 1) : await this.evaluate(A.$if.else, e, t + 1);
    }
    if (typeof A == "string" && A.includes("?") && A.includes(":")) {
      const [o, g] = A.split("?").map((r) => r.trim());
      if (g) {
        const [r, n] = g.split(":").map((a) => a.trim());
        return (o.startsWith("$") ? this.evaluateShortcut(o, e) : await this.evaluate(o, e, t + 1)) ? await this.evaluate(r, e, t + 1) : await this.evaluate(n, e, t + 1);
      }
    }
    return A;
  }
  /**
   * Evaluate return expression in $map context with custom item key
   * Handles shortcuts like $$msg.role when as="msg" by treating $$itemKey.path as item.path
   * @param {any} returnExpr - The return expression to evaluate
   * @param {Object} data - The data context { context, item, result }
   * @param {string} itemKey - The 'as' variable name (e.g., "msg")
   * @param {any} currentItem - The current array item being mapped
   * @param {number} depth - Current recursion depth
   * @returns {Promise<any>} The evaluated result
   */
  async evaluateMapReturn(A, e, t, o, g) {
    if (typeof A == "string" && A.startsWith("$$" + t + ".")) {
      const r = A.substring(2 + t.length + 1);
      return Ce(o, r);
    }
    if (typeof A == "object" && A !== null && !Array.isArray(A)) {
      const r = {};
      for (const [n, s] of Object.entries(A))
        if (typeof s == "string" && s.startsWith("$$" + t + ".")) {
          const a = s.substring(2 + t.length + 1);
          r[n] = Ce(o, a);
        } else
          r[n] = await this.evaluate(s, e, g + 1);
      return r;
    }
    return await this.evaluate(A, e, g + 1);
  }
  /**
   * Evaluate compact shortcut syntax: $key or $$key
   * v0.2 syntax:
   * - $key  context.key (implicit context)
   * - $$key  item.key (explicit item with double-dollar)
   * - $$result  result (tool result with double-dollar)
   * @param {string} shortcut - The shortcut string (e.g., "$title", "$$text", "$$result.draggedItemId")
   * @param {Object} data - The data context { context, item, result }
   * @returns {any} The evaluated result
   */
  evaluateShortcut(A, e) {
    if (A.startsWith("$$result")) {
      const g = A.substring(8);
      if (g.startsWith(".")) return Ce(e.result, g.substring(1));
      if (g === "") return e.result;
    }
    if (A.startsWith("$$"))
      return Ce(e.item, A.substring(2));
    const t = A.substring(1), o = Ce(e.context, t);
    return o instanceof mA ? o.value : o;
  }
  /**
   * Check if an expression is a DSL operation
   * @param {any} expression - The expression to check
   * @returns {boolean} True if it's a DSL operation
   */
  isDSLOperation(A) {
    return typeof A == "string" && A.startsWith("$") ? !0 : typeof A != "object" || A === null ? !1 : "$context" in A || "$item" in A || "$if" in A || "$eq" in A || "$ne" in A || "$not" in A || "$and" in A || "$or" in A || "$trim" in A || "$gt" in A || "$length" in A || "$concat" in A || "$map" in A;
  }
}
const Of = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Evaluator: Xg
}, Symbol.toStringTag, { value: "Module" })), Pf = {
  $schema: "@schema/tool",
  $id: "tool_noop_001",
  name: "@core/noop",
  description: "No operation tool (does nothing)",
  parameters: {
    type: "object",
    properties: {}
  }
}, jf = {
  $schema: "@schema/tool",
  $id: "tool_publish_message_001",
  name: "@core/publishMessage",
  description: "Publishes a message to subscribed actors",
  parameters: {
    type: "object",
    properties: {
      type: {
        type: "string",
        description: "Message type"
      },
      payload: {
        type: "object",
        description: "Message payload",
        required: !1
      }
    },
    required: ["type"]
  }
}, Vf = {
  $schema: "@schema/tool",
  $id: "@tool/core/computeMessageNames",
  name: "computeMessageNames",
  description: "Computes a lookup object mapping message IDs to display names based on role",
  parameters: {
    type: "object",
    properties: {
      conversations: {
        type: "array",
        description: "Array of conversation messages with id and role properties"
      }
    },
    required: ["conversations"]
  }
}, Wf = {
  $schema: "@schema/tool",
  $id: "tool_memory_001",
  name: "@memory",
  description: "Memory tool for interacting with Honcho - persistent agent memory system",
  parameters: {
    type: "object",
    properties: {
      op: {
        type: "string",
        enum: ["createSession", "addMessage", "getContext", "chat"],
        description: "Memory operation to execute"
      },
      workspaceId: {
        type: "string",
        description: "Honcho workspace ID (default: 'maiaos-dev')"
      },
      peerId: {
        type: "string",
        description: "Peer ID ('maia' for agent, 'samuel' for user)"
      },
      sessionId: {
        type: "string",
        description: "Session ID (required for addMessage, optional for chat)"
      },
      content: {
        type: "string",
        description: "Message content (required for addMessage)"
      },
      query: {
        type: "string",
        description: "Query for chat/getContext operations"
      },
      target: {
        type: "string",
        description: "Target peer ID for chat (optional, defaults to querying about the peer)"
      }
    },
    required: ["op"]
  }
}, va = {
  $schema: "@schema/tool",
  $id: "tool_agent_001",
  name: "@agent/chat",
  description: "Unified agent chat tool using OpenAI-compatible API (RedPill) for LLM interactions. Model can be configured dynamically via payload - RedPill API endpoint is hardcoded, but each call can specify which LLM model to query. LLMs are stateless - each request sends the full context (complete conversation history).",
  parameters: {
    type: "object",
    properties: {
      context: {
        type: "array",
        description: "Complete conversation context to send to the LLM. LLMs are stateless - this represents the full context/history for this request. Each request can have completely different context.",
        items: {
          type: "object",
          properties: {
            role: {
              type: "string",
              enum: ["system", "user", "assistant"],
              description: "Message role"
            },
            content: {
              type: "string",
              description: "Message content"
            }
          },
          required: ["role", "content"]
        }
      },
      model: {
        type: "string",
        description: "LLM model to query (dynamically configurable per call). Default: qwen/qwen3-30b-a3b-instruct-2507. The RedPill API endpoint is hardcoded, but you can specify any model available on RedPill.",
        default: "qwen/qwen3-30b-a3b-instruct-2507"
      },
      temperature: {
        type: "number",
        description: "Temperature for response (0-2, default: 1)",
        default: 1
      }
    },
    required: ["context"]
  }
}, zf = {
  async execute(i, A) {
  }
}, $f = {
  async execute(i, A) {
    const { type: e, payload: t = {}, target: o } = A;
    if (!e)
      throw new Error("Message type is required");
    if (!o)
      throw new Error("Target is required. Topics infrastructure removed - use direct messaging with target parameter.");
    if (i.actorEngine) {
      if (o.startsWith("@actor/")) {
        console.error(`[publishMessage]  Target not transformed: ${o}. Should be a co-id. Check schema transformer.`);
        return;
      }
      await i.actorEngine.sendMessage(o, {
        type: e,
        payload: t,
        from: i.id,
        timestamp: Date.now()
      });
    } else
      console.warn("[publishMessage] Actor has no actorEngine reference");
  }
}, Zf = {
  async execute(i, A) {
    const { conversations: e = [] } = A;
    if (!Array.isArray(e))
      return {};
    const t = {};
    for (const o of e)
      o && o.id && (t[o.id] = o.role === "user" ? "me" : "Maia");
    return t;
  }
}, _f = () => {
  const i = "localhost:4201";
  return i.startsWith("http://") || i.startsWith("https://") ? i : `http://${i}`;
}, Xf = _f();
async function Tt(i, A) {
  const e = `${Xf}${i}`, t = await fetch(e, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify(A)
  });
  if (!t.ok) {
    const o = await t.json().catch(() => ({ error: "Unknown error" }));
    throw new Error(`[@memory] API request failed: ${o.error || o.message || t.statusText}`);
  }
  return await t.json();
}
const Aw = {
  async execute(i, A) {
    const { op: e, workspaceId: t = "maiaos-dev", peerId: o, sessionId: g, content: r, query: n, target: s } = A;
    try {
      switch (e) {
        case "createSession": {
          if (!o)
            throw new Error("[@memory] peerId is required for createSession");
          const a = await Tt("/api/v0/memory/create-session", {
            workspaceId: t,
            peerId: o,
            sessionId: g
          });
          return { sessionId: a.sessionId, workspaceId: a.workspaceId, peerId: a.peerId };
        }
        case "addMessage": {
          if (!g || !o || !r)
            throw new Error("[@memory] sessionId, peerId, and content are required for addMessage");
          const a = await Tt("/api/v0/memory/add-message", {
            workspaceId: t,
            sessionId: g,
            peerId: o,
            content: r
          });
          return { success: a.success, sessionId: a.sessionId, peerId: a.peerId, content: a.content };
        }
        case "getContext": {
          if (!o || !n)
            throw new Error("[@memory] peerId and query are required for getContext");
          return { context: (await Tt("/api/v0/memory/get-context", {
            workspaceId: t,
            peerId: o,
            sessionId: g,
            query: n,
            target: s
          })).context };
        }
        case "chat": {
          if (!o || !n)
            throw new Error("[@memory] peerId and query are required for chat");
          return { response: (await Tt("/api/v0/memory/chat", {
            workspaceId: t,
            peerId: o,
            sessionId: g,
            query: n,
            target: s
          })).response };
        }
        default:
          throw new Error(`[@memory] Unknown operation: ${e}`);
      }
    } catch (a) {
      throw console.error("[@memory] Error:", a), a;
    }
  }
}, ew = () => {
  const i = "localhost:4201";
  return i.startsWith("http://") || i.startsWith("https://") ? i : `http://${i}`;
}, tw = ew(), Ua = {
  async execute(i, A) {
    const e = A?.context || A?.messages, { model: t = "qwen/qwen3-30b-a3b-instruct-2507", temperature: o = 1 } = A;
    if (!e || !Array.isArray(e) || e.length === 0)
      throw console.error("[@agent/chat] Invalid context:", e), new Error("[@agent/chat] context array is required");
    try {
      const g = {
        model: t,
        messages: e,
        // Map context to messages for API
        temperature: o
      }, r = `${tw}/api/v0/llm/chat`;
      console.log("[@agent/chat]  Sending request to:", r), console.log("[@agent/chat] Request payload:", {
        model: t,
        temperature: o,
        messageCount: e.length,
        lastMessage: e[e.length - 1]?.content?.substring(0, 100) || "N/A"
      });
      const n = await fetch(r, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(g)
      });
      if (console.log("[@agent/chat]  Response received:", {
        status: n.status,
        statusText: n.statusText,
        ok: n.ok,
        headers: Object.fromEntries(n.headers.entries())
      }), !n.ok) {
        const I = await n.json().catch(() => ({ error: "Unknown error" }));
        throw console.error("[@agent/chat]  API error:", I), new Error(`[@agent/chat] API request failed: ${I.error || I.message || n.statusText}`);
      }
      const s = await n.json();
      return console.log("[@agent/chat]  Response data:", {
        contentLength: s.content?.length || 0,
        contentPreview: s.content?.substring(0, 200) || "N/A",
        role: s.role,
        usage: s.usage
      }), {
        content: s.content,
        role: s.role || "assistant",
        usage: s.usage || null
      };
    } catch (g) {
      throw console.error("[@agent/chat] Error:", g), g;
    }
  }
}, Ar = {
  "core/noop": { definition: Pf, function: zf },
  "core/publishMessage": { definition: jf, function: $f },
  "core/computeMessageNames": { definition: Vf, function: Zf },
  "memory/memory": { definition: Wf, function: Aw },
  "agent/chat": { definition: va, function: Ua }
};
function Ja(i) {
  return Ar[i] || null;
}
function iw() {
  const i = {};
  for (const [A, e] of Object.entries(Ar))
    i[A] = e.definition;
  return i;
}
const Ha = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  TOOLS: Ar,
  getAllToolDefinitions: iw,
  getTool: Ja
}, Symbol.toStringTag, { value: "Module" }));
class ow {
  constructor() {
    this.modules = /* @__PURE__ */ new Map(), this.moduleConfigs = /* @__PURE__ */ new Map();
  }
  /**
   * Register a MaiaScript module
   * @param {string} name - Module name (e.g., 'core', 'dragdrop')
   * @param {Object} module - Module instance or class
   * @param {Object} config - Optional module configuration/metadata
   */
  registerModule(A, e, t = {}) {
    this.modules.has(A) && console.warn(`[Registry] Module "${A}" already registered, overwriting`), this.modules.set(A, e), this.moduleConfigs.set(A, {
      name: A,
      version: t.version || "1.0.0",
      description: t.description || "",
      ...t
    });
  }
  /**
   * Get a module by name
   * @param {string} name - Module name
   * @returns {Object|null} Module instance or null
   */
  getModule(A) {
    return this.modules.get(A) || null;
  }
  /**
   * Get module configuration
   * @param {string} name - Module name
   * @returns {Object|null} Module config or null
   */
  getModuleConfig(A) {
    return this.moduleConfigs.get(A) || null;
  }
  /**
   * Check if a module exists
   * @param {string} name - Module name
   * @returns {boolean}
   */
  hasModule(A) {
    return this.modules.has(A);
  }
  /**
   * List all registered modules
   * @returns {Array<string>} Array of module names
   */
  listModules() {
    return Array.from(this.modules.keys());
  }
  /**
   * List all module configs
   * @returns {Array<Object>} Array of module configurations
   */
  listModuleConfigs() {
    return Array.from(this.moduleConfigs.values());
  }
  /**
   * Clear all registered modules
   * @internal For testing purposes only
   */
  clear() {
    this.modules.clear(), this.moduleConfigs.clear(), console.log("[Registry] Cleared all modules");
  }
  /**
   * Load a module (imports and registers)
   * @param {string} moduleName - Module name to load
   * @param {string} modulePath - Path to module file (optional, defaults to modules/{name}.module.js)
   * @returns {Promise<void>}
   */
  async loadModule(A, e = null) {
    if (this.hasModule(A)) {
      console.log(`[Registry] Module "${A}" already loaded`);
      return;
    }
    const t = e || `./${A}.module.js`;
    try {
      const o = await import(
        /* @vite-ignore */
        t
      );
      o.default && typeof o.default.register == "function" ? await o.default.register(this) : typeof o.register == "function" ? await o.register(this) : console.warn(`[Registry] Module "${A}" has no register method`);
    } catch (o) {
      throw console.error(`[Registry] Failed to load module "${A}":`, o), o;
    }
  }
  /**
   * Query module for configuration/data
   * @param {string} moduleName - Module name
   * @param {string} query - Query string
   * @returns {any} Query result or null
   */
  query(A, e) {
    const t = this.getModule(A);
    return t ? typeof t.query == "function" ? t.query(e) : t.config && e in t.config ? t.config[e] : null : null;
  }
  /**
   * Get tool engine from registry
   * @param {string} moduleName - Module name for error messages
   * @returns {Object} ToolEngine instance
   */
  _getToolEngine(A) {
    const e = this._toolEngine;
    if (!e)
      throw new Error(`[${A}] ToolEngine not available in registry`);
    return e;
  }
  /**
   * Register tools from tools registry
   * @param {string} moduleName - Module name
   * @param {Array<string>} toolNames - Array of tool names
   * @param {string} namespace - Namespace prefix (e.g., '@core')
   * @param {Object} options - Options (silent, etc.)
   * @returns {Promise<Array<string>>} Array of registered tool names
   */
  async _registerToolsFromRegistry(A, e, t, o = {}) {
    const { silent: g = !1 } = o, r = this._getToolEngine(A), n = [];
    for (const s of e)
      try {
        const a = Ja(`${A}/${s}`);
        a && (await r.registerTool(`${A}/${s}`, `${t}/${s}`, {
          definition: a.definition,
          function: a.function
        }), n.push(`${t}/${s}`));
      } catch (a) {
        g || console.error(`[${A}] Failed to register ${t}/${s}:`, a.message);
      }
    return n;
  }
}
class Lr extends $g {
  constructor(A) {
    const e = new Xg();
    super(A, { evaluator: e });
  }
}
const gw = {
  async execute(i, A) {
    if (!i)
      throw new Error("[@db] Actor context required");
    const e = i.actorEngine.os;
    if (!e || !e.db)
      throw new Error("[@db] Database engine not available");
    if (A.op === "create" && A.schema && !A.schema.startsWith("co_z"))
      throw new Error(`[@db] Schema must be a co-id (co_z...), got: ${A.schema}. State machine entry actions should be transformed during seeding. No human-readable fallbacks allowed.`);
    return await e.db(A);
  }
}, rw = {
  $schema: "@schema/tool",
  $id: "db",
  name: "Database Tool",
  description: "Unified API for all database operations (query, create, update, delete)",
  schema: "@schema/tool",
  params: {
    op: {
      type: "string",
      enum: ["query", "create", "update", "delete", "seed"],
      description: "Database operation to execute"
    },
    schema: {
      type: "string",
      description: "Schema reference (co-id) - REQUIRED for 'create' operation only (no CoValue exists yet). OPTIONAL for 'update' and 'delete' operations (schema is extracted from CoValue headerMeta internally by operations)."
    },
    key: {
      type: "string",
      description: "Optional: Specific key for config queries"
    },
    filter: {
      type: "object",
      description: "Optional: Filter criteria for data queries"
    },
    callback: {
      description: "Optional: Callback function for reactive subscriptions (not validated - runtime only)"
    },
    id: {
      type: "string",
      description: "Optional: Record ID for update/delete operations"
    },
    data: {
      type: "object",
      description: "Optional: Data for create/update operations"
    }
  },
  returns: {
    type: "any",
    description: "Operation result (data, unsubscribe function, created/updated/deleted record, etc.)"
  }
}, Le = {
  version: "1.0.0",
  description: "Unified database operation API",
  namespace: "@db",
  tools: ["@db"]
};
async function nw(i) {
  i._getToolEngine("DBModule").tools.set("@db", {
    definition: rw,
    function: gw,
    namespacePath: "db/db"
  }), i.registerModule("db", { config: Le, query: (e) => e === "tools" ? ["@db"] : null }, {
    version: Le.version,
    description: Le.description,
    namespace: Le.namespace,
    tools: Le.tools
  });
}
const sw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  config: Le,
  register: nw
}, Symbol.toStringTag, { value: "Module" })), he = {
  version: "1.0.0",
  description: "Core UI tools (view modes, modals, utilities)",
  namespace: "@core",
  tools: ["noop", "preventDefault", "publishMessage", "computeMessageNames"]
};
async function aw(i) {
  const A = he.tools, e = await i._registerToolsFromRegistry("core", A, he.namespace, { silent: !0 });
  i.registerModule("core", { config: he, query: () => null }, {
    version: he.version,
    description: he.description,
    namespace: he.namespace,
    tools: e
  });
}
const Iw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  config: he,
  register: aw
}, Symbol.toStringTag, { value: "Module" })), xe = {
  version: "1.0.0",
  description: "Unified agent tool for OpenAI-compatible API integration (RedPill)",
  namespace: "@agent",
  tools: ["@agent/chat"]
};
async function Cw(i) {
  i._getToolEngine("AgentModule").tools.set("@agent/chat", {
    definition: va,
    function: Ua,
    namespacePath: "agent/chat"
  }), i.registerModule("agent", { config: xe, query: (e) => e === "tools" ? ["@agent/chat"] : null }, {
    version: xe.version,
    description: xe.description,
    namespace: xe.namespace,
    tools: xe.tools
  });
}
const cw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  config: xe,
  register: Cw
}, Symbol.toStringTag, { value: "Module" })), ve = {}, xr = {
  db: sw,
  core: Iw,
  agent: cw
};
class XA {
  constructor() {
    this.moduleRegistry = null, this.evaluator = null, this.toolEngine = null, this.stateEngine = null, this.styleEngine = null, this.viewEngine = null, this.actorEngine = null, this.subscriptionEngine = null, this.dbEngine = null, this._node = null, this._account = null, this._syncDomain = null;
  }
  /**
   * Compatibility property for maia-city and other tools
   * Exposes node and account for CoJSON backend access
   */
  get id() {
    return !this._node || !this._account ? null : {
      maiaId: this._account,
      node: this._node
    };
  }
  /**
   * Get all CoValues from the node (for maia-city compatibility)
   * @returns {Array} Array of CoValue metadata
   */
  getAllCoValues() {
    if (!this._node)
      return [];
    const A = [], e = this._node.coValues;
    if (e && typeof e.entries == "function")
      for (const [t, o] of e.entries())
        try {
          if (!o.isAvailable()) {
            A.push({
              id: t,
              type: "loading",
              schema: null,
              headerMeta: null,
              keys: "N/A",
              content: null,
              createdAt: null
            });
            continue;
          }
          const g = o.getCurrentContent(), r = o.verified?.header, n = r?.meta || null, s = n?.$schema || null, a = r?.createdAt || null;
          let I = "N/A";
          if (g && g.keys && typeof g.keys == "function")
            try {
              I = g.keys().length;
            } catch {
            }
          const C = g?.type || "unknown";
          let c = null;
          if (C === "costream")
            try {
              const Q = g.toJSON();
              if (Q instanceof Uint8Array)
                c = {
                  type: "stream",
                  itemCount: "binary",
                  preview: `${Q.length} bytes`
                };
              else if (Q && typeof Q == "object") {
                const d = [];
                for (const f in Q)
                  Array.isArray(Q[f]) && d.push(...Q[f]);
                c = {
                  type: "stream",
                  itemCount: d.length,
                  preview: d.slice(0, 3)
                };
              }
            } catch {
            }
          else if (C === "coplaintext")
            try {
              c = {
                type: "plaintext",
                content: g.text || g.toString()
              };
            } catch {
            }
          A.push({
            id: t,
            type: C,
            schema: s,
            headerMeta: n,
            keys: I,
            content: c || g,
            createdAt: a
          });
        } catch (g) {
          console.warn(`Error processing CoValue ${t}:`, g), A.push({
            id: t,
            type: "error",
            schema: null,
            headerMeta: null,
            keys: "N/A",
            content: null,
            createdAt: null,
            error: g.message
          });
        }
    return A;
  }
  /**
   * Boot the operating system
   * @param {Object} config - Boot configuration
   * @param {Object} [config.node] - LocalNode instance (required for CoJSON backend if backend not provided)
   * @param {Object} [config.account] - RawAccount instance (required for CoJSON backend if backend not provided)
   * @param {Object} [config.backend] - Pre-initialized backend (alternative to node+account)
   * @param {Object} [config.registry] - Config registry for seeding
   * @param {string} [config.syncDomain] - Sync service domain (overrides env vars, single source of truth)
   * @param {'human' | 'agent'} [config.mode] - Operational mode (default: detect from env vars)
   * @returns {Promise<MaiaOS>} Booted OS instance
   * @throws {Error} If neither backend nor node+account is provided (or agent mode credentials missing)
   */
  static async boot(A = {}) {
    const e = new XA(), t = A.mode || typeof process < "u" && process.env?.MAIA_MODE || typeof import.meta < "u" && ve?.MAIA_MODE || typeof import.meta < "u" && ve?.VITE_MAIA_MODE || "human";
    if (A.syncDomain && (e._syncDomain = A.syncDomain), t === "agent" && !A.node && !A.account && !A.backend) {
      const { loadAgentAccount: g, createAgentAccount: r } = await Promise.resolve().then(() => hw), n = typeof process < "u" && process.env?.MAIA_AGENT_ACCOUNT_ID || typeof import.meta < "u" && ve?.MAIA_AGENT_ACCOUNT_ID || typeof import.meta < "u" && ve?.VITE_MAIA_AGENT_ACCOUNT_ID, s = typeof process < "u" && process.env?.MAIA_AGENT_SECRET || typeof import.meta < "u" && ve?.MAIA_AGENT_SECRET || typeof import.meta < "u" && ve?.VITE_MAIA_AGENT_SECRET;
      if (!n || !s)
        throw new Error(
          "Agent mode requires MAIA_AGENT_ACCOUNT_ID and MAIA_AGENT_SECRET environment variables. For services, use service-specific prefixes: SYNC_MAIA_* for sync service, CITY_MAIA_* for maia-city. Run `bun agent:generate --service <service>` to generate credentials."
        );
      let a;
      try {
        a = await g({
          accountID: n,
          agentSecret: s,
          syncDomain: A.syncDomain || null
        });
      } catch {
        console.log("[MaiaOS.boot] Account not found, creating new agent account..."), a = await r({
          agentSecret: s,
          name: "Maia Agent",
          syncDomain: A.syncDomain || null
        });
      }
      e._node = a.node, e._account = a.account;
    } else
      A.node && A.account && (e._node = A.node, e._account = A.account);
    const o = await XA._initializeDatabase(e, A);
    return o && typeof o.ensureAccountOsReady == "function" && o.ensureAccountOsReady({ timeoutMs: 1e4 }).then((g) => {
      g || console.warn("[MaiaOS.boot]  account.os readiness check failed - schema resolution may fail until it loads");
    }).catch((g) => {
      console.warn("[MaiaOS.boot]  account.os loading error (non-blocking):", g);
    }), A.registry && await XA._seedDatabase(e, o, A), XA._initializeEngines(e, A), await XA._loadModules(e, A), e;
  }
  /**
   * Initialize database backend and engine
   * Requires either a pre-initialized backend or CoJSON node+account
   * @param {MaiaOS} os - OS instance
   * @param {Object} config - Boot configuration
   * @param {Object} [config.node] - LocalNode instance (required for CoJSON backend)
   * @param {Object} [config.account] - RawAccount instance (required for CoJSON backend)
   * @param {Object} [config.backend] - Pre-initialized backend (alternative to node+account)
   * @returns {Promise<DBAdapter>} Initialized backend
   * @throws {Error} If neither backend nor node+account is provided
   */
  static async _initializeDatabase(A, e = {}) {
    if (e.backend)
      return A.dbEngine = new Lr(e.backend), e.backend;
    if (e.node && e.account) {
      const { CoJSONBackend: t } = await Promise.resolve().then(() => so), o = new t(e.node, e.account);
      return A.dbEngine = new Lr(o), o.dbEngine = A.dbEngine, o;
    }
    throw new Error(
      "MaiaOS.boot() requires either a backend or node+account for CoJSON backend. Provide either: { backend: <DBAdapter> } or { node: <LocalNode>, account: <RawAccount> }"
    );
  }
  /**
   * Collect schemas from schemata module
   * @returns {Object} Schemas object
   */
  static _collectSchemas() {
    const A = {};
    return typeof ag == "function" && Object.assign(A, ag()), typeof ng == "function" && (A["meta-schema"] = ng()), A;
  }
  /**
   * Validate schemas against meta schema
   * @param {Object} schemas - Schemas to validate
   * @param {ValidationEngine} validationEngine - Validation engine instance
   * @throws {Error} If any schema fails validation
   */
  static async _validateSchemas(A, e) {
    for (const [t, o] of Object.entries(A)) {
      const g = await e.validateSchemaAgainstMeta(o);
      if (!g.valid) {
        const r = g.errors.map((n) => `  - ${n.instancePath}: ${n.message}`).join(`
`);
        throw console.error(` Schema '${t}' failed meta schema validation:
${r}`), new Error(`Schema '${t}' is not valid JSON Schema`);
      }
    }
  }
  /**
   * Seed database with configs, schemas, and tool definitions
   * @param {MaiaOS} os - OS instance
   * @param {DBAdapter} backend - Database backend (CoJSONBackend)
   * @param {Object} config - Boot configuration
   */
  static async _seedDatabase(A, e, t) {
    const { getAllToolDefinitions: o } = await Promise.resolve().then(() => Ha), g = o(), r = {
      ...t.registry,
      tool: g
      // Add tool definitions under 'tool' key
    }, n = XA._collectSchemas(), s = new Me();
    await s.initialize(), await XA._validateSchemas(n, s);
    const I = t.registry?.data || {};
    await A.dbEngine.execute({
      op: "seed",
      configs: r,
      schemas: n,
      data: I
    });
    const { setSchemaResolver: C } = await Promise.resolve().then(() => fu);
    C({ dbEngine: A.dbEngine });
  }
  /**
   * Initialize all engines and wire dependencies
   * @param {MaiaOS} os - OS instance
   * @param {Object} config - Boot configuration
   */
  static _initializeEngines(A, e) {
    A.moduleRegistry = new ow(), A.evaluator = new Xg(A.moduleRegistry, { dbEngine: A.dbEngine }), A.toolEngine = new Tf(A.moduleRegistry), A.moduleRegistry._toolEngine = A.toolEngine, A.moduleRegistry._dbEngine = A.dbEngine, A.stateEngine = new xf(A.toolEngine, A.evaluator), A.styleEngine = new Lf(), e.isDevelopment && A.styleEngine.clearCache(), A.viewEngine = new Hf(A.evaluator, null, A.moduleRegistry), A.actorEngine = new vf(
      A.styleEngine,
      A.viewEngine,
      A.moduleRegistry,
      A.toolEngine,
      A.stateEngine
    ), A.actorEngine.dbEngine = A.dbEngine, A.viewEngine.dbEngine = A.dbEngine, A.styleEngine.dbEngine = A.dbEngine, A.stateEngine.dbEngine = A.dbEngine, A.actorEngine.os = A, A.viewEngine.actorEngine = A.actorEngine, A.stateEngine.actorEngine = A.actorEngine;
  }
  /**
   * Load modules
   * @param {MaiaOS} os - OS instance
   * @param {Object} config - Boot configuration
   */
  static async _loadModules(A, e) {
    const t = e.modules || ["db", "core"];
    for (const o of t)
      try {
        if (xr[o]) {
          const g = xr[o];
          g.default && typeof g.default.register == "function" ? await g.default.register(A.moduleRegistry) : typeof g.register == "function" && await g.register(A.moduleRegistry);
        } else
          await A.moduleRegistry.loadModule(o);
      } catch (g) {
        console.error(`Failed to load module "${o}":`, g);
      }
  }
  /**
   * Create an actor
   * @param {string} actorPath - Path to actor.maia file
   * @param {HTMLElement} container - Container element
   * @returns {Promise<Object>} Created actor
   */
  async createActor(A, e) {
    let t;
    if (typeof A == "object" && A !== null)
      t = A;
    else if (typeof A == "string" && A.startsWith("co_z")) {
      const g = await oA(this.actorEngine.dbEngine.backend, { fromCoValue: A }, { returnType: "coId" });
      t = (await this.actorEngine.dbEngine.execute({ op: "read", schema: g, key: A })).value;
    } else
      throw new Error(`[MaiaOS] createActor expects co-id (co_z...) or config object, got: ${typeof A}`);
    return await this.actorEngine.createActor(t, e);
  }
  /**
   * Load a vibe (app manifest) from file and create its root actor
   * @param {string} vibePath - Path to vibe manifest
   * @param {HTMLElement} container - Container element
   * @returns {Promise<{vibe: Object, actor: Object}>} Vibe metadata and actor instance
   */
  async loadVibe(A, e) {
    const t = await fetch(A);
    if (!t.ok)
      throw new Error(`Failed to load vibe: ${A}`);
    const o = await t.json(), r = `${A.substring(0, A.lastIndexOf("/"))}/${o.actor}`, n = await this.createActor(r, e);
    return { vibe: o, actor: n };
  }
  /**
   * Load a vibe from account.vibes using the abstracted operations API
   * @param {string} vibeKey - Vibe key in account.vibes (e.g., "todos")
   * @param {HTMLElement} container - Container element
   * @returns {Promise<{vibe: Object, actor: Object}>} Vibe metadata and actor instance
   */
  async loadVibeFromAccount(A, e) {
    if (!this.dbEngine || !this._account)
      throw new Error("[Kernel] Cannot load vibe from account - dbEngine or account not available");
    const t = this._account, g = (await this.dbEngine.execute({
      op: "read",
      schema: "@account",
      key: t.id
    })).value;
    if (!g)
      throw new Error("[Kernel] Failed to read account CoMap");
    const r = g.vibes;
    if (!r || typeof r != "string" || !r.startsWith("co_"))
      throw new Error(`[Kernel] account.vibes not found. Make sure the vibe was seeded correctly. Account data: ${JSON.stringify({ id: g.id, hasVibes: !!g.vibes })}`);
    const s = (await this.dbEngine.execute({
      op: "read",
      schema: r,
      key: r
    })).value;
    if (!s || s.error)
      throw new Error(`[Kernel] account.vibes CoMap not found or error (co-id: ${r}): ${s?.error || "Unknown error"}. Make sure the vibe was seeded correctly.`);
    const a = s[A];
    if (!a || typeof a != "string" || !a.startsWith("co_")) {
      const I = Object.keys(s).filter((C) => C !== "id" && C !== "$schema" && C !== "type" && typeof s[C] == "string" && s[C].startsWith("co_"));
      throw console.error(`[Kernel] Vibe '${A}' not found in account.vibes. Available vibes:`, I), new Error(`[Kernel] Vibe '${A}' not found in account.vibes. Available vibes: ${I.join(", ")}`);
    }
    return await this.loadVibeFromDatabase(a, e, A);
  }
  /**
   * Load a vibe from database (maia.db)
   * @param {string} vibeId - Vibe ID (co-id or human-readable like "@vibe/todos")
   * @param {HTMLElement} container - Container element
   * @param {string} [vibeKey] - Optional vibe key for actor reuse tracking (e.g., 'todos')
   * @returns {Promise<{vibe: Object, actor: Object}>} Vibe metadata and actor instance
   */
  async loadVibeFromDatabase(A, e, t = null) {
    if (!A.startsWith("co_z"))
      throw new Error(`[Kernel] Vibe ID must be co-id at runtime: ${A}. This should have been resolved during seeding.`);
    const o = A, g = await this.dbEngine.execute({
      op: "read",
      schema: null,
      // No schema filter - read CoValue directly
      key: o
    }), r = await this.dbEngine.execute({
      op: "schema",
      fromCoValue: o
      //  Extracts headerMeta.$schema internally
    }), n = r.value?.$id || g.value?.$schema;
    if (!n)
      throw new Error(`[Kernel] Failed to extract schema co-id from vibe ${o}. Vibe must have $schema in headerMeta.`);
    let a = g.value;
    if (!a || a.error) {
      console.error("[Kernel] Vibe not found! Trying to debug..."), console.error(`[Kernel] Vibe co-id: ${o}`), console.error(`[Kernel] Schema co-id: ${n}`);
      try {
        const y = (await this.dbEngine.execute({
          op: "read",
          schema: null,
          // Read CoValue directly
          key: o
        })).value;
        console.error("[Kernel] Direct read() result:", y ? "FOUND" : "NULL", y);
      } catch (u) {
        console.error("[Kernel] Direct read() error:", u);
      }
      throw new Error(`Vibe not found in database: ${A} (co-id: ${o})`);
    }
    if (a.properties && Array.isArray(a.properties)) {
      const u = {};
      for (const y of a.properties)
        u[y.key] = y.value;
      a.id && (u.id = a.id), a.$schema && (u.$schema = a.$schema), a.type && (u.type = a.type), a = u;
    }
    const I = r.value;
    I && await Fe(I, a, "vibe");
    let C = a.actor;
    if (!C)
      throw new Error(`[MaiaOS] Vibe ${A} (${o}) does not have an 'actor' property. Vibe structure: ${JSON.stringify(Object.keys(a))}`);
    if (!C.startsWith("co_z"))
      throw new Error(`[Kernel] Actor ID must be co-id at runtime: ${C}. This should have been resolved during seeding.`);
    const c = ee(this.dbEngine.backend, { fromCoValue: C }, { returnType: "coId" });
    let Q;
    const d = await new Promise((u, y) => {
      const E = setTimeout(() => {
        Q && Q(), y(new Error(`[Kernel] Timeout waiting for actor schema to resolve for ${C} after 10000ms`));
      }, 1e4);
      Q = c.subscribe((w) => {
        w.loading || (clearTimeout(E), Q && Q(), w.error || !w.schemaCoId ? y(new Error(`[Kernel] Failed to extract schema co-id from actor ${C}: ${w.error || "Schema not found"}`)) : u(w.schemaCoId));
      });
    }), f = await this.dbEngine.execute({
      op: "read",
      schema: d,
      key: C
    });
    if (!f.value)
      throw new Error(`[MaiaOS] Actor with co-id ${C} not found in database. The actor may not have been seeded correctly.`);
    if (t) {
      const u = this.actorEngine.getActorsForVibe(t);
      if (u && u.size > 0) {
        const y = Array.from(u)[0], E = this.actorEngine.actors.get(y);
        if (E?.config?.id, E && E.config && E.config.id === C) {
          const w = await this.actorEngine.reattachActorsForVibe(t, e);
          if (w)
            return { vibe: a, actor: w };
        } else
          this.actorEngine.detachActorsForVibe(t);
      }
    }
    const l = f.value, B = await this.actorEngine.createActor(l, e, t);
    return { vibe: a, actor: B };
  }
  /**
   * Debug helper to list coIdRegistry keys (for troubleshooting)
   * @private
   */
  async _debugCoIdRegistry() {
    try {
      const t = this.dbEngine.backend.db.transaction(["coIdRegistry"], "readonly").objectStore("coIdRegistry").getAllKeys();
      return (await new Promise((g, r) => {
        t.onsuccess = () => g(t.result), t.onerror = () => r(t.error);
      })).filter((g) => g && (g.includes("actor") || g.includes("agent")));
    } catch (A) {
      return [`Error: ${A.message}`];
    }
  }
  /**
   * Get actor by ID
   * @param {string} actorId - Actor ID
   * @returns {Object|null} Actor instance
   */
  getActor(A) {
    return this.actorEngine.getActor(A);
  }
  /**
   * Send message to actor
   * @param {string} actorId - Target actor ID
   * @param {Object} message - Message object
   */
  sendMessage(A, e) {
    this.actorEngine.sendMessage(A, e);
  }
  /**
   * Execute database operation (internal use + @db tool)
   * @param {Object} payload - Operation payload {op: 'query|create|update|delete|seed', ...}
   * @returns {Promise<any>} Operation result
   */
  async db(A) {
    return await this.dbEngine.execute(A);
  }
  /**
   * Get sync domain (single source of truth)
   * Returns the sync domain configured during boot, or null if not set
   * @returns {string|null} Sync domain or null
   */
  getSyncDomain() {
    return this._syncDomain;
  }
  /**
   * Expose engines for debugging
   */
  getEngines() {
    return {
      actorEngine: this.actorEngine,
      viewEngine: this.viewEngine,
      styleEngine: this.styleEngine,
      stateEngine: this.stateEngine,
      toolEngine: this.toolEngine,
      dbEngine: this.dbEngine,
      evaluator: this.evaluator,
      moduleRegistry: this.moduleRegistry
    };
  }
}
async function qa() {
  if (!window.PublicKeyCredential)
    throw new Error(
      `WebAuthn not supported. Please use:
- Chrome on macOS/Linux/Windows 11
- Safari on macOS 13+/iOS 16+
Firefox and Windows 10 are NOT supported.`
    );
  try {
    if (!await PublicKeyCredential.isConditionalMediationAvailable?.())
      throw new Error(
        `WebAuthn PRF not supported. Please use:
- Chrome on macOS/Linux/Windows 11
- Safari on macOS 13+/iOS 16+
Firefox and Windows 10 are NOT supported.`
      );
    return !0;
  } catch {
    throw new Error(
      `WebAuthn PRF not supported. Please use:
- Chrome on macOS/Linux/Windows 11
- Safari on macOS 13+/iOS 16+
Firefox and Windows 10 are NOT supported.`
    );
  }
}
async function er() {
  await qa();
}
function La(i) {
  const A = new Uint8Array(i);
  let e = "";
  for (let t = 0; t < A.byteLength; t++)
    e += String.fromCharCode(A[t]);
  return btoa(e);
}
function tr(i) {
  return new TextEncoder().encode(i);
}
async function xa({ salt: i, rpId: A = window.location.hostname }) {
  try {
    const e = await navigator.credentials.get({
      publicKey: {
        challenge: crypto.getRandomValues(new Uint8Array(32)),
        rpId: A,
        userVerification: "required",
        authenticatorAttachment: "platform",
        // ONLY platform authenticators!
        // WebAuthn Level 3: Hint the browser UI to show platform authenticator
        hints: ["client-device"],
        // Prioritize local device, suppress QR code UI
        extensions: {
          prf: {
            eval: {
              first: i
              // The salt we want to evaluate
            }
          }
        }
      },
      mediation: "optional"
      // Show passkey picker
    });
    if (!e)
      throw new Error("No passkey selected");
    const t = e.getClientExtensionResults()?.prf;
    if (!t?.results?.first)
      throw new Error("PRF evaluation failed: no results returned");
    return {
      prfOutput: new Uint8Array(t.results.first),
      credentialId: e.rawId
    };
  } catch (e) {
    throw console.error("PRF evaluation error:", e), new Error(`Failed to evaluate PRF: ${e.message}`);
  }
}
async function Ta({ name: i, userId: A, rpId: e = window.location.hostname, salt: t }) {
  try {
    const o = t ? {
      prf: {
        eval: {
          first: t
          // Evaluate PRF during creation!
        }
      }
    } : {
      prf: {}
      // Just enable PRF without evaluation
    }, g = await navigator.credentials.create({
      publicKey: {
        challenge: crypto.getRandomValues(new Uint8Array(32)),
        rp: {
          name: "Maia OS",
          id: e
        },
        user: {
          id: A,
          name: i,
          displayName: i
        },
        pubKeyCredParams: [
          { type: "public-key", alg: -7 },
          // ES256
          { type: "public-key", alg: -257 }
          // RS256
        ],
        authenticatorSelection: {
          authenticatorAttachment: "platform",
          // ONLY platform authenticators
          residentKey: "required",
          userVerification: "required"
        },
        // WebAuthn Level 3: Hint the browser UI to show platform authenticator first
        hints: ["client-device"],
        // Prioritize local device authenticator UI
        extensions: o
      }
    }), r = g.getClientExtensionResults();
    if (!r.prf?.enabled)
      throw new Error("PRF extension not enabled on credential");
    const n = r.prf?.results?.first ? new Uint8Array(r.prf.results.first) : null;
    return {
      credentialId: g.rawId,
      response: g.response,
      prfOutput: n
      // May be null if salt wasn't provided
    };
  } catch (o) {
    throw console.error("Passkey creation error:", o), new Error(`Failed to create passkey: ${o.message}`);
  }
}
const { accountHeaderForInitialAgentSecret: ao, idforHeader: Io } = Yg;
async function Bw({ name: i = "maia", salt: A = "maia.city" } = {}) {
  await er();
  const e = tr(A), t = await ie.create(), { credentialId: o, prfOutput: g } = await Ta({
    name: i,
    userId: globalThis.crypto.getRandomValues(new Uint8Array(32)),
    // Random userID - we don't store anything!
    salt: e
  });
  if (!g)
    throw new Error("PRF evaluation failed");
  const r = t.agentSecretFromSecretSeed(g), n = ao(r, t), s = Io(n, t), a = await be({ mode: "human", servicePrefix: "CITY" }), I = Yt(), C = await Vg({
    agentSecret: r,
    name: i,
    peers: I ? I.peers : [],
    storage: a
  }), { node: c, account: Q, accountID: d } = C;
  if (I && I.setNode(c), d !== s)
    throw new Error(
      `CRITICAL: AccountID mismatch!
  Computed: ${s}
  Created:  ${d}
This should never happen - deterministic computation failed!`
    );
  return {
    accountID: d,
    agentSecret: r,
    node: c,
    account: Q,
    credentialId: La(o)
  };
}
async function Qw({ salt: i = "maia.city" } = {}) {
  await er();
  const A = tr(i), { prfOutput: e } = await xa({ salt: A });
  if (!e)
    throw new Error("PRF evaluation failed during sign-in");
  const t = await ie.create(), o = t.agentSecretFromSecretSeed(e), g = ao(o, t), r = Io(g, t), n = await be({ mode: "human", servicePrefix: "CITY" }), s = Yt();
  performance.now();
  const a = (async () => {
    try {
      let I = !1;
      s && s.waitForPeer && (I = await s.waitForPeer());
      const C = await Wg({
        accountID: r,
        agentSecret: o,
        peers: s ? s.peers : [],
        storage: n
      }), { node: c, account: Q } = C;
      return s && s.setNode(c), console.log("    0 secrets retrieved from storage"), console.log("    Everything computed deterministically!"), {
        accountID: Q.id,
        agentSecret: o,
        node: c,
        account: Q
      };
    } catch (I) {
      throw console.error(" Account loading failed:", I), console.error("   Error message:", I.message), console.error("   Error stack:", I.stack), console.error("   AccountID:", r), console.error("   Peers available:", s ? s.peers.length : 0), s && s.peers.length > 0 && console.error("   Peer IDs:", s.peers.map((C) => C.id || "unknown")), I;
    }
  })();
  return console.log(" Returning from signInWithPasskey() immediately (account loading in background)..."), {
    accountID: r,
    agentSecret: o,
    loadingPromise: a
  };
}
async function Ew({ name: i = "Maia Agent" } = {}) {
  const A = await ie.create(), e = A.newRandomAgentSecret(), t = ao(e, A);
  return {
    accountID: Io(t, A),
    agentSecret: e,
    name: i
  };
}
async function lw({ agentSecret: i, name: A = "Maia Agent", syncDomain: e = null, servicePrefix: t = null, dbPath: o = null, inMemory: g = !1 } = {}) {
  if (!i)
    throw new Error(
      "agentSecret is required. Set service-specific env var (e.g., SYNC_MAIA_AGENT_SECRET or CITY_MAIA_AGENT_SECRET). Run `bun agent:generate --service <service>` to generate credentials."
    );
  const r = await ie.create(), n = ao(i, r), s = Io(n, r), a = await be({ mode: "agent", servicePrefix: t, dbPath: o, inMemory: g }), I = Yt(e), C = await Vg({
    agentSecret: i,
    name: A,
    peers: I ? I.peers : [],
    storage: a,
    skipAutoSeeding: !0
    // Agent accounts don't need vibes/views seeding
  }), { node: c, account: Q, accountID: d } = C;
  if (I && I.setNode(c), d !== s)
    throw new Error(
      `CRITICAL: AccountID mismatch!
  Computed: ${s}
  Created:  ${d}
This should never happen - deterministic computation failed!`
    );
  return {
    accountID: d,
    agentSecret: i,
    node: c,
    account: Q
  };
}
async function dw({ accountID: i, agentSecret: A, syncDomain: e = null, servicePrefix: t = null, dbPath: o = null, inMemory: g = !1 } = {}) {
  if (!A)
    throw new Error(
      "agentSecret is required. Set service-specific env var (e.g., SYNC_MAIA_AGENT_SECRET or CITY_MAIA_AGENT_SECRET). Run `bun agent:generate --service <service>` to generate credentials."
    );
  if (!i)
    throw new Error(
      "accountID is required. Set service-specific env var (e.g., SYNC_MAIA_AGENT_ACCOUNT_ID or CITY_MAIA_AGENT_ACCOUNT_ID). Run `bun agent:generate --service <service>` to generate credentials."
    );
  const r = await be({ mode: "agent", servicePrefix: t, dbPath: o, inMemory: g }), n = Yt(e), s = await Wg({
    accountID: i,
    agentSecret: A,
    peers: n ? n.peers : [],
    storage: r
  }), { node: a, account: I } = s;
  return n && n.setNode(a), {
    accountID: I.id,
    agentSecret: A,
    node: a,
    account: I
  };
}
const hw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  arrayBufferToBase64: La,
  createAgentAccount: lw,
  createPasskeyWithPRF: Ta,
  evaluatePRF: xa,
  generateAgentCredentials: Ew,
  getStorage: be,
  isPRFSupported: qa,
  loadAgentAccount: dw,
  requirePRFSupport: er,
  signInWithPasskey: Qw,
  signUpWithPasskey: Bw,
  stringToUint8Array: tr
}, Symbol.toStringTag, { value: "Module" }));
function Oa(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
}
var Ot = { exports: {} }, Ko = {}, zA = {}, ce = {}, Yo = {}, vo = {}, Uo = {}, Tr;
function Zi() {
  return Tr || (Tr = 1, (function(i) {
    Object.defineProperty(i, "__esModule", { value: !0 }), i.regexpCode = i.getEsmExportName = i.getProperty = i.safeStringify = i.stringify = i.strConcat = i.addCodeArg = i.str = i._ = i.nil = i._Code = i.Name = i.IDENTIFIER = i._CodeOrName = void 0;
    class A {
    }
    i._CodeOrName = A, i.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    class e extends A {
      constructor(B) {
        if (super(), !i.IDENTIFIER.test(B))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = B;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return !1;
      }
      get names() {
        return { [this.str]: 1 };
      }
    }
    i.Name = e;
    class t extends A {
      constructor(B) {
        super(), this._items = typeof B == "string" ? [B] : B;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return !1;
        const B = this._items[0];
        return B === "" || B === '""';
      }
      get str() {
        var B;
        return (B = this._str) !== null && B !== void 0 ? B : this._str = this._items.reduce((u, y) => `${u}${y}`, "");
      }
      get names() {
        var B;
        return (B = this._names) !== null && B !== void 0 ? B : this._names = this._items.reduce((u, y) => (y instanceof e && (u[y.str] = (u[y.str] || 0) + 1), u), {});
      }
    }
    i._Code = t, i.nil = new t("");
    function o(l, ...B) {
      const u = [l[0]];
      let y = 0;
      for (; y < B.length; )
        n(u, B[y]), u.push(l[++y]);
      return new t(u);
    }
    i._ = o;
    const g = new t("+");
    function r(l, ...B) {
      const u = [Q(l[0])];
      let y = 0;
      for (; y < B.length; )
        u.push(g), n(u, B[y]), u.push(g, Q(l[++y]));
      return s(u), new t(u);
    }
    i.str = r;
    function n(l, B) {
      B instanceof t ? l.push(...B._items) : B instanceof e ? l.push(B) : l.push(C(B));
    }
    i.addCodeArg = n;
    function s(l) {
      let B = 1;
      for (; B < l.length - 1; ) {
        if (l[B] === g) {
          const u = a(l[B - 1], l[B + 1]);
          if (u !== void 0) {
            l.splice(B - 1, 3, u);
            continue;
          }
          l[B++] = "+";
        }
        B++;
      }
    }
    function a(l, B) {
      if (B === '""')
        return l;
      if (l === '""')
        return B;
      if (typeof l == "string")
        return B instanceof e || l[l.length - 1] !== '"' ? void 0 : typeof B != "string" ? `${l.slice(0, -1)}${B}"` : B[0] === '"' ? l.slice(0, -1) + B.slice(1) : void 0;
      if (typeof B == "string" && B[0] === '"' && !(l instanceof e))
        return `"${l}${B.slice(1)}`;
    }
    function I(l, B) {
      return B.emptyStr() ? l : l.emptyStr() ? B : r`${l}${B}`;
    }
    i.strConcat = I;
    function C(l) {
      return typeof l == "number" || typeof l == "boolean" || l === null ? l : Q(Array.isArray(l) ? l.join(",") : l);
    }
    function c(l) {
      return new t(Q(l));
    }
    i.stringify = c;
    function Q(l) {
      return JSON.stringify(l).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    i.safeStringify = Q;
    function d(l) {
      return typeof l == "string" && i.IDENTIFIER.test(l) ? new t(`.${l}`) : o`[${l}]`;
    }
    i.getProperty = d;
    function f(l) {
      if (typeof l == "string" && i.IDENTIFIER.test(l))
        return new t(`${l}`);
      throw new Error(`CodeGen: invalid export name: ${l}, use explicit $id name mapping`);
    }
    i.getEsmExportName = f;
    function h(l) {
      return new t(l.toString());
    }
    i.regexpCode = h;
  })(Uo)), Uo;
}
var Jo = {}, Or;
function Pr() {
  return Or || (Or = 1, (function(i) {
    Object.defineProperty(i, "__esModule", { value: !0 }), i.ValueScope = i.ValueScopeName = i.Scope = i.varKinds = i.UsedValueState = void 0;
    const A = Zi();
    class e extends Error {
      constructor(a) {
        super(`CodeGen: "code" for ${a} not defined`), this.value = a.value;
      }
    }
    var t;
    (function(s) {
      s[s.Started = 0] = "Started", s[s.Completed = 1] = "Completed";
    })(t || (i.UsedValueState = t = {})), i.varKinds = {
      const: new A.Name("const"),
      let: new A.Name("let"),
      var: new A.Name("var")
    };
    class o {
      constructor({ prefixes: a, parent: I } = {}) {
        this._names = {}, this._prefixes = a, this._parent = I;
      }
      toName(a) {
        return a instanceof A.Name ? a : this.name(a);
      }
      name(a) {
        return new A.Name(this._newName(a));
      }
      _newName(a) {
        const I = this._names[a] || this._nameGroup(a);
        return `${a}${I.index++}`;
      }
      _nameGroup(a) {
        var I, C;
        if (!((C = (I = this._parent) === null || I === void 0 ? void 0 : I._prefixes) === null || C === void 0) && C.has(a) || this._prefixes && !this._prefixes.has(a))
          throw new Error(`CodeGen: prefix "${a}" is not allowed in this scope`);
        return this._names[a] = { prefix: a, index: 0 };
      }
    }
    i.Scope = o;
    class g extends A.Name {
      constructor(a, I) {
        super(I), this.prefix = a;
      }
      setValue(a, { property: I, itemIndex: C }) {
        this.value = a, this.scopePath = (0, A._)`.${new A.Name(I)}[${C}]`;
      }
    }
    i.ValueScopeName = g;
    const r = (0, A._)`\n`;
    class n extends o {
      constructor(a) {
        super(a), this._values = {}, this._scope = a.scope, this.opts = { ...a, _n: a.lines ? r : A.nil };
      }
      get() {
        return this._scope;
      }
      name(a) {
        return new g(a, this._newName(a));
      }
      value(a, I) {
        var C;
        if (I.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const c = this.toName(a), { prefix: Q } = c, d = (C = I.key) !== null && C !== void 0 ? C : I.ref;
        let f = this._values[Q];
        if (f) {
          const B = f.get(d);
          if (B)
            return B;
        } else
          f = this._values[Q] = /* @__PURE__ */ new Map();
        f.set(d, c);
        const h = this._scope[Q] || (this._scope[Q] = []), l = h.length;
        return h[l] = I.ref, c.setValue(I, { property: Q, itemIndex: l }), c;
      }
      getValue(a, I) {
        const C = this._values[a];
        if (C)
          return C.get(I);
      }
      scopeRefs(a, I = this._values) {
        return this._reduceValues(I, (C) => {
          if (C.scopePath === void 0)
            throw new Error(`CodeGen: name "${C}" has no value`);
          return (0, A._)`${a}${C.scopePath}`;
        });
      }
      scopeCode(a = this._values, I, C) {
        return this._reduceValues(a, (c) => {
          if (c.value === void 0)
            throw new Error(`CodeGen: name "${c}" has no value`);
          return c.value.code;
        }, I, C);
      }
      _reduceValues(a, I, C = {}, c) {
        let Q = A.nil;
        for (const d in a) {
          const f = a[d];
          if (!f)
            continue;
          const h = C[d] = C[d] || /* @__PURE__ */ new Map();
          f.forEach((l) => {
            if (h.has(l))
              return;
            h.set(l, t.Started);
            let B = I(l);
            if (B) {
              const u = this.opts.es5 ? i.varKinds.var : i.varKinds.const;
              Q = (0, A._)`${Q}${u} ${l} = ${B};${this.opts._n}`;
            } else if (B = c?.(l))
              Q = (0, A._)`${Q}${B}${this.opts._n}`;
            else
              throw new e(l);
            h.set(l, t.Completed);
          });
        }
        return Q;
      }
    }
    i.ValueScope = n;
  })(Jo)), Jo;
}
var jr;
function tA() {
  return jr || (jr = 1, (function(i) {
    Object.defineProperty(i, "__esModule", { value: !0 }), i.or = i.and = i.not = i.CodeGen = i.operators = i.varKinds = i.ValueScopeName = i.ValueScope = i.Scope = i.Name = i.regexpCode = i.stringify = i.getProperty = i.nil = i.strConcat = i.str = i._ = void 0;
    const A = Zi(), e = Pr();
    var t = Zi();
    Object.defineProperty(i, "_", { enumerable: !0, get: function() {
      return t._;
    } }), Object.defineProperty(i, "str", { enumerable: !0, get: function() {
      return t.str;
    } }), Object.defineProperty(i, "strConcat", { enumerable: !0, get: function() {
      return t.strConcat;
    } }), Object.defineProperty(i, "nil", { enumerable: !0, get: function() {
      return t.nil;
    } }), Object.defineProperty(i, "getProperty", { enumerable: !0, get: function() {
      return t.getProperty;
    } }), Object.defineProperty(i, "stringify", { enumerable: !0, get: function() {
      return t.stringify;
    } }), Object.defineProperty(i, "regexpCode", { enumerable: !0, get: function() {
      return t.regexpCode;
    } }), Object.defineProperty(i, "Name", { enumerable: !0, get: function() {
      return t.Name;
    } });
    var o = Pr();
    Object.defineProperty(i, "Scope", { enumerable: !0, get: function() {
      return o.Scope;
    } }), Object.defineProperty(i, "ValueScope", { enumerable: !0, get: function() {
      return o.ValueScope;
    } }), Object.defineProperty(i, "ValueScopeName", { enumerable: !0, get: function() {
      return o.ValueScopeName;
    } }), Object.defineProperty(i, "varKinds", { enumerable: !0, get: function() {
      return o.varKinds;
    } }), i.operators = {
      GT: new A._Code(">"),
      GTE: new A._Code(">="),
      LT: new A._Code("<"),
      LTE: new A._Code("<="),
      EQ: new A._Code("==="),
      NEQ: new A._Code("!=="),
      NOT: new A._Code("!"),
      OR: new A._Code("||"),
      AND: new A._Code("&&"),
      ADD: new A._Code("+")
    };
    class g {
      optimizeNodes() {
        return this;
      }
      optimizeNames(D, m) {
        return this;
      }
    }
    class r extends g {
      constructor(D, m, R) {
        super(), this.varKind = D, this.name = m, this.rhs = R;
      }
      render({ es5: D, _n: m }) {
        const R = D ? e.varKinds.var : this.varKind, j = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${R} ${this.name}${j};` + m;
      }
      optimizeNames(D, m) {
        if (D[this.name.str])
          return this.rhs && (this.rhs = W(this.rhs, D, m)), this;
      }
      get names() {
        return this.rhs instanceof A._CodeOrName ? this.rhs.names : {};
      }
    }
    class n extends g {
      constructor(D, m, R) {
        super(), this.lhs = D, this.rhs = m, this.sideEffects = R;
      }
      render({ _n: D }) {
        return `${this.lhs} = ${this.rhs};` + D;
      }
      optimizeNames(D, m) {
        if (!(this.lhs instanceof A.Name && !D[this.lhs.str] && !this.sideEffects))
          return this.rhs = W(this.rhs, D, m), this;
      }
      get names() {
        const D = this.lhs instanceof A.Name ? {} : { ...this.lhs.names };
        return V(D, this.rhs);
      }
    }
    class s extends n {
      constructor(D, m, R, j) {
        super(D, R, j), this.op = m;
      }
      render({ _n: D }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + D;
      }
    }
    class a extends g {
      constructor(D) {
        super(), this.label = D, this.names = {};
      }
      render({ _n: D }) {
        return `${this.label}:` + D;
      }
    }
    class I extends g {
      constructor(D) {
        super(), this.label = D, this.names = {};
      }
      render({ _n: D }) {
        return `break${this.label ? ` ${this.label}` : ""};` + D;
      }
    }
    class C extends g {
      constructor(D) {
        super(), this.error = D;
      }
      render({ _n: D }) {
        return `throw ${this.error};` + D;
      }
      get names() {
        return this.error.names;
      }
    }
    class c extends g {
      constructor(D) {
        super(), this.code = D;
      }
      render({ _n: D }) {
        return `${this.code};` + D;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(D, m) {
        return this.code = W(this.code, D, m), this;
      }
      get names() {
        return this.code instanceof A._CodeOrName ? this.code.names : {};
      }
    }
    class Q extends g {
      constructor(D = []) {
        super(), this.nodes = D;
      }
      render(D) {
        return this.nodes.reduce((m, R) => m + R.render(D), "");
      }
      optimizeNodes() {
        const { nodes: D } = this;
        let m = D.length;
        for (; m--; ) {
          const R = D[m].optimizeNodes();
          Array.isArray(R) ? D.splice(m, 1, ...R) : R ? D[m] = R : D.splice(m, 1);
        }
        return D.length > 0 ? this : void 0;
      }
      optimizeNames(D, m) {
        const { nodes: R } = this;
        let j = R.length;
        for (; j--; ) {
          const T = R[j];
          T.optimizeNames(D, m) || (QA(D, T.names), R.splice(j, 1));
        }
        return R.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((D, m) => P(D, m.names), {});
      }
    }
    class d extends Q {
      render(D) {
        return "{" + D._n + super.render(D) + "}" + D._n;
      }
    }
    class f extends Q {
    }
    class h extends d {
    }
    h.kind = "else";
    class l extends d {
      constructor(D, m) {
        super(m), this.condition = D;
      }
      render(D) {
        let m = `if(${this.condition})` + super.render(D);
        return this.else && (m += "else " + this.else.render(D)), m;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const D = this.condition;
        if (D === !0)
          return this.nodes;
        let m = this.else;
        if (m) {
          const R = m.optimizeNodes();
          m = this.else = Array.isArray(R) ? new h(R) : R;
        }
        if (m)
          return D === !1 ? m instanceof l ? m : m.nodes : this.nodes.length ? this : new l(aA(D), m instanceof l ? [m] : m.nodes);
        if (!(D === !1 || !this.nodes.length))
          return this;
      }
      optimizeNames(D, m) {
        var R;
        if (this.else = (R = this.else) === null || R === void 0 ? void 0 : R.optimizeNames(D, m), !!(super.optimizeNames(D, m) || this.else))
          return this.condition = W(this.condition, D, m), this;
      }
      get names() {
        const D = super.names;
        return V(D, this.condition), this.else && P(D, this.else.names), D;
      }
    }
    l.kind = "if";
    class B extends d {
    }
    B.kind = "for";
    class u extends B {
      constructor(D) {
        super(), this.iteration = D;
      }
      render(D) {
        return `for(${this.iteration})` + super.render(D);
      }
      optimizeNames(D, m) {
        if (super.optimizeNames(D, m))
          return this.iteration = W(this.iteration, D, m), this;
      }
      get names() {
        return P(super.names, this.iteration.names);
      }
    }
    class y extends B {
      constructor(D, m, R, j) {
        super(), this.varKind = D, this.name = m, this.from = R, this.to = j;
      }
      render(D) {
        const m = D.es5 ? e.varKinds.var : this.varKind, { name: R, from: j, to: T } = this;
        return `for(${m} ${R}=${j}; ${R}<${T}; ${R}++)` + super.render(D);
      }
      get names() {
        const D = V(super.names, this.from);
        return V(D, this.to);
      }
    }
    class E extends B {
      constructor(D, m, R, j) {
        super(), this.loop = D, this.varKind = m, this.name = R, this.iterable = j;
      }
      render(D) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(D);
      }
      optimizeNames(D, m) {
        if (super.optimizeNames(D, m))
          return this.iterable = W(this.iterable, D, m), this;
      }
      get names() {
        return P(super.names, this.iterable.names);
      }
    }
    class w extends d {
      constructor(D, m, R) {
        super(), this.name = D, this.args = m, this.async = R;
      }
      render(D) {
        return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(D);
      }
    }
    w.kind = "func";
    class p extends Q {
      render(D) {
        return "return " + super.render(D);
      }
    }
    p.kind = "return";
    class N extends d {
      render(D) {
        let m = "try" + super.render(D);
        return this.catch && (m += this.catch.render(D)), this.finally && (m += this.finally.render(D)), m;
      }
      optimizeNodes() {
        var D, m;
        return super.optimizeNodes(), (D = this.catch) === null || D === void 0 || D.optimizeNodes(), (m = this.finally) === null || m === void 0 || m.optimizeNodes(), this;
      }
      optimizeNames(D, m) {
        var R, j;
        return super.optimizeNames(D, m), (R = this.catch) === null || R === void 0 || R.optimizeNames(D, m), (j = this.finally) === null || j === void 0 || j.optimizeNames(D, m), this;
      }
      get names() {
        const D = super.names;
        return this.catch && P(D, this.catch.names), this.finally && P(D, this.finally.names), D;
      }
    }
    class v extends d {
      constructor(D) {
        super(), this.error = D;
      }
      render(D) {
        return `catch(${this.error})` + super.render(D);
      }
    }
    v.kind = "catch";
    class U extends d {
      render(D) {
        return "finally" + super.render(D);
      }
    }
    U.kind = "finally";
    class L {
      constructor(D, m = {}) {
        this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...m, _n: m.lines ? `
` : "" }, this._extScope = D, this._scope = new e.Scope({ parent: D }), this._nodes = [new f()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(D) {
        return this._scope.name(D);
      }
      // reserves unique name in the external scope
      scopeName(D) {
        return this._extScope.name(D);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(D, m) {
        const R = this._extScope.value(D, m);
        return (this._values[R.prefix] || (this._values[R.prefix] = /* @__PURE__ */ new Set())).add(R), R;
      }
      getScopeValue(D, m) {
        return this._extScope.getValue(D, m);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(D) {
        return this._extScope.scopeRefs(D, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(D, m, R, j) {
        const T = this._scope.toName(m);
        return R !== void 0 && j && (this._constants[T.str] = R), this._leafNode(new r(D, T, R)), T;
      }
      // `const` declaration (`var` in es5 mode)
      const(D, m, R) {
        return this._def(e.varKinds.const, D, m, R);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(D, m, R) {
        return this._def(e.varKinds.let, D, m, R);
      }
      // `var` declaration with optional assignment
      var(D, m, R) {
        return this._def(e.varKinds.var, D, m, R);
      }
      // assignment code
      assign(D, m, R) {
        return this._leafNode(new n(D, m, R));
      }
      // `+=` code
      add(D, m) {
        return this._leafNode(new s(D, i.operators.ADD, m));
      }
      // appends passed SafeExpr to code or executes Block
      code(D) {
        return typeof D == "function" ? D() : D !== A.nil && this._leafNode(new c(D)), this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...D) {
        const m = ["{"];
        for (const [R, j] of D)
          m.length > 1 && m.push(","), m.push(R), (R !== j || this.opts.es5) && (m.push(":"), (0, A.addCodeArg)(m, j));
        return m.push("}"), new A._Code(m);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(D, m, R) {
        if (this._blockNode(new l(D)), m && R)
          this.code(m).else().code(R).endIf();
        else if (m)
          this.code(m).endIf();
        else if (R)
          throw new Error('CodeGen: "else" body without "then" body');
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(D) {
        return this._elseNode(new l(D));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new h());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(l, h);
      }
      _for(D, m) {
        return this._blockNode(D), m && this.code(m).endFor(), this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(D, m) {
        return this._for(new u(D), m);
      }
      // `for` statement for a range of values
      forRange(D, m, R, j, T = this.opts.es5 ? e.varKinds.var : e.varKinds.let) {
        const eA = this._scope.toName(D);
        return this._for(new y(T, eA, m, R), () => j(eA));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(D, m, R, j = e.varKinds.const) {
        const T = this._scope.toName(D);
        if (this.opts.es5) {
          const eA = m instanceof A.Name ? m : this.var("_arr", m);
          return this.forRange("_i", 0, (0, A._)`${eA}.length`, (AA) => {
            this.var(T, (0, A._)`${eA}[${AA}]`), R(T);
          });
        }
        return this._for(new E("of", j, T, m), () => R(T));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(D, m, R, j = this.opts.es5 ? e.varKinds.var : e.varKinds.const) {
        if (this.opts.ownProperties)
          return this.forOf(D, (0, A._)`Object.keys(${m})`, R);
        const T = this._scope.toName(D);
        return this._for(new E("in", j, T, m), () => R(T));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(B);
      }
      // `label` statement
      label(D) {
        return this._leafNode(new a(D));
      }
      // `break` statement
      break(D) {
        return this._leafNode(new I(D));
      }
      // `return` statement
      return(D) {
        const m = new p();
        if (this._blockNode(m), this.code(D), m.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(p);
      }
      // `try` statement
      try(D, m, R) {
        if (!m && !R)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const j = new N();
        if (this._blockNode(j), this.code(D), m) {
          const T = this.name("e");
          this._currNode = j.catch = new v(T), m(T);
        }
        return R && (this._currNode = j.finally = new U(), this.code(R)), this._endBlockNode(v, U);
      }
      // `throw` statement
      throw(D) {
        return this._leafNode(new C(D));
      }
      // start self-balancing block
      block(D, m) {
        return this._blockStarts.push(this._nodes.length), D && this.code(D).endBlock(m), this;
      }
      // end the current self-balancing block
      endBlock(D) {
        const m = this._blockStarts.pop();
        if (m === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const R = this._nodes.length - m;
        if (R < 0 || D !== void 0 && R !== D)
          throw new Error(`CodeGen: wrong number of nodes: ${R} vs ${D} expected`);
        return this._nodes.length = m, this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(D, m = A.nil, R, j) {
        return this._blockNode(new w(D, m, R)), j && this.code(j).endFunc(), this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(w);
      }
      optimize(D = 1) {
        for (; D-- > 0; )
          this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
      }
      _leafNode(D) {
        return this._currNode.nodes.push(D), this;
      }
      _blockNode(D) {
        this._currNode.nodes.push(D), this._nodes.push(D);
      }
      _endBlockNode(D, m) {
        const R = this._currNode;
        if (R instanceof D || m && R instanceof m)
          return this._nodes.pop(), this;
        throw new Error(`CodeGen: not in block "${m ? `${D.kind}/${m.kind}` : D.kind}"`);
      }
      _elseNode(D) {
        const m = this._currNode;
        if (!(m instanceof l))
          throw new Error('CodeGen: "else" without "if"');
        return this._currNode = m.else = D, this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const D = this._nodes;
        return D[D.length - 1];
      }
      set _currNode(D) {
        const m = this._nodes;
        m[m.length - 1] = D;
      }
    }
    i.CodeGen = L;
    function P(K, D) {
      for (const m in D)
        K[m] = (K[m] || 0) + (D[m] || 0);
      return K;
    }
    function V(K, D) {
      return D instanceof A._CodeOrName ? P(K, D.names) : K;
    }
    function W(K, D, m) {
      if (K instanceof A.Name)
        return R(K);
      if (!j(K))
        return K;
      return new A._Code(K._items.reduce((T, eA) => (eA instanceof A.Name && (eA = R(eA)), eA instanceof A._Code ? T.push(...eA._items) : T.push(eA), T), []));
      function R(T) {
        const eA = m[T.str];
        return eA === void 0 || D[T.str] !== 1 ? T : (delete D[T.str], eA);
      }
      function j(T) {
        return T instanceof A._Code && T._items.some((eA) => eA instanceof A.Name && D[eA.str] === 1 && m[eA.str] !== void 0);
      }
    }
    function QA(K, D) {
      for (const m in D)
        K[m] = (K[m] || 0) - (D[m] || 0);
    }
    function aA(K) {
      return typeof K == "boolean" || typeof K == "number" || K === null ? !K : (0, A._)`!${H(K)}`;
    }
    i.not = aA;
    const wA = k(i.operators.AND);
    function gA(...K) {
      return K.reduce(wA);
    }
    i.and = gA;
    const kA = k(i.operators.OR);
    function q(...K) {
      return K.reduce(kA);
    }
    i.or = q;
    function k(K) {
      return (D, m) => D === A.nil ? m : m === A.nil ? D : (0, A._)`${H(D)} ${K} ${H(m)}`;
    }
    function H(K) {
      return K instanceof A.Name ? K : (0, A._)`(${K})`;
    }
  })(vo)), vo;
}
var iA = {}, Vr;
function nA() {
  if (Vr) return iA;
  Vr = 1, Object.defineProperty(iA, "__esModule", { value: !0 }), iA.checkStrictMode = iA.getErrorPath = iA.Type = iA.useFunc = iA.setEvaluated = iA.evaluatedPropsToName = iA.mergeEvaluated = iA.eachItem = iA.unescapeJsonPointer = iA.escapeJsonPointer = iA.escapeFragment = iA.unescapeFragment = iA.schemaRefOrVal = iA.schemaHasRulesButRef = iA.schemaHasRules = iA.checkUnknownRules = iA.alwaysValidSchema = iA.toHash = void 0;
  const i = tA(), A = Zi();
  function e(E) {
    const w = {};
    for (const p of E)
      w[p] = !0;
    return w;
  }
  iA.toHash = e;
  function t(E, w) {
    return typeof w == "boolean" ? w : Object.keys(w).length === 0 ? !0 : (o(E, w), !g(w, E.self.RULES.all));
  }
  iA.alwaysValidSchema = t;
  function o(E, w = E.schema) {
    const { opts: p, self: N } = E;
    if (!p.strictSchema || typeof w == "boolean")
      return;
    const v = N.RULES.keywords;
    for (const U in w)
      v[U] || y(E, `unknown keyword: "${U}"`);
  }
  iA.checkUnknownRules = o;
  function g(E, w) {
    if (typeof E == "boolean")
      return !E;
    for (const p in E)
      if (w[p])
        return !0;
    return !1;
  }
  iA.schemaHasRules = g;
  function r(E, w) {
    if (typeof E == "boolean")
      return !E;
    for (const p in E)
      if (p !== "$ref" && w.all[p])
        return !0;
    return !1;
  }
  iA.schemaHasRulesButRef = r;
  function n({ topSchemaRef: E, schemaPath: w }, p, N, v) {
    if (!v) {
      if (typeof p == "number" || typeof p == "boolean")
        return p;
      if (typeof p == "string")
        return (0, i._)`${p}`;
    }
    return (0, i._)`${E}${w}${(0, i.getProperty)(N)}`;
  }
  iA.schemaRefOrVal = n;
  function s(E) {
    return C(decodeURIComponent(E));
  }
  iA.unescapeFragment = s;
  function a(E) {
    return encodeURIComponent(I(E));
  }
  iA.escapeFragment = a;
  function I(E) {
    return typeof E == "number" ? `${E}` : E.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  iA.escapeJsonPointer = I;
  function C(E) {
    return E.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  iA.unescapeJsonPointer = C;
  function c(E, w) {
    if (Array.isArray(E))
      for (const p of E)
        w(p);
    else
      w(E);
  }
  iA.eachItem = c;
  function Q({ mergeNames: E, mergeToName: w, mergeValues: p, resultToName: N }) {
    return (v, U, L, P) => {
      const V = L === void 0 ? U : L instanceof i.Name ? (U instanceof i.Name ? E(v, U, L) : w(v, U, L), L) : U instanceof i.Name ? (w(v, L, U), U) : p(U, L);
      return P === i.Name && !(V instanceof i.Name) ? N(v, V) : V;
    };
  }
  iA.mergeEvaluated = {
    props: Q({
      mergeNames: (E, w, p) => E.if((0, i._)`${p} !== true && ${w} !== undefined`, () => {
        E.if((0, i._)`${w} === true`, () => E.assign(p, !0), () => E.assign(p, (0, i._)`${p} || {}`).code((0, i._)`Object.assign(${p}, ${w})`));
      }),
      mergeToName: (E, w, p) => E.if((0, i._)`${p} !== true`, () => {
        w === !0 ? E.assign(p, !0) : (E.assign(p, (0, i._)`${p} || {}`), f(E, p, w));
      }),
      mergeValues: (E, w) => E === !0 ? !0 : { ...E, ...w },
      resultToName: d
    }),
    items: Q({
      mergeNames: (E, w, p) => E.if((0, i._)`${p} !== true && ${w} !== undefined`, () => E.assign(p, (0, i._)`${w} === true ? true : ${p} > ${w} ? ${p} : ${w}`)),
      mergeToName: (E, w, p) => E.if((0, i._)`${p} !== true`, () => E.assign(p, w === !0 ? !0 : (0, i._)`${p} > ${w} ? ${p} : ${w}`)),
      mergeValues: (E, w) => E === !0 ? !0 : Math.max(E, w),
      resultToName: (E, w) => E.var("items", w)
    })
  };
  function d(E, w) {
    if (w === !0)
      return E.var("props", !0);
    const p = E.var("props", (0, i._)`{}`);
    return w !== void 0 && f(E, p, w), p;
  }
  iA.evaluatedPropsToName = d;
  function f(E, w, p) {
    Object.keys(p).forEach((N) => E.assign((0, i._)`${w}${(0, i.getProperty)(N)}`, !0));
  }
  iA.setEvaluated = f;
  const h = {};
  function l(E, w) {
    return E.scopeValue("func", {
      ref: w,
      code: h[w.code] || (h[w.code] = new A._Code(w.code))
    });
  }
  iA.useFunc = l;
  var B;
  (function(E) {
    E[E.Num = 0] = "Num", E[E.Str = 1] = "Str";
  })(B || (iA.Type = B = {}));
  function u(E, w, p) {
    if (E instanceof i.Name) {
      const N = w === B.Num;
      return p ? N ? (0, i._)`"[" + ${E} + "]"` : (0, i._)`"['" + ${E} + "']"` : N ? (0, i._)`"/" + ${E}` : (0, i._)`"/" + ${E}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return p ? (0, i.getProperty)(E).toString() : "/" + I(E);
  }
  iA.getErrorPath = u;
  function y(E, w, p = E.opts.strictSchema) {
    if (p) {
      if (w = `strict mode: ${w}`, p === !0)
        throw new Error(w);
      E.self.logger.warn(w);
    }
  }
  return iA.checkStrictMode = y, iA;
}
var Pt = {}, Wr;
function LA() {
  if (Wr) return Pt;
  Wr = 1, Object.defineProperty(Pt, "__esModule", { value: !0 });
  const i = tA(), A = {
    // validation function arguments
    data: new i.Name("data"),
    // data passed to validation function
    // args passed from referencing schema
    valCxt: new i.Name("valCxt"),
    // validation/data context - should not be used directly, it is destructured to the names below
    instancePath: new i.Name("instancePath"),
    parentData: new i.Name("parentData"),
    parentDataProperty: new i.Name("parentDataProperty"),
    rootData: new i.Name("rootData"),
    // root data - same as the data passed to the first/top validation function
    dynamicAnchors: new i.Name("dynamicAnchors"),
    // used to support recursiveRef and dynamicRef
    // function scoped variables
    vErrors: new i.Name("vErrors"),
    // null or array of validation errors
    errors: new i.Name("errors"),
    // counter of validation errors
    this: new i.Name("this"),
    // "globals"
    self: new i.Name("self"),
    scope: new i.Name("scope"),
    // JTD serialize/parse name for JSON string and position
    json: new i.Name("json"),
    jsonPos: new i.Name("jsonPos"),
    jsonLen: new i.Name("jsonLen"),
    jsonPart: new i.Name("jsonPart")
  };
  return Pt.default = A, Pt;
}
var zr;
function Co() {
  return zr || (zr = 1, (function(i) {
    Object.defineProperty(i, "__esModule", { value: !0 }), i.extendErrors = i.resetErrorsCount = i.reportExtraError = i.reportError = i.keyword$DataError = i.keywordError = void 0;
    const A = tA(), e = nA(), t = LA();
    i.keywordError = {
      message: ({ keyword: h }) => (0, A.str)`must pass "${h}" keyword validation`
    }, i.keyword$DataError = {
      message: ({ keyword: h, schemaType: l }) => l ? (0, A.str)`"${h}" keyword must be ${l} ($data)` : (0, A.str)`"${h}" keyword is invalid ($data)`
    };
    function o(h, l = i.keywordError, B, u) {
      const { it: y } = h, { gen: E, compositeRule: w, allErrors: p } = y, N = C(h, l, B);
      u ?? (w || p) ? s(E, N) : a(y, (0, A._)`[${N}]`);
    }
    i.reportError = o;
    function g(h, l = i.keywordError, B) {
      const { it: u } = h, { gen: y, compositeRule: E, allErrors: w } = u, p = C(h, l, B);
      s(y, p), E || w || a(u, t.default.vErrors);
    }
    i.reportExtraError = g;
    function r(h, l) {
      h.assign(t.default.errors, l), h.if((0, A._)`${t.default.vErrors} !== null`, () => h.if(l, () => h.assign((0, A._)`${t.default.vErrors}.length`, l), () => h.assign(t.default.vErrors, null)));
    }
    i.resetErrorsCount = r;
    function n({ gen: h, keyword: l, schemaValue: B, data: u, errsCount: y, it: E }) {
      if (y === void 0)
        throw new Error("ajv implementation error");
      const w = h.name("err");
      h.forRange("i", y, t.default.errors, (p) => {
        h.const(w, (0, A._)`${t.default.vErrors}[${p}]`), h.if((0, A._)`${w}.instancePath === undefined`, () => h.assign((0, A._)`${w}.instancePath`, (0, A.strConcat)(t.default.instancePath, E.errorPath))), h.assign((0, A._)`${w}.schemaPath`, (0, A.str)`${E.errSchemaPath}/${l}`), E.opts.verbose && (h.assign((0, A._)`${w}.schema`, B), h.assign((0, A._)`${w}.data`, u));
      });
    }
    i.extendErrors = n;
    function s(h, l) {
      const B = h.const("err", l);
      h.if((0, A._)`${t.default.vErrors} === null`, () => h.assign(t.default.vErrors, (0, A._)`[${B}]`), (0, A._)`${t.default.vErrors}.push(${B})`), h.code((0, A._)`${t.default.errors}++`);
    }
    function a(h, l) {
      const { gen: B, validateName: u, schemaEnv: y } = h;
      y.$async ? B.throw((0, A._)`new ${h.ValidationError}(${l})`) : (B.assign((0, A._)`${u}.errors`, l), B.return(!1));
    }
    const I = {
      keyword: new A.Name("keyword"),
      schemaPath: new A.Name("schemaPath"),
      // also used in JTD errors
      params: new A.Name("params"),
      propertyName: new A.Name("propertyName"),
      message: new A.Name("message"),
      schema: new A.Name("schema"),
      parentSchema: new A.Name("parentSchema")
    };
    function C(h, l, B) {
      const { createErrors: u } = h.it;
      return u === !1 ? (0, A._)`{}` : c(h, l, B);
    }
    function c(h, l, B = {}) {
      const { gen: u, it: y } = h, E = [
        Q(y, B),
        d(h, B)
      ];
      return f(h, l, E), u.object(...E);
    }
    function Q({ errorPath: h }, { instancePath: l }) {
      const B = l ? (0, A.str)`${h}${(0, e.getErrorPath)(l, e.Type.Str)}` : h;
      return [t.default.instancePath, (0, A.strConcat)(t.default.instancePath, B)];
    }
    function d({ keyword: h, it: { errSchemaPath: l } }, { schemaPath: B, parentSchema: u }) {
      let y = u ? l : (0, A.str)`${l}/${h}`;
      return B && (y = (0, A.str)`${y}${(0, e.getErrorPath)(B, e.Type.Str)}`), [I.schemaPath, y];
    }
    function f(h, { params: l, message: B }, u) {
      const { keyword: y, data: E, schemaValue: w, it: p } = h, { opts: N, propertyName: v, topSchemaRef: U, schemaPath: L } = p;
      u.push([I.keyword, y], [I.params, typeof l == "function" ? l(h) : l || (0, A._)`{}`]), N.messages && u.push([I.message, typeof B == "function" ? B(h) : B]), N.verbose && u.push([I.schema, w], [I.parentSchema, (0, A._)`${U}${L}`], [t.default.data, E]), v && u.push([I.propertyName, v]);
    }
  })(Yo)), Yo;
}
var $r;
function uw() {
  if ($r) return ce;
  $r = 1, Object.defineProperty(ce, "__esModule", { value: !0 }), ce.boolOrEmptySchema = ce.topBoolOrEmptySchema = void 0;
  const i = Co(), A = tA(), e = LA(), t = {
    message: "boolean schema is false"
  };
  function o(n) {
    const { gen: s, schema: a, validateName: I } = n;
    a === !1 ? r(n, !1) : typeof a == "object" && a.$async === !0 ? s.return(e.default.data) : (s.assign((0, A._)`${I}.errors`, null), s.return(!0));
  }
  ce.topBoolOrEmptySchema = o;
  function g(n, s) {
    const { gen: a, schema: I } = n;
    I === !1 ? (a.var(s, !1), r(n)) : a.var(s, !0);
  }
  ce.boolOrEmptySchema = g;
  function r(n, s) {
    const { gen: a, data: I } = n, C = {
      gen: a,
      keyword: "false schema",
      data: I,
      schema: !1,
      schemaCode: !1,
      schemaValue: !1,
      params: {},
      it: n
    };
    (0, i.reportError)(C, t, void 0, s);
  }
  return ce;
}
var uA = {}, Be = {}, Zr;
function Pa() {
  if (Zr) return Be;
  Zr = 1, Object.defineProperty(Be, "__esModule", { value: !0 }), Be.getRules = Be.isJSONType = void 0;
  const i = ["string", "number", "integer", "boolean", "null", "object", "array"], A = new Set(i);
  function e(o) {
    return typeof o == "string" && A.has(o);
  }
  Be.isJSONType = e;
  function t() {
    const o = {
      number: { type: "number", rules: [] },
      string: { type: "string", rules: [] },
      array: { type: "array", rules: [] },
      object: { type: "object", rules: [] }
    };
    return {
      types: { ...o, integer: !0, boolean: !0, null: !0 },
      rules: [{ rules: [] }, o.number, o.string, o.array, o.object],
      post: { rules: [] },
      all: {},
      keywords: {}
    };
  }
  return Be.getRules = t, Be;
}
var $A = {}, _r;
function ja() {
  if (_r) return $A;
  _r = 1, Object.defineProperty($A, "__esModule", { value: !0 }), $A.shouldUseRule = $A.shouldUseGroup = $A.schemaHasRulesForType = void 0;
  function i({ schema: t, self: o }, g) {
    const r = o.RULES.types[g];
    return r && r !== !0 && A(t, r);
  }
  $A.schemaHasRulesForType = i;
  function A(t, o) {
    return o.rules.some((g) => e(t, g));
  }
  $A.shouldUseGroup = A;
  function e(t, o) {
    var g;
    return t[o.keyword] !== void 0 || ((g = o.definition.implements) === null || g === void 0 ? void 0 : g.some((r) => t[r] !== void 0));
  }
  return $A.shouldUseRule = e, $A;
}
var Xr;
function _i() {
  if (Xr) return uA;
  Xr = 1, Object.defineProperty(uA, "__esModule", { value: !0 }), uA.reportTypeError = uA.checkDataTypes = uA.checkDataType = uA.coerceAndCheckDataType = uA.getJSONTypes = uA.getSchemaTypes = uA.DataType = void 0;
  const i = Pa(), A = ja(), e = Co(), t = tA(), o = nA();
  var g;
  (function(B) {
    B[B.Correct = 0] = "Correct", B[B.Wrong = 1] = "Wrong";
  })(g || (uA.DataType = g = {}));
  function r(B) {
    const u = n(B.type);
    if (u.includes("null")) {
      if (B.nullable === !1)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!u.length && B.nullable !== void 0)
        throw new Error('"nullable" cannot be used without "type"');
      B.nullable === !0 && u.push("null");
    }
    return u;
  }
  uA.getSchemaTypes = r;
  function n(B) {
    const u = Array.isArray(B) ? B : B ? [B] : [];
    if (u.every(i.isJSONType))
      return u;
    throw new Error("type must be JSONType or JSONType[]: " + u.join(","));
  }
  uA.getJSONTypes = n;
  function s(B, u) {
    const { gen: y, data: E, opts: w } = B, p = I(u, w.coerceTypes), N = u.length > 0 && !(p.length === 0 && u.length === 1 && (0, A.schemaHasRulesForType)(B, u[0]));
    if (N) {
      const v = d(u, E, w.strictNumbers, g.Wrong);
      y.if(v, () => {
        p.length ? C(B, u, p) : h(B);
      });
    }
    return N;
  }
  uA.coerceAndCheckDataType = s;
  const a = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
  function I(B, u) {
    return u ? B.filter((y) => a.has(y) || u === "array" && y === "array") : [];
  }
  function C(B, u, y) {
    const { gen: E, data: w, opts: p } = B, N = E.let("dataType", (0, t._)`typeof ${w}`), v = E.let("coerced", (0, t._)`undefined`);
    p.coerceTypes === "array" && E.if((0, t._)`${N} == 'object' && Array.isArray(${w}) && ${w}.length == 1`, () => E.assign(w, (0, t._)`${w}[0]`).assign(N, (0, t._)`typeof ${w}`).if(d(u, w, p.strictNumbers), () => E.assign(v, w))), E.if((0, t._)`${v} !== undefined`);
    for (const L of y)
      (a.has(L) || L === "array" && p.coerceTypes === "array") && U(L);
    E.else(), h(B), E.endIf(), E.if((0, t._)`${v} !== undefined`, () => {
      E.assign(w, v), c(B, v);
    });
    function U(L) {
      switch (L) {
        case "string":
          E.elseIf((0, t._)`${N} == "number" || ${N} == "boolean"`).assign(v, (0, t._)`"" + ${w}`).elseIf((0, t._)`${w} === null`).assign(v, (0, t._)`""`);
          return;
        case "number":
          E.elseIf((0, t._)`${N} == "boolean" || ${w} === null
              || (${N} == "string" && ${w} && ${w} == +${w})`).assign(v, (0, t._)`+${w}`);
          return;
        case "integer":
          E.elseIf((0, t._)`${N} === "boolean" || ${w} === null
              || (${N} === "string" && ${w} && ${w} == +${w} && !(${w} % 1))`).assign(v, (0, t._)`+${w}`);
          return;
        case "boolean":
          E.elseIf((0, t._)`${w} === "false" || ${w} === 0 || ${w} === null`).assign(v, !1).elseIf((0, t._)`${w} === "true" || ${w} === 1`).assign(v, !0);
          return;
        case "null":
          E.elseIf((0, t._)`${w} === "" || ${w} === 0 || ${w} === false`), E.assign(v, null);
          return;
        case "array":
          E.elseIf((0, t._)`${N} === "string" || ${N} === "number"
              || ${N} === "boolean" || ${w} === null`).assign(v, (0, t._)`[${w}]`);
      }
    }
  }
  function c({ gen: B, parentData: u, parentDataProperty: y }, E) {
    B.if((0, t._)`${u} !== undefined`, () => B.assign((0, t._)`${u}[${y}]`, E));
  }
  function Q(B, u, y, E = g.Correct) {
    const w = E === g.Correct ? t.operators.EQ : t.operators.NEQ;
    let p;
    switch (B) {
      case "null":
        return (0, t._)`${u} ${w} null`;
      case "array":
        p = (0, t._)`Array.isArray(${u})`;
        break;
      case "object":
        p = (0, t._)`${u} && typeof ${u} == "object" && !Array.isArray(${u})`;
        break;
      case "integer":
        p = N((0, t._)`!(${u} % 1) && !isNaN(${u})`);
        break;
      case "number":
        p = N();
        break;
      default:
        return (0, t._)`typeof ${u} ${w} ${B}`;
    }
    return E === g.Correct ? p : (0, t.not)(p);
    function N(v = t.nil) {
      return (0, t.and)((0, t._)`typeof ${u} == "number"`, v, y ? (0, t._)`isFinite(${u})` : t.nil);
    }
  }
  uA.checkDataType = Q;
  function d(B, u, y, E) {
    if (B.length === 1)
      return Q(B[0], u, y, E);
    let w;
    const p = (0, o.toHash)(B);
    if (p.array && p.object) {
      const N = (0, t._)`typeof ${u} != "object"`;
      w = p.null ? N : (0, t._)`!${u} || ${N}`, delete p.null, delete p.array, delete p.object;
    } else
      w = t.nil;
    p.number && delete p.integer;
    for (const N in p)
      w = (0, t.and)(w, Q(N, u, y, E));
    return w;
  }
  uA.checkDataTypes = d;
  const f = {
    message: ({ schema: B }) => `must be ${B}`,
    params: ({ schema: B, schemaValue: u }) => typeof B == "string" ? (0, t._)`{type: ${B}}` : (0, t._)`{type: ${u}}`
  };
  function h(B) {
    const u = l(B);
    (0, e.reportError)(u, f);
  }
  uA.reportTypeError = h;
  function l(B) {
    const { gen: u, data: y, schema: E } = B, w = (0, o.schemaRefOrVal)(B, E, "type");
    return {
      gen: u,
      keyword: "type",
      data: y,
      schema: E.type,
      schemaCode: w,
      schemaValue: w,
      parentSchema: E,
      params: {},
      it: B
    };
  }
  return uA;
}
var rt = {}, An;
function fw() {
  if (An) return rt;
  An = 1, Object.defineProperty(rt, "__esModule", { value: !0 }), rt.assignDefaults = void 0;
  const i = tA(), A = nA();
  function e(o, g) {
    const { properties: r, items: n } = o.schema;
    if (g === "object" && r)
      for (const s in r)
        t(o, s, r[s].default);
    else g === "array" && Array.isArray(n) && n.forEach((s, a) => t(o, a, s.default));
  }
  rt.assignDefaults = e;
  function t(o, g, r) {
    const { gen: n, compositeRule: s, data: a, opts: I } = o;
    if (r === void 0)
      return;
    const C = (0, i._)`${a}${(0, i.getProperty)(g)}`;
    if (s) {
      (0, A.checkStrictMode)(o, `default is ignored for: ${C}`);
      return;
    }
    let c = (0, i._)`${C} === undefined`;
    I.useDefaults === "empty" && (c = (0, i._)`${c} || ${C} === null || ${C} === ""`), n.if(c, (0, i._)`${C} = ${(0, i.stringify)(r)}`);
  }
  return rt;
}
var UA = {}, CA = {}, en;
function xA() {
  if (en) return CA;
  en = 1, Object.defineProperty(CA, "__esModule", { value: !0 }), CA.validateUnion = CA.validateArray = CA.usePattern = CA.callValidateCode = CA.schemaProperties = CA.allSchemaProperties = CA.noPropertyInData = CA.propertyInData = CA.isOwnProperty = CA.hasPropFunc = CA.reportMissingProp = CA.checkMissingProp = CA.checkReportMissingProp = void 0;
  const i = tA(), A = nA(), e = LA(), t = nA();
  function o(B, u) {
    const { gen: y, data: E, it: w } = B;
    y.if(I(y, E, u, w.opts.ownProperties), () => {
      B.setParams({ missingProperty: (0, i._)`${u}` }, !0), B.error();
    });
  }
  CA.checkReportMissingProp = o;
  function g({ gen: B, data: u, it: { opts: y } }, E, w) {
    return (0, i.or)(...E.map((p) => (0, i.and)(I(B, u, p, y.ownProperties), (0, i._)`${w} = ${p}`)));
  }
  CA.checkMissingProp = g;
  function r(B, u) {
    B.setParams({ missingProperty: u }, !0), B.error();
  }
  CA.reportMissingProp = r;
  function n(B) {
    return B.scopeValue("func", {
      // eslint-disable-next-line @typescript-eslint/unbound-method
      ref: Object.prototype.hasOwnProperty,
      code: (0, i._)`Object.prototype.hasOwnProperty`
    });
  }
  CA.hasPropFunc = n;
  function s(B, u, y) {
    return (0, i._)`${n(B)}.call(${u}, ${y})`;
  }
  CA.isOwnProperty = s;
  function a(B, u, y, E) {
    const w = (0, i._)`${u}${(0, i.getProperty)(y)} !== undefined`;
    return E ? (0, i._)`${w} && ${s(B, u, y)}` : w;
  }
  CA.propertyInData = a;
  function I(B, u, y, E) {
    const w = (0, i._)`${u}${(0, i.getProperty)(y)} === undefined`;
    return E ? (0, i.or)(w, (0, i.not)(s(B, u, y))) : w;
  }
  CA.noPropertyInData = I;
  function C(B) {
    return B ? Object.keys(B).filter((u) => u !== "__proto__") : [];
  }
  CA.allSchemaProperties = C;
  function c(B, u) {
    return C(u).filter((y) => !(0, A.alwaysValidSchema)(B, u[y]));
  }
  CA.schemaProperties = c;
  function Q({ schemaCode: B, data: u, it: { gen: y, topSchemaRef: E, schemaPath: w, errorPath: p }, it: N }, v, U, L) {
    const P = L ? (0, i._)`${B}, ${u}, ${E}${w}` : u, V = [
      [e.default.instancePath, (0, i.strConcat)(e.default.instancePath, p)],
      [e.default.parentData, N.parentData],
      [e.default.parentDataProperty, N.parentDataProperty],
      [e.default.rootData, e.default.rootData]
    ];
    N.opts.dynamicRef && V.push([e.default.dynamicAnchors, e.default.dynamicAnchors]);
    const W = (0, i._)`${P}, ${y.object(...V)}`;
    return U !== i.nil ? (0, i._)`${v}.call(${U}, ${W})` : (0, i._)`${v}(${W})`;
  }
  CA.callValidateCode = Q;
  const d = (0, i._)`new RegExp`;
  function f({ gen: B, it: { opts: u } }, y) {
    const E = u.unicodeRegExp ? "u" : "", { regExp: w } = u.code, p = w(y, E);
    return B.scopeValue("pattern", {
      key: p.toString(),
      ref: p,
      code: (0, i._)`${w.code === "new RegExp" ? d : (0, t.useFunc)(B, w)}(${y}, ${E})`
    });
  }
  CA.usePattern = f;
  function h(B) {
    const { gen: u, data: y, keyword: E, it: w } = B, p = u.name("valid");
    if (w.allErrors) {
      const v = u.let("valid", !0);
      return N(() => u.assign(v, !1)), v;
    }
    return u.var(p, !0), N(() => u.break()), p;
    function N(v) {
      const U = u.const("len", (0, i._)`${y}.length`);
      u.forRange("i", 0, U, (L) => {
        B.subschema({
          keyword: E,
          dataProp: L,
          dataPropType: A.Type.Num
        }, p), u.if((0, i.not)(p), v);
      });
    }
  }
  CA.validateArray = h;
  function l(B) {
    const { gen: u, schema: y, keyword: E, it: w } = B;
    if (!Array.isArray(y))
      throw new Error("ajv implementation error");
    if (y.some((U) => (0, A.alwaysValidSchema)(w, U)) && !w.opts.unevaluated)
      return;
    const N = u.let("valid", !1), v = u.name("_valid");
    u.block(() => y.forEach((U, L) => {
      const P = B.subschema({
        keyword: E,
        schemaProp: L,
        compositeRule: !0
      }, v);
      u.assign(N, (0, i._)`${N} || ${v}`), B.mergeValidEvaluated(P, v) || u.if((0, i.not)(N));
    })), B.result(N, () => B.reset(), () => B.error(!0));
  }
  return CA.validateUnion = l, CA;
}
var tn;
function ww() {
  if (tn) return UA;
  tn = 1, Object.defineProperty(UA, "__esModule", { value: !0 }), UA.validateKeywordUsage = UA.validSchemaType = UA.funcKeywordCode = UA.macroKeywordCode = void 0;
  const i = tA(), A = LA(), e = xA(), t = Co();
  function o(c, Q) {
    const { gen: d, keyword: f, schema: h, parentSchema: l, it: B } = c, u = Q.macro.call(B.self, h, l, B), y = a(d, f, u);
    B.opts.validateSchema !== !1 && B.self.validateSchema(u, !0);
    const E = d.name("valid");
    c.subschema({
      schema: u,
      schemaPath: i.nil,
      errSchemaPath: `${B.errSchemaPath}/${f}`,
      topSchemaRef: y,
      compositeRule: !0
    }, E), c.pass(E, () => c.error(!0));
  }
  UA.macroKeywordCode = o;
  function g(c, Q) {
    var d;
    const { gen: f, keyword: h, schema: l, parentSchema: B, $data: u, it: y } = c;
    s(y, Q);
    const E = !u && Q.compile ? Q.compile.call(y.self, l, B, y) : Q.validate, w = a(f, h, E), p = f.let("valid");
    c.block$data(p, N), c.ok((d = Q.valid) !== null && d !== void 0 ? d : p);
    function N() {
      if (Q.errors === !1)
        L(), Q.modifying && r(c), P(() => c.error());
      else {
        const V = Q.async ? v() : U();
        Q.modifying && r(c), P(() => n(c, V));
      }
    }
    function v() {
      const V = f.let("ruleErrs", null);
      return f.try(() => L((0, i._)`await `), (W) => f.assign(p, !1).if((0, i._)`${W} instanceof ${y.ValidationError}`, () => f.assign(V, (0, i._)`${W}.errors`), () => f.throw(W))), V;
    }
    function U() {
      const V = (0, i._)`${w}.errors`;
      return f.assign(V, null), L(i.nil), V;
    }
    function L(V = Q.async ? (0, i._)`await ` : i.nil) {
      const W = y.opts.passContext ? A.default.this : A.default.self, QA = !("compile" in Q && !u || Q.schema === !1);
      f.assign(p, (0, i._)`${V}${(0, e.callValidateCode)(c, w, W, QA)}`, Q.modifying);
    }
    function P(V) {
      var W;
      f.if((0, i.not)((W = Q.valid) !== null && W !== void 0 ? W : p), V);
    }
  }
  UA.funcKeywordCode = g;
  function r(c) {
    const { gen: Q, data: d, it: f } = c;
    Q.if(f.parentData, () => Q.assign(d, (0, i._)`${f.parentData}[${f.parentDataProperty}]`));
  }
  function n(c, Q) {
    const { gen: d } = c;
    d.if((0, i._)`Array.isArray(${Q})`, () => {
      d.assign(A.default.vErrors, (0, i._)`${A.default.vErrors} === null ? ${Q} : ${A.default.vErrors}.concat(${Q})`).assign(A.default.errors, (0, i._)`${A.default.vErrors}.length`), (0, t.extendErrors)(c);
    }, () => c.error());
  }
  function s({ schemaEnv: c }, Q) {
    if (Q.async && !c.$async)
      throw new Error("async keyword in sync schema");
  }
  function a(c, Q, d) {
    if (d === void 0)
      throw new Error(`keyword "${Q}" failed to compile`);
    return c.scopeValue("keyword", typeof d == "function" ? { ref: d } : { ref: d, code: (0, i.stringify)(d) });
  }
  function I(c, Q, d = !1) {
    return !Q.length || Q.some((f) => f === "array" ? Array.isArray(c) : f === "object" ? c && typeof c == "object" && !Array.isArray(c) : typeof c == f || d && typeof c > "u");
  }
  UA.validSchemaType = I;
  function C({ schema: c, opts: Q, self: d, errSchemaPath: f }, h, l) {
    if (Array.isArray(h.keyword) ? !h.keyword.includes(l) : h.keyword !== l)
      throw new Error("ajv implementation error");
    const B = h.dependencies;
    if (B?.some((u) => !Object.prototype.hasOwnProperty.call(c, u)))
      throw new Error(`parent schema must have dependencies of ${l}: ${B.join(",")}`);
    if (h.validateSchema && !h.validateSchema(c[l])) {
      const y = `keyword "${l}" value is invalid at path "${f}": ` + d.errorsText(h.validateSchema.errors);
      if (Q.validateSchema === "log")
        d.logger.error(y);
      else
        throw new Error(y);
    }
  }
  return UA.validateKeywordUsage = C, UA;
}
var ZA = {}, on;
function yw() {
  if (on) return ZA;
  on = 1, Object.defineProperty(ZA, "__esModule", { value: !0 }), ZA.extendSubschemaMode = ZA.extendSubschemaData = ZA.getSubschema = void 0;
  const i = tA(), A = nA();
  function e(g, { keyword: r, schemaProp: n, schema: s, schemaPath: a, errSchemaPath: I, topSchemaRef: C }) {
    if (r !== void 0 && s !== void 0)
      throw new Error('both "keyword" and "schema" passed, only one allowed');
    if (r !== void 0) {
      const c = g.schema[r];
      return n === void 0 ? {
        schema: c,
        schemaPath: (0, i._)`${g.schemaPath}${(0, i.getProperty)(r)}`,
        errSchemaPath: `${g.errSchemaPath}/${r}`
      } : {
        schema: c[n],
        schemaPath: (0, i._)`${g.schemaPath}${(0, i.getProperty)(r)}${(0, i.getProperty)(n)}`,
        errSchemaPath: `${g.errSchemaPath}/${r}/${(0, A.escapeFragment)(n)}`
      };
    }
    if (s !== void 0) {
      if (a === void 0 || I === void 0 || C === void 0)
        throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
      return {
        schema: s,
        schemaPath: a,
        topSchemaRef: C,
        errSchemaPath: I
      };
    }
    throw new Error('either "keyword" or "schema" must be passed');
  }
  ZA.getSubschema = e;
  function t(g, r, { dataProp: n, dataPropType: s, data: a, dataTypes: I, propertyName: C }) {
    if (a !== void 0 && n !== void 0)
      throw new Error('both "data" and "dataProp" passed, only one allowed');
    const { gen: c } = r;
    if (n !== void 0) {
      const { errorPath: d, dataPathArr: f, opts: h } = r, l = c.let("data", (0, i._)`${r.data}${(0, i.getProperty)(n)}`, !0);
      Q(l), g.errorPath = (0, i.str)`${d}${(0, A.getErrorPath)(n, s, h.jsPropertySyntax)}`, g.parentDataProperty = (0, i._)`${n}`, g.dataPathArr = [...f, g.parentDataProperty];
    }
    if (a !== void 0) {
      const d = a instanceof i.Name ? a : c.let("data", a, !0);
      Q(d), C !== void 0 && (g.propertyName = C);
    }
    I && (g.dataTypes = I);
    function Q(d) {
      g.data = d, g.dataLevel = r.dataLevel + 1, g.dataTypes = [], r.definedProperties = /* @__PURE__ */ new Set(), g.parentData = r.data, g.dataNames = [...r.dataNames, d];
    }
  }
  ZA.extendSubschemaData = t;
  function o(g, { jtdDiscriminator: r, jtdMetadata: n, compositeRule: s, createErrors: a, allErrors: I }) {
    s !== void 0 && (g.compositeRule = s), a !== void 0 && (g.createErrors = a), I !== void 0 && (g.allErrors = I), g.jtdDiscriminator = r, g.jtdMetadata = n;
  }
  return ZA.extendSubschemaMode = o, ZA;
}
var yA = {}, Ho, gn;
function Va() {
  return gn || (gn = 1, Ho = function i(A, e) {
    if (A === e) return !0;
    if (A && e && typeof A == "object" && typeof e == "object") {
      if (A.constructor !== e.constructor) return !1;
      var t, o, g;
      if (Array.isArray(A)) {
        if (t = A.length, t != e.length) return !1;
        for (o = t; o-- !== 0; )
          if (!i(A[o], e[o])) return !1;
        return !0;
      }
      if (A.constructor === RegExp) return A.source === e.source && A.flags === e.flags;
      if (A.valueOf !== Object.prototype.valueOf) return A.valueOf() === e.valueOf();
      if (A.toString !== Object.prototype.toString) return A.toString() === e.toString();
      if (g = Object.keys(A), t = g.length, t !== Object.keys(e).length) return !1;
      for (o = t; o-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(e, g[o])) return !1;
      for (o = t; o-- !== 0; ) {
        var r = g[o];
        if (!i(A[r], e[r])) return !1;
      }
      return !0;
    }
    return A !== A && e !== e;
  }), Ho;
}
var qo = { exports: {} }, rn;
function pw() {
  if (rn) return qo.exports;
  rn = 1;
  var i = qo.exports = function(t, o, g) {
    typeof o == "function" && (g = o, o = {}), g = o.cb || g;
    var r = typeof g == "function" ? g : g.pre || function() {
    }, n = g.post || function() {
    };
    A(o, r, n, t, "", t);
  };
  i.keywords = {
    additionalItems: !0,
    items: !0,
    contains: !0,
    additionalProperties: !0,
    propertyNames: !0,
    not: !0,
    if: !0,
    then: !0,
    else: !0
  }, i.arrayKeywords = {
    items: !0,
    allOf: !0,
    anyOf: !0,
    oneOf: !0
  }, i.propsKeywords = {
    $defs: !0,
    definitions: !0,
    properties: !0,
    patternProperties: !0,
    dependencies: !0
  }, i.skipKeywords = {
    default: !0,
    enum: !0,
    const: !0,
    required: !0,
    maximum: !0,
    minimum: !0,
    exclusiveMaximum: !0,
    exclusiveMinimum: !0,
    multipleOf: !0,
    maxLength: !0,
    minLength: !0,
    pattern: !0,
    format: !0,
    maxItems: !0,
    minItems: !0,
    uniqueItems: !0,
    maxProperties: !0,
    minProperties: !0
  };
  function A(t, o, g, r, n, s, a, I, C, c) {
    if (r && typeof r == "object" && !Array.isArray(r)) {
      o(r, n, s, a, I, C, c);
      for (var Q in r) {
        var d = r[Q];
        if (Array.isArray(d)) {
          if (Q in i.arrayKeywords)
            for (var f = 0; f < d.length; f++)
              A(t, o, g, d[f], n + "/" + Q + "/" + f, s, n, Q, r, f);
        } else if (Q in i.propsKeywords) {
          if (d && typeof d == "object")
            for (var h in d)
              A(t, o, g, d[h], n + "/" + Q + "/" + e(h), s, n, Q, r, h);
        } else (Q in i.keywords || t.allKeys && !(Q in i.skipKeywords)) && A(t, o, g, d, n + "/" + Q, s, n, Q, r);
      }
      g(r, n, s, a, I, C, c);
    }
  }
  function e(t) {
    return t.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  return qo.exports;
}
var nn;
function co() {
  if (nn) return yA;
  nn = 1, Object.defineProperty(yA, "__esModule", { value: !0 }), yA.getSchemaRefs = yA.resolveUrl = yA.normalizeId = yA._getFullPath = yA.getFullPath = yA.inlineRef = void 0;
  const i = nA(), A = Va(), e = pw(), t = /* @__PURE__ */ new Set([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum",
    "const"
  ]);
  function o(f, h = !0) {
    return typeof f == "boolean" ? !0 : h === !0 ? !r(f) : h ? n(f) <= h : !1;
  }
  yA.inlineRef = o;
  const g = /* @__PURE__ */ new Set([
    "$ref",
    "$recursiveRef",
    "$recursiveAnchor",
    "$dynamicRef",
    "$dynamicAnchor"
  ]);
  function r(f) {
    for (const h in f) {
      if (g.has(h))
        return !0;
      const l = f[h];
      if (Array.isArray(l) && l.some(r) || typeof l == "object" && r(l))
        return !0;
    }
    return !1;
  }
  function n(f) {
    let h = 0;
    for (const l in f) {
      if (l === "$ref")
        return 1 / 0;
      if (h++, !t.has(l) && (typeof f[l] == "object" && (0, i.eachItem)(f[l], (B) => h += n(B)), h === 1 / 0))
        return 1 / 0;
    }
    return h;
  }
  function s(f, h = "", l) {
    l !== !1 && (h = C(h));
    const B = f.parse(h);
    return a(f, B);
  }
  yA.getFullPath = s;
  function a(f, h) {
    return f.serialize(h).split("#")[0] + "#";
  }
  yA._getFullPath = a;
  const I = /#\/?$/;
  function C(f) {
    return f ? f.replace(I, "") : "";
  }
  yA.normalizeId = C;
  function c(f, h, l) {
    return l = C(l), f.resolve(h, l);
  }
  yA.resolveUrl = c;
  const Q = /^[a-z_][-a-z0-9._]*$/i;
  function d(f, h) {
    if (typeof f == "boolean")
      return {};
    const { schemaId: l, uriResolver: B } = this.opts, u = C(f[l] || h), y = { "": u }, E = s(B, u, !1), w = {}, p = /* @__PURE__ */ new Set();
    return e(f, { allKeys: !0 }, (U, L, P, V) => {
      if (V === void 0)
        return;
      const W = E + L;
      let QA = y[V];
      typeof U[l] == "string" && (QA = aA.call(this, U[l])), wA.call(this, U.$anchor), wA.call(this, U.$dynamicAnchor), y[L] = QA;
      function aA(gA) {
        const kA = this.opts.uriResolver.resolve;
        if (gA = C(QA ? kA(QA, gA) : gA), p.has(gA))
          throw v(gA);
        p.add(gA);
        let q = this.refs[gA];
        return typeof q == "string" && (q = this.refs[q]), typeof q == "object" ? N(U, q.schema, gA) : gA !== C(W) && (gA[0] === "#" ? (N(U, w[gA], gA), w[gA] = U) : this.refs[gA] = W), gA;
      }
      function wA(gA) {
        if (typeof gA == "string") {
          if (!Q.test(gA))
            throw new Error(`invalid anchor "${gA}"`);
          aA.call(this, `#${gA}`);
        }
      }
    }), w;
    function N(U, L, P) {
      if (L !== void 0 && !A(U, L))
        throw v(P);
    }
    function v(U) {
      return new Error(`reference "${U}" resolves to more than one schema`);
    }
  }
  return yA.getSchemaRefs = d, yA;
}
var sn;
function vt() {
  if (sn) return zA;
  sn = 1, Object.defineProperty(zA, "__esModule", { value: !0 }), zA.getData = zA.KeywordCxt = zA.validateFunctionCode = void 0;
  const i = uw(), A = _i(), e = ja(), t = _i(), o = fw(), g = ww(), r = yw(), n = tA(), s = LA(), a = co(), I = nA(), C = Co();
  function c(M) {
    if (E(M) && (p(M), y(M))) {
      h(M);
      return;
    }
    Q(M, () => (0, i.topBoolOrEmptySchema)(M));
  }
  zA.validateFunctionCode = c;
  function Q({ gen: M, validateName: b, schema: S, schemaEnv: G, opts: F }, J) {
    F.code.es5 ? M.func(b, (0, n._)`${s.default.data}, ${s.default.valCxt}`, G.$async, () => {
      M.code((0, n._)`"use strict"; ${B(S, F)}`), f(M, F), M.code(J);
    }) : M.func(b, (0, n._)`${s.default.data}, ${d(F)}`, G.$async, () => M.code(B(S, F)).code(J));
  }
  function d(M) {
    return (0, n._)`{${s.default.instancePath}="", ${s.default.parentData}, ${s.default.parentDataProperty}, ${s.default.rootData}=${s.default.data}${M.dynamicRef ? (0, n._)`, ${s.default.dynamicAnchors}={}` : n.nil}}={}`;
  }
  function f(M, b) {
    M.if(s.default.valCxt, () => {
      M.var(s.default.instancePath, (0, n._)`${s.default.valCxt}.${s.default.instancePath}`), M.var(s.default.parentData, (0, n._)`${s.default.valCxt}.${s.default.parentData}`), M.var(s.default.parentDataProperty, (0, n._)`${s.default.valCxt}.${s.default.parentDataProperty}`), M.var(s.default.rootData, (0, n._)`${s.default.valCxt}.${s.default.rootData}`), b.dynamicRef && M.var(s.default.dynamicAnchors, (0, n._)`${s.default.valCxt}.${s.default.dynamicAnchors}`);
    }, () => {
      M.var(s.default.instancePath, (0, n._)`""`), M.var(s.default.parentData, (0, n._)`undefined`), M.var(s.default.parentDataProperty, (0, n._)`undefined`), M.var(s.default.rootData, s.default.data), b.dynamicRef && M.var(s.default.dynamicAnchors, (0, n._)`{}`);
    });
  }
  function h(M) {
    const { schema: b, opts: S, gen: G } = M;
    Q(M, () => {
      S.$comment && b.$comment && V(M), U(M), G.let(s.default.vErrors, null), G.let(s.default.errors, 0), S.unevaluated && l(M), N(M), W(M);
    });
  }
  function l(M) {
    const { gen: b, validateName: S } = M;
    M.evaluated = b.const("evaluated", (0, n._)`${S}.evaluated`), b.if((0, n._)`${M.evaluated}.dynamicProps`, () => b.assign((0, n._)`${M.evaluated}.props`, (0, n._)`undefined`)), b.if((0, n._)`${M.evaluated}.dynamicItems`, () => b.assign((0, n._)`${M.evaluated}.items`, (0, n._)`undefined`));
  }
  function B(M, b) {
    const S = typeof M == "object" && M[b.schemaId];
    return S && (b.code.source || b.code.process) ? (0, n._)`/*# sourceURL=${S} */` : n.nil;
  }
  function u(M, b) {
    if (E(M) && (p(M), y(M))) {
      w(M, b);
      return;
    }
    (0, i.boolOrEmptySchema)(M, b);
  }
  function y({ schema: M, self: b }) {
    if (typeof M == "boolean")
      return !M;
    for (const S in M)
      if (b.RULES.all[S])
        return !0;
    return !1;
  }
  function E(M) {
    return typeof M.schema != "boolean";
  }
  function w(M, b) {
    const { schema: S, gen: G, opts: F } = M;
    F.$comment && S.$comment && V(M), L(M), P(M);
    const J = G.const("_errs", s.default.errors);
    N(M, J), G.var(b, (0, n._)`${J} === ${s.default.errors}`);
  }
  function p(M) {
    (0, I.checkUnknownRules)(M), v(M);
  }
  function N(M, b) {
    if (M.opts.jtd)
      return aA(M, [], !1, b);
    const S = (0, A.getSchemaTypes)(M.schema), G = (0, A.coerceAndCheckDataType)(M, S);
    aA(M, S, !G, b);
  }
  function v(M) {
    const { schema: b, errSchemaPath: S, opts: G, self: F } = M;
    b.$ref && G.ignoreKeywordsWithRef && (0, I.schemaHasRulesButRef)(b, F.RULES) && F.logger.warn(`$ref: keywords ignored in schema at path "${S}"`);
  }
  function U(M) {
    const { schema: b, opts: S } = M;
    b.default !== void 0 && S.useDefaults && S.strictSchema && (0, I.checkStrictMode)(M, "default is ignored in the schema root");
  }
  function L(M) {
    const b = M.schema[M.opts.schemaId];
    b && (M.baseId = (0, a.resolveUrl)(M.opts.uriResolver, M.baseId, b));
  }
  function P(M) {
    if (M.schema.$async && !M.schemaEnv.$async)
      throw new Error("async schema in sync schema");
  }
  function V({ gen: M, schemaEnv: b, schema: S, errSchemaPath: G, opts: F }) {
    const J = S.$comment;
    if (F.$comment === !0)
      M.code((0, n._)`${s.default.self}.logger.log(${J})`);
    else if (typeof F.$comment == "function") {
      const x = (0, n.str)`${G}/$comment`, z = M.scopeValue("root", { ref: b.root });
      M.code((0, n._)`${s.default.self}.opts.$comment(${J}, ${x}, ${z}.schema)`);
    }
  }
  function W(M) {
    const { gen: b, schemaEnv: S, validateName: G, ValidationError: F, opts: J } = M;
    S.$async ? b.if((0, n._)`${s.default.errors} === 0`, () => b.return(s.default.data), () => b.throw((0, n._)`new ${F}(${s.default.vErrors})`)) : (b.assign((0, n._)`${G}.errors`, s.default.vErrors), J.unevaluated && QA(M), b.return((0, n._)`${s.default.errors} === 0`));
  }
  function QA({ gen: M, evaluated: b, props: S, items: G }) {
    S instanceof n.Name && M.assign((0, n._)`${b}.props`, S), G instanceof n.Name && M.assign((0, n._)`${b}.items`, G);
  }
  function aA(M, b, S, G) {
    const { gen: F, schema: J, data: x, allErrors: z, opts: $, self: _ } = M, { RULES: O } = _;
    if (J.$ref && ($.ignoreKeywordsWithRef || !(0, I.schemaHasRulesButRef)(J, O))) {
      F.block(() => j(M, "$ref", O.all.$ref.definition));
      return;
    }
    $.jtd || gA(M, b), F.block(() => {
      for (const rA of O.rules)
        sA(rA);
      sA(O.post);
    });
    function sA(rA) {
      (0, e.shouldUseGroup)(J, rA) && (rA.type ? (F.if((0, t.checkDataType)(rA.type, x, $.strictNumbers)), wA(M, rA), b.length === 1 && b[0] === rA.type && S && (F.else(), (0, t.reportTypeError)(M)), F.endIf()) : wA(M, rA), z || F.if((0, n._)`${s.default.errors} === ${G || 0}`));
    }
  }
  function wA(M, b) {
    const { gen: S, schema: G, opts: { useDefaults: F } } = M;
    F && (0, o.assignDefaults)(M, b.type), S.block(() => {
      for (const J of b.rules)
        (0, e.shouldUseRule)(G, J) && j(M, J.keyword, J.definition, b.type);
    });
  }
  function gA(M, b) {
    M.schemaEnv.meta || !M.opts.strictTypes || (kA(M, b), M.opts.allowUnionTypes || q(M, b), k(M, M.dataTypes));
  }
  function kA(M, b) {
    if (b.length) {
      if (!M.dataTypes.length) {
        M.dataTypes = b;
        return;
      }
      b.forEach((S) => {
        K(M.dataTypes, S) || m(M, `type "${S}" not allowed by context "${M.dataTypes.join(",")}"`);
      }), D(M, b);
    }
  }
  function q(M, b) {
    b.length > 1 && !(b.length === 2 && b.includes("null")) && m(M, "use allowUnionTypes to allow union type keyword");
  }
  function k(M, b) {
    const S = M.self.RULES.all;
    for (const G in S) {
      const F = S[G];
      if (typeof F == "object" && (0, e.shouldUseRule)(M.schema, F)) {
        const { type: J } = F.definition;
        J.length && !J.some((x) => H(b, x)) && m(M, `missing type "${J.join(",")}" for keyword "${G}"`);
      }
    }
  }
  function H(M, b) {
    return M.includes(b) || b === "number" && M.includes("integer");
  }
  function K(M, b) {
    return M.includes(b) || b === "integer" && M.includes("number");
  }
  function D(M, b) {
    const S = [];
    for (const G of M.dataTypes)
      K(b, G) ? S.push(G) : b.includes("integer") && G === "number" && S.push("integer");
    M.dataTypes = S;
  }
  function m(M, b) {
    const S = M.schemaEnv.baseId + M.errSchemaPath;
    b += ` at "${S}" (strictTypes)`, (0, I.checkStrictMode)(M, b, M.opts.strictTypes);
  }
  class R {
    constructor(b, S, G) {
      if ((0, g.validateKeywordUsage)(b, S, G), this.gen = b.gen, this.allErrors = b.allErrors, this.keyword = G, this.data = b.data, this.schema = b.schema[G], this.$data = S.$data && b.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, I.schemaRefOrVal)(b, this.schema, G, this.$data), this.schemaType = S.schemaType, this.parentSchema = b.schema, this.params = {}, this.it = b, this.def = S, this.$data)
        this.schemaCode = b.gen.const("vSchema", AA(this.$data, b));
      else if (this.schemaCode = this.schemaValue, !(0, g.validSchemaType)(this.schema, S.schemaType, S.allowUndefined))
        throw new Error(`${G} value must be ${JSON.stringify(S.schemaType)}`);
      ("code" in S ? S.trackErrors : S.errors !== !1) && (this.errsCount = b.gen.const("_errs", s.default.errors));
    }
    result(b, S, G) {
      this.failResult((0, n.not)(b), S, G);
    }
    failResult(b, S, G) {
      this.gen.if(b), G ? G() : this.error(), S ? (this.gen.else(), S(), this.allErrors && this.gen.endIf()) : this.allErrors ? this.gen.endIf() : this.gen.else();
    }
    pass(b, S) {
      this.failResult((0, n.not)(b), void 0, S);
    }
    fail(b) {
      if (b === void 0) {
        this.error(), this.allErrors || this.gen.if(!1);
        return;
      }
      this.gen.if(b), this.error(), this.allErrors ? this.gen.endIf() : this.gen.else();
    }
    fail$data(b) {
      if (!this.$data)
        return this.fail(b);
      const { schemaCode: S } = this;
      this.fail((0, n._)`${S} !== undefined && (${(0, n.or)(this.invalid$data(), b)})`);
    }
    error(b, S, G) {
      if (S) {
        this.setParams(S), this._error(b, G), this.setParams({});
        return;
      }
      this._error(b, G);
    }
    _error(b, S) {
      (b ? C.reportExtraError : C.reportError)(this, this.def.error, S);
    }
    $dataError() {
      (0, C.reportError)(this, this.def.$dataError || C.keyword$DataError);
    }
    reset() {
      if (this.errsCount === void 0)
        throw new Error('add "trackErrors" to keyword definition');
      (0, C.resetErrorsCount)(this.gen, this.errsCount);
    }
    ok(b) {
      this.allErrors || this.gen.if(b);
    }
    setParams(b, S) {
      S ? Object.assign(this.params, b) : this.params = b;
    }
    block$data(b, S, G = n.nil) {
      this.gen.block(() => {
        this.check$data(b, G), S();
      });
    }
    check$data(b = n.nil, S = n.nil) {
      if (!this.$data)
        return;
      const { gen: G, schemaCode: F, schemaType: J, def: x } = this;
      G.if((0, n.or)((0, n._)`${F} === undefined`, S)), b !== n.nil && G.assign(b, !0), (J.length || x.validateSchema) && (G.elseIf(this.invalid$data()), this.$dataError(), b !== n.nil && G.assign(b, !1)), G.else();
    }
    invalid$data() {
      const { gen: b, schemaCode: S, schemaType: G, def: F, it: J } = this;
      return (0, n.or)(x(), z());
      function x() {
        if (G.length) {
          if (!(S instanceof n.Name))
            throw new Error("ajv implementation error");
          const $ = Array.isArray(G) ? G : [G];
          return (0, n._)`${(0, t.checkDataTypes)($, S, J.opts.strictNumbers, t.DataType.Wrong)}`;
        }
        return n.nil;
      }
      function z() {
        if (F.validateSchema) {
          const $ = b.scopeValue("validate$data", { ref: F.validateSchema });
          return (0, n._)`!${$}(${S})`;
        }
        return n.nil;
      }
    }
    subschema(b, S) {
      const G = (0, r.getSubschema)(this.it, b);
      (0, r.extendSubschemaData)(G, this.it, b), (0, r.extendSubschemaMode)(G, b);
      const F = { ...this.it, ...G, items: void 0, props: void 0 };
      return u(F, S), F;
    }
    mergeEvaluated(b, S) {
      const { it: G, gen: F } = this;
      G.opts.unevaluated && (G.props !== !0 && b.props !== void 0 && (G.props = I.mergeEvaluated.props(F, b.props, G.props, S)), G.items !== !0 && b.items !== void 0 && (G.items = I.mergeEvaluated.items(F, b.items, G.items, S)));
    }
    mergeValidEvaluated(b, S) {
      const { it: G, gen: F } = this;
      if (G.opts.unevaluated && (G.props !== !0 || G.items !== !0))
        return F.if(S, () => this.mergeEvaluated(b, n.Name)), !0;
    }
  }
  zA.KeywordCxt = R;
  function j(M, b, S, G) {
    const F = new R(M, S, b);
    "code" in S ? S.code(F, G) : F.$data && S.validate ? (0, g.funcKeywordCode)(F, S) : "macro" in S ? (0, g.macroKeywordCode)(F, S) : (S.compile || S.validate) && (0, g.funcKeywordCode)(F, S);
  }
  const T = /^\/(?:[^~]|~0|~1)*$/, eA = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
  function AA(M, { dataLevel: b, dataNames: S, dataPathArr: G }) {
    let F, J;
    if (M === "")
      return s.default.rootData;
    if (M[0] === "/") {
      if (!T.test(M))
        throw new Error(`Invalid JSON-pointer: ${M}`);
      F = M, J = s.default.rootData;
    } else {
      const _ = eA.exec(M);
      if (!_)
        throw new Error(`Invalid JSON-pointer: ${M}`);
      const O = +_[1];
      if (F = _[2], F === "#") {
        if (O >= b)
          throw new Error($("property/index", O));
        return G[b - O];
      }
      if (O > b)
        throw new Error($("data", O));
      if (J = S[b - O], !F)
        return J;
    }
    let x = J;
    const z = F.split("/");
    for (const _ of z)
      _ && (J = (0, n._)`${J}${(0, n.getProperty)((0, I.unescapeJsonPointer)(_))}`, x = (0, n._)`${x} && ${J}`);
    return x;
    function $(_, O) {
      return `Cannot access ${_} ${O} levels up, current level is ${b}`;
    }
  }
  return zA.getData = AA, zA;
}
var jt = {}, an;
function Bo() {
  if (an) return jt;
  an = 1, Object.defineProperty(jt, "__esModule", { value: !0 });
  class i extends Error {
    constructor(e) {
      super("validation failed"), this.errors = e, this.ajv = this.validation = !0;
    }
  }
  return jt.default = i, jt;
}
var Vt = {}, In;
function Ut() {
  if (In) return Vt;
  In = 1, Object.defineProperty(Vt, "__esModule", { value: !0 });
  const i = co();
  class A extends Error {
    constructor(t, o, g, r) {
      super(r || `can't resolve reference ${g} from id ${o}`), this.missingRef = (0, i.resolveUrl)(t, o, g), this.missingSchema = (0, i.normalizeId)((0, i.getFullPath)(t, this.missingRef));
    }
  }
  return Vt.default = A, Vt;
}
var SA = {}, Cn;
function Qo() {
  if (Cn) return SA;
  Cn = 1, Object.defineProperty(SA, "__esModule", { value: !0 }), SA.resolveSchema = SA.getCompilingSchema = SA.resolveRef = SA.compileSchema = SA.SchemaEnv = void 0;
  const i = tA(), A = Bo(), e = LA(), t = co(), o = nA(), g = vt();
  class r {
    constructor(l) {
      var B;
      this.refs = {}, this.dynamicAnchors = {};
      let u;
      typeof l.schema == "object" && (u = l.schema), this.schema = l.schema, this.schemaId = l.schemaId, this.root = l.root || this, this.baseId = (B = l.baseId) !== null && B !== void 0 ? B : (0, t.normalizeId)(u?.[l.schemaId || "$id"]), this.schemaPath = l.schemaPath, this.localRefs = l.localRefs, this.meta = l.meta, this.$async = u?.$async, this.refs = {};
    }
  }
  SA.SchemaEnv = r;
  function n(h) {
    const l = I.call(this, h);
    if (l)
      return l;
    const B = (0, t.getFullPath)(this.opts.uriResolver, h.root.baseId), { es5: u, lines: y } = this.opts.code, { ownProperties: E } = this.opts, w = new i.CodeGen(this.scope, { es5: u, lines: y, ownProperties: E });
    let p;
    h.$async && (p = w.scopeValue("Error", {
      ref: A.default,
      code: (0, i._)`require("ajv/dist/runtime/validation_error").default`
    }));
    const N = w.scopeName("validate");
    h.validateName = N;
    const v = {
      gen: w,
      allErrors: this.opts.allErrors,
      data: e.default.data,
      parentData: e.default.parentData,
      parentDataProperty: e.default.parentDataProperty,
      dataNames: [e.default.data],
      dataPathArr: [i.nil],
      // TODO can its length be used as dataLevel if nil is removed?
      dataLevel: 0,
      dataTypes: [],
      definedProperties: /* @__PURE__ */ new Set(),
      topSchemaRef: w.scopeValue("schema", this.opts.code.source === !0 ? { ref: h.schema, code: (0, i.stringify)(h.schema) } : { ref: h.schema }),
      validateName: N,
      ValidationError: p,
      schema: h.schema,
      schemaEnv: h,
      rootId: B,
      baseId: h.baseId || B,
      schemaPath: i.nil,
      errSchemaPath: h.schemaPath || (this.opts.jtd ? "" : "#"),
      errorPath: (0, i._)`""`,
      opts: this.opts,
      self: this
    };
    let U;
    try {
      this._compilations.add(h), (0, g.validateFunctionCode)(v), w.optimize(this.opts.code.optimize);
      const L = w.toString();
      U = `${w.scopeRefs(e.default.scope)}return ${L}`, this.opts.code.process && (U = this.opts.code.process(U, h));
      const V = new Function(`${e.default.self}`, `${e.default.scope}`, U)(this, this.scope.get());
      if (this.scope.value(N, { ref: V }), V.errors = null, V.schema = h.schema, V.schemaEnv = h, h.$async && (V.$async = !0), this.opts.code.source === !0 && (V.source = { validateName: N, validateCode: L, scopeValues: w._values }), this.opts.unevaluated) {
        const { props: W, items: QA } = v;
        V.evaluated = {
          props: W instanceof i.Name ? void 0 : W,
          items: QA instanceof i.Name ? void 0 : QA,
          dynamicProps: W instanceof i.Name,
          dynamicItems: QA instanceof i.Name
        }, V.source && (V.source.evaluated = (0, i.stringify)(V.evaluated));
      }
      return h.validate = V, h;
    } catch (L) {
      throw delete h.validate, delete h.validateName, U && this.logger.error("Error compiling schema, function code:", U), L;
    } finally {
      this._compilations.delete(h);
    }
  }
  SA.compileSchema = n;
  function s(h, l, B) {
    var u;
    B = (0, t.resolveUrl)(this.opts.uriResolver, l, B);
    const y = h.refs[B];
    if (y)
      return y;
    let E = c.call(this, h, B);
    if (E === void 0) {
      const w = (u = h.localRefs) === null || u === void 0 ? void 0 : u[B], { schemaId: p } = this.opts;
      w && (E = new r({ schema: w, schemaId: p, root: h, baseId: l }));
    }
    if (E !== void 0)
      return h.refs[B] = a.call(this, E);
  }
  SA.resolveRef = s;
  function a(h) {
    return (0, t.inlineRef)(h.schema, this.opts.inlineRefs) ? h.schema : h.validate ? h : n.call(this, h);
  }
  function I(h) {
    for (const l of this._compilations)
      if (C(l, h))
        return l;
  }
  SA.getCompilingSchema = I;
  function C(h, l) {
    return h.schema === l.schema && h.root === l.root && h.baseId === l.baseId;
  }
  function c(h, l) {
    let B;
    for (; typeof (B = this.refs[l]) == "string"; )
      l = B;
    return B || this.schemas[l] || Q.call(this, h, l);
  }
  function Q(h, l) {
    const B = this.opts.uriResolver.parse(l), u = (0, t._getFullPath)(this.opts.uriResolver, B);
    let y = (0, t.getFullPath)(this.opts.uriResolver, h.baseId, void 0);
    if (Object.keys(h.schema).length > 0 && u === y)
      return f.call(this, B, h);
    const E = (0, t.normalizeId)(u), w = this.refs[E] || this.schemas[E];
    if (typeof w == "string") {
      const p = Q.call(this, h, w);
      return typeof p?.schema != "object" ? void 0 : f.call(this, B, p);
    }
    if (typeof w?.schema == "object") {
      if (w.validate || n.call(this, w), E === (0, t.normalizeId)(l)) {
        const { schema: p } = w, { schemaId: N } = this.opts, v = p[N];
        return v && (y = (0, t.resolveUrl)(this.opts.uriResolver, y, v)), new r({ schema: p, schemaId: N, root: h, baseId: y });
      }
      return f.call(this, B, w);
    }
  }
  SA.resolveSchema = Q;
  const d = /* @__PURE__ */ new Set([
    "properties",
    "patternProperties",
    "enum",
    "dependencies",
    "definitions"
  ]);
  function f(h, { baseId: l, schema: B, root: u }) {
    var y;
    if (((y = h.fragment) === null || y === void 0 ? void 0 : y[0]) !== "/")
      return;
    for (const p of h.fragment.slice(1).split("/")) {
      if (typeof B == "boolean")
        return;
      const N = B[(0, o.unescapeFragment)(p)];
      if (N === void 0)
        return;
      B = N;
      const v = typeof B == "object" && B[this.opts.schemaId];
      !d.has(p) && v && (l = (0, t.resolveUrl)(this.opts.uriResolver, l, v));
    }
    let E;
    if (typeof B != "boolean" && B.$ref && !(0, o.schemaHasRulesButRef)(B, this.RULES)) {
      const p = (0, t.resolveUrl)(this.opts.uriResolver, l, B.$ref);
      E = Q.call(this, u, p);
    }
    const { schemaId: w } = this.opts;
    if (E = E || new r({ schema: B, schemaId: w, root: u, baseId: l }), E.schema !== E.root.schema)
      return E;
  }
  return SA;
}
const Dw = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#", mw = "Meta-schema for $data reference (JSON AnySchema extension proposal)", Sw = "object", Nw = ["$data"], Mw = { $data: { type: "string", anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }] } }, Gw = !1, kw = {
  $id: Dw,
  description: mw,
  type: Sw,
  required: Nw,
  properties: Mw,
  additionalProperties: Gw
};
var Wt = {}, nt = { exports: {} }, Lo, cn;
function Wa() {
  if (cn) return Lo;
  cn = 1;
  const i = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu), A = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
  function e(c) {
    let Q = "", d = 0, f = 0;
    for (f = 0; f < c.length; f++)
      if (d = c[f].charCodeAt(0), d !== 48) {
        if (!(d >= 48 && d <= 57 || d >= 65 && d <= 70 || d >= 97 && d <= 102))
          return "";
        Q += c[f];
        break;
      }
    for (f += 1; f < c.length; f++) {
      if (d = c[f].charCodeAt(0), !(d >= 48 && d <= 57 || d >= 65 && d <= 70 || d >= 97 && d <= 102))
        return "";
      Q += c[f];
    }
    return Q;
  }
  const t = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
  function o(c) {
    return c.length = 0, !0;
  }
  function g(c, Q, d) {
    if (c.length) {
      const f = e(c);
      if (f !== "")
        Q.push(f);
      else
        return d.error = !0, !1;
      c.length = 0;
    }
    return !0;
  }
  function r(c) {
    let Q = 0;
    const d = { error: !1, address: "", zone: "" }, f = [], h = [];
    let l = !1, B = !1, u = g;
    for (let y = 0; y < c.length; y++) {
      const E = c[y];
      if (!(E === "[" || E === "]"))
        if (E === ":") {
          if (l === !0 && (B = !0), !u(h, f, d))
            break;
          if (++Q > 7) {
            d.error = !0;
            break;
          }
          y > 0 && c[y - 1] === ":" && (l = !0), f.push(":");
          continue;
        } else if (E === "%") {
          if (!u(h, f, d))
            break;
          u = o;
        } else {
          h.push(E);
          continue;
        }
    }
    return h.length && (u === o ? d.zone = h.join("") : B ? f.push(h.join("")) : f.push(e(h))), d.address = f.join(""), d;
  }
  function n(c) {
    if (s(c, ":") < 2)
      return { host: c, isIPV6: !1 };
    const Q = r(c);
    if (Q.error)
      return { host: c, isIPV6: !1 };
    {
      let d = Q.address, f = Q.address;
      return Q.zone && (d += "%" + Q.zone, f += "%25" + Q.zone), { host: d, isIPV6: !0, escapedHost: f };
    }
  }
  function s(c, Q) {
    let d = 0;
    for (let f = 0; f < c.length; f++)
      c[f] === Q && d++;
    return d;
  }
  function a(c) {
    let Q = c;
    const d = [];
    let f = -1, h = 0;
    for (; h = Q.length; ) {
      if (h === 1) {
        if (Q === ".")
          break;
        if (Q === "/") {
          d.push("/");
          break;
        } else {
          d.push(Q);
          break;
        }
      } else if (h === 2) {
        if (Q[0] === ".") {
          if (Q[1] === ".")
            break;
          if (Q[1] === "/") {
            Q = Q.slice(2);
            continue;
          }
        } else if (Q[0] === "/" && (Q[1] === "." || Q[1] === "/")) {
          d.push("/");
          break;
        }
      } else if (h === 3 && Q === "/..") {
        d.length !== 0 && d.pop(), d.push("/");
        break;
      }
      if (Q[0] === ".") {
        if (Q[1] === ".") {
          if (Q[2] === "/") {
            Q = Q.slice(3);
            continue;
          }
        } else if (Q[1] === "/") {
          Q = Q.slice(2);
          continue;
        }
      } else if (Q[0] === "/" && Q[1] === ".") {
        if (Q[2] === "/") {
          Q = Q.slice(2);
          continue;
        } else if (Q[2] === "." && Q[3] === "/") {
          Q = Q.slice(3), d.length !== 0 && d.pop();
          continue;
        }
      }
      if ((f = Q.indexOf("/", 1)) === -1) {
        d.push(Q);
        break;
      } else
        d.push(Q.slice(0, f)), Q = Q.slice(f);
    }
    return d.join("");
  }
  function I(c, Q) {
    const d = Q !== !0 ? escape : unescape;
    return c.scheme !== void 0 && (c.scheme = d(c.scheme)), c.userinfo !== void 0 && (c.userinfo = d(c.userinfo)), c.host !== void 0 && (c.host = d(c.host)), c.path !== void 0 && (c.path = d(c.path)), c.query !== void 0 && (c.query = d(c.query)), c.fragment !== void 0 && (c.fragment = d(c.fragment)), c;
  }
  function C(c) {
    const Q = [];
    if (c.userinfo !== void 0 && (Q.push(c.userinfo), Q.push("@")), c.host !== void 0) {
      let d = unescape(c.host);
      if (!A(d)) {
        const f = n(d);
        f.isIPV6 === !0 ? d = `[${f.escapedHost}]` : d = c.host;
      }
      Q.push(d);
    }
    return (typeof c.port == "number" || typeof c.port == "string") && (Q.push(":"), Q.push(String(c.port))), Q.length ? Q.join("") : void 0;
  }
  return Lo = {
    nonSimpleDomain: t,
    recomposeAuthority: C,
    normalizeComponentEncoding: I,
    removeDotSegments: a,
    isIPv4: A,
    isUUID: i,
    normalizeIPv6: n,
    stringArrayToHexStripped: e
  }, Lo;
}
var xo, Bn;
function Fw() {
  if (Bn) return xo;
  Bn = 1;
  const { isUUID: i } = Wa(), A = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu, e = (
    /** @type {const} */
    [
      "http",
      "https",
      "ws",
      "wss",
      "urn",
      "urn:uuid"
    ]
  );
  function t(E) {
    return e.indexOf(
      /** @type {*} */
      E
    ) !== -1;
  }
  function o(E) {
    return E.secure === !0 ? !0 : E.secure === !1 ? !1 : E.scheme ? E.scheme.length === 3 && (E.scheme[0] === "w" || E.scheme[0] === "W") && (E.scheme[1] === "s" || E.scheme[1] === "S") && (E.scheme[2] === "s" || E.scheme[2] === "S") : !1;
  }
  function g(E) {
    return E.host || (E.error = E.error || "HTTP URIs must have a host."), E;
  }
  function r(E) {
    const w = String(E.scheme).toLowerCase() === "https";
    return (E.port === (w ? 443 : 80) || E.port === "") && (E.port = void 0), E.path || (E.path = "/"), E;
  }
  function n(E) {
    return E.secure = o(E), E.resourceName = (E.path || "/") + (E.query ? "?" + E.query : ""), E.path = void 0, E.query = void 0, E;
  }
  function s(E) {
    if ((E.port === (o(E) ? 443 : 80) || E.port === "") && (E.port = void 0), typeof E.secure == "boolean" && (E.scheme = E.secure ? "wss" : "ws", E.secure = void 0), E.resourceName) {
      const [w, p] = E.resourceName.split("?");
      E.path = w && w !== "/" ? w : void 0, E.query = p, E.resourceName = void 0;
    }
    return E.fragment = void 0, E;
  }
  function a(E, w) {
    if (!E.path)
      return E.error = "URN can not be parsed", E;
    const p = E.path.match(A);
    if (p) {
      const N = w.scheme || E.scheme || "urn";
      E.nid = p[1].toLowerCase(), E.nss = p[2];
      const v = `${N}:${w.nid || E.nid}`, U = y(v);
      E.path = void 0, U && (E = U.parse(E, w));
    } else
      E.error = E.error || "URN can not be parsed.";
    return E;
  }
  function I(E, w) {
    if (E.nid === void 0)
      throw new Error("URN without nid cannot be serialized");
    const p = w.scheme || E.scheme || "urn", N = E.nid.toLowerCase(), v = `${p}:${w.nid || N}`, U = y(v);
    U && (E = U.serialize(E, w));
    const L = E, P = E.nss;
    return L.path = `${N || w.nid}:${P}`, w.skipEscape = !0, L;
  }
  function C(E, w) {
    const p = E;
    return p.uuid = p.nss, p.nss = void 0, !w.tolerant && (!p.uuid || !i(p.uuid)) && (p.error = p.error || "UUID is not valid."), p;
  }
  function c(E) {
    const w = E;
    return w.nss = (E.uuid || "").toLowerCase(), w;
  }
  const Q = (
    /** @type {SchemeHandler} */
    {
      scheme: "http",
      domainHost: !0,
      parse: g,
      serialize: r
    }
  ), d = (
    /** @type {SchemeHandler} */
    {
      scheme: "https",
      domainHost: Q.domainHost,
      parse: g,
      serialize: r
    }
  ), f = (
    /** @type {SchemeHandler} */
    {
      scheme: "ws",
      domainHost: !0,
      parse: n,
      serialize: s
    }
  ), h = (
    /** @type {SchemeHandler} */
    {
      scheme: "wss",
      domainHost: f.domainHost,
      parse: f.parse,
      serialize: f.serialize
    }
  ), u = (
    /** @type {Record<SchemeName, SchemeHandler>} */
    {
      http: Q,
      https: d,
      ws: f,
      wss: h,
      urn: (
        /** @type {SchemeHandler} */
        {
          scheme: "urn",
          parse: a,
          serialize: I,
          skipNormalize: !0
        }
      ),
      "urn:uuid": (
        /** @type {SchemeHandler} */
        {
          scheme: "urn:uuid",
          parse: C,
          serialize: c,
          skipNormalize: !0
        }
      )
    }
  );
  Object.setPrototypeOf(u, null);
  function y(E) {
    return E && (u[
      /** @type {SchemeName} */
      E
    ] || u[
      /** @type {SchemeName} */
      E.toLowerCase()
    ]) || void 0;
  }
  return xo = {
    wsIsSecure: o,
    SCHEMES: u,
    isValidSchemeName: t,
    getSchemeHandler: y
  }, xo;
}
var Qn;
function Rw() {
  if (Qn) return nt.exports;
  Qn = 1;
  const { normalizeIPv6: i, removeDotSegments: A, recomposeAuthority: e, normalizeComponentEncoding: t, isIPv4: o, nonSimpleDomain: g } = Wa(), { SCHEMES: r, getSchemeHandler: n } = Fw();
  function s(h, l) {
    return typeof h == "string" ? h = /** @type {T} */
    c(d(h, l), l) : typeof h == "object" && (h = /** @type {T} */
    d(c(h, l), l)), h;
  }
  function a(h, l, B) {
    const u = B ? Object.assign({ scheme: "null" }, B) : { scheme: "null" }, y = I(d(h, u), d(l, u), u, !0);
    return u.skipEscape = !0, c(y, u);
  }
  function I(h, l, B, u) {
    const y = {};
    return u || (h = d(c(h, B), B), l = d(c(l, B), B)), B = B || {}, !B.tolerant && l.scheme ? (y.scheme = l.scheme, y.userinfo = l.userinfo, y.host = l.host, y.port = l.port, y.path = A(l.path || ""), y.query = l.query) : (l.userinfo !== void 0 || l.host !== void 0 || l.port !== void 0 ? (y.userinfo = l.userinfo, y.host = l.host, y.port = l.port, y.path = A(l.path || ""), y.query = l.query) : (l.path ? (l.path[0] === "/" ? y.path = A(l.path) : ((h.userinfo !== void 0 || h.host !== void 0 || h.port !== void 0) && !h.path ? y.path = "/" + l.path : h.path ? y.path = h.path.slice(0, h.path.lastIndexOf("/") + 1) + l.path : y.path = l.path, y.path = A(y.path)), y.query = l.query) : (y.path = h.path, l.query !== void 0 ? y.query = l.query : y.query = h.query), y.userinfo = h.userinfo, y.host = h.host, y.port = h.port), y.scheme = h.scheme), y.fragment = l.fragment, y;
  }
  function C(h, l, B) {
    return typeof h == "string" ? (h = unescape(h), h = c(t(d(h, B), !0), { ...B, skipEscape: !0 })) : typeof h == "object" && (h = c(t(h, !0), { ...B, skipEscape: !0 })), typeof l == "string" ? (l = unescape(l), l = c(t(d(l, B), !0), { ...B, skipEscape: !0 })) : typeof l == "object" && (l = c(t(l, !0), { ...B, skipEscape: !0 })), h.toLowerCase() === l.toLowerCase();
  }
  function c(h, l) {
    const B = {
      host: h.host,
      scheme: h.scheme,
      userinfo: h.userinfo,
      port: h.port,
      path: h.path,
      query: h.query,
      nid: h.nid,
      nss: h.nss,
      uuid: h.uuid,
      fragment: h.fragment,
      reference: h.reference,
      resourceName: h.resourceName,
      secure: h.secure,
      error: ""
    }, u = Object.assign({}, l), y = [], E = n(u.scheme || B.scheme);
    E && E.serialize && E.serialize(B, u), B.path !== void 0 && (u.skipEscape ? B.path = unescape(B.path) : (B.path = escape(B.path), B.scheme !== void 0 && (B.path = B.path.split("%3A").join(":")))), u.reference !== "suffix" && B.scheme && y.push(B.scheme, ":");
    const w = e(B);
    if (w !== void 0 && (u.reference !== "suffix" && y.push("//"), y.push(w), B.path && B.path[0] !== "/" && y.push("/")), B.path !== void 0) {
      let p = B.path;
      !u.absolutePath && (!E || !E.absolutePath) && (p = A(p)), w === void 0 && p[0] === "/" && p[1] === "/" && (p = "/%2F" + p.slice(2)), y.push(p);
    }
    return B.query !== void 0 && y.push("?", B.query), B.fragment !== void 0 && y.push("#", B.fragment), y.join("");
  }
  const Q = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
  function d(h, l) {
    const B = Object.assign({}, l), u = {
      scheme: void 0,
      userinfo: void 0,
      host: "",
      port: void 0,
      path: "",
      query: void 0,
      fragment: void 0
    };
    let y = !1;
    B.reference === "suffix" && (B.scheme ? h = B.scheme + ":" + h : h = "//" + h);
    const E = h.match(Q);
    if (E) {
      if (u.scheme = E[1], u.userinfo = E[3], u.host = E[4], u.port = parseInt(E[5], 10), u.path = E[6] || "", u.query = E[7], u.fragment = E[8], isNaN(u.port) && (u.port = E[5]), u.host)
        if (o(u.host) === !1) {
          const N = i(u.host);
          u.host = N.host.toLowerCase(), y = N.isIPV6;
        } else
          y = !0;
      u.scheme === void 0 && u.userinfo === void 0 && u.host === void 0 && u.port === void 0 && u.query === void 0 && !u.path ? u.reference = "same-document" : u.scheme === void 0 ? u.reference = "relative" : u.fragment === void 0 ? u.reference = "absolute" : u.reference = "uri", B.reference && B.reference !== "suffix" && B.reference !== u.reference && (u.error = u.error || "URI is not a " + B.reference + " reference.");
      const w = n(B.scheme || u.scheme);
      if (!B.unicodeSupport && (!w || !w.unicodeSupport) && u.host && (B.domainHost || w && w.domainHost) && y === !1 && g(u.host))
        try {
          u.host = URL.domainToASCII(u.host.toLowerCase());
        } catch (p) {
          u.error = u.error || "Host's domain name can not be converted to ASCII: " + p;
        }
      (!w || w && !w.skipNormalize) && (h.indexOf("%") !== -1 && (u.scheme !== void 0 && (u.scheme = unescape(u.scheme)), u.host !== void 0 && (u.host = unescape(u.host))), u.path && (u.path = escape(unescape(u.path))), u.fragment && (u.fragment = encodeURI(decodeURIComponent(u.fragment)))), w && w.parse && w.parse(u, B);
    } else
      u.error = u.error || "URI can not be parsed.";
    return u;
  }
  const f = {
    SCHEMES: r,
    normalize: s,
    resolve: a,
    resolveComponent: I,
    equal: C,
    serialize: c,
    parse: d
  };
  return nt.exports = f, nt.exports.default = f, nt.exports.fastUri = f, nt.exports;
}
var En;
function bw() {
  if (En) return Wt;
  En = 1, Object.defineProperty(Wt, "__esModule", { value: !0 });
  const i = Rw();
  return i.code = 'require("ajv/dist/runtime/uri").default', Wt.default = i, Wt;
}
var ln;
function za() {
  return ln || (ln = 1, (function(i) {
    Object.defineProperty(i, "__esModule", { value: !0 }), i.CodeGen = i.Name = i.nil = i.stringify = i.str = i._ = i.KeywordCxt = void 0;
    var A = vt();
    Object.defineProperty(i, "KeywordCxt", { enumerable: !0, get: function() {
      return A.KeywordCxt;
    } });
    var e = tA();
    Object.defineProperty(i, "_", { enumerable: !0, get: function() {
      return e._;
    } }), Object.defineProperty(i, "str", { enumerable: !0, get: function() {
      return e.str;
    } }), Object.defineProperty(i, "stringify", { enumerable: !0, get: function() {
      return e.stringify;
    } }), Object.defineProperty(i, "nil", { enumerable: !0, get: function() {
      return e.nil;
    } }), Object.defineProperty(i, "Name", { enumerable: !0, get: function() {
      return e.Name;
    } }), Object.defineProperty(i, "CodeGen", { enumerable: !0, get: function() {
      return e.CodeGen;
    } });
    const t = Bo(), o = Ut(), g = Pa(), r = Qo(), n = tA(), s = co(), a = _i(), I = nA(), C = kw, c = bw(), Q = (q, k) => new RegExp(q, k);
    Q.code = "new RegExp";
    const d = ["removeAdditional", "useDefaults", "coerceTypes"], f = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]), h = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    }, l = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    }, B = 200;
    function u(q) {
      var k, H, K, D, m, R, j, T, eA, AA, M, b, S, G, F, J, x, z, $, _, O, sA, rA, EA, hA;
      const WA = q.strict, At = (k = q.code) === null || k === void 0 ? void 0 : k.optimize, rr = At === !0 || At === void 0 ? 1 : At || 0, nr = (K = (H = q.code) === null || H === void 0 ? void 0 : H.regExp) !== null && K !== void 0 ? K : Q, sI = (D = q.uriResolver) !== null && D !== void 0 ? D : c.default;
      return {
        strictSchema: (R = (m = q.strictSchema) !== null && m !== void 0 ? m : WA) !== null && R !== void 0 ? R : !0,
        strictNumbers: (T = (j = q.strictNumbers) !== null && j !== void 0 ? j : WA) !== null && T !== void 0 ? T : !0,
        strictTypes: (AA = (eA = q.strictTypes) !== null && eA !== void 0 ? eA : WA) !== null && AA !== void 0 ? AA : "log",
        strictTuples: (b = (M = q.strictTuples) !== null && M !== void 0 ? M : WA) !== null && b !== void 0 ? b : "log",
        strictRequired: (G = (S = q.strictRequired) !== null && S !== void 0 ? S : WA) !== null && G !== void 0 ? G : !1,
        code: q.code ? { ...q.code, optimize: rr, regExp: nr } : { optimize: rr, regExp: nr },
        loopRequired: (F = q.loopRequired) !== null && F !== void 0 ? F : B,
        loopEnum: (J = q.loopEnum) !== null && J !== void 0 ? J : B,
        meta: (x = q.meta) !== null && x !== void 0 ? x : !0,
        messages: (z = q.messages) !== null && z !== void 0 ? z : !0,
        inlineRefs: ($ = q.inlineRefs) !== null && $ !== void 0 ? $ : !0,
        schemaId: (_ = q.schemaId) !== null && _ !== void 0 ? _ : "$id",
        addUsedSchema: (O = q.addUsedSchema) !== null && O !== void 0 ? O : !0,
        validateSchema: (sA = q.validateSchema) !== null && sA !== void 0 ? sA : !0,
        validateFormats: (rA = q.validateFormats) !== null && rA !== void 0 ? rA : !0,
        unicodeRegExp: (EA = q.unicodeRegExp) !== null && EA !== void 0 ? EA : !0,
        int32range: (hA = q.int32range) !== null && hA !== void 0 ? hA : !0,
        uriResolver: sI
      };
    }
    class y {
      constructor(k = {}) {
        this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = /* @__PURE__ */ new Set(), this._loading = {}, this._cache = /* @__PURE__ */ new Map(), k = this.opts = { ...k, ...u(k) };
        const { es5: H, lines: K } = this.opts.code;
        this.scope = new n.ValueScope({ scope: {}, prefixes: f, es5: H, lines: K }), this.logger = P(k.logger);
        const D = k.validateFormats;
        k.validateFormats = !1, this.RULES = (0, g.getRules)(), E.call(this, h, k, "NOT SUPPORTED"), E.call(this, l, k, "DEPRECATED", "warn"), this._metaOpts = U.call(this), k.formats && N.call(this), this._addVocabularies(), this._addDefaultMetaSchema(), k.keywords && v.call(this, k.keywords), typeof k.meta == "object" && this.addMetaSchema(k.meta), p.call(this), k.validateFormats = D;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data: k, meta: H, schemaId: K } = this.opts;
        let D = C;
        K === "id" && (D = { ...C }, D.id = D.$id, delete D.$id), H && k && this.addMetaSchema(D, D[K], !1);
      }
      defaultMeta() {
        const { meta: k, schemaId: H } = this.opts;
        return this.opts.defaultMeta = typeof k == "object" ? k[H] || k : void 0;
      }
      validate(k, H) {
        let K;
        if (typeof k == "string") {
          if (K = this.getSchema(k), !K)
            throw new Error(`no schema with key or ref "${k}"`);
        } else
          K = this.compile(k);
        const D = K(H);
        return "$async" in K || (this.errors = K.errors), D;
      }
      compile(k, H) {
        const K = this._addSchema(k, H);
        return K.validate || this._compileSchemaEnv(K);
      }
      compileAsync(k, H) {
        if (typeof this.opts.loadSchema != "function")
          throw new Error("options.loadSchema should be a function");
        const { loadSchema: K } = this.opts;
        return D.call(this, k, H);
        async function D(AA, M) {
          await m.call(this, AA.$schema);
          const b = this._addSchema(AA, M);
          return b.validate || R.call(this, b);
        }
        async function m(AA) {
          AA && !this.getSchema(AA) && await D.call(this, { $ref: AA }, !0);
        }
        async function R(AA) {
          try {
            return this._compileSchemaEnv(AA);
          } catch (M) {
            if (!(M instanceof o.default))
              throw M;
            return j.call(this, M), await T.call(this, M.missingSchema), R.call(this, AA);
          }
        }
        function j({ missingSchema: AA, missingRef: M }) {
          if (this.refs[AA])
            throw new Error(`AnySchema ${AA} is loaded but ${M} cannot be resolved`);
        }
        async function T(AA) {
          const M = await eA.call(this, AA);
          this.refs[AA] || await m.call(this, M.$schema), this.refs[AA] || this.addSchema(M, AA, H);
        }
        async function eA(AA) {
          const M = this._loading[AA];
          if (M)
            return M;
          try {
            return await (this._loading[AA] = K(AA));
          } finally {
            delete this._loading[AA];
          }
        }
      }
      // Adds schema to the instance
      addSchema(k, H, K, D = this.opts.validateSchema) {
        if (Array.isArray(k)) {
          for (const R of k)
            this.addSchema(R, void 0, K, D);
          return this;
        }
        let m;
        if (typeof k == "object") {
          const { schemaId: R } = this.opts;
          if (m = k[R], m !== void 0 && typeof m != "string")
            throw new Error(`schema ${R} must be string`);
        }
        return H = (0, s.normalizeId)(H || m), this._checkUnique(H), this.schemas[H] = this._addSchema(k, K, H, D, !0), this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(k, H, K = this.opts.validateSchema) {
        return this.addSchema(k, H, !0, K), this;
      }
      //  Validate schema against its meta-schema
      validateSchema(k, H) {
        if (typeof k == "boolean")
          return !0;
        let K;
        if (K = k.$schema, K !== void 0 && typeof K != "string")
          throw new Error("$schema must be a string");
        if (K = K || this.opts.defaultMeta || this.defaultMeta(), !K)
          return this.logger.warn("meta-schema not available"), this.errors = null, !0;
        const D = this.validate(K, k);
        if (!D && H) {
          const m = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(m);
          else
            throw new Error(m);
        }
        return D;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(k) {
        let H;
        for (; typeof (H = w.call(this, k)) == "string"; )
          k = H;
        if (H === void 0) {
          const { schemaId: K } = this.opts, D = new r.SchemaEnv({ schema: {}, schemaId: K });
          if (H = r.resolveSchema.call(this, D, k), !H)
            return;
          this.refs[k] = H;
        }
        return H.validate || this._compileSchemaEnv(H);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(k) {
        if (k instanceof RegExp)
          return this._removeAllSchemas(this.schemas, k), this._removeAllSchemas(this.refs, k), this;
        switch (typeof k) {
          case "undefined":
            return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
          case "string": {
            const H = w.call(this, k);
            return typeof H == "object" && this._cache.delete(H.schema), delete this.schemas[k], delete this.refs[k], this;
          }
          case "object": {
            const H = k;
            this._cache.delete(H);
            let K = k[this.opts.schemaId];
            return K && (K = (0, s.normalizeId)(K), delete this.schemas[K], delete this.refs[K]), this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(k) {
        for (const H of k)
          this.addKeyword(H);
        return this;
      }
      addKeyword(k, H) {
        let K;
        if (typeof k == "string")
          K = k, typeof H == "object" && (this.logger.warn("these parameters are deprecated, see docs for addKeyword"), H.keyword = K);
        else if (typeof k == "object" && H === void 0) {
          if (H = k, K = H.keyword, Array.isArray(K) && !K.length)
            throw new Error("addKeywords: keyword must be string or non-empty array");
        } else
          throw new Error("invalid addKeywords parameters");
        if (W.call(this, K, H), !H)
          return (0, I.eachItem)(K, (m) => QA.call(this, m)), this;
        wA.call(this, H);
        const D = {
          ...H,
          type: (0, a.getJSONTypes)(H.type),
          schemaType: (0, a.getJSONTypes)(H.schemaType)
        };
        return (0, I.eachItem)(K, D.type.length === 0 ? (m) => QA.call(this, m, D) : (m) => D.type.forEach((R) => QA.call(this, m, D, R))), this;
      }
      getKeyword(k) {
        const H = this.RULES.all[k];
        return typeof H == "object" ? H.definition : !!H;
      }
      // Remove keyword
      removeKeyword(k) {
        const { RULES: H } = this;
        delete H.keywords[k], delete H.all[k];
        for (const K of H.rules) {
          const D = K.rules.findIndex((m) => m.keyword === k);
          D >= 0 && K.rules.splice(D, 1);
        }
        return this;
      }
      // Add format
      addFormat(k, H) {
        return typeof H == "string" && (H = new RegExp(H)), this.formats[k] = H, this;
      }
      errorsText(k = this.errors, { separator: H = ", ", dataVar: K = "data" } = {}) {
        return !k || k.length === 0 ? "No errors" : k.map((D) => `${K}${D.instancePath} ${D.message}`).reduce((D, m) => D + H + m);
      }
      $dataMetaSchema(k, H) {
        const K = this.RULES.all;
        k = JSON.parse(JSON.stringify(k));
        for (const D of H) {
          const m = D.split("/").slice(1);
          let R = k;
          for (const j of m)
            R = R[j];
          for (const j in K) {
            const T = K[j];
            if (typeof T != "object")
              continue;
            const { $data: eA } = T.definition, AA = R[j];
            eA && AA && (R[j] = kA(AA));
          }
        }
        return k;
      }
      _removeAllSchemas(k, H) {
        for (const K in k) {
          const D = k[K];
          (!H || H.test(K)) && (typeof D == "string" ? delete k[K] : D && !D.meta && (this._cache.delete(D.schema), delete k[K]));
        }
      }
      _addSchema(k, H, K, D = this.opts.validateSchema, m = this.opts.addUsedSchema) {
        let R;
        const { schemaId: j } = this.opts;
        if (typeof k == "object")
          R = k[j];
        else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          if (typeof k != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let T = this._cache.get(k);
        if (T !== void 0)
          return T;
        K = (0, s.normalizeId)(R || K);
        const eA = s.getSchemaRefs.call(this, k, K);
        return T = new r.SchemaEnv({ schema: k, schemaId: j, meta: H, baseId: K, localRefs: eA }), this._cache.set(T.schema, T), m && !K.startsWith("#") && (K && this._checkUnique(K), this.refs[K] = T), D && this.validateSchema(k, !0), T;
      }
      _checkUnique(k) {
        if (this.schemas[k] || this.refs[k])
          throw new Error(`schema with key or id "${k}" already exists`);
      }
      _compileSchemaEnv(k) {
        if (k.meta ? this._compileMetaSchema(k) : r.compileSchema.call(this, k), !k.validate)
          throw new Error("ajv implementation error");
        return k.validate;
      }
      _compileMetaSchema(k) {
        const H = this.opts;
        this.opts = this._metaOpts;
        try {
          r.compileSchema.call(this, k);
        } finally {
          this.opts = H;
        }
      }
    }
    y.ValidationError = t.default, y.MissingRefError = o.default, i.default = y;
    function E(q, k, H, K = "error") {
      for (const D in q) {
        const m = D;
        m in k && this.logger[K](`${H}: option ${D}. ${q[m]}`);
      }
    }
    function w(q) {
      return q = (0, s.normalizeId)(q), this.schemas[q] || this.refs[q];
    }
    function p() {
      const q = this.opts.schemas;
      if (q)
        if (Array.isArray(q))
          this.addSchema(q);
        else
          for (const k in q)
            this.addSchema(q[k], k);
    }
    function N() {
      for (const q in this.opts.formats) {
        const k = this.opts.formats[q];
        k && this.addFormat(q, k);
      }
    }
    function v(q) {
      if (Array.isArray(q)) {
        this.addVocabulary(q);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const k in q) {
        const H = q[k];
        H.keyword || (H.keyword = k), this.addKeyword(H);
      }
    }
    function U() {
      const q = { ...this.opts };
      for (const k of d)
        delete q[k];
      return q;
    }
    const L = { log() {
    }, warn() {
    }, error() {
    } };
    function P(q) {
      if (q === !1)
        return L;
      if (q === void 0)
        return console;
      if (q.log && q.warn && q.error)
        return q;
      throw new Error("logger must implement log, warn and error methods");
    }
    const V = /^[a-z_$][a-z0-9_$:-]*$/i;
    function W(q, k) {
      const { RULES: H } = this;
      if ((0, I.eachItem)(q, (K) => {
        if (H.keywords[K])
          throw new Error(`Keyword ${K} is already defined`);
        if (!V.test(K))
          throw new Error(`Keyword ${K} has invalid name`);
      }), !!k && k.$data && !("code" in k || "validate" in k))
        throw new Error('$data keyword must have "code" or "validate" function');
    }
    function QA(q, k, H) {
      var K;
      const D = k?.post;
      if (H && D)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES: m } = this;
      let R = D ? m.post : m.rules.find(({ type: T }) => T === H);
      if (R || (R = { type: H, rules: [] }, m.rules.push(R)), m.keywords[q] = !0, !k)
        return;
      const j = {
        keyword: q,
        definition: {
          ...k,
          type: (0, a.getJSONTypes)(k.type),
          schemaType: (0, a.getJSONTypes)(k.schemaType)
        }
      };
      k.before ? aA.call(this, R, j, k.before) : R.rules.push(j), m.all[q] = j, (K = k.implements) === null || K === void 0 || K.forEach((T) => this.addKeyword(T));
    }
    function aA(q, k, H) {
      const K = q.rules.findIndex((D) => D.keyword === H);
      K >= 0 ? q.rules.splice(K, 0, k) : (q.rules.push(k), this.logger.warn(`rule ${H} is not defined`));
    }
    function wA(q) {
      let { metaSchema: k } = q;
      k !== void 0 && (q.$data && this.opts.$data && (k = kA(k)), q.validateSchema = this.compile(k, !0));
    }
    const gA = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function kA(q) {
      return { anyOf: [q, gA] };
    }
  })(Ko)), Ko;
}
var zt = {}, $t = {}, Zt = {}, dn;
function Kw() {
  if (dn) return Zt;
  dn = 1, Object.defineProperty(Zt, "__esModule", { value: !0 });
  const i = {
    keyword: "id",
    code() {
      throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
    }
  };
  return Zt.default = i, Zt;
}
var ge = {}, hn;
function ir() {
  if (hn) return ge;
  hn = 1, Object.defineProperty(ge, "__esModule", { value: !0 }), ge.callRef = ge.getValidate = void 0;
  const i = Ut(), A = xA(), e = tA(), t = LA(), o = Qo(), g = nA(), r = {
    keyword: "$ref",
    schemaType: "string",
    code(a) {
      const { gen: I, schema: C, it: c } = a, { baseId: Q, schemaEnv: d, validateName: f, opts: h, self: l } = c, { root: B } = d;
      if ((C === "#" || C === "#/") && Q === B.baseId)
        return y();
      const u = o.resolveRef.call(l, B, Q, C);
      if (u === void 0)
        throw new i.default(c.opts.uriResolver, Q, C);
      if (u instanceof o.SchemaEnv)
        return E(u);
      return w(u);
      function y() {
        if (d === B)
          return s(a, f, d, d.$async);
        const p = I.scopeValue("root", { ref: B });
        return s(a, (0, e._)`${p}.validate`, B, B.$async);
      }
      function E(p) {
        const N = n(a, p);
        s(a, N, p, p.$async);
      }
      function w(p) {
        const N = I.scopeValue("schema", h.code.source === !0 ? { ref: p, code: (0, e.stringify)(p) } : { ref: p }), v = I.name("valid"), U = a.subschema({
          schema: p,
          dataTypes: [],
          schemaPath: e.nil,
          topSchemaRef: N,
          errSchemaPath: C
        }, v);
        a.mergeEvaluated(U), a.ok(v);
      }
    }
  };
  function n(a, I) {
    const { gen: C } = a;
    return I.validate ? C.scopeValue("validate", { ref: I.validate }) : (0, e._)`${C.scopeValue("wrapper", { ref: I })}.validate`;
  }
  ge.getValidate = n;
  function s(a, I, C, c) {
    const { gen: Q, it: d } = a, { allErrors: f, schemaEnv: h, opts: l } = d, B = l.passContext ? t.default.this : e.nil;
    c ? u() : y();
    function u() {
      if (!h.$async)
        throw new Error("async schema referenced by sync schema");
      const p = Q.let("valid");
      Q.try(() => {
        Q.code((0, e._)`await ${(0, A.callValidateCode)(a, I, B)}`), w(I), f || Q.assign(p, !0);
      }, (N) => {
        Q.if((0, e._)`!(${N} instanceof ${d.ValidationError})`, () => Q.throw(N)), E(N), f || Q.assign(p, !1);
      }), a.ok(p);
    }
    function y() {
      a.result((0, A.callValidateCode)(a, I, B), () => w(I), () => E(I));
    }
    function E(p) {
      const N = (0, e._)`${p}.errors`;
      Q.assign(t.default.vErrors, (0, e._)`${t.default.vErrors} === null ? ${N} : ${t.default.vErrors}.concat(${N})`), Q.assign(t.default.errors, (0, e._)`${t.default.vErrors}.length`);
    }
    function w(p) {
      var N;
      if (!d.opts.unevaluated)
        return;
      const v = (N = C?.validate) === null || N === void 0 ? void 0 : N.evaluated;
      if (d.props !== !0)
        if (v && !v.dynamicProps)
          v.props !== void 0 && (d.props = g.mergeEvaluated.props(Q, v.props, d.props));
        else {
          const U = Q.var("props", (0, e._)`${p}.evaluated.props`);
          d.props = g.mergeEvaluated.props(Q, U, d.props, e.Name);
        }
      if (d.items !== !0)
        if (v && !v.dynamicItems)
          v.items !== void 0 && (d.items = g.mergeEvaluated.items(Q, v.items, d.items));
        else {
          const U = Q.var("items", (0, e._)`${p}.evaluated.items`);
          d.items = g.mergeEvaluated.items(Q, U, d.items, e.Name);
        }
    }
  }
  return ge.callRef = s, ge.default = r, ge;
}
var un;
function $a() {
  if (un) return $t;
  un = 1, Object.defineProperty($t, "__esModule", { value: !0 });
  const i = Kw(), A = ir(), e = [
    "$schema",
    "$id",
    "$defs",
    "$vocabulary",
    { keyword: "$comment" },
    "definitions",
    i.default,
    A.default
  ];
  return $t.default = e, $t;
}
var _t = {}, Xt = {}, fn;
function Yw() {
  if (fn) return Xt;
  fn = 1, Object.defineProperty(Xt, "__esModule", { value: !0 });
  const i = tA(), A = i.operators, e = {
    maximum: { okStr: "<=", ok: A.LTE, fail: A.GT },
    minimum: { okStr: ">=", ok: A.GTE, fail: A.LT },
    exclusiveMaximum: { okStr: "<", ok: A.LT, fail: A.GTE },
    exclusiveMinimum: { okStr: ">", ok: A.GT, fail: A.LTE }
  }, t = {
    message: ({ keyword: g, schemaCode: r }) => (0, i.str)`must be ${e[g].okStr} ${r}`,
    params: ({ keyword: g, schemaCode: r }) => (0, i._)`{comparison: ${e[g].okStr}, limit: ${r}}`
  }, o = {
    keyword: Object.keys(e),
    type: "number",
    schemaType: "number",
    $data: !0,
    error: t,
    code(g) {
      const { keyword: r, data: n, schemaCode: s } = g;
      g.fail$data((0, i._)`${n} ${e[r].fail} ${s} || isNaN(${n})`);
    }
  };
  return Xt.default = o, Xt;
}
var Ai = {}, wn;
function vw() {
  if (wn) return Ai;
  wn = 1, Object.defineProperty(Ai, "__esModule", { value: !0 });
  const i = tA(), e = {
    keyword: "multipleOf",
    type: "number",
    schemaType: "number",
    $data: !0,
    error: {
      message: ({ schemaCode: t }) => (0, i.str)`must be multiple of ${t}`,
      params: ({ schemaCode: t }) => (0, i._)`{multipleOf: ${t}}`
    },
    code(t) {
      const { gen: o, data: g, schemaCode: r, it: n } = t, s = n.opts.multipleOfPrecision, a = o.let("res"), I = s ? (0, i._)`Math.abs(Math.round(${a}) - ${a}) > 1e-${s}` : (0, i._)`${a} !== parseInt(${a})`;
      t.fail$data((0, i._)`(${r} === 0 || (${a} = ${g}/${r}, ${I}))`);
    }
  };
  return Ai.default = e, Ai;
}
var ei = {}, ti = {}, yn;
function Uw() {
  if (yn) return ti;
  yn = 1, Object.defineProperty(ti, "__esModule", { value: !0 });
  function i(A) {
    const e = A.length;
    let t = 0, o = 0, g;
    for (; o < e; )
      t++, g = A.charCodeAt(o++), g >= 55296 && g <= 56319 && o < e && (g = A.charCodeAt(o), (g & 64512) === 56320 && o++);
    return t;
  }
  return ti.default = i, i.code = 'require("ajv/dist/runtime/ucs2length").default', ti;
}
var pn;
function Jw() {
  if (pn) return ei;
  pn = 1, Object.defineProperty(ei, "__esModule", { value: !0 });
  const i = tA(), A = nA(), e = Uw(), o = {
    keyword: ["maxLength", "minLength"],
    type: "string",
    schemaType: "number",
    $data: !0,
    error: {
      message({ keyword: g, schemaCode: r }) {
        const n = g === "maxLength" ? "more" : "fewer";
        return (0, i.str)`must NOT have ${n} than ${r} characters`;
      },
      params: ({ schemaCode: g }) => (0, i._)`{limit: ${g}}`
    },
    code(g) {
      const { keyword: r, data: n, schemaCode: s, it: a } = g, I = r === "maxLength" ? i.operators.GT : i.operators.LT, C = a.opts.unicode === !1 ? (0, i._)`${n}.length` : (0, i._)`${(0, A.useFunc)(g.gen, e.default)}(${n})`;
      g.fail$data((0, i._)`${C} ${I} ${s}`);
    }
  };
  return ei.default = o, ei;
}
var ii = {}, Dn;
function Hw() {
  if (Dn) return ii;
  Dn = 1, Object.defineProperty(ii, "__esModule", { value: !0 });
  const i = xA(), A = tA(), t = {
    keyword: "pattern",
    type: "string",
    schemaType: "string",
    $data: !0,
    error: {
      message: ({ schemaCode: o }) => (0, A.str)`must match pattern "${o}"`,
      params: ({ schemaCode: o }) => (0, A._)`{pattern: ${o}}`
    },
    code(o) {
      const { data: g, $data: r, schema: n, schemaCode: s, it: a } = o, I = a.opts.unicodeRegExp ? "u" : "", C = r ? (0, A._)`(new RegExp(${s}, ${I}))` : (0, i.usePattern)(o, n);
      o.fail$data((0, A._)`!${C}.test(${g})`);
    }
  };
  return ii.default = t, ii;
}
var oi = {}, mn;
function qw() {
  if (mn) return oi;
  mn = 1, Object.defineProperty(oi, "__esModule", { value: !0 });
  const i = tA(), e = {
    keyword: ["maxProperties", "minProperties"],
    type: "object",
    schemaType: "number",
    $data: !0,
    error: {
      message({ keyword: t, schemaCode: o }) {
        const g = t === "maxProperties" ? "more" : "fewer";
        return (0, i.str)`must NOT have ${g} than ${o} properties`;
      },
      params: ({ schemaCode: t }) => (0, i._)`{limit: ${t}}`
    },
    code(t) {
      const { keyword: o, data: g, schemaCode: r } = t, n = o === "maxProperties" ? i.operators.GT : i.operators.LT;
      t.fail$data((0, i._)`Object.keys(${g}).length ${n} ${r}`);
    }
  };
  return oi.default = e, oi;
}
var gi = {}, Sn;
function Lw() {
  if (Sn) return gi;
  Sn = 1, Object.defineProperty(gi, "__esModule", { value: !0 });
  const i = xA(), A = tA(), e = nA(), o = {
    keyword: "required",
    type: "object",
    schemaType: "array",
    $data: !0,
    error: {
      message: ({ params: { missingProperty: g } }) => (0, A.str)`must have required property '${g}'`,
      params: ({ params: { missingProperty: g } }) => (0, A._)`{missingProperty: ${g}}`
    },
    code(g) {
      const { gen: r, schema: n, schemaCode: s, data: a, $data: I, it: C } = g, { opts: c } = C;
      if (!I && n.length === 0)
        return;
      const Q = n.length >= c.loopRequired;
      if (C.allErrors ? d() : f(), c.strictRequired) {
        const B = g.parentSchema.properties, { definedProperties: u } = g.it;
        for (const y of n)
          if (B?.[y] === void 0 && !u.has(y)) {
            const E = C.schemaEnv.baseId + C.errSchemaPath, w = `required property "${y}" is not defined at "${E}" (strictRequired)`;
            (0, e.checkStrictMode)(C, w, C.opts.strictRequired);
          }
      }
      function d() {
        if (Q || I)
          g.block$data(A.nil, h);
        else
          for (const B of n)
            (0, i.checkReportMissingProp)(g, B);
      }
      function f() {
        const B = r.let("missing");
        if (Q || I) {
          const u = r.let("valid", !0);
          g.block$data(u, () => l(B, u)), g.ok(u);
        } else
          r.if((0, i.checkMissingProp)(g, n, B)), (0, i.reportMissingProp)(g, B), r.else();
      }
      function h() {
        r.forOf("prop", s, (B) => {
          g.setParams({ missingProperty: B }), r.if((0, i.noPropertyInData)(r, a, B, c.ownProperties), () => g.error());
        });
      }
      function l(B, u) {
        g.setParams({ missingProperty: B }), r.forOf(B, s, () => {
          r.assign(u, (0, i.propertyInData)(r, a, B, c.ownProperties)), r.if((0, A.not)(u), () => {
            g.error(), r.break();
          });
        }, A.nil);
      }
    }
  };
  return gi.default = o, gi;
}
var ri = {}, Nn;
function xw() {
  if (Nn) return ri;
  Nn = 1, Object.defineProperty(ri, "__esModule", { value: !0 });
  const i = tA(), e = {
    keyword: ["maxItems", "minItems"],
    type: "array",
    schemaType: "number",
    $data: !0,
    error: {
      message({ keyword: t, schemaCode: o }) {
        const g = t === "maxItems" ? "more" : "fewer";
        return (0, i.str)`must NOT have ${g} than ${o} items`;
      },
      params: ({ schemaCode: t }) => (0, i._)`{limit: ${t}}`
    },
    code(t) {
      const { keyword: o, data: g, schemaCode: r } = t, n = o === "maxItems" ? i.operators.GT : i.operators.LT;
      t.fail$data((0, i._)`${g}.length ${n} ${r}`);
    }
  };
  return ri.default = e, ri;
}
var ni = {}, si = {}, Mn;
function or() {
  if (Mn) return si;
  Mn = 1, Object.defineProperty(si, "__esModule", { value: !0 });
  const i = Va();
  return i.code = 'require("ajv/dist/runtime/equal").default', si.default = i, si;
}
var Gn;
function Tw() {
  if (Gn) return ni;
  Gn = 1, Object.defineProperty(ni, "__esModule", { value: !0 });
  const i = _i(), A = tA(), e = nA(), t = or(), g = {
    keyword: "uniqueItems",
    type: "array",
    schemaType: "boolean",
    $data: !0,
    error: {
      message: ({ params: { i: r, j: n } }) => (0, A.str)`must NOT have duplicate items (items ## ${n} and ${r} are identical)`,
      params: ({ params: { i: r, j: n } }) => (0, A._)`{i: ${r}, j: ${n}}`
    },
    code(r) {
      const { gen: n, data: s, $data: a, schema: I, parentSchema: C, schemaCode: c, it: Q } = r;
      if (!a && !I)
        return;
      const d = n.let("valid"), f = C.items ? (0, i.getSchemaTypes)(C.items) : [];
      r.block$data(d, h, (0, A._)`${c} === false`), r.ok(d);
      function h() {
        const y = n.let("i", (0, A._)`${s}.length`), E = n.let("j");
        r.setParams({ i: y, j: E }), n.assign(d, !0), n.if((0, A._)`${y} > 1`, () => (l() ? B : u)(y, E));
      }
      function l() {
        return f.length > 0 && !f.some((y) => y === "object" || y === "array");
      }
      function B(y, E) {
        const w = n.name("item"), p = (0, i.checkDataTypes)(f, w, Q.opts.strictNumbers, i.DataType.Wrong), N = n.const("indices", (0, A._)`{}`);
        n.for((0, A._)`;${y}--;`, () => {
          n.let(w, (0, A._)`${s}[${y}]`), n.if(p, (0, A._)`continue`), f.length > 1 && n.if((0, A._)`typeof ${w} == "string"`, (0, A._)`${w} += "_"`), n.if((0, A._)`typeof ${N}[${w}] == "number"`, () => {
            n.assign(E, (0, A._)`${N}[${w}]`), r.error(), n.assign(d, !1).break();
          }).code((0, A._)`${N}[${w}] = ${y}`);
        });
      }
      function u(y, E) {
        const w = (0, e.useFunc)(n, t.default), p = n.name("outer");
        n.label(p).for((0, A._)`;${y}--;`, () => n.for((0, A._)`${E} = ${y}; ${E}--;`, () => n.if((0, A._)`${w}(${s}[${y}], ${s}[${E}])`, () => {
          r.error(), n.assign(d, !1).break(p);
        })));
      }
    }
  };
  return ni.default = g, ni;
}
var ai = {}, kn;
function Ow() {
  if (kn) return ai;
  kn = 1, Object.defineProperty(ai, "__esModule", { value: !0 });
  const i = tA(), A = nA(), e = or(), o = {
    keyword: "const",
    $data: !0,
    error: {
      message: "must be equal to constant",
      params: ({ schemaCode: g }) => (0, i._)`{allowedValue: ${g}}`
    },
    code(g) {
      const { gen: r, data: n, $data: s, schemaCode: a, schema: I } = g;
      s || I && typeof I == "object" ? g.fail$data((0, i._)`!${(0, A.useFunc)(r, e.default)}(${n}, ${a})`) : g.fail((0, i._)`${I} !== ${n}`);
    }
  };
  return ai.default = o, ai;
}
var Ii = {}, Fn;
function Pw() {
  if (Fn) return Ii;
  Fn = 1, Object.defineProperty(Ii, "__esModule", { value: !0 });
  const i = tA(), A = nA(), e = or(), o = {
    keyword: "enum",
    schemaType: "array",
    $data: !0,
    error: {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode: g }) => (0, i._)`{allowedValues: ${g}}`
    },
    code(g) {
      const { gen: r, data: n, $data: s, schema: a, schemaCode: I, it: C } = g;
      if (!s && a.length === 0)
        throw new Error("enum must have non-empty array");
      const c = a.length >= C.opts.loopEnum;
      let Q;
      const d = () => Q ?? (Q = (0, A.useFunc)(r, e.default));
      let f;
      if (c || s)
        f = r.let("valid"), g.block$data(f, h);
      else {
        if (!Array.isArray(a))
          throw new Error("ajv implementation error");
        const B = r.const("vSchema", I);
        f = (0, i.or)(...a.map((u, y) => l(B, y)));
      }
      g.pass(f);
      function h() {
        r.assign(f, !1), r.forOf("v", I, (B) => r.if((0, i._)`${d()}(${n}, ${B})`, () => r.assign(f, !0).break()));
      }
      function l(B, u) {
        const y = a[u];
        return typeof y == "object" && y !== null ? (0, i._)`${d()}(${n}, ${B}[${u}])` : (0, i._)`${n} === ${y}`;
      }
    }
  };
  return Ii.default = o, Ii;
}
var Rn;
function Za() {
  if (Rn) return _t;
  Rn = 1, Object.defineProperty(_t, "__esModule", { value: !0 });
  const i = Yw(), A = vw(), e = Jw(), t = Hw(), o = qw(), g = Lw(), r = xw(), n = Tw(), s = Ow(), a = Pw(), I = [
    // number
    i.default,
    A.default,
    // string
    e.default,
    t.default,
    // object
    o.default,
    g.default,
    // array
    r.default,
    n.default,
    // any
    { keyword: "type", schemaType: ["string", "array"] },
    { keyword: "nullable", schemaType: "boolean" },
    s.default,
    a.default
  ];
  return _t.default = I, _t;
}
var Ci = {}, Ue = {}, bn;
function _a() {
  if (bn) return Ue;
  bn = 1, Object.defineProperty(Ue, "__esModule", { value: !0 }), Ue.validateAdditionalItems = void 0;
  const i = tA(), A = nA(), t = {
    keyword: "additionalItems",
    type: "array",
    schemaType: ["boolean", "object"],
    before: "uniqueItems",
    error: {
      message: ({ params: { len: g } }) => (0, i.str)`must NOT have more than ${g} items`,
      params: ({ params: { len: g } }) => (0, i._)`{limit: ${g}}`
    },
    code(g) {
      const { parentSchema: r, it: n } = g, { items: s } = r;
      if (!Array.isArray(s)) {
        (0, A.checkStrictMode)(n, '"additionalItems" is ignored when "items" is not an array of schemas');
        return;
      }
      o(g, s);
    }
  };
  function o(g, r) {
    const { gen: n, schema: s, data: a, keyword: I, it: C } = g;
    C.items = !0;
    const c = n.const("len", (0, i._)`${a}.length`);
    if (s === !1)
      g.setParams({ len: r.length }), g.pass((0, i._)`${c} <= ${r.length}`);
    else if (typeof s == "object" && !(0, A.alwaysValidSchema)(C, s)) {
      const d = n.var("valid", (0, i._)`${c} <= ${r.length}`);
      n.if((0, i.not)(d), () => Q(d)), g.ok(d);
    }
    function Q(d) {
      n.forRange("i", r.length, c, (f) => {
        g.subschema({ keyword: I, dataProp: f, dataPropType: A.Type.Num }, d), C.allErrors || n.if((0, i.not)(d), () => n.break());
      });
    }
  }
  return Ue.validateAdditionalItems = o, Ue.default = t, Ue;
}
var ci = {}, Je = {}, Kn;
function Xa() {
  if (Kn) return Je;
  Kn = 1, Object.defineProperty(Je, "__esModule", { value: !0 }), Je.validateTuple = void 0;
  const i = tA(), A = nA(), e = xA(), t = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "array", "boolean"],
    before: "uniqueItems",
    code(g) {
      const { schema: r, it: n } = g;
      if (Array.isArray(r))
        return o(g, "additionalItems", r);
      n.items = !0, !(0, A.alwaysValidSchema)(n, r) && g.ok((0, e.validateArray)(g));
    }
  };
  function o(g, r, n = g.schema) {
    const { gen: s, parentSchema: a, data: I, keyword: C, it: c } = g;
    f(a), c.opts.unevaluated && n.length && c.items !== !0 && (c.items = A.mergeEvaluated.items(s, n.length, c.items));
    const Q = s.name("valid"), d = s.const("len", (0, i._)`${I}.length`);
    n.forEach((h, l) => {
      (0, A.alwaysValidSchema)(c, h) || (s.if((0, i._)`${d} > ${l}`, () => g.subschema({
        keyword: C,
        schemaProp: l,
        dataProp: l
      }, Q)), g.ok(Q));
    });
    function f(h) {
      const { opts: l, errSchemaPath: B } = c, u = n.length, y = u === h.minItems && (u === h.maxItems || h[r] === !1);
      if (l.strictTuples && !y) {
        const E = `"${C}" is ${u}-tuple, but minItems or maxItems/${r} are not specified or different at path "${B}"`;
        (0, A.checkStrictMode)(c, E, l.strictTuples);
      }
    }
  }
  return Je.validateTuple = o, Je.default = t, Je;
}
var Yn;
function jw() {
  if (Yn) return ci;
  Yn = 1, Object.defineProperty(ci, "__esModule", { value: !0 });
  const i = Xa(), A = {
    keyword: "prefixItems",
    type: "array",
    schemaType: ["array"],
    before: "uniqueItems",
    code: (e) => (0, i.validateTuple)(e, "items")
  };
  return ci.default = A, ci;
}
var Bi = {}, vn;
function Vw() {
  if (vn) return Bi;
  vn = 1, Object.defineProperty(Bi, "__esModule", { value: !0 });
  const i = tA(), A = nA(), e = xA(), t = _a(), g = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    error: {
      message: ({ params: { len: r } }) => (0, i.str)`must NOT have more than ${r} items`,
      params: ({ params: { len: r } }) => (0, i._)`{limit: ${r}}`
    },
    code(r) {
      const { schema: n, parentSchema: s, it: a } = r, { prefixItems: I } = s;
      a.items = !0, !(0, A.alwaysValidSchema)(a, n) && (I ? (0, t.validateAdditionalItems)(r, I) : r.ok((0, e.validateArray)(r)));
    }
  };
  return Bi.default = g, Bi;
}
var Qi = {}, Un;
function Ww() {
  if (Un) return Qi;
  Un = 1, Object.defineProperty(Qi, "__esModule", { value: !0 });
  const i = tA(), A = nA(), t = {
    keyword: "contains",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    trackErrors: !0,
    error: {
      message: ({ params: { min: o, max: g } }) => g === void 0 ? (0, i.str)`must contain at least ${o} valid item(s)` : (0, i.str)`must contain at least ${o} and no more than ${g} valid item(s)`,
      params: ({ params: { min: o, max: g } }) => g === void 0 ? (0, i._)`{minContains: ${o}}` : (0, i._)`{minContains: ${o}, maxContains: ${g}}`
    },
    code(o) {
      const { gen: g, schema: r, parentSchema: n, data: s, it: a } = o;
      let I, C;
      const { minContains: c, maxContains: Q } = n;
      a.opts.next ? (I = c === void 0 ? 1 : c, C = Q) : I = 1;
      const d = g.const("len", (0, i._)`${s}.length`);
      if (o.setParams({ min: I, max: C }), C === void 0 && I === 0) {
        (0, A.checkStrictMode)(a, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
        return;
      }
      if (C !== void 0 && I > C) {
        (0, A.checkStrictMode)(a, '"minContains" > "maxContains" is always invalid'), o.fail();
        return;
      }
      if ((0, A.alwaysValidSchema)(a, r)) {
        let u = (0, i._)`${d} >= ${I}`;
        C !== void 0 && (u = (0, i._)`${u} && ${d} <= ${C}`), o.pass(u);
        return;
      }
      a.items = !0;
      const f = g.name("valid");
      C === void 0 && I === 1 ? l(f, () => g.if(f, () => g.break())) : I === 0 ? (g.let(f, !0), C !== void 0 && g.if((0, i._)`${s}.length > 0`, h)) : (g.let(f, !1), h()), o.result(f, () => o.reset());
      function h() {
        const u = g.name("_valid"), y = g.let("count", 0);
        l(u, () => g.if(u, () => B(y)));
      }
      function l(u, y) {
        g.forRange("i", 0, d, (E) => {
          o.subschema({
            keyword: "contains",
            dataProp: E,
            dataPropType: A.Type.Num,
            compositeRule: !0
          }, u), y();
        });
      }
      function B(u) {
        g.code((0, i._)`${u}++`), C === void 0 ? g.if((0, i._)`${u} >= ${I}`, () => g.assign(f, !0).break()) : (g.if((0, i._)`${u} > ${C}`, () => g.assign(f, !1).break()), I === 1 ? g.assign(f, !0) : g.if((0, i._)`${u} >= ${I}`, () => g.assign(f, !0)));
      }
    }
  };
  return Qi.default = t, Qi;
}
var To = {}, Jn;
function gr() {
  return Jn || (Jn = 1, (function(i) {
    Object.defineProperty(i, "__esModule", { value: !0 }), i.validateSchemaDeps = i.validatePropertyDeps = i.error = void 0;
    const A = tA(), e = nA(), t = xA();
    i.error = {
      message: ({ params: { property: s, depsCount: a, deps: I } }) => {
        const C = a === 1 ? "property" : "properties";
        return (0, A.str)`must have ${C} ${I} when property ${s} is present`;
      },
      params: ({ params: { property: s, depsCount: a, deps: I, missingProperty: C } }) => (0, A._)`{property: ${s},
    missingProperty: ${C},
    depsCount: ${a},
    deps: ${I}}`
      // TODO change to reference
    };
    const o = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: i.error,
      code(s) {
        const [a, I] = g(s);
        r(s, a), n(s, I);
      }
    };
    function g({ schema: s }) {
      const a = {}, I = {};
      for (const C in s) {
        if (C === "__proto__")
          continue;
        const c = Array.isArray(s[C]) ? a : I;
        c[C] = s[C];
      }
      return [a, I];
    }
    function r(s, a = s.schema) {
      const { gen: I, data: C, it: c } = s;
      if (Object.keys(a).length === 0)
        return;
      const Q = I.let("missing");
      for (const d in a) {
        const f = a[d];
        if (f.length === 0)
          continue;
        const h = (0, t.propertyInData)(I, C, d, c.opts.ownProperties);
        s.setParams({
          property: d,
          depsCount: f.length,
          deps: f.join(", ")
        }), c.allErrors ? I.if(h, () => {
          for (const l of f)
            (0, t.checkReportMissingProp)(s, l);
        }) : (I.if((0, A._)`${h} && (${(0, t.checkMissingProp)(s, f, Q)})`), (0, t.reportMissingProp)(s, Q), I.else());
      }
    }
    i.validatePropertyDeps = r;
    function n(s, a = s.schema) {
      const { gen: I, data: C, keyword: c, it: Q } = s, d = I.name("valid");
      for (const f in a)
        (0, e.alwaysValidSchema)(Q, a[f]) || (I.if(
          (0, t.propertyInData)(I, C, f, Q.opts.ownProperties),
          () => {
            const h = s.subschema({ keyword: c, schemaProp: f }, d);
            s.mergeValidEvaluated(h, d);
          },
          () => I.var(d, !0)
          // TODO var
        ), s.ok(d));
    }
    i.validateSchemaDeps = n, i.default = o;
  })(To)), To;
}
var Ei = {}, Hn;
function zw() {
  if (Hn) return Ei;
  Hn = 1, Object.defineProperty(Ei, "__esModule", { value: !0 });
  const i = tA(), A = nA(), t = {
    keyword: "propertyNames",
    type: "object",
    schemaType: ["object", "boolean"],
    error: {
      message: "property name must be valid",
      params: ({ params: o }) => (0, i._)`{propertyName: ${o.propertyName}}`
    },
    code(o) {
      const { gen: g, schema: r, data: n, it: s } = o;
      if ((0, A.alwaysValidSchema)(s, r))
        return;
      const a = g.name("valid");
      g.forIn("key", n, (I) => {
        o.setParams({ propertyName: I }), o.subschema({
          keyword: "propertyNames",
          data: I,
          dataTypes: ["string"],
          propertyName: I,
          compositeRule: !0
        }, a), g.if((0, i.not)(a), () => {
          o.error(!0), s.allErrors || g.break();
        });
      }), o.ok(a);
    }
  };
  return Ei.default = t, Ei;
}
var li = {}, qn;
function AI() {
  if (qn) return li;
  qn = 1, Object.defineProperty(li, "__esModule", { value: !0 });
  const i = xA(), A = tA(), e = LA(), t = nA(), g = {
    keyword: "additionalProperties",
    type: ["object"],
    schemaType: ["boolean", "object"],
    allowUndefined: !0,
    trackErrors: !0,
    error: {
      message: "must NOT have additional properties",
      params: ({ params: r }) => (0, A._)`{additionalProperty: ${r.additionalProperty}}`
    },
    code(r) {
      const { gen: n, schema: s, parentSchema: a, data: I, errsCount: C, it: c } = r;
      if (!C)
        throw new Error("ajv implementation error");
      const { allErrors: Q, opts: d } = c;
      if (c.props = !0, d.removeAdditional !== "all" && (0, t.alwaysValidSchema)(c, s))
        return;
      const f = (0, i.allSchemaProperties)(a.properties), h = (0, i.allSchemaProperties)(a.patternProperties);
      l(), r.ok((0, A._)`${C} === ${e.default.errors}`);
      function l() {
        n.forIn("key", I, (w) => {
          !f.length && !h.length ? y(w) : n.if(B(w), () => y(w));
        });
      }
      function B(w) {
        let p;
        if (f.length > 8) {
          const N = (0, t.schemaRefOrVal)(c, a.properties, "properties");
          p = (0, i.isOwnProperty)(n, N, w);
        } else f.length ? p = (0, A.or)(...f.map((N) => (0, A._)`${w} === ${N}`)) : p = A.nil;
        return h.length && (p = (0, A.or)(p, ...h.map((N) => (0, A._)`${(0, i.usePattern)(r, N)}.test(${w})`))), (0, A.not)(p);
      }
      function u(w) {
        n.code((0, A._)`delete ${I}[${w}]`);
      }
      function y(w) {
        if (d.removeAdditional === "all" || d.removeAdditional && s === !1) {
          u(w);
          return;
        }
        if (s === !1) {
          r.setParams({ additionalProperty: w }), r.error(), Q || n.break();
          return;
        }
        if (typeof s == "object" && !(0, t.alwaysValidSchema)(c, s)) {
          const p = n.name("valid");
          d.removeAdditional === "failing" ? (E(w, p, !1), n.if((0, A.not)(p), () => {
            r.reset(), u(w);
          })) : (E(w, p), Q || n.if((0, A.not)(p), () => n.break()));
        }
      }
      function E(w, p, N) {
        const v = {
          keyword: "additionalProperties",
          dataProp: w,
          dataPropType: t.Type.Str
        };
        N === !1 && Object.assign(v, {
          compositeRule: !0,
          createErrors: !1,
          allErrors: !1
        }), r.subschema(v, p);
      }
    }
  };
  return li.default = g, li;
}
var di = {}, Ln;
function $w() {
  if (Ln) return di;
  Ln = 1, Object.defineProperty(di, "__esModule", { value: !0 });
  const i = vt(), A = xA(), e = nA(), t = AI(), o = {
    keyword: "properties",
    type: "object",
    schemaType: "object",
    code(g) {
      const { gen: r, schema: n, parentSchema: s, data: a, it: I } = g;
      I.opts.removeAdditional === "all" && s.additionalProperties === void 0 && t.default.code(new i.KeywordCxt(I, t.default, "additionalProperties"));
      const C = (0, A.allSchemaProperties)(n);
      for (const h of C)
        I.definedProperties.add(h);
      I.opts.unevaluated && C.length && I.props !== !0 && (I.props = e.mergeEvaluated.props(r, (0, e.toHash)(C), I.props));
      const c = C.filter((h) => !(0, e.alwaysValidSchema)(I, n[h]));
      if (c.length === 0)
        return;
      const Q = r.name("valid");
      for (const h of c)
        d(h) ? f(h) : (r.if((0, A.propertyInData)(r, a, h, I.opts.ownProperties)), f(h), I.allErrors || r.else().var(Q, !0), r.endIf()), g.it.definedProperties.add(h), g.ok(Q);
      function d(h) {
        return I.opts.useDefaults && !I.compositeRule && n[h].default !== void 0;
      }
      function f(h) {
        g.subschema({
          keyword: "properties",
          schemaProp: h,
          dataProp: h
        }, Q);
      }
    }
  };
  return di.default = o, di;
}
var hi = {}, xn;
function Zw() {
  if (xn) return hi;
  xn = 1, Object.defineProperty(hi, "__esModule", { value: !0 });
  const i = xA(), A = tA(), e = nA(), t = nA(), o = {
    keyword: "patternProperties",
    type: "object",
    schemaType: "object",
    code(g) {
      const { gen: r, schema: n, data: s, parentSchema: a, it: I } = g, { opts: C } = I, c = (0, i.allSchemaProperties)(n), Q = c.filter((y) => (0, e.alwaysValidSchema)(I, n[y]));
      if (c.length === 0 || Q.length === c.length && (!I.opts.unevaluated || I.props === !0))
        return;
      const d = C.strictSchema && !C.allowMatchingProperties && a.properties, f = r.name("valid");
      I.props !== !0 && !(I.props instanceof A.Name) && (I.props = (0, t.evaluatedPropsToName)(r, I.props));
      const { props: h } = I;
      l();
      function l() {
        for (const y of c)
          d && B(y), I.allErrors ? u(y) : (r.var(f, !0), u(y), r.if(f));
      }
      function B(y) {
        for (const E in d)
          new RegExp(y).test(E) && (0, e.checkStrictMode)(I, `property ${E} matches pattern ${y} (use allowMatchingProperties)`);
      }
      function u(y) {
        r.forIn("key", s, (E) => {
          r.if((0, A._)`${(0, i.usePattern)(g, y)}.test(${E})`, () => {
            const w = Q.includes(y);
            w || g.subschema({
              keyword: "patternProperties",
              schemaProp: y,
              dataProp: E,
              dataPropType: t.Type.Str
            }, f), I.opts.unevaluated && h !== !0 ? r.assign((0, A._)`${h}[${E}]`, !0) : !w && !I.allErrors && r.if((0, A.not)(f), () => r.break());
          });
        });
      }
    }
  };
  return hi.default = o, hi;
}
var ui = {}, Tn;
function _w() {
  if (Tn) return ui;
  Tn = 1, Object.defineProperty(ui, "__esModule", { value: !0 });
  const i = nA(), A = {
    keyword: "not",
    schemaType: ["object", "boolean"],
    trackErrors: !0,
    code(e) {
      const { gen: t, schema: o, it: g } = e;
      if ((0, i.alwaysValidSchema)(g, o)) {
        e.fail();
        return;
      }
      const r = t.name("valid");
      e.subschema({
        keyword: "not",
        compositeRule: !0,
        createErrors: !1,
        allErrors: !1
      }, r), e.failResult(r, () => e.reset(), () => e.error());
    },
    error: { message: "must NOT be valid" }
  };
  return ui.default = A, ui;
}
var fi = {}, On;
function Xw() {
  if (On) return fi;
  On = 1, Object.defineProperty(fi, "__esModule", { value: !0 });
  const A = {
    keyword: "anyOf",
    schemaType: "array",
    trackErrors: !0,
    code: xA().validateUnion,
    error: { message: "must match a schema in anyOf" }
  };
  return fi.default = A, fi;
}
var wi = {}, Pn;
function Ay() {
  if (Pn) return wi;
  Pn = 1, Object.defineProperty(wi, "__esModule", { value: !0 });
  const i = tA(), A = nA(), t = {
    keyword: "oneOf",
    schemaType: "array",
    trackErrors: !0,
    error: {
      message: "must match exactly one schema in oneOf",
      params: ({ params: o }) => (0, i._)`{passingSchemas: ${o.passing}}`
    },
    code(o) {
      const { gen: g, schema: r, parentSchema: n, it: s } = o;
      if (!Array.isArray(r))
        throw new Error("ajv implementation error");
      if (s.opts.discriminator && n.discriminator)
        return;
      const a = r, I = g.let("valid", !1), C = g.let("passing", null), c = g.name("_valid");
      o.setParams({ passing: C }), g.block(Q), o.result(I, () => o.reset(), () => o.error(!0));
      function Q() {
        a.forEach((d, f) => {
          let h;
          (0, A.alwaysValidSchema)(s, d) ? g.var(c, !0) : h = o.subschema({
            keyword: "oneOf",
            schemaProp: f,
            compositeRule: !0
          }, c), f > 0 && g.if((0, i._)`${c} && ${I}`).assign(I, !1).assign(C, (0, i._)`[${C}, ${f}]`).else(), g.if(c, () => {
            g.assign(I, !0), g.assign(C, f), h && o.mergeEvaluated(h, i.Name);
          });
        });
      }
    }
  };
  return wi.default = t, wi;
}
var yi = {}, jn;
function ey() {
  if (jn) return yi;
  jn = 1, Object.defineProperty(yi, "__esModule", { value: !0 });
  const i = nA(), A = {
    keyword: "allOf",
    schemaType: "array",
    code(e) {
      const { gen: t, schema: o, it: g } = e;
      if (!Array.isArray(o))
        throw new Error("ajv implementation error");
      const r = t.name("valid");
      o.forEach((n, s) => {
        if ((0, i.alwaysValidSchema)(g, n))
          return;
        const a = e.subschema({ keyword: "allOf", schemaProp: s }, r);
        e.ok(r), e.mergeEvaluated(a);
      });
    }
  };
  return yi.default = A, yi;
}
var pi = {}, Vn;
function ty() {
  if (Vn) return pi;
  Vn = 1, Object.defineProperty(pi, "__esModule", { value: !0 });
  const i = tA(), A = nA(), t = {
    keyword: "if",
    schemaType: ["object", "boolean"],
    trackErrors: !0,
    error: {
      message: ({ params: g }) => (0, i.str)`must match "${g.ifClause}" schema`,
      params: ({ params: g }) => (0, i._)`{failingKeyword: ${g.ifClause}}`
    },
    code(g) {
      const { gen: r, parentSchema: n, it: s } = g;
      n.then === void 0 && n.else === void 0 && (0, A.checkStrictMode)(s, '"if" without "then" and "else" is ignored');
      const a = o(s, "then"), I = o(s, "else");
      if (!a && !I)
        return;
      const C = r.let("valid", !0), c = r.name("_valid");
      if (Q(), g.reset(), a && I) {
        const f = r.let("ifClause");
        g.setParams({ ifClause: f }), r.if(c, d("then", f), d("else", f));
      } else a ? r.if(c, d("then")) : r.if((0, i.not)(c), d("else"));
      g.pass(C, () => g.error(!0));
      function Q() {
        const f = g.subschema({
          keyword: "if",
          compositeRule: !0,
          createErrors: !1,
          allErrors: !1
        }, c);
        g.mergeEvaluated(f);
      }
      function d(f, h) {
        return () => {
          const l = g.subschema({ keyword: f }, c);
          r.assign(C, c), g.mergeValidEvaluated(l, C), h ? r.assign(h, (0, i._)`${f}`) : g.setParams({ ifClause: f });
        };
      }
    }
  };
  function o(g, r) {
    const n = g.schema[r];
    return n !== void 0 && !(0, A.alwaysValidSchema)(g, n);
  }
  return pi.default = t, pi;
}
var Di = {}, Wn;
function iy() {
  if (Wn) return Di;
  Wn = 1, Object.defineProperty(Di, "__esModule", { value: !0 });
  const i = nA(), A = {
    keyword: ["then", "else"],
    schemaType: ["object", "boolean"],
    code({ keyword: e, parentSchema: t, it: o }) {
      t.if === void 0 && (0, i.checkStrictMode)(o, `"${e}" without "if" is ignored`);
    }
  };
  return Di.default = A, Di;
}
var zn;
function eI() {
  if (zn) return Ci;
  zn = 1, Object.defineProperty(Ci, "__esModule", { value: !0 });
  const i = _a(), A = jw(), e = Xa(), t = Vw(), o = Ww(), g = gr(), r = zw(), n = AI(), s = $w(), a = Zw(), I = _w(), C = Xw(), c = Ay(), Q = ey(), d = ty(), f = iy();
  function h(l = !1) {
    const B = [
      // any
      I.default,
      C.default,
      c.default,
      Q.default,
      d.default,
      f.default,
      // object
      r.default,
      n.default,
      g.default,
      s.default,
      a.default
    ];
    return l ? B.push(A.default, t.default) : B.push(i.default, e.default), B.push(o.default), B;
  }
  return Ci.default = h, Ci;
}
var mi = {}, He = {}, $n;
function tI() {
  if ($n) return He;
  $n = 1, Object.defineProperty(He, "__esModule", { value: !0 }), He.dynamicAnchor = void 0;
  const i = tA(), A = LA(), e = Qo(), t = ir(), o = {
    keyword: "$dynamicAnchor",
    schemaType: "string",
    code: (n) => g(n, n.schema)
  };
  function g(n, s) {
    const { gen: a, it: I } = n;
    I.schemaEnv.root.dynamicAnchors[s] = !0;
    const C = (0, i._)`${A.default.dynamicAnchors}${(0, i.getProperty)(s)}`, c = I.errSchemaPath === "#" ? I.validateName : r(n);
    a.if((0, i._)`!${C}`, () => a.assign(C, c));
  }
  He.dynamicAnchor = g;
  function r(n) {
    const { schemaEnv: s, schema: a, self: I } = n.it, { root: C, baseId: c, localRefs: Q, meta: d } = s.root, { schemaId: f } = I.opts, h = new e.SchemaEnv({ schema: a, schemaId: f, root: C, baseId: c, localRefs: Q, meta: d });
    return e.compileSchema.call(I, h), (0, t.getValidate)(n, h);
  }
  return He.default = o, He;
}
var qe = {}, Zn;
function iI() {
  if (Zn) return qe;
  Zn = 1, Object.defineProperty(qe, "__esModule", { value: !0 }), qe.dynamicRef = void 0;
  const i = tA(), A = LA(), e = ir(), t = {
    keyword: "$dynamicRef",
    schemaType: "string",
    code: (g) => o(g, g.schema)
  };
  function o(g, r) {
    const { gen: n, keyword: s, it: a } = g;
    if (r[0] !== "#")
      throw new Error(`"${s}" only supports hash fragment reference`);
    const I = r.slice(1);
    if (a.allErrors)
      C();
    else {
      const Q = n.let("valid", !1);
      C(Q), g.ok(Q);
    }
    function C(Q) {
      if (a.schemaEnv.root.dynamicAnchors[I]) {
        const d = n.let("_v", (0, i._)`${A.default.dynamicAnchors}${(0, i.getProperty)(I)}`);
        n.if(d, c(d, Q), c(a.validateName, Q));
      } else
        c(a.validateName, Q)();
    }
    function c(Q, d) {
      return d ? () => n.block(() => {
        (0, e.callRef)(g, Q), n.let(d, !0);
      }) : () => (0, e.callRef)(g, Q);
    }
  }
  return qe.dynamicRef = o, qe.default = t, qe;
}
var Si = {}, _n;
function oy() {
  if (_n) return Si;
  _n = 1, Object.defineProperty(Si, "__esModule", { value: !0 });
  const i = tI(), A = nA(), e = {
    keyword: "$recursiveAnchor",
    schemaType: "boolean",
    code(t) {
      t.schema ? (0, i.dynamicAnchor)(t, "") : (0, A.checkStrictMode)(t.it, "$recursiveAnchor: false is ignored");
    }
  };
  return Si.default = e, Si;
}
var Ni = {}, Xn;
function gy() {
  if (Xn) return Ni;
  Xn = 1, Object.defineProperty(Ni, "__esModule", { value: !0 });
  const i = iI(), A = {
    keyword: "$recursiveRef",
    schemaType: "string",
    code: (e) => (0, i.dynamicRef)(e, e.schema)
  };
  return Ni.default = A, Ni;
}
var As;
function ry() {
  if (As) return mi;
  As = 1, Object.defineProperty(mi, "__esModule", { value: !0 });
  const i = tI(), A = iI(), e = oy(), t = gy(), o = [i.default, A.default, e.default, t.default];
  return mi.default = o, mi;
}
var Mi = {}, Gi = {}, es;
function ny() {
  if (es) return Gi;
  es = 1, Object.defineProperty(Gi, "__esModule", { value: !0 });
  const i = gr(), A = {
    keyword: "dependentRequired",
    type: "object",
    schemaType: "object",
    error: i.error,
    code: (e) => (0, i.validatePropertyDeps)(e)
  };
  return Gi.default = A, Gi;
}
var ki = {}, ts;
function sy() {
  if (ts) return ki;
  ts = 1, Object.defineProperty(ki, "__esModule", { value: !0 });
  const i = gr(), A = {
    keyword: "dependentSchemas",
    type: "object",
    schemaType: "object",
    code: (e) => (0, i.validateSchemaDeps)(e)
  };
  return ki.default = A, ki;
}
var Fi = {}, is;
function ay() {
  if (is) return Fi;
  is = 1, Object.defineProperty(Fi, "__esModule", { value: !0 });
  const i = nA(), A = {
    keyword: ["maxContains", "minContains"],
    type: "array",
    schemaType: "number",
    code({ keyword: e, parentSchema: t, it: o }) {
      t.contains === void 0 && (0, i.checkStrictMode)(o, `"${e}" without "contains" is ignored`);
    }
  };
  return Fi.default = A, Fi;
}
var os;
function Iy() {
  if (os) return Mi;
  os = 1, Object.defineProperty(Mi, "__esModule", { value: !0 });
  const i = ny(), A = sy(), e = ay(), t = [i.default, A.default, e.default];
  return Mi.default = t, Mi;
}
var Ri = {}, bi = {}, gs;
function Cy() {
  if (gs) return bi;
  gs = 1, Object.defineProperty(bi, "__esModule", { value: !0 });
  const i = tA(), A = nA(), e = LA(), o = {
    keyword: "unevaluatedProperties",
    type: "object",
    schemaType: ["boolean", "object"],
    trackErrors: !0,
    error: {
      message: "must NOT have unevaluated properties",
      params: ({ params: g }) => (0, i._)`{unevaluatedProperty: ${g.unevaluatedProperty}}`
    },
    code(g) {
      const { gen: r, schema: n, data: s, errsCount: a, it: I } = g;
      if (!a)
        throw new Error("ajv implementation error");
      const { allErrors: C, props: c } = I;
      c instanceof i.Name ? r.if((0, i._)`${c} !== true`, () => r.forIn("key", s, (h) => r.if(d(c, h), () => Q(h)))) : c !== !0 && r.forIn("key", s, (h) => c === void 0 ? Q(h) : r.if(f(c, h), () => Q(h))), I.props = !0, g.ok((0, i._)`${a} === ${e.default.errors}`);
      function Q(h) {
        if (n === !1) {
          g.setParams({ unevaluatedProperty: h }), g.error(), C || r.break();
          return;
        }
        if (!(0, A.alwaysValidSchema)(I, n)) {
          const l = r.name("valid");
          g.subschema({
            keyword: "unevaluatedProperties",
            dataProp: h,
            dataPropType: A.Type.Str
          }, l), C || r.if((0, i.not)(l), () => r.break());
        }
      }
      function d(h, l) {
        return (0, i._)`!${h} || !${h}[${l}]`;
      }
      function f(h, l) {
        const B = [];
        for (const u in h)
          h[u] === !0 && B.push((0, i._)`${l} !== ${u}`);
        return (0, i.and)(...B);
      }
    }
  };
  return bi.default = o, bi;
}
var Ki = {}, rs;
function cy() {
  if (rs) return Ki;
  rs = 1, Object.defineProperty(Ki, "__esModule", { value: !0 });
  const i = tA(), A = nA(), t = {
    keyword: "unevaluatedItems",
    type: "array",
    schemaType: ["boolean", "object"],
    error: {
      message: ({ params: { len: o } }) => (0, i.str)`must NOT have more than ${o} items`,
      params: ({ params: { len: o } }) => (0, i._)`{limit: ${o}}`
    },
    code(o) {
      const { gen: g, schema: r, data: n, it: s } = o, a = s.items || 0;
      if (a === !0)
        return;
      const I = g.const("len", (0, i._)`${n}.length`);
      if (r === !1)
        o.setParams({ len: a }), o.fail((0, i._)`${I} > ${a}`);
      else if (typeof r == "object" && !(0, A.alwaysValidSchema)(s, r)) {
        const c = g.var("valid", (0, i._)`${I} <= ${a}`);
        g.if((0, i.not)(c), () => C(c, a)), o.ok(c);
      }
      s.items = !0;
      function C(c, Q) {
        g.forRange("i", Q, I, (d) => {
          o.subschema({ keyword: "unevaluatedItems", dataProp: d, dataPropType: A.Type.Num }, c), s.allErrors || g.if((0, i.not)(c), () => g.break());
        });
      }
    }
  };
  return Ki.default = t, Ki;
}
var ns;
function By() {
  if (ns) return Ri;
  ns = 1, Object.defineProperty(Ri, "__esModule", { value: !0 });
  const i = Cy(), A = cy(), e = [i.default, A.default];
  return Ri.default = e, Ri;
}
var Yi = {}, vi = {}, ss;
function Qy() {
  if (ss) return vi;
  ss = 1, Object.defineProperty(vi, "__esModule", { value: !0 });
  const i = tA(), e = {
    keyword: "format",
    type: ["number", "string"],
    schemaType: "string",
    $data: !0,
    error: {
      message: ({ schemaCode: t }) => (0, i.str)`must match format "${t}"`,
      params: ({ schemaCode: t }) => (0, i._)`{format: ${t}}`
    },
    code(t, o) {
      const { gen: g, data: r, $data: n, schema: s, schemaCode: a, it: I } = t, { opts: C, errSchemaPath: c, schemaEnv: Q, self: d } = I;
      if (!C.validateFormats)
        return;
      n ? f() : h();
      function f() {
        const l = g.scopeValue("formats", {
          ref: d.formats,
          code: C.code.formats
        }), B = g.const("fDef", (0, i._)`${l}[${a}]`), u = g.let("fType"), y = g.let("format");
        g.if((0, i._)`typeof ${B} == "object" && !(${B} instanceof RegExp)`, () => g.assign(u, (0, i._)`${B}.type || "string"`).assign(y, (0, i._)`${B}.validate`), () => g.assign(u, (0, i._)`"string"`).assign(y, B)), t.fail$data((0, i.or)(E(), w()));
        function E() {
          return C.strictSchema === !1 ? i.nil : (0, i._)`${a} && !${y}`;
        }
        function w() {
          const p = Q.$async ? (0, i._)`(${B}.async ? await ${y}(${r}) : ${y}(${r}))` : (0, i._)`${y}(${r})`, N = (0, i._)`(typeof ${y} == "function" ? ${p} : ${y}.test(${r}))`;
          return (0, i._)`${y} && ${y} !== true && ${u} === ${o} && !${N}`;
        }
      }
      function h() {
        const l = d.formats[s];
        if (!l) {
          E();
          return;
        }
        if (l === !0)
          return;
        const [B, u, y] = w(l);
        B === o && t.pass(p());
        function E() {
          if (C.strictSchema === !1) {
            d.logger.warn(N());
            return;
          }
          throw new Error(N());
          function N() {
            return `unknown format "${s}" ignored in schema at path "${c}"`;
          }
        }
        function w(N) {
          const v = N instanceof RegExp ? (0, i.regexpCode)(N) : C.code.formats ? (0, i._)`${C.code.formats}${(0, i.getProperty)(s)}` : void 0, U = g.scopeValue("formats", { key: s, ref: N, code: v });
          return typeof N == "object" && !(N instanceof RegExp) ? [N.type || "string", N.validate, (0, i._)`${U}.validate`] : ["string", N, U];
        }
        function p() {
          if (typeof l == "object" && !(l instanceof RegExp) && l.async) {
            if (!Q.$async)
              throw new Error("async format in sync schema");
            return (0, i._)`await ${y}(${r})`;
          }
          return typeof u == "function" ? (0, i._)`${y}(${r})` : (0, i._)`${y}.test(${r})`;
        }
      }
    }
  };
  return vi.default = e, vi;
}
var as;
function oI() {
  if (as) return Yi;
  as = 1, Object.defineProperty(Yi, "__esModule", { value: !0 });
  const A = [Qy().default];
  return Yi.default = A, Yi;
}
var Qe = {}, Is;
function gI() {
  return Is || (Is = 1, Object.defineProperty(Qe, "__esModule", { value: !0 }), Qe.contentVocabulary = Qe.metadataVocabulary = void 0, Qe.metadataVocabulary = [
    "title",
    "description",
    "default",
    "deprecated",
    "readOnly",
    "writeOnly",
    "examples"
  ], Qe.contentVocabulary = [
    "contentMediaType",
    "contentEncoding",
    "contentSchema"
  ]), Qe;
}
var Cs;
function Ey() {
  if (Cs) return zt;
  Cs = 1, Object.defineProperty(zt, "__esModule", { value: !0 });
  const i = $a(), A = Za(), e = eI(), t = ry(), o = Iy(), g = By(), r = oI(), n = gI(), s = [
    t.default,
    i.default,
    A.default,
    (0, e.default)(!0),
    r.default,
    n.metadataVocabulary,
    n.contentVocabulary,
    o.default,
    g.default
  ];
  return zt.default = s, zt;
}
var Ui = {}, st = {}, cs;
function ly() {
  if (cs) return st;
  cs = 1, Object.defineProperty(st, "__esModule", { value: !0 }), st.DiscrError = void 0;
  var i;
  return (function(A) {
    A.Tag = "tag", A.Mapping = "mapping";
  })(i || (st.DiscrError = i = {})), st;
}
var Bs;
function rI() {
  if (Bs) return Ui;
  Bs = 1, Object.defineProperty(Ui, "__esModule", { value: !0 });
  const i = tA(), A = ly(), e = Qo(), t = Ut(), o = nA(), r = {
    keyword: "discriminator",
    type: "object",
    schemaType: "object",
    error: {
      message: ({ params: { discrError: n, tagName: s } }) => n === A.DiscrError.Tag ? `tag "${s}" must be string` : `value of tag "${s}" must be in oneOf`,
      params: ({ params: { discrError: n, tag: s, tagName: a } }) => (0, i._)`{error: ${n}, tag: ${a}, tagValue: ${s}}`
    },
    code(n) {
      const { gen: s, data: a, schema: I, parentSchema: C, it: c } = n, { oneOf: Q } = C;
      if (!c.opts.discriminator)
        throw new Error("discriminator: requires discriminator option");
      const d = I.propertyName;
      if (typeof d != "string")
        throw new Error("discriminator: requires propertyName");
      if (I.mapping)
        throw new Error("discriminator: mapping is not supported");
      if (!Q)
        throw new Error("discriminator: requires oneOf keyword");
      const f = s.let("valid", !1), h = s.const("tag", (0, i._)`${a}${(0, i.getProperty)(d)}`);
      s.if((0, i._)`typeof ${h} == "string"`, () => l(), () => n.error(!1, { discrError: A.DiscrError.Tag, tag: h, tagName: d })), n.ok(f);
      function l() {
        const y = u();
        s.if(!1);
        for (const E in y)
          s.elseIf((0, i._)`${h} === ${E}`), s.assign(f, B(y[E]));
        s.else(), n.error(!1, { discrError: A.DiscrError.Mapping, tag: h, tagName: d }), s.endIf();
      }
      function B(y) {
        const E = s.name("valid"), w = n.subschema({ keyword: "oneOf", schemaProp: y }, E);
        return n.mergeEvaluated(w, i.Name), E;
      }
      function u() {
        var y;
        const E = {}, w = N(C);
        let p = !0;
        for (let L = 0; L < Q.length; L++) {
          let P = Q[L];
          if (P?.$ref && !(0, o.schemaHasRulesButRef)(P, c.self.RULES)) {
            const W = P.$ref;
            if (P = e.resolveRef.call(c.self, c.schemaEnv.root, c.baseId, W), P instanceof e.SchemaEnv && (P = P.schema), P === void 0)
              throw new t.default(c.opts.uriResolver, c.baseId, W);
          }
          const V = (y = P?.properties) === null || y === void 0 ? void 0 : y[d];
          if (typeof V != "object")
            throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${d}"`);
          p = p && (w || N(P)), v(V, L);
        }
        if (!p)
          throw new Error(`discriminator: "${d}" must be required`);
        return E;
        function N({ required: L }) {
          return Array.isArray(L) && L.includes(d);
        }
        function v(L, P) {
          if (L.const)
            U(L.const, P);
          else if (L.enum)
            for (const V of L.enum)
              U(V, P);
          else
            throw new Error(`discriminator: "properties/${d}" must have "const" or "enum"`);
        }
        function U(L, P) {
          if (typeof L != "string" || L in E)
            throw new Error(`discriminator: "${d}" values must be unique strings`);
          E[L] = P;
        }
      }
    }
  };
  return Ui.default = r, Ui;
}
var Ji = {};
const dy = "https://json-schema.org/draft/2020-12/schema", hy = "https://json-schema.org/draft/2020-12/schema", uy = { "https://json-schema.org/draft/2020-12/vocab/core": !0, "https://json-schema.org/draft/2020-12/vocab/applicator": !0, "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0, "https://json-schema.org/draft/2020-12/vocab/validation": !0, "https://json-schema.org/draft/2020-12/vocab/meta-data": !0, "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0, "https://json-schema.org/draft/2020-12/vocab/content": !0 }, fy = "meta", wy = "Core and Validation specifications meta-schema", yy = [{ $ref: "meta/core" }, { $ref: "meta/applicator" }, { $ref: "meta/unevaluated" }, { $ref: "meta/validation" }, { $ref: "meta/meta-data" }, { $ref: "meta/format-annotation" }, { $ref: "meta/content" }], py = ["object", "boolean"], Dy = "This meta-schema also defines keywords that have appeared in previous drafts in order to prevent incompatible extensions as they remain in common use.", my = { definitions: { $comment: '"definitions" has been replaced by "$defs".', type: "object", additionalProperties: { $dynamicRef: "#meta" }, deprecated: !0, default: {} }, dependencies: { $comment: '"dependencies" has been split and replaced by "dependentSchemas" and "dependentRequired" in order to serve their differing semantics.', type: "object", additionalProperties: { anyOf: [{ $dynamicRef: "#meta" }, { $ref: "meta/validation#/$defs/stringArray" }] }, deprecated: !0, default: {} }, $recursiveAnchor: { $comment: '"$recursiveAnchor" has been replaced by "$dynamicAnchor".', $ref: "meta/core#/$defs/anchorString", deprecated: !0 }, $recursiveRef: { $comment: '"$recursiveRef" has been replaced by "$dynamicRef".', $ref: "meta/core#/$defs/uriReferenceString", deprecated: !0 } }, Sy = {
  $schema: dy,
  $id: hy,
  $vocabulary: uy,
  $dynamicAnchor: fy,
  title: wy,
  allOf: yy,
  type: py,
  $comment: Dy,
  properties: my
}, Ny = "https://json-schema.org/draft/2020-12/schema", My = "https://json-schema.org/draft/2020-12/meta/applicator", Gy = { "https://json-schema.org/draft/2020-12/vocab/applicator": !0 }, ky = "meta", Fy = "Applicator vocabulary meta-schema", Ry = ["object", "boolean"], by = { prefixItems: { $ref: "#/$defs/schemaArray" }, items: { $dynamicRef: "#meta" }, contains: { $dynamicRef: "#meta" }, additionalProperties: { $dynamicRef: "#meta" }, properties: { type: "object", additionalProperties: { $dynamicRef: "#meta" }, default: {} }, patternProperties: { type: "object", additionalProperties: { $dynamicRef: "#meta" }, propertyNames: { format: "regex" }, default: {} }, dependentSchemas: { type: "object", additionalProperties: { $dynamicRef: "#meta" }, default: {} }, propertyNames: { $dynamicRef: "#meta" }, if: { $dynamicRef: "#meta" }, then: { $dynamicRef: "#meta" }, else: { $dynamicRef: "#meta" }, allOf: { $ref: "#/$defs/schemaArray" }, anyOf: { $ref: "#/$defs/schemaArray" }, oneOf: { $ref: "#/$defs/schemaArray" }, not: { $dynamicRef: "#meta" } }, Ky = { schemaArray: { type: "array", minItems: 1, items: { $dynamicRef: "#meta" } } }, Yy = {
  $schema: Ny,
  $id: My,
  $vocabulary: Gy,
  $dynamicAnchor: ky,
  title: Fy,
  type: Ry,
  properties: by,
  $defs: Ky
}, vy = "https://json-schema.org/draft/2020-12/schema", Uy = "https://json-schema.org/draft/2020-12/meta/unevaluated", Jy = { "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0 }, Hy = "meta", qy = "Unevaluated applicator vocabulary meta-schema", Ly = ["object", "boolean"], xy = { unevaluatedItems: { $dynamicRef: "#meta" }, unevaluatedProperties: { $dynamicRef: "#meta" } }, Ty = {
  $schema: vy,
  $id: Uy,
  $vocabulary: Jy,
  $dynamicAnchor: Hy,
  title: qy,
  type: Ly,
  properties: xy
}, Oy = "https://json-schema.org/draft/2020-12/schema", Py = "https://json-schema.org/draft/2020-12/meta/content", jy = { "https://json-schema.org/draft/2020-12/vocab/content": !0 }, Vy = "meta", Wy = "Content vocabulary meta-schema", zy = ["object", "boolean"], $y = { contentEncoding: { type: "string" }, contentMediaType: { type: "string" }, contentSchema: { $dynamicRef: "#meta" } }, Zy = {
  $schema: Oy,
  $id: Py,
  $vocabulary: jy,
  $dynamicAnchor: Vy,
  title: Wy,
  type: zy,
  properties: $y
}, _y = "https://json-schema.org/draft/2020-12/schema", Xy = "https://json-schema.org/draft/2020-12/meta/core", Ap = { "https://json-schema.org/draft/2020-12/vocab/core": !0 }, ep = "meta", tp = "Core vocabulary meta-schema", ip = ["object", "boolean"], op = { $id: { $ref: "#/$defs/uriReferenceString", $comment: "Non-empty fragments not allowed.", pattern: "^[^#]*#?$" }, $schema: { $ref: "#/$defs/uriString" }, $ref: { $ref: "#/$defs/uriReferenceString" }, $anchor: { $ref: "#/$defs/anchorString" }, $dynamicRef: { $ref: "#/$defs/uriReferenceString" }, $dynamicAnchor: { $ref: "#/$defs/anchorString" }, $vocabulary: { type: "object", propertyNames: { $ref: "#/$defs/uriString" }, additionalProperties: { type: "boolean" } }, $comment: { type: "string" }, $defs: { type: "object", additionalProperties: { $dynamicRef: "#meta" } } }, gp = { anchorString: { type: "string", pattern: "^[A-Za-z_][-A-Za-z0-9._]*$" }, uriString: { type: "string", format: "uri" }, uriReferenceString: { type: "string", format: "uri-reference" } }, rp = {
  $schema: _y,
  $id: Xy,
  $vocabulary: Ap,
  $dynamicAnchor: ep,
  title: tp,
  type: ip,
  properties: op,
  $defs: gp
}, np = "https://json-schema.org/draft/2020-12/schema", sp = "https://json-schema.org/draft/2020-12/meta/format-annotation", ap = { "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0 }, Ip = "meta", Cp = "Format vocabulary meta-schema for annotation results", cp = ["object", "boolean"], Bp = { format: { type: "string" } }, Qp = {
  $schema: np,
  $id: sp,
  $vocabulary: ap,
  $dynamicAnchor: Ip,
  title: Cp,
  type: cp,
  properties: Bp
}, Ep = "https://json-schema.org/draft/2020-12/schema", lp = "https://json-schema.org/draft/2020-12/meta/meta-data", dp = { "https://json-schema.org/draft/2020-12/vocab/meta-data": !0 }, hp = "meta", up = "Meta-data vocabulary meta-schema", fp = ["object", "boolean"], wp = { title: { type: "string" }, description: { type: "string" }, default: !0, deprecated: { type: "boolean", default: !1 }, readOnly: { type: "boolean", default: !1 }, writeOnly: { type: "boolean", default: !1 }, examples: { type: "array", items: !0 } }, yp = {
  $schema: Ep,
  $id: lp,
  $vocabulary: dp,
  $dynamicAnchor: hp,
  title: up,
  type: fp,
  properties: wp
}, pp = "https://json-schema.org/draft/2020-12/schema", Dp = "https://json-schema.org/draft/2020-12/meta/validation", mp = { "https://json-schema.org/draft/2020-12/vocab/validation": !0 }, Sp = "meta", Np = "Validation vocabulary meta-schema", Mp = ["object", "boolean"], Gp = { type: { anyOf: [{ $ref: "#/$defs/simpleTypes" }, { type: "array", items: { $ref: "#/$defs/simpleTypes" }, minItems: 1, uniqueItems: !0 }] }, const: !0, enum: { type: "array", items: !0 }, multipleOf: { type: "number", exclusiveMinimum: 0 }, maximum: { type: "number" }, exclusiveMaximum: { type: "number" }, minimum: { type: "number" }, exclusiveMinimum: { type: "number" }, maxLength: { $ref: "#/$defs/nonNegativeInteger" }, minLength: { $ref: "#/$defs/nonNegativeIntegerDefault0" }, pattern: { type: "string", format: "regex" }, maxItems: { $ref: "#/$defs/nonNegativeInteger" }, minItems: { $ref: "#/$defs/nonNegativeIntegerDefault0" }, uniqueItems: { type: "boolean", default: !1 }, maxContains: { $ref: "#/$defs/nonNegativeInteger" }, minContains: { $ref: "#/$defs/nonNegativeInteger", default: 1 }, maxProperties: { $ref: "#/$defs/nonNegativeInteger" }, minProperties: { $ref: "#/$defs/nonNegativeIntegerDefault0" }, required: { $ref: "#/$defs/stringArray" }, dependentRequired: { type: "object", additionalProperties: { $ref: "#/$defs/stringArray" } } }, kp = { nonNegativeInteger: { type: "integer", minimum: 0 }, nonNegativeIntegerDefault0: { $ref: "#/$defs/nonNegativeInteger", default: 0 }, simpleTypes: { enum: ["array", "boolean", "integer", "null", "number", "object", "string"] }, stringArray: { type: "array", items: { type: "string" }, uniqueItems: !0, default: [] } }, Fp = {
  $schema: pp,
  $id: Dp,
  $vocabulary: mp,
  $dynamicAnchor: Sp,
  title: Np,
  type: Mp,
  properties: Gp,
  $defs: kp
};
var Qs;
function Rp() {
  if (Qs) return Ji;
  Qs = 1, Object.defineProperty(Ji, "__esModule", { value: !0 });
  const i = Sy, A = Yy, e = Ty, t = Zy, o = rp, g = Qp, r = yp, n = Fp, s = ["/properties"];
  function a(I) {
    return [
      i,
      A,
      e,
      t,
      o,
      C(this, g),
      r,
      C(this, n)
    ].forEach((c) => this.addMetaSchema(c, void 0, !1)), this;
    function C(c, Q) {
      return I ? c.$dataMetaSchema(Q, s) : Q;
    }
  }
  return Ji.default = a, Ji;
}
var Es;
function bp() {
  return Es || (Es = 1, (function(i, A) {
    Object.defineProperty(A, "__esModule", { value: !0 }), A.MissingRefError = A.ValidationError = A.CodeGen = A.Name = A.nil = A.stringify = A.str = A._ = A.KeywordCxt = A.Ajv2020 = void 0;
    const e = za(), t = Ey(), o = rI(), g = Rp(), r = "https://json-schema.org/draft/2020-12/schema";
    class n extends e.default {
      constructor(Q = {}) {
        super({
          ...Q,
          dynamicRef: !0,
          next: !0,
          unevaluated: !0
        });
      }
      _addVocabularies() {
        super._addVocabularies(), t.default.forEach((Q) => this.addVocabulary(Q)), this.opts.discriminator && this.addKeyword(o.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        const { $data: Q, meta: d } = this.opts;
        d && (g.default.call(this, Q), this.refs["http://json-schema.org/schema"] = r);
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(r) ? r : void 0);
      }
    }
    A.Ajv2020 = n, i.exports = A = n, i.exports.Ajv2020 = n, Object.defineProperty(A, "__esModule", { value: !0 }), A.default = n;
    var s = vt();
    Object.defineProperty(A, "KeywordCxt", { enumerable: !0, get: function() {
      return s.KeywordCxt;
    } });
    var a = tA();
    Object.defineProperty(A, "_", { enumerable: !0, get: function() {
      return a._;
    } }), Object.defineProperty(A, "str", { enumerable: !0, get: function() {
      return a.str;
    } }), Object.defineProperty(A, "stringify", { enumerable: !0, get: function() {
      return a.stringify;
    } }), Object.defineProperty(A, "nil", { enumerable: !0, get: function() {
      return a.nil;
    } }), Object.defineProperty(A, "Name", { enumerable: !0, get: function() {
      return a.Name;
    } }), Object.defineProperty(A, "CodeGen", { enumerable: !0, get: function() {
      return a.CodeGen;
    } });
    var I = Bo();
    Object.defineProperty(A, "ValidationError", { enumerable: !0, get: function() {
      return I.default;
    } });
    var C = Ut();
    Object.defineProperty(A, "MissingRefError", { enumerable: !0, get: function() {
      return C.default;
    } });
  })(Ot, Ot.exports)), Ot.exports;
}
var nI = bp();
const Kp = /* @__PURE__ */ Oa(nI), Yp = /* @__PURE__ */ aI({
  __proto__: null,
  default: Kp
}, [nI]);
var Hi = { exports: {} }, qi = {}, ls;
function vp() {
  if (ls) return qi;
  ls = 1, Object.defineProperty(qi, "__esModule", { value: !0 });
  const i = $a(), A = Za(), e = eI(), t = oI(), o = gI(), g = [
    i.default,
    A.default,
    (0, e.default)(),
    t.default,
    o.metadataVocabulary,
    o.contentVocabulary
  ];
  return qi.default = g, qi;
}
const Up = "http://json-schema.org/draft-07/schema#", Jp = "http://json-schema.org/draft-07/schema#", Hp = "Core schema meta-schema", qp = { schemaArray: { type: "array", minItems: 1, items: { $ref: "#" } }, nonNegativeInteger: { type: "integer", minimum: 0 }, nonNegativeIntegerDefault0: { allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }] }, simpleTypes: { enum: ["array", "boolean", "integer", "null", "number", "object", "string"] }, stringArray: { type: "array", items: { type: "string" }, uniqueItems: !0, default: [] } }, Lp = ["object", "boolean"], xp = { $id: { type: "string", format: "uri-reference" }, $schema: { type: "string", format: "uri" }, $ref: { type: "string", format: "uri-reference" }, $comment: { type: "string" }, title: { type: "string" }, description: { type: "string" }, default: !0, readOnly: { type: "boolean", default: !1 }, examples: { type: "array", items: !0 }, multipleOf: { type: "number", exclusiveMinimum: 0 }, maximum: { type: "number" }, exclusiveMaximum: { type: "number" }, minimum: { type: "number" }, exclusiveMinimum: { type: "number" }, maxLength: { $ref: "#/definitions/nonNegativeInteger" }, minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, pattern: { type: "string", format: "regex" }, additionalItems: { $ref: "#" }, items: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }], default: !0 }, maxItems: { $ref: "#/definitions/nonNegativeInteger" }, minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, uniqueItems: { type: "boolean", default: !1 }, contains: { $ref: "#" }, maxProperties: { $ref: "#/definitions/nonNegativeInteger" }, minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, required: { $ref: "#/definitions/stringArray" }, additionalProperties: { $ref: "#" }, definitions: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, properties: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, patternProperties: { type: "object", additionalProperties: { $ref: "#" }, propertyNames: { format: "regex" }, default: {} }, dependencies: { type: "object", additionalProperties: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }] } }, propertyNames: { $ref: "#" }, const: !0, enum: { type: "array", items: !0, minItems: 1, uniqueItems: !0 }, type: { anyOf: [{ $ref: "#/definitions/simpleTypes" }, { type: "array", items: { $ref: "#/definitions/simpleTypes" }, minItems: 1, uniqueItems: !0 }] }, format: { type: "string" }, contentMediaType: { type: "string" }, contentEncoding: { type: "string" }, if: { $ref: "#" }, then: { $ref: "#" }, else: { $ref: "#" }, allOf: { $ref: "#/definitions/schemaArray" }, anyOf: { $ref: "#/definitions/schemaArray" }, oneOf: { $ref: "#/definitions/schemaArray" }, not: { $ref: "#" } }, Tp = {
  $schema: Up,
  $id: Jp,
  title: Hp,
  definitions: qp,
  type: Lp,
  properties: xp,
  default: !0
};
var ds;
function Op() {
  return ds || (ds = 1, (function(i, A) {
    Object.defineProperty(A, "__esModule", { value: !0 }), A.MissingRefError = A.ValidationError = A.CodeGen = A.Name = A.nil = A.stringify = A.str = A._ = A.KeywordCxt = A.Ajv = void 0;
    const e = za(), t = vp(), o = rI(), g = Tp, r = ["/properties"], n = "http://json-schema.org/draft-07/schema";
    class s extends e.default {
      _addVocabularies() {
        super._addVocabularies(), t.default.forEach((d) => this.addVocabulary(d)), this.opts.discriminator && this.addKeyword(o.default);
      }
      _addDefaultMetaSchema() {
        if (super._addDefaultMetaSchema(), !this.opts.meta)
          return;
        const d = this.opts.$data ? this.$dataMetaSchema(g, r) : g;
        this.addMetaSchema(d, n, !1), this.refs["http://json-schema.org/schema"] = n;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(n) ? n : void 0);
      }
    }
    A.Ajv = s, i.exports = A = s, i.exports.Ajv = s, Object.defineProperty(A, "__esModule", { value: !0 }), A.default = s;
    var a = vt();
    Object.defineProperty(A, "KeywordCxt", { enumerable: !0, get: function() {
      return a.KeywordCxt;
    } });
    var I = tA();
    Object.defineProperty(A, "_", { enumerable: !0, get: function() {
      return I._;
    } }), Object.defineProperty(A, "str", { enumerable: !0, get: function() {
      return I.str;
    } }), Object.defineProperty(A, "stringify", { enumerable: !0, get: function() {
      return I.stringify;
    } }), Object.defineProperty(A, "nil", { enumerable: !0, get: function() {
      return I.nil;
    } }), Object.defineProperty(A, "Name", { enumerable: !0, get: function() {
      return I.Name;
    } }), Object.defineProperty(A, "CodeGen", { enumerable: !0, get: function() {
      return I.CodeGen;
    } });
    var C = Bo();
    Object.defineProperty(A, "ValidationError", { enumerable: !0, get: function() {
      return C.default;
    } });
    var c = Ut();
    Object.defineProperty(A, "MissingRefError", { enumerable: !0, get: function() {
      return c.default;
    } });
  })(Hi, Hi.exports)), Hi.exports;
}
var Pp = Op();
const jp = /* @__PURE__ */ Oa(Pp), Vp = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: jp
}, Symbol.toStringTag, { value: "Module" })), Wp = {}, hs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Wp
}, Symbol.toStringTag, { value: "Module" })), zp = {
  $schema: "@schema/vibe",
  $id: "@vibe/todos",
  name: "Todos",
  description: "Complete todo list with state machines and AI tools",
  actor: "@todos/actor/agent"
}, $p = {
  $schema: "@schema/style",
  $id: "@todos/style/brand",
  tokens: {
    colors: {
      marineBlue: "#001F33",
      marineBlueMuted: "#2D4A5C",
      marineBlueLight: "#5E7A8C",
      paradiseWater: "#00BDD6",
      lushGreen: "#4E9A58",
      terracotta: "#C27B66",
      sunYellow: "#E6B94D",
      softClay: "#E8E1D9",
      tintedWhite: "#F0EDE6",
      background: "transparent",
      foreground: "#001F33",
      primary: "#00BDD6",
      secondary: "#2D4A5C",
      border: "rgba(255, 255, 255, 0.1)",
      surface: "rgba(255, 255, 255, 0.3)",
      glass: "rgba(255, 255, 255, 0.0005)",
      glassStrong: "rgba(255, 255, 255, 0.15)",
      text: {
        marine: "#D1E8F7",
        water: "#004D59",
        green: "#F0F9F1",
        terracotta: "#FDF2EF",
        yellow: "#4D3810"
      }
    },
    spacing: {
      xs: "0.5rem",
      sm: "0.75rem",
      md: "1rem",
      lg: "1.5rem",
      xl: "2rem",
      "2xl": "3rem"
    },
    typography: {
      fontFamily: {
        heading: "'Indie Flower', cursive",
        body: "'Plus Jakarta Sans', sans-serif"
      },
      fontWeight: {
        light: "300",
        normal: "400",
        medium: "500",
        semibold: "600",
        bold: "700"
      }
    },
    radii: {
      sm: "4px",
      md: "12px",
      apple: "18px",
      full: "9999px"
    },
    shadows: {
      sm: "0 4px 30px rgba(0, 0, 0, 0.05)",
      md: "0 10px 30px rgba(0, 0, 0, 0.05)",
      lg: "0 10px 40px rgba(0, 0, 0, 0.1)"
    },
    transitions: {
      fast: "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)",
      standard: "all 0.5s cubic-bezier(0.2, 0, 0.2, 1)"
    }
  },
  components: {
    stack: {
      display: "flex",
      flexDirection: "column",
      gap: "0.25rem",
      width: "100%",
      maxWidth: "100%",
      height: "100vh",
      background: "{colors.softClay}",
      padding: "0.375rem",
      overflowY: "auto",
      overflowX: "hidden",
      fontFamily: "{typography.fontFamily.body}",
      color: "{colors.marineBlue}",
      boxSizing: "border-box"
    },
    headerSection: {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      gap: "0.25rem",
      marginBottom: "0.25rem",
      width: "100%"
    },
    todoCategory: {
      fontFamily: "{typography.fontFamily.heading}",
      fontSize: "0.6rem",
      fontStyle: "italic",
      color: "{colors.paradiseWater}",
      marginBottom: "0.25rem",
      display: "block",
      textAlign: "center",
      width: "100%",
      textShadow: "0 0 10px rgba(0, 189, 214, 0.2)"
    },
    todoTitle: {
      fontFamily: "{typography.fontFamily.heading}",
      fontSize: "0.9rem",
      fontWeight: "{typography.fontWeight.bold}",
      color: "{colors.marineBlue}",
      margin: "0",
      marginBottom: "0.375rem",
      textAlign: "center",
      width: "100%",
      letterSpacing: "-0.02em"
    },
    viewSwitcher: {
      display: "flex",
      gap: "0.2rem",
      background: "rgba(255, 255, 255, 0.2)",
      padding: "0.15rem",
      borderRadius: "{radii.full}",
      margin: "0 auto",
      border: "1px solid {colors.border}"
    },
    buttonViewSwitch: {
      padding: "0.25rem 0.6rem",
      background: "transparent",
      border: "none",
      borderRadius: "{radii.full}",
      fontSize: "0.55rem",
      fontWeight: "600",
      textTransform: "uppercase",
      letterSpacing: "0.05em",
      color: "{colors.marineBlueMuted}",
      cursor: "pointer",
      transition: "{transitions.fast}",
      data: {
        active: {
          true: {
            background: "{colors.marineBlue}",
            color: "{colors.softClay}",
            boxShadow: "0 4px 12px rgba(0, 31, 51, 0.2)"
          }
        }
      }
    },
    form: {
      display: "flex",
      flexDirection: "row",
      alignItems: "center",
      gap: "0.25rem",
      padding: "0.25rem 0.375rem",
      background: "rgba(255, 255, 255, 0.4)",
      backdropFilter: "blur(8px) saturate(150%)",
      borderRadius: "{radii.full}",
      border: "1px solid {colors.border}",
      boxShadow: "{shadows.md}",
      width: "100%",
      boxSizing: "border-box",
      marginBottom: "0.25rem"
    },
    input: {
      flex: "1",
      width: "100%",
      padding: "0.25rem 0.5rem",
      border: "none",
      background: "transparent",
      fontSize: "0.6rem",
      color: "{colors.marineBlue}",
      fontFamily: "{typography.fontFamily.body}",
      fontWeight: "{typography.fontWeight.light}",
      outline: "none",
      minHeight: "0",
      minWidth: "0",
      lineHeight: "1.35"
    },
    button: {
      width: "auto",
      padding: "0.25rem 0.5rem",
      background: "{colors.lushGreen}",
      color: "{colors.text.green}",
      border: "none",
      borderRadius: "{radii.full}",
      cursor: "pointer",
      fontSize: "0.5rem",
      fontWeight: "600",
      textTransform: "uppercase",
      letterSpacing: "0.05em",
      transition: "{transitions.fast}",
      boxShadow: "0 4px 12px rgba(78, 154, 88, 0.2)",
      whiteSpace: "nowrap",
      flexShrink: "0",
      ":hover": {
        filter: "brightness(1.1)",
        transform: "translateY(-1px)",
        boxShadow: "0 6px 16px rgba(78, 154, 88, 0.3)"
      }
    }
  },
  selectors: {
    ":host": {
      display: "block",
      height: "100%",
      background: "transparent"
    },
    "@container {containerName} (min-width: {containers.xs})": {
      ".stack": {
        padding: "0.625rem",
        gap: "0.375rem"
      },
      ".headerSection": {
        gap: "0.375rem",
        marginBottom: "0.375rem"
      },
      ".todoCategory": {
        fontSize: "0.8rem"
      },
      ".todoTitle": {
        fontSize: "1.15rem"
      },
      ".viewSwitcher": {
        gap: "0.375rem",
        padding: "0.25rem",
        minWidth: "fit-content"
      },
      ".buttonViewSwitch": {
        padding: "0.4rem 0.8rem",
        fontSize: "0.7rem"
      },
      ".form": {
        gap: "0.375rem",
        padding: "0.375rem 0.5rem"
      },
      ".input": {
        padding: "0.375rem 0.625rem",
        fontSize: "0.7rem"
      },
      ".button": {
        padding: "0.375rem 0.625rem",
        fontSize: "0.6rem"
      }
    },
    "@container {containerName} (min-width: {containers.sm})": {
      ".stack": {
        padding: "0.75rem",
        gap: "0.5rem"
      },
      ".headerSection": {
        gap: "0.5rem",
        marginBottom: "0.5rem"
      },
      ".todoCategory": {
        fontSize: "0.95rem"
      },
      ".todoTitle": {
        fontSize: "1.3rem"
      },
      ".viewSwitcher": {
        gap: "0.5rem",
        padding: "0.3rem",
        minWidth: "fit-content"
      },
      ".buttonViewSwitch": {
        padding: "0.4rem 0.8rem",
        fontSize: "0.7rem"
      },
      ".form": {
        gap: "0.5rem",
        padding: "0.5rem 0.625rem"
      },
      ".input": {
        padding: "0.5rem 0.75rem",
        fontSize: "0.75rem"
      },
      ".button": {
        padding: "0.5rem 0.75rem",
        fontSize: "0.65rem"
      }
    },
    "@container {containerName} (min-width: {containers.md})": {
      ".stack": {
        padding: "1rem",
        gap: "0.625rem"
      },
      ".headerSection": {
        gap: "0.625rem",
        marginBottom: "0.625rem"
      },
      ".todoCategory": {
        fontSize: "1.1rem"
      },
      ".todoTitle": {
        fontSize: "1.45rem"
      },
      ".viewSwitcher": {
        gap: "0.625rem",
        padding: "0.375rem",
        minWidth: "fit-content"
      },
      ".buttonViewSwitch": {
        padding: "0.6rem 1rem",
        fontSize: "0.85rem"
      },
      ".form": {
        gap: "0.625rem",
        padding: "0.625rem 0.75rem"
      },
      ".input": {
        padding: "0.625rem 0.875rem",
        fontSize: "0.8rem"
      },
      ".button": {
        padding: "0.625rem 0.875rem",
        fontSize: "0.7rem"
      }
    },
    "@container {containerName} (min-width: {containers.lg})": {
      ".stack": {
        padding: "1.25rem",
        gap: "0.75rem"
      },
      ".headerSection": {
        gap: "0.75rem",
        marginBottom: "0.75rem"
      },
      ".todoCategory": {
        fontSize: "1.2rem"
      },
      ".todoTitle": {
        fontSize: "1.55rem"
      },
      ".viewSwitcher": {
        gap: "0.75rem",
        padding: "0.45rem",
        minWidth: "fit-content"
      },
      ".buttonViewSwitch": {
        padding: "0.7rem 1.1rem",
        fontSize: "0.9rem"
      },
      ".form": {
        gap: "0.75rem",
        padding: "0.75rem 0.875rem"
      },
      ".input": {
        padding: "0.75rem 1rem",
        fontSize: "0.85rem"
      },
      ".button": {
        padding: "0.75rem 1rem",
        fontSize: "0.75rem"
      }
    },
    "@container {containerName} (min-width: {containers.xl})": {
      ".stack": {
        padding: "1.5rem",
        gap: "0.875rem"
      },
      ".headerSection": {
        gap: "0.875rem",
        marginBottom: "0.875rem"
      },
      ".todoCategory": {
        fontSize: "1.3rem"
      },
      ".todoTitle": {
        fontSize: "1.65rem"
      },
      ".viewSwitcher": {
        gap: "0.875rem",
        padding: "0.5rem",
        minWidth: "fit-content"
      },
      ".buttonViewSwitch": {
        padding: "0.8rem 1.2rem",
        fontSize: "1rem"
      },
      ".form": {
        gap: "0.875rem",
        padding: "0.875rem 1rem"
      },
      ".input": {
        padding: "0.875rem 1.125rem",
        fontSize: "0.9rem"
      },
      ".button": {
        padding: "0.875rem 1.125rem",
        fontSize: "0.8rem"
      }
    },
    "@container {containerName} (min-width: {containers.2xl})": {
      ".stack": {
        padding: "1.75rem",
        gap: "1rem"
      },
      ".headerSection": {
        gap: "1rem",
        marginBottom: "1rem"
      },
      ".todoCategory": {
        fontSize: "1.4rem"
      },
      ".todoTitle": {
        fontSize: "1.75rem"
      },
      ".viewSwitcher": {
        gap: "1rem",
        padding: "0.55rem",
        minWidth: "fit-content"
      },
      ".buttonViewSwitch": {
        padding: "0.9rem 1.3rem",
        fontSize: "1.1rem"
      },
      ".form": {
        gap: "1rem",
        padding: "1rem 1.125rem"
      },
      ".input": {
        padding: "1rem 1.25rem",
        fontSize: "0.95rem"
      },
      ".button": {
        padding: "1rem 1.25rem",
        fontSize: "0.85rem"
      }
    }
  }
}, Zp = {
  $schema: "@schema/style",
  $id: "@todos/style/list",
  components: {
    list: {
      display: "flex",
      flexDirection: "column",
      gap: "0.25rem",
      overflowY: "auto",
      width: "100%",
      boxSizing: "border-box",
      padding: "0.375rem"
    },
    card: {
      display: "flex",
      flexDirection: "column",
      alignItems: "flex-start",
      gap: "0.25rem",
      padding: "0.25rem 0.375rem",
      background: "rgba(255, 255, 255, 0.3)",
      backdropFilter: "blur(8px) saturate(150%)",
      borderRadius: "{radii.apple}",
      border: "1px solid {colors.border}",
      transition: "{transitions.fast}",
      marginBottom: "0.25rem",
      ":hover": {
        background: "rgba(255, 255, 255, 0.5)",
        transform: "translateY(-2px)",
        boxShadow: "{shadows.sm}"
      }
    },
    body: {
      flex: "1",
      fontSize: "0.75rem",
      fontWeight: "{typography.fontWeight.light}",
      color: "{colors.marineBlue}",
      lineHeight: "1.3",
      width: "100%"
    },
    buttonSmall: {
      width: "12px",
      height: "12px",
      minWidth: "12px",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      background: "rgba(255, 255, 255, 0.2)",
      color: "{colors.marineBlueMuted}",
      border: "1px solid {colors.border}",
      borderRadius: "{radii.full}",
      cursor: "pointer",
      transition: "{transitions.fast}",
      fontSize: "0.5rem",
      ":hover": {
        background: "{colors.marineBlue}",
        color: "{colors.softClay}",
        borderColor: "{colors.marineBlue}"
      }
    },
    buttonDanger: {
      ":hover": {
        background: "{colors.terracotta}",
        color: "{colors.text.terracotta}",
        borderColor: "{colors.terracotta}"
      }
    }
  },
  selectors: {
    "@container {containerName} (min-width: {containers.xs})": {
      ".list": {
        gap: "0.375rem",
        padding: "0.5rem"
      },
      ".card": {
        padding: "0.375rem 0.5rem",
        gap: "0.375rem"
      },
      ".body": {
        fontSize: "0.8rem"
      },
      ".buttonSmall": {
        width: "14px",
        height: "14px",
        minWidth: "14px",
        fontSize: "0.6rem"
      }
    },
    "@container {containerName} (min-width: {containers.sm})": {
      ".list": {
        gap: "0.5rem",
        padding: "0.625rem"
      },
      ".card": {
        flexDirection: "row",
        alignItems: "center",
        padding: "0.5rem 0.625rem",
        gap: "0.5rem"
      },
      ".body": {
        fontSize: "0.85rem",
        width: "auto"
      },
      ".buttonSmall": {
        width: "16px",
        height: "16px",
        minWidth: "16px",
        fontSize: "0.65rem"
      }
    },
    "@container {containerName} (min-width: {containers.md})": {
      ".list": {
        gap: "0.625rem",
        padding: "0.75rem"
      },
      ".card": {
        padding: "0.625rem 0.75rem",
        gap: "0.625rem"
      },
      ".body": {
        fontSize: "0.9rem"
      },
      ".buttonSmall": {
        width: "18px",
        height: "18px",
        minWidth: "18px",
        fontSize: "0.7rem"
      }
    },
    "@container {containerName} (min-width: {containers.lg})": {
      ".list": {
        gap: "0.75rem",
        padding: "1rem"
      },
      ".card": {
        padding: "0.75rem 0.875rem",
        gap: "0.75rem"
      },
      ".body": {
        fontSize: "0.95rem"
      },
      ".buttonSmall": {
        width: "20px",
        height: "20px",
        minWidth: "20px",
        fontSize: "0.75rem"
      }
    },
    "@container {containerName} (min-width: {containers.xl})": {
      ".list": {
        gap: "0.875rem",
        padding: "1.25rem"
      },
      ".card": {
        padding: "0.875rem 1rem",
        gap: "0.875rem"
      },
      ".body": {
        fontSize: "1rem",
        fontWeight: "{typography.fontWeight.medium}"
      },
      ".buttonSmall": {
        width: "22px",
        height: "22px",
        minWidth: "22px",
        fontSize: "0.8rem"
      },
      ".card:hover": {
        transform: "translateY(-1px)",
        boxShadow: "{shadows.md}"
      }
    },
    "@container {containerName} (min-width: {containers.2xl})": {
      ".list": {
        gap: "1rem",
        padding: "1.5rem"
      },
      ".card": {
        padding: "1rem 1.25rem",
        gap: "1rem"
      },
      ".body": {
        fontSize: "1.05rem",
        fontWeight: "{typography.fontWeight.medium}"
      },
      ".buttonSmall": {
        width: "24px",
        height: "24px",
        minWidth: "24px",
        fontSize: "0.85rem"
      },
      ".card:hover": {
        transform: "translateY(-2px)",
        boxShadow: "{shadows.lg}"
      }
    },
    "[data-done=true] .body": {
      textDecoration: "line-through",
      opacity: "0.7"
    },
    "[data-done=true]": {
      opacity: "0.6",
      background: "rgba(255, 255, 255, 0.1)"
    }
  }
}, _p = {
  $schema: "@schema/style",
  $id: "@todos/style/logs",
  components: {
    logs: {
      padding: "0",
      margin: "0",
      background: "transparent",
      color: "#001F33",
      fontFamily: "'Plus Jakarta Sans', sans-serif",
      fontSize: "0.85rem",
      lineHeight: "1.5"
    },
    logEntryContainer: {
      display: "flex",
      flexDirection: "column",
      width: "100%",
      maxWidth: "100%",
      boxSizing: "border-box",
      overflow: "hidden"
    },
    logEntries: {
      display: "flex",
      flexDirection: "column",
      gap: "0.2rem",
      width: "100%",
      maxWidth: "100%",
      boxSizing: "border-box"
    },
    logEntry: {
      padding: "0.1rem 0.75rem",
      margin: "0",
      background: "rgba(255, 255, 255, 0.4)",
      backdropFilter: "blur(8px) saturate(150%)",
      "-webkit-backdrop-filter": "blur(8px) saturate(150%)",
      border: "1px solid rgba(0, 31, 51, 0.05)",
      borderLeft: "4px solid #00BDD6",
      borderRadius: "8px",
      display: "grid",
      gridTemplateColumns: "auto auto auto 1fr auto",
      gridTemplateRows: "auto auto",
      alignItems: "center",
      minHeight: "1.3rem",
      transition: "all 0.2s cubic-bezier(0.4, 0, 0.2, 1)",
      width: "100%",
      maxWidth: "100%",
      boxSizing: "border-box",
      color: "#001F33",
      position: "relative",
      boxShadow: "0 2px 8px rgba(0, 0, 0, 0.02)",
      overflow: "visible",
      ":hover": {
        background: "rgba(255, 255, 255, 0.6)",
        transform: "translateX(4px)",
        boxShadow: "0 4px 12px rgba(0, 0, 0, 0.04)"
      }
    },
    logType: {
      color: "#001F33",
      fontWeight: "700",
      fontSize: "0.6rem",
      textTransform: "uppercase",
      minWidth: "5rem",
      textAlign: "left",
      letterSpacing: "0.1em",
      opacity: "0.8"
    },
    logSource: {
      color: "#2D4A5C",
      fontSize: "0.65rem",
      fontFamily: "monospace",
      minWidth: "8rem",
      flexShrink: "0",
      fontWeight: "500",
      display: "flex",
      alignItems: "center",
      gap: "0.3rem",
      background: "rgba(0, 31, 51, 0.05)",
      padding: "0.1rem 0.4rem",
      borderRadius: "4px"
    },
    logSourceRole: {
      color: "#001F33",
      fontWeight: "700",
      textTransform: "lowercase",
      opacity: "0.6"
    },
    logSourceId: {
      color: "#5E7A8C",
      fontSize: "0.6rem"
    },
    logTarget: {
      color: "#2D4A5C",
      fontSize: "0.65rem",
      fontFamily: "monospace",
      minWidth: "8rem",
      flexShrink: "0",
      fontWeight: "500",
      display: "flex",
      alignItems: "center",
      gap: "0.3rem",
      background: "rgba(0, 189, 214, 0.05)",
      padding: "0.1rem 0.4rem",
      borderRadius: "4px"
    },
    logTargetRole: {
      color: "#004D59",
      fontWeight: "700",
      textTransform: "lowercase",
      opacity: "0.6"
    },
    logTargetId: {
      color: "#00BDD6",
      fontSize: "0.6rem"
    },
    logPayloadDetails: {
      display: "contents"
    },
    logPayloadToggle: {
      gridColumn: "5",
      gridRow: "1",
      color: "#004D59",
      fontSize: "0.6rem",
      fontWeight: "700",
      cursor: "pointer",
      userSelect: "none",
      padding: "0.15rem 0.5rem",
      borderRadius: "9999px",
      background: "rgba(0, 189, 214, 0.15)",
      border: "1px solid rgba(0, 189, 214, 0.2)",
      transition: "all 0.2s ease",
      textTransform: "uppercase",
      letterSpacing: "0.05em",
      justifySelf: "end",
      ":hover": {
        background: "rgba(0, 189, 214, 0.25)",
        transform: "scale(1.05)"
      }
    },
    logPayload: {
      gridRow: "2",
      gridColumn: "4 / 6",
      margin: "0.3rem 0 0.2rem 0",
      padding: "0.6rem 0.8rem",
      background: "rgba(0, 31, 51, 0.03)",
      borderRadius: "8px",
      border: "1px solid rgba(0, 31, 51, 0.05)",
      color: "#2D4A5C",
      fontSize: "0.65rem",
      fontFamily: "monospace",
      whiteSpace: "pre-wrap",
      wordBreak: "break-all",
      overflow: "auto",
      maxHeight: "400px",
      width: "fit-content",
      minWidth: "180px",
      maxWidth: "100%",
      boxSizing: "border-box",
      boxShadow: "inset 0 2px 4px rgba(0, 0, 0, 0.02)",
      textAlign: "left",
      justifySelf: "end",
      display: "flex",
      alignItems: "center"
    }
  },
  selectors: {
    ".log-entry[data-event-type='SUCCESS']": {
      borderLeftColor: "#4E9A58",
      background: "rgba(78, 154, 88, 0.05)"
    },
    ".log-entry[data-event-type='ERROR']": {
      borderLeftColor: "#C27B66",
      background: "rgba(194, 123, 102, 0.05)"
    },
    ".log-entry[data-event-type='SWITCH_VIEW']": {
      borderLeftColor: "#00BDD6"
    },
    "summary::-webkit-details-marker": {
      display: "none"
    },
    "summary::marker": {
      display: "none"
    },
    "details:not([open]) .log-payload": {
      display: "none"
    }
  }
}, Xp = {
  $schema: "@schema/actor",
  $id: "@todos/actor/agent",
  role: "agent",
  context: "@todos/context/agent",
  view: "@todos/view/agent",
  state: "@todos/state/agent",
  brand: "@todos/style/brand",
  inbox: "@todos/inbox/agent",
  messageTypes: [
    "CREATE_BUTTON",
    "TOGGLE_BUTTON",
    "DELETE_BUTTON",
    "UPDATE_INPUT",
    "SWITCH_VIEW",
    "SUCCESS",
    "ERROR"
  ]
}, AD = {
  $schema: "@schema/actor",
  $id: "@todos/actor/list",
  role: "todo-list",
  context: "@todos/context/list",
  view: "@todos/view/list",
  state: "@todos/state/list",
  brand: "@todos/style/brand",
  style: "@todos/style/list",
  inbox: "@todos/inbox/list",
  messageTypes: [
    "TOGGLE_BUTTON",
    "DELETE_BUTTON",
    "SUCCESS",
    "RETRY",
    "DISMISS"
  ]
}, eD = {
  $schema: "@schema/actor",
  $id: "@todos/actor/logs",
  role: "logs",
  context: "@todos/context/logs",
  view: "@todos/view/logs",
  state: "@todos/state/logs",
  brand: "@todos/style/brand",
  style: "@todos/style/logs",
  inbox: "@todos/inbox/logs",
  messageTypes: [
    "RETRY",
    "DISMISS"
  ]
}, tD = {
  $schema: "@schema/view",
  $id: "@todos/view/agent",
  content: {
    tag: "div",
    class: "stack",
    children: [
      {
        tag: "div",
        class: "header-section",
        children: [
          {
            tag: "h2",
            class: "todo-title",
            text: "Daily Focus"
          },
          {
            tag: "div",
            class: "view-switcher",
            children: [
              {
                tag: "button",
                class: "button-view-switch",
                attrs: {
                  "data-view": "list",
                  data: {
                    active: "$listButtonActive"
                  }
                },
                text: "$listViewLabel",
                $on: {
                  click: {
                    send: "SWITCH_VIEW",
                    payload: { viewMode: "list" }
                  }
                }
              },
              {
                tag: "button",
                class: "button-view-switch",
                attrs: {
                  "data-view": "logs",
                  data: {
                    active: "$logsButtonActive"
                  }
                },
                text: "$logsViewLabel",
                $on: {
                  click: {
                    send: "SWITCH_VIEW",
                    payload: { viewMode: "logs" }
                  }
                }
              }
            ]
          }
        ]
      },
      {
        class: "form",
        children: [
          {
            tag: "input",
            class: "input",
            attrs: {
              type: "text",
              placeholder: "$inputPlaceholder"
            },
            value: "$newTodoText",
            $on: {
              input: {
                send: "UPDATE_INPUT",
                payload: { newTodoText: "@inputValue" }
              },
              blur: {
                send: "UPDATE_INPUT",
                payload: { newTodoText: "@inputValue" }
              },
              keydown: {
                send: "CREATE_BUTTON",
                payload: { text: "@inputValue" },
                key: "Enter"
              }
            }
          },
          {
            tag: "button",
            class: "button",
            text: "$addButtonText",
            $on: {
              click: {
                send: "CREATE_BUTTON",
                payload: { text: "$newTodoText" }
              }
            }
          }
        ]
      },
      {
        tag: "main",
        class: "content-area",
        $slot: "$currentView"
      }
    ]
  }
}, iD = {
  $schema: "@schema/view",
  $id: "@todos/view/list",
  content: {
    class: "list",
    $each: {
      items: "$list",
      template: {
        class: "card",
        attrs: {
          "data-done": "$$done"
        },
        children: [
          {
            tag: "span",
            class: "body",
            text: "$$text"
          },
          {
            tag: "button",
            class: "button-small",
            text: "",
            $on: {
              click: {
                send: "TOGGLE_BUTTON",
                payload: { id: "$$id", done: "$$done" }
              }
            }
          },
          {
            tag: "button",
            class: "button-small button-danger",
            text: "$deleteButtonText",
            $on: {
              click: {
                send: "DELETE_BUTTON",
                payload: { id: "$$id" }
              }
            }
          }
        ]
      }
    }
  }
}, oD = {
  $schema: "@schema/view",
  $id: "@todos/view/logs",
  content: {
    class: "logs",
    attrs: {
      data: "log-viewer"
    },
    children: [
      {
        tag: "div",
        class: "log-entries",
        $each: {
          items: "$messages",
          template: {
            class: "log-entry-container",
            children: [
              {
                tag: "div",
                class: "log-entry",
                attrs: {
                  data: {
                    eventType: "$$type",
                    processed: "$$processed"
                  }
                },
                children: [
                  {
                    tag: "span",
                    class: "log-type",
                    text: "$$type"
                  },
                  {
                    tag: "span",
                    class: "log-source",
                    children: [
                      {
                        tag: "span",
                        class: "log-source-role",
                        text: "$$fromRole"
                      },
                      {
                        tag: "span",
                        class: "log-source-id",
                        text: "$$fromId"
                      }
                    ]
                  },
                  {
                    tag: "span",
                    class: "log-target",
                    children: [
                      {
                        tag: "span",
                        class: "log-target-role",
                        text: "$$recipient"
                      },
                      {
                        tag: "span",
                        class: "log-target-id",
                        text: "$$targetId"
                      }
                    ]
                  },
                  {
                    tag: "details",
                    class: "log-payload-details",
                    children: [
                      {
                        tag: "summary",
                        class: "log-payload-toggle",
                        text: "$payloadLabel"
                      },
                      {
                        tag: "pre",
                        class: "log-payload",
                        text: "$$payload"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        }
      }
    ]
  }
}, gD = {
  $schema: "@schema/context",
  $id: "@todos/context/agent",
  currentView: "@list",
  viewMode: "list",
  listButtonActive: !0,
  logsButtonActive: !1,
  inputPlaceholder: "Add a new todo...",
  addButtonText: "Add",
  listViewLabel: "List",
  logsViewLabel: "Logs",
  newTodoText: "",
  error: null,
  "@actors": {
    list: "@todos/actor/list",
    logs: "@todos/actor/logs"
  }
}, rD = {
  $schema: "@schema/context",
  $id: "@todos/context/list",
  list: {
    schema: "@schema/data/todos"
  },
  toggleButtonText: "",
  deleteButtonText: ""
}, nD = {
  $schema: "@schema/context",
  $id: "@todos/context/logs",
  messages: {
    schema: "@schema/message",
    options: {
      map: {
        fromRole: "$$source.role",
        toRole: "$$target.role",
        fromId: "$$source.id",
        toId: "$$target.id"
      }
    }
  },
  payloadLabel: "payload"
}, sD = {
  $schema: "@schema/state",
  $id: "@todos/state/agent",
  initial: "idle",
  states: {
    idle: {
      on: {
        CREATE_BUTTON: {
          target: "creating"
        },
        TOGGLE_BUTTON: {
          target: "toggling"
        },
        DELETE_BUTTON: {
          target: "deleting"
        },
        SWITCH_VIEW: {
          target: "idle",
          actions: [
            {
              updateContext: { viewMode: "$$viewMode" }
            },
            {
              updateContext: {
                currentView: {
                  $if: {
                    condition: { $eq: ["$$viewMode", "list"] },
                    then: "@list",
                    else: "@logs"
                  }
                }
              }
            },
            {
              updateContext: {
                listButtonActive: {
                  $eq: ["$$viewMode", "list"]
                }
              }
            },
            {
              updateContext: {
                logsButtonActive: {
                  $eq: ["$$viewMode", "logs"]
                }
              }
            }
          ]
        },
        UPDATE_INPUT: {
          target: "idle",
          actions: [
            {
              updateContext: { newTodoText: "$$newTodoText" }
            }
          ]
        }
      }
    },
    creating: {
      entry: {
        tool: "@db",
        payload: {
          op: "create",
          schema: "@schema/data/todos",
          data: { text: "$$text", done: !1 }
        }
      },
      on: {
        UPDATE_INPUT: {
          target: "idle"
        },
        CREATE_BUTTON: {
          target: "creating"
        },
        TOGGLE_BUTTON: {
          target: "toggling"
        },
        DELETE_BUTTON: {
          target: "deleting"
        },
        SWITCH_VIEW: {
          target: "idle",
          actions: [
            {
              updateContext: { viewMode: "$$viewMode" }
            },
            {
              updateContext: {
                currentView: {
                  $if: {
                    condition: { $eq: ["$$viewMode", "list"] },
                    then: "@list",
                    else: "@logs"
                  }
                }
              }
            },
            {
              updateContext: {
                listButtonActive: {
                  $eq: ["$$viewMode", "list"]
                }
              }
            },
            {
              updateContext: {
                logsButtonActive: {
                  $eq: ["$$viewMode", "logs"]
                }
              }
            }
          ]
        },
        SUCCESS: {
          target: "idle",
          actions: [
            {
              updateContext: { newTodoText: "" }
            }
          ]
        },
        ERROR: "error"
      }
    },
    toggling: {
      entry: {
        tool: "@db",
        payload: {
          op: "update",
          id: "$$id",
          data: {
            done: {
              $not: "$$done"
            }
          }
        }
      },
      on: {
        TOGGLE_BUTTON: {
          target: "toggling"
        },
        DELETE_BUTTON: {
          target: "deleting"
        },
        UPDATE_INPUT: {
          target: "idle"
        },
        CREATE_BUTTON: {
          target: "creating"
        },
        SWITCH_VIEW: {
          target: "idle"
        },
        SUCCESS: {
          target: "idle"
        },
        ERROR: "error"
      }
    },
    deleting: {
      entry: {
        tool: "@db",
        payload: {
          op: "delete",
          id: "$$id"
        }
      },
      on: {
        DELETE_BUTTON: {
          target: "deleting"
        },
        UPDATE_INPUT: {
          target: "idle"
        },
        CREATE_BUTTON: {
          target: "creating"
        },
        SWITCH_VIEW: {
          target: "idle"
        },
        TOGGLE_BUTTON: {
          target: "toggling"
        },
        SUCCESS: {
          target: "idle"
        },
        ERROR: {
          target: "error"
        }
      }
    },
    error: {
      entry: {
        updateContext: { error: "$$error" }
      },
      on: {
        TOGGLE_BUTTON: {
          target: "toggling"
        },
        DELETE_BUTTON: {
          target: "deleting"
        },
        RETRY: {
          target: "idle",
          actions: [
            {
              updateContext: { error: null }
            }
          ]
        },
        DISMISS: {
          target: "idle",
          actions: [
            {
              updateContext: { error: null }
            }
          ]
        }
      }
    }
  }
}, aD = {
  $schema: "@schema/state",
  $id: "@todos/state/list",
  initial: "idle",
  states: {
    idle: {
      on: {
        TOGGLE_BUTTON: {
          target: "idle",
          actions: [
            {
              tool: "@core/publishMessage",
              payload: {
                type: "TOGGLE_BUTTON",
                payload: { id: "$$id", done: "$$done" },
                target: "@todos/actor/agent"
              }
            }
          ]
        },
        DELETE_BUTTON: {
          target: "idle",
          actions: [
            {
              tool: "@core/publishMessage",
              payload: {
                type: "DELETE_BUTTON",
                payload: { id: "$$id" },
                target: "@todos/actor/agent"
              }
            }
          ]
        },
        SUCCESS: {
          target: "idle"
        }
      }
    },
    error: {
      entry: {
        updateContext: { error: "$$error" }
      },
      on: {
        RETRY: {
          target: "idle",
          actions: [
            {
              updateContext: { error: null }
            }
          ]
        },
        DISMISS: {
          target: "idle",
          actions: [
            {
              updateContext: { error: null }
            }
          ]
        }
      }
    }
  }
}, ID = {
  $schema: "@schema/state",
  $id: "@todos/state/logs",
  initial: "idle",
  states: {
    idle: {},
    error: {
      entry: {
        updateContext: { error: "$$error" }
      },
      on: {
        RETRY: {
          target: "idle",
          actions: [
            {
              updateContext: { error: null }
            }
          ]
        },
        DISMISS: {
          target: "idle",
          actions: [
            {
              updateContext: { error: null }
            }
          ]
        }
      }
    }
  }
}, CD = {
  $schema: "@schema/inbox",
  $id: "@todos/inbox/agent",
  items: []
}, cD = {
  $schema: "@schema/inbox",
  $id: "@todos/inbox/list",
  items: []
}, BD = {
  $schema: "@schema/inbox",
  $id: "@todos/inbox/logs",
  items: []
}, dg = {
  vibe: zp,
  styles: {
    "@todos/style/brand": $p,
    "@todos/style/list": Zp,
    "@todos/style/logs": _p
  },
  actors: {
    "@todos/actor/agent": Xp,
    "@todos/actor/list": AD,
    "@todos/actor/logs": eD
  },
  views: {
    "@todos/view/agent": tD,
    "@todos/view/list": iD,
    "@todos/view/logs": oD
  },
  contexts: {
    "@todos/context/agent": gD,
    "@todos/context/list": rD,
    "@todos/context/logs": nD
  },
  states: {
    "@todos/state/agent": sD,
    "@todos/state/list": aD,
    "@todos/state/logs": ID
  },
  inboxes: {
    "@todos/inbox/agent": CD,
    "@todos/inbox/list": cD,
    "@todos/inbox/logs": BD
  },
  // Note: Children are now stored in context.actors (not separate children CoList files)
  // See agent.context.maia and composite.context.maia for children definitions
  // Initial data for seeding (creates individual todo CoMap items)
  // NOTE: These todos are automatically indexed into account.os.{schemaCoId} via storage hooks
  // The read() query reads from account.os.{schemaCoId}, NOT from account.data.todos (which is deprecated)
  data: {
    todos: [
      {
        text: "Welcome to MaiaOS! ",
        done: !1
      },
      {
        text: "Toggle me to mark as complete",
        done: !1
      }
    ]
  }
}, QD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  TodosVibeRegistry: dg
}, Symbol.toStringTag, { value: "Module" })), ED = {
  $schema: "@schema/vibe",
  $id: "@vibe/my-data",
  name: "MaiaDB",
  description: "Database viewer with navigation and detail panels",
  actor: "@my-data/actor/agent"
}, lD = {
  $schema: "@schema/style",
  $id: "@my-data/style/brand",
  tokens: {
    colors: {
      marineBlue: "#001F33",
      marineBlueMuted: "#2D4A5C",
      marineBlueLight: "#5E7A8C",
      paradiseWater: "#00BDD6",
      lushGreen: "#4E9A58",
      terracotta: "#C27B66",
      sunYellow: "#E6B94D",
      softClay: "#E8E1D9",
      tintedWhite: "#F0EDE6",
      background: "#E8E1D9",
      foreground: "#001F33",
      primary: "#00BDD6",
      secondary: "#2D4A5C",
      border: "rgba(255, 255, 255, 0.1)",
      surface: "rgba(255, 255, 255, 0.3)",
      glass: "rgba(255, 255, 255, 0.0005)",
      glassStrong: "rgba(255, 255, 255, 0.15)",
      text: {
        marine: "#D1E8F7",
        water: "#004D59",
        green: "#F0F9F1",
        terracotta: "#FDF2EF",
        yellow: "#4D3810"
      }
    },
    spacing: {
      xs: "0.5rem",
      sm: "0.75rem",
      md: "1rem",
      lg: "1.5rem",
      xl: "2rem",
      "2xl": "3rem"
    },
    typography: {
      fontFamily: {
        heading: "'Indie Flower', cursive",
        body: "'Plus Jakarta Sans', sans-serif"
      },
      fontFaces: [
        {
          fontFamily: "Indie Flower",
          src: "url('/brand/fonts/IndieFlower/IndieFlower-Regular.ttf') format('truetype')",
          fontWeight: "400",
          fontStyle: "normal",
          fontDisplay: "swap"
        },
        {
          fontFamily: "Plus Jakarta Sans",
          src: "url('/brand/fonts/Jarkata/PlusJakartaSans-VariableFont_wght.ttf') format('truetype')",
          fontWeight: "100 900",
          fontStyle: "normal",
          fontDisplay: "swap"
        }
      ],
      fontSize: {
        xs: "0.75rem",
        sm: "0.85rem",
        base: "1rem",
        lg: "1.15rem",
        xl: "1.5rem",
        "2xl": "2rem"
      },
      fontWeight: {
        light: "300",
        normal: "400",
        medium: "500",
        semibold: "600",
        bold: "700"
      }
    },
    radii: {
      sm: "4px",
      md: "12px",
      apple: "18px",
      full: "9999px"
    },
    shadows: {
      sm: "0 4px 30px rgba(0, 0, 0, 0.05)",
      md: "0 10px 30px rgba(0, 0, 0, 0.05)",
      lg: "0 10px 40px rgba(0, 0, 0, 0.1)"
    },
    transitions: {
      fast: "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)",
      standard: "all 0.5s cubic-bezier(0.2, 0, 0.2, 1)"
    }
  },
  components: {
    dbViewer: {
      display: "grid",
      gridTemplateColumns: "220px 1fr 400px",
      height: "100vh",
      width: "100%",
      background: "transparent",
      fontFamily: "{typography.fontFamily.body}",
      color: "{colors.marineBlue}",
      position: "relative",
      overflow: "hidden",
      padding: "{spacing.md}",
      gap: "{spacing.md}"
    },
    navAside: {
      background: "rgba(255, 255, 255, 0.4)",
      backdropFilter: "blur(12px) saturate(160%)",
      borderRadius: "{radii.apple}",
      border: "1px solid rgba(255, 255, 255, 0.2)",
      boxShadow: "{shadows.md}",
      padding: "{spacing.md}",
      overflowY: "auto",
      display: "flex",
      flexDirection: "column",
      gap: "{spacing.md}",
      zIndex: "10",
      height: "fit-content",
      maxHeight: "100%",
      position: "relative"
    },
    sidebarToggle: {
      display: "none",
      alignItems: "center",
      justifyContent: "center",
      width: "100%",
      padding: "{spacing.sm}",
      background: "rgba(255, 255, 255, 0.2)",
      border: "1px solid rgba(255, 255, 255, 0.2)",
      borderRadius: "{radii.md}",
      cursor: "pointer",
      marginBottom: "{spacing.sm}",
      fontSize: "0.7rem",
      fontWeight: "700",
      textTransform: "uppercase",
      color: "{colors.marineBlue}",
      fontFamily: "{typography.fontFamily.body}",
      transition: "{transitions.fast}",
      ":hover": {
        background: "rgba(255, 255, 255, 0.4)"
      }
    },
    detailContentWrapper: {
      display: "flex",
      flexDirection: "column",
      height: "100%",
      overflowY: "auto"
    },
    navTitle: {
      fontFamily: "{typography.fontFamily.heading}",
      fontSize: "{typography.fontSize.lg}",
      fontWeight: "{typography.fontWeight.normal}",
      fontStyle: "normal",
      color: "{colors.marineBlue}",
      marginBottom: "{spacing.sm}",
      marginTop: "0",
      padding: "0 {spacing.xs}",
      letterSpacing: "-0.02em"
    },
    navList: {
      display: "flex",
      flexDirection: "column",
      gap: "{spacing.sm}"
    },
    navCategory: {
      display: "flex",
      flexDirection: "column",
      gap: "{spacing.sm}"
    },
    navCategoryDivider: {
      fontFamily: "{typography.fontFamily.body}",
      fontSize: "0.6rem",
      fontWeight: "700",
      textTransform: "uppercase",
      letterSpacing: "0.15em",
      color: "{colors.marineBlueLight}",
      padding: "0.5rem {spacing.xs} 0.25rem {spacing.xs}",
      marginTop: "{spacing.sm}",
      marginBottom: "0"
    },
    navItem: {
      display: "flex",
      alignItems: "center",
      width: "100%",
      padding: "0.6rem 1.2rem",
      marginBottom: "{spacing.xs}",
      background: "rgba(255, 255, 255, 0.1)",
      backdropFilter: "blur(8px) saturate(150%)",
      border: "none",
      borderRadius: "{radii.full}",
      cursor: "pointer",
      transition: "{transitions.fast}",
      fontFamily: "{typography.fontFamily.body}",
      fontSize: "0.75rem",
      fontWeight: "{typography.fontWeight.semibold}",
      color: "{colors.marineBlueMuted}",
      textAlign: "left",
      textTransform: "uppercase",
      letterSpacing: "0.05em",
      boxShadow: "0 2px 8px rgba(0, 0, 0, 0.05)",
      ":hover": {
        background: "rgba(255, 255, 255, 0.2)",
        color: "{colors.marineBlue}",
        transform: "translateX(2px)",
        boxShadow: "0 4px 12px rgba(0, 0, 0, 0.1)"
      }
    },
    tableArea: {
      overflowY: "auto",
      display: "flex",
      flexDirection: "column",
      zIndex: "5",
      containerType: "inline-size",
      background: "transparent",
      padding: "0"
    },
    tableContainer: {
      background: "rgba(255, 255, 255, 0.4)",
      backdropFilter: "blur(12px) saturate(160%)",
      borderRadius: "{radii.apple}",
      boxShadow: "{shadows.md}",
      overflow: "auto",
      border: "1px solid rgba(255, 255, 255, 0.2)",
      transition: "{transitions.standard}",
      height: "100%",
      display: "flex",
      flexDirection: "column",
      padding: "{spacing.md}"
    },
    dataTable: {
      width: "100%",
      borderCollapse: "separate",
      borderSpacing: "0",
      fontFamily: "{typography.fontFamily.body}",
      fontSize: "{typography.fontSize.sm}"
    },
    "dataTable th": {
      background: "rgba(255, 255, 255, 0.4)",
      padding: "{spacing.lg}",
      textAlign: "left",
      fontWeight: "700",
      color: "{colors.marineBlue}",
      borderBottom: "1px solid {colors.border}",
      textTransform: "uppercase",
      letterSpacing: "0.12em",
      fontSize: "0.65rem"
    },
    "dataTable td": {
      padding: "{spacing.lg}",
      borderBottom: "1px solid {colors.border}",
      color: "{colors.marineBlueMuted}",
      transition: "{transitions.fast}",
      fontSize: "{typography.fontSize.sm}",
      fontWeight: "{typography.fontWeight.light}"
    },
    tableRow: {
      cursor: "pointer",
      transition: "{transitions.fast}",
      ":hover": {
        background: "rgba(255, 255, 255, 0.5)"
      }
    },
    detailAside: {
      overflowY: "auto",
      display: "flex",
      flexDirection: "column",
      zIndex: "10",
      containerType: "inline-size",
      background: "transparent",
      padding: "0"
    },
    detailContainer: {
      background: "rgba(255, 255, 255, 0.4)",
      backdropFilter: "blur(12px) saturate(160%)",
      borderRadius: "{radii.apple}",
      boxShadow: "{shadows.md}",
      overflow: "auto",
      border: "1px solid rgba(255, 255, 255, 0.2)",
      transition: "{transitions.standard}",
      height: "100%",
      display: "flex",
      flexDirection: "column",
      padding: "{spacing.md}"
    },
    detailTitle: {
      fontFamily: "{typography.fontFamily.heading}",
      fontSize: "{typography.fontSize.xl}",
      fontWeight: "{typography.fontWeight.bold}",
      color: "{colors.marineBlue}",
      marginBottom: "{spacing.md}",
      marginTop: "0",
      letterSpacing: "-0.02em"
    },
    detailCategory: {
      fontFamily: "{typography.fontFamily.heading}",
      fontSize: "0.85rem",
      fontStyle: "italic",
      color: "{colors.paradiseWater}",
      marginBottom: "0.5rem",
      display: "block",
      textShadow: "0 0 10px rgba(0, 189, 214, 0.2)"
    },
    detailList: {
      display: "flex",
      flexDirection: "column",
      gap: "{spacing.sm}"
    },
    detailItem: {
      display: "flex",
      flexDirection: "column",
      gap: "0.15rem",
      padding: "{spacing.md}",
      background: "rgba(255, 255, 255, 0.2)",
      borderRadius: "{radii.md}",
      border: "1px solid {colors.border}",
      transition: "{transitions.fast}",
      ":hover": {
        background: "rgba(255, 255, 255, 0.4)",
        transform: "translateY(-2px)",
        boxShadow: "{shadows.sm}"
      }
    },
    detailLabel: {
      fontSize: "0.65rem",
      textTransform: "uppercase",
      letterSpacing: "0.08em",
      color: "{colors.marineBlueLight}",
      fontWeight: "700"
    },
    detailValue: {
      fontSize: "{typography.fontSize.base}",
      color: "{colors.marineBlue}",
      fontWeight: "{typography.fontWeight.light}"
    }
  },
  selectors: {
    ":host": {
      position: "relative",
      background: "transparent",
      fontFamily: "{typography.fontFamily.body}",
      color: "{colors.foreground}"
    },
    ".nav-item[data-selected='true']": {
      background: "rgba(0, 189, 214, 0.2)",
      backdropFilter: "blur(12px) saturate(160%)",
      color: "{colors.marineBlue}",
      fontWeight: "{typography.fontWeight.semibold}",
      boxShadow: "0 4px 12px rgba(0, 189, 214, 0.2)",
      transform: "translateX(2px)",
      textShadow: "0 0 10px rgba(0, 189, 214, 0.3)",
      marginBottom: "{spacing.xs}"
    },
    ".nav-item:last-child": {
      marginBottom: "0"
    },
    ".nav-category:first-child .nav-category-divider": {
      marginTop: "0"
    },
    ".table-row[data-selected='true']": {
      background: "rgba(0, 189, 214, 0.15)",
      color: "{colors.marineBlue}",
      backdropFilter: "blur(4px)"
    },
    "@container (max-width: 1000px)": {
      ".db-viewer": {
        gridTemplateColumns: "180px 1fr 300px"
      }
    },
    "@container (max-width: 700px)": {
      ".db-viewer": {
        gridTemplateColumns: "1fr",
        gridTemplateRows: "auto 1fr auto",
        position: "relative",
        overflow: "hidden"
      },
      ".sidebar-toggle": {
        display: "flex"
      },
      ".nav-aside": {
        position: "absolute",
        left: "0",
        top: "0",
        bottom: "0",
        width: "280px",
        maxWidth: "85vw",
        zIndex: "100",
        transform: "translateX(-100%)",
        opacity: "0",
        pointerEvents: "none",
        transition: "none",
        boxShadow: "2px 0 20px rgba(0, 0, 0, 0.1)"
      },
      ".nav-aside.sidebar-ready": {
        transition: "{transitions.standard}"
      },
      ".nav-aside:not(.collapsed)": {
        transform: "translateX(0)",
        opacity: "1",
        pointerEvents: "auto"
      },
      ".detail-aside": {
        position: "absolute",
        right: "0",
        top: "0",
        bottom: "0",
        width: "320px",
        maxWidth: "85vw",
        zIndex: "100",
        transform: "translateX(100%)",
        opacity: "0",
        pointerEvents: "none",
        transition: "none",
        boxShadow: "-2px 0 20px rgba(0, 0, 0, 0.1)"
      },
      ".detail-aside.sidebar-ready": {
        transition: "{transitions.standard}"
      },
      ".detail-aside:not(.collapsed)": {
        transform: "translateX(0)",
        opacity: "1",
        pointerEvents: "auto"
      },
      ".nav-aside.collapsed": {
        transform: "translateX(-100%)",
        opacity: "0",
        pointerEvents: "none"
      },
      ".detail-aside.collapsed": {
        transform: "translateX(100%)",
        opacity: "0",
        pointerEvents: "none"
      },
      ".nav-aside.collapsed .nav-title": {
        display: "none"
      },
      ".nav-aside.collapsed .nav-list": {
        display: "none"
      },
      ".detail-aside.collapsed .detail-content-wrapper": {
        display: "none"
      }
    }
  }
}, dD = {
  $schema: "@schema/actor",
  $id: "@my-data/actor/agent",
  role: "agent",
  context: "@my-data/context/agent",
  view: "@my-data/view/agent",
  state: "@my-data/state/agent",
  brand: "@my-data/style/brand",
  inbox: "@my-data/inbox/agent",
  messageTypes: [
    "SELECT_NAV",
    "SELECT_ROW"
  ]
}, hD = {
  $schema: "@schema/actor",
  $id: "@my-data/actor/table",
  role: "ui",
  context: "@my-data/context/table",
  view: "@my-data/view/table",
  state: "@my-data/state/table",
  brand: "@my-data/style/brand",
  inbox: "@my-data/inbox/table",
  messageTypes: [
    "SELECT_ROW"
  ]
}, uD = {
  $schema: "@schema/actor",
  $id: "@my-data/actor/detail",
  role: "ui",
  context: "@my-data/context/detail",
  view: "@my-data/view/detail",
  state: "@my-data/state/detail",
  brand: "@my-data/style/brand",
  inbox: "@my-data/inbox/detail",
  messageTypes: []
}, fD = {
  $schema: "@schema/view",
  $id: "@my-data/view/agent",
  content: {
    tag: "div",
    class: "db-viewer",
    children: [
      {
        tag: "aside",
        class: "nav-aside",
        children: [
          {
            tag: "button",
            class: "sidebar-toggle nav-toggle",
            attrs: {
              "aria-label": "Toggle navigation sidebar"
            },
            text: "Navigation"
          },
          {
            tag: "h2",
            class: "nav-title",
            text: "$navTitle"
          },
          {
            tag: "nav",
            class: "nav-list",
            children: [
              {
                $each: {
                  items: "$navCategories",
                  template: {
                    tag: "div",
                    class: "nav-category",
                    children: [
                      {
                        tag: "div",
                        class: "nav-category-divider",
                        text: "$$category"
                      },
                      {
                        $each: {
                          items: "$$items",
                          template: {
                            tag: "button",
                            class: "nav-item",
                            attrs: {
                              data: {
                                selected: "$selectedNavItems.$$id"
                              }
                            },
                            children: [
                              {
                                tag: "span",
                                class: "nav-label",
                                text: "$$label"
                              }
                            ],
                            $on: {
                              click: {
                                send: "SELECT_NAV",
                                payload: { navId: "$$id" }
                              }
                            }
                          }
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        ]
      },
      {
        tag: "main",
        class: "table-area",
        $slot: "$currentTable"
      },
      {
        tag: "aside",
        class: "detail-aside",
        children: [
          {
            tag: "button",
            class: "sidebar-toggle detail-toggle",
            attrs: {
              "aria-label": "Toggle detail sidebar"
            },
            text: "Details"
          },
          {
            tag: "div",
            class: "detail-content-wrapper",
            $slot: "$currentDetail"
          }
        ]
      }
    ]
  }
}, wD = {
  $schema: "@schema/view",
  $id: "@my-data/view/table",
  content: {
    tag: "div",
    class: "table-container",
    children: [
      {
        tag: "table",
        class: "data-table",
        children: [
          {
            tag: "thead",
            children: [
              {
                tag: "tr",
                children: [
                  {
                    tag: "th",
                    text: "$tableHeaders.name"
                  },
                  {
                    tag: "th",
                    text: "$tableHeaders.email"
                  },
                  {
                    tag: "th",
                    text: "$tableHeaders.role"
                  },
                  {
                    tag: "th",
                    text: "$tableHeaders.status"
                  },
                  {
                    tag: "th",
                    text: "$tableHeaders.createdAt"
                  }
                ]
              }
            ]
          },
          {
            tag: "tbody",
            $each: {
              items: "$table",
              template: {
                tag: "tr",
                class: "table-row",
                attrs: {
                  data: {
                    selected: "$selectedRowItems.$$id"
                  }
                },
                children: [
                  {
                    tag: "td",
                    text: "$$name"
                  },
                  {
                    tag: "td",
                    text: "$$email"
                  },
                  {
                    tag: "td",
                    text: "$$role"
                  },
                  {
                    tag: "td",
                    text: "$$status"
                  },
                  {
                    tag: "td",
                    text: "$$createdAt"
                  }
                ],
                $on: {
                  click: {
                    send: "SELECT_ROW",
                    payload: { rowId: "$$id" }
                  }
                }
              }
            }
          }
        ]
      }
    ]
  }
}, yD = {
  $schema: "@schema/view",
  $id: "@my-data/view/detail",
  content: {
    tag: "div",
    class: "detail-container",
    children: [
      {
        tag: "span",
        class: "detail-category",
        text: "Metadata"
      },
      {
        tag: "h2",
        class: "detail-title",
        text: "Entity Insight"
      },
      {
        tag: "div",
        class: "detail-list",
        children: [
          {
            tag: "div",
            class: "detail-item",
            children: [
              { tag: "span", class: "detail-label", text: "$detailLabels.id" },
              { tag: "span", class: "detail-value", text: "$detail.id" }
            ]
          },
          {
            tag: "div",
            class: "detail-item",
            children: [
              { tag: "span", class: "detail-label", text: "$detailLabels.name" },
              { tag: "span", class: "detail-value", text: "$detail.name" }
            ]
          },
          {
            tag: "div",
            class: "detail-item",
            children: [
              { tag: "span", class: "detail-label", text: "$detailLabels.email" },
              { tag: "span", class: "detail-value", text: "$detail.email" }
            ]
          },
          {
            tag: "div",
            class: "detail-item",
            children: [
              { tag: "span", class: "detail-label", text: "$detailLabels.role" },
              { tag: "span", class: "detail-value", text: "$detail.role" }
            ]
          },
          {
            tag: "div",
            class: "detail-item",
            children: [
              { tag: "span", class: "detail-label", text: "$detailLabels.status" },
              { tag: "span", class: "detail-value", text: "$detail.status" }
            ]
          },
          {
            tag: "div",
            class: "detail-item",
            children: [
              { tag: "span", class: "detail-label", text: "$detailLabels.createdAt" },
              { tag: "span", class: "detail-value", text: "$detail.createdAt" }
            ]
          },
          {
            tag: "div",
            class: "detail-item",
            children: [
              { tag: "span", class: "detail-label", text: "$detailLabels.lastLogin" },
              { tag: "span", class: "detail-value", text: "$detail.lastLogin" }
            ]
          },
          {
            tag: "div",
            class: "detail-item",
            children: [
              { tag: "span", class: "detail-label", text: "$detailLabels.bio" },
              { tag: "span", class: "detail-value", text: "$detail.bio" }
            ]
          },
          {
            tag: "div",
            class: "detail-item",
            children: [
              { tag: "span", class: "detail-label", text: "$detailLabels.department" },
              { tag: "span", class: "detail-value", text: "$detail.department" }
            ]
          },
          {
            tag: "div",
            class: "detail-item",
            children: [
              { tag: "span", class: "detail-label", text: "$detailLabels.phone" },
              { tag: "span", class: "detail-value", text: "$detail.phone" }
            ]
          }
        ]
      }
    ]
  }
}, pD = {
  $schema: "@schema/context",
  $id: "@my-data/context/agent",
  navTitle: "MaiaDB",
  navCategories: [
    {
      category: "Account",
      items: [
        { id: "account", label: "Owner" },
        { id: "group", label: "Avatar" }
      ]
    },
    {
      category: "Vibes",
      items: [
        { id: "maia-db", label: "MaiaDB" },
        { id: "todos", label: "Todos" }
      ]
    },
    {
      category: "OS",
      items: [
        { id: "schemata", label: "Schemata" },
        { id: "indexes", label: "Indexes" }
      ]
    }
  ],
  selectedNavId: "account",
  selectedRowId: "1",
  selectedNavItems: { account: !0 },
  selectedRowItems: { 1: !0 },
  currentTable: "@table",
  currentDetail: "@detail",
  "@actors": {
    table: "@my-data/actor/table",
    detail: "@my-data/actor/detail"
  }
}, DD = {
  $schema: "@schema/context",
  $id: "@my-data/context/table",
  table: [
    { id: "1", name: "John Doe", email: "john@example.com", role: "admin", status: "active", createdAt: "2024-01-15" },
    { id: "2", name: "Jane Smith", email: "jane@example.com", role: "user", status: "active", createdAt: "2024-01-20" },
    { id: "3", name: "Bob Johnson", email: "bob@example.com", role: "user", status: "inactive", createdAt: "2024-02-01" },
    { id: "4", name: "Alice Williams", email: "alice@example.com", role: "moderator", status: "active", createdAt: "2024-02-10" },
    { id: "5", name: "Charlie Brown", email: "charlie@example.com", role: "user", status: "pending", createdAt: "2024-02-15" }
  ],
  selectedRowId: null,
  tableHeaders: {
    name: "Name",
    email: "Email",
    role: "Role",
    status: "Status",
    createdAt: "Created"
  }
}, mD = {
  $schema: "@schema/context",
  $id: "@my-data/context/detail",
  detail: {
    id: "1",
    name: "John Doe",
    email: "john@example.com",
    role: "admin",
    status: "active",
    createdAt: "2024-01-15",
    lastLogin: "2024-02-20",
    bio: "System administrator with 5 years of experience.",
    department: "IT",
    phone: "+1 (555) 123-4567"
  },
  detailLabels: {
    id: "ID",
    name: "Name",
    email: "Email",
    role: "Role",
    status: "Status",
    createdAt: "Created",
    lastLogin: "Last Login",
    bio: "Bio",
    department: "Department",
    phone: "Phone"
  }
}, SD = {
  $schema: "@schema/state",
  $id: "@my-data/state/agent",
  initial: "idle",
  states: {
    idle: {
      on: {
        SELECT_NAV: {
          target: "idle",
          actions: [
            {
              updateContext: {
                selectedNavId: "$$navId",
                selectedNavItems: { $$navId: !0 }
              }
            },
            {
              updateContext: {
                selectedRowId: null,
                selectedRowItems: {}
              }
            }
          ]
        },
        SELECT_ROW: {
          target: "idle",
          actions: [
            {
              updateContext: {
                selectedRowId: "$$rowId",
                selectedRowItems: { $$rowId: !0 }
              }
            }
          ]
        }
      }
    }
  }
}, ND = {
  $schema: "@schema/state",
  $id: "@my-data/state/table",
  initial: "idle",
  states: {
    idle: {
      on: {
        SELECT_ROW: {
          target: "idle",
          actions: [
            {
              updateContext: { selectedRowId: "$$rowId" }
            }
          ]
        }
      }
    }
  }
}, MD = {
  $schema: "@schema/state",
  $id: "@my-data/state/detail",
  initial: "idle",
  states: {
    idle: {}
  }
}, GD = {
  $schema: "@schema/inbox",
  $id: "@my-data/inbox/agent",
  cotype: "costream"
}, kD = {
  $schema: "@schema/inbox",
  $id: "@my-data/inbox/table",
  cotype: "costream"
}, FD = {
  $schema: "@schema/inbox",
  $id: "@my-data/inbox/detail",
  cotype: "costream"
}, hg = {
  vibe: ED,
  styles: {
    "@my-data/style/brand": lD
  },
  actors: {
    "@my-data/actor/agent": dD,
    "@my-data/actor/table": hD,
    "@my-data/actor/detail": uD
  },
  views: {
    "@my-data/view/agent": fD,
    "@my-data/view/table": wD,
    "@my-data/view/detail": yD
  },
  contexts: {
    "@my-data/context/agent": pD,
    "@my-data/context/table": DD,
    "@my-data/context/detail": mD
  },
  states: {
    "@my-data/state/agent": SD,
    "@my-data/state/table": ND,
    "@my-data/state/detail": MD
  },
  inboxes: {
    "@my-data/inbox/agent": GD,
    "@my-data/inbox/table": kD,
    "@my-data/inbox/detail": FD
  },
  // No initial data - this vibe uses mocked data in context
  data: {}
}, RD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  MyDataVibeRegistry: hg
}, Symbol.toStringTag, { value: "Module" }));
async function bD() {
  const i = [];
  try {
    const { TodosVibeRegistry: A } = await Promise.resolve().then(() => QD);
    A && A.vibe && i.push(A);
  } catch (A) {
    console.warn("[Vibes] Could not load TodosVibeRegistry:", A.message);
  }
  try {
    const { MaiaAgentVibeRegistry: A } = await Promise.resolve().then(() => PD);
    A && A.vibe && i.push(A);
  } catch (A) {
    console.warn("[Vibes] Could not load MaiaAgentVibeRegistry:", A.message);
  }
  try {
    const { MyDataVibeRegistry: A } = await Promise.resolve().then(() => RD);
    A && A.vibe && i.push(A);
  } catch (A) {
    console.warn("[Vibes] Could not load MyDataVibeRegistry:", A.message);
  }
  return i;
}
function KD(i) {
  if (!i) return null;
  const A = i.$id || "";
  return A.startsWith("@vibe/") ? A.replace("@vibe/", "") : (i.name || "default").toLowerCase().replace(/\s+/g, "-");
}
function YD(i, A = null) {
  if (A == null || Array.isArray(A) && A.length === 0)
    return [];
  if (A === "all")
    return i;
  if (Array.isArray(A)) {
    const e = A.map((t) => t.toLowerCase().trim());
    return i.filter((t) => {
      if (!t.vibe) return !1;
      const o = KD(t.vibe);
      return e.includes(o);
    });
  }
  return console.warn(`[Vibes] Invalid seeding config: ${A}. Expected null, "all", or array of vibe keys.`), [];
}
const vD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  MaiaOS: XA,
  MyDataRegistry: hg,
  MyDataVibeRegistry: hg,
  TodosRegistry: dg,
  TodosVibeRegistry: dg,
  filterVibesForSeeding: YD,
  getAllVibeRegistries: bD
}, Symbol.toStringTag, { value: "Module" })), UD = {
  $schema: "@schema/vibe",
  $id: "@vibe/maia",
  name: "Maia Agent",
  description: "CTO-level AI assistant for MaiaOS codebase",
  actor: "@maia/actor/agent"
}, JD = {
  $schema: "@schema/style",
  $id: "@maia/style/brand",
  tokens: {
    colors: {
      marineBlue: "#001F33",
      marineBlueMuted: "#2D4A5C",
      marineBlueLight: "#5E7A8C",
      paradiseWater: "#00BDD6",
      lushGreen: "#4E9A58",
      terracotta: "#C27B66",
      sunYellow: "#E6B94D",
      softClay: "#E8E1D9",
      tintedWhite: "#F0EDE6",
      background: "transparent",
      foreground: "#001F33",
      primary: "#00BDD6",
      secondary: "#2D4A5C",
      border: "rgba(255, 255, 255, 0.1)",
      surface: "rgba(255, 255, 255, 0.3)",
      glass: "rgba(255, 255, 255, 0.0005)",
      glassStrong: "rgba(255, 255, 255, 0.15)",
      text: {
        marine: "#D1E8F7",
        water: "#004D59",
        green: "#F0F9F1",
        terracotta: "#FDF2EF",
        yellow: "#4D3810"
      }
    },
    spacing: {
      xs: "0.5rem",
      sm: "0.75rem",
      md: "1rem",
      lg: "1.5rem",
      xl: "2rem",
      "2xl": "3rem"
    },
    typography: {
      fontFamily: {
        heading: "'Indie Flower', cursive",
        body: "'Plus Jakarta Sans', sans-serif"
      },
      fontWeight: {
        light: "300",
        normal: "400",
        medium: "500",
        semibold: "600",
        bold: "700"
      }
    },
    radii: {
      sm: "4px",
      md: "12px",
      apple: "18px",
      full: "9999px"
    },
    shadows: {
      sm: "0 4px 30px rgba(0, 0, 0, 0.05)",
      md: "0 10px 30px rgba(0, 0, 0, 0.05)",
      lg: "0 10px 40px rgba(0, 0, 0, 0.1)"
    },
    transitions: {
      fast: "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)",
      standard: "all 0.5s cubic-bezier(0.2, 0, 0.2, 1)"
    }
  },
  selectors: {
    ":host": {
      display: "block",
      height: "100%",
      background: "{colors.background}",
      fontFamily: "{typography.fontFamily.body}",
      color: "{colors.marineBlue}"
    },
    ".chatContainer": {
      display: "grid",
      gridTemplateRows: "1fr auto",
      height: "100%",
      minHeight: "0",
      maxHeight: "100%",
      position: "relative",
      overflow: "hidden",
      background: "{colors.softClay}",
      padding: "{spacing.sm}",
      gap: "{spacing.sm}"
    },
    ".messagesContainer": {
      gridRow: "1",
      overflowY: "auto",
      overflowX: "hidden",
      padding: "{spacing.sm}",
      display: "flex",
      flexDirection: "column",
      gap: "{spacing.md}",
      minHeight: "0",
      maxHeight: "100%",
      position: "relative",
      zIndex: "1",
      background: "rgba(255, 255, 255, 0.4)",
      backdropFilter: "blur(8px) saturate(150%)",
      borderRadius: "{radii.apple}",
      border: "1px solid {colors.border}",
      boxShadow: "{shadows.md}"
    },
    ".message-wrapper": {
      display: "flex",
      flexDirection: "column",
      marginBottom: "{spacing.md}"
    },
    ".message-wrapper[data-role='user']": {
      alignItems: "flex-end"
    },
    ".message-wrapper[data-role='assistant']": {
      alignItems: "flex-start"
    },
    ".message-name": {
      fontSize: "0.65rem",
      fontWeight: "{typography.fontWeight.semibold}",
      textTransform: "uppercase",
      letterSpacing: "0.05em",
      marginBottom: "0.25rem",
      opacity: "0.7"
    },
    ".message-wrapper[data-role='user'] .message-name": {
      color: "{colors.marineBlue}",
      textAlign: "right"
    },
    ".message-wrapper[data-role='assistant'] .message-name": {
      color: "{colors.marineBlue}",
      textAlign: "left"
    },
    ".message": {
      padding: "{spacing.sm} {spacing.md}",
      borderRadius: "{radii.apple}",
      maxWidth: "85%",
      wordWrap: "break-word",
      fontSize: "0.75rem",
      fontWeight: "{typography.fontWeight.light}",
      lineHeight: "1.4",
      transition: "{transitions.fast}"
    },
    ".messageAssistant": {
      alignSelf: "flex-start",
      background: "rgba(255, 255, 255, 0.6)",
      color: "{colors.marineBlue}",
      border: "1px solid {colors.border}",
      boxShadow: "{shadows.sm}"
    },
    ".messageUser": {
      alignSelf: "flex-end",
      background: "{colors.marineBlue}",
      color: "{colors.text.marine}",
      boxShadow: "0 4px 12px rgba(0, 31, 51, 0.2)"
    },
    ".message[data-role='assistant']": {
      alignSelf: "flex-start",
      background: "rgba(255, 255, 255, 0.6)",
      color: "{colors.marineBlue}",
      border: "1px solid {colors.border}"
    },
    ".message[data-role='user']": {
      alignSelf: "flex-end",
      background: "{colors.marineBlue}",
      color: "{colors.text.marine}"
    },
    ".welcomeMessage": {
      fontFamily: "{typography.fontFamily.body}",
      fontSize: "0.75rem",
      background: "rgba(0, 189, 214, 0.05)",
      border: "1px solid rgba(0, 189, 214, 0.1)",
      color: "{colors.marineBlue}",
      marginTop: "{spacing.sm}",
      marginBottom: "{spacing.md}",
      data: {
        hasConversations: {
          true: {
            display: "none"
          }
        }
      }
    },
    ".welcomeSection": {
      display: "flex",
      flexDirection: "column",
      marginBottom: "{spacing.md}"
    },
    ".agentCategory": {
      fontFamily: "{typography.fontFamily.heading}",
      fontSize: "0.6rem",
      fontStyle: "italic",
      color: "{colors.paradiseWater}",
      marginBottom: "0.25rem",
      display: "block",
      textShadow: "0 0 10px rgba(0, 189, 214, 0.2)"
    },
    ".agentTitle": {
      fontFamily: "{typography.fontFamily.heading}",
      fontSize: "0.9rem",
      fontWeight: "{typography.fontWeight.bold}",
      color: "{colors.marineBlue}",
      margin: "0",
      letterSpacing: "-0.02em"
    },
    ".inputContainer": {
      gridRow: "2",
      display: "flex",
      gap: "{spacing.sm}",
      padding: "{spacing.sm}",
      background: "rgba(255, 255, 255, 0.4)",
      backdropFilter: "blur(8px) saturate(150%)",
      borderRadius: "{radii.full}",
      border: "1px solid {colors.border}",
      boxShadow: "{shadows.md}",
      flexShrink: "0",
      position: "relative",
      zIndex: "100"
    },
    ".input": {
      flex: "1",
      padding: "{spacing.xs} {spacing.md}",
      border: "none",
      background: "transparent",
      fontSize: "0.7rem",
      color: "{colors.marineBlue}",
      fontFamily: "{typography.fontFamily.body}",
      fontWeight: "{typography.fontWeight.light}",
      outline: "none",
      cursor: "text"
    },
    ".button": {
      padding: "{spacing.xs} {spacing.md}",
      background: "{colors.paradiseWater}",
      color: "{colors.text.water}",
      border: "none",
      borderRadius: "{radii.full}",
      cursor: "pointer",
      fontSize: "0.6rem",
      fontWeight: "600",
      textTransform: "uppercase",
      letterSpacing: "0.05em",
      transition: "{transitions.fast}",
      boxShadow: "0 4px 12px rgba(0, 189, 214, 0.2)",
      ":hover": {
        filter: "brightness(1.1)",
        transform: "translateY(-1px)",
        boxShadow: "0 6px 16px rgba(0, 189, 214, 0.3)"
      },
      ":active": {
        transform: "translateY(0)"
      }
    },
    ".button:disabled": {
      background: "{colors.marineBlueLight}",
      opacity: "0.5",
      cursor: "not-allowed",
      boxShadow: "none"
    },
    ".loading": {
      padding: "{spacing.sm} {spacing.md}",
      color: "{colors.marineBlueLight}",
      fontFamily: "{typography.fontFamily.heading}",
      fontStyle: "italic",
      display: "none",
      position: "absolute",
      top: "{spacing.xl}",
      left: "50%",
      transform: "translateX(-50%)",
      zIndex: "10",
      background: "rgba(232, 225, 217, 0.8)",
      backdropFilter: "blur(4px)",
      borderRadius: "{radii.full}",
      border: "1px solid {colors.border}",
      data: {
        isLoading: {
          true: {
            display: "block"
          }
        }
      }
    },
    ".error": {
      padding: "{spacing.md}",
      background: "rgba(194, 123, 102, 0.1)",
      color: "{colors.terracotta}",
      borderRadius: "{radii.apple}",
      border: "1px solid rgba(194, 123, 102, 0.2)",
      margin: "{spacing.md}",
      display: "none",
      data: {
        hasError: {
          true: {
            display: "block"
          }
        }
      }
    },
    "@container {containerName} (min-width: {containers.xs})": {
      ".chatContainer": {
        padding: "{spacing.sm}",
        gap: "{spacing.sm}"
      },
      ".messagesContainer": {
        padding: "{spacing.sm}",
        gap: "{spacing.md}"
      },
      ".message": {
        padding: "{spacing.sm} {spacing.md}",
        fontSize: "0.7rem"
      },
      ".agentCategory": {
        fontSize: "0.65rem"
      },
      ".agentTitle": {
        fontSize: "0.85rem"
      },
      ".inputContainer": {
        gap: "{spacing.sm}",
        padding: "{spacing.sm}"
      },
      ".input": {
        padding: "{spacing.xs} {spacing.md}",
        fontSize: "0.7rem"
      },
      ".button": {
        padding: "{spacing.xs} {spacing.md}",
        fontSize: "0.65rem"
      },
      ".welcomeMessage": {
        fontSize: "0.7rem"
      }
    },
    "@container {containerName} (min-width: {containers.sm})": {
      ".chatContainer": {
        padding: "{spacing.sm}",
        gap: "{spacing.sm}"
      },
      ".messagesContainer": {
        padding: "{spacing.sm}",
        gap: "{spacing.md}"
      },
      ".message": {
        padding: "{spacing.sm} {spacing.md}",
        fontSize: "0.75rem"
      },
      ".agentCategory": {
        fontSize: "0.7rem"
      },
      ".agentTitle": {
        fontSize: "0.9rem"
      },
      ".inputContainer": {
        gap: "{spacing.sm}",
        padding: "{spacing.sm}"
      },
      ".input": {
        padding: "{spacing.xs} {spacing.md}",
        fontSize: "0.7rem"
      },
      ".button": {
        padding: "{spacing.xs} {spacing.md}",
        fontSize: "0.65rem"
      },
      ".welcomeMessage": {
        fontSize: "0.75rem"
      }
    },
    "@container {containerName} (min-width: {containers.md})": {
      ".chatContainer": {
        padding: "{spacing.sm}",
        gap: "{spacing.sm}"
      },
      ".messagesContainer": {
        padding: "{spacing.sm}",
        gap: "{spacing.md}"
      },
      ".message": {
        padding: "{spacing.sm} {spacing.md}",
        fontSize: "0.8rem"
      },
      ".agentCategory": {
        fontSize: "0.75rem"
      },
      ".agentTitle": {
        fontSize: "0.95rem"
      },
      ".inputContainer": {
        gap: "{spacing.sm}",
        padding: "{spacing.sm}"
      },
      ".input": {
        padding: "{spacing.xs} {spacing.md}",
        fontSize: "0.75rem"
      },
      ".button": {
        padding: "{spacing.xs} {spacing.md}",
        fontSize: "0.7rem"
      },
      ".welcomeMessage": {
        fontSize: "0.8rem"
      }
    },
    "@container {containerName} (min-width: {containers.lg})": {
      ".chatContainer": {
        padding: "{spacing.sm}",
        gap: "{spacing.sm}"
      },
      ".messagesContainer": {
        padding: "{spacing.sm}",
        gap: "{spacing.md}"
      },
      ".message": {
        padding: "{spacing.sm} {spacing.md}",
        fontSize: "0.85rem"
      },
      ".agentCategory": {
        fontSize: "0.8rem"
      },
      ".agentTitle": {
        fontSize: "1rem"
      },
      ".inputContainer": {
        gap: "{spacing.sm}",
        padding: "{spacing.sm}"
      },
      ".input": {
        padding: "{spacing.xs} {spacing.md}",
        fontSize: "0.8rem"
      },
      ".button": {
        padding: "{spacing.xs} {spacing.md}",
        fontSize: "0.75rem"
      },
      ".welcomeMessage": {
        fontSize: "0.85rem"
      }
    },
    "@container {containerName} (min-width: {containers.xl})": {
      ".chatContainer": {
        padding: "{spacing.sm}",
        gap: "{spacing.sm}"
      },
      ".messagesContainer": {
        padding: "{spacing.sm}",
        gap: "{spacing.md}"
      },
      ".message": {
        padding: "{spacing.sm} {spacing.md}",
        fontSize: "0.9rem"
      },
      ".agentCategory": {
        fontSize: "0.85rem"
      },
      ".agentTitle": {
        fontSize: "1.05rem"
      },
      ".inputContainer": {
        gap: "{spacing.sm}",
        padding: "{spacing.sm}"
      },
      ".input": {
        padding: "{spacing.xs} {spacing.md}",
        fontSize: "0.85rem"
      },
      ".button": {
        padding: "{spacing.xs} {spacing.md}",
        fontSize: "0.8rem"
      },
      ".welcomeMessage": {
        fontSize: "0.9rem"
      }
    },
    "@container {containerName} (min-width: {containers.2xl})": {
      ".chatContainer": {
        padding: "{spacing.sm}",
        gap: "{spacing.sm}"
      },
      ".messagesContainer": {
        padding: "{spacing.sm}",
        gap: "{spacing.md}"
      },
      ".message": {
        padding: "{spacing.sm} {spacing.md}",
        fontSize: "0.95rem"
      },
      ".agentCategory": {
        fontSize: "0.9rem"
      },
      ".agentTitle": {
        fontSize: "1.1rem"
      },
      ".inputContainer": {
        gap: "{spacing.sm}",
        padding: "{spacing.sm}"
      },
      ".input": {
        padding: "{spacing.xs} {spacing.md}",
        fontSize: "0.9rem"
      },
      ".button": {
        padding: "{spacing.xs} {spacing.md}",
        fontSize: "0.85rem"
      },
      ".welcomeMessage": {
        fontSize: "0.95rem"
      }
    }
  }
}, HD = {
  $schema: "@schema/actor",
  $id: "@maia/actor/agent",
  role: "agent",
  context: "@maia/context/agent",
  view: "@maia/view/agent",
  state: "@maia/state/agent",
  brand: "@maia/style/brand",
  inbox: "@maia/inbox/agent",
  messageTypes: [
    "SEND_MESSAGE",
    "UPDATE_INPUT",
    "RENDER_COMPLETE",
    "SUCCESS",
    "ERROR",
    "RETRY",
    "DISMISS"
  ]
}, qD = {
  $schema: "@schema/view",
  $id: "@maia/view/agent",
  content: {
    tag: "div",
    class: "chat-container",
    children: [
      {
        tag: "div",
        class: "messages-container",
        children: [
          {
            tag: "div",
            class: "welcome-section",
            children: [
              {
                tag: "h2",
                class: "agent-title",
                text: "Maia"
              },
              {
                tag: "div",
                class: "message message-assistant welcome-message",
                attrs: {
                  data: {
                    hasConversations: "$hasConversations"
                  }
                },
                text: "Hello! I'm Maia, your CTO-level AI assistant. I understand the MaiaOS codebase and learn alongside your coding sessions. How can I help you today?"
              }
            ]
          },
          {
            $each: {
              items: "$conversations",
              template: {
                tag: "div",
                class: "message-wrapper",
                attrs: {
                  data: {
                    role: "$$role"
                  }
                },
                children: [
                  {
                    tag: "div",
                    class: "message-name",
                    text: "$messageNames.$$id"
                  },
                  {
                    tag: "div",
                    class: "message",
                    attrs: {
                      data: {
                        role: "$$role"
                      }
                    },
                    text: "$$content"
                  }
                ]
              }
            }
          }
        ]
      },
      {
        tag: "div",
        class: "loading",
        attrs: {
          data: {
            isLoading: "$isLoading"
          }
        },
        text: "Maia is thinking..."
      },
      {
        tag: "div",
        class: "error",
        attrs: {
          data: {
            hasError: "$hasError"
          }
        },
        children: [
          {
            tag: "strong",
            text: "Error: "
          },
          {
            text: "$error"
          },
          {
            tag: "button",
            class: "button",
            text: "Dismiss",
            $on: {
              click: {
                send: "DISMISS"
              }
            }
          }
        ]
      },
      {
        tag: "div",
        class: "input-container",
        children: [
          {
            tag: "input",
            class: "input",
            attrs: {
              type: "text",
              placeholder: "Type your message...",
              disabled: "$isLoading"
            },
            value: "$inputText",
            $on: {
              input: {
                send: "UPDATE_INPUT",
                payload: { inputText: "@inputValue" }
              },
              keydown: {
                send: "SEND_MESSAGE",
                payload: { inputText: "@inputValue" },
                key: "Enter"
              }
            }
          },
          {
            tag: "button",
            class: "button",
            attrs: {
              disabled: "$isLoading"
            },
            text: "Send",
            $on: {
              click: {
                send: "SEND_MESSAGE",
                payload: { inputText: "$inputText" }
              }
            }
          }
        ]
      }
    ]
  }
}, LD = {
  $schema: "@schema/context",
  $id: "@maia/context/agent",
  conversations: {
    schema: "@schema/data/chat"
  },
  inputText: "",
  assistantResponse: null,
  isLoading: !1,
  error: null,
  hasConversations: !1,
  hasError: !1,
  messageNames: {}
}, xD = {
  $schema: "@schema/state",
  $id: "@maia/state/agent",
  initial: "idle",
  states: {
    idle: {
      entry: [
        {
          updateContext: {
            isLoading: !1
          }
        },
        {
          tool: "@core/computeMessageNames",
          payload: {
            conversations: "$conversations"
          },
          onSuccess: {
            updateContext: {
              messageNames: "$$result"
            }
          }
        }
      ],
      on: {
        RENDER_COMPLETE: {
          target: "idle",
          actions: [
            {
              updateContext: {
                hasConversations: {
                  $gt: [{ $length: "$conversations" }, 0]
                }
              }
            },
            {
              tool: "@core/computeMessageNames",
              payload: {
                conversations: "$conversations"
              },
              onSuccess: {
                updateContext: {
                  messageNames: "$$result"
                }
              }
            }
          ]
        },
        SEND_MESSAGE: {
          target: "chatting"
        },
        UPDATE_INPUT: {
          target: "idle",
          actions: [
            {
              updateContext: { inputText: "$$inputText" }
            }
          ]
        }
      }
    },
    chatting: {
      entry: [
        {
          updateContext: {
            isLoading: !0,
            hasError: !1
          }
        },
        {
          tool: "@db",
          payload: {
            op: "create",
            schema: "@schema/data/chat",
            data: {
              role: "user",
              content: "$$inputText"
            }
          }
        }
      ],
      on: {
        SUCCESS: {
          target: "calling_llm",
          actions: [
            {
              updateContext: {
                inputText: ""
              }
            }
          ]
        },
        ERROR: {
          target: "error",
          actions: [
            {
              updateContext: {
                isLoading: !1
              }
            }
          ]
        }
      }
    },
    calling_llm: {
      entry: {
        tool: "@agent/chat",
        payload: {
          model: "qwen/qwen3-30b-a3b-instruct-2507",
          temperature: 1,
          context: {
            $concat: [
              [
                {
                  role: "system",
                  content: "You are Maia, a CTO-level AI assistant that understands the entire MaiaOS codebase, architecture, and all packages. You learn alongside coding sessions. Be helpful, technical, and concise. Never use emoticons in your responses."
                }
              ],
              {
                $map: {
                  array: "$conversations",
                  as: "msg",
                  return: {
                    role: "$$msg.role",
                    content: "$$msg.content"
                  }
                }
              }
            ]
          }
        }
      },
      on: {
        SUCCESS: {
          target: "saving_response"
        },
        ERROR: {
          target: "error",
          actions: [
            {
              updateContext: {
                isLoading: !1
              }
            }
          ]
        }
      }
    },
    saving_response: {
      entry: [
        {
          tool: "@db",
          payload: {
            op: "create",
            schema: "@schema/data/chat",
            data: {
              role: "assistant",
              content: "$$result.content"
            }
          }
        }
      ],
      on: {
        SUCCESS: {
          target: "idle",
          actions: [
            {
              updateContext: {
                assistantResponse: null,
                isLoading: !1,
                hasError: !1
              }
            },
            {
              updateContext: {
                hasConversations: {
                  $gt: [{ $length: "$conversations" }, 0]
                }
              }
            },
            {
              tool: "@core/computeMessageNames",
              payload: {
                conversations: "$conversations"
              },
              onSuccess: {
                updateContext: {
                  messageNames: "$$result"
                }
              }
            }
          ]
        },
        ERROR: {
          target: "error",
          actions: [
            {
              updateContext: {
                isLoading: !1
              }
            }
          ]
        }
      }
    },
    error: {
      entry: {
        updateContext: {
          error: "$$error",
          isLoading: !1,
          hasError: !0
        }
      },
      on: {
        SEND_MESSAGE: {
          target: "chatting",
          actions: [
            {
              updateContext: {
                error: null,
                hasError: !1
              }
            }
          ]
        },
        RETRY: {
          target: "idle",
          actions: [
            {
              updateContext: {
                error: null,
                hasError: !1
              }
            }
          ]
        },
        DISMISS: {
          target: "idle",
          actions: [
            {
              updateContext: {
                error: null,
                hasError: !1
              }
            }
          ]
        }
      }
    }
  }
}, TD = {
  $schema: "@schema/inbox",
  $id: "@maia/inbox/agent"
}, OD = {
  vibe: UD,
  styles: {
    "@maia/style/brand": JD
  },
  actors: {
    "@maia/actor/agent": HD
  },
  views: {
    "@maia/view/agent": qD
  },
  contexts: {
    "@maia/context/agent": LD
  },
  states: {
    "@maia/state/agent": xD
  },
  inboxes: {
    "@maia/inbox/agent": TD
  }
}, PD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  MaiaAgentVibeRegistry: OD
}, Symbol.toStringTag, { value: "Module" }));
export {
  XA as MaiaOS,
  mA as ReactiveStore,
  lw as createAgentAccount,
  uf as createCoJSONAPI,
  Ew as generateAgentCredentials,
  go as getAllSchemas,
  Ca as getSchema,
  ra as getSchemaIndexColistId,
  qa as isPRFSupported,
  dw as loadAgentAccount,
  Yt as setupSyncPeers,
  Qw as signInWithPasskey,
  Bw as signUpWithPasskey,
  Yf as subscribeSyncState
};
