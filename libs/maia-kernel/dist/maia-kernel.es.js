function ac(t, A) {
  for (var e = 0; e < A.length; e++) {
    const i = A[e];
    if (typeof i != "string" && !Array.isArray(i)) {
      for (const o in i)
        if (o !== "default" && !(o in t)) {
          const r = Object.getOwnPropertyDescriptor(i, o);
          r && Object.defineProperty(t, o, r.get ? r : {
            enumerable: !0,
            get: () => i[o]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }));
}
const gc = new TextEncoder(), Ic = new TextDecoder();
function Er(t) {
  t = t.replace(/=/g, "");
  const A = t.length, e = A % 4, i = e && e - 1, o = (A >> 2) * 3 + i, r = new Uint8Array(A + 3);
  gc.encodeInto(t + "===", r);
  for (let n = 0, s = 0; n < A; n += 4, s += 3) {
    const a = (Ze[r[n]] << 18) + (Ze[r[n + 1]] << 12) + (Ze[r[n + 2]] << 6) + Ze[r[n + 3]];
    r[s] = a >> 16, r[s + 1] = a >> 8 & 255, r[s + 2] = a & 255;
  }
  return new Uint8Array(r.buffer, 0, o);
}
function lr(t) {
  const A = t.length, e = A % 3, i = Math.floor(A / 3) * 4 + (e && e + 1), o = Math.ceil(A / 3) * 4, r = new Uint8Array(o);
  for (let s = 0, a = 0; a < A; s += 4, a += 3) {
    const g = (t[a] << 16) + (t[a + 1] << 8) + (t[a + 2] | 0);
    r[s] = pt[g >> 18], r[s + 1] = pt[g >> 12 & 63], r[s + 2] = pt[g >> 6 & 63], r[s + 3] = pt[g & 63];
  }
  let n = Ic.decode(new Uint8Array(r.buffer, 0, i));
  return e === 1 && (n += "=="), e === 2 && (n += "="), n;
}
const ag = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", Ze = new Uint8Array(128);
for (const [t, A] of Array.from(ag).entries())
  Ze[A.charCodeAt(0)] = t;
Ze[61] = 0;
const pt = new Uint8Array(64);
for (const [t, A] of Array.from(ag).entries())
  pt[t] = A.charCodeAt(0);
var cc = typeof globalThis == "object" ? globalThis : typeof self == "object" ? self : typeof window == "object" ? window : typeof globalThis == "object" ? globalThis : {}, Ne = "1.9.0", Zn = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
function Cc(t) {
  var A = /* @__PURE__ */ new Set([t]), e = /* @__PURE__ */ new Set(), i = t.match(Zn);
  if (!i)
    return function() {
      return !1;
    };
  var o = {
    major: +i[1],
    minor: +i[2],
    patch: +i[3],
    prerelease: i[4]
  };
  if (o.prerelease != null)
    return function(a) {
      return a === t;
    };
  function r(s) {
    return e.add(s), !1;
  }
  function n(s) {
    return A.add(s), !0;
  }
  return function(a) {
    if (A.has(a))
      return !0;
    if (e.has(a))
      return !1;
    var g = a.match(Zn);
    if (!g)
      return r(a);
    var I = {
      major: +g[1],
      minor: +g[2],
      patch: +g[3],
      prerelease: g[4]
    };
    return I.prerelease != null || o.major !== I.major ? r(a) : o.major === 0 ? o.minor === I.minor && o.patch <= I.patch ? n(a) : r(a) : o.minor <= I.minor ? n(a) : r(a);
  };
}
var Bc = Cc(Ne), Qc = Ne.split(".")[0], Kt = /* @__PURE__ */ Symbol.for("opentelemetry.js.api." + Qc), vt = cc;
function xt(t, A, e, i) {
  var o;
  i === void 0 && (i = !1);
  var r = vt[Kt] = (o = vt[Kt]) !== null && o !== void 0 ? o : {
    version: Ne
  };
  if (!i && r[t]) {
    var n = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + t);
    return e.error(n.stack || n.message), !1;
  }
  if (r.version !== Ne) {
    var n = new Error("@opentelemetry/api: Registration of version v" + r.version + " for " + t + " does not match previously registered API v" + Ne);
    return e.error(n.stack || n.message), !1;
  }
  return r[t] = A, e.debug("@opentelemetry/api: Registered a global for " + t + " v" + Ne + "."), !0;
}
function Ke(t) {
  var A, e, i = (A = vt[Kt]) === null || A === void 0 ? void 0 : A.version;
  if (!(!i || !Bc(i)))
    return (e = vt[Kt]) === null || e === void 0 ? void 0 : e[t];
}
function Lt(t, A) {
  A.debug("@opentelemetry/api: Unregistering a global for " + t + " v" + Ne + ".");
  var e = vt[Kt];
  e && delete e[t];
}
var Ec = function(t, A) {
  var e = typeof Symbol == "function" && t[Symbol.iterator];
  if (!e) return t;
  var i = e.call(t), o, r = [], n;
  try {
    for (; (A === void 0 || A-- > 0) && !(o = i.next()).done; ) r.push(o.value);
  } catch (s) {
    n = { error: s };
  } finally {
    try {
      o && !o.done && (e = i.return) && e.call(i);
    } finally {
      if (n) throw n.error;
    }
  }
  return r;
}, lc = function(t, A, e) {
  if (arguments.length === 2) for (var i = 0, o = A.length, r; i < o; i++)
    (r || !(i in A)) && (r || (r = Array.prototype.slice.call(A, 0, i)), r[i] = A[i]);
  return t.concat(r || Array.prototype.slice.call(A));
}, dc = (
  /** @class */
  (function() {
    function t(A) {
      this._namespace = A.namespace || "DiagComponentLogger";
    }
    return t.prototype.debug = function() {
      for (var A = [], e = 0; e < arguments.length; e++)
        A[e] = arguments[e];
      return Ct("debug", this._namespace, A);
    }, t.prototype.error = function() {
      for (var A = [], e = 0; e < arguments.length; e++)
        A[e] = arguments[e];
      return Ct("error", this._namespace, A);
    }, t.prototype.info = function() {
      for (var A = [], e = 0; e < arguments.length; e++)
        A[e] = arguments[e];
      return Ct("info", this._namespace, A);
    }, t.prototype.warn = function() {
      for (var A = [], e = 0; e < arguments.length; e++)
        A[e] = arguments[e];
      return Ct("warn", this._namespace, A);
    }, t.prototype.verbose = function() {
      for (var A = [], e = 0; e < arguments.length; e++)
        A[e] = arguments[e];
      return Ct("verbose", this._namespace, A);
    }, t;
  })()
);
function Ct(t, A, e) {
  var i = Ke("diag");
  if (i)
    return e.unshift(A), i[t].apply(i, lc([], Ec(e), !1));
}
var UA;
(function(t) {
  t[t.NONE = 0] = "NONE", t[t.ERROR = 30] = "ERROR", t[t.WARN = 50] = "WARN", t[t.INFO = 60] = "INFO", t[t.DEBUG = 70] = "DEBUG", t[t.VERBOSE = 80] = "VERBOSE", t[t.ALL = 9999] = "ALL";
})(UA || (UA = {}));
function uc(t, A) {
  t < UA.NONE ? t = UA.NONE : t > UA.ALL && (t = UA.ALL), A = A || {};
  function e(i, o) {
    var r = A[i];
    return typeof r == "function" && t >= o ? r.bind(A) : function() {
    };
  }
  return {
    error: e("error", UA.ERROR),
    warn: e("warn", UA.WARN),
    info: e("info", UA.INFO),
    debug: e("debug", UA.DEBUG),
    verbose: e("verbose", UA.VERBOSE)
  };
}
var hc = function(t, A) {
  var e = typeof Symbol == "function" && t[Symbol.iterator];
  if (!e) return t;
  var i = e.call(t), o, r = [], n;
  try {
    for (; (A === void 0 || A-- > 0) && !(o = i.next()).done; ) r.push(o.value);
  } catch (s) {
    n = { error: s };
  } finally {
    try {
      o && !o.done && (e = i.return) && e.call(i);
    } finally {
      if (n) throw n.error;
    }
  }
  return r;
}, fc = function(t, A, e) {
  if (arguments.length === 2) for (var i = 0, o = A.length, r; i < o; i++)
    (r || !(i in A)) && (r || (r = Array.prototype.slice.call(A, 0, i)), r[i] = A[i]);
  return t.concat(r || Array.prototype.slice.call(A));
}, pc = "diag", te = (
  /** @class */
  (function() {
    function t() {
      function A(o) {
        return function() {
          for (var r = [], n = 0; n < arguments.length; n++)
            r[n] = arguments[n];
          var s = Ke("diag");
          if (s)
            return s[o].apply(s, fc([], hc(r), !1));
        };
      }
      var e = this, i = function(o, r) {
        var n, s, a;
        if (r === void 0 && (r = { logLevel: UA.INFO }), o === e) {
          var g = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
          return e.error((n = g.stack) !== null && n !== void 0 ? n : g.message), !1;
        }
        typeof r == "number" && (r = {
          logLevel: r
        });
        var I = Ke("diag"), c = uc((s = r.logLevel) !== null && s !== void 0 ? s : UA.INFO, o);
        if (I && !r.suppressOverrideMessage) {
          var C = (a = new Error().stack) !== null && a !== void 0 ? a : "<failed to generate stacktrace>";
          I.warn("Current logger will be overwritten from " + C), c.warn("Current logger will overwrite one already registered from " + C);
        }
        return xt("diag", c, e, !0);
      };
      e.setLogger = i, e.disable = function() {
        Lt(pc, e);
      }, e.createComponentLogger = function(o) {
        return new dc(o);
      }, e.verbose = A("verbose"), e.debug = A("debug"), e.info = A("info"), e.warn = A("warn"), e.error = A("error");
    }
    return t.instance = function() {
      return this._instance || (this._instance = new t()), this._instance;
    }, t;
  })()
), wc = function(t, A) {
  var e = typeof Symbol == "function" && t[Symbol.iterator];
  if (!e) return t;
  var i = e.call(t), o, r = [], n;
  try {
    for (; (A === void 0 || A-- > 0) && !(o = i.next()).done; ) r.push(o.value);
  } catch (s) {
    n = { error: s };
  } finally {
    try {
      o && !o.done && (e = i.return) && e.call(i);
    } finally {
      if (n) throw n.error;
    }
  }
  return r;
}, yc = function(t) {
  var A = typeof Symbol == "function" && Symbol.iterator, e = A && t[A], i = 0;
  if (e) return e.call(t);
  if (t && typeof t.length == "number") return {
    next: function() {
      return t && i >= t.length && (t = void 0), { value: t && t[i++], done: !t };
    }
  };
  throw new TypeError(A ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, Dc = (
  /** @class */
  (function() {
    function t(A) {
      this._entries = A ? new Map(A) : /* @__PURE__ */ new Map();
    }
    return t.prototype.getEntry = function(A) {
      var e = this._entries.get(A);
      if (e)
        return Object.assign({}, e);
    }, t.prototype.getAllEntries = function() {
      return Array.from(this._entries.entries()).map(function(A) {
        var e = wc(A, 2), i = e[0], o = e[1];
        return [i, o];
      });
    }, t.prototype.setEntry = function(A, e) {
      var i = new t(this._entries);
      return i._entries.set(A, e), i;
    }, t.prototype.removeEntry = function(A) {
      var e = new t(this._entries);
      return e._entries.delete(A), e;
    }, t.prototype.removeEntries = function() {
      for (var A, e, i = [], o = 0; o < arguments.length; o++)
        i[o] = arguments[o];
      var r = new t(this._entries);
      try {
        for (var n = yc(i), s = n.next(); !s.done; s = n.next()) {
          var a = s.value;
          r._entries.delete(a);
        }
      } catch (g) {
        A = { error: g };
      } finally {
        try {
          s && !s.done && (e = n.return) && e.call(n);
        } finally {
          if (A) throw A.error;
        }
      }
      return r;
    }, t.prototype.clear = function() {
      return new t();
    }, t;
  })()
);
te.instance();
function mc(t) {
  return t === void 0 && (t = {}), new Dc(new Map(Object.entries(t)));
}
function gg(t) {
  return Symbol.for(t);
}
var Sc = (
  /** @class */
  /* @__PURE__ */ (function() {
    function t(A) {
      var e = this;
      e._currentContext = A ? new Map(A) : /* @__PURE__ */ new Map(), e.getValue = function(i) {
        return e._currentContext.get(i);
      }, e.setValue = function(i, o) {
        var r = new t(e._currentContext);
        return r._currentContext.set(i, o), r;
      }, e.deleteValue = function(i) {
        var o = new t(e._currentContext);
        return o._currentContext.delete(i), o;
      };
    }
    return t;
  })()
), kc = new Sc(), Ue = /* @__PURE__ */ (function() {
  var t = function(A, e) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, o) {
      i.__proto__ = o;
    } || function(i, o) {
      for (var r in o) Object.prototype.hasOwnProperty.call(o, r) && (i[r] = o[r]);
    }, t(A, e);
  };
  return function(A, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
    t(A, e);
    function i() {
      this.constructor = A;
    }
    A.prototype = e === null ? Object.create(e) : (i.prototype = e.prototype, new i());
  };
})(), Nc = (
  /** @class */
  (function() {
    function t() {
    }
    return t.prototype.createGauge = function(A, e) {
      return Jc;
    }, t.prototype.createHistogram = function(A, e) {
      return Hc;
    }, t.prototype.createCounter = function(A, e) {
      return Uc;
    }, t.prototype.createUpDownCounter = function(A, e) {
      return qc;
    }, t.prototype.createObservableGauge = function(A, e) {
      return Lc;
    }, t.prototype.createObservableCounter = function(A, e) {
      return xc;
    }, t.prototype.createObservableUpDownCounter = function(A, e) {
      return Tc;
    }, t.prototype.addBatchObservableCallback = function(A, e) {
    }, t.prototype.removeBatchObservableCallback = function(A) {
    }, t;
  })()
), Qo = (
  /** @class */
  /* @__PURE__ */ (function() {
    function t() {
    }
    return t;
  })()
), Mc = (
  /** @class */
  (function(t) {
    Ue(A, t);
    function A() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return A.prototype.add = function(e, i) {
    }, A;
  })(Qo)
), Gc = (
  /** @class */
  (function(t) {
    Ue(A, t);
    function A() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return A.prototype.add = function(e, i) {
    }, A;
  })(Qo)
), Fc = (
  /** @class */
  (function(t) {
    Ue(A, t);
    function A() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return A.prototype.record = function(e, i) {
    }, A;
  })(Qo)
), bc = (
  /** @class */
  (function(t) {
    Ue(A, t);
    function A() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return A.prototype.record = function(e, i) {
    }, A;
  })(Qo)
), zr = (
  /** @class */
  (function() {
    function t() {
    }
    return t.prototype.addCallback = function(A) {
    }, t.prototype.removeCallback = function(A) {
    }, t;
  })()
), Rc = (
  /** @class */
  (function(t) {
    Ue(A, t);
    function A() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return A;
  })(zr)
), Kc = (
  /** @class */
  (function(t) {
    Ue(A, t);
    function A() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return A;
  })(zr)
), vc = (
  /** @class */
  (function(t) {
    Ue(A, t);
    function A() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return A;
  })(zr)
), Yc = new Nc(), Uc = new Mc(), Jc = new Fc(), Hc = new bc(), qc = new Gc(), xc = new Rc(), Lc = new Kc(), Tc = new vc(), WA;
(function(t) {
  t[t.INT = 0] = "INT", t[t.DOUBLE = 1] = "DOUBLE";
})(WA || (WA = {}));
var Oc = {
  get: function(t, A) {
    if (t != null)
      return t[A];
  },
  keys: function(t) {
    return t == null ? [] : Object.keys(t);
  }
}, Pc = {
  set: function(t, A, e) {
    t != null && (t[A] = e);
  }
}, jc = function(t, A) {
  var e = typeof Symbol == "function" && t[Symbol.iterator];
  if (!e) return t;
  var i = e.call(t), o, r = [], n;
  try {
    for (; (A === void 0 || A-- > 0) && !(o = i.next()).done; ) r.push(o.value);
  } catch (s) {
    n = { error: s };
  } finally {
    try {
      o && !o.done && (e = i.return) && e.call(i);
    } finally {
      if (n) throw n.error;
    }
  }
  return r;
}, Vc = function(t, A, e) {
  if (e || arguments.length === 2) for (var i = 0, o = A.length, r; i < o; i++)
    (r || !(i in A)) && (r || (r = Array.prototype.slice.call(A, 0, i)), r[i] = A[i]);
  return t.concat(r || Array.prototype.slice.call(A));
}, $c = (
  /** @class */
  (function() {
    function t() {
    }
    return t.prototype.active = function() {
      return kc;
    }, t.prototype.with = function(A, e, i) {
      for (var o = [], r = 3; r < arguments.length; r++)
        o[r - 3] = arguments[r];
      return e.call.apply(e, Vc([i], jc(o), !1));
    }, t.prototype.bind = function(A, e) {
      return e;
    }, t.prototype.enable = function() {
      return this;
    }, t.prototype.disable = function() {
      return this;
    }, t;
  })()
), Wc = function(t, A) {
  var e = typeof Symbol == "function" && t[Symbol.iterator];
  if (!e) return t;
  var i = e.call(t), o, r = [], n;
  try {
    for (; (A === void 0 || A-- > 0) && !(o = i.next()).done; ) r.push(o.value);
  } catch (s) {
    n = { error: s };
  } finally {
    try {
      o && !o.done && (e = i.return) && e.call(i);
    } finally {
      if (n) throw n.error;
    }
  }
  return r;
}, zc = function(t, A, e) {
  if (arguments.length === 2) for (var i = 0, o = A.length, r; i < o; i++)
    (r || !(i in A)) && (r || (r = Array.prototype.slice.call(A, 0, i)), r[i] = A[i]);
  return t.concat(r || Array.prototype.slice.call(A));
}, Ho = "context", _c = new $c(), Eo = (
  /** @class */
  (function() {
    function t() {
    }
    return t.getInstance = function() {
      return this._instance || (this._instance = new t()), this._instance;
    }, t.prototype.setGlobalContextManager = function(A) {
      return xt(Ho, A, te.instance());
    }, t.prototype.active = function() {
      return this._getContextManager().active();
    }, t.prototype.with = function(A, e, i) {
      for (var o, r = [], n = 3; n < arguments.length; n++)
        r[n - 3] = arguments[n];
      return (o = this._getContextManager()).with.apply(o, zc([A, e, i], Wc(r), !1));
    }, t.prototype.bind = function(A, e) {
      return this._getContextManager().bind(A, e);
    }, t.prototype._getContextManager = function() {
      return Ke(Ho) || _c;
    }, t.prototype.disable = function() {
      this._getContextManager().disable(), Lt(Ho, te.instance());
    }, t;
  })()
), dr;
(function(t) {
  t[t.NONE = 0] = "NONE", t[t.SAMPLED = 1] = "SAMPLED";
})(dr || (dr = {}));
var Ig = "0000000000000000", cg = "00000000000000000000000000000000", Zc = {
  traceId: cg,
  spanId: Ig,
  traceFlags: dr.NONE
}, Nt = (
  /** @class */
  (function() {
    function t(A) {
      A === void 0 && (A = Zc), this._spanContext = A;
    }
    return t.prototype.spanContext = function() {
      return this._spanContext;
    }, t.prototype.setAttribute = function(A, e) {
      return this;
    }, t.prototype.setAttributes = function(A) {
      return this;
    }, t.prototype.addEvent = function(A, e) {
      return this;
    }, t.prototype.addLink = function(A) {
      return this;
    }, t.prototype.addLinks = function(A) {
      return this;
    }, t.prototype.setStatus = function(A) {
      return this;
    }, t.prototype.updateName = function(A) {
      return this;
    }, t.prototype.end = function(A) {
    }, t.prototype.isRecording = function() {
      return !1;
    }, t.prototype.recordException = function(A, e) {
    }, t;
  })()
), _r = gg("OpenTelemetry Context Key SPAN");
function Zr(t) {
  return t.getValue(_r) || void 0;
}
function Xc() {
  return Zr(Eo.getInstance().active());
}
function Xr(t, A) {
  return t.setValue(_r, A);
}
function AC(t) {
  return t.deleteValue(_r);
}
function eC(t, A) {
  return Xr(t, new Nt(A));
}
function Cg(t) {
  var A;
  return (A = Zr(t)) === null || A === void 0 ? void 0 : A.spanContext();
}
var tC = /^([0-9a-f]{32})$/i, iC = /^[0-9a-f]{16}$/i;
function oC(t) {
  return tC.test(t) && t !== cg;
}
function rC(t) {
  return iC.test(t) && t !== Ig;
}
function Bg(t) {
  return oC(t.traceId) && rC(t.spanId);
}
function nC(t) {
  return new Nt(t);
}
var qo = Eo.getInstance(), Qg = (
  /** @class */
  (function() {
    function t() {
    }
    return t.prototype.startSpan = function(A, e, i) {
      i === void 0 && (i = qo.active());
      var o = !!e?.root;
      if (o)
        return new Nt();
      var r = i && Cg(i);
      return sC(r) && Bg(r) ? new Nt(r) : new Nt();
    }, t.prototype.startActiveSpan = function(A, e, i, o) {
      var r, n, s;
      if (!(arguments.length < 2)) {
        arguments.length === 2 ? s = e : arguments.length === 3 ? (r = e, s = i) : (r = e, n = i, s = o);
        var a = n ?? qo.active(), g = this.startSpan(A, r, a), I = Xr(a, g);
        return qo.with(I, s, void 0, g);
      }
    }, t;
  })()
);
function sC(t) {
  return typeof t == "object" && typeof t.spanId == "string" && typeof t.traceId == "string" && typeof t.traceFlags == "number";
}
var aC = new Qg(), gC = (
  /** @class */
  (function() {
    function t(A, e, i, o) {
      this._provider = A, this.name = e, this.version = i, this.options = o;
    }
    return t.prototype.startSpan = function(A, e, i) {
      return this._getTracer().startSpan(A, e, i);
    }, t.prototype.startActiveSpan = function(A, e, i, o) {
      var r = this._getTracer();
      return Reflect.apply(r.startActiveSpan, r, arguments);
    }, t.prototype._getTracer = function() {
      if (this._delegate)
        return this._delegate;
      var A = this._provider.getDelegateTracer(this.name, this.version, this.options);
      return A ? (this._delegate = A, this._delegate) : aC;
    }, t;
  })()
), IC = (
  /** @class */
  (function() {
    function t() {
    }
    return t.prototype.getTracer = function(A, e, i) {
      return new Qg();
    }, t;
  })()
), cC = new IC(), Xn = (
  /** @class */
  (function() {
    function t() {
    }
    return t.prototype.getTracer = function(A, e, i) {
      var o;
      return (o = this.getDelegateTracer(A, e, i)) !== null && o !== void 0 ? o : new gC(this, A, e, i);
    }, t.prototype.getDelegate = function() {
      var A;
      return (A = this._delegate) !== null && A !== void 0 ? A : cC;
    }, t.prototype.setDelegate = function(A) {
      this._delegate = A;
    }, t.prototype.getDelegateTracer = function(A, e, i) {
      var o;
      return (o = this._delegate) === null || o === void 0 ? void 0 : o.getTracer(A, e, i);
    }, t;
  })()
);
Eo.getInstance();
te.instance();
var CC = (
  /** @class */
  (function() {
    function t() {
    }
    return t.prototype.getMeter = function(A, e, i) {
      return Yc;
    }, t;
  })()
), BC = new CC(), xo = "metrics", QC = (
  /** @class */
  (function() {
    function t() {
    }
    return t.getInstance = function() {
      return this._instance || (this._instance = new t()), this._instance;
    }, t.prototype.setGlobalMeterProvider = function(A) {
      return xt(xo, A, te.instance());
    }, t.prototype.getMeterProvider = function() {
      return Ke(xo) || BC;
    }, t.prototype.getMeter = function(A, e, i) {
      return this.getMeterProvider().getMeter(A, e, i);
    }, t.prototype.disable = function() {
      Lt(xo, te.instance());
    }, t;
  })()
), ge = QC.getInstance(), EC = (
  /** @class */
  (function() {
    function t() {
    }
    return t.prototype.inject = function(A, e) {
    }, t.prototype.extract = function(A, e) {
      return A;
    }, t.prototype.fields = function() {
      return [];
    }, t;
  })()
), An = gg("OpenTelemetry Baggage Key");
function Eg(t) {
  return t.getValue(An) || void 0;
}
function lC() {
  return Eg(Eo.getInstance().active());
}
function dC(t, A) {
  return t.setValue(An, A);
}
function uC(t) {
  return t.deleteValue(An);
}
var Lo = "propagation", hC = new EC(), fC = (
  /** @class */
  (function() {
    function t() {
      this.createBaggage = mc, this.getBaggage = Eg, this.getActiveBaggage = lC, this.setBaggage = dC, this.deleteBaggage = uC;
    }
    return t.getInstance = function() {
      return this._instance || (this._instance = new t()), this._instance;
    }, t.prototype.setGlobalPropagator = function(A) {
      return xt(Lo, A, te.instance());
    }, t.prototype.inject = function(A, e, i) {
      return i === void 0 && (i = Pc), this._getGlobalPropagator().inject(A, e, i);
    }, t.prototype.extract = function(A, e, i) {
      return i === void 0 && (i = Oc), this._getGlobalPropagator().extract(A, e, i);
    }, t.prototype.fields = function() {
      return this._getGlobalPropagator().fields();
    }, t.prototype.disable = function() {
      Lt(Lo, te.instance());
    }, t.prototype._getGlobalPropagator = function() {
      return Ke(Lo) || hC;
    }, t;
  })()
);
fC.getInstance();
var To = "trace", pC = (
  /** @class */
  (function() {
    function t() {
      this._proxyTracerProvider = new Xn(), this.wrapSpanContext = nC, this.isSpanContextValid = Bg, this.deleteSpan = AC, this.getSpan = Zr, this.getActiveSpan = Xc, this.getSpanContext = Cg, this.setSpan = Xr, this.setSpanContext = eC;
    }
    return t.getInstance = function() {
      return this._instance || (this._instance = new t()), this._instance;
    }, t.prototype.setGlobalTracerProvider = function(A) {
      var e = xt(To, this._proxyTracerProvider, te.instance());
      return e && this._proxyTracerProvider.setDelegate(A), e;
    }, t.prototype.getTracerProvider = function() {
      return Ke(To) || this._proxyTracerProvider;
    }, t.prototype.getTracer = function(A, e) {
      return this.getTracerProvider().getTracer(A, e);
    }, t.prototype.disable = function() {
      Lt(To, te.instance()), this._proxyTracerProvider = new Xn();
    }, t;
  })()
);
pC.getInstance();
class wC {
  constructor(A) {
    this.totalValidTransactions = 0, this.version = 0, this.id = A.id, this.core = A;
  }
  get type() {
    return this.core.verified.header.type;
  }
  get headerMeta() {
    return this.core.verified.header.meta;
  }
  /** @category 6. Meta */
  get group() {
    return this.core.getGroup();
  }
  toJSON() {
    return {};
  }
  atTime() {
    return this;
  }
  subscribe(A) {
    return this.core.subscribe((e) => {
      A(e.getCurrentContent());
    });
  }
  processNewTransactions() {
  }
  rebuildFromCore() {
  }
}
function yC(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function lg(t, A) {
  return Array.isArray(A) ? A.length === 0 ? !0 : t ? A.every((e) => typeof e == "string") : A.every((e) => Number.isSafeInteger(e)) : !1;
}
function ur(t, A) {
  if (typeof A != "string")
    throw new Error(`${t}: string expected`);
  return !0;
}
function dg(t) {
  if (!Number.isSafeInteger(t))
    throw new Error(`invalid integer: ${t}`);
}
function hr(t) {
  if (!Array.isArray(t))
    throw new Error("array expected");
}
function ug(t, A) {
  if (!lg(!0, A))
    throw new Error(`${t}: array of strings expected`);
}
function DC(t, A) {
  if (!lg(!1, A))
    throw new Error(`${t}: array of numbers expected`);
}
// @__NO_SIDE_EFFECTS__
function mC(...t) {
  const A = (r) => r, e = (r, n) => (s) => r(n(s)), i = t.map((r) => r.encode).reduceRight(e, A), o = t.map((r) => r.decode).reduce(e, A);
  return { encode: i, decode: o };
}
// @__NO_SIDE_EFFECTS__
function SC(t) {
  const A = typeof t == "string" ? t.split("") : t, e = A.length;
  ug("alphabet", A);
  const i = new Map(A.map((o, r) => [o, r]));
  return {
    encode: (o) => (hr(o), o.map((r) => {
      if (!Number.isSafeInteger(r) || r < 0 || r >= e)
        throw new Error(`alphabet.encode: digit index outside alphabet "${r}". Allowed: ${t}`);
      return A[r];
    })),
    decode: (o) => (hr(o), o.map((r) => {
      ur("alphabet.decode", r);
      const n = i.get(r);
      if (n === void 0)
        throw new Error(`Unknown letter: "${r}". Allowed: ${t}`);
      return n;
    }))
  };
}
// @__NO_SIDE_EFFECTS__
function kC(t = "") {
  return ur("join", t), {
    encode: (A) => (ug("join.decode", A), A.join(t)),
    decode: (A) => (ur("join.decode", A), A.split(t))
  };
}
function As(t, A, e) {
  if (A < 2)
    throw new Error(`convertRadix: invalid from=${A}, base cannot be less than 2`);
  if (e < 2)
    throw new Error(`convertRadix: invalid to=${e}, base cannot be less than 2`);
  if (hr(t), !t.length)
    return [];
  let i = 0;
  const o = [], r = Array.from(t, (s) => {
    if (dg(s), s < 0 || s >= A)
      throw new Error(`invalid integer: ${s}`);
    return s;
  }), n = r.length;
  for (; ; ) {
    let s = 0, a = !0;
    for (let g = i; g < n; g++) {
      const I = r[g], c = A * s, C = c + I;
      if (!Number.isSafeInteger(C) || c / A !== s || C - I !== c)
        throw new Error("convertRadix: carry overflow");
      const B = C / e;
      s = C % e;
      const Q = Math.floor(B);
      if (r[g] = Q, !Number.isSafeInteger(Q) || Q * e + s !== C)
        throw new Error("convertRadix: carry overflow");
      if (a)
        Q ? a = !1 : i = g;
      else continue;
    }
    if (o.push(s), a)
      break;
  }
  for (let s = 0; s < t.length - 1 && t[s] === 0; s++)
    o.push(0);
  return o.reverse();
}
// @__NO_SIDE_EFFECTS__
function NC(t) {
  dg(t);
  const A = 2 ** 8;
  return {
    encode: (e) => {
      if (!yC(e))
        throw new Error("radix.encode input should be Uint8Array");
      return As(Array.from(e), A, t);
    },
    decode: (e) => (DC("radix.decode", e), Uint8Array.from(As(e, t, A)))
  };
}
const MC = /* @__NO_SIDE_EFFECTS__ */ (t) => /* @__PURE__ */ mC(/* @__PURE__ */ NC(58), /* @__PURE__ */ SC(t), /* @__PURE__ */ kC("")), YA = /* @__PURE__ */ MC("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
function LA(t) {
  const A = [];
  let e = t;
  if (e && e.toJSON && typeof e.toJSON == "function" && (e = e.toJSON()), e === void 0)
    return;
  if (typeof e == "number")
    return isFinite(e) ? "" + e : "null";
  if (typeof e != "object")
    return typeof e == "string" && (e.startsWith("encrypted_U") || e.startsWith("binary_U")) ? `"${e}"` : JSON.stringify(e);
  let i, o;
  if (Array.isArray(e)) {
    for (o = "[", i = 0; i < e.length; i++)
      i && (o += ","), o += LA(e[i]) || "null";
    return o + "]";
  }
  if (e === null)
    return "null";
  if (A.indexOf(e) !== -1)
    throw new TypeError("Converting circular structure to JSON");
  const r = A.push(e) - 1, n = Object.keys(e).sort();
  for (o = "", i = 0; i < n.length; i++) {
    const s = n[i], a = LA(e[s]);
    a && (o && (o += ","), o += JSON.stringify(s) + ":" + a);
  }
  return A.splice(r, 1), "{" + o + "}";
}
function so(t) {
  return JSON.parse(t);
}
function fr(t) {
  try {
    return JSON.parse(t);
  } catch {
    return;
  }
}
const Bt = {
  DEBUG: 0,
  INFO: 1,
  WARN: 2,
  ERROR: 3
};
class GC {
  debug(A, e) {
    console.debug(A, e);
  }
  info(A, e) {
    console.info(A, e);
  }
  warn(A, e) {
    console.warn(A, e);
  }
  error(A, e) {
    console.error(A, e);
  }
}
class FC {
  constructor(A = Bt.INFO, e = new GC()) {
    this.level = A, this.logSystem = e;
  }
  setLevel(A) {
    this.level = A;
  }
  setLogSystem(A) {
    this.logSystem = A;
  }
  debug(A, e) {
    this.level <= Bt.DEBUG && this.logSystem.debug(A, e);
  }
  info(A, e) {
    this.level <= Bt.INFO && this.logSystem.info(A, e);
  }
  warn(A, e) {
    this.level <= Bt.WARN && this.logSystem.warn(A, e);
  }
  error(A, e) {
    this.level <= Bt.ERROR && this.logSystem.error(A, e);
  }
}
const AA = new FC();
function bC(t = 32) {
  return crypto.getRandomValues(new Uint8Array(t));
}
const SA = new TextEncoder(), es = new TextDecoder();
class RC {
  constructor() {
    this.agentIdCache = /* @__PURE__ */ new Map();
  }
  randomBytes(A) {
    return bC(A);
  }
  newRandomSigner() {
    return `signerSecret_z${YA.encode(this.newEd25519SigningKey())}`;
  }
  newRandomSealer() {
    return `sealerSecret_z${YA.encode(this.newX25519StaticSecret())}`;
  }
  newRandomAgentSecret() {
    return `${this.newRandomSealer()}/${this.newRandomSigner()}`;
  }
  getAgentID(A) {
    const e = A;
    let i = this.agentIdCache.get(e);
    if (!i) {
      const [o, r] = A.split("/");
      i = `${this.getSealerID(o)}/${this.getSignerID(r)}`, this.agentIdCache.set(e, i);
    }
    return i;
  }
  getAgentSignerID(A) {
    return A.split("/")[1];
  }
  getAgentSignerSecret(A) {
    return A.split("/")[1];
  }
  getAgentSealerID(A) {
    return A.split("/")[0];
  }
  getAgentSealerSecret(A) {
    return A.split("/")[0];
  }
  secureHash(A) {
    return `hash_z${YA.encode(this.blake3HashOnce(SA.encode(LA(A))))}`;
  }
  shortHash(A) {
    return `shortHash_z${YA.encode(this.blake3HashOnce(SA.encode(LA(A))).slice(0, KC))}`;
  }
  decrypt(A, e, i) {
    try {
      return so(this.decryptRaw(A, e, i));
    } catch (o) {
      AA.error("Decryption error", { err: o });
      return;
    }
  }
  newRandomKeySecret() {
    return {
      secret: `keySecret_z${YA.encode(this.randomBytes(32))}`,
      id: `key_z${YA.encode(this.randomBytes(12))}`
    };
  }
  encryptKeySecret(A) {
    const e = {
      encryptedID: A.toEncrypt.id,
      encryptingID: A.encrypting.id
    };
    return {
      encryptedID: A.toEncrypt.id,
      encryptingID: A.encrypting.id,
      encrypted: this.encrypt(A.toEncrypt.secret, A.encrypting.secret, e)
    };
  }
  decryptKeySecret(A, e) {
    const i = {
      encryptedID: A.encryptedID,
      encryptingID: A.encryptingID
    };
    return this.decrypt(A.encrypted, e, i);
  }
  uniquenessForHeader() {
    return `z${YA.encode(this.randomBytes(12))}`;
  }
  createdNowUnique() {
    return {
      createdAt: (/* @__PURE__ */ new Date()).toISOString(),
      uniqueness: this.uniquenessForHeader()
    };
  }
  newRandomSecretSeed() {
    return this.randomBytes(Oo);
  }
  agentSecretFromSecretSeed(A) {
    if (A.length !== Oo)
      throw new Error(`Secret seed needs to be ${Oo} bytes long`);
    return `sealerSecret_z${YA.encode(this.blake3HashOnceWithContext(A, {
      context: SA.encode("seal")
    }))}/signerSecret_z${YA.encode(this.blake3HashOnceWithContext(A, {
      context: SA.encode("sign")
    }))}`;
  }
  newRandomSessionID(A) {
    const e = YA.encode(this.randomBytes(8));
    return `${A}_session_z${e}`;
  }
  newDeleteSessionID(A) {
    const e = YA.encode(this.randomBytes(7));
    return `${A}_session_d${e}$`;
  }
}
const KC = 19, Oo = 32;
function hg(t) {
  return typeof t == "string" && t.startsWith("co_z");
}
function Xe(t) {
  return typeof t == "string" && t.startsWith("sealer_") && t.includes("/signer_");
}
const vC = 36;
function ve(t) {
  return t.charCodeAt(t.length - 1) === vC;
}
function fg(t) {
  return t.startsWith("parent_");
}
function pg(t) {
  return t.slice(7);
}
function YC(t) {
  if (typeof t == "string") {
    if (fg(t))
      return pg(t);
    if (t.startsWith("co_"))
      return t;
  }
}
function OA(t) {
  const A = t.indexOf("_session");
  return t.slice(0, A);
}
class Tt {
  resetInternalState() {
    this.afterStart = [], this.beforeEnd = [], this.insertions = {}, this.deletionsByInsertion = {}, this._cachedEntries = void 0, this.knownTransactions = { [this.core.id]: 0 }, this.lastValidTransaction = void 0, this.totalValidTransactions = 0;
  }
  /** @internal */
  constructor(A, e) {
    this.type = "colist", this.afterStart = [], this.beforeEnd = [], this.insertions = {}, this.deletionsByInsertion = {}, this.atTimeFilter = void 0, this.knownTransactions = {}, this.version = 0, this.totalValidTransactions = 0, this.id = A.id, this.core = A, this.insertions = {}, this.deletionsByInsertion = {}, this.afterStart = [], this.beforeEnd = [], this.knownTransactions = { [A.id]: 0 }, this.atTimeFilter = e, this._processNewTransactions();
  }
  getInsertionsEntry(A) {
    const e = Zt(A), i = this.insertions[e];
    if (!i)
      return;
    const o = i[A.txIndex];
    if (o)
      return o[A.changeIdx];
  }
  createInsertionsEntry(A, e) {
    const i = Zt(A);
    let o = this.insertions[i];
    o || (o = {}, this.insertions[i] = o);
    let r = o[A.txIndex];
    return r || (r = {}, o[A.txIndex] = r), r[A.changeIdx] ? !1 : (r[A.changeIdx] = e, !0);
  }
  isDeleted(A) {
    const e = Zt(A), i = this.deletionsByInsertion[e];
    if (!i)
      return !1;
    const o = i[A.txIndex];
    return o ? !!o[A.changeIdx]?.length : !1;
  }
  pushDeletionsByInsertionEntry(A, e) {
    const i = Zt(A);
    let o = this.deletionsByInsertion[i];
    o || (o = {}, this.deletionsByInsertion[i] = o);
    let r = o[A.txIndex];
    r || (r = {}, o[A.txIndex] = r);
    let n = r[A.changeIdx];
    n || (n = [], r[A.changeIdx] = n), n.push(e);
  }
  processNewTransactions() {
    if (this.isTimeTravelEntity())
      throw new Error("Cannot process transactions on a time travel entity");
    this._processNewTransactions();
  }
  _processNewTransactions() {
    const A = this.core.getValidSortedTransactions({
      ignorePrivateTransactions: !1,
      knownTransactions: this.knownTransactions
    });
    if (A.length === 0)
      return;
    let e, i;
    this._cachedEntries = void 0;
    for (const { txID: o, changes: r, madeAt: n } of A)
      if (!this.isFilteredOut(n)) {
        e = Math.max(e ?? 0, n), i = Math.min(i ?? 1 / 0, n);
        for (const [s, a] of r.entries()) {
          const g = a, I = {
            sessionID: o.sessionID,
            txIndex: o.txIndex,
            branch: o.branch,
            changeIdx: s
          };
          if (g.op === "pre" || g.op === "app") {
            if (!this.createInsertionsEntry(I, {
              madeAt: n,
              predecessors: [],
              successors: [],
              change: g
            }))
              continue;
            if (g.op === "pre")
              if (g.before === "end")
                this.beforeEnd.push(I);
              else {
                const C = this.getInsertionsEntry(g.before);
                if (!C)
                  continue;
                C.predecessors.push(I);
              }
            else if (g.after === "start")
              this.afterStart.push(I);
            else {
              const C = this.getInsertionsEntry(g.after);
              if (!C)
                continue;
              C.successors.push(I);
            }
          } else if (g.op === "del")
            this.pushDeletionsByInsertionEntry(g.insertion, {
              madeAt: n,
              deletionID: I,
              change: g
            });
          else
            throw new Error("Unknown list operation " + g.op);
        }
      }
    this.lastValidTransaction && i && i < this.lastValidTransaction ? this.rebuildFromCore() : this.lastValidTransaction = e, this.totalValidTransactions += A.length;
  }
  rebuildFromCore() {
    this.version += 1, this.resetInternalState(), this.processNewTransactions();
  }
  isTimeTravelEntity() {
    return !!this.atTimeFilter;
  }
  isFilteredOut(A) {
    return this.atTimeFilter === void 0 ? !1 : A > this.atTimeFilter;
  }
  /** @category 6. Meta */
  get headerMeta() {
    return this.core.verified.header.meta;
  }
  /** @category 6. Meta */
  get group() {
    return this.core.getGroup();
  }
  /**
   * Not yet implemented
   *
   * @category 4. Time travel
   */
  atTime(A) {
    return new Tt(this.core, A);
  }
  /**
   * Get the item currently at `idx`.
   *
   * @category 1. Reading
   */
  get(A) {
    const e = this.entries()[A];
    if (e)
      return e.value;
  }
  /**
   * Returns the current items in the CoList as an array.
   *
   * @category 1. Reading
   **/
  asArray() {
    return this.entries().map((A) => A.value);
  }
  /** @internal */
  entries() {
    if (this._cachedEntries)
      return this._cachedEntries;
    const A = this.entriesUncached();
    return this._cachedEntries = A, A;
  }
  length() {
    return this.entries().length;
  }
  /** @internal */
  entriesUncached() {
    const A = [];
    for (const e of this.afterStart)
      this.fillArrayFromOpID(e, A);
    for (const e of this.beforeEnd)
      this.fillArrayFromOpID(e, A);
    return A;
  }
  /** @internal */
  fillArrayFromOpID(A, e) {
    const i = [A], o = /* @__PURE__ */ new Set();
    for (; i.length > 0; ) {
      const r = i[i.length - 1], n = this.getInsertionsEntry(r);
      if (!n)
        throw new Error("Missing op " + r);
      if (n.predecessors.length > 0 && !o.has(r)) {
        for (const a of n.predecessors)
          i.push(a);
        o.add(r);
      } else {
        i.pop(), this.isDeleted(r) || e.push({
          value: n.change.value,
          madeAt: n.madeAt,
          opID: r
        });
        for (const g of n.successors)
          i.push(g);
      }
    }
  }
  /**
   * Returns the current items in the CoList as an array. (alias of `asArray`)
   *
   * @category 1. Reading
   */
  toJSON() {
    return this.asArray();
  }
  /** @category 5. Edit history */
  editAt(A) {
    const e = this.entries()[A];
    if (!e)
      return;
    const i = new Date(e.madeAt), o = OA(e.opID.sessionID), r = e.value;
    return {
      by: o,
      tx: {
        sessionID: e.opID.sessionID,
        txIndex: e.opID.txIndex
      },
      at: i,
      value: r
    };
  }
  /** @category 5. Edit history */
  deletionEdits() {
    const A = [];
    for (const e in this.deletionsByInsertion) {
      const i = this.deletionsByInsertion[e];
      for (const o in i) {
        const r = i[Number(o)];
        for (const n in r) {
          const s = r[Number(n)];
          for (const a of s || []) {
            const g = new Date(a.madeAt), I = OA(a.deletionID.sessionID);
            A.push({
              by: I,
              tx: a.deletionID,
              at: g
            });
          }
        }
      }
    }
    return A;
  }
  /** @category 3. Subscription */
  subscribe(A) {
    return this.core.subscribe((e) => {
      A(e.getCurrentContent());
    });
  }
  /** Appends `item` after the item currently at index `after`.
   *
   * If `privacy` is `"private"` **(default)**, `item` is encrypted in the transaction, only readable by other members of the group this `CoList` belongs to. Not even sync servers can see the content in plaintext.
   *
   * If `privacy` is `"trusting"`, `item` is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
   *
   * @category 2. Editing
   **/
  append(A, e, i = "private") {
    this.appendItems([A], e, i);
  }
  /**
   * Appends `items` to the list at index `after`. If `after` is negative, it is treated as `0`.
   *
   * If `privacy` is `"private"` **(default)**, `items` are encrypted in the transaction, only readable by other members of the group this `CoList` belongs to. Not even sync servers can see the content in plaintext.
   *
   * If `privacy` is `"trusting"`, `items` are stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
   *
   * @category 2. Editing
   */
  appendItems(A, e, i = "private") {
    const o = this.entries();
    e = e === void 0 ? o.length > 0 ? o.length - 1 : 0 : Math.max(0, e);
    let r;
    if (o.length > 0) {
      const s = o[e];
      if (!s)
        throw new Error("Invalid index " + e);
      r = s.opID;
    } else {
      if (e !== 0)
        throw new Error("Invalid index " + e);
      r = "start";
    }
    const n = A.map((s) => ({
      op: "app",
      value: et(s) ? s.id : s,
      after: r
    }));
    r !== "start" && n.reverse(), this.core.makeTransaction(n, i), this.processNewTransactions();
  }
  /**
   * Prepends `item` before the item currently at index `before`.
   *
   * If `privacy` is `"private"` **(default)**, `item` is encrypted in the transaction, only readable by other members of the group this `CoList` belongs to. Not even sync servers can see the content in plaintext.
   *
   * If `privacy` is `"trusting"`, `item` is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
   *
   * @category 2. Editing
   */
  prepend(A, e, i = "private") {
    const o = this.entries();
    e = e === void 0 ? 0 : e;
    let r;
    if (o.length > 0) {
      const n = o[e];
      if (n)
        r = n.opID;
      else {
        if (e !== o.length)
          throw new Error("Invalid index " + e);
        r = "end";
      }
    } else {
      if (e !== 0)
        throw new Error("Invalid index " + e);
      r = "end";
    }
    this.core.makeTransaction([
      {
        op: "pre",
        value: et(A) ? A.id : A,
        before: r
      }
    ], i), this.processNewTransactions();
  }
  /** Deletes the item at index `at`.
   *
   * If `privacy` is `"private"` **(default)**, the fact of this deletion is encrypted in the transaction, only readable by other members of the group this `CoList` belongs to. Not even sync servers can see the content in plaintext.
   *
   * If `privacy` is `"trusting"`, the fact of this deletion is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
   *
   * @category 2. Editing
   **/
  delete(A, e = "private") {
    const o = this.entries()[A];
    if (!o)
      throw new Error("Invalid index " + A);
    this.core.makeTransaction([
      {
        op: "del",
        insertion: o.opID
      }
    ], e), this.processNewTransactions();
  }
  replace(A, e, i = "private") {
    const r = this.entries()[A];
    if (!r)
      throw new Error("Invalid index " + A);
    this.core.makeTransaction([
      {
        op: "app",
        value: et(e) ? e.id : e,
        after: r.opID
      },
      {
        op: "del",
        insertion: r.opID
      }
    ], i), this.processNewTransactions();
  }
}
function Zt(t) {
  return t.branch ? `${t.sessionID}_branch_${t.branch}` : t.sessionID;
}
function en(t) {
  return t.startsWith("co_");
}
class wg {
  resetInternalState() {
    this.items = {}, this.knownTransactions = { [this.core.id]: 0 }, this.totalValidTransactions = 0;
  }
  constructor(A) {
    this.type = "costream", this.totalValidTransactions = 0, this.version = 0, this.id = A.id, this.core = A, this.items = {}, this.knownTransactions = { [A.id]: 0 }, this.processNewTransactions();
  }
  rebuildFromCore() {
    this.version++, this.resetInternalState(), this.processNewTransactions();
  }
  get headerMeta() {
    return this.core.verified.header.meta;
  }
  get group() {
    return this.core.getGroup();
  }
  /** Not yet implemented */
  atTime(A) {
    throw new Error("Not yet implemented");
  }
  /** @internal */
  compareStreamItems(A, e) {
    return A.madeAt - e.madeAt || (A.tx.sessionID === e.tx.sessionID ? 0 : A.tx.sessionID < e.tx.sessionID ? -1 : 1) || A.tx.txIndex - e.tx.txIndex;
  }
  /** @internal */
  processNewTransactions() {
    const A = /* @__PURE__ */ new Set(), e = this.core.getValidTransactions({
      ignorePrivateTransactions: !1,
      knownTransactions: this.knownTransactions
    });
    if (e.length !== 0) {
      for (const { txID: i, madeAt: o, changes: r } of e)
        for (const n of r) {
          const s = n;
          let a = this.items[i.sessionID];
          a || (a = [], this.items[i.sessionID] = a), a.push({ value: s, madeAt: o, tx: i }), A.add(a);
        }
      for (const i of A)
        i.sort(this.compareStreamItems);
      this.totalValidTransactions += e.length;
    }
  }
  getSingleStream() {
    const A = Object.values(this.items), e = A[0];
    if (e) {
      if (A.length > 1)
        throw new Error("CoStream.getSingleStream() can only be called when there is exactly one stream");
      return e.map((i) => i.value);
    }
  }
  sessions() {
    return Object.keys(this.items);
  }
  accounts() {
    return new Set(this.sessions().map(OA).filter(en));
  }
  nthItemIn(A, e) {
    const i = this.items[A];
    if (!i)
      return;
    const o = i[e];
    if (o)
      return {
        by: OA(A),
        tx: o.tx,
        at: new Date(o.madeAt),
        value: o.value
      };
  }
  lastItemIn(A) {
    const e = this.items[A];
    if (e)
      return this.nthItemIn(A, e.length - 1);
  }
  *itemsIn(A) {
    const e = this.items[A];
    if (e)
      for (const i of e)
        yield {
          by: OA(A),
          tx: i.tx,
          at: new Date(i.madeAt),
          value: i.value
        };
  }
  lastItemBy(A) {
    let e;
    for (const i of Object.keys(this.items))
      if (i.startsWith(A)) {
        const o = this.lastItemIn(i);
        if (!o)
          continue;
        (!e || o.at > e.at) && (e = {
          by: o.by,
          tx: o.tx,
          at: o.at,
          value: o.value
        });
      }
    return e;
  }
  *itemsBy(A) {
    const e = [
      ...Object.keys(this.items).flatMap((i) => i.startsWith(A) ? [...this.itemsIn(i)].map((o) => ({
        in: i,
        ...o
      })) : [])
    ];
    e.sort((i, o) => i.at.getTime() - o.at.getTime());
    for (const i of e)
      yield i;
  }
  toJSON() {
    return Object.fromEntries(Object.entries(this.items).map(([A, e]) => [
      A,
      e.map((i) => i.value)
    ]));
  }
  subscribe(A) {
    return this.core.subscribe((e) => {
      A(e.getCurrentContent());
    });
  }
}
class yg extends wg {
  push(A, e = "private") {
    this.core.makeTransaction([et(A) ? A.id : A], e), this.processNewTransactions();
  }
}
const UC = 8;
class JC extends wg {
  isBinaryStreamEnded() {
    const A = this.getSingleStream();
    return !A || A.length === 0 ? !1 : A[A.length - 1]?.type === "end";
  }
  getBinaryStreamInfo() {
    const A = this.getSingleStream();
    if (!A)
      return;
    const e = A[0];
    if (e?.type !== "start") {
      AA.error("Invalid binary stream start", e);
      return;
    }
    return {
      mimeType: e.mimeType,
      fileName: e.fileName,
      totalSizeBytes: e.totalSizeBytes
    };
  }
  getBinaryChunks(A) {
    const e = this.getSingleStream();
    if (!e)
      return;
    const i = this.getBinaryStreamInfo();
    if (!i || e[e.length - 1]?.type !== "end" && !A)
      return;
    const r = [];
    let n = !1;
    for (const s of e.slice(1)) {
      if (s.type === "end") {
        n = !0;
        break;
      }
      if (s.type !== "chunk") {
        AA.error("Invalid binary stream chunk", s);
        return;
      }
      const a = Er(s.chunk.slice(UC));
      r.push(a);
    }
    return {
      ...i,
      chunks: r,
      finished: n
    };
  }
}
class Dg extends JC {
  /** @internal */
  push(A, e = "private", i = !0) {
    this.core.makeTransaction([A], e), i && this.processNewTransactions();
  }
  startBinaryStream(A, e = "private") {
    this.push({
      type: "start",
      ...A
    }, e, !1);
  }
  pushBinaryStreamChunk(A, e = "private") {
    this.push({
      type: "chunk",
      chunk: `binary_U${lr(A)}`
    }, e, !1);
  }
  endBinaryStream(A = "private") {
    this.push({
      type: "end"
    }, A, !0);
  }
}
function et(t) {
  return t instanceof tn || t instanceof Tt || t instanceof yg || t instanceof Dg;
}
class tn {
  /** @internal */
  get latestTxMadeAt() {
    return this.core.latestTxMadeAt;
  }
  /** @internal */
  get earliestTxMadeAt() {
    return this.core.earliestTxMadeAt;
  }
  resetInternalState() {
    this.ops = {}, this.latest = {}, this.knownTransactions = { [this.core.id]: 0 }, this.totalValidTransactions = 0;
  }
  /** @internal */
  constructor(A, e) {
    this.type = "comap", this.ops = {}, this.latest = {}, this.knownTransactions = {}, this.totalValidTransactions = 0, this.version = 0, this.atTimeFilter = void 0, this.id = A.id, this.core = A, this.ignorePrivateTransactions = e?.ignorePrivateTransactions ?? !1, this.processNewTransactions();
  }
  processNewTransactions() {
    if (this.isTimeTravelEntity())
      throw new Error("Cannot process transactions on a time travel entity");
    const A = this.core.getValidTransactions({
      ignorePrivateTransactions: this.ignorePrivateTransactions,
      knownTransactions: this.knownTransactions
    });
    if (A.length === 0)
      return;
    const { ops: e } = this, i = /* @__PURE__ */ new Map();
    for (const o of A) {
      const { txID: r, changes: n, madeAt: s, tx: a } = o;
      for (let g = 0; g < n.length; g++) {
        const I = n[g], c = {
          txID: r,
          madeAt: s,
          changeIdx: g,
          change: I,
          trusting: a.privacy === "trusting"
        }, C = e[I.key];
        if (C)
          C.push(c), i.set(I.key, C);
        else {
          const B = [c];
          e[I.key] = B, i.set(I.key, B);
        }
      }
      this.handleNewTransaction(o);
    }
    for (const o of i.values())
      o.sort(this.core.compareTransactions);
    for (const [o, r] of i.entries())
      this.latest[o] = r[r.length - 1];
    this.totalValidTransactions += A.length;
  }
  handleNewTransaction(A) {
  }
  rebuildFromCore() {
    this.version += 1, this.resetInternalState(), this.processNewTransactions();
  }
  isTimeTravelEntity() {
    return !!this.atTimeFilter;
  }
  /** @category 6. Meta */
  get headerMeta() {
    return this.core.verified.header.meta;
  }
  /** @category 6. Meta */
  get group() {
    return this.core.getGroup();
  }
  /** @category 4. Time travel */
  atTime(A) {
    const e = Object.create(this);
    return e.atTimeFilter = A, e.latest = {}, e;
  }
  /** @internal */
  timeFilteredOps(A) {
    if (A === "constructor")
      return;
    const e = this.atTimeFilter;
    return e ? this.ops[A]?.filter((i) => i.madeAt <= e) : this.ops[A];
  }
  /**
   * Get all keys currently in the map.
   *
   * @category 1. Reading */
  keys() {
    return Object.keys(this.ops).filter((A) => {
      const e = this.getRaw(A);
      return !(e === void 0 || e.change.op === "del");
    });
  }
  getRaw(A) {
    let e = this.latest[A];
    if (e === void 0) {
      const i = this.ops[A];
      if (i && !(A in this.latest)) {
        const o = this.atTimeFilter;
        o ? e = i.findLast((r) => r.madeAt <= o) : e = i[i.length - 1], this.latest[A] = e;
      }
      if (e === void 0)
        return;
    }
    return e;
  }
  /**
   * Returns the current value for the given key.
   *
   * @category 1. Reading
   **/
  get(A) {
    const e = this.getRaw(A);
    if (e?.change !== void 0 && e.change.op !== "del")
      return e.change.value;
  }
  /** @category 1. Reading */
  asObject() {
    const A = {};
    for (const e of Object.keys(this.ops)) {
      const i = this.get(e);
      i !== void 0 && (A[e] = i);
    }
    return A;
  }
  /** @category 1. Reading */
  toJSON() {
    return this.asObject();
  }
  /** @category 5. Edit history */
  nthEditAt(A, e) {
    const i = this.ops[A], o = this.atTimeFilter, r = i?.[e];
    if (r && !(o && r.madeAt > o))
      return Po(r);
  }
  /** @category 5. Edit history */
  lastEditAt(A) {
    const e = this.getRaw(A);
    if (e)
      return Po(e);
  }
  /** @category 5. Edit history */
  *editsAt(A) {
    const e = this.ops[A];
    if (!e)
      return;
    const i = this.atTimeFilter;
    for (const o of e) {
      if (i && o.madeAt > i)
        return;
      yield Po(o);
    }
  }
  /** @category 3. Subscription */
  subscribe(A) {
    return this.core.subscribe((e) => {
      A(e.getCurrentContent());
    });
  }
  /** Set a new value for the given key.
   *
   * If `privacy` is `"private"` **(default)**, both `key` and `value` are encrypted in the transaction, only readable by other members of the group this `CoMap` belongs to. Not even sync servers can see the content in plaintext.
   *
   * If `privacy` is `"trusting"`, both `key` and `value` are stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
   *
   * @category 2. Editing
   **/
  set(A, e, i = "private") {
    if (this.isTimeTravelEntity())
      throw new Error("Cannot set value on a time travel entity");
    this.core.makeTransaction([
      {
        op: "set",
        key: A,
        value: et(e) ? e.id : e
      }
    ], i), this.processNewTransactions();
  }
  assign(A, e = "private") {
    if (this.isTimeTravelEntity())
      throw new Error("Cannot set value on a time travel entity");
    this.core.makeTransaction(Object.entries(A).map(([i, o]) => ({
      op: "set",
      key: i,
      value: et(o) ? o.id : o
    })), e), this.processNewTransactions();
  }
  /** Delete the given key (setting it to undefined).
   *
   * If `privacy` is `"private"` **(default)**, `key` is encrypted in the transaction, only readable by other members of the group this `CoMap` belongs to. Not even sync servers can see the content in plaintext.
   *
   * If `privacy` is `"trusting"`, `key` is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
   *
   * @category 2. Editing
   **/
  delete(A, e = "private") {
    if (this.isTimeTravelEntity())
      throw new Error("Cannot delete value on a time travel entity");
    this.core.makeTransaction([
      {
        op: "del",
        key: A
      }
    ], e), this.processNewTransactions();
  }
}
function Po(t) {
  return {
    by: OA(t.txID.sessionID),
    tx: t.txID,
    at: new Date(t.madeAt),
    value: t.change.op === "del" ? void 0 : t.change.value
  };
}
function bA(t) {
  if (t.type !== "comap")
    throw new Error("Expected group");
  if (t.core.verified.header.ruleset.type !== "group")
    throw new Error("Expected group ruleset in group");
  if (!(t instanceof on))
    throw new Error("Expected group");
  return t;
}
function ts(t) {
  return t === "manager" || t === "admin" || t === "writer" || t === "reader" || t === "writeOnly";
}
function Qt(t) {
  return t === "admin" || t === "manager";
}
function HC(t) {
  if (!t.isAvailable())
    throw new Error("determineValidTransactions CoValue is not available");
  if (t.verified.header.ruleset.type === "group") {
    const A = t.verified.header.ruleset.initialAdmin;
    if (!A)
      throw new Error("Group must have initialAdmin");
    LC(t, A);
    return;
  }
  if (t.verified.header.ruleset.type === "ownedByGroup") {
    const A = bA(t.node.expectCoValueLoaded(t.verified.header.ruleset.group, "Determining valid transaction in owned object but its group wasn't loaded").getCurrentContent());
    if (A.type !== "comap")
      throw new Error("Group must be a map");
    for (const e of t.toValidateTransactions) {
      const i = A.atTime(e.currentMadeAt), o = TC(e.author, i);
      if (!o) {
        e.markInvalid("Transactor not found in group", {
          transactor: e.author,
          group: i.toJSON()
        });
        continue;
      }
      const r = i.roleOfInternal(o);
      if (r === "reader" && e.meta?.branch && e.meta?.ownerId) {
        e.meta = {
          branch: e.meta.branch,
          ownerId: e.meta.ownerId
        }, e.changes = [], e.markValid();
        continue;
      }
      if (r !== "admin" && r !== "manager" && r !== "writer" && r !== "writeOnly") {
        e.markInvalid("Transactor has no write permissions", {
          transactor: e.author,
          transactorRole: r ?? "undefined"
        });
        continue;
      }
      e.markValid();
    }
    return;
  }
  if (t.verified.header.ruleset.type === "unsafeAllowAll") {
    for (const A of t.toValidateTransactions)
      A.markValid();
    return;
  }
  throw new Error("Unknown ruleset type " + t.verified.header.ruleset.type);
}
function qC(t, A) {
  return t === void 0 || t === "revoked" ? !1 : A === void 0 || A === "revoked" ? !0 : A === "admin" ? !1 : t === "admin" ? !0 : A === "manager" ? !1 : t === "manager" ? !0 : t === "writer" && A === "reader";
}
class xC {
  constructor() {
    this.parentGroups = /* @__PURE__ */ new Map(), this.memberRoles = /* @__PURE__ */ new Map();
  }
  setDirectRole(A, e) {
    this.memberRoles.set(A, e);
  }
  removeMember(A) {
    this.memberRoles.delete(A);
  }
  addParentGroup(A, e) {
    this.parentGroups.set(A, e);
  }
  removeParentGroup(A) {
    this.parentGroups.delete(A);
  }
  getDirectRole(A) {
    return this.memberRoles.get(A);
  }
  getRoleAtTime(A, e) {
    let i = this.memberRoles.get(A);
    for (const [o, r] of this.parentGroups.entries()) {
      const n = o.atTime(e).roleOfInternal(A);
      if (!n || !Sg(n))
        continue;
      const s = r === "extend" ? n : r;
      qC(s, i) && (i = s);
    }
    return i;
  }
}
function LC(t, A) {
  t.verifiedTransactions.sort(t.compareTransactions);
  const e = {}, i = /* @__PURE__ */ new Set(), o = new xC(), r = t.isGroup();
  for (const n of t.verifiedTransactions) {
    let Q = function(l) {
      if (l.op !== "set")
        throw new Error("Expected set operation");
      o.setDirectRole(l.key, l.value), n.markValid();
    };
    const s = n.author, a = o.getRoleAtTime(s, n.currentMadeAt);
    if (n.tx.privacy === "private") {
      if (r) {
        n.markInvalid("Can't make private transactions in groups");
        continue;
      }
      if (a === "admin") {
        n.markValid();
        continue;
      } else {
        n.markInvalid("Only admins can make private transactions in groups");
        continue;
      }
    }
    const I = n.changes;
    if (!I)
      continue;
    const c = I[0];
    if (I.length !== 1) {
      n.markInvalid("Group transaction must have exactly one change");
      continue;
    }
    if (c.op !== "set") {
      n.markInvalid("Group transaction must set a role or readKey");
      continue;
    }
    if (c.key === "readKey") {
      if (!Qt(a)) {
        n.markInvalid("Only admins can set readKeys");
        continue;
      }
      n.markValid();
      continue;
    } else if (c.key === "profile") {
      if (!Qt(a)) {
        n.markInvalid("Only admins can set profile");
        continue;
      }
      n.markValid();
      continue;
    } else if (c.key === "root") {
      if (!Qt(a)) {
        n.markInvalid("Only admins can set root");
        continue;
      }
      n.markValid();
      continue;
    } else if (mg(c.key) || jC(c.key)) {
      if (a !== "admin" && a !== "adminInvite" && a !== "manager" && a !== "managerInvite" && a !== "writerInvite" && a !== "readerInvite" && a !== "writeOnlyInvite" && !WC(c.key, s, e)) {
        n.markInvalid("Only admins and managers can reveal keys");
        continue;
      }
      n.markValid();
      continue;
    } else if (VC(c.key)) {
      if (!Qt(a)) {
        n.markInvalid("Only admins and managers can set parent extensions");
        continue;
      }
      const l = pg(c.key), u = t.node.expectCoValueLoaded(l, "Expected parent group to be loaded");
      if (!u.isGroup()) {
        n.markInvalid("Parent group is not a group");
        continue;
      }
      const d = bA(u.getCurrentContent());
      if (kg(t, d)) {
        n.markInvalid("Parent group is a circular dependency");
        continue;
      }
      const h = c.value;
      h === "revoked" ? o.removeParentGroup(d) : o.addParentGroup(d, h), n.markValid();
      continue;
    } else if ($C(c.key)) {
      n.markInvalid("Child extensions are not allowed anymore");
      continue;
    } else if (OC(c.key)) {
      const l = PC(c.key);
      if (a !== "admin" && a !== "manager" && a !== "writeOnlyInvite" && l !== s) {
        n.markInvalid("Only admins and managers can set writeKeys");
        continue;
      }
      if (e[l] = c.value, i.has(c.key) && !Qt(a)) {
        n.markInvalid("Write key already exists and can't be overridden by invite");
        continue;
      }
      i.add(c.key), n.markValid();
      continue;
    }
    const C = c.key, B = c.value;
    if (B !== "admin" && B !== "manager" && B !== "writer" && B !== "reader" && B !== "writeOnly" && B !== "revoked" && B !== "managerInvite" && B !== "adminInvite" && B !== "writerInvite" && B !== "readerInvite" && B !== "writeOnlyInvite") {
      n.markInvalid("Group transaction must set a valid role");
      continue;
    }
    if (C === Ae && !(B === "reader" || B === "writer" || B === "writeOnly" || B === "revoked")) {
      n.markInvalid("Everyone can only be set to reader, writer, writeOnly or revoked");
      continue;
    }
    if (a === void 0 && s === A && C === s && B === "admin") {
      Q(c);
      continue;
    }
    if (s === c.key && c.value === "revoked") {
      Q(c);
      continue;
    }
    const f = o.getRoleAtTime(C, n.currentMadeAt);
    if (a === "admin") {
      if (f === "admin" && B !== "admin" && C !== s) {
        n.markInvalid("Admins can't demote admins.");
        continue;
      }
      Q(c);
      continue;
    }
    if (a === "manager") {
      if (f === "admin") {
        n.markInvalid("Managers can't demote admins.");
        continue;
      }
      if (c.value === "admin") {
        n.markInvalid("Managers can't promote to admin.");
        continue;
      }
      if (c.value === "adminInvite") {
        n.markInvalid("Managers can't invite admins.");
        continue;
      }
      if (c.value === "managerInvite") {
        n.markInvalid("Managers can't invite managers.");
        continue;
      }
      Q(c);
      continue;
    }
    if (a === "adminInvite") {
      if (c.value !== "admin") {
        n.markInvalid("AdminInvites can only create admins.");
        continue;
      }
    } else if (a === "managerInvite") {
      if (c.value !== "manager") {
        n.markInvalid("managerInvite can only create managers.");
        continue;
      }
    } else if (a === "writerInvite") {
      if (c.value !== "writer") {
        n.markInvalid("WriterInvites can only create writers.");
        continue;
      }
    } else if (a === "readerInvite") {
      if (c.value !== "reader") {
        n.markInvalid("ReaderInvites can only create reader.");
        continue;
      }
    } else if (a === "writeOnlyInvite") {
      if (c.value !== "writeOnly") {
        n.markInvalid("WriteOnlyInvites can only create writeOnly.");
        continue;
      }
    } else {
      n.markInvalid("Group transaction must be made by current admin, manager, or invite");
      continue;
    }
    o.setDirectRole(C, c.value), n.markValid();
  }
}
function TC(t, A) {
  return t === A.id && A instanceof rn ? A.currentAgentID() : t;
}
function OC(t) {
  return t.startsWith("writeKeyFor_");
}
function PC(t) {
  return t.slice(12);
}
function mg(t) {
  return t.startsWith("key_") && t.includes("_for_key");
}
function jC(t) {
  return t.startsWith("key_") && (t.includes("_for_sealer") || t.includes("_for_co")) || t.includes("_for_everyone");
}
function VC(t) {
  return t.startsWith("parent_");
}
function $C(t) {
  return t.startsWith("child_");
}
function WC(t, A, e) {
  if (Object.keys(e).length === 0)
    return !1;
  const i = t.slice(0, t.indexOf("_for_"));
  return e[A] === i;
}
const Ae = "everyone";
function zC(t) {
  const A = t.get("readKey");
  if (!A || !ao(t, Ae) || t.get(`${A}_for_${Ae}`))
    return;
  if (ao(t, t.core.node.getCurrentAgent().id)) {
    const r = t.getReadKey(A);
    r && t.set(`${A}_for_${Ae}`, r, "trusting");
    return;
  }
  const i = t.keys().filter((r) => r.startsWith("key_") && r.endsWith("_for_everyone"));
  let o = i[0];
  for (const r of i) {
    if (!o) {
      o = r;
      continue;
    }
    const n = t.getRaw(r), s = t.getRaw(o);
    n && s && n.madeAt > s.madeAt && (o = r);
  }
  o && (t._lastReadableKeyId = o.replace("_for_everyone", ""));
}
class _C {
  constructor() {
    this.changes = [];
  }
  addChange(A, e) {
    const i = this.changes, o = { madeAt: A, value: e };
    let r = i.length;
    for (; r > 0 && i[r - 1].madeAt > A; )
      r--;
    r === i.length ? i.push(o) : i.splice(r, 0, o);
  }
  getLatest() {
    return this.changes[this.changes.length - 1]?.value;
  }
  getAtTime(A) {
    return A === void 0 ? this.getLatest() : this.changes.findLast((e) => e.madeAt <= A)?.value;
  }
}
class on extends tn {
  resetInternalState() {
    super.resetInternalState(), this.parentGroupsChanges = /* @__PURE__ */ new Map(), this.keyRevelations = /* @__PURE__ */ new Map(), this._lastReadableKeyId = void 0;
  }
  constructor(A, e) {
    super(A, e), this.crypto = A.node.crypto, this.migrate();
  }
  // We override the handleNewTransaction hook from CoMap to build the parent group cache
  // and key revelations cache
  handleNewTransaction(A) {
    this.parentGroupsChanges || (this.parentGroupsChanges = /* @__PURE__ */ new Map()), this.keyRevelations || (this.keyRevelations = /* @__PURE__ */ new Map());
    for (const e of A.changes) {
      const i = e;
      i.op === "set" && (fg(i.key) ? this.updateParentGroupCache(i.key, i.value, A.madeAt) : mg(i.key) && this.updateKeyRevelationsCache(i.key));
    }
  }
  updateKeyRevelationsCache(A) {
    const e = A.split("_for_");
    if (e.length === 2) {
      const i = e[0], o = e[1];
      let r = this.keyRevelations.get(i);
      r || (r = /* @__PURE__ */ new Set(), this.keyRevelations.set(i, r)), r.add(o);
    }
  }
  updateParentGroupCache(A, e, i) {
    const o = A.substring(7);
    let r = this.parentGroupsChanges.get(o);
    r || (r = new _C(), this.parentGroupsChanges.set(o, r)), r.addChange(i, e);
  }
  migrate() {
    if (!this.core.isGroup())
      return;
    const A = () => {
      zC(this);
    };
    this.core.isCompletelyDownloaded() ? A() : this.core.waitFor({
      predicate: (e) => e.isCompletelyDownloaded(),
      onSuccess: A
    });
  }
  /**
   * Returns the current role of a given account.
   *
   * @category 1. Role reading
   */
  roleOf(A) {
    return this.roleOfInternal(A);
  }
  /**
   *  This is a performance-critical function, micro-optimizing it is important
   *
   *  Avoid to add objects/array allocations in this function
   */
  /** @internal */
  roleOfInternal(A) {
    let e = this.get(A);
    e === "revoked" && (e = void 0);
    let i = e;
    for (const [o, r] of this.parentGroupsChanges.entries()) {
      const n = r.getAtTime(this.atTimeFilter);
      if (!n || n === "revoked")
        continue;
      const a = this.getParentGroup(o, this.atTimeFilter).roleOfInternal(A);
      if (!Sg(a))
        continue;
      const g = n !== "extend" ? n : a;
      ZC(g, i) && (i = g);
    }
    if (!i && A !== "everyone") {
      const o = this.get("everyone");
      if (o && o !== "revoked")
        return o;
    }
    return i;
  }
  getParentGroup(A, e) {
    const i = this.core.node.expectCoValueLoaded(A, "Expected parent group to be loaded"), o = bA(i.getCurrentContent());
    return e ? o.atTime(e) : o;
  }
  getParentGroups() {
    const A = [];
    for (const [e, i] of this.parentGroupsChanges.entries()) {
      const o = i.getAtTime(this.atTimeFilter);
      !o || o === "revoked" || A.push(this.getParentGroup(e, this.atTimeFilter));
    }
    return A;
  }
  forEachChildGroup(A) {
    for (const e of this.core.dependant) {
      const i = this.core.node.getCoValue(e);
      if (!i.isGroup())
        continue;
      const o = bA(i.getCurrentContent()), r = o.get(`parent_${this.id}`);
      r && r !== "revoked" && A(o);
    }
  }
  /**
   * Returns the role of the current account in the group.
   *
   * @category 1. Role reading
   */
  myRole() {
    return this.roleOfInternal(this.core.node.getCurrentAccountOrAgentID());
  }
  /**
   * Directly grants a new member a role in the group. The current account must be an
   * admin to be able to do so. Throws otherwise.
   *
   * @category 2. Role changing
   */
  addMember(A, e) {
    this.addMemberInternal(A, e);
  }
  /** @internal */
  addMemberInternal(A, e) {
    const i = typeof A == "string" ? A : A.id, o = this.get(i);
    if (o === e)
      return;
    if (i === Ae) {
      if (!(e === "reader" || e === "writer" || e === "writeOnly"))
        throw new Error("Can't make everyone something other than reader, writer or writeOnly");
      const n = this.getCurrentReadKey();
      if (!n.secret)
        throw new Error("Can't add member without read key secret");
      const s = this.get(i);
      if (this.set(i, e, "trusting"), this.get(i) !== e)
        throw new Error(`Failed to set role ${e} to ${i} (role of current account is ${this.myRole()})`);
      e === "writeOnly" ? ((s === "reader" || s === "writer") && this.rotateReadKey("everyone"), this.delete(`${n.id}_for_${Ae}`)) : this.set(`${n.id}_for_${Ae}`, n.secret, "trusting");
      return;
    }
    const r = typeof A == "string" ? A : A.currentAgentID();
    if (r === Ae)
      throw new Error("Agent should not be everyone");
    if (e === "writeOnly" || e === "writeOnlyInvite") {
      if ((o === "reader" || o === "writer" || o === "manager" || o === "admin") && this.rotateReadKey(i), this.set(i, e, "trusting"), this.get(i) !== e)
        throw new Error(`Failed to set role ${e} to ${i} (role of current account is ${this.myRole()})`);
      this.internalCreateWriteOnlyKeyForMember(i, r);
    } else {
      const n = this.getCurrentReadKey();
      if (!n.secret)
        throw new Error("Can't add member without read key secret");
      if (this.set(i, e, "trusting"), this.get(i) !== e)
        throw new Error(`Failed to set role ${e} to ${i} (role of current account is ${this.myRole()})`);
      this.storeKeyRevelationForMember(i, r, n.id, n.secret);
      for (const s of this.getWriteOnlyKeys()) {
        const a = this.core.getReadKey(s);
        if (!a) {
          AA.error("Can't find key " + s);
          continue;
        }
        this.storeKeyRevelationForMember(i, r, s, a);
      }
    }
  }
  internalCreateWriteOnlyKeyForMember(A, e) {
    const i = this.crypto.newRandomKeySecret();
    this.set(`writeKeyFor_${A}`, i.id, "trusting"), this.storeKeyRevelationForMember(A, e, i.id, i.secret);
    for (const o of this.getMemberKeys()) {
      const r = this.get(o);
      if (r === "reader" || r === "writer" || r === "admin" || r === "manager" || r === "readerInvite" || r === "writerInvite" || r === "adminInvite") {
        const n = this.core.node.resolveAccountAgent(o, "Expected member agent to be loaded").value;
        if (!n)
          throw new Error("Expected member agent to be loaded");
        this.storeKeyRevelationForMember(o, n, i.id, i.secret);
      }
    }
    for (const o of this.getParentGroups())
      this.revealReadKeyToParentGroup(o, i.id, i.secret, { revealAllWriteOnlyKeys: !1 });
    return i.id;
  }
  storeKeyRevelationForMember(A, e, i, o) {
    this.set(`${i}_for_${A}`, this.crypto.seal({
      message: o,
      from: this.core.node.getCurrentAgent().currentSealerSecret(),
      to: this.crypto.getAgentSealerID(e),
      nOnceMaterial: {
        in: this.id,
        tx: this.core.nextTransactionID()
      }
    }), "trusting");
  }
  storeKeyRevelationForParentGroup(A, e, i, o) {
    this.set(`${i}_for_${A}`, this.crypto.encryptKeySecret({
      encrypting: {
        id: A,
        secret: e
      },
      toEncrypt: {
        id: i,
        secret: o
      }
    }).encrypted, "trusting");
  }
  getWriteOnlyKeys() {
    const A = [];
    for (const e of this.keys())
      e.startsWith("writeKeyFor_") && A.push(this.get(e));
    return A;
  }
  getCurrentReadKeyId() {
    if (this._lastReadableKeyId)
      return this._lastReadableKeyId;
    const A = this.myRole();
    if (A === "writeOnly") {
      const e = this.core.node.getCurrentAgent().id, i = this.get(`writeKeyFor_${e}`);
      return !i && this.get("everyone") === "writeOnly" ? (this.internalCreateWriteOnlyKeyForMember(e, this.core.node.getCurrentAgent().currentAgentID()), this.get(`writeKeyFor_${e}`)) : i;
    }
    if (!A) {
      const e = this.core.node.getCurrentAgent().id, i = this.get(`writeKeyFor_${e}`);
      if (i)
        return i;
    }
    return this.get("readKey");
  }
  getMemberKeys() {
    return this.keys().filter((A) => A.startsWith("co_") || Xe(A));
  }
  getAllMemberKeysSet() {
    const A = new Set(this.getMemberKeys());
    for (const e of this.getParentGroups())
      for (const i of e.getAllMemberKeysSet())
        A.add(i);
    return A;
  }
  getReadKey(A) {
    const e = this.core.readKeyCache;
    let i = e.get(A);
    return i || (i = this.getUncachedReadKey(A), i && e.set(A, i)), i;
  }
  getUncachedReadKey(A) {
    const e = this.core, i = this.get(`${A}_for_everyone`);
    if (i)
      return i;
    const o = OA(e.node.currentSessionID), r = en(o) && e.id === o ? e.node.crypto.getAgentID(e.node.agentSecret) : o, n = this.lastEditAt(`${A}_for_${r}`);
    if (n?.value) {
      const a = n.by, g = e.node.resolveAccountAgent(a, "Expected to know revealer").value;
      if (!g)
        throw new Error("Expected to know revealer");
      const I = this.crypto.unseal(
        n.value,
        this.crypto.getAgentSealerSecret(e.node.agentSecret),
        // being careful here to avoid recursion
        this.crypto.getAgentSealerID(g),
        {
          in: this.id,
          tx: n.tx
        }
      );
      if (I)
        return I;
    }
    const s = this.keyRevelations.get(A);
    if (s)
      for (const a of s) {
        const g = this.getReadKey(a);
        if (!g)
          continue;
        const I = this.get(`${A}_for_${a}`), c = this.crypto.decryptKeySecret({
          encryptedID: A,
          encryptingID: a,
          encrypted: I
        }, g);
        if (c)
          return c;
        AA.warn(`Encrypting ${a} key didn't decrypt ${A}`);
      }
    for (const a of this.parentGroupsChanges.keys()) {
      const g = e.node.expectCoValueLoaded(a, "Expected parent group to be loaded"), I = this.findValidParentKeys(A, g);
      for (const c of I) {
        const C = this.get(`${A}_for_${c.id}`);
        if (C) {
          const B = g.node.crypto.decryptKeySecret({
            encryptedID: A,
            encryptingID: c.id,
            encrypted: C
          }, c.secret);
          if (B)
            return B;
          AA.warn(`Encrypting parent ${c.id} key didn't decrypt ${A}`);
        }
      }
    }
  }
  findValidParentKeys(A, e) {
    const i = [], o = this.keyRevelations.get(A);
    if (o)
      for (const r of o) {
        const n = e.getReadKey(r);
        n && i.push({
          id: r,
          secret: n
        });
      }
    return i;
  }
  /** @internal */
  rotateReadKey(A) {
    if (A !== Ae && ao(this, Ae))
      return;
    const e = this.getMemberKeys().filter((g) => g !== A), i = e.filter((g) => ao(this, g)), o = e.filter((g) => {
      const I = this.get(g);
      return I === "writeOnly" || I === "writeOnlyInvite";
    }), r = this.getParentGroups(), n = this.getCurrentReadKey();
    if (!n.secret)
      throw new is("Can't rotate read key secret we don't have access to");
    const s = {
      id: n.id,
      secret: n.secret
    }, a = this.crypto.newRandomKeySecret();
    for (const g of i) {
      const I = this.core.node.resolveAccountAgent(g, "Expected to know currently permitted reader").value;
      if (!I)
        throw new Error("Expected to know currently permitted reader");
      this.storeKeyRevelationForMember(g, I, a.id, a.secret);
    }
    for (const g of o) {
      const I = this.core.node.resolveAccountAgent(g, "Expected to know writeOnly member").value;
      if (!I)
        throw new Error("Expected to know writeOnly member");
      const c = this.crypto.newRandomKeySecret();
      this.storeKeyRevelationForMember(g, I, c.id, c.secret), this.set(`writeKeyFor_${g}`, c.id, "trusting");
      for (const C of i) {
        const B = this.core.node.resolveAccountAgent(C, "Expected to know currently permitted reader").value;
        if (!B)
          throw new Error("Expected to know currently permitted reader");
        this.storeKeyRevelationForMember(C, B, c.id, c.secret);
      }
      for (const C of this.getParentGroups())
        this.revealReadKeyToParentGroup(C, c.id, c.secret, { revealAllWriteOnlyKeys: !1 });
    }
    this.set(`${s.id}_for_${a.id}`, this.crypto.encryptKeySecret({
      encrypting: a,
      toEncrypt: s
    }).encrypted, "trusting"), this.set("readKey", a.id, "trusting");
    for (const g of r) {
      const { id: I, secret: c } = g.getCurrentReadKey();
      if (!c) {
        AA.warn("Can't reveal new child key to parent where we don't have access to the parent read key");
        continue;
      }
      this.storeKeyRevelationForParentGroup(I, c, a.id, a.secret);
    }
    this.forEachChildGroup((g) => {
      if (!g.isSelfExtension(this))
        try {
          g.rotateReadKey(A);
        } catch (I) {
          if (I instanceof is)
            AA.warn(`Can't rotate read key on child ${g.id} because we don't have access to the read key`);
          else
            throw I;
        }
    });
  }
  /** Detect circular references in group inheritance */
  isSelfExtension(A) {
    return kg(this.core, A);
  }
  getCurrentReadKey() {
    const A = this.getCurrentReadKeyId();
    if (!A)
      throw new Error("No readKey set");
    return {
      secret: this.getReadKey(A),
      id: A
    };
  }
  extend(A, e = "inherit") {
    if (this.isSelfExtension(A))
      return;
    if (this.myRole() !== "admin")
      throw new Error("To extend a group, the current account must be an admin in the child group");
    const i = e === "inherit" ? "extend" : e;
    this.set(`parent_${A.id}`, i, "trusting");
    const { id: o, secret: r } = this.getCurrentReadKey();
    if (r === void 0)
      throw new Error("Can't extend group without child read key secret");
    this.revealReadKeyToParentGroup(A, o, r, { revealAllWriteOnlyKeys: !0 });
  }
  revealReadKeyToParentGroup(A, e, i, { revealAllWriteOnlyKeys: o }) {
    let r;
    ts(A.myRole()) || (r = A.internalCreateWriteOnlyKeyForMember(this.core.node.getCurrentAgent().id, this.core.node.getCurrentAgent().currentAgentID()));
    let { id: n, secret: s } = A.getCurrentReadKey();
    if (!s)
      throw new Error("Can't extend group without parent read key secret");
    if (this.storeKeyRevelationForParentGroup(n, s, e, i), o)
      for (const a of this.getWriteOnlyKeys()) {
        if (a === r)
          continue;
        const g = this.core.getReadKey(a);
        if (!g) {
          AA.error("Can't find key " + a);
          continue;
        }
        this.storeKeyRevelationForParentGroup(n, s, a, g);
      }
  }
  revokeExtend(A) {
    if (this.myRole() !== "admin")
      throw new Error("To unextend a group, the current account must be an admin in the child group");
    if (!ts(A.myRole()))
      throw new Error("To unextend a group, the current account must be a member of the parent group");
    !this.get(`parent_${A.id}`) || this.get(`parent_${A.id}`) === "revoked" || (this.set(`parent_${A.id}`, "revoked", "trusting"), A.get(`child_${this.id}`) && A.set(`child_${this.id}`, "revoked", "trusting"), this.rotateReadKey());
  }
  /**
   * Strips the specified member of all roles (preventing future writes in
   *  the group and owned values) and rotates the read encryption key for that group
   * (preventing reads of new content in the group and owned values)
   *
   * @category 2. Role changing
   */
  removeMember(A) {
    const e = typeof A == "string" ? A : A.id;
    if ((this.myRole() === "admin" || this.myRole() === "manager") && this.rotateReadKey(e), this.set(e, "revoked", "trusting"), this.get(e) !== "revoked")
      throw new Error(`Failed to revoke role to ${e} (role of current account is ${this.myRole()})`);
  }
  /**
   * Creates an invite for new members to indirectly join the group,
   * allowing them to grant themselves the specified role with the InviteSecret
   * (a string starting with "inviteSecret_") - use `LocalNode.acceptInvite()` for this purpose.
   *
   * @category 2. Role changing
   */
  createInvite(A) {
    const e = this.crypto.newRandomSecretSeed(), i = this.crypto.agentSecretFromSecretSeed(e), o = this.crypto.getAgentID(i);
    return this.addMemberInternal(o, `${A}Invite`), XC(e);
  }
  /**
   * Creates a new `CoMap` within this group, with the specified specialized
   * `CoMap` type `M` and optional static metadata.
   *
   * @category 3. Value creation
   */
  createMap(A, e, i = "private", o = this.crypto.createdNowUnique()) {
    const r = this.core.node.createCoValue({
      type: "comap",
      ruleset: {
        type: "ownedByGroup",
        group: this.id
      },
      meta: e || null,
      ...o.createdAt !== void 0 ? { createdAt: o.createdAt } : {},
      uniqueness: o.uniqueness
    }).getCurrentContent();
    return A ? r.assign(A, i) : o.createdAt || r.core.makeTransaction([], "trusting"), r;
  }
  /**
   * Creates a new `CoList` within this group, with the specified specialized
   * `CoList` type `L` and optional static metadata.
   *
   * @category 3. Value creation
   */
  createList(A, e, i = "private", o = this.crypto.createdNowUnique()) {
    const r = this.core.node.createCoValue({
      type: "colist",
      ruleset: {
        type: "ownedByGroup",
        group: this.id
      },
      meta: e || null,
      ...o.createdAt !== void 0 ? { createdAt: o.createdAt } : {},
      uniqueness: o.uniqueness
    }).getCurrentContent();
    return A?.length ? r.appendItems(A, void 0, i) : o.createdAt || r.core.makeTransaction([], "trusting"), r;
  }
  /**
   * Creates a new `CoPlainText` within this group, with the specified specialized
   * `CoPlainText` type `T` and optional static metadata.
   *
   * @category 3. Value creation
   */
  createPlainText(A, e, i = "private") {
    const o = this.core.node.createCoValue({
      type: "coplaintext",
      ruleset: {
        type: "ownedByGroup",
        group: this.id
      },
      meta: e || null,
      ...this.crypto.createdNowUnique()
    }).getCurrentContent();
    return A && o.insertAfter(0, A, i), o;
  }
  /** @category 3. Value creation */
  createStream(A, e = this.crypto.createdNowUnique()) {
    const i = this.core.node.createCoValue({
      type: "costream",
      ruleset: {
        type: "ownedByGroup",
        group: this.id
      },
      meta: A || null,
      ...e.createdAt !== void 0 ? { createdAt: e.createdAt } : {},
      uniqueness: e.uniqueness
    }).getCurrentContent();
    return e.createdAt || i.core.makeTransaction([], "trusting"), i;
  }
  /** @category 3. Value creation */
  createBinaryStream(A = { type: "binary" }, e = this.crypto.createdNowUnique()) {
    return this.core.node.createCoValue({
      type: "costream",
      ruleset: {
        type: "ownedByGroup",
        group: this.id
      },
      meta: A,
      ...e.createdAt !== void 0 ? { createdAt: e.createdAt } : {},
      uniqueness: e.uniqueness
    }).getCurrentContent();
  }
}
function Sg(t) {
  return t === "revoked" || t === "admin" || t === "manager" || t === "writer" || t === "reader";
}
function ZC(t, A) {
  return t === "revoked" ? !0 : t === "manager" ? !A || A !== "manager" && A !== "admin" : t === "admin" ? !A || A !== "admin" : t === "writer" ? !A || A === "reader" || A === "writeOnly" : t === "reader" ? !A : !1;
}
function XC(t) {
  return `inviteSecret_z${YA.encode(t)}`;
}
function AB(t) {
  if (!t.startsWith("inviteSecret_z"))
    throw new Error("Invalid invite secret");
  return YA.decode(t.slice(14));
}
const ao = (t, A) => {
  const e = t.get(A);
  return e === "admin" || e === "manager" || e === "writer" || e === "reader" || e === "adminInvite" || e === "writerInvite" || e === "readerInvite";
};
class is extends Error {
  constructor(A) {
    super(A), this.name = "NoReadKeyAccessError";
  }
}
function kg(t, A) {
  const e = /* @__PURE__ */ new Set(), i = [A];
  for (; ; ) {
    const o = i.pop();
    if (!o)
      return !1;
    if (o.id === t.id)
      return !0;
    e.add(o.id);
    const r = o.getParentGroups();
    for (const n of r)
      e.has(n.id) || i.push(n);
  }
}
function Ng(t, A) {
  return {
    type: "comap",
    ruleset: { type: "group", initialAdmin: A.getAgentID(t) },
    meta: {
      type: "account"
    },
    createdAt: null,
    uniqueness: null
  };
}
class rn extends on {
  currentAgentID() {
    if (this._cachedCurrentAgentID)
      return this._cachedCurrentAgentID;
    const A = this.core.verified.header;
    if (A.ruleset.type !== "group")
      throw new Error("You can't get an agent id from a non-group value");
    const e = A.ruleset.initialAdmin;
    if (!Xe(e))
      throw new Error("You can read agent ids only from account values");
    return this._cachedCurrentAgentID = e, e;
  }
  createInvite(A) {
    throw new Error("Cannot create invite from an account");
  }
  roleOfInternal(A) {
    return A === this.id ? "admin" : super.roleOfInternal(A);
  }
  addMember(A, e) {
    throw new Error("Cannot add a member to an account");
  }
  removeMember(A) {
    throw new Error("Cannot remove a member from an account");
  }
  extend(A, e = "inherit") {
    throw new Error("Cannot extend an account");
  }
  revokeExtend(A) {
    throw new Error("Cannot unextend an account");
  }
}
class eB {
  constructor(A, e) {
    this.account = A, this.agentSecret = e, this.crypto = A.core.node.crypto;
  }
  get id() {
    return this.account.id;
  }
  currentAgentID() {
    return this.crypto.getAgentID(this.agentSecret);
  }
  currentSignerID() {
    return this.crypto.getAgentSignerID(this.currentAgentID());
  }
  currentSignerSecret() {
    return this.crypto.getAgentSignerSecret(this.agentSecret);
  }
  currentSealerID() {
    return this.crypto.getAgentSealerID(this.currentAgentID());
  }
  currentSealerSecret() {
    return this.crypto.getAgentSealerSecret(this.agentSecret);
  }
}
class os {
  constructor(A, e) {
    this.agentSecret = A, this.crypto = e;
  }
  get id() {
    return this.crypto.getAgentID(this.agentSecret);
  }
  currentAgentID() {
    return this.crypto.getAgentID(this.agentSecret);
  }
  currentSignerID() {
    return this.crypto.getAgentSignerID(this.currentAgentID());
  }
  currentSignerSecret() {
    return this.crypto.getAgentSignerSecret(this.agentSecret);
  }
  currentSealerID() {
    return this.crypto.getAgentSealerID(this.currentAgentID());
  }
  currentSealerSecret() {
    return this.crypto.getAgentSealerSecret(this.agentSecret);
  }
}
function rs(t) {
  if (!(t instanceof rn))
    throw new Error("Expected an account");
  return t;
}
function Mg(t, A = "") {
  let e = (
    /** @type {Array<CategorizedUnicodeRange<T>>} */
    []
  ), i = t.split(",").map((r) => r ? parseInt(r, 36) : 0), o = 0;
  for (let r = 0; r < i.length; r++)
    r % 2 ? e.push([
      o,
      o + i[r],
      /** @type {T} */
      A ? parseInt(A[r >> 1], 36) : 0
    ]) : o = i[r];
  return e;
}
function Gg(t, A) {
  let e = 0, i = A.length - 1;
  for (; e <= i; ) {
    let o = e + i >> 1, r = A[o], n = r[0], s = r[1];
    if (n <= t && t <= s) return o;
    t > s ? e = o + 1 : i = o - 1;
  }
  return -1;
}
function tB(t) {
  return t <= 65535;
}
const ns = Mg(
  /** @type {UnicodeDataEncoding} */
  ",9,a,,b,1,d,,e,h,3j,w,4p,,4t,,4u,,lc,33,w3,6,13l,18,14v,,14x,1,150,1,153,,16o,5,174,a,17g,,18r,k,19s,,1cm,6,1ct,,1cv,5,1d3,1,1d6,3,1e7,,1e9,,1f4,q,1ie,a,1kb,8,1kt,,1li,3,1ln,8,1lx,2,1m1,4,1nd,2,1ow,1,1p3,8,1qi,n,1r6,,1r7,v,1s3,,1tm,,1tn,,1to,,1tq,2,1tt,7,1u1,3,1u5,,1u6,1,1u9,6,1uq,1,1vl,,1vm,1,1x8,,1xa,,1xb,1,1xd,3,1xj,1,1xn,1,1xp,,1xz,,1ya,1,1z2,,1z5,1,1z7,,20s,,20u,2,20x,1,213,1,217,2,21d,,228,1,22d,,22p,1,22r,,24c,,24e,2,24h,4,24n,1,24p,,24r,1,24t,,25e,1,262,5,269,,26a,1,27w,,27y,1,280,,281,3,287,1,28b,1,28d,,28l,2,28y,1,29u,,2bi,,2bj,,2bk,,2bl,1,2bq,2,2bu,2,2bx,,2c7,,2dc,,2dd,2,2dg,,2f0,,2f2,2,2f5,3,2fa,2,2fe,3,2fp,1,2g2,1,2gx,,2gy,1,2ik,,2im,,2in,1,2ip,,2iq,,2ir,1,2iu,2,2iy,3,2j9,1,2jm,1,2k3,,2kg,1,2ki,1,2m3,1,2m6,,2m7,1,2m9,3,2me,2,2mi,2,2ml,,2mm,,2mv,,2n6,1,2o1,,2o2,1,2q2,,2q7,,2q8,1,2qa,2,2qe,,2qg,6,2qn,,2r6,1,2sx,,2sz,,2t0,6,2tj,7,2wh,,2wj,,2wk,8,2x4,6,2zc,1,305,,307,,309,,30e,1,31t,d,327,,328,4,32e,1,32l,a,32x,z,346,,371,3,375,,376,5,37d,1,37f,1,37h,1,386,1,388,1,38e,2,38x,3,39e,,39g,,39h,1,39p,,3a5,,3cw,2n,3fk,1z,3hk,2f,3tp,2,4k2,3,4ky,2,4lu,1,4mq,1,4ok,1,4om,,4on,6,4ou,7,4p2,,4p3,1,4p5,a,4pp,,4qz,2,4r2,,4r3,,4ud,1,4vd,,4yo,2,4yr,3,4yv,1,4yx,2,4z4,1,4z6,,4z7,5,4zd,2,55j,1,55l,1,55n,,579,,57a,,57b,,57c,6,57k,,57m,,57p,7,57x,5,583,9,58f,,59s,u,5c0,3,5c4,,5dg,9,5dq,3,5du,2,5ez,8,5fk,1,5fm,,5gh,,5gi,3,5gm,1,5go,5,5ie,,5if,,5ig,1,5ii,2,5il,,5im,,5in,4,5k4,7,5kc,7,5kk,1,5km,1,5ow,2,5p0,c,5pd,,5pe,6,5pp,,5pw,,5pz,,5q0,1,5vk,1r,6bv,,6bw,,6bx,,6by,1,6co,6,6d8,,6dl,,6e8,f,6hc,w,6jm,,6k9,,6ms,5,6nd,1,6xm,1,6y0,,70o,,72n,,73d,a,73s,2,79e,,7fu,1,7g6,,7gg,,7i3,3,7i8,5,7if,b,7is,35,7m8,39,7pk,a,7pw,,7py,,7q5,,7q9,,7qg,,7qr,1,7r8,,7rb,,7rg,,7ri,,7rn,2,7rr,,7s3,4,7th,2,7tt,,7u8,,7un,,850,1,8hx,2,8ij,1,8k0,,8k5,,8vj,2,8zj,,928,v,9ii,5,9io,,9j1,,9ll,1,9zr,,9zt,,wvj,3,wvo,9,wwu,1,wz4,1,x6q,,x6u,,x6z,,x7n,1,x7p,1,x7r,,x7w,,xa8,1,xbo,f,xc4,1,xcw,h,xdr,,xeu,7,xfr,a,xg2,,xg3,,xgg,s,xhc,2,xhf,,xir,,xis,1,xiu,3,xiy,1,xj0,1,xj2,1,xj4,,xk5,,xm1,5,xm7,1,xm9,1,xmb,1,xmd,1,xmr,,xn0,,xn1,,xoc,,xps,,xpu,2,xpz,1,xq6,1,xq9,,xrf,,xrg,1,xri,1,xrp,,xrq,,xyb,1,xyd,,xye,1,xyg,,xyh,1,xyk,,xyl,,xz4,,xz5,q,xzw,,xzx,q,y0o,,y0p,q,y1g,,y1h,q,y28,,y29,q,y30,,y31,q,y3s,,y3t,q,y4k,,y4l,q,y5c,,y5d,q,y64,,y65,q,y6w,,y6x,q,y7o,,y7p,q,y8g,,y8h,q,y98,,y99,q,ya0,,ya1,q,yas,,yat,q,ybk,,ybl,q,ycc,,ycd,q,yd4,,yd5,q,ydw,,ydx,q,yeo,,yep,q,yfg,,yfh,q,yg8,,yg9,q,yh0,,yh1,q,yhs,,yht,q,yik,,yil,q,yjc,,yjd,q,yk4,,yk5,q,ykw,,ykx,q,ylo,,ylp,q,ymg,,ymh,q,yn8,,yn9,q,yo0,,yo1,q,yos,,yot,q,ypk,,ypl,q,yqc,,yqd,q,yr4,,yr5,q,yrw,,yrx,q,yso,,ysp,q,ytg,,yth,q,yu8,,yu9,q,yv0,,yv1,q,yvs,,yvt,q,ywk,,ywl,q,yxc,,yxd,q,yy4,,yy5,q,yyw,,yyx,q,yzo,,yzp,q,z0g,,z0h,q,z18,,z19,q,z20,,z21,q,z2s,,z2t,q,z3k,,z3l,q,z4c,,z4d,q,z54,,z55,q,z5w,,z5x,q,z6o,,z6p,q,z7g,,z7h,q,z88,,z89,q,z90,,z91,q,z9s,,z9t,q,zak,,zal,q,zbc,,zbd,q,zc4,,zc5,q,zcw,,zcx,q,zdo,,zdp,q,zeg,,zeh,q,zf8,,zf9,q,zg0,,zg1,q,zgs,,zgt,q,zhk,,zhl,q,zic,,zid,q,zj4,,zj5,q,zjw,,zjx,q,zko,,zkp,q,zlg,,zlh,q,zm8,,zm9,q,zn0,,zn1,q,zns,,znt,q,zok,,zol,q,zpc,,zpd,q,zq4,,zq5,q,zqw,,zqx,q,zro,,zrp,q,zsg,,zsh,q,zt8,,zt9,q,zu0,,zu1,q,zus,,zut,q,zvk,,zvl,q,zwc,,zwd,q,zx4,,zx5,q,zxw,,zxx,q,zyo,,zyp,q,zzg,,zzh,q,1008,,1009,q,1010,,1011,q,101s,,101t,q,102k,,102l,q,103c,,103d,q,1044,,1045,q,104w,,104x,q,105o,,105p,q,106g,,106h,q,1078,,1079,q,1080,,1081,q,108s,,108t,q,109k,,109l,q,10ac,,10ad,q,10b4,,10b5,q,10bw,,10bx,q,10co,,10cp,q,10dg,,10dh,q,10e8,,10e9,q,10f0,,10f1,q,10fs,,10ft,q,10gk,,10gl,q,10hc,,10hd,q,10i4,,10i5,q,10iw,,10ix,q,10jo,,10jp,q,10kg,,10kh,q,10l8,,10l9,q,10m0,,10m1,q,10ms,,10mt,q,10nk,,10nl,q,10oc,,10od,q,10p4,,10p5,q,10pw,,10px,q,10qo,,10qp,q,10rg,,10rh,q,10s8,,10s9,q,10t0,,10t1,q,10ts,,10tt,q,10uk,,10ul,q,10vc,,10vd,q,10w4,,10w5,q,10ww,,10wx,q,10xo,,10xp,q,10yg,,10yh,q,10z8,,10z9,q,1100,,1101,q,110s,,110t,q,111k,,111l,q,112c,,112d,q,1134,,1135,q,113w,,113x,q,114o,,114p,q,115g,,115h,q,1168,,1169,q,1170,,1171,q,117s,,117t,q,118k,,118l,q,119c,,119d,q,11a4,,11a5,q,11aw,,11ax,q,11bo,,11bp,q,11cg,,11ch,q,11d8,,11d9,q,11e0,,11e1,q,11es,,11et,q,11fk,,11fl,q,11gc,,11gd,q,11h4,,11h5,q,11hw,,11hx,q,11io,,11ip,q,11jg,,11jh,q,11k8,,11k9,q,11l0,,11l1,q,11ls,,11lt,q,11mk,,11ml,q,11nc,,11nd,q,11o4,,11o5,q,11ow,,11ox,q,11po,,11pp,q,11qg,,11qh,q,11r8,,11r9,q,11s0,,11s1,q,11ss,,11st,q,11tk,,11tl,q,11uc,,11ud,q,11v4,,11v5,q,11vw,,11vx,q,11wo,,11wp,q,11xg,,11xh,q,11y8,,11y9,q,11z0,,11z1,q,11zs,,11zt,q,120k,,120l,q,121c,,121d,q,1224,,1225,q,122w,,122x,q,123o,,123p,q,124g,,124h,q,1258,,1259,q,1260,,1261,q,126s,,126t,q,127k,,127l,q,128c,,128d,q,1294,,1295,q,129w,,129x,q,12ao,,12ap,q,12bg,,12bh,q,12c8,,12c9,q,12d0,,12d1,q,12ds,,12dt,q,12ek,,12el,q,12fc,,12fd,q,12g4,,12g5,q,12gw,,12gx,q,12ho,,12hp,q,12ig,,12ih,q,12j8,,12j9,q,12k0,,12k1,q,12ks,,12kt,q,12lk,,12ll,q,12mc,,12md,q,12n4,,12n5,q,12nw,,12nx,q,12oo,,12op,q,12pg,,12ph,q,12q8,,12q9,q,12r0,,12r1,q,12rs,,12rt,q,12sk,,12sl,q,12tc,,12td,q,12u4,,12u5,q,12uw,,12ux,q,12vo,,12vp,q,12wg,,12wh,q,12x8,,12x9,q,12y0,,12y1,q,12ys,,12yt,q,12zk,,12zl,q,130c,,130d,q,1314,,1315,q,131w,,131x,q,132o,,132p,q,133g,,133h,q,1348,,1349,q,1350,,1351,q,135s,,135t,q,136k,,136l,q,137c,,137d,q,1384,,1385,q,138w,,138x,q,139o,,139p,q,13ag,,13ah,q,13b8,,13b9,q,13c0,,13c1,q,13cs,,13ct,q,13dk,,13dl,q,13ec,,13ed,q,13f4,,13f5,q,13fw,,13fx,q,13go,,13gp,q,13hg,,13hh,q,13i8,,13i9,q,13j0,,13j1,q,13js,,13jt,q,13kk,,13kl,q,13lc,,13ld,q,13m4,,13m5,q,13mw,,13mx,q,13no,,13np,q,13og,,13oh,q,13p8,,13p9,q,13q0,,13q1,q,13qs,,13qt,q,13rk,,13rl,q,13sc,,13sd,q,13t4,,13t5,q,13tw,,13tx,q,13uo,,13up,q,13vg,,13vh,q,13w8,,13w9,q,13x0,,13x1,q,13xs,,13xt,q,13yk,,13yl,q,13zc,,13zd,q,1404,,1405,q,140w,,140x,q,141o,,141p,q,142g,,142h,q,1438,,1439,q,1440,,1441,q,144s,,144t,q,145k,,145l,q,146c,,146d,q,1474,,1475,q,147w,,147x,q,148o,,148p,q,149g,,149h,q,14a8,,14a9,q,14b0,,14b1,q,14bs,,14bt,q,14ck,,14cl,q,14dc,,14dd,q,14e4,,14e5,q,14ew,,14ex,q,14fo,,14fp,q,14gg,,14gh,q,14h8,,14h9,q,14i0,,14i1,q,14is,,14it,q,14jk,,14jl,q,14kc,,14kd,q,14l4,,14l5,q,14lw,,14lx,q,14mo,,14mp,q,14ng,,14nh,q,14o8,,14o9,q,14p0,,14p1,q,14ps,,14pt,q,14qk,,14ql,q,14rc,,14rd,q,14s4,,14s5,q,14sw,,14sx,q,14to,,14tp,q,14ug,,14uh,q,14v8,,14v9,q,14w0,,14w1,q,14ws,,14wt,q,14xk,,14xl,q,14yc,,14yd,q,14z4,,14z5,q,14zw,,14zx,q,150o,,150p,q,151g,,151h,q,1528,,1529,q,1530,,1531,q,153s,,153t,q,154k,,154l,q,155c,,155d,q,1564,,1565,q,156w,,156x,q,157o,,157p,q,158g,,158h,q,1598,,1599,q,15a0,,15a1,q,15as,,15at,q,15bk,,15bl,q,15cc,,15cd,q,15d4,,15d5,q,15dw,,15dx,q,15eo,,15ep,q,15fg,,15fh,q,15g8,,15g9,q,15h0,,15h1,q,15hs,,15ht,q,15ik,,15il,q,15jc,,15jd,q,15k4,,15k5,q,15kw,,15kx,q,15lo,,15lp,q,15mg,,15mh,q,15n8,,15n9,q,15o0,,15o1,q,15os,,15ot,q,15pk,,15pl,q,15qc,,15qd,q,15r4,,15r5,q,15rw,,15rx,q,15so,,15sp,q,15tg,,15th,q,15u8,,15u9,q,15v0,,15v1,q,15vs,,15vt,q,15wk,,15wl,q,15xc,,15xd,q,15y4,,15y5,q,15yw,,15yx,q,15zo,,15zp,q,160g,,160h,q,1618,,1619,q,1620,,1621,q,162s,,162t,q,163k,,163l,q,164c,,164d,q,1654,,1655,q,165w,,165x,q,166o,,166p,q,167g,,167h,q,1688,,1689,q,1690,,1691,q,169s,,169t,q,16ak,,16al,q,16bc,,16bd,q,16c4,,16c5,q,16cw,,16cx,q,16do,,16dp,q,16eg,,16eh,q,16f8,,16f9,q,16g0,,16g1,q,16gs,,16gt,q,16hk,,16hl,q,16ic,,16id,q,16j4,,16j5,q,16jw,,16jx,q,16ko,,16kp,q,16ls,m,16mj,1c,1dlq,,1e68,f,1e74,f,1edb,,1ehq,1,1ek0,b,1eyl,,1f4w,,1f92,4,1gjl,2,1gjp,1,1gjw,3,1gl4,2,1glb,,1gpx,1,1h5w,3,1h7t,4,1hgr,1,1hj0,3,1hl2,a,1hmq,3,1hq8,,1hq9,,1hqa,,1hrs,e,1htc,,1htf,1,1htr,2,1htu,,1hv4,2,1hv7,3,1hvb,1,1hvd,1,1hvh,,1hvm,,1hvx,,1hxc,2,1hyf,4,1hyk,,1hyl,7,1hz9,1,1i0j,,1i0w,1,1i0y,,1i2b,2,1i2e,8,1i2n,,1i2o,,1i2q,1,1i2x,3,1i32,,1i33,,1i5o,2,1i5r,2,1i5u,1,1i5w,3,1i66,,1i69,,1ian,,1iao,2,1iar,7,1ibk,1,1ibm,1,1id7,1,1ida,,1idb,,1idc,,1idd,3,1idj,1,1idn,1,1idp,,1idz,,1iea,1,1iee,6,1ieo,4,1igo,,1igp,1,1igr,5,1igy,,1ih1,,1ih3,2,1ih6,,1ih8,1,1iha,2,1ihd,,1ihe,,1iht,1,1ik5,2,1ik8,7,1ikg,1,1iki,2,1ikl,,1ikm,,1ila,,1ink,,1inl,1,1inn,5,1int,,1inu,,1inv,1,1inx,,1iny,,1inz,1,1io1,,1io2,1,1iun,,1iuo,1,1iuq,3,1iuw,3,1iv0,1,1iv2,,1iv3,1,1ivw,1,1iy8,2,1iyb,7,1iyj,1,1iyl,,1iym,,1iyn,1,1j1n,,1j1o,,1j1p,,1j1q,1,1j1s,7,1j4t,,1j4u,,1j4v,,1j4y,3,1j52,,1j53,4,1jcc,2,1jcf,8,1jco,,1jcp,1,1jjk,,1jjl,4,1jjr,1,1jjv,3,1jjz,,1jk0,,1jk1,,1jk2,,1jk3,,1jo1,2,1jo4,3,1joa,1,1joc,3,1jog,,1jok,,1jpd,9,1jqr,5,1jqx,,1jqy,,1jqz,3,1jrb,,1jrl,5,1jrr,1,1jrt,2,1jt0,5,1jt6,c,1jtj,,1jtk,1,1k4v,,1k4w,6,1k54,5,1k5a,,1k5b,,1k7m,l,1k89,,1k8a,6,1k8h,,1k8i,1,1k8k,,1k8l,1,1kc1,5,1kca,,1kcc,1,1kcf,6,1kcm,,1kcn,,1kei,4,1keo,1,1ker,1,1ket,,1keu,,1kev,,1koj,1,1kol,1,1kow,1,1koy,,1koz,,1kqc,1,1kqe,4,1kqm,1,1kqo,2,1kre,,1ovk,f,1ow0,,1ow7,e,1xr2,b,1xre,2,1xrh,2,1zow,4,1zqo,6,206b,,206f,3,20jz,,20k1,1i,20lr,3,20o4,,20og,1,2ftp,1,2fts,3,2jgg,19,2jhs,m,2jxh,4,2jxp,5,2jxv,7,2jy3,7,2jyd,6,2jze,3,2k3m,2,2lmo,1i,2lob,1d,2lpx,,2lqc,,2lqz,4,2lr5,e,2mtc,6,2mtk,g,2mu3,6,2mub,1,2mue,4,2mxb,,2n1s,6,2nce,,2ne4,3,2nsc,3,2nzi,1,2ok0,6,2on8,6,2pz4,73,2q6l,2,2q7j,,2q98,5,2q9q,1,2qa6,,2qa9,9,2qb1,1k,2qcm,p,2qdd,e,2qe2,,2qen,,2qeq,8,2qf0,3,2qfd,c1,2qrf,4,2qrk,8t,2r0m,7d,2r9c,3j,2rg4,b,2rit,16,2rkc,3,2rm0,7,2rmi,5,2rns,7,2rou,29,2rrg,1a,2rss,9,2rt3,c8,2scg,sd,jny8,v,jnz4,2n,jo1s,3j,jo5c,6n,joc0,2rz",
  "262122424333333393233393339333333333393393b3b3b3b3b333b33b3bb33333b3b3333333b3b33bb3333b33b3bb33333b3bbb333b333b33333b3b3b3b3333b3b33b3bb39333b33b33b3b3b333b333333b3b333333b33b3b3333b3335dc333333b3b3b33323333b3bb3b33b3b3b3333b3333b3b333bb3b33b3b3b3b3b333b333b3323e2244234444444444444444444444444444444444444444443333443443333333b3b3bb33333b353b3b3b3b333b3b333b333333b3bb3b3b3bb3787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878dc333232333333333333333b3b3333bb3b393933b3b33bb3b393b3b3b3333b33b33b3bbb33b333b3333bb3933b3b3b333b3b3b3b3b33b3b3b33b3b3b33b3b33b33b3b3b33bb39b9b3b33b3b33b9333b393b3b33b33b3b3b3333393b3b3b33b39bb3b332333b333dd3b33332333323333333333333333333333344444444a44444434444444444444423232"
), iB = Mg(
  /** @type {UnicodeDataEncoding} */
  "1sl,10,1ug,7,1vc,7,1w5,j,1wq,6,1wy,,1x2,3,1y4,1,1y7,,1yo,1,239,j,23u,6,242,1,245,4,261,,26t,j,27e,6,27m,1,27p,4,28s,1,28v,,29d,,2dx,j,2ei,f,2fs,2,2l1,11"
);
function* oB(t) {
  if (t === "")
    return;
  let A = 0, e = t.length, i = null, o = null, r = null, n = [
    0,
    0,
    2
    /* GC_Control */
  ], s = 0, a = !1, g = !1, I = !1, c = !1, C = (
    /** @type number */
    t.codePointAt(A)
  ), B = 0, Q = "";
  for (; ; ) {
    if (Q += t[A++], tB(C) || (Q += t[A++]), i = o, i === null && (i = ss(C, n), r = i), !g && i === 0 ? g = as(C) : i === 3 && (I = rB(C)), A < e)
      C = /** @type {number} */
      t.codePointAt(A), o = ss(C, n);
    else {
      yield {
        segment: Q,
        index: B,
        input: t,
        _catBegin: (
          /** @type {typeof catBefore} */
          r
        ),
        _catEnd: i
      };
      return;
    }
    i === 10 ? s += 1 : (s = 0, o === 14 && (i === 3 || i === 4) ? a = !0 : o === 0 && (c = g && I && (g = as(C)), I = I && !g)), nB(i, o, s, a, c) && (yield {
      segment: Q,
      index: B,
      input: t,
      _catBegin: (
        /** @type {typeof catBefore} */
        r
      ),
      _catEnd: i
    }, B = A, Q = "", a = !1, c = !1, r = o);
  }
}
function* jo(t) {
  for (let A of oB(t)) yield A.segment;
}
function ss(t, A) {
  if (t < 127)
    return t >= 32 ? 0 : t === 10 ? 6 : t === 13 ? 1 : 2;
  if (t < A[0] || t > A[1]) {
    let e = Gg(t, ns);
    if (e < 0)
      return 0;
    let i = ns[e];
    A[0] = i[0], A[1] = i[1], A[2] = i[2];
  }
  return A[2];
}
function as(t) {
  return Gg(t, iB) >= 0;
}
function rB(t) {
  return t === 2381 || t === 2509 || t === 2765 || t === 2893 || t === 3149 || t === 3405;
}
function nB(t, A, e, i, o) {
  return t === 1 && A === 6 ? !1 : t === 1 || t === 2 || t === 6 || A === 1 || A === 2 || A === 6 ? !0 : t === 5 && (A === 5 || A === 7 || A === 8 || A === 13) || (t === 7 || t === 13) && (A === 12 || A === 13) || A === 12 && (t === 8 || t === 12) || A === 3 || A === 14 || A === 11 || t === 9 || A === 0 && o ? !1 : t === 14 && A === 4 ? !i : t === 10 && A === 10 ? e % 2 === 0 : !0;
}
const pr = {
  MAX_RECOMMENDED_TX_SIZE: 100 * 1024
}, At = {
  MAX_RETRIES: 1,
  TIMEOUT: 6e4,
  RETRY_DELAY: 3e3,
  MAX_IN_FLIGHT_LOADS_PER_PEER: 1e3
}, sB = {
  INCOMING_MESSAGES_TIME_BUDGET: 50
}, gs = {
  MAX_AGE: 1e3 * 60 * 10,
  // 10 minutes
  INTERVAL: 1e3 * 60 * 5
  // 5 minutes
}, aB = {
  MAX_OUTGOING_MESSAGES_CHUNK_BYTES: 25e3
};
function Is(t) {
  return `${t.sessionID}:${t.txIndex}:${t.changeIdx}`;
}
class nn extends Tt {
  constructor(A, e) {
    super(A, e), this.type = "coplaintext", this._cachedMapping = /* @__PURE__ */ new WeakMap();
  }
  get mapping() {
    const A = this.entries();
    let e = this._cachedMapping.get(A);
    if (e)
      return e;
    e = {
      opIDbeforeIdx: [],
      opIDafterIdx: [],
      idxAfterOpID: {},
      idxBeforeOpID: {}
    };
    let i = 0;
    for (const o of A) {
      const r = i + 1;
      e.opIDafterIdx[i] = o.opID, e.opIDbeforeIdx[r] = o.opID, e.idxAfterOpID[Is(o.opID)] = r, e.idxBeforeOpID[Is(o.opID)] = i, i = r;
    }
    return this._cachedMapping.set(A, e), e;
  }
  toString() {
    return this.entries().map((A) => A.value).join("");
  }
  atTime(A) {
    return new nn(this.core, A);
  }
  /**
   * Inserts `text` before the character at index `idx`.
   * If idx is 0, inserts at the start of the text.
   *
   * @param idx - The index of the character to insert before
   * @param text - The text to insert
   * @param privacy - Whether the operation should be private or trusting
   * @category 2. Editing
   */
  insertBefore(A, e, i = "private") {
    const o = Array.from(jo(e));
    if (A === 0) {
      const r = o[0];
      r && this.prepend(r, 0, i), o.length > 1 && this.appendChars(o.slice(1), 0, i);
    } else
      this.appendChars(o, A - 1, i);
  }
  appendChars(A, e, i = "private") {
    const o = gB(A);
    for (const r of o)
      this.appendItems(r, e, i), e += r.length;
  }
  /**
   * Inserts `text` after the character at index `idx`.
   *
   * @param idx - The index of the character to insert after
   * @param text - The text to insert
   * @param privacy - Whether the operation should be private or trusting
   * @category 2. Editing
   */
  insertAfter(A, e, i = "private") {
    const o = Array.from(jo(e));
    A >= this.entries().length ? this.appendChars(o, A - 1, i) : this.appendChars(o, A, i);
  }
  deleteRange({ from: A, to: e }, i = "private") {
    const o = [];
    for (let r = A; r < e; ) {
      const n = this.mapping.opIDafterIdx[r];
      if (!n)
        throw new Error("Invalid idx to delete " + r);
      o.push({
        op: "del",
        insertion: n
      });
      let s = r + 1;
      for (; !this.mapping.opIDbeforeIdx[s] && s < e; )
        s++;
      r = s;
    }
    this.core.makeTransaction(o, i), this.processNewTransactions();
  }
  /** @internal Helper method to split text into graphemes */
  toGraphemes(A) {
    return [...jo(A)];
  }
  /** @internal Helper method to join graphemes into a string */
  fromGraphemes(A) {
    return A.join("");
  }
}
function gB(t) {
  const A = Math.ceil(pr.MAX_RECOMMENDED_TX_SIZE / 200), e = [];
  for (let i = 0; i < t.length; i += A)
    e.push(t.slice(i, i + A));
  return e;
}
function IB(t, A) {
  return t.verified.header.type === "comap" ? t.verified.header.ruleset.type === "group" ? t.verified.header.meta?.type === "account" && !A?.ignorePrivateTransactions ? new rn(t) : new on(t, A) : new tn(t) : t.verified.header.type === "coplaintext" ? new nn(t) : t.verified.header.type === "colist" ? new Tt(t) : t.verified.header.type === "costream" ? t.verified.header.meta && t.verified.header.meta.type === "binary" ? new Dg(t) : new yg(t) : new wC(t);
}
function sn(t, A = /* @__PURE__ */ new Set()) {
  return t.ruleset.type === "ownedByGroup" && A.add(t.ruleset.group), t.meta?.source && A.add(t.meta.source), A;
}
function Fg(t, A) {
  for (const e of t) {
    const i = OA(e);
    en(i) && A.add(i);
  }
}
function an(t, A = /* @__PURE__ */ new Set()) {
  for (const e of t) {
    if (e.privacy !== "trusting")
      continue;
    const i = BB(e.changes);
    for (const o of i)
      if (o && typeof o == "object" && "op" in o && o.op === "set" && "key" in o && o.key) {
        const r = YC(o.key);
        r && A.add(r);
      }
  }
  return A;
}
function cB(t, A, e, i) {
  const o = /* @__PURE__ */ new Set();
  if (sn(A, o), Fg(e, o), A.ruleset.type === "group")
    for (const r of i)
      an(r, o);
  return o.delete(t), o;
}
function CB(t, A) {
  const e = /* @__PURE__ */ new Set();
  A.header && sn(A.header, e);
  const i = Object.keys(A.new);
  if (Fg(i, e), (t.verified?.header ?? A.header)?.ruleset.type === "group")
    for (const { newTransactions: r } of Object.values(A.new))
      an(r, e);
  return e.delete(t.id), e;
}
function BB(t) {
  try {
    return so(t);
  } catch {
    return [];
  }
}
function Je(t) {
  return {
    id: t,
    header: !1,
    sessions: {}
  };
}
function Vo(t) {
  return {
    id: t.id,
    header: t.header,
    sessions: t.sessions
  };
}
function $o(t, A) {
  return ot(t.sessions, A.sessions), A.header && !t.header && (t.header = !0), t;
}
function ot(t, A) {
  for (const [e, i] of Object.entries(A)) {
    const o = t[e] || 0;
    i > o && (t[e] = i);
  }
  return t;
}
function Wo(t, A, e) {
  t[A] = e;
}
function cs(t, A, e) {
  t[A] = Math.max(t[A] || 0, e);
}
function Se(t) {
  return {
    id: t.id,
    header: t.header,
    sessions: { ...t.sessions }
  };
}
function bg(t, A) {
  for (const [e, i] of Object.entries(t)) {
    const o = A[e] ?? 0;
    if (i !== o)
      return !1;
  }
  return !0;
}
function wr(t, A) {
  for (const [e, i] of Object.entries(t)) {
    const o = A[e] ?? 0;
    if (i > o)
      return !1;
  }
  return !0;
}
function QB(t, A) {
  return !A || !A.header && t.header ? !1 : wr(t.sessions, A.sessions);
}
function Rg(t, A) {
  const e = {};
  for (const [i, o] of Object.entries(t)) {
    const r = A[i] ?? 0;
    o > r && (e[i] = o);
  }
  return e;
}
const TA = {
  HIGH: 0,
  MEDIUM: 3,
  LOW: 6
};
function EB(t) {
  return typeof t == "boolean" || !t ? TA.MEDIUM : t.meta?.type === "account" || t.ruleset.type === "group" ? TA.HIGH : t.type === "costream" && t.meta?.type === "binary" ? TA.LOW : TA.MEDIUM;
}
function Mt(t, A, e = !0) {
  return {
    action: "content",
    id: t,
    header: e ? A : void 0,
    priority: EB(A),
    new: {}
  };
}
function zo(t, A, e, i, o) {
  const r = t.new[e];
  r ? (r.newTransactions.push(A), r.lastSignature = i) : t.new[e] = {
    after: o,
    newTransactions: [A],
    lastSignature: i
  };
}
function lo(t) {
  return t.privacy === "private" ? t.encryptedChanges.length : t.changes.length;
}
function go(t, A) {
  return A === void 0 ? t > pr.MAX_RECOMMENDED_TX_SIZE : t + A > pr.MAX_RECOMMENDED_TX_SIZE;
}
function Xt(t) {
  const A = Je(t.id);
  A.header = !!t.header;
  for (const [e, i] of Object.entries(t.new))
    A.sessions[e] = i.after + i.newTransactions.length;
  return A;
}
function lB(t) {
  return Object.values(t.new).reduce((A, e) => A + e.newTransactions.reduce((i, o) => i + lo(o), 0), 0);
}
function _o(t) {
  return Object.entries(t.new).map(([A, e]) => `Session: ${A} After: ${e.after} New: ${e.newTransactions.length}`);
}
function dB(t, A, e) {
  const i = A.sessions[e] ?? 0, o = t.after;
  if (i < o)
    return;
  const r = i - o;
  return t.newTransactions.slice(r);
}
function uB(t) {
  return Object.entries(t.new);
}
class uo {
  constructor(A, e, i) {
    this.id = A, this.crypto = e, this.isDeleted = !1, this.sessions = /* @__PURE__ */ new Map(), this.knownState = { id: this.id, header: !0, sessions: {} }, i && (this.streamingKnownState = { ...i }, this.knownStateWithStreaming = {
      id: this.id,
      header: !0,
      sessions: { ...i }
    });
  }
  markAsDeleted() {
    this.isDeleted = !0, this.knownState = { id: this.id, header: !0, sessions: {} }, this.knownStateWithStreaming = void 0, this.streamingKnownState = void 0, this.invalidateKnownStateCache();
    for (const [A, e] of this.sessions.entries())
      ve(A) && (this.knownState.sessions[A] = e.transactions.length);
  }
  setStreamingKnownState(A) {
    if (this.isDeleted || wr(A, this.knownState.sessions))
      return;
    const e = Rg(A, this.knownState.sessions);
    this.streamingKnownState ? ot(this.streamingKnownState, e) : this.streamingKnownState = e, this.knownStateWithStreaming || (this.knownStateWithStreaming = Se(this.knownState)), ot(this.knownStateWithStreaming.sessions, e);
  }
  invalidateKnownStateCache() {
    this.immutableKnownState = void 0, this.immutableKnownStateWithStreaming = void 0;
  }
  getImmutableKnownState() {
    return this.immutableKnownState || (this.immutableKnownState = Se(this.knownState)), this.immutableKnownState;
  }
  getImmutableKnownStateWithStreaming() {
    return this.knownStateWithStreaming ? (this.immutableKnownStateWithStreaming || (this.immutableKnownStateWithStreaming = Se(this.knownStateWithStreaming)), this.immutableKnownStateWithStreaming) : this.getImmutableKnownState();
  }
  get(A) {
    return this.sessions.get(A);
  }
  getOrCreateSessionLog(A, e) {
    let i = this.sessions.get(A);
    return i || (i = {
      signerID: e,
      impl: this.crypto.createSessionLog(this.id, A, e),
      transactions: [],
      lastSignature: void 0,
      signatureAfter: {},
      txSizeSinceLastInbetweenSignature: 0,
      sessionID: A
    }, this.sessions.set(A, i)), i;
  }
  addTransaction(A, e, i, o, r = !1) {
    if (this.isDeleted && !ve(A))
      throw new Error("Cannot add transactions to a deleted coValue");
    const n = this.getOrCreateSessionLog(A, e);
    n.impl.tryAdd(i, o, r), this.addTransactionsToJsLog(n, i, o);
  }
  makeNewPrivateTransaction(A, e, i, o, r, n, s) {
    if (this.isDeleted)
      throw new Error("Cannot make new private transaction on a deleted coValue");
    const a = this.getOrCreateSessionLog(A, e.currentSignerID()), g = a.impl.addNewPrivateTransaction(e, i, o, r, s, n);
    return this.addTransactionsToJsLog(a, [g.transaction], g.signature), g;
  }
  makeNewTrustingTransaction(A, e, i, o, r) {
    if (this.isDeleted)
      throw new Error("Cannot make new trusting transaction on a deleted coValue");
    const n = this.getOrCreateSessionLog(A, e.currentSignerID()), s = n.impl.addNewTrustingTransaction(e, i, r, o);
    return this.addTransactionsToJsLog(n, [s.transaction], s.signature), s;
  }
  addTransactionsToJsLog(A, e, i) {
    for (const r of e)
      A.transactions.push(r);
    A.lastSignature = i, A.txSizeSinceLastInbetweenSignature += e.reduce((r, n) => r + (n.privacy === "private" ? n.encryptedChanges.length : n.changes.length), 0);
    const o = A.transactions.length;
    go(A.txSizeSinceLastInbetweenSignature) && (A.signatureAfter[o - 1] = i, A.txSizeSinceLastInbetweenSignature = 0), cs(this.knownState.sessions, A.sessionID, o), this.streamingKnownState && wr(this.streamingKnownState, this.knownState.sessions) && (this.streamingKnownState = void 0, this.knownStateWithStreaming = void 0), this.knownStateWithStreaming && cs(this.knownStateWithStreaming.sessions, A.sessionID, o), this.invalidateKnownStateCache();
  }
  decryptTransaction(A, e, i) {
    const o = this.sessions.get(A);
    if (!o)
      return;
    const r = o.impl.decryptNextTransactionChangesJson(e, i);
    if (r)
      return so(r);
  }
  decryptTransactionMeta(A, e, i) {
    const o = this.sessions.get(A);
    if (!o?.transactions[e]?.meta)
      return;
    const r = o.impl.decryptNextTransactionMetaJson(e, i);
    if (r)
      return so(r);
  }
  get size() {
    return this.sessions.size;
  }
  entries() {
    return this.sessions.entries();
  }
  values() {
    return this.sessions.values();
  }
  keys() {
    return this.sessions.keys();
  }
  clone() {
    const A = new uo(this.id, this.crypto);
    for (const [e, i] of this.sessions)
      A.sessions.set(e, {
        impl: i.impl.clone(),
        transactions: i.transactions.slice(),
        lastSignature: i.lastSignature,
        signatureAfter: { ...i.signatureAfter },
        txSizeSinceLastInbetweenSignature: i.txSizeSinceLastInbetweenSignature,
        signerID: i.signerID,
        sessionID: e
      });
    return A.streamingKnownState = this.streamingKnownState ? { ...this.streamingKnownState } : void 0, A.knownState = Se(this.knownState), A.knownStateWithStreaming = this.knownStateWithStreaming ? Se(this.knownStateWithStreaming) : void 0, A;
  }
}
class gn {
  constructor(A, e, i, o) {
    this.isDeleted = !1, this.id = A, this.crypto = e, this.header = i, this.sessions = o ?? new uo(A, e), this.branchSourceId = i.meta?.source, this.branchName = i.meta?.branch;
  }
  clone() {
    return new gn(this.id, this.crypto, this.header, this.sessions.clone());
  }
  markAsDeleted() {
    this.isDeleted = !0, this.sessions.markAsDeleted();
  }
  tryAddTransactions(A, e, i, o, r = !1) {
    this.sessions.addTransaction(A, e, i, o, r);
  }
  makeNewTrustingTransaction(A, e, i, o, r) {
    return this.sessions.makeNewTrustingTransaction(A, e, i, o, r);
  }
  makeNewPrivateTransaction(A, e, i, o, r, n, s) {
    return this.sessions.makeNewPrivateTransaction(A, e, i, o, r, n, s);
  }
  getLastSignatureCheckpoint(A) {
    const e = this.sessions.get(A);
    return e?.signatureAfter ? Object.keys(e.signatureAfter).reduce((i, o) => Math.max(i, parseInt(o)), -1) : -1;
  }
  setStreamingKnownState(A) {
    this.sessions.setStreamingKnownState(A);
  }
  newContentSince(A) {
    let e = Mt(this.id, this.header, !1);
    const i = [e];
    let o = 0;
    const r = () => {
      e = Mt(this.id, this.header, !1), i.push(e), o = 0;
    }, n = (c) => {
      const C = e.new[c];
      if (!C)
        throw new Error("Session content not found", {
          cause: {
            sessionID: c,
            currentPiece: e
          }
        });
      delete e.new[c];
      const B = Mt(this.id, this.header, !1);
      B.new[c] = C, i.splice(i.length - 1, 0, B);
    }, s = A?.sessions;
    for (const [c, C] of this.sessions.sessions) {
      if (this.isDeleted && !ve(c))
        continue;
      const B = s?.[c] ?? 0;
      let Q = 0;
      for (let f = B; f < C.transactions.length; f++) {
        const l = f === C.transactions.length - 1, u = C.transactions[f];
        Q += lo(u);
        const d = C.signatureAfter[f];
        if (d)
          zo(e, u, c, d, f), n(c), Q = 0;
        else if (l) {
          if (!C.lastSignature)
            throw new Error("All the SessionLogs sent must have a lastSignature", {
              cause: C
            });
          zo(e, u, c, C.lastSignature, f), go(Q) ? (Zo(c, e), n(c)) : go(o, Q) ? (Zo(c, e), r()) : o += Q;
        } else
          zo(e, u, c, void 0, f);
      }
      Zo(c, e);
    }
    const a = i[0];
    if (!a)
      throw new Error("First piece not found", {
        cause: i
      });
    !A?.header && (a.header = this.header);
    const I = i.filter((c) => c.header || Object.keys(c.new).length > 0);
    if ((I.length > 1 || this.isStreaming()) && (A ? a.expectContentUntil = Rg(this.knownStateWithStreaming().sessions, A.sessions) : a.expectContentUntil = {
      ...this.knownStateWithStreaming().sessions
    }), I.length !== 0)
      return I;
  }
  knownState() {
    return this.sessions.knownState;
  }
  knownStateWithStreaming() {
    return this.sessions.knownStateWithStreaming ?? this.knownState();
  }
  immutableKnownState() {
    return this.sessions.getImmutableKnownState();
  }
  immutableKnownStateWithStreaming() {
    return this.sessions.getImmutableKnownStateWithStreaming();
  }
  isStreaming() {
    return !!this.sessions.knownStateWithStreaming;
  }
  decryptTransaction(A, e, i) {
    return this.sessions.decryptTransaction(A, e, i);
  }
  decryptTransactionMeta(A, e, i) {
    return this.sessions.decryptTransactionMeta(A, e, i);
  }
}
function Zo(t, A) {
  if (A.new[t] && !A.new[t].lastSignature)
    throw new Error("The SessionContent sent must have a lastSignature", {
      cause: A.new[t]
    });
}
function Kg({ type: t, branchName: A, ownerId: e, sourceId: i }) {
  return {
    type: t,
    // Branch name and source id are stored in the meta field
    // and used to generate the unique id for the branch
    meta: {
      branch: A,
      source: i
    },
    ruleset: {
      type: "ownedByGroup",
      // The owner is part of the id generation, making it possible to have multiple branches with the same name
      // but different owners
      group: e
    },
    // The meta is enough to have reproducible unique id for the branch
    uniqueness: ""
  };
}
function vg(t) {
  return t.verified?.header.ruleset.type === "ownedByGroup";
}
function hB(t, A, e) {
  if (!t.verified)
    throw new Error("CoValueCore: getBranchId called on coValue without verified state");
  const i = e ?? In(t);
  if (!i)
    return t.id;
  const o = Kg({
    type: t.verified.header.type,
    branchName: A,
    ownerId: i,
    sourceId: t.id
  });
  return Yt(o, t.node.crypto);
}
function In(t) {
  if (!t.verified)
    throw new Error("CoValueCore: getBranchOwnerId called on coValue without verified state");
  const A = t.verified.header;
  if (A.ruleset.type === "ownedByGroup")
    return A.ruleset.group;
}
function fB(t, A, e) {
  if (!t.verified)
    throw new Error("CoValueCore: createBranch called on coValue without verified state");
  const i = e ?? In(t);
  if (!i)
    return t;
  const o = t.safeGetGroup()?.myRole();
  if (!o || o === "reader" && !e)
    return AA.warn("Trying to create a branch without enough access rights, returning the source coValue"), t;
  const r = o === "reader" ? "trusting" : "private", n = Kg({
    type: t.verified.header.type,
    branchName: A,
    ownerId: i,
    sourceId: t.id
  }), s = t.node.createCoValue(n), a = { ...t.knownState().sessions };
  return s.makeTransaction([], "private", {
    from: a
  }), t.makeTransaction([], r, {
    branch: A,
    ownerId: e
  }), s;
}
function Yg(t) {
  if (!t.verified)
    return;
  const A = t.getCurrentBranchSourceId();
  if (!A)
    return;
  const e = t.node.getCoValue(A);
  if (e.isAvailable())
    return e;
}
function pB(t) {
  if (!t.verified)
    throw new Error("CoValueCore: mergeBranch called on coValue without verified state");
  if (!vg(t))
    return t;
  const A = Yg(t);
  if (!A)
    throw new Error("CoValueCore: unable to find source branch");
  let e = {};
  for (const c of A.getMergeCommits())
    c.branch === t.id && ot(e, c.merged);
  const i = t.getValidTransactions({
    from: e,
    ignorePrivateTransactions: !1,
    skipBranchSource: !0
  }).filter((c) => c.changes.length > 0);
  if (i.length === 0)
    return A;
  let o, r, n = 0;
  const s = Date.now();
  for (const c of i) {
    const C = {
      mi: c.txID.txIndex
    };
    c.madeAt !== n && (C.t = s - c.madeAt), o !== c.txID.sessionID && (C.s = c.txID.sessionID), r !== c.txID.branch && (C.b = c.txID.branch), A.makeTransaction(c.changes, c.tx.privacy, C, s), o = c.txID.sessionID, r = c.txID.branch, n = c.madeAt;
  }
  const a = t.knownState().sessions, g = e, I = {};
  for (const [c, C] of Object.entries(a))
    (g[c] ?? 0) < C && (I[c] = C);
  return A.makeTransaction([], "private", {
    merged: I,
    branch: t.id
  }), A;
}
function wB(t, A) {
  if (!A.isValid || A.tx.privacy === "trusting")
    return;
  const e = !A.changes, i = !A.meta && A.tx.meta;
  if (!e && !i)
    return;
  const o = t.getReadKey(A.tx.keyUsed);
  if (o) {
    if (e) {
      const r = t.verified.decryptTransaction(A.txID.sessionID, A.txID.txIndex, o);
      r && (A.changes = r);
    }
    if (i) {
      const r = t.verified.decryptTransactionMeta(A.txID.sessionID, A.txID.txIndex, o);
      r && (A.meta = r);
    }
  }
}
var xA = function(t, A, e, i) {
  if (e === "a" && !i) throw new TypeError("Private accessor was defined without a getter");
  if (typeof A == "function" ? t !== A || !i : !A.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return e === "m" ? i : e === "a" ? i.call(t) : i ? i.value : A.get(t);
}, qA = function(t, A, e, i, o) {
  if (i === "m") throw new TypeError("Private method is not writable");
  if (i === "a" && !o) throw new TypeError("Private accessor was defined without a setter");
  if (typeof A == "function" ? t !== A || !o : !A.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return i === "a" ? o.call(t, e) : o ? o.value = e : A.set(t, e), e;
}, Me, we, ye, Ug, yr, Cs, Bs, wt, yt, Dt;
function yB(t) {
  if (typeof t == "number" && !Number.isInteger(t))
    return {
      isOk: !1,
      message: "Uniqueness cannot be a non-integer number, got " + t
    };
  if (Array.isArray(t))
    return {
      isOk: !1,
      message: "Uniqueness cannot be an array, got " + t
    };
  if (typeof t == "object" && t !== null) {
    for (let [A, e] of Object.entries(t))
      if (typeof e != "string")
        return {
          isOk: !1,
          message: "Uniqueness object values must be a string, got " + e + " for key " + A
        };
  }
  return { isOk: !0 };
}
function Yt(t, A) {
  return `co_z${A.shortHash(t).slice(11)}`;
}
class DB {
  constructor(A, e, i, o, r, n, s, a) {
    this.isValidated = !1, this.isValid = !1, this.validationErrorMessage = void 0, this.dispatchTransaction = a, this.author = OA(e);
    const g = r ? {
      sessionID: e,
      txIndex: i,
      branch: r
    } : {
      sessionID: e,
      txIndex: i
    };
    this.coValueId = A, this.currentTxID = g, this.sourceTxID = void 0, this.tx = o, this.currentMadeAt = o.madeAt, this.sourceTxMadeAt = void 0, this.previous = s, n ? (this.changes = n.changes, this.meta = n.meta) : this.tx.privacy === "trusting" && (this.changes = fr(this.tx.changes), this.tx.meta && (this.meta = fr(this.tx.meta)));
  }
  // The TxID that refers to the current position in the session map
  // If this is a merged transaction, the txID is the TxID of the merged transaction
  get txID() {
    return this.sourceTxID ?? this.currentTxID;
  }
  // The madeAt that refers to the time when the transaction was made
  // If this is a merged transaction, the madeAt is the time when the transaction has been made in the branch
  get madeAt() {
    return this.sourceTxMadeAt ?? this.currentMadeAt;
  }
  isValidTransactionWithChanges() {
    return !!(this.isValid && this.changes);
  }
  markValid() {
    this.isValid = !0, this.validationErrorMessage = void 0, this.isValidated || (this.isValidated = !0, this.dispatchTransaction(this));
  }
  markInvalid(A, e) {
    this.isValidated = !0, this.isValid = !1, this.validationErrorMessage = A;
  }
}
class Qs {
  /** Holds the fundamental syncable content of a CoValue,
   * consisting of the header (verified by hash -> RawCoID)
   * and the sessions (verified by signature).
   *
   * It does not do any *validation* or *decryption* and as such doesn't
   * depend on other CoValues or the LocalNode.
   *
   * `CoValueCore.verified` may be null when a CoValue is requested to be
   * loaded but no content has been received from storage or peers yet.
   * In this case, it acts as a centralised entry to keep track of peer loading
   * state and to subscribe to its content when it does become available. */
  get verified() {
    return this._verified;
  }
  constructor(A, e) {
    Me.add(this), this.isDeleted = !1, this.loadingStatuses = /* @__PURE__ */ new Map(), we.set(this, void 0), ye.set(this, void 0), this.listeners = /* @__PURE__ */ new Set(), this.missingDependencies = /* @__PURE__ */ new Set(), this.newContentQueue = [], wt.set(this, !1), yt.set(this, !1), Dt.set(this, !1), this.mergeCommits = [], this.branches = [], this.earliestTxMadeAt = Number.MAX_SAFE_INTEGER, this.latestTxMadeAt = 0, this.verifiedTransactions = [], this.toValidateTransactions = [], this.toDecryptTransactions = [], this.toParseMetaTransactions = [], this.toProcessTransactions = [], this.verifiedTransactionsKnownSessions = {}, this.lastVerifiedTransactionBySessionID = {}, this.parsingCache = /* @__PURE__ */ new Map(), this.dispatchTransaction = (i) => {
      if (!i.isValidated) {
        this.toValidateTransactions.push(i);
        return;
      }
      i.changes ? this.toProcessTransactions.push(i) : this.toDecryptTransactions.push(i), i.meta && this.toParseMetaTransactions.push(i);
    }, this.dependencies = /* @__PURE__ */ new Set(), this.incompleteDependencies = /* @__PURE__ */ new Set(), this.dependant = /* @__PURE__ */ new Set(), this.readKeyCache = /* @__PURE__ */ new Map(), this.crypto = e.crypto, this.id = A, this._verified = null, this.node = e, this.counter = ge.getMeter("cojson").createUpDownCounter("jazz.covalues.loaded", {
      description: "The number of covalues in the system",
      unit: "covalue",
      valueType: WA.INT
    }), this.updateCounter(null);
  }
  get loadingState() {
    if (this.verified)
      return "available";
    for (const A of this.loadingStatuses.values())
      if (A.type === "pending")
        return "loading";
    if (xA(this, we, "f"))
      return xA(this, we, "f");
    if (this.loadingStatuses.size === 0)
      return "unknown";
    for (const A of this.loadingStatuses.values())
      if (A.type === "unknown")
        return "unknown";
    return "unavailable";
  }
  hasMissingDependencies() {
    return this.missingDependencies.size > 0;
  }
  isAvailable() {
    return this.hasVerifiedContent();
  }
  isCompletelyDownloaded() {
    return !(!this.hasVerifiedContent() || this.isStreaming() || this.incompleteDependencies.size > 0);
  }
  isStreaming() {
    return this.verified?.isStreaming() ?? !1;
  }
  hasVerifiedContent() {
    return !!this.verified;
  }
  /**
   * Returns the CoValue data as NewContentMessage objects, excluding the transactions that are part of the given known state.
   *
   * Used to serialize the CoValue data to send it to peers and storage.
   */
  newContentSince(A) {
    return this.verified?.newContentSince(A);
  }
  isErroredInPeer(A) {
    return this.getLoadingStateForPeer(A) === "errored";
  }
  getErroredInPeerError(A) {
    const e = this.loadingStatuses.get(A);
    if (e?.type === "errored")
      return e.error;
  }
  waitFor(A) {
    const { predicate: e, onSuccess: i } = A;
    this.subscribe((o, r) => {
      e(o) && (r(), i(o));
    }, !0);
  }
  waitForAsync(A) {
    return new Promise((e) => {
      this.waitFor({ predicate: A, onSuccess: e });
    });
  }
  waitForAvailableOrUnavailable() {
    return this.waitForAsync((A) => A.isAvailable() || A.loadingState === "unavailable");
  }
  waitForAvailable() {
    return this.waitForAsync((A) => A.isAvailable());
  }
  waitForFullStreaming() {
    return this.waitForAsync((A) => A.isAvailable() && !A.isStreaming());
  }
  getLoadingStateForPeer(A) {
    return this.loadingStatuses.get(A)?.type ?? "unknown";
  }
  updateCounter(A) {
    const e = this.loadingState;
    A !== e && (A && this.counter.add(-1, { state: A }), this.counter.add(1, { state: e }));
  }
  /**
   * Removes the CoValue content from memory but keeps a shell with cached knownState.
   * This enables accurate LOAD requests during peer reconciliation.
   *
   * @returns true if the coValue was successfully unmounted, false otherwise
   */
  unmount() {
    return this.node.internalUnmountCoValue(this.id);
  }
  /**
   * Decrements the counter for the current loading state.
   * Used during unmount to properly track state transitions.
   * @internal
   */
  decrementLoadingStateCounter() {
    this.counter.add(-1, { state: this.loadingState });
  }
  markNotFoundInPeer(A) {
    const e = this.loadingState;
    this.loadingStatuses.set(A, { type: "unavailable" }), this.updateCounter(e), this.scheduleNotifyUpdate();
  }
  markFoundInPeer(A, e) {
    this.loadingStatuses.set(A, { type: "available" }), this.updateCounter(e), this.scheduleNotifyUpdate();
  }
  /**
   * Clean up cached state when CoValue becomes available.
   * Called after the CoValue transitions from garbageCollected/onlyKnownState to available.
   */
  cleanupLastKnownState() {
    qA(this, we, void 0, "f"), qA(this, ye, void 0, "f");
  }
  /**
   * Initialize this CoValueCore as a garbageCollected shell.
   * Called when creating a replacement CoValueCore after unmounting.
   */
  setGarbageCollectedState(A) {
    if (!this.node.storage)
      return;
    const e = this.loadingState;
    qA(this, we, "garbageCollected", "f"), qA(this, ye, A, "f"), this.updateCounter(e);
  }
  isCircularDependency(A) {
    if (A.id === this.id)
      return !0;
    const e = /* @__PURE__ */ new Set(), i = [A];
    for (; i.length > 0; ) {
      const o = i.pop();
      if (!o)
        return !1;
      e.add(o.id);
      for (const r of o.dependencies) {
        if (r === this.id)
          return !0;
        e.has(r) || i.push(this.node.getCoValue(r));
      }
    }
    return !1;
  }
  /**
   * Add a new content to the queue and handle it when the dependencies are available
   */
  addNewContentToQueue(A, e) {
    const i = this.newContentQueue.length > 0;
    this.newContentQueue.push({ msg: A, from: e }), !i && this.waitFor({
      predicate: (o) => !o.hasMissingDependencies(),
      onSuccess: () => {
        const o = this.newContentQueue;
        this.newContentQueue = [];
        for (const { msg: r, from: n } of o)
          this.node.syncManager.handleNewContent(r, n);
      }
    });
  }
  addDependencyFromHeader(A) {
    for (const e of sn(A))
      this.addDependency(e);
  }
  provideHeader(A, e, i) {
    if (!i) {
      const o = yB(A.uniqueness);
      if (!o.isOk)
        return AA.error("Invalid uniqueness", {
          header: A,
          errorMessage: o.message
        }), !1;
      const r = Yt(A, this.node.crypto);
      if (this.id !== r)
        return !1;
    }
    if (this.addDependencyFromHeader(A), this._verified?.sessions.size)
      throw new Error("CoValueCore: provideHeader called on coValue with verified sessions present!");
    return this._verified = new gn(this.id, this.node.crypto, A, new uo(this.id, this.node.crypto, e)), this.isAvailable() && this.cleanupLastKnownState(), !0;
  }
  markErrored(A, e) {
    const i = this.loadingState;
    this.loadingStatuses.set(A, { type: "errored", error: e }), this.updateCounter(i), this.scheduleNotifyUpdate();
  }
  markPending(A) {
    const e = this.loadingState;
    this.loadingStatuses.set(A, { type: "pending" }), this.updateCounter(e), this.scheduleNotifyUpdate();
  }
  contentInClonedNodeWithDifferentAccount(A) {
    return this.node.loadCoValueAsDifferentAgent(this.id, A.agentSecret, A.id).then((e) => e.getCurrentContent());
  }
  /**
   * Returns the known state considering the known state of the streaming source
   *
   * Used to correctly manage the content & subscriptions during the content streaming process
   */
  knownStateWithStreaming() {
    return this.verified ? this.verified.immutableKnownStateWithStreaming() : this.knownState();
  }
  /**
   * Returns the known state of the CoValue
   *
   * The return value identity is going to be stable as long as the CoValue is not modified.
   *
   * On change the knownState is invalidated and a new object is returned.
   *
   * For garbageCollected/onlyKnownState CoValues, returns the cached knownState.
   */
  knownState() {
    return this.verified ? this.verified.immutableKnownState() : xA(this, ye, "f") ? xA(this, ye, "f") : Je(this.id);
  }
  /**
   * Returns a known state message to signal to the peer that the coValue doesn't need to be synced anymore
   *
   * Implemented to be backward compatible with clients that don't support deleted coValues
   */
  stopSyncingKnownStateMessage(A) {
    if (!A)
      return {
        action: "known",
        ...this.knownState()
      };
    const e = Se(this.knownState());
    return ot(e.sessions, A.sessions), {
      action: "known",
      ...e
    };
  }
  get meta() {
    return this.verified?.header.meta ?? null;
  }
  nextTransactionID() {
    if (!this.verified)
      throw new Error("CoValueCore: nextTransactionID called on coValue without verified state");
    const A = this.verified.header.meta?.type === "account" ? this.node.currentSessionID.replace(this.node.getCurrentAgent().id, this.node.getCurrentAgent().currentAgentID()) : this.node.currentSessionID;
    return {
      sessionID: A,
      txIndex: this.verified.sessions.get(A)?.transactions.length || 0
    };
  }
  addDependenciesFromContentMessage(A) {
    const e = CB(this, A);
    for (const i of e)
      this.addDependency(i);
  }
  /**
   * Apply new transactions that were not generated by the current node to the CoValue
   */
  tryAddTransactions(A, e, i, o = !1) {
    if (e.length === 0)
      return;
    let r;
    if (this.isDeleted && !ve(A))
      return {
        type: "CoValueDeleted",
        id: this.id,
        error: new Error("Cannot add transactions to a deleted coValue")
      };
    if (!o) {
      const s = this.node.resolveAccountAgent(OA(A), "Expected to know signer of transaction");
      if (s.error || !s.value)
        return {
          type: "ResolveAccountAgentError",
          id: this.id,
          error: s.error
        };
      r = this.crypto.getAgentSignerID(s.value);
    }
    if (!this.verified)
      return {
        type: "TriedToAddTransactionsWithoutVerifiedState",
        id: this.id,
        error: void 0
      };
    const n = xA(this, Me, "m", Ug).call(this, A, e, o);
    if (n.err)
      return n.err;
    try {
      this.verified.tryAddTransactions(A, r, e, i, o), n.value && xA(this, Me, "m", yr).call(this), this.processNewTransactions(), this.scheduleNotifyUpdate(), this.invalidateDependants();
    } catch (s) {
      return { type: "InvalidSignature", id: this.id, error: s };
    }
  }
  notifyDependants() {
    if (this.isGroup())
      for (const A of this.dependant)
        this.node.getCoValue(A).scheduleNotifyUpdate(), this.node.getCoValue(A).notifyDependants();
  }
  invalidateDependants() {
    if (this.isGroup())
      for (const A of this.dependant)
        this.node.getCoValue(A).resetParsedTransactions(), this.node.getCoValue(A).invalidateDependants();
  }
  processNewTransactions() {
    this._cachedContent && this._cachedContent.processNewTransactions();
  }
  scheduleNotifyUpdate() {
    this.listeners.size !== 0 && (qA(this, yt, !0, "f"), xA(this, wt, "f") || (qA(this, wt, !0, "f"), queueMicrotask(() => {
      qA(this, wt, !1, "f"), xA(this, yt, "f") && this.notifyUpdate();
    })));
  }
  pauseNotifyUpdate() {
    qA(this, Dt, !0, "f");
  }
  resumeNotifyUpdate() {
    qA(this, Dt, !1, "f"), this.notifyUpdate();
  }
  notifyUpdate() {
    if (!(this.listeners.size === 0 || xA(this, Dt, "f"))) {
      qA(this, yt, !1, "f");
      for (const A of this.listeners)
        try {
          A(this, () => {
            this.listeners.delete(A);
          });
        } catch (e) {
          AA.error("Error in listener for coValue " + this.id, { err: e });
        }
    }
  }
  subscribe(A, e = !0) {
    return this.listeners.add(A), e && A(this, () => {
      this.listeners.delete(A);
    }), () => {
      this.listeners.delete(A);
    };
  }
  validateDeletePermissions() {
    if (!this.verified)
      return {
        ok: !1,
        reason: "CannotVerifyPermissions",
        message: "Cannot verify delete permissions without verified state"
      };
    if (this.isGroupOrAccount())
      return {
        ok: !1,
        reason: "CoValueNotDeletable",
        message: "Cannot delete Group or Account coValues"
      };
    const A = this.safeGetGroup();
    return A ? A.myRole() !== "admin" ? {
      ok: !1,
      reason: "NotAdmin",
      message: "The current account lacks admin permissions to delete this coValue"
    } : { ok: !0 } : {
      ok: !1,
      reason: "CannotVerifyPermissions",
      message: "Cannot verify delete permissions for coValues not owned by a group"
    };
  }
  /**
   * Creates a delete marker transaction for this CoValue and sets the coValue as deleted
   *
   * Constraints:
   * - Account and Group CoValues cannot be deleted.
   * - Only admins can delete a coValue.
   */
  deleteCoValue() {
    if (this.isDeleted)
      return;
    const A = this.validateDeletePermissions();
    if (!A.ok)
      throw new Error(A.message);
    this.makeTransaction(
      [],
      // Empty changes array
      "trusting",
      // Unencrypted
      { deleted: this.id }
    );
  }
  /**
   * Creates a new transaction with local changes and syncs it to all peers
   */
  makeTransaction(A, e, i, o) {
    if (!this.verified)
      throw new Error("CoValueCore: makeTransaction called on coValue without verified state");
    const r = !!i?.deleted;
    if (this.isDeleted && !r)
      return AA.error("Cannot make transaction on a deleted coValue", {
        id: this.id
      }), !1;
    let n = this.verified.header.meta?.type === "account" ? this.node.currentSessionID.replace(this.node.getCurrentAgent().id, this.node.getCurrentAgent().currentAgentID()) : this.node.currentSessionID;
    r && (n = this.crypto.newDeleteSessionID(this.node.getCurrentAccountOrAgentID()));
    const s = this.node.getCurrentAgent();
    let a;
    const g = this.knownState();
    if (e === "private") {
      const { secret: c, id: C } = this.getCurrentReadKey();
      if (!c)
        throw new Error("Can't make transaction without read key secret");
      a = this.verified.makeNewPrivateTransaction(n, s, A, C, c, i, o ?? Date.now());
    } else
      a = this.verified.makeNewTrustingTransaction(n, s, A, i, o ?? Date.now());
    r && xA(this, Me, "m", yr).call(this);
    const { transaction: I } = a;
    return this.parsingCache.set(I, { changes: A, meta: i }), this.node.syncManager.recordTransactionsSize([I], "local"), this.processNewTransactions(), this.addDependenciesFromNewTransaction(I), this.notifyUpdate(), this.node.syncManager.syncLocalTransaction(this.verified, g), o === void 0 ? this.notifyDependants() : this.invalidateDependants(), !0;
  }
  addDependenciesFromNewTransaction(A) {
    if (this.verified?.header.ruleset.type === "group")
      for (const e of an([
        A
      ]))
        this.addDependency(e);
  }
  getCurrentContent(A) {
    if (!this.verified)
      throw new Error("CoValueCore: getCurrentContent called on coValue without verified state");
    if (!A?.ignorePrivateTransactions && this._cachedContent)
      return this._cachedContent;
    const e = IB(this, A);
    return A?.ignorePrivateTransactions || (this._cachedContent = e), e;
  }
  // Reset the parsed transactions and branches, to validate them again from scratch when the group is updated
  resetParsedTransactions() {
    const A = this.verifiedTransactions;
    if (A.length === 0)
      return;
    this.branchStart = void 0, this.mergeCommits = [];
    const e = new Array(A.length);
    this.verifiedTransactions.forEach((o, r) => {
      o.isValidated = !1, e[r] = o.isValidTransactionWithChanges();
    }), this.toValidateTransactions = A.slice(), this.toProcessTransactions = [], this.toDecryptTransactions = [], this.toParseMetaTransactions = [], this.parseNewTransactions(!1), e.every((o, r) => o === A[r]?.isValidTransactionWithChanges()) || this._cachedContent?.rebuildFromCore(), this.scheduleNotifyUpdate();
  }
  /**
     * Loads the new transaction from the SessionMap into verifiedTransactions as a VerifiedTransaction.
     *
     * If the transaction is already loaded from the SessionMap in the past, it will not be loaded again.
     *
     * Used to have a fast way to iterate over the CoValue transactions, and track their validation/decoding state.
  
    * @internal
     * */
  loadVerifiedTransactionsFromLogs() {
    if (!this.verified)
      return;
    const A = this.isBranched();
    for (const [e, i] of this.verified.sessions.entries()) {
      const o = this.verifiedTransactionsKnownSessions[e] ?? 0;
      for (let r = o; r < i.transactions.length; r++) {
        const n = i.transactions[r];
        if (!n)
          continue;
        const s = this.parsingCache.get(n);
        s && this.parsingCache.delete(n);
        const a = new DB(this.id, e, r, n, A ? this.id : void 0, s, this.lastVerifiedTransactionBySessionID[e], this.dispatchTransaction);
        a.madeAt > this.latestTxMadeAt && (this.latestTxMadeAt = a.madeAt), a.madeAt < this.earliestTxMadeAt && (this.earliestTxMadeAt = a.madeAt), this.verifiedTransactions.push(a), this.dispatchTransaction(a), this.lastVerifiedTransactionBySessionID[e] = a;
      }
      this.verifiedTransactionsKnownSessions[e] = i.transactions.length;
    }
  }
  /**
   * Iterates over the verifiedTransactions and marks them as valid or invalid, based on the group membership of the authors of the transactions  .
   */
  determineValidTransactions() {
    HC(this), this.toValidateTransactions = [];
  }
  /**
   * Parses the meta information of a transaction, and set the branchStart and mergeCommits.
   */
  parseMetaInformation(A) {
    if (A.meta) {
      if (this.isBranched() && "from" in A.meta) {
        const e = A.meta;
        this.branchStart ? this.branchStart = ot(this.branchStart, e.from) : this.branchStart = e.from;
      }
      if ("branch" in A.meta) {
        const e = A.meta;
        this.branches.push(e);
      }
      if ("merged" in A.meta) {
        const e = A.meta;
        this.mergeCommits.push(e);
      }
      if ("mi" in A.meta) {
        const e = A.meta, i = A.previous, o = e.s ?? i?.txID.sessionID;
        e.t ? A.sourceTxMadeAt = A.currentMadeAt - e.t : i && (A.sourceTxMadeAt = i.madeAt), A.sourceTxMadeAt && A.sourceTxMadeAt > A.currentMadeAt && A.markInvalid("Transaction sourceMadeAt is after the currentMadeAt", {
          sourceTxMadeAt: A.sourceTxMadeAt,
          currentMadeAt: A.currentMadeAt
        }), o ? A.sourceTxID = {
          sessionID: o,
          txIndex: e.mi,
          branch: e.b ?? i?.txID.branch
        } : AA.error("Merge commit without session ID", {
          txID: A.txID,
          prevTxID: i?.txID ?? null
        });
      }
    }
  }
  /**
   * Loads the new transactions from SessionMap and:
   * - Validates each transaction based on the group membership of the authors
   * - Decodes the changes & meta for each transaction
   * - Parses the meta information of the transaction
   */
  parseNewTransactions(A) {
    if (!this.isAvailable())
      return;
    if (this.loadVerifiedTransactionsFromLogs(), this.determineValidTransactions(), !A) {
      const i = this.toDecryptTransactions;
      this.toDecryptTransactions = [];
      for (const o of i)
        wB(this, o), this.dispatchTransaction(o);
    }
    const e = this.toParseMetaTransactions;
    this.toParseMetaTransactions = [];
    for (const i of e)
      this.parseMetaInformation(i);
  }
  /**
   * Returns the valid transactions matching the criteria specified in the options
   */
  getValidTransactions(A) {
    if (!this.verified)
      return [];
    this.parseNewTransactions(A?.ignorePrivateTransactions ?? !1);
    const e = [], i = Yg(this), o = A?.from, r = A?.to, n = A?.knownTransactions?.[this.id] ?? 0;
    for (let s = n; s < this.toProcessTransactions.length; s++) {
      const a = this.toProcessTransactions[s];
      if (!a.isValidTransactionWithChanges())
        continue;
      const g = a.currentTxID, I = o?.[g.sessionID] ?? -1, c = r?.[g.sessionID] ?? 1 / 0;
      I > g.txIndex || c < g.txIndex || e.push(a);
    }
    if (A?.knownTransactions !== void 0 && (A.knownTransactions[this.id] = this.toProcessTransactions.length), i && this.branchStart && !A?.skipBranchSource) {
      const s = i.getValidTransactions({
        knownTransactions: A?.knownTransactions,
        to: this.branchStart,
        ignorePrivateTransactions: A?.ignorePrivateTransactions ?? !1
      });
      for (const a of s)
        e.push(a);
    }
    return e;
  }
  addDependency(A) {
    const e = this.node.getCoValue(A);
    this.isCircularDependency(e) || this.dependencies.has(A) || (this.dependencies.add(A), e.addDependant(this.id), e.isCompletelyDownloaded() || (this.incompleteDependencies.add(e.id), e.waitFor({
      predicate: (i) => i.isCompletelyDownloaded(),
      onSuccess: () => {
        this.incompleteDependencies.delete(e.id), this.incompleteDependencies.size === 0 && this.notifyUpdate();
      }
    })), e.isAvailable() || (this.missingDependencies.add(e.id), e.waitFor({
      predicate: (i) => i.isAvailable(),
      onSuccess: () => {
        this.missingDependencies.delete(e.id), this.missingDependencies.size === 0 && this.notifyUpdate();
      }
    })));
  }
  addDependant(A) {
    this.dependant.add(A);
  }
  isGroupOrAccount() {
    return this.verified ? this.verified.header.ruleset.type === "group" : !1;
  }
  isGroup() {
    return !(!this.verified || this.verified.header.ruleset.type !== "group" || this.verified.header.meta?.type === "account");
  }
  createBranch(A, e) {
    return fB(this, A, e);
  }
  mergeBranch() {
    return pB(this);
  }
  getBranch(A, e) {
    return this.node.getCoValue(hB(this, A, e));
  }
  getCurrentBranchName() {
    return this.verified?.branchName;
  }
  getCurrentBranchSourceId() {
    return this.verified?.branchSourceId;
  }
  isBranched() {
    return !!this.verified?.branchSourceId;
  }
  hasBranch(A, e) {
    this.parseNewTransactions(!1);
    const i = In(this);
    return this.branches.some((o) => {
      if (o.branch !== A)
        return !1;
      if (o.ownerId === e)
        return !0;
      if (!e)
        return o.ownerId === i;
      if (!o.ownerId)
        return e === i;
    });
  }
  getMergeCommits() {
    return this.mergeCommits;
  }
  getValidSortedTransactions(A) {
    const e = this.getValidTransactions(A);
    return e.sort(this.compareTransactions), e;
  }
  compareTransactions(A, e) {
    return A.madeAt !== e.madeAt ? A.madeAt - e.madeAt : A.txID.sessionID === e.txID.sessionID ? A.txID.txIndex - e.txID.txIndex : 0;
  }
  getCurrentReadKey() {
    if (!this.verified)
      throw new Error("CoValueCore: getCurrentReadKey called on coValue without verified state");
    if (this.isGroupOrAccount())
      return bA(this.getCurrentContent()).getCurrentReadKey();
    if (this.verified.header.ruleset.type === "ownedByGroup")
      return this.node.expectCoValueLoaded(this.verified.header.ruleset.group).getCurrentReadKey();
    throw new Error("Only groups or values owned by groups have read secrets");
  }
  getReadKey(A) {
    const e = this.readKeyCache.get(A);
    if (e)
      return e;
    if (!this.verified)
      throw new Error("CoValueCore: getUncachedReadKey called on coValue without verified state");
    if (this.isGroup())
      return bA(
        // Private transactions are not considered valid in groups, so we don't need to pass
        // ignorePrivateTransactions: true to safely load the content
        this.getCurrentContent()
      ).getReadKey(A);
    if (this.isGroupOrAccount())
      return bA(
        // Old accounts might have private transactions, because we were encrypting the root id in the past
        // So we need to load the account without private transactions, because we can't decrypt them without the read key
        this.getCurrentContent({ ignorePrivateTransactions: !0 })
      ).getReadKey(A);
    if (this.verified.header.ruleset.type === "ownedByGroup")
      return bA(this.node.expectCoValueLoaded(this.verified.header.ruleset.group).getCurrentContent()).getReadKey(A);
    throw new Error("Only groups or values owned by groups have read secrets");
  }
  safeGetGroup() {
    if (!this.verified)
      throw new Error("CoValueCore: getGroup called on coValue without verified state");
    if (this.verified.header.ruleset.type === "ownedByGroup")
      return bA(this.node.expectCoValueLoaded(this.verified.header.ruleset.group).getCurrentContent());
  }
  getGroup() {
    const A = this.safeGetGroup();
    if (!A)
      throw new Error("Only values owned by groups have groups");
    return A;
  }
  getTx(A) {
    return this.verified?.sessions.get(A.sessionID)?.transactions[A.txIndex];
  }
  getDependedOnCoValues() {
    return this.dependencies;
  }
  waitForSync(A) {
    return this.node.syncManager.waitForSync(this.id, A?.timeout);
  }
  load(A, e) {
    this.loadFromStorage((i) => {
      i || this.loadFromPeers(A, e);
    });
  }
  loadFromStorage(A) {
    const e = this.node;
    if (!e.storage) {
      A?.(!1);
      return;
    }
    const i = this.getLoadingStateForPeer("storage");
    if (i === "pending") {
      if (!A)
        return;
      this.subscribe((r, n) => {
        const s = r.getLoadingStateForPeer("storage");
        s === "available" || r.isAvailable() ? (n(), A(!0)) : (s === "errored" || s === "unavailable") && (n(), A(!1));
      });
      return;
    }
    const o = this.loadingState;
    if (i !== "unknown" && o !== "garbageCollected" && o !== "onlyKnownState") {
      A?.(i === "available");
      return;
    }
    this.markPending("storage"), e.storage.load(this.id, (r) => {
      e.syncManager.handleNewContent(r, "storage");
    }, (r) => {
      A?.(r), r || this.markNotFoundInPeer("storage");
    });
  }
  /**
   * Lazily load only the knownState from storage without loading full transaction data.
   * This is useful for checking if a peer needs new content before committing to a full load.
   *
   * If found in storage, marks the CoValue as onlyKnownState and caches the knownState.
   * This enables accurate LOAD requests during peer reconciliation.
   *
   * @param done - Callback with the storage knownState, or undefined if not found in storage
   */
  getKnownStateFromStorage(A) {
    if (!this.node.storage) {
      A(void 0);
      return;
    }
    const e = this.knownState();
    if (e.header) {
      A(e);
      return;
    }
    this.node.storage.loadKnownState(this.id, (i) => {
      if (i && !this.isAvailable()) {
        const o = this.loadingState;
        qA(this, we, "onlyKnownState", "f"), qA(this, ye, i, "f"), this.updateCounter(o);
      }
      A(i);
    });
  }
  loadFromPeers(A, e) {
    if (A.length !== 0)
      for (const i of A) {
        const o = this.getLoadingStateForPeer(i.id);
        (o === "unknown" || o === "unavailable") && (this.markPending(i.id), this.internalLoadFromPeer(i, e));
      }
  }
  internalLoadFromPeer(A, e) {
    if (A.closed && !A.persistent) {
      this.markNotFoundInPeer(A.id);
      return;
    }
    const i = () => {
      this.getLoadingStateForPeer(A.id) === "pending" && (AA.warn("Timeout waiting for peer to load coValue", {
        id: this.id,
        peerID: A.id
      }), this.markNotFoundInPeer(A.id));
    }, o = A.persistent ? void 0 : A.addCloseListener(i);
    A.closed || A.sendLoadRequest(this, e), this.subscribe((r, n) => {
      const s = r.getLoadingStateForPeer(A.id);
      (r.isAvailable() || // might have become available from another peer e.g. through handleNewContent
      s === "available" || s === "errored" || s === "unavailable") && (n(), o?.());
    }, !0);
  }
}
we = /* @__PURE__ */ new WeakMap(), ye = /* @__PURE__ */ new WeakMap(), wt = /* @__PURE__ */ new WeakMap(), yt = /* @__PURE__ */ new WeakMap(), Dt = /* @__PURE__ */ new WeakMap(), Me = /* @__PURE__ */ new WeakSet(), Ug = function(A, e, i) {
  if (!this.verified)
    return {
      value: !1
    };
  let o;
  if (ve(A)) {
    if ((this.verified.sessions.get(A)?.transactions.length ?? 0) > 0 || e.length > 1)
      return {
        value: !0,
        err: {
          type: "DeleteTransactionRejected",
          id: this.id,
          sessionID: A,
          reason: "InvalidDeleteTransaction",
          error: new Error("Delete transaction must be the only transaction in the session")
        }
      };
    const n = e[0], s = n && xA(this, Me, "m", Cs).call(this, n);
    if (s && (o = n, s.deleted !== this.id))
      return {
        value: !0,
        err: {
          type: "DeleteTransactionRejected",
          id: this.id,
          sessionID: A,
          reason: "InvalidDeleteTransaction",
          error: new Error(`Delete transaction ID mismatch: expected ${this.id}, got ${s.deleted}`)
        }
      };
    if (this.isGroupOrAccount())
      return {
        value: !0,
        err: {
          type: "DeleteTransactionRejected",
          id: this.id,
          sessionID: A,
          reason: "CoValueNotDeletable",
          error: new Error("Cannot delete Group or Account coValues")
        }
      };
  }
  if (!i && o) {
    const r = OA(A), n = xA(this, Me, "m", Bs).call(this, r, o.madeAt);
    if (!n.ok)
      return {
        value: !0,
        err: {
          type: "DeleteTransactionRejected",
          id: this.id,
          sessionID: A,
          author: r,
          reason: n.reason,
          error: new Error(n.message)
        }
      };
  }
  return {
    value: !!o
  };
}, yr = function() {
  this.isDeleted = !0, this.verified?.markAsDeleted();
}, Cs = function(A) {
  if (A.privacy !== "trusting" || !A.meta)
    return;
  const e = fr(A.meta);
  return e && typeof e.deleted == "string" ? e : void 0;
}, Bs = function(A, e) {
  if (!this.verified)
    return {
      ok: !1,
      reason: "CannotVerifyPermissions",
      message: "Cannot verify delete permissions without verified state"
    };
  if (this.isGroupOrAccount())
    return {
      ok: !1,
      reason: "CoValueNotDeletable",
      message: "Cannot delete Group or Account coValues"
    };
  const i = this.safeGetGroup();
  return i ? i.atTime(e).roleOfInternal(A) !== "admin" ? {
    ok: !1,
    reason: "NotAdmin",
    message: "Delete transaction rejected: author is not an admin"
  } : { ok: !0 } : {
    ok: !1,
    reason: "CannotVerifyPermissions",
    message: "Cannot verify delete permissions for coValues not owned by a group"
  };
};
class mB {
  constructor(A) {
    this.node = A, this.interval = setInterval(() => {
      this.collect();
    }, gs.INTERVAL);
  }
  getCurrentTime() {
    return performance.now();
  }
  trackCoValueAccess({ verified: A }) {
    A && (A.lastAccessed = this.getCurrentTime());
  }
  collect() {
    const A = this.getCurrentTime();
    for (const e of this.node.allCoValues()) {
      const { verified: i } = e;
      if (!i?.lastAccessed)
        continue;
      A - i.lastAccessed > gs.MAX_AGE && this.node.internalUnmountCoValue(e.id);
    }
  }
  stop() {
    clearInterval(this.interval);
  }
}
class cn {
  constructor(A, e) {
    this.id = A, this.peerId = e, this.knownState = Je(A);
  }
  cloneWithoutOptimistic() {
    const A = new cn(this.id, this.peerId);
    return A.set(this.knownState), A;
  }
  updateHeader(A) {
    this.knownState.header = A, this.optimisticKnownState && (this.optimisticKnownState.header = A);
  }
  combineWith(A) {
    $o(this.knownState, A), this.optimisticKnownState && $o(this.optimisticKnownState, A);
  }
  combineOptimisticWith(A) {
    this.optimisticKnownState || (this.optimisticKnownState = Se(this.knownState)), $o(this.optimisticKnownState, A);
  }
  /**
   * Aligns the CoValue known state with the defined payload
   */
  set(A) {
    A === "empty" ? (this.knownState.header = !1, this.knownState.sessions = {}) : (this.knownState.header = A.header, this.knownState.sessions = { ...A.sessions }), this.optimisticKnownState = void 0;
  }
  value() {
    return this.knownState;
  }
  optimisticValue() {
    return this.optimisticKnownState ?? this.knownState;
  }
}
class ho {
  constructor(A) {
    this.meter = A, this.head = void 0, this.tail = void 0, this.length = 0;
  }
  push(A) {
    const e = { value: A, prev: void 0, next: void 0 };
    if (this.head === void 0)
      this.head = e, this.tail = e;
    else if (this.tail)
      e.prev = this.tail, this.tail.next = e, this.tail = e;
    else
      throw new Error("LinkedList is corrupted");
    return this.length++, this.meter?.push(), e;
  }
  shift() {
    if (!this.head)
      return;
    const A = this.head, e = A.value;
    return this.head = A.next, A.next = void 0, this.head === void 0 ? this.tail = void 0 : this.head.prev = void 0, this.length--, this.meter?.pull(), e;
  }
  /**
   * Remove a specific node from the list in O(1) time.
   * The node must be a valid node that was returned by push().
   */
  remove(A) {
    A.prev ? A.prev.next = A.next : this.head = A.next, A.next ? A.next.prev = A.prev : this.tail = A.prev, A.prev = void 0, A.next = void 0, this.length--, this.meter?.pull();
  }
  isEmpty() {
    return this.head === void 0;
  }
}
class SB {
  constructor(A, e) {
    this.attrs = e, this.pullCounter = ge.getMeter("cojson").createCounter(`${A}.pulled`, {
      description: "Number of messages pulled from the queue",
      valueType: WA.INT,
      unit: "1"
    }), this.pushCounter = ge.getMeter("cojson").createCounter(`${A}.pushed`, {
      description: "Number of messages pushed to the queue",
      valueType: WA.INT,
      unit: "1"
    }), this.pullCounter.add(0, this.attrs), this.pushCounter.add(0, this.attrs);
  }
  pull() {
    this.pullCounter.add(1, this.attrs);
  }
  push() {
    this.pushCounter.add(1, this.attrs);
  }
}
function Gt(t, A) {
  return new ho(new SB("jazz.messagequeue." + t, A));
}
class kB {
  constructor(A) {
    this.peerId = A, this.inFlightLoads = /* @__PURE__ */ new Map(), this.highPriorityPending = Gt("load-requests-queue", { priority: "high" }), this.lowPriorityPending = Gt("load-requests-queue", { priority: "low" }), this.lowPriorityNodes = /* @__PURE__ */ new Map(), this.highPriorityNodes = /* @__PURE__ */ new Map(), this.timeoutHandle = null, this.processing = !1;
  }
  /**
   * Check if we can send another load request.
   */
  canSend() {
    return this.inFlightLoads.size < At.MAX_IN_FLIGHT_LOADS_PER_PEER;
  }
  /**
   * Track that a load request has been sent.
   */
  trackSent(A) {
    const e = performance.now();
    this.inFlightLoads.set(A, e), this.scheduleTimeoutCheck(At.TIMEOUT);
  }
  /**
   * Schedule a timeout check if not already scheduled.
   * Uses a single timer to check all in-flight loads.
   */
  scheduleTimeoutCheck(A) {
    this.timeoutHandle === null && (this.timeoutHandle = setTimeout(() => {
      this.timeoutHandle = null, this.checkTimeouts();
    }, A));
  }
  /**
   * Check all in-flight loads for timeouts and handle them.
   */
  checkTimeouts() {
    const A = performance.now();
    let e;
    for (const [i, o] of this.inFlightLoads.entries()) {
      const r = o + At.TIMEOUT;
      A >= r ? (i.isAvailable() ? i.isStreaming() && AA.warn("Content streaming is taking more than " + At.TIMEOUT / 1e3 + "s", {
        id: i.id,
        peerId: this.peerId,
        knownState: i.knownState().sessions,
        streamingTarget: i.knownStateWithStreaming().sessions
      }) : (AA.warn("Load request timed out", {
        id: i.id,
        peerId: this.peerId
      }), i.markNotFoundInPeer(this.peerId)), this.inFlightLoads.delete(i), this.processQueue()) : e = Math.min(e ?? 1 / 0, r - A);
    }
    e && this.scheduleTimeoutCheck(e);
  }
  trackUpdate(A) {
    this.inFlightLoads.has(A) && this.inFlightLoads.set(A, performance.now());
  }
  /**
   * Track that a load request has completed.
   * Triggers processing of pending requests.
   */
  trackComplete(A) {
    this.inFlightLoads.has(A) && (A.isStreaming() || (this.inFlightLoads.delete(A), this.processQueue()));
  }
  /**
   * Enqueue a load request.
   * Immediately processes the queue to send requests if capacity is available.
   * Skips CoValues that are already in-flight or pending.
   *
   * @param coValue - The CoValue to load
   * @param sendCallback - Callback to send the request when ready
   * @param mode - Optional mode: "low-priority" for background loads, "immediate" to bypass queue
   */
  enqueue(A, e, i = "high-priority") {
    if (this.inFlightLoads.has(A))
      return;
    const o = this.lowPriorityNodes.get(A.id), r = this.highPriorityNodes.get(A.id);
    switch (i) {
      case "immediate":
        o && (this.lowPriorityPending.remove(o), this.lowPriorityNodes.delete(A.id)), r && (this.highPriorityPending.remove(r), this.highPriorityNodes.delete(A.id)), this.trackSent(A), e();
        break;
      case "high-priority":
        if (r)
          return;
        o && (this.lowPriorityPending.remove(o), this.lowPriorityNodes.delete(A.id)), this.highPriorityNodes.set(A.id, this.highPriorityPending.push({ value: A, sendCallback: e })), this.processQueue();
        break;
      case "low-priority":
        if (o || r)
          return;
        this.lowPriorityNodes.set(A.id, this.lowPriorityPending.push({ value: A, sendCallback: e })), this.processQueue();
        break;
    }
  }
  /**
   * Process all pending load requests while capacity is available.
   * High-priority requests are processed first, then low-priority.
   */
  processQueue() {
    if (!(this.processing || !this.canSend())) {
      for (this.processing = !0; this.canSend(); ) {
        let A = this.highPriorityPending.shift();
        if (A ? this.highPriorityNodes.delete(A.value.id) : (A = this.lowPriorityPending.shift(), A && this.lowPriorityNodes.delete(A.value.id)), !A)
          break;
        this.trackSent(A.value), A.sendCallback();
      }
      this.processing = !1;
    }
  }
  /**
   * Clear all state. Called on disconnect.
   * Clears the timeout and all pending/in-flight loads.
   */
  clear() {
    for (this.timeoutHandle !== null && (clearTimeout(this.timeoutHandle), this.timeoutHandle = null), this.inFlightLoads.clear(); this.highPriorityPending.shift(); )
      ;
    for (; this.lowPriorityPending.shift(); )
      ;
    this.highPriorityNodes.clear(), this.lowPriorityNodes.clear();
  }
  /**
   * Get the number of in-flight loads (for testing/debugging).
   */
  get inFlightCount() {
    return this.inFlightLoads.size;
  }
  /**
   * Get the number of pending loads (for testing/debugging).
   */
  get pendingCount() {
    return this.highPriorityPending.length + this.lowPriorityPending.length;
  }
  /**
   * Get the number of high-priority pending loads (for testing/debugging).
   */
  get highPriorityPendingCount() {
    return this.highPriorityPending.length;
  }
  /**
   * Get the number of low-priority pending loads (for testing/debugging).
   */
  get lowPriorityPendingCount() {
    return this.lowPriorityPending.length;
  }
}
class Cn {
  constructor(A, e) {
    this.peer = A, this.toldKnownState = /* @__PURE__ */ new Set(), this.loadRequestSent = /* @__PURE__ */ new Set(), this.listeners = /* @__PURE__ */ new Set(), this.closed = !1, this.closeListeners = /* @__PURE__ */ new Set(), this._knownStates = e ?? /* @__PURE__ */ new Map(), this.loadQueue = new kB(A.id);
  }
  getKnownState(A) {
    return this._knownStates.get(A)?.value();
  }
  getOptimisticKnownState(A) {
    return this._knownStates.get(A)?.optimisticValue();
  }
  isCoValueSubscribedToPeer(A) {
    return this._knownStates.has(A);
  }
  /**
   * Closes the current peer state and creates a new one from a given peer,
   * keeping the same known states.
   *
   * This is used to create a new peer state when a peer reconnects.
   */
  newPeerStateFrom(A) {
    this.closed || this.gracefulShutdown();
    const e = /* @__PURE__ */ new Map();
    for (const i of this._knownStates.values())
      e.set(i.id, i.cloneWithoutOptimistic());
    return new Cn(A, e);
  }
  sendLoadRequest(A, e) {
    this.toldKnownState.add(A.id), this.loadRequestSent.add(A.id), this.loadQueue.enqueue(A, () => {
      this.pushOutgoingMessage({
        action: "load",
        ...A.knownStateWithStreaming()
      });
    }, e);
  }
  trackLoadRequestUpdate(A) {
    this.loadQueue.trackUpdate(A);
  }
  trackLoadRequestComplete(A) {
    this.loadQueue.trackComplete(A);
  }
  trackToldKnownState(A) {
    this.toldKnownState.add(A);
  }
  getOrCreateKnownState(A) {
    let e = this._knownStates.get(A);
    return e || (e = new cn(A, this.peer.id), this._knownStates.set(A, e)), e;
  }
  updateHeader(A, e) {
    const i = this.getOrCreateKnownState(A);
    i.updateHeader(e), this.triggerUpdate(A, i);
  }
  combineWith(A, e) {
    const i = this.getOrCreateKnownState(A);
    i.combineWith(e), this.triggerUpdate(A, i);
  }
  combineOptimisticWith(A, e) {
    const i = this.getOrCreateKnownState(A);
    i.combineOptimisticWith(e), this.triggerUpdate(A, i);
  }
  setKnownState(A, e) {
    const i = this.getOrCreateKnownState(A);
    i.set(e), this.triggerUpdate(A, i);
  }
  /**
   * Emit a change event for a given coValue.
   *
   * This is used to notify subscribers that the known state of a coValue has changed,
   * but the known state of the peer has not.
   */
  emitCoValueChange(A) {
    if (this.peer.role === "client" && !this.isCoValueSubscribedToPeer(A))
      return;
    const e = this.getOrCreateKnownState(A);
    this.triggerUpdate(A, e);
  }
  triggerUpdate(A, e) {
    for (const i of this.listeners)
      i(A, e);
  }
  subscribeToKnownStatesUpdates(A) {
    return this.listeners.add(A), () => {
      this.listeners.delete(A);
    };
  }
  get id() {
    return this.peer.id;
  }
  get role() {
    return this.peer.role;
  }
  get priority() {
    return this.peer.priority;
  }
  get incoming() {
    return this.peer.incoming;
  }
  get persistent() {
    return this.peer.persistent;
  }
  pushOutgoingMessage(A) {
    this.peer.outgoing.push(A);
  }
  addCloseListener(A) {
    return this.closed ? (A(), () => {
    }) : (this.closeListeners.add(A), () => {
      this.closeListeners.delete(A);
    });
  }
  emitClose() {
    for (const A of this.closeListeners)
      A();
    this.closeListeners.clear();
  }
  gracefulShutdown() {
    this.closed || (AA.debug("Gracefully closing", {
      peerId: this.id,
      peerRole: this.role
    }), this.closed = !0, this.loadQueue.clear(), this.peer.outgoing.push("Disconnected"), this.peer.outgoing.close(), this.peer.incoming.close(), this.emitClose());
  }
}
class NB {
  constructor(A) {
    this.syncManager = A, this.listeners = /* @__PURE__ */ new Set(), this.listenersByCoValues = /* @__PURE__ */ new Map(), this.listenersByPeersAndCoValues = /* @__PURE__ */ new Map();
  }
  subscribeToUpdates(A) {
    return this.listeners.add(A), () => {
      this.listeners.delete(A);
    };
  }
  subscribeToCoValueUpdates(A, e) {
    let i = this.listenersByCoValues.get(A);
    return i || (i = /* @__PURE__ */ new Set(), this.listenersByCoValues.set(A, i)), i.add(e), () => {
      i.delete(e), i.size === 0 && this.listenersByCoValues.delete(A);
    };
  }
  subscribeToPeerUpdates(A, e, i) {
    let o = this.listenersByPeersAndCoValues.get(A);
    o || (o = /* @__PURE__ */ new Map(), this.listenersByPeersAndCoValues.set(A, o));
    let r = o.get(e);
    return r || (r = /* @__PURE__ */ new Set(), o.set(e, r)), r.add(i), () => {
      r.delete(i), r.size === 0 && (o.delete(e), o.size === 0 && this.listenersByPeersAndCoValues.delete(A));
    };
  }
  triggerUpdate(A, e, i) {
    const o = this.listeners, r = this.listenersByCoValues.get(e), s = this.listenersByPeersAndCoValues.get(A.id)?.get(e);
    if (!o.size && !r?.size && !s?.size)
      return;
    const a = {
      uploaded: this.getIsCoValueFullyUploadedIntoPeer(i, e)
    };
    for (const g of this.listeners)
      g(A, i, a);
    if (r)
      for (const g of r)
        g(A, i, a);
    if (s)
      for (const g of s)
        g(i, a);
  }
  isSynced(A, e) {
    const i = A.getKnownState(e);
    return i ? this.getIsCoValueFullyUploadedIntoPeer(i, e) : !1;
  }
  getIsCoValueFullyUploadedIntoPeer(A, e) {
    const i = this.syncManager.local.getCoValue(e);
    if (!i.hasVerifiedContent())
      return !1;
    const o = i.verified.knownState();
    return bg(o.sessions, A.sessions);
  }
}
const Es = "any";
let MB = 200;
class GB {
  constructor() {
    this.unsynced = /* @__PURE__ */ new Map(), this.coValueListeners = /* @__PURE__ */ new Map(), this.globalListeners = /* @__PURE__ */ new Set(), this.pendingUpdates = [];
  }
  /**
   * Add a CoValue as unsynced to a specific peer.
   * Triggers persistence if storage is available.
   * @returns true if the CoValue was already tracked, false otherwise.
   */
  add(A, e = Es) {
    this.unsynced.has(A) || this.unsynced.set(A, /* @__PURE__ */ new Set());
    const i = this.unsynced.get(A), o = i.has(e);
    return o || (i.add(e), this.schedulePersist(A, e, !1), this.notifyCoValueListeners(A, !1), this.notifyGlobalListeners(!1)), o;
  }
  /**
   * Remove a CoValue from being unsynced to a specific peer.
   * Triggers persistence if storage is available.
   */
  remove(A, e = Es) {
    const i = this.unsynced.get(A);
    if (!i || !i.has(e))
      return;
    i.delete(e), i.size === 0 && this.unsynced.delete(A), this.schedulePersist(A, e, !0);
    const o = !this.unsynced.has(A);
    this.notifyCoValueListeners(A, o), this.notifyGlobalListeners(this.isAllSynced());
  }
  /**
   * Remove all tracking for a CoValue (all peers).
   * Triggers persistence if storage is available.
   */
  removeAll(A) {
    const e = this.unsynced.get(A);
    if (!e)
      return;
    const i = Array.from(e);
    for (const o of i)
      this.remove(A, o);
  }
  forcePersist() {
    return this.flush();
  }
  schedulePersist(A, e, i) {
    this.storage && (this.pendingUpdates.push({ id: A, peerId: e, synced: i }), this.flushTimer || (this.flushTimer = setTimeout(() => {
      this.flush();
    }, MB)));
  }
  /**
   * Flush all pending persistence updates in a batch
   */
  flush() {
    if (this.flushTimer && (clearTimeout(this.flushTimer), this.flushTimer = void 0), this.pendingUpdates.length === 0)
      return;
    const A = this.storage;
    if (!A)
      return;
    const e = this.simplifyPendingUpdates(this.pendingUpdates);
    return this.pendingUpdates = [], new Promise((i) => {
      try {
        A.trackCoValuesSyncState(e, () => i());
      } catch (o) {
        AA.warn("Failed to persist batched unsynced CoValue tracking", {
          err: o
        }), i();
      }
    });
  }
  /**
   * Get all CoValue IDs that have at least one unsynced peer.
   */
  getAll() {
    return Array.from(this.unsynced.keys());
  }
  /**
   * Check if all CoValues are synced
   */
  isAllSynced() {
    return this.unsynced.size === 0;
  }
  /**
   * Check if a specific CoValue is tracked as unsynced.
   */
  has(A) {
    return this.unsynced.has(A);
  }
  subscribe(A, e) {
    if (typeof A == "string" && e) {
      const o = A;
      this.coValueListeners.has(o) || this.coValueListeners.set(o, /* @__PURE__ */ new Set()), this.coValueListeners.get(o).add(e);
      const r = !this.unsynced.has(o);
      return e(r), () => {
        const n = this.coValueListeners.get(o);
        n && (n.delete(e), n.size === 0 && this.coValueListeners.delete(o));
      };
    }
    const i = A;
    return this.globalListeners.add(i), i(this.isAllSynced()), () => {
      this.globalListeners.delete(i);
    };
  }
  setStorage(A) {
    this.storage = A;
  }
  removeStorage() {
    this.storage = void 0;
  }
  /**
   * Notify all listeners for a specific CoValue about sync status change.
   */
  notifyCoValueListeners(A, e) {
    const i = this.coValueListeners.get(A);
    if (i)
      for (const o of i)
        o(e);
  }
  /**
   * Notify all global listeners about "all synced" status change.
   */
  notifyGlobalListeners(A) {
    for (const e of this.globalListeners)
      e(A);
  }
  /**
   * Keep only the last update for each (id, peerId) combination
   */
  simplifyPendingUpdates(A) {
    const e = /* @__PURE__ */ new Map();
    for (const i of A)
      e.set(`${i.id}|${i.peerId}`, i);
    return Array.from(e.values());
  }
}
class FB {
  constructor(A) {
    this.processQueues = A, this.currentQueue = 0, this.pullCounter = ge.getMeter("cojson").createCounter("jazz.messagequeue.incoming.pulled", {
      description: "Number of messages pulled from the queue",
      valueType: WA.INT,
      unit: "1"
    }), this.pushCounter = ge.getMeter("cojson").createCounter("jazz.messagequeue.incoming.pushed", {
      description: "Number of messages pushed to the queue",
      valueType: WA.INT,
      unit: "1"
    }), this.pullCounter.add(0, {
      peerRole: "client"
    }), this.pushCounter.add(0, {
      peerRole: "client"
    }), this.pullCounter.add(0, {
      peerRole: "server"
    }), this.pushCounter.add(0, {
      peerRole: "server"
    }), this.queues = [], this.peerToQueue = /* @__PURE__ */ new WeakMap();
  }
  push(A, e) {
    const i = this.peerToQueue.get(e);
    if (i)
      i.push(A);
    else {
      const o = new ho();
      this.peerToQueue.set(e, o), this.queues.push([o, e]), o.push(A);
    }
    this.pushCounter.add(1, {
      peerRole: e.role
    }), this.processQueues();
  }
  pull() {
    const A = this.queues[this.currentQueue];
    if (!A)
      return;
    const [e, i] = A, o = e.shift();
    if (e.isEmpty() ? (this.queues.splice(this.currentQueue, 1), this.peerToQueue.delete(i)) : this.currentQueue++, this.currentQueue >= this.queues.length && (this.currentQueue = 0), o)
      return this.pullCounter.add(1, {
        peerRole: i.role
      }), { msg: o, peer: i };
  }
}
class bB {
  constructor(A) {
    this.sync = A, this.batch = [], this.syncTransaction = (e, i) => {
      const o = this.lastUpdatedValue, r = this.lastUpdatedValueKnownState;
      if (o && r) {
        if (o.id === e.id)
          return;
        this.addContentToBatch(o, r);
      }
      this.lastUpdatedValue = e, this.lastUpdatedValueKnownState = i;
      for (const n of this.dirtyCoValuesTrackingSets)
        n.add(e.id);
      this.scheduleNextBatch();
    }, this.nextBatchScheduled = !1, this.dirtyCoValuesTrackingSets = /* @__PURE__ */ new Set(), this.trackDirtyCoValues = () => {
      const e = /* @__PURE__ */ new Set();
      return this.dirtyCoValuesTrackingSets.add(e), {
        done: () => (this.dirtyCoValuesTrackingSets.delete(e), e)
      };
    };
  }
  addContentToBatch(A, e) {
    const i = A.newContentSince(e);
    if (i)
      for (const o of i)
        this.batch.push(o);
  }
  scheduleNextBatch() {
    this.nextBatchScheduled || (this.nextBatchScheduled = !0, queueMicrotask(() => {
      this.lastUpdatedValue && this.lastUpdatedValueKnownState && this.addContentToBatch(this.lastUpdatedValue, this.lastUpdatedValueKnownState);
      const A = this.batch;
      this.lastUpdatedValue = void 0, this.lastUpdatedValueKnownState = void 0, this.batch = [], this.nextBatchScheduled = !1;
      for (const e of A)
        this.sync(e);
    }));
  }
}
function ls(t) {
  return t.role === "server" && (t.persistent ?? !1);
}
class RB {
  ignoreUnknownCoValuesFromServers() {
    this._ignoreUnknownCoValuesFromServers = !0;
  }
  constructor(A) {
    this.peers = {}, this.skipVerify = !1, this._ignoreUnknownCoValuesFromServers = !1, this.peersCounter = ge.getMeter("cojson").createUpDownCounter("jazz.peers", {
      description: "Amount of connected peers",
      valueType: WA.INT,
      unit: "peer"
    }), this.messagesQueue = new FB(() => this.processQueues()), this.processing = !1, this.syncQueue = new bB((e) => this.syncContent(e)), this.syncLocalTransaction = this.syncQueue.syncTransaction, this.trackDirtyCoValues = this.syncQueue.trackDirtyCoValues, this.local = A, this.syncState = new NB(this), this.unsyncedTracker = new GB(), this.transactionsSizeHistogram = ge.getMeter("cojson").createHistogram("jazz.transactions.size", {
      description: "The size of transactions in a covalue",
      unit: "bytes",
      valueType: WA.INT
    });
  }
  disableTransactionVerification() {
    this.skipVerify = !0;
  }
  getPeers(A) {
    return this.getServerPeers(A).concat(this.getClientPeers());
  }
  getClientPeers() {
    return Object.values(this.peers).filter((A) => A.role === "client");
  }
  getServerPeers(A, e) {
    const i = Object.values(this.peers).filter((o) => o.role === "server" && o.id !== e);
    return this.serverPeerSelector ? this.serverPeerSelector(A, i) : i;
  }
  getPersistentServerPeers(A) {
    return this.getServerPeers(A).filter((e) => e.persistent);
  }
  handleSyncMessage(A, e) {
    if (!hg(A.id)) {
      const i = A.id ? "invalid" : "undefined";
      AA.warn(`Received sync message with ${i} id`, {
        msg: A
      });
      return;
    }
    if (e.role === "server" && this._ignoreUnknownCoValuesFromServers && !this.local.hasCoValue(A.id)) {
      AA.warn(`Ignoring message ${A.action} on unknown coValue ${A.id} from peer ${e.id}`);
      return;
    }
    if (this.local.getCoValue(A.id).isErroredInPeer(e.id)) {
      AA.warn(`Skipping message ${A.action} on errored coValue ${A.id} from peer ${e.id}`);
      return;
    }
    switch (A.action) {
      case "load":
        return this.handleLoad(A, e);
      case "known":
        return A.isCorrection ? this.handleCorrection(A, e) : this.handleKnownState(A, e);
      case "content":
        return this.handleNewContent(A, e);
      case "done":
        return;
      default:
        throw new Error(`Unknown message type ${A.action}`);
    }
  }
  sendNewContent(A, e, i = /* @__PURE__ */ new Set()) {
    if (i.has(A))
      return;
    i.add(A);
    const o = this.local.getCoValue(A);
    if (!o.isAvailable())
      return;
    if (e.role !== "server")
      for (const s of o.getDependedOnCoValues())
        this.sendNewContent(s, e, i);
    const n = o.newContentSince(e.getOptimisticKnownState(A));
    if (n) {
      for (const s of n)
        this.trySendToPeer(e, s);
      e.combineOptimisticWith(A, o.knownState());
    } else e.toldKnownState.has(A) || (o.isDeleted ? this.trySendToPeer(e, o.stopSyncingKnownStateMessage(e.getKnownState(A))) : this.trySendToPeer(e, {
      action: "known",
      ...o.knownStateWithStreaming()
    }));
    e.trackToldKnownState(A);
  }
  reconcileServerPeers() {
    const A = Object.values(this.peers).filter((e) => e.role === "server");
    for (const e of A)
      this.startPeerReconciliation(e);
  }
  async resumeUnsyncedCoValues() {
    this.local.storage && await new Promise((A, e) => {
      this.local.storage?.getUnsyncedCoValueIDs((i) => {
        const o = i.filter((a) => !this.local.hasCoValue(a));
        if (o.length === 0) {
          A();
          return;
        }
        const r = 10;
        let n = 0;
        const s = async () => {
          const a = o.slice(n, n + r);
          await Promise.all(a.map(async (g) => new Promise((I) => {
            try {
              this.local.storage?.stopTrackingSyncState(g), this.trackSyncState(g), this.local.getCoValue(g).loadFromStorage((C) => {
                C || this.unsyncedTracker.removeAll(g), I();
              });
            } catch (c) {
              AA.warn(`Failed to resume sync for CoValue ${g}:`, {
                err: c,
                coValueId: g
              }), this.unsyncedTracker.removeAll(g), I();
            }
          }))), n += a.length, n < o.length ? s().catch(e) : A();
        };
        s().catch(e);
      });
    });
  }
  startPeerReconciliation(A) {
    ls(A) && this.resumeUnsyncedCoValues().catch((r) => {
      AA.warn("Failed to resume unsynced CoValues:", r);
    });
    const e = [], i = /* @__PURE__ */ new Set(), o = (r) => {
      if (!i.has(r.id) && (i.add(r.id), this.getServerPeers(r.id).find((n) => n.id === A.id) !== void 0)) {
        for (const n of r.getDependedOnCoValues()) {
          const s = this.local.getCoValue(n);
          s.isAvailable() && o(s);
        }
        e.push(r);
      }
    };
    for (const r of this.local.allCoValues()) {
      if (r.isAvailable())
        o(r);
      else {
        if (r.loadingState === "unknown")
          continue;
        A.loadRequestSent.has(r.id) || A.sendLoadRequest(r, "low-priority");
      }
      A.getKnownState(r.id) || A.setKnownState(r.id, "empty");
    }
    for (const r of e)
      A.sendLoadRequest(r, "low-priority");
  }
  pushMessage(A, e) {
    this.messagesQueue.push(A, e);
  }
  /**
   * Get the storage streaming queue if available.
   * Returns undefined if storage doesn't have a streaming queue.
   */
  getStorageStreamingQueue() {
    const A = this.local.storage;
    if (A && "streamingQueue" in A)
      return A.streamingQueue;
  }
  /**
   * Unified queue processing that coordinates both incoming messages
   * and storage streaming entries.
   *
   * Processes items from both queues with priority ordering:
   * - Incoming messages are processed via round-robin across peers
   * - Storage streaming entries are processed by priority (MEDIUM before LOW)
   *
   * Implements time budget scheduling to avoid blocking the main thread.
   */
  async processQueues() {
    if (this.processing)
      return;
    this.processing = !0;
    let A = performance.now();
    const e = this.getStorageStreamingQueue();
    for (; ; ) {
      const i = this.messagesQueue.pull();
      if (i)
        try {
          this.handleSyncMessage(i.msg, i.peer);
        } catch (n) {
          AA.error("Error processing message", { err: n });
        }
      const o = e?.pull();
      if (o)
        try {
          o();
        } catch (n) {
          AA.error("Error processing storage streaming entry", {
            err: n
          });
        }
      if (!i && !o)
        break;
      performance.now() - A > sB.INCOMING_MESSAGES_TIME_BUDGET && (await Jg(), A = performance.now());
    }
    this.processing = !1;
  }
  addPeer(A, e = !1) {
    const i = this.peers[A.id], o = i ? i.newPeerStateFrom(A) : new Cn(A, void 0);
    this.peers[A.id] = o, this.peersCounter.add(1, { role: A.role });
    const r = o.subscribeToKnownStatesUpdates((n, s) => {
      this.syncState.triggerUpdate(A, n, s.value());
    });
    !e && o.role === "server" && this.startPeerReconciliation(o), o.incoming.onMessage((n) => {
      if (n === "Disconnected") {
        o.gracefulShutdown();
        return;
      }
      this.pushMessage(n, o);
    }), o.addCloseListener(() => {
      r(), this.peersCounter.add(-1, { role: A.role }), !A.persistent && this.peers[A.id] === o && this.removePeer(A.id);
    });
  }
  removePeer(A) {
    const e = this.peers[A];
    e && (e.closed || e.gracefulShutdown(), delete this.peers[e.id]);
  }
  trySendToPeer(A, e) {
    return A.pushOutgoingMessage(e);
  }
  /**
   * Handles the load message from a peer.
   *
   * Differences with the known state message:
   * - The load message triggers the CoValue loading process on the other peer
   * - The peer known state is stored as-is instead of being merged
   * - The load message always replies with a known state message
   */
  handleLoad(A, e) {
    e.setKnownState(A.id, Vo(A));
    const i = this.local.getCoValue(A.id);
    if (i.isAvailable()) {
      this.sendNewContent(A.id, e);
      return;
    }
    const o = e.getOptimisticKnownState(A.id);
    if (!o?.header) {
      this.loadFromStorageAndRespond(A.id, e, i);
      return;
    }
    i.getKnownStateFromStorage((r) => {
      if (i.isAvailable()) {
        this.sendNewContent(A.id, e);
        return;
      }
      if (!r) {
        this.loadFromPeersAndRespond(A.id, e, i);
        return;
      }
      if (QB(r, o)) {
        e.trackToldKnownState(A.id), this.trySendToPeer(e, {
          action: "known",
          ...r
        });
        return;
      }
      this.loadFromStorageAndRespond(A.id, e, i);
    });
  }
  /**
   * Helper to load from storage and respond appropriately.
   * Falls back to peers if not found in storage.
   */
  loadFromStorageAndRespond(A, e, i) {
    i.loadFromStorage((o) => {
      o && i.isAvailable() ? this.sendNewContent(A, e) : this.loadFromPeersAndRespond(A, e, i);
    });
  }
  /**
   * Helper to load from peers and respond appropriately.
   */
  loadFromPeersAndRespond(A, e, i) {
    const o = this.getServerPeers(A, e.id);
    i.loadFromPeers(o);
    const r = () => {
      if (i.isAvailable()) {
        this.sendNewContent(A, e);
        return;
      }
      this.handleLoadNotFound(A, e);
    };
    o.length > 0 ? i.waitForAvailableOrUnavailable().then(r) : r();
  }
  /**
   * Handle case when CoValue is not found.
   */
  handleLoadNotFound(A, e) {
    e.trackToldKnownState(A), this.trySendToPeer(e, {
      action: "known",
      id: A,
      header: !1,
      sessions: {}
    });
  }
  /**
   * Request full content from a peer when we don't have the CoValue.
   */
  requestFullContent(A, e) {
    e ? this.trySendToPeer(e, {
      action: "known",
      isCorrection: !0,
      id: A,
      header: !1,
      sessions: {}
    }) : AA.error("Received new content with no header on a missing CoValue", {
      id: A
    });
  }
  handleKnownState(A, e) {
    const i = this.local.getCoValue(A.id);
    e.combineWith(A.id, Vo(A)), e.getOptimisticKnownState(A.id)?.header || i.markNotFoundInPeer(e.id), i.isAvailable() && this.sendNewContent(A.id, e), e.trackLoadRequestComplete(i);
  }
  recordTransactionsSize(A, e) {
    for (const i of A) {
      const o = lo(i);
      this.transactionsSizeHistogram.record(o, {
        source: e
      });
    }
  }
  handleNewContent(A, e) {
    const i = this.local.getCoValue(A.id), o = e === "storage" || e === "import" ? void 0 : e, r = e === "storage" ? "storage" : e === "import" ? "import" : o?.role;
    if (o?.role === "client" && A.expectContentUntil && (A = {
      ...A,
      expectContentUntil: void 0
    }), o?.trackLoadRequestUpdate(i), i.addDependenciesFromContentMessage(A), !this.skipVerify && i.hasMissingDependencies()) {
      i.addNewContentToQueue(A, e);
      for (const I of i.missingDependencies) {
        const c = this.local.getCoValue(I);
        if (!c.hasVerifiedContent()) {
          const C = this.getServerPeers(I);
          o?.role === "client" && C.push(o), c.load(C, "immediate");
        }
      }
      return;
    }
    if (i.hasVerifiedContent())
      A.expectContentUntil && i.verified.setStreamingKnownState(A.expectContentUntil);
    else {
      if (!A.header) {
        if (e === "storage") {
          AA.warn("Received content from storage without header - CoValue may have been garbage collected mid-stream", {
            id: A.id,
            from: e
          });
          return;
        }
        i.loadFromStorage((C) => {
          C ? this.handleNewContent(A, e) : this.requestFullContent(A.id, o);
        });
        return;
      }
      const I = i.loadingState;
      if (!i.provideHeader(A.header, A.expectContentUntil, this.skipVerify)) {
        AA.error("Failed to provide header", {
          id: A.id,
          header: A.header
        });
        return;
      }
      i.markFoundInPeer(o?.id ?? "storage", I), o?.updateHeader(A.id, !0), A.expectContentUntil && o?.combineWith(A.id, {
        id: A.id,
        header: !0,
        sessions: A.expectContentUntil
      });
    }
    if (!i.hasVerifiedContent())
      throw new Error("Unreachable: CoValue should always have a verified state at this point");
    let n = !1;
    const s = {
      action: "content",
      id: A.id,
      priority: A.priority,
      header: A.header,
      new: {}
    };
    let a = i.isDeleted;
    for (const [I, c] of uB(A)) {
      if (a && !ve(I))
        continue;
      const C = dB(c, i.knownState(), I);
      if (C === void 0) {
        n = !0;
        continue;
      }
      if (C.length === 0)
        continue;
      const B = i.tryAddTransactions(I, C, c.lastSignature, this.skipVerify);
      if (B) {
        o ? (AA.error("Failed to add transactions", {
          peerId: o.id,
          peerRole: o.role,
          id: A.id,
          errorType: B.type,
          err: B.error,
          sessionID: I,
          msgKnownState: Xt(A).sessions,
          msgSummary: _o(A),
          knownState: i.knownState().sessions
        }), i.markErrored(o.id, B)) : AA.error("Failed to add transactions from storage", {
          id: A.id,
          err: B.error,
          sessionID: I,
          errorType: B.type
        });
        continue;
      }
      r && r !== "import" && this.recordTransactionsSize(C, r), !a && i.isDeleted && (a = !0, s.new = {}), s.new[I] = c;
    }
    o && (i.isDeleted ? o.combineWith(A.id, Xt(A)) : o.combineWith(A.id, Xt(s))), n ? o ? (this.trySendToPeer(o, {
      action: "known",
      isCorrection: !0,
      ...i.knownState()
    }), o.trackToldKnownState(A.id)) : AA.error("Invalid state assumed when handling new content from storage", {
      id: A.id,
      content: _o(A),
      knownState: i.knownState()
    }) : o && (i.isDeleted ? this.trySendToPeer(o, i.stopSyncingKnownStateMessage(o.getKnownState(A.id))) : this.trySendToPeer(o, {
      action: "known",
      ...i.knownState()
    }), o.trackToldKnownState(A.id));
    const g = s.header || Object.keys(s.new).length > 0;
    e !== "storage" && g && (this.storeContent(s), e === "import" && this.trackSyncState(i.id)), o?.trackLoadRequestComplete(i);
    for (const I of this.getPeers(i.id)) {
      if (I.closed || i.isErroredInPeer(I.id)) {
        I.emitCoValueChange(i.id);
        continue;
      }
      I.isCoValueSubscribedToPeer(i.id) ? this.sendNewContent(i.id, I) : I.role === "server" && I.sendLoadRequest(i);
    }
  }
  handleCorrection(A, e) {
    return e.setKnownState(A.id, Vo(A)), this.sendNewContent(A.id, e);
  }
  syncContent(A) {
    const e = this.local.getCoValue(A.id);
    this.storeContent(A), this.trackSyncState(e.id);
    const i = Xt(A);
    for (const o of this.getPeers(e.id))
      if (!(o.role === "client" && !o.isCoValueSubscribedToPeer(e.id))) {
        if (o.closed || e.isErroredInPeer(o.id)) {
          o.emitCoValueChange(A.id);
          continue;
        }
        this.trySendToPeer(o, A), o.combineOptimisticWith(e.id, i), o.trackToldKnownState(e.id);
      }
  }
  trackSyncState(A) {
    const e = this.getPersistentServerPeers(A);
    if (this.local.syncWhen !== "never" && e.length === 0) {
      this.unsyncedTracker.add(A);
      const o = this.syncState.subscribeToCoValueUpdates(A, (r, n, s) => {
        ls(r) && s.uploaded && (this.unsyncedTracker.remove(A), o());
      });
      return;
    }
    for (const o of e) {
      if (this.syncState.isSynced(o, A) || this.unsyncedTracker.add(A, o.id))
        continue;
      const n = this.syncState.subscribeToPeerUpdates(o.id, A, (s, a) => {
        a.uploaded && (this.unsyncedTracker.remove(A, o.id), n());
      });
    }
  }
  storeContent(A) {
    const e = this.local.storage;
    if (!e)
      return;
    const i = this.local.getCoValue(A.id);
    i.isDeleted && e.markDeleteAsValid(i.id), e.store(A, (o) => {
      if (!i.verified) {
        AA.error("Correction requested for a CoValue with no verified content", {
          id: A.id,
          content: _o(A),
          correction: o,
          state: i.loadingState
        });
        return;
      }
      return i.newContentSince(o);
    });
  }
  /**
   * Returns true if the local CoValue changes have been synced to all persistent server peers.
   *
   * Used during garbage collection to determine if the coValue is pending sync.
   */
  isSyncedToServerPeers(A) {
    return this.getPersistentServerPeers(A).every((e) => this.syncState.isSynced(e, A));
  }
  waitForSyncWithPeer(A, e, i) {
    const o = this.peers[A];
    if (o) {
      if (o.isCoValueSubscribedToPeer(e)) {
        if (this.syncState.isSynced(o, e))
          return;
      } else if (o.role === "client")
        return;
      return new Promise((r, n) => {
        const s = this.syncState.subscribeToPeerUpdates(A, e, (g, I) => {
          I.uploaded && (r(!0), s?.(), clearTimeout(a));
        }), a = setTimeout(() => {
          const g = this.local.getCoValue(e), I = g.getErroredInPeerError(A), c = g.knownState().sessions, C = o.getKnownState(e)?.sessions ?? {};
          let B = `Timeout on waiting for sync with peer ${A} for coValue ${e}:
  Known state: ${JSON.stringify(c)}
  Peer state: ${JSON.stringify(C)}
`;
          I && (B += `
Marked as errored: "${I}"`), n(new Error(B)), s?.();
        }, i);
      });
    }
  }
  waitForStorageSync(A) {
    return this.local.storage?.waitForSync(A, this.local.getCoValue(A));
  }
  waitForSync(A, e = 6e4) {
    const i = this.getPeers(A);
    return Promise.all(i.map((o) => this.waitForSyncWithPeer(o.id, A, e)).concat(this.waitForStorageSync(A)));
  }
  waitForAllCoValuesSync(A = 6e4) {
    const e = this.local.allCoValues(), i = Array.from(e).filter((o) => o.loadingState === "available" || o.loadingState === "loading");
    return Promise.all(i.map((o) => this.waitForSync(o.id, A)));
  }
  setStorage(A) {
    this.unsyncedTracker.setStorage(A);
    const e = this.getStorageStreamingQueue();
    e && e.setListener(() => {
      this.processQueues();
    });
  }
  removeStorage() {
    this.unsyncedTracker.removeStorage();
  }
  /**
   * Closes all the peer connections and ensures the list of unsynced coValues is persisted to storage.
   * @returns Promise of the current pending store operation, if any.
   */
  gracefulShutdown() {
    for (const A of Object.values(this.peers))
      A.gracefulShutdown();
    return this.unsyncedTracker.forcePersist();
  }
}
let Jg = () => new Promise((t) => queueMicrotask(t));
typeof setImmediate == "function" && (Jg = () => new Promise((t) => setImmediate(t)));
function KB(t, A, { peer1role: e = "client", peer2role: i = "client", persistent: o = !1 } = {}) {
  const r = new Dr(), n = new Dr();
  return [{
    id: t,
    incoming: r,
    outgoing: n,
    role: e,
    persistent: o
  }, {
    id: A,
    incoming: n,
    outgoing: r,
    role: i,
    persistent: o
  }];
}
let Dr = class {
  constructor() {
    this.buffer = [], this.listeners = /* @__PURE__ */ new Set(), this.closed = !1, this.closeListeners = /* @__PURE__ */ new Set();
  }
  push(A) {
    if (!this.listeners.size) {
      this.buffer.push(A);
      return;
    }
    for (const e of this.listeners)
      e(A);
  }
  close() {
    this.closed = !0;
    for (const A of this.closeListeners)
      A();
    this.closeListeners.clear(), this.listeners.clear();
  }
  onMessage(A) {
    if (this.buffer.length) {
      for (const e of this.buffer)
        A(e);
      this.buffer = [];
    }
    this.listeners.add(A);
  }
  onClose(A) {
    this.closeListeners.add(A);
  }
};
class Ge {
  /** @category 3. Low-level */
  constructor(A, e, i, o) {
    this.syncWhen = o, this.coValues = /* @__PURE__ */ new Map(), this.syncManager = new RB(this), this.garbageCollector = void 0, this.crashed = void 0, this.agentSecret = A, this.currentSessionID = e, this.crypto = i;
  }
  enableGarbageCollector() {
    this.garbageCollector || (this.garbageCollector = new mB(this));
  }
  setStorage(A) {
    this.storage = A, this.syncManager.setStorage(A);
  }
  removeStorage() {
    this.storage?.close(), this.storage = void 0, this.syncManager.removeStorage();
  }
  /**
   * Enable background erasure of deleted coValues (space reclamation).
   *
   * Deleted coValues are immediately blocked from syncing via tombstones; this feature
   * only reclaims local storage space by deleting historical content while preserving
   * the tombstone (header + delete session).
   *
   * This is opt-in and affects only the currently configured storage (if any)
   *
   * @category 3. Low-level
   */
  enableDeletedCoValuesErasure() {
    this.storage?.enableDeletedCoValuesErasure();
  }
  hasCoValue(A) {
    const e = this.coValues.get(A);
    if (!e)
      return !1;
    const i = e.loadingState;
    return i !== "unknown" && i !== "garbageCollected" && i !== "onlyKnownState";
  }
  getCoValue(A) {
    let e = this.coValues.get(A);
    return e || (e = new Qs(A, this), this.coValues.set(A, e)), this.garbageCollector?.trackCoValueAccess(e), e;
  }
  allCoValues() {
    return this.coValues.values();
  }
  /**
   * Simple delete of a CoValue from memory.
   * Used for testing and forced cleanup scenarios.
   * @internal
   */
  internalDeleteCoValue(A) {
    this.coValues.delete(A), this.storage?.onCoValueUnmounted(A);
  }
  /**
   * Unmount a CoValue from memory, keeping a shell with cached knownState.
   * This enables accurate LOAD requests during peer reconciliation.
   *
   * @returns true if the coValue was successfully unmounted, false otherwise
   */
  internalUnmountCoValue(A) {
    const e = this.coValues.get(A);
    if (!e || e.listeners.size > 0)
      return !1;
    for (const r of e.dependant)
      if (this.hasCoValue(r))
        return !1;
    if (!this.syncManager.isSyncedToServerPeers(A))
      return !1;
    const i = e.knownState();
    e.decrementLoadingStateCounter();
    const o = new Qs(A, this);
    return o.setGarbageCollectedState(i), this.coValues.set(A, o), this.storage?.onCoValueUnmounted(A), !0;
  }
  getCurrentAccountOrAgentID() {
    return OA(this.currentSessionID);
  }
  getCurrentAgent() {
    if (!this._cachedCurrentAgent) {
      const A = this.getCurrentAccountOrAgentID();
      Xe(A) ? this._cachedCurrentAgent = new os(this.agentSecret, this.crypto) : this._cachedCurrentAgent = new eB(rs(this.expectCoValueLoaded(A).getCurrentContent()), this.agentSecret);
    }
    return this._cachedCurrentAgent;
  }
  expectCurrentAccountID(A) {
    const e = this.getCurrentAccountOrAgentID();
    if (Xe(e))
      throw new Error("Current account is an agent, but expected an account: " + A);
    return e;
  }
  expectCurrentAccount(A) {
    const e = this.expectCurrentAccountID(A);
    return rs(this.expectCoValueLoaded(e).getCurrentContent());
  }
  static internalCreateAccount(A) {
    const { crypto: e, initialAgentSecret: i = e.newRandomAgentSecret(), peers: o = [], syncWhen: r } = A, n = Ng(i, e), s = Yt(n, e), a = new Ge(i, e.newRandomSessionID(s), e, r);
    A.storage && a.setStorage(A.storage);
    for (const B of o)
      a.syncManager.addPeer(B);
    const g = e.getAgentID(i), I = bA(a.createCoValue(n).getCurrentContent());
    I.set(g, "admin", "trusting");
    const c = e.newRandomKeySecret(), C = e.seal({
      message: c.secret,
      from: e.getAgentSealerSecret(i),
      to: e.getAgentSealerID(g),
      nOnceMaterial: {
        in: I.id,
        tx: I.core.nextTransactionID()
      }
    });
    return I.set(`${c.id}_for_${g}`, C, "trusting"), I.set("readKey", c.id, "trusting"), a.expectCurrentAccount("after creation");
  }
  /** @category 2. Node Creation */
  static async withNewlyCreatedAccount({ creationProps: A, peers: e, syncWhen: i, migration: o, crypto: r, initialAgentSecret: n = r.newRandomAgentSecret(), storage: s }) {
    const a = Ge.internalCreateAccount({
      crypto: r,
      initialAgentSecret: n,
      peers: e,
      syncWhen: i,
      storage: s
    }), g = a.core.node;
    if (o)
      await o(a, g, A);
    else {
      const c = g.createGroup();
      c.addMember("everyone", "reader");
      const C = c.createMap({
        name: A.name
      });
      a.set("profile", C.id, "trusting");
    }
    const I = a.get("profile");
    if (!I)
      throw new Error("Must set account profile in initial migration");
    return g.storage && await Promise.all([
      g.syncManager.waitForStorageSync(a.id),
      g.syncManager.waitForStorageSync(I)
    ]), {
      node: g,
      accountID: a.id,
      accountSecret: n,
      sessionID: g.currentSessionID
    };
  }
  /** @category 2. Node Creation */
  static async withLoadedAccount({ accountID: A, accountSecret: e, sessionID: i, peers: o, syncWhen: r, crypto: n, migration: s, storage: a }) {
    try {
      const g = n.getAgentID(e), I = new Ge(e, i || n.newRandomSessionID(A), n, r);
      a && I.setStorage(a);
      for (const Q of o)
        I.syncManager.addPeer(Q);
      const c = await I.load(A);
      if (c === "unavailable")
        throw new Error("Account unavailable from all peers");
      if (c.currentAgentID() !== g)
        throw new Error("Account secret does not match expected agent ID in account");
      const C = c.get("profile");
      if (!C)
        throw new Error("Account has no profile");
      const B = c.get("root");
      return B && (c.getRaw("root")?.trusting || c.set("root", B, "trusting")), await I.load(C), s && await s(c, I), I;
    } catch (g) {
      throw AA.error("Error withLoadedAccount", { err: g }), g;
    }
  }
  /** @internal */
  createCoValue(A) {
    if (this.crashed)
      throw new Error("Trying to create CoValue after node has crashed", {
        cause: this.crashed
      });
    const e = Yt(A, this.crypto), i = this.getCoValue(e);
    if (i.provideHeader(A), !i.hasVerifiedContent())
      throw new Error("CoValue not available after providing header");
    return this.garbageCollector?.trackCoValueAccess(i), this.syncManager.syncLocalTransaction(i.verified, Je(e)), i;
  }
  /** @internal */
  async loadCoValueCore(A, e, i) {
    if (!hg(A))
      throw new TypeError(`Trying to load CoValue with invalid id ${Array.isArray(A) ? JSON.stringify(A) : A}`);
    if (this.crashed)
      throw new Error("Trying to load CoValue after node has crashed", {
        cause: this.crashed
      });
    let o = 0;
    for (; ; ) {
      const r = this.getCoValue(A);
      if (r.isAvailable())
        return r;
      if (r.loadingState === "unknown" || r.loadingState === "unavailable" || r.loadingState === "garbageCollected" || r.loadingState === "onlyKnownState") {
        const s = this.syncManager.getServerPeers(A, e);
        if (!this.storage && s.length === 0)
          return r.markNotFoundInPeer("storage"), r;
        r.load(s);
      }
      const n = await r.waitForAvailableOrUnavailable();
      if (n.isAvailable() || i || o >= At.MAX_RETRIES)
        return n;
      await Promise.race([
        new Promise((s) => setTimeout(s, At.RETRY_DELAY)),
        r.waitForAvailable()
        // Stop waiting if the coValue becomes available
      ]), o++;
    }
  }
  /**
   * Loads a CoValue's content, syncing from peers as necessary and resolving the returned
   * promise once a first version has been loaded. See `coValue.subscribe()` and `node.useTelepathicData()`
   * for listening to subsequent updates to the CoValue.
   *
   * @category 3. Low-level
   */
  async load(A, e) {
    const i = await this.loadCoValueCore(A, void 0, e);
    return i.isAvailable() ? i.getCurrentContent() : "unavailable";
  }
  /**
   * Loads a branch from a group coValue, creating a new one if it doesn't exist.
   *
   * Returns "unavailable" in case of errors or missing source.
   */
  async checkoutBranch(A, e, i) {
    const o = await this.loadCoValueCore(A);
    if (!o.isAvailable())
      return "unavailable";
    if (!vg(o))
      return o.getCurrentContent();
    const r = o.getBranch(e, i);
    return r.isAvailable() ? r.getCurrentContent() : !o.hasBranch(e, i) || (await this.loadCoValueCore(r.id), !r.isAvailable()) ? o.createBranch(e, i).getCurrentContent() : r.getCurrentContent();
  }
  getLoaded(A) {
    const e = this.getCoValue(A);
    if (e.isAvailable())
      return e.getCurrentContent();
  }
  /** @category 3. Low-level */
  subscribe(A, e, i) {
    let o = !1, r;
    return this.load(A, i).then((n) => {
      if (!o) {
        if (n === "unavailable") {
          e("unavailable");
          return;
        }
        r = n.subscribe(e);
      }
    }).catch((n) => {
      AA.error("Subscription error", {
        id: A,
        err: n
      });
    }), () => {
      o = !0, r?.();
    };
  }
  async acceptInvite(A, e) {
    const i = await this.load(A);
    if (i === "unavailable")
      throw new Error("Trying to accept invite: Group/owned value unavailable from all peers");
    const o = i.core.verified.header.ruleset;
    let r;
    if (o.type === "unsafeAllowAll")
      throw new Error("Can only accept invites to values owned by groups");
    if (o.type === "ownedByGroup") {
      const Q = await this.load(o.group);
      if (Q === "unavailable")
        throw new Error("Trying to accept invite: CoValue owner unavailable from all peers");
      r = bA(Q);
    } else
      r = bA(i);
    if (r.core.verified.header.meta?.type === "account")
      throw new Error("Can't accept invites to values owned by accounts");
    const n = this.crypto.agentSecretFromSecretSeed(AB(e)), s = this.crypto.getAgentID(n), a = await new Promise((Q, f) => {
      r.subscribe((l) => {
        const u = l.get(s);
        u && Q(u);
      }), setTimeout(() => f(new Error("Couldn't find invite before timeout")), 2e3);
    });
    if (!a)
      throw new Error("No invite found");
    const g = this.getCurrentAgent(), I = r.get(g.id);
    if (I === "admin" || I === "writer" && a === "writerInvite" || I === "writer" && a === "reader" || I === "reader" && a === "readerInvite" || I && a === "writeOnlyInvite") {
      AA.debug("Not accepting invite that would replace or downgrade role");
      return;
    }
    const c = await this.loadCoValueAsDifferentAgent(r.id, n), C = bA(c.getCurrentContent());
    C.addMemberInternal(g, a === "adminInvite" ? "admin" : a === "managerInvite" ? "manager" : a === "writerInvite" ? "writer" : a === "writeOnlyInvite" ? "writeOnly" : "reader");
    const B = C.core.newContentSince(r.core.knownState()) ?? [];
    for (const Q of B)
      this.syncManager.handleNewContent(Q, "import");
  }
  /** @internal */
  expectCoValueLoaded(A, e) {
    const i = this.getCoValue(A);
    if (!i.isAvailable())
      throw new Error(`${e ? e + ": " : ""}CoValue ${A} not yet loaded.`);
    return i;
  }
  /** @internal */
  expectProfileLoaded(A, e) {
    const i = this.expectCoValueLoaded(A, e), o = bA(i.getCurrentContent()).get("profile");
    if (!o)
      throw new Error(`${e ? e + ": " : ""}Account ${A} has no profile`);
    return this.expectCoValueLoaded(o, e).getCurrentContent();
  }
  /** @internal */
  resolveAccountAgent(A, e) {
    if (Xe(A))
      return { value: A, error: void 0 };
    let i;
    try {
      i = this.expectCoValueLoaded(A, e);
    } catch (r) {
      return { value: void 0, error: r };
    }
    if (i.verified.header.type !== "comap" || i.verified.header.ruleset.type !== "group" || !i.verified.header.meta || !("type" in i.verified.header.meta) || i.verified.header.meta.type !== "account")
      return {
        value: void 0,
        error: new Error(`Unexpectedly not account: ${e}`)
      };
    const o = i.verified.header.ruleset.initialAdmin;
    return Xe(o) ? { value: o, error: void 0 } : {
      value: void 0,
      error: new Error(`Unexpectedly not account: ${e}`)
    };
  }
  createGroup(A = this.crypto.createdNowUnique()) {
    const e = this.getCurrentAgent(), i = this.createCoValue({
      type: "comap",
      ruleset: { type: "group", initialAdmin: e.id },
      meta: null,
      ...A.createdAt !== void 0 ? { createdAt: A.createdAt } : {},
      uniqueness: A.uniqueness
    }), o = bA(i.getCurrentContent());
    o.set(e.id, "admin", "trusting");
    const r = this.crypto.newRandomKeySecret();
    return o.set(`${r.id}_for_${e.id}`, this.crypto.seal({
      message: r.secret,
      from: e.currentSealerSecret(),
      to: e.currentSealerID(),
      nOnceMaterial: {
        in: i.id,
        tx: i.nextTransactionID()
      }
    }), "trusting"), o.set("readKey", r.id, "trusting"), o;
  }
  async loadCoValueAsDifferentAgent(A, e, i) {
    const o = new os(e, this.crypto), r = new Ge(e, this.crypto.newRandomSessionID(i || o.id), this.crypto);
    return await r.loadVerifiedStateFrom(this, A), r.expectCoValueLoaded(A);
  }
  /** @internal */
  async loadVerifiedStateFrom(A, e) {
    const i = KB("source-" + e, "target-" + e, {
      peer1role: "server",
      peer2role: "client"
    });
    this.syncManager.addPeer(i[0], !0), A.syncManager.addPeer(i[1], !0);
    const o = this.getCoValue(e), r = this.syncManager.peers[i[0].id];
    if (!r)
      throw new Error("Peer state not found");
    o.loadFromPeers([r]), await o.waitForAvailable(), r.gracefulShutdown();
  }
  /**
   * Closes all the peer connections, drains all the queues and closes the storage.
   *
   * @returns Promise of the current pending store operation, if any.
   */
  async gracefulShutdown() {
    return this.garbageCollector?.stop(), await this.syncManager.gracefulShutdown(), this.storage?.close();
  }
}
function vB({ newTxsInSession: t, contentMessage: A, sessionRow: e, firstNewTxIdx: i, signature: o }) {
  let r = A.new[e.sessionID];
  r ? r.lastSignature = o : (r = {
    after: i,
    lastSignature: o,
    newTransactions: []
  }, A.new[e.sessionID] = r);
  for (const n of t)
    r.newTransactions.push(n.tx);
}
function YB(t, A) {
  const e = A.id, i = Object.keys(A.new), o = Object.values(A.new).map((r) => r.newTransactions);
  return cB(e, t, i, o);
}
function UB(t) {
  return t.reduce((A, e) => A + lo(e), 0);
}
const JB = {
  [TA.HIGH]: 0,
  [TA.MEDIUM]: 1,
  [TA.LOW]: 2
};
class HB {
  constructor(A, e, i) {
    this.defaultPriority = A, this.queues = [
      Gt(e, { priority: TA.HIGH, ...i }),
      Gt(e, { priority: TA.MEDIUM, ...i }),
      Gt(e, { priority: TA.LOW, ...i })
    ];
  }
  getQueue(A) {
    return this.queues[JB[A]];
  }
  push(A) {
    const e = "priority" in A ? A.priority : this.defaultPriority;
    this.getQueue(e).push(A);
  }
  pull() {
    const A = this.queues.findIndex((e) => e.length > 0);
    return this.queues[A]?.shift();
  }
}
var Ut;
(function(t) {
  t[t.Pending = 0] = "Pending", t[t.Done = 1] = "Done";
})(Ut || (Ut = {}));
class qB {
  constructor() {
    this.knownStates = /* @__PURE__ */ new Map(), this.waitForSyncRequests = /* @__PURE__ */ new Map();
  }
  getKnownState(A) {
    const e = this.knownStates.get(A);
    if (!e) {
      const i = Je(A);
      return this.knownStates.set(A, i), i;
    }
    return e;
  }
  /**
   * Get a cached knownState if it exists and has a header.
   * Unlike getKnownState, this doesn't create an empty state if one doesn't exist.
   */
  getCachedKnownState(A) {
    const e = this.knownStates.get(A);
    if (e?.header)
      return e;
  }
  setKnownState(A, e) {
    this.knownStates.set(A, e);
  }
  handleUpdate(A, e) {
    const i = this.waitForSyncRequests.get(A);
    if (i)
      for (const o of i)
        ds(o.knownState, e) && (o.resolve(), i.delete(o));
  }
  waitForSync(A, e) {
    const i = e.knownState();
    if (ds(i, this.getKnownState(A)))
      return Promise.resolve();
    const o = this.waitForSyncRequests.get(A) || /* @__PURE__ */ new Set();
    return this.waitForSyncRequests.set(A, o), new Promise((r) => {
      const n = e.subscribe((g) => {
        a.knownState = g.knownState(), this.handleUpdate(A, this.getKnownState(A));
      }, !1), a = { knownState: i, resolve: () => {
        r(), n();
      } };
      o.add(a);
    });
  }
}
function ds(t, A) {
  return !A.header && t.header ? !1 : bg(t.sessions, A.sessions);
}
const xB = {
  throttleMs: 6e4,
  startupDelayMs: 1e3,
  followUpDelayMs: 1e3
};
class LB {
  isDisposed() {
    return this.state === "disposed";
  }
  constructor({ run: A, opts: e }) {
    this.state = "idle", this.runCallback = A, this.opts = e || xB;
  }
  scheduleStartupDrain() {
    this.isDisposed() || this.state === "idle" && this.scheduleTimer("startup_scheduled", this.opts.startupDelayMs);
  }
  onEnqueueDeletedCoValue() {
    this.isDisposed() || this.state === "idle" && this.scheduleTimer("throttle_scheduled", this.opts.throttleMs);
  }
  dispose() {
    this.isDisposed() || (this.state = "disposed", this.scheduledTimeout && clearTimeout(this.scheduledTimeout), this.scheduledTimeout = void 0);
  }
  scheduleTimer(A, e) {
    this.isDisposed() || this.scheduledTimeout || (this.state = A, this.scheduledTimeout = setTimeout(() => {
      this.scheduledTimeout = void 0, this.run();
    }, e));
  }
  async run() {
    if (this.isDisposed())
      return;
    this.state = "running";
    let A;
    try {
      A = await this.runCallback();
    } catch (e) {
      AA.error("Error running deleted co values eraser scheduler", {
        err: e
      }), this.isDisposed() || (this.state = "idle");
      return;
    }
    if (!this.isDisposed()) {
      if (A.hasMore) {
        this.scheduleTimer("followup_scheduled", this.opts.followUpDelayMs);
        return;
      }
      this.state = "idle";
    }
  }
}
class TB {
  constructor() {
    this.backlog = new ho(), this.processing = !1;
  }
  async schedule(A, e) {
    if (this.backlog.push({ queue: A, callback: e }), !this.processing) {
      for (this.processing = !0; this.backlog.head; )
        await this.backlog.head.value.callback(), this.backlog.shift();
      this.processing = !1;
    }
  }
}
class fo {
  constructor() {
    this.queue = new ho(), this.closed = !1, this.processing = !1;
  }
  push(A, e) {
    this.closed || this.queue.push({ data: A, correctionCallback: e });
  }
  pull() {
    return this.queue.shift();
  }
  processQueue(A) {
    if (!this.processing)
      return this.processing = !0, fo.manager.schedule(this, async () => {
        let e;
        for (; e = this.pull(); ) {
          const { data: i, correctionCallback: o } = e;
          try {
            this.lastCallback = A(i, o), await this.lastCallback;
          } catch (r) {
            AA.error("Error processing message in store queue", { err: r });
          }
        }
        this.lastCallback = void 0, this.processing = !1;
      });
  }
  close() {
    for (this.closed = !0; this.pull(); )
      ;
    return this.lastCallback;
  }
}
fo.manager = new TB();
class Hg {
  constructor(A) {
    this.inMemoryCoValues = /* @__PURE__ */ new Set(), this.pendingKnownStateLoads = /* @__PURE__ */ new Map(), this.knownStates = new qB(), this.storeQueue = new fo(), this.deletedValues = /* @__PURE__ */ new Set(), this.dbClient = A;
  }
  getKnownState(A) {
    return this.knownStates.getKnownState(A);
  }
  loadKnownState(A, e) {
    const i = this.knownStates.getCachedKnownState(A);
    if (i) {
      e(i);
      return;
    }
    const o = this.pendingKnownStateLoads.get(A);
    if (o) {
      o.then(e, () => e(void 0));
      return;
    }
    const r = this.dbClient.getCoValueKnownState(A).then((n) => (n && this.knownStates.setKnownState(A, n), n)).catch((n) => {
      AA.warn("Failed to load knownState from storage", { id: A, err: n });
    }).finally(() => {
      this.pendingKnownStateLoads.delete(A);
    });
    this.pendingKnownStateLoads.set(A, r), r.then(e);
  }
  async load(A, e, i) {
    await this.loadCoValue(A, e, i);
  }
  async loadCoValue(A, e, i) {
    this.interruptEraser("load");
    const o = await this.dbClient.getCoValue(A);
    if (!o) {
      i?.(!1);
      return;
    }
    const r = await this.dbClient.getCoValueSessions(o.rowID), n = /* @__PURE__ */ new Map();
    let s = !1;
    await Promise.all(r.map(async (c) => {
      const C = await this.dbClient.getSignatures(c.rowID, 0);
      C.length > 0 && (s = !0, n.set(c.sessionID, C));
    }));
    const a = this.knownStates.getKnownState(o.id);
    a.header = !0;
    for (const c of r)
      Wo(a.sessions, c.sessionID, c.lastIdx);
    this.inMemoryCoValues.add(o.id);
    let g = Mt(o.id, o.header);
    s && (g.expectContentUntil = a.sessions);
    for (const c of r) {
      const C = n.get(c.sessionID) || [];
      let B = 0;
      C[C.length - 1]?.signature !== c.lastSignature && C.push({
        idx: c.lastIdx,
        signature: c.lastSignature
      });
      for (const f of C) {
        const l = await this.dbClient.getNewTransactionInSession(c.rowID, B, f.idx);
        vB({
          newTxsInSession: l,
          contentMessage: g,
          sessionRow: c,
          firstNewTxIdx: B,
          signature: f.signature
        }), B = f.idx + 1, C.length > 1 && (await this.pushContentWithDependencies(o, g, e), g = Mt(o.id, o.header));
      }
    }
    (Object.keys(g.new).length > 0 || !s) && await this.pushContentWithDependencies(o, g, e), this.knownStates.handleUpdate(o.id, a), i?.(!0);
  }
  async pushContentWithDependencies(A, e, i) {
    const o = YB(A.header, e), r = [];
    for (const n of o)
      this.inMemoryCoValues.has(n) || r.push(new Promise((s) => {
        this.loadCoValue(n, i, s);
      }));
    await Promise.all(r), i(e);
  }
  async store(A, e) {
    this.storeQueue.push(A, e), this.storeQueue.processQueue(async (i, o) => (this.interruptEraser("store"), this.storeSingle(i, o)));
  }
  interruptEraser(A) {
    this.eraserController && (this.eraserController.abort(A), this.eraserController = void 0);
  }
  async eraseAllDeletedCoValues() {
    const A = await this.dbClient.getAllCoValuesWaitingForDelete();
    this.eraserController = new AbortController();
    const e = this.eraserController.signal;
    for (const i of A) {
      if (e.aborted)
        return;
      await this.dbClient.eraseCoValueButKeepTombstone(i);
    }
  }
  /**
   * This function is called when the storage lacks the information required to store the incoming content.
   *
   * It triggers a `correctionCallback` to ask the syncManager to provide the missing information.
   *
   * The correction is applied immediately, to ensure that, when applicable, the dependent content in the queue won't require additional corrections.
   */
  async handleCorrection(A, e) {
    const i = e(A);
    if (!i)
      return AA.error("Correction callback returned undefined", {
        knownState: A,
        correction: i ?? null
      }), !1;
    for (const o of i)
      if (!await this.storeSingle(o, (n) => {
        AA.error("Double correction requested", {
          msg: o,
          knownState: n
        });
      }))
        return !1;
    return !0;
  }
  async storeSingle(A, e) {
    if (this.interruptEraser("store"), this.storeQueue.closed)
      return !1;
    const i = A.id, o = await this.dbClient.upsertCoValue(i, A.header);
    if (!o) {
      const s = Je(i);
      return this.knownStates.setKnownState(i, s), this.handleCorrection(s, e);
    }
    const r = this.knownStates.getKnownState(i);
    r.header = !0;
    let n = !1;
    for (const s of Object.keys(A.new))
      await this.dbClient.transaction(async (a) => {
        const g = await a.getSingleCoValueSession(o, s);
        this.deletedValues.has(i) && ve(s) && await a.markCoValueAsDeleted(i), g && Wo(r.sessions, g.sessionID, g.lastIdx);
        const I = g?.lastIdx || 0, c = A.new[s]?.after || 0;
        if (I < c)
          n = !0;
        else {
          const C = await this.putNewTxs(a, A, s, g, o);
          Wo(r.sessions, s, C);
        }
      });
    return this.inMemoryCoValues.add(i), this.knownStates.handleUpdate(i, r), n ? this.handleCorrection(r, e) : !0;
  }
  async putNewTxs(A, e, i, o, r) {
    const n = e.new[i]?.newTransactions || [], s = o?.lastIdx || 0, a = s - (e.new[i]?.after || 0), g = n.slice(a);
    if (g.length === 0)
      return s;
    let I = o?.bytesSinceLastSignature || 0;
    const c = UB(g), C = s + g.length;
    let B = !1;
    go(I, c) ? (B = !0, I = 0) : I += c;
    const Q = s;
    if (!e.new[i])
      throw new Error("Session ID not found");
    const f = {
      coValue: r,
      sessionID: i,
      lastIdx: C,
      lastSignature: e.new[i].lastSignature,
      bytesSinceLastSignature: I
    }, l = await A.addSessionUpdate({
      sessionUpdate: f,
      sessionRow: o
    });
    return B && await A.addSignatureAfter({
      sessionRowID: l,
      idx: C - 1,
      signature: e.new[i].lastSignature
    }), await Promise.all(g.map((u, d) => A.addTransaction(l, Q + d, u))), C;
  }
  markDeleteAsValid(A) {
    this.deletedValues.add(A), this.deletedCoValuesEraserScheduler && this.deletedCoValuesEraserScheduler.onEnqueueDeletedCoValue();
  }
  enableDeletedCoValuesErasure() {
    this.deletedCoValuesEraserScheduler || (this.deletedCoValuesEraserScheduler = new LB({
      run: async () => (await this.eraseAllDeletedCoValues(), { hasMore: (await this.dbClient.getAllCoValuesWaitingForDelete()).length > 0 })
    }), this.deletedCoValuesEraserScheduler.scheduleStartupDrain());
  }
  waitForSync(A, e) {
    return this.knownStates.waitForSync(A, e);
  }
  trackCoValuesSyncState(A, e) {
    this.dbClient.trackCoValuesSyncState(A).then(() => e?.());
  }
  getUnsyncedCoValueIDs(A) {
    this.dbClient.getUnsyncedCoValueIDs().then(A);
  }
  stopTrackingSyncState(A) {
    this.dbClient.stopTrackingSyncState(A);
  }
  onCoValueUnmounted(A) {
    this.inMemoryCoValues.delete(A);
  }
  close() {
    return this.deletedCoValuesEraserScheduler?.dispose(), this.inMemoryCoValues.clear(), this.storeQueue.close();
  }
}
const Bn = {
  accountHeaderForInitialAgentSecret: Ng,
  idforHeader: Yt,
  CO_VALUE_PRIORITY: TA,
  ConnectedPeerChannel: Dr,
  getContentMessageSize: lB,
  WEBSOCKET_CONFIG: aB
};
let U, tA = 0, mt = null;
function tt() {
  return (mt === null || mt.byteLength === 0) && (mt = new Uint8Array(U.memory.buffer)), mt;
}
const to = typeof TextEncoder < "u" ? new TextEncoder("utf-8") : { encode: () => {
  throw Error("TextEncoder not available");
} }, OB = typeof to.encodeInto == "function" ? function(t, A) {
  return to.encodeInto(t, A);
} : function(t, A) {
  const e = to.encode(t);
  return A.set(e), {
    read: t.length,
    written: e.length
  };
};
function CA(t, A, e) {
  if (e === void 0) {
    const s = to.encode(t), a = A(s.length, 1) >>> 0;
    return tt().subarray(a, a + s.length).set(s), tA = s.length, a;
  }
  let i = t.length, o = A(i, 1) >>> 0;
  const r = tt();
  let n = 0;
  for (; n < i; n++) {
    const s = t.charCodeAt(n);
    if (s > 127) break;
    r[o + n] = s;
  }
  if (n !== i) {
    n !== 0 && (t = t.slice(n)), o = e(o, i, i = n + t.length * 3, 1) >>> 0;
    const s = tt().subarray(o + n, o + i), a = OB(t, s);
    n += a.written, o = e(o, i, n, 1) >>> 0;
  }
  return tA = n, o;
}
let De = null;
function Ai() {
  return (De === null || De.buffer.detached === !0 || De.buffer.detached === void 0 && De.buffer !== U.memory.buffer) && (De = new DataView(U.memory.buffer)), De;
}
function St(t) {
  const A = U.__externref_table_alloc();
  return U.__wbindgen_export_4.set(A, t), A;
}
function Et(t, A) {
  try {
    return t.apply(this, A);
  } catch (e) {
    const i = St(e);
    U.__wbindgen_exn_store(i);
  }
}
const qg = typeof TextDecoder < "u" ? new TextDecoder("utf-8", { ignoreBOM: !0, fatal: !0 }) : { decode: () => {
  throw Error("TextDecoder not available");
} };
typeof TextDecoder < "u" && qg.decode();
function VA(t, A) {
  return t = t >>> 0, qg.decode(tt().subarray(t, t + A));
}
function ae(t) {
  return t == null;
}
function mr(t) {
  const A = typeof t;
  if (A == "number" || A == "boolean" || t == null)
    return `${t}`;
  if (A == "string")
    return `"${t}"`;
  if (A == "symbol") {
    const o = t.description;
    return o == null ? "Symbol" : `Symbol(${o})`;
  }
  if (A == "function") {
    const o = t.name;
    return typeof o == "string" && o.length > 0 ? `Function(${o})` : "Function";
  }
  if (Array.isArray(t)) {
    const o = t.length;
    let r = "[";
    o > 0 && (r += mr(t[0]));
    for (let n = 1; n < o; n++)
      r += ", " + mr(t[n]);
    return r += "]", r;
  }
  const e = /\[object ([^\]]+)\]/.exec(toString.call(t));
  let i;
  if (e && e.length > 1)
    i = e[1];
  else
    return toString.call(t);
  if (i == "Object")
    try {
      return "Object(" + JSON.stringify(t) + ")";
    } catch {
      return "Object";
    }
  return t instanceof Error ? `${t.name}: ${t.message}
${t.stack}` : i;
}
function FA(t) {
  const A = U.__wbindgen_export_4.get(t);
  return U.__externref_table_dealloc(t), A;
}
function DA(t, A) {
  const e = A(t.length * 1, 1) >>> 0;
  return tt().set(t, e / 1), tA = t.length, e;
}
function de(t, A) {
  return t = t >>> 0, tt().subarray(t / 1, t / 1 + A);
}
function PB() {
  const t = U.newEd25519SigningKey();
  var A = de(t[0], t[1]).slice();
  return U.__wbindgen_free(t[0], t[1] * 1, 1), A;
}
function jB(t) {
  let A, e;
  try {
    const r = DA(t, U.__wbindgen_malloc), n = tA, s = U.getSignerId(r, n);
    var i = s[0], o = s[1];
    if (s[3])
      throw i = 0, o = 0, FA(s[2]);
    return A = i, e = o, VA(i, o);
  } finally {
    U.__wbindgen_free(A, e, 1);
  }
}
function VB(t, A) {
  let e, i;
  try {
    const n = DA(t, U.__wbindgen_malloc), s = tA, a = DA(A, U.__wbindgen_malloc), g = tA, I = U.sign(n, s, a, g);
    var o = I[0], r = I[1];
    if (I[3])
      throw o = 0, r = 0, FA(I[2]);
    return e = o, i = r, VA(o, r);
  } finally {
    U.__wbindgen_free(e, i, 1);
  }
}
function $B(t, A, e) {
  const i = DA(t, U.__wbindgen_malloc), o = tA, r = DA(A, U.__wbindgen_malloc), n = tA, s = DA(e, U.__wbindgen_malloc), a = tA, g = U.verify(i, o, r, n, s, a);
  if (g[2])
    throw FA(g[1]);
  return g[0] !== 0;
}
function WB(t) {
  const A = DA(t, U.__wbindgen_malloc), e = tA, i = U.blake3HashOnce(A, e);
  var o = de(i[0], i[1]).slice();
  return U.__wbindgen_free(i[0], i[1] * 1, 1), o;
}
function zB(t, A) {
  const e = DA(t, U.__wbindgen_malloc), i = tA, o = DA(A, U.__wbindgen_malloc), r = tA, n = U.blake3HashOnceWithContext(e, i, o, r);
  var s = de(n[0], n[1]).slice();
  return U.__wbindgen_free(n[0], n[1] * 1, 1), s;
}
function _B(t, A, e, i) {
  const o = DA(t, U.__wbindgen_malloc), r = tA, n = CA(A, U.__wbindgen_malloc, U.__wbindgen_realloc), s = tA, a = CA(e, U.__wbindgen_malloc, U.__wbindgen_realloc), g = tA, I = DA(i, U.__wbindgen_malloc), c = tA, C = U.unseal(o, r, n, s, a, g, I, c);
  if (C[3])
    throw FA(C[2]);
  var B = de(C[0], C[1]).slice();
  return U.__wbindgen_free(C[0], C[1] * 1, 1), B;
}
function ZB(t, A, e, i) {
  const o = DA(t, U.__wbindgen_malloc), r = tA, n = CA(A, U.__wbindgen_malloc, U.__wbindgen_realloc), s = tA, a = CA(e, U.__wbindgen_malloc, U.__wbindgen_realloc), g = tA, I = DA(i, U.__wbindgen_malloc), c = tA, C = U.seal(o, r, n, s, a, g, I, c);
  if (C[3])
    throw FA(C[2]);
  var B = de(C[0], C[1]).slice();
  return U.__wbindgen_free(C[0], C[1] * 1, 1), B;
}
function XB(t, A, e) {
  const i = DA(t, U.__wbindgen_malloc), o = tA, r = CA(A, U.__wbindgen_malloc, U.__wbindgen_realloc), n = tA, s = DA(e, U.__wbindgen_malloc), a = tA, g = U.encrypt(i, o, r, n, s, a);
  if (g[3])
    throw FA(g[2]);
  var I = de(g[0], g[1]).slice();
  return U.__wbindgen_free(g[0], g[1] * 1, 1), I;
}
function AQ(t, A, e) {
  const i = DA(t, U.__wbindgen_malloc), o = tA, r = CA(A, U.__wbindgen_malloc, U.__wbindgen_realloc), n = tA, s = DA(e, U.__wbindgen_malloc), a = tA, g = U.decrypt(i, o, r, n, s, a);
  if (g[3])
    throw FA(g[2]);
  var I = de(g[0], g[1]).slice();
  return U.__wbindgen_free(g[0], g[1] * 1, 1), I;
}
function eQ(t) {
  let A, e;
  try {
    const r = DA(t, U.__wbindgen_malloc), n = tA, s = U.getSealerId(r, n);
    var i = s[0], o = s[1];
    if (s[3])
      throw i = 0, o = 0, FA(s[2]);
    return A = i, e = o, VA(i, o);
  } finally {
    U.__wbindgen_free(A, e, 1);
  }
}
function tQ() {
  const t = U.newX25519PrivateKey();
  var A = de(t[0], t[1]).slice();
  return U.__wbindgen_free(t[0], t[1] * 1, 1), A;
}
typeof FinalizationRegistry > "u" || new FinalizationRegistry((t) => U.__wbg_blake3hasher_free(t >>> 0, 1));
const Xo = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((t) => U.__wbg_sessionlog_free(t >>> 0, 1));
class Io {
  static __wrap(A) {
    A = A >>> 0;
    const e = Object.create(Io.prototype);
    return e.__wbg_ptr = A, Xo.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const A = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Xo.unregister(this), A;
  }
  free() {
    const A = this.__destroy_into_raw();
    U.__wbg_sessionlog_free(A, 0);
  }
  /**
   * Commit pending transactions to the main state.
   * If skip_validate is false, validates the signature first.
   * If skip_validate is true, commits without validation.
   * @param {string} new_signature_str
   * @param {boolean} skip_validate
   */
  commitTransactions(A, e) {
    const i = CA(A, U.__wbindgen_malloc, U.__wbindgen_realloc), o = tA, r = U.sessionlog_commitTransactions(this.__wbg_ptr, i, o, e);
    if (r[1])
      throw FA(r[0]);
  }
  /**
   * @param {string} changes_json
   * @param {string} signer_secret
   * @param {string} encryption_key
   * @param {string} key_id
   * @param {number} made_at
   * @param {string | null} [meta]
   * @returns {string}
   */
  addNewPrivateTransaction(A, e, i, o, r, n) {
    let s, a;
    try {
      const B = CA(A, U.__wbindgen_malloc, U.__wbindgen_realloc), Q = tA, f = CA(e, U.__wbindgen_malloc, U.__wbindgen_realloc), l = tA, u = CA(i, U.__wbindgen_malloc, U.__wbindgen_realloc), d = tA, h = CA(o, U.__wbindgen_malloc, U.__wbindgen_realloc), p = tA;
      var g = ae(n) ? 0 : CA(n, U.__wbindgen_malloc, U.__wbindgen_realloc), I = tA;
      const E = U.sessionlog_addNewPrivateTransaction(this.__wbg_ptr, B, Q, f, l, u, d, h, p, r, g, I);
      var c = E[0], C = E[1];
      if (E[3])
        throw c = 0, C = 0, FA(E[2]);
      return s = c, a = C, VA(c, C);
    } finally {
      U.__wbindgen_free(s, a, 1);
    }
  }
  /**
   * @param {string} changes_json
   * @param {string} signer_secret
   * @param {number} made_at
   * @param {string | null} [meta]
   * @returns {string}
   */
  addNewTrustingTransaction(A, e, i, o) {
    let r, n;
    try {
      const c = CA(A, U.__wbindgen_malloc, U.__wbindgen_realloc), C = tA, B = CA(e, U.__wbindgen_malloc, U.__wbindgen_realloc), Q = tA;
      var s = ae(o) ? 0 : CA(o, U.__wbindgen_malloc, U.__wbindgen_realloc), a = tA;
      const f = U.sessionlog_addNewTrustingTransaction(this.__wbg_ptr, c, C, B, Q, i, s, a);
      var g = f[0], I = f[1];
      if (f[3])
        throw g = 0, I = 0, FA(f[2]);
      return r = g, n = I, VA(g, I);
    } finally {
      U.__wbindgen_free(r, n, 1);
    }
  }
  /**
   * Add an existing private transaction to the staging area.
   * The transaction is NOT committed until commitTransactions() succeeds.
   * Note: made_at uses f64 because JavaScript's number type is f64.
   * @param {string} encrypted_changes
   * @param {string} key_used
   * @param {number} made_at
   * @param {string | null} [meta]
   */
  addExistingPrivateTransaction(A, e, i, o) {
    const r = CA(A, U.__wbindgen_malloc, U.__wbindgen_realloc), n = tA, s = CA(e, U.__wbindgen_malloc, U.__wbindgen_realloc), a = tA;
    var g = ae(o) ? 0 : CA(o, U.__wbindgen_malloc, U.__wbindgen_realloc), I = tA;
    const c = U.sessionlog_addExistingPrivateTransaction(this.__wbg_ptr, r, n, s, a, i, g, I);
    if (c[1])
      throw FA(c[0]);
  }
  /**
   * Add an existing trusting transaction to the staging area.
   * The transaction is NOT committed until commitTransactions() succeeds.
   * Note: made_at uses f64 because JavaScript's number type is f64.
   * @param {string} changes
   * @param {number} made_at
   * @param {string | null} [meta]
   */
  addExistingTrustingTransaction(A, e, i) {
    const o = CA(A, U.__wbindgen_malloc, U.__wbindgen_realloc), r = tA;
    var n = ae(i) ? 0 : CA(i, U.__wbindgen_malloc, U.__wbindgen_realloc), s = tA;
    const a = U.sessionlog_addExistingTrustingTransaction(this.__wbg_ptr, o, r, e, n, s);
    if (a[1])
      throw FA(a[0]);
  }
  /**
   * @param {number} tx_index
   * @param {string} encryption_key
   * @returns {string | undefined}
   */
  decryptNextTransactionMetaJson(A, e) {
    const i = CA(e, U.__wbindgen_malloc, U.__wbindgen_realloc), o = tA, r = U.sessionlog_decryptNextTransactionMetaJson(this.__wbg_ptr, A, i, o);
    if (r[3])
      throw FA(r[2]);
    let n;
    return r[0] !== 0 && (n = VA(r[0], r[1]).slice(), U.__wbindgen_free(r[0], r[1] * 1, 1)), n;
  }
  /**
   * @param {number} tx_index
   * @param {string} encryption_key
   * @returns {string}
   */
  decryptNextTransactionChangesJson(A, e) {
    let i, o;
    try {
      const s = CA(e, U.__wbindgen_malloc, U.__wbindgen_realloc), a = tA, g = U.sessionlog_decryptNextTransactionChangesJson(this.__wbg_ptr, A, s, a);
      var r = g[0], n = g[1];
      if (g[3])
        throw r = 0, n = 0, FA(g[2]);
      return i = r, o = n, VA(r, n);
    } finally {
      U.__wbindgen_free(i, o, 1);
    }
  }
  /**
   * @param {string} co_id
   * @param {string} session_id
   * @param {string | null} [signer_id]
   */
  constructor(A, e, i) {
    const o = CA(A, U.__wbindgen_malloc, U.__wbindgen_realloc), r = tA, n = CA(e, U.__wbindgen_malloc, U.__wbindgen_realloc), s = tA;
    var a = ae(i) ? 0 : CA(i, U.__wbindgen_malloc, U.__wbindgen_realloc), g = tA;
    const I = U.sessionlog_new(o, r, n, s, a, g);
    return this.__wbg_ptr = I >>> 0, Xo.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * @returns {SessionLog}
   */
  clone() {
    const A = U.sessionlog_clone(this.__wbg_ptr);
    return Io.__wrap(A);
  }
}
async function iQ(t, A) {
  if (typeof Response == "function" && t instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming == "function")
      try {
        return await WebAssembly.instantiateStreaming(t, A);
      } catch (i) {
        if (t.headers.get("Content-Type") != "application/wasm")
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", i);
        else
          throw i;
      }
    const e = await t.arrayBuffer();
    return await WebAssembly.instantiate(e, A);
  } else {
    const e = await WebAssembly.instantiate(t, A);
    return e instanceof WebAssembly.Instance ? { instance: e, module: t } : e;
  }
}
function xg() {
  const t = {};
  return t.wbg = {}, t.wbg.__wbg_String_8f0eb39a4a4c2f66 = function(A, e) {
    const i = String(e), o = CA(i, U.__wbindgen_malloc, U.__wbindgen_realloc), r = tA;
    Ai().setInt32(A + 4, r, !0), Ai().setInt32(A + 0, o, !0);
  }, t.wbg.__wbg_buffer_609cc3eee51ed158 = function(A) {
    return A.buffer;
  }, t.wbg.__wbg_call_672a4d21634d4a24 = function() {
    return Et(function(A, e) {
      return A.call(e);
    }, arguments);
  }, t.wbg.__wbg_call_7cccdd69e0791ae2 = function() {
    return Et(function(A, e, i) {
      return A.call(e, i);
    }, arguments);
  }, t.wbg.__wbg_crypto_574e78ad8b13b65f = function(A) {
    return A.crypto;
  }, t.wbg.__wbg_getRandomValues_b8f5dbd5f3995a9e = function() {
    return Et(function(A, e) {
      A.getRandomValues(e);
    }, arguments);
  }, t.wbg.__wbg_msCrypto_a61aeb35a24c1329 = function(A) {
    return A.msCrypto;
  }, t.wbg.__wbg_new_a12002a7f91c75be = function(A) {
    return new Uint8Array(A);
  }, t.wbg.__wbg_newnoargs_105ed471475aaf50 = function(A, e) {
    return new Function(VA(A, e));
  }, t.wbg.__wbg_newwithbyteoffsetandlength_d97e637ebe145a9a = function(A, e, i) {
    return new Uint8Array(A, e >>> 0, i >>> 0);
  }, t.wbg.__wbg_newwithlength_a381634e90c276d4 = function(A) {
    return new Uint8Array(A >>> 0);
  }, t.wbg.__wbg_node_905d3e251edff8a2 = function(A) {
    return A.node;
  }, t.wbg.__wbg_process_dc0fbacc7c1c06f7 = function(A) {
    return A.process;
  }, t.wbg.__wbg_randomFillSync_ac0988aba3254290 = function() {
    return Et(function(A, e) {
      A.randomFillSync(e);
    }, arguments);
  }, t.wbg.__wbg_require_60cc747a6bc5215a = function() {
    return Et(function() {
      return module.require;
    }, arguments);
  }, t.wbg.__wbg_set_65595bdd868b3009 = function(A, e, i) {
    A.set(e, i >>> 0);
  }, t.wbg.__wbg_static_accessor_GLOBAL_88a902d13a557d07 = function() {
    const A = typeof globalThis > "u" ? null : globalThis;
    return ae(A) ? 0 : St(A);
  }, t.wbg.__wbg_static_accessor_GLOBAL_THIS_56578be7e9f832b0 = function() {
    const A = typeof globalThis > "u" ? null : globalThis;
    return ae(A) ? 0 : St(A);
  }, t.wbg.__wbg_static_accessor_SELF_37c5d418e4bf5819 = function() {
    const A = typeof self > "u" ? null : self;
    return ae(A) ? 0 : St(A);
  }, t.wbg.__wbg_static_accessor_WINDOW_5de37043a91a9c40 = function() {
    const A = typeof window > "u" ? null : window;
    return ae(A) ? 0 : St(A);
  }, t.wbg.__wbg_subarray_aa9065fa9dc5df96 = function(A, e, i) {
    return A.subarray(e >>> 0, i >>> 0);
  }, t.wbg.__wbg_versions_c01dfd4722a88165 = function(A) {
    return A.versions;
  }, t.wbg.__wbindgen_debug_string = function(A, e) {
    const i = mr(e), o = CA(i, U.__wbindgen_malloc, U.__wbindgen_realloc), r = tA;
    Ai().setInt32(A + 4, r, !0), Ai().setInt32(A + 0, o, !0);
  }, t.wbg.__wbindgen_error_new = function(A, e) {
    return new Error(VA(A, e));
  }, t.wbg.__wbindgen_init_externref_table = function() {
    const A = U.__wbindgen_export_4, e = A.grow(4);
    A.set(0, void 0), A.set(e + 0, void 0), A.set(e + 1, null), A.set(e + 2, !0), A.set(e + 3, !1);
  }, t.wbg.__wbindgen_is_function = function(A) {
    return typeof A == "function";
  }, t.wbg.__wbindgen_is_object = function(A) {
    const e = A;
    return typeof e == "object" && e !== null;
  }, t.wbg.__wbindgen_is_string = function(A) {
    return typeof A == "string";
  }, t.wbg.__wbindgen_is_undefined = function(A) {
    return A === void 0;
  }, t.wbg.__wbindgen_memory = function() {
    return U.memory;
  }, t.wbg.__wbindgen_string_new = function(A, e) {
    return VA(A, e);
  }, t.wbg.__wbindgen_throw = function(A, e) {
    throw new Error(VA(A, e));
  }, t;
}
function Lg(t, A) {
  return U = t.exports, Tg.__wbindgen_wasm_module = A, De = null, mt = null, U.__wbindgen_start(), U;
}
function oQ(t) {
  if (U !== void 0) return U;
  typeof t < "u" && (Object.getPrototypeOf(t) === Object.prototype ? { module: t } = t : console.warn("using deprecated parameters for `initSync()`; pass a single object instead"));
  const A = xg();
  t instanceof WebAssembly.Module || (t = new WebAssembly.Module(t));
  const e = new WebAssembly.Instance(t, A);
  return Lg(e, t);
}
async function Tg(t) {
  if (U !== void 0) return U;
  if (typeof t < "u" && (Object.getPrototypeOf(t) === Object.prototype ? { module_or_path: t } = t : console.warn("using deprecated parameters for the initialization function; pass a single object instead")), typeof t > "u")
    throw new Error();
  const A = xg();
  (typeof t == "string" || typeof Request == "function" && t instanceof Request || typeof URL == "function" && t instanceof URL) && (t = fetch(t));
  const { instance: e, module: i } = await iQ(await t, A);
  return Lg(e, i);
}
const Og = "data:application/wasm;base64,AGFzbQEAAAAB4wM9YAJ/fwF/YAN/f38Bf2ACf38AYAN/f38AYAF/AGAABH9/f39gAX8Bf2AFf39/f38AYAACf39gAAF/YAR/f39/AGACf38Ef39/f2ABbwFvYAAAYAV/f39+fwBgB39/f39/f38AYAV/f39/fwF/YAR/f39/AX9gBH9/f38Ef39/f2ABbwF/YAZ/f39/f38Bf2AAA39/f2ACf38Bb2AGf39/f39/AGACf28AYAABb2ACb28AYANvf38Bb2ACf34AYAh/f39/f39/fwR/f39/YAZ/f39/f38Ef39/f2AGf39/f39/A39/f2AEf39/fwJ/f2ACf38Cf39gA29vfwBgAX8Bb2ACb28Bb2ADb29vAW9gBn9/f39+fwBgCH9/f39/f35/AGACfH8Bf2AHf39/fn9/fwF/YAR/f39+AGAJf39/f39/fn5+AGACfn8AYAd/f39/f39/AX9gC39/f39/f39/f39/AX9gA39+fgBgAAF+YAR/fn5/AGAMf39/f39/f39/fH9/BH9/f39gCH9/f39/fH9/BH9/f39gCH9/f39/fH9/An9/YAZ/f398f38Cf39gAX8Cf39gBX9/fH9/AGAEf3x/fwBgBX9/fn9/AGAEf35/fwBgBX9/fX9/AGAEf31/fwACogkgA3diZxVfX3diaW5kZ2VuX3N0cmluZ19uZXcAFgN3YmcUX193YmluZGdlbl9lcnJvcl9uZXcAFgN3YmcUX193YmluZGdlbl9pc19vYmplY3QAEwN3YmcdX193YmdfU3RyaW5nXzhmMGViMzlhNGE0YzJmNjYAGAN3YmcdX193YmdfY3J5cHRvXzU3NGU3OGFkOGIxM2I2NWYADAN3YmceX193YmdfcHJvY2Vzc19kYzBmYmFjYzdjMWMwNmY3AAwDd2JnH19fd2JnX3ZlcnNpb25zX2MwMWRmZDQ3MjJhODgxNjUADAN3YmcbX193Ymdfbm9kZV85MDVkM2UyNTFlZGZmOGEyAAwDd2JnFF9fd2JpbmRnZW5faXNfc3RyaW5nABMDd2JnHl9fd2JnX3JlcXVpcmVfNjBjYzc0N2E2YmM1MjE1YQAZA3diZxZfX3diaW5kZ2VuX2lzX2Z1bmN0aW9uABMDd2JnH19fd2JnX21zQ3J5cHRvX2E2MWFlYjM1YTI0YzEzMjkADAN3YmclX193YmdfcmFuZG9tRmlsbFN5bmNfYWMwOTg4YWJhMzI1NDI5MAAaA3diZyZfX3diZ19nZXRSYW5kb21WYWx1ZXNfYjhmNWRiZDVmMzk5NWE5ZQAaA3diZyBfX3diZ19uZXdub2FyZ3NfMTA1ZWQ0NzE0NzVhYWY1MAAWA3diZxpfX3diZ19uZXdfYTEyMDAyYTdmOTFjNzViZQAMA3diZx1fX3diZ19idWZmZXJfNjA5Y2MzZWVlNTFlZDE1OAAMA3diZzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9kOTdlNjM3ZWJlMTQ1YTlhABsDd2JnGl9fd2JnX3NldF82NTU5NWJkZDg2OGIzMDA5ACIDd2JnJF9fd2JnX25ld3dpdGhsZW5ndGhfYTM4MTYzNGU5MGMyNzZkNAAjA3diZx9fX3diZ19zdWJhcnJheV9hYTkwNjVmYTlkYzVkZjk2ABsDd2JnMl9fd2JnX3N0YXRpY19hY2Nlc3Nvcl9HTE9CQUxfVEhJU181NjU3OGJlN2U5ZjgzMmIwAAkDd2JnF19fd2JpbmRnZW5faXNfdW5kZWZpbmVkABMDd2JnG19fd2JnX2NhbGxfNjcyYTRkMjE2MzRkNGEyNAAkA3diZytfX3diZ19zdGF0aWNfYWNjZXNzb3JfU0VMRl8zN2M1ZDQxOGU0YmY1ODE5AAkDd2JnLV9fd2JnX3N0YXRpY19hY2Nlc3Nvcl9HTE9CQUxfODhhOTAyZDEzYTU1N2QwNwAJA3diZy1fX3diZ19zdGF0aWNfYWNjZXNzb3JfV0lORE9XXzVkZTM3MDQzYTkxYTljNDAACQN3YmcbX193YmdfY2FsbF83Y2NjZGQ2OWUwNzkxYWUyACUDd2JnEV9fd2JpbmRnZW5fbWVtb3J5ABkDd2JnEF9fd2JpbmRnZW5fdGhyb3cAAgN3YmcXX193YmluZGdlbl9kZWJ1Z19zdHJpbmcAGAN3YmcfX193YmluZGdlbl9pbml0X2V4dGVybnJlZl90YWJsZQANA4kDhwMDJg4GJwAKAigDAgMCAAYDAgMHAgICAykDAgIDAgMDDwMAARwEAgYDKgMDFAMEDgMCDwMBAQICAwIAAxwCAAoBAQIDAAAPAQoDFAMKAwMDAgoDDw8CAgMHDgIDBAIrAQIsBwAELQQCCQMDAxcAAgMJAgQDAAACAgAEAAMABwIBEBEOAAAGAAIEBAQEAAYAAAkQAAYAAgAADQ0UAAABEQACBAMEBAcCFwcuBwQGAwcXAgADAwQABAABAAMABAIEAAoBAC8EAwIHAAAOAgMAAAICAgQDBAAAMDEDBAACAAAABAIBAQECBgEAAAADAwMyAAAAAAEAAgQCAgoDBAQAMx0dAAACEB4eBgoAAAQ0EhISHxIfEjULCwsLCwsLCwAJAgIgIAEhIRE2FAgIBxA3OTsECgAAAQAEAAICAgICAAQEBAQEAAAGAAAGAwEABwARAAACAAIEAAACAAAGAwQEAAAAAAAAAAAAAAAAAAAAAAAAAg0NAgAAAAACAAACAQAAAAAAAgQNBgkDBAsCcAG1AbUBbwCAAQUDAQASBgkBfwFBgIDAAAsH+AgxBm1lbW9yeQIAFV9fd2JnX3Nlc3Npb25sb2dfZnJlZQBYKHNlc3Npb25sb2dfYWRkRXhpc3RpbmdQcml2YXRlVHJhbnNhY3Rpb24AqwIpc2Vzc2lvbmxvZ19hZGRFeGlzdGluZ1RydXN0aW5nVHJhbnNhY3Rpb24AswIjc2Vzc2lvbmxvZ19hZGROZXdQcml2YXRlVHJhbnNhY3Rpb24AjQIkc2Vzc2lvbmxvZ19hZGROZXdUcnVzdGluZ1RyYW5zYWN0aW9uAJ0CEHNlc3Npb25sb2dfY2xvbmUArAEdc2Vzc2lvbmxvZ19jb21taXRUcmFuc2FjdGlvbnMAwAIsc2Vzc2lvbmxvZ19kZWNyeXB0TmV4dFRyYW5zYWN0aW9uQ2hhbmdlc0pzb24ArQIpc2Vzc2lvbmxvZ19kZWNyeXB0TmV4dFRyYW5zYWN0aW9uTWV0YUpzb24ArAIOc2Vzc2lvbmxvZ19uZXcAuQELZWQyNTUxOVNpZ24ArgIZZWQyNTUxOVNpZ25hdHVyZUZyb21CeXRlcwC2AhplZDI1NTE5U2lnbmluZ0tleUZyb21CeXRlcwC1AhllZDI1NTE5U2lnbmluZ0tleVRvUHVibGljALQCDWVkMjU1MTlWZXJpZnkArwITZWQyNTUxOVZlcmlmeWluZ0tleQC3AhxlZDI1NTE5VmVyaWZ5aW5nS2V5RnJvbUJ5dGVzALgCFG5ld0VkMjU1MTlTaWduaW5nS2V5AMgCFWVkMjU1MTlTaWduaW5nS2V5U2lnbgCuAgtnZXRTaWduZXJJZAC5AgRzaWduALACBnZlcmlmeQCxAhdfX3diZ19ibGFrZTNoYXNoZXJfZnJlZQDPAQ5ibGFrZTNIYXNoT25jZQDEAhlibGFrZTNIYXNoT25jZVdpdGhDb250ZXh0AMECEmJsYWtlM2hhc2hlcl9jbG9uZQBGFWJsYWtlM2hhc2hlcl9maW5hbGl6ZQDGAhBibGFrZTNoYXNoZXJfbmV3AIcBE2JsYWtlM2hhc2hlcl91cGRhdGUAzAEPZGVjcnlwdFhzYWxzYTIwAKQCD2VuY3J5cHRYc2Fsc2EyMACkAg1nZW5lcmF0ZU5vbmNlAMMCB2RlY3J5cHQApQIHZW5jcnlwdAClAgRzZWFsAJ8CBnVuc2VhbACeAgtnZXRTZWFsZXJJZAC7AhNuZXdYMjU1MTlQcml2YXRlS2V5AMkCE3gyNTUxOURpZmZpZUhlbGxtYW4AsgIPeDI1NTE5UHVibGljS2V5ALoCEV9fd2JpbmRnZW5fbWFsbG9jALwCEl9fd2JpbmRnZW5fcmVhbGxvYwDFAhRfX3diaW5kZ2VuX2V4bl9zdG9yZQDzAhdfX2V4dGVybnJlZl90YWJsZV9hbGxvYwCPARNfX3diaW5kZ2VuX2V4cG9ydF80AQEZX19leHRlcm5yZWZfdGFibGVfZGVhbGxvYwD/AQ9fX3diaW5kZ2VuX2ZyZWUA6AIQX193YmluZGdlbl9zdGFydAAfCe0CAQBBAQu0Af4C1QKBAqIB/wL9Ao4CqAL9AaACjwLVAoECogGAA6gC7gKFA90BsQGbAtQB+QGMAaEC0AGIAo0D0gKoAqEC1gGfA4QDggODA/UC7AHdAYYDjgPlAuYChwPVAoECogGKA4gDiQObAu4C1QKBAqIBiwPtAYkC1QKQAtUCgQKiAYwDqAKgAu4C7wLsApsBjgPYAdUC1QKRAqADqAL+AZkB7wL6AfoB0wG7AdoBoQPXAvACoQOmA/ECoQLvAvwB6gK2AboBoQPYAvICpgOUAagC8QKpAssCzgHKAs4CzQLKAswCygLQAssCxwLTAt0C3gLfAuACrwHhAu4C1gL0ApcB7AKrAe8C1QKBAqIBlAOTA9UCgQKiAdECkwG+Aa0B8QKTArwB1AKVA/AB7gLvAtUCggKjAZYD9QKXAvYClwPPAt4BpgHFAaED2gLZApkD1QKG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IgkgA3NBGHciAyAmczYAPCAAICUgAiANIBRzQRh3IiYgDmoiCCASc0EZdyINIB4gJGpqIiRqIBUgJHNBEHciAiARaiIVIA1zQRR3IiRqIh4gAnNBGHciAnM2ADggACAnIAEgCyAfaiIfIBhzQRl3IhggIiAjamoiImogBSAic0EQdyIBIAhqIiMgGHNBFHciGGoiESABc0EYdyIBczYANCAAICggISAXIBxzQRl3IgUgDyAgamoiIGogBSAgICZzQRB3IgUgH2oiIHNBFHciF2oiHyAFc0EYdyIFczYAMCAAICsgBSAgaiIgczYALCAAICwgAyAHaiIiczYAKCAAICkgAiAVaiIVczYAJCAAICogASAjaiIcczYAICAAIB4gIHM2AAwgACARICJzNgAIIAAgFSAfczYABCAAIAkgHHM2AAAgACAYIBxzQRl3IANzNgAcIAAgFyAgc0EZdyACczYAGCAAIAogInNBGXcgAXM2ABQgACAVICRzQRl3IAVzNgAQC4kbASB/IAAgACgCGCIdIAEoABAiJCAAKAIIamoiGyABKAAUIhVqIB0gGyACQf8BcXNBEHciAkHy5rvjA2oiHXNBFHciG2oiIiACc0EYdyIJIB1qIhwgG3NBGXciDyAAKAIUIhsgASgACCICIAAoAgRqaiIZIAEoAAwiHWogGSADQiCIp3NBEHciHkH7ouGkBGsiICAbc0EUdyIGaiIKIAEoACgiG2pqIiMgASgALCIZaiAPICMgACgCECIhIAEoAAAiDyAAKAIAamoiCCABKAAEIh9qICEgCCADp3NBEHciIUHnzKfQBmoiCHNBFHciB2oiDiAhc0EYdyINc0EQdyILIAAoAhwiBSABKAAYIiMgACgCDGpqIgwgASgAHCIhaiAFIAwgBEH/AXFzQRB3IgRBxpXA1QVrIgVzQRR3IgxqIhEgBHNBGHciECAFaiIFaiISc0EUdyIUaiITIB1qIAYgICAKIB5zQRh3IiBqIgZzQRl3IgogDiABKAAgIgRqaiIOIAEoACQiHmogCiAcIA4gEHNBEHciHGoiCnNBFHciDmoiECAcc0EYdyIWIApqIgogDnNBGXciHGoiDiAbaiAcIA4gBSAMc0EZdyIFICIgASgAMCIcamoiDCABKAA0IiJqIAwgIHNBEHciICAIIA1qIghqIg0gBXNBFHciBWoi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jOjEACABNgIAC0GQ6MQAQf8fNgIAQdzlxAAgBzYCAEHU5cQAIAQ2AgBB0OXEACABNgIAQezlxABB4OXEADYCAEH05cQAQejlxAA2AgBB6OXEAEHg5cQANgIAQfzlxABB8OXEADYCAEHw5cQAQejlxAA2AgBBhObEAEH45cQANgIAQfjlxABB8OXEADYCAEGM5sQAQYDmxAA2AgBBgObEAEH45cQANgIAQZTmxABBiObEADYCAEGI5sQAQYDmxAA2AgBBnObEAEGQ5sQANgIAQZDmxABBiObEADYCAEGk5sQAQZjmxAA2AgBBmObEAEGQ5sQANgIAQazmxABBoObEADYCAEGg5sQAQZjmxAA2AgBBqObEAEGg5sQANgIAQbTmxABBqObEADYCAEGw5sQAQajmxAA2AgBBvObEAEGw5sQANgIAQbjmxABBsObEADYCAEHE5sQAQbjmxAA2AgBBwObEAEG45sQANgIAQczmxABBwObEADYCAEHI5sQAQcDmxAA2AgBB1ObEAEHI5sQANgIAQdDmxABByObEADYCAEHc5sQAQdDmxAA2AgBB2ObEAEHQ5sQANgIAQeTmxABB2ObEADYCAEHg5sQAQdjmxAA2AgBB7ObEAEHg5sQANgIAQfTmxABB6ObEADYCAEHo5sQAQeDmxAA2AgBB/ObEAEHw5sQANgIAQfDmxABB6ObEADYCAEGE58QAQfjmxAA2AgBB+ObEAEHw5sQANgIAQYznxABBgOfEADYCAEGA58QAQfjmxAA2AgBBlOfEAEGI58QANgIAQYjnxABBgOfEADYCAEGc58QAQZDnxAA2AgBBkOfEAEGI58QANgIAQaTnxABBmOfEADYCAEGY58QAQZDnxAA2AgBBrOfEAEGg58QANgIAQaDnxABBmOfEADYCAEG058QAQajnxAA2AgBBqOfEAEGg58QANgIAQbznxABBsOfEADYCAEGw58QAQajnxAA2AgBBxOfEAEG458QANgIAQbjnxABBsOfEADYCAEHM58QAQcDnxAA2AgBBwOfEAEG458QANgIAQdTnxABByOfEADYCAEHI58QAQcDnxAA2AgBB3OfEAEHQ58QANgIAQdDnxABByOfEADYCAEHk58QAQdjnxAA2AgBB2OfEAEHQ58QANgIAQfznxAAgAUEPakF4cSIAQQhrIgI2AgBB4OfEAEHY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akEJdyAMcyIMIAVqQQ13IA9zIg8gDGpBEncgCHMhCCAQIBQgFWpBEncgB3MiB2pBB3cgCXMiCSAHakEJdyANcyINIAlqQQ13IBBzIhAgDWpBEncgB3MhByATQQFrIhMNAAsgACkCICEpIAAoAgAhEyAAKAIEIRIgACgCCCERIAAoAgwhFCAAKAIQIRUgACgCFCEcIAAoAhghGiAAKAIcIR0gACgCICEeIAAoAiQhHyAAKAIoISAgACgCLCEhIAAoAjAhIiAAKAI0ISMgACgCOCEkIAAgACgCPCABajYCfCAAIBYgJGo2AnggACAOICNqNgJ0IAAgBiAiajYCcCAAIAIgIWo2AmwgACAEICBqNgJoIAAgFyAfajYCZCAAIAsgHmo2AmAgACAMIB1qNgJcIAAgBSAaajYCWCAAIAggHGo2AlQgACAPIBVqNgJQIAAgECAUajYCTCAAIA0gEWo2AkggACAJIBJqNgJEIAAgByATajYCQCAAIClCAXwiKT4CICAAIClCIIg+AiQgCkEBcSECQQAhASAbQQFGDQEgCkE+cSEKA0AgASAZaiIGIAAgAWoiBEFAay0AACABIBhqIgUtAABzOgAAIAZBAWogBEHBAGotAAAgBUEBai0AAHM6AAAgCiABQQJqIgFHDQALDAELAkAgCkUNACABKAIEIQAgASgCACECQQAhASAKQQFHBEAgCkF+cSEGA0AgACABaiIFIAEgCGoiB0FAay0AACABIAJqIg4tAABzOgAAIAVBAWogB0HBAGotAAAgDkEBai0AAHM6AAAgBiABQQJqIgFHDQALCyAKQQFxRQ0AIAAgAWogASAJai0AACABIAJqLQAAczoAAAsgBCAKaiEbDAELIAJFDQAgASAZaiAAQUBrIAFqLQAAIAEgGGotAABzOgAACyAlIBs6AABBAAsgA0HAAWokAAuQMQITfyR+IwBB4AVrIgQkACAEQeAAaiIFQQBB4AD8CwAgBEHYAGoiByABQdgBaikCADcDACAEQdAAaiIGIAFB0AFqKQIANwMAIARBkANqIghBsN/AACkDADcDACAEQZgDaiIJQbjfwAApAwA3AwAgBEGgA2pBwN/AACkDADcDACAEQagDakHI38AAKQMANwMAIARBsANqQdDfwAApAwA3AwAgBEG4A2pB2N/AACkDADcDACAEIAFByAFqKQIANwNIIAQgASkCwAE3A0AgBEGg38AAKQMANwOAAyAEQajfwAApAwA3A4gDIARCADcDyAMgBEIANwPAAyAEQdADaiINIARBQGsiCkGAAfwKAAAgBEGoBWoiDkIANwMAIARBsAVqIg9CADcDACAEQbgFaiILQgA3AwAgBEHABWoiDEIANwMAIARByAVqIhBCADcDACAEQdAFaiIRQgA3AwAgBEHYBWoiEkIANwMAIARBIDoA0AQgBEIANwOgBSAEQYADaiITIA0gBEGgBWoQOCAJIAspAwA3AwAgCCAPKQMANwMAIARBiANqIA4pAwA3AwAgBCAEKQOgBSIXNwOAAyAEIBenQfgBcToAgAMgBCAELQCfA0E/cUHAAHI6AJ8DIAQgExD7ASAEQThqIgggEikDADcAACAEQTBqIgkgESkDADcAACAEQShqIg0gECkDADcAACAEIAwpAwA3ACAgBEH4AGpB6N3AACkDADcDACAEQfAAakHg3cAAKQMANwMAIARB6ABqQdjdwAApAwA3AwAgBUHQ3cAAKQMANwMAIAdByN3AACkDADcDACAGQcDdwAApAwA3AwAgBEIANwOIASAEQgA3A4ABIARBuN3AACkDADcDSCAEQbDdwAApAwA3A0AgBEGwAWoiBUEAQeAA/AsAIARBqAFqIAgpAAA3AwAgBEGgAWogCSkAADcDACAEQZgBaiANKQAANwMAIARBIDoAkAIgBCAEKQAgNwOQASAEQZABaiEHAkAgA0HgAE8EQCAFIAJB4AD8CgAAIARCADcDiAEgBEIBNwOAASAKIAdBARAgIAJB4ABqIQggA0HgAGsiBkH/AHEhBSAGQYABTwRAIAQgBCkDgAEiFyAGQQd2IgmtfCIYNwOAASAEIAQpA4gBIBcgGFatfDcDiAEgCiAIIAkQIAsgBUUNASAHIAggBkGAf3FqIAX8CgAADAELIAMEQCAEQbABaiACIAP8CgAACyADQSBqIQULIAQgBToAkAIgBEGAA2oiBSAEQUBrQeAB/AoAACAEQdgFaiIGQgA3AwAgBEHQBWoiCkIANwMAIARByAVqIghCADcDACAEQcAFaiIJQgA3AwAgBEG4BWoiDUIANwMAIARBsAVqIg5CADcDACAEQagFaiIPQgA3AwAgBEIANwOgBSAFIARB0ANqIARBoAVqEDggBEGYBWogBikDADcD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//8BcTYCbCABIAEoAkwgASgCKCACQR12amoiAkH/////AXE2AnAgASABKAJQIAEoAiwgAkEddmpqIgJB/////wFxNgJ0IAEgASgCVCABKAIwIAJBHXZqaiICQf////8BcTYCeCABIAEoAlggASgCNCACQR12amoiAkH/////AXE2AnwgASABKAJcIAEoAjggAkEddmpqIgJB/////wFxNgKAASABIAEoAmAgASgCPCACQR12amoiAkH/////AXE2AoQBIAEgASgCZCABKAJAIAJBHXZqaiICQf////8BcTYCiAEgASABKAJoIAEoAkQgAkEddmpqQf////8BcTYCjAEgASABQewAakHg4cAAEGggBEGgA2oiAiABEH8gAUGQAWokACAPIARByAJqKQAAIhc3AwAgDiAEQdACaikAACIYNwMAIA0gBEHYAmopAAAiGzcDACAAIAQpAMACIhw3AAEgAEEJaiAXNwAAIABBEWogGDcAACAAQRlqIBs3AAAgAEEhaiACKQMANwAAIABBKWogBEGoA2opAwA3AAAgAEExaiAEQbADaikDADcAACAAQTlqIARBuANqKQMANwAAIAQgHDcDgAMgAEEAOgAAIAQQwgEgBEEAOgAgIARBADoAISAEQQA6ACIgBEEAOgAjIARBADoAJCAEQQA6ACUgBEEAOgAmIARBADoAJyAEQQA6ACggBEEAOgApIARBADoAKiAEQQA6ACsgBEEAOgAsIARBADoALSAEQQA6AC4gBEEAOgAvIARBADoAMCAEQQA6ADEgBEEAOgAyIARBADoAMyAEQQA6ADQgBEEAOgA1IARBADoANiAEQQA6ADcgBEEAOgA4IARBADoAOSAEQQA6ADogBEEAOgA7IARBADoAPCAEQQA6AD0gBEEAOgA+IARBADoAPyAEQeAFaiQAC/QZAhl/BH4jAEGwB2siAiQAIwBBIGsiBCQAIAIgAS0AACIDQQR2OgABIAIgA0EPcSIGOgAAIAIgAS0AASIDQQR2OgADIAIgA0EPcToAAiACIAEtAAIiA0EEdjoABSACIANBD3E6AAQgAiABLQADIgNBBHY6AAcgAiADQQ9xOgAGIAIgAS0ABCIDQQR2OgAJIAIgA0EPcToACCACIAEtAAUiA0EEdjoACyACIANBD3E6AAogAiABLQAGIgNBBHY6AA0gAiADQQ9xOgAMIAIgAS0AByIDQQR2OgAPIAIgA0EPcToADiACIAEtAAgiA0EEdjoAESACIANBD3E6ABAgAiABLQAJIgNBBHY6ABMgAiADQQ9xOgASIAIgAS0ACiIDQQR2OgAVIAIgA0EPcToAFCACIAEtAAsiA0EEdjoAFyACIANBD3E6ABYgAiABLQAMIgNBBHY6ABkgAiADQQ9xOgAYIAIgAS0ADSIDQQR2OgAbIAIgA0EPcToAGiACIAEtAA4iA0EEdjoAHSACIANBD3E6ABwgAiABLQAPIgNBBHY6AB8gAiADQQ9xOgAeIAIgAS0AECIDQQR2OgAhIAIgA0EPcToAICACIAEtABEiA0EPcToAIiACIANBBHY6ACMgAiABLQASIgNBBHY6ACUgAiADQQ9xOgAkIAIgAS0AEyIDQQR2OgAnIAIgA0EPcToAJiACIAEtABQiA0EEdjoAKSACIANBD3E6ACggAiABLQAVIgNBBHY6ACsgAiADQQ9xOgAqIAIgAS0AFiIDQQR2OgAtIAIgA0EPcToALCACIAEtABciA0EEdjoALyACIANBD3E6AC4gAiABLQAYIgNBBHY6ADEgAiADQQ9xOgAwIAIgAS0AGSIDQQR2OgAzIAIgA0EPcToAMiACIAEtABoiA0EEdjoANSACIANBD3E6ADQgAiABLQAbIgNBBHY6ADcgAiADQQ9xOgA2IAIgAS0AHCIDQQR2OgA5IAIgA0EPcToAOCACIAEtAB0iA0EEdjoAOyACIANBD3E6ADogAiABLQAeIgNBBHY6AD0gAiADQQ9xOgA8IAIgAS0AHyIBQQR2OgA/IAIgAUEPcToAPgNAIAIgBWoiCCAGIAZBCGoiAUHwAXFrOgAAIAhBAWoiAyADLQAAIAHAQQR1aiIBOgAAIAVBPkcEQCADIAEgAUEIaiIDQfABcWs6AAAgCEECaiIBIAEtAAAgA8BBBHVqIgY6AAAgBUECaiEFDAELCyAEQSBqJAAgAkHgAGpCADcDACACQdgAakIANwMAIAJB0ABqQgA3AwAgAkHIAGpCADcDAEEAIQEgAkHwAGpBoOPAACkCACIcNwMAIAJB+ABqQajjwAApAgAiHTcDACACQYABakGw48AAKQIAIh43AwAgAkGIAWpBuOPAACkCACIbNwMAIAJBmAFqIBw3AwAgAkGgAWogHTcDACACQagBaiAeNwMAIAJBsAFqIBs3AwAgAkIANwNAIAJBmOPAACkCACIbNwNoIAIgGzcDkAEgAkHYAWpCADcDACACQdABakIANwMAIAJByAFqQgA3AwAgAkHAAWpCADcDACACQgA3A7gBIAJB+ANqIQwgAkHQA2ohDSACQagDaiEOIAJB6AVqIQsgAkHABWohBSACQZAGaiEGIAJBkAFqIQ8gAkHoAGohEANAAkACQCABQcAARwRAIAFBAXENAQwCCyACQegEaiAQQSBqKQIANwMAIAJB4ARqIBBBGGopAgA3AwAgAkHYBGogEEEQaikCADcDACACQdAEaiAQQQhqKQIANwMAIAJB+ARqIA9BCGopAgA3AwAgAkGABWogD0EQaikCADcDACACQYgFaiAPQRhqKQIANwMAIAJBkAVqIA9BIGopAgA3AwAgAiAQKQIANwPIBCACIA8pAgA3A/AEIAJBwARqIAJB4ABqKQMANwMAIAJBuARqIAJB2ABqKQMANwMAIAJBsARqIAJB0ABqKQMANwMAIAJBqARqIAJByABqKQMANwMAIAIgAikDQDcDoAQgAkGYBWoiAyACQaAEahAsQQAiAUUEQCACQYADaiADQaAB/AoAAAsgAkGYBWoiByACQYADaiITIAJB+ANqIgkQNiACQYgHaiIVIAJBqANqIhEgAkHQA2oiChA2IAJB4AFqIhQgCiAJEDYgAkHgBWoiGiACQagHaiIWKQIANwIAIAJB2AVqIgwgAkGgB2oiFykCADcCACACQdAFaiINIAJBmAdqIhgpAgA3AgAgAkHIBWoiDiACQZAHaiIZKQIANwIAIAJB8AVqIg8gAkHoAWoiECkCADcCACACQfgFaiILIAJB8AFqIgUpAgA3AgAgAkGABmoiBiACQfgBaiIIKQIANwIAIAJBiAZqIgQgAkGAAmoiAykCADcCACACIAIpAogHNwLABSACIAIpAuABNwLoBSACQaAEaiISIAdB+AD8CgAAIAcgEhAsIBMgB0GgAfwKAAAgByATIAkQNiAVIBEgChA2IBQgCiAJEDYgGiAWKQIANwIAIAwgFykCADcCACANIBgpAgA3AgAgDiAZKQIANwIAIA8gECkCADcCACALIAUpAgA3AgAgBiAIKQIANwIAIAQgAykCADcCACACIAIpAogHNwLABSACIAIpAuABNwLoBSASIAdB+AD8CgAAIAcgEhAsIBMgB0GgAfwKAAAgByATIAkQNiAVIBEgChA2IBQgCiAJEDYgGiAWKQIANwIAIAwgFykCADcCACANIBgpAgA3AgAgDiAZKQIANwIAIA8gECkCADcCACALIAUpAgA3AgAgBiAIKQIANwIAIAQgAykCADcCACACIAIpAogHNwLABSACIAIpAuABNwLoBSASIAdB+AD8CgAAIAcgEhAsIBQgByACQZAGaiILEDYgAkG4BmogAkHABWoiBSACQegFaiIGEDYgAkHgBmogBiALEDYgFSAHIAUQNiACQagCaiACQdgGaikCADcCACACQaACaiACQdAGaikCADcCACACQZgCaiACQcgGaikCADcCACACQZACaiACQcAGaikCADcCACACQbgCaiACQegGaikCADcCACACQcACaiACQfAGaikCADcCACACQcgCaiACQfgGaikCADcCACACQdACaiACQYAHaikCADcCACACIAIpArgGNwKIAiACIAIpAuAGNwKwAiACQfgCaiAWKQIANwIAIAJB8AJqIBcpAgA3AgAgAkHoAmogGCkCADcCACACQeACaiAZKQIANwIAIAIgAikCiAc3AtgCIAJBQGsgFEGgAfwKAAADQAJAAkAgAUHAAEcEQCABQQFxRQ0BDAILIAAgAkFAa0GgAfwKAAAgAkGwB2okAA8LIAFBAXYhBCABQcAASQRAIAJB4AFqIgMgBEHAB2xBuKHBAGogASACai0AABBiIAJBmAVqIgggAkFAayIEIAMQQCACQYADaiIDIAggCxA2IAJB4AZqIAUgBhA2IAJBiAdqIAYgCxA2IAJBoARqIAggBRA2IBFBIGogAkGAB2opAgA3AgAgEUEYaiACQfgGaikCADcCACARQRBqIAJB8AZqKQIANwIAIBFBCGogAkHoBmopAgA3AgAgESACKQLgBjcCACAKIAIpAogHNwIAIApBCGogAkGQB2opAgA3AgAgCkEQaiACQZgHaikCADcCACAKQRhqIAJBoAdqKQIANwIAIApBIGogAkGoB2opAgA3AgAgCUEgaiACQcAEaikCADcCACAJQRhqIAJBuARqKQIANwIAIAlBEGogAkGwBGopAgA3AgAgCUEIaiACQagEaikCADcCACAJIAIpAqAENwIAIAQgA0GgAfwKAAAgAUEBaiEBDAILIARBIEHA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ASASQgA3AwAgE0IANwMAIBRCADcDACAVQgA3AwAgF0IANwMAIBhCADcDACAZQgA3AwAgDiAAQQhqKQMANwMAIBAgAEEQaikDADcDACARIABBGGopAwA3AwAgA0IANwOAASADIAApAwA3A8ABIAApA4ABIRsgBSAaQeAA/AoAACAAQQA7AYgBIAAgG0IBfDcDgAEgASAKaiEBCyACQYEITwRAIABBnAFqIQ8gACkDgAEhGyADQdAAaiEMIANBwAFqIQkgA0GgAWohCgNAIBtCCoYhHEF/IAJBAXZndkEBaiEEA0AgBCIFQQF2IQQgHCAFQQFrrYNCAFINAAsgBUEKdq0hHAJAAkAgBUGBCE8EQCACIAVPDQFBACAFIAJB7NrAABCYAgALIANBiAFqQgA3AwAgA0GQAWpCADcDACADQZgBakIANwMAIApCADcDACADQagBakIANwMAIANBsAFqQgA3AwAgA0G4AWpCADcDACAJIAApAwA3AwAgCUEIaiIHIABBCGopAwA3AwAgCUEQaiIGIABBEGopAwA3AwAgCUEYaiIIIABBGGopAwA3AwAgA0IANwOAASADQQA7AegBIAMgGzcD4AEgAyAALQCKAToA6gEgA0GAAWogASAFEH4hBCAMIAkpAwA3AwAgDEEIaiAHKQMANwMAIAxBEGogBikDADcDACAMQRhqIAgpAwA3AwAgA0EYaiAEQQhqKQMANwMAIANBIGogBEEQaikDADcDACADQShqIARBGGopAwA3AwAgA0EwaiAEQSBqKQMANwMAIANBOGogBEEoaikDADcDACADQUBrIARBMGopAwA3AwAgA0HIAGogBEE4aikDADcDACADIAQpAwA3AxAgAy0A6gEhBCADLQDpASELIAMgAy0A6AEiDToAeCADIAMpA+ABIhs3A3AgAyAEIAtFckECciIEOgB5IANBiAJqIgsgCCkCADcDACADQYACaiIIIAYpAgA3AwAgA0H4AWoiDiAHKQIANwMAIAMgCSkCADcD8AEgA0HwAWogA0EQaiANIBsgBBAiIAsoAgAhByAIKAIAIQYgDigCACEIIAMoAowCIQsgAygChAIhDSADKAL8ASEOIAMoAvQBIRAgAygC8AEhESAAIAApA4ABEEMgACgCmAEiBEE3Tw0HIAAgBEEBajYCmAEgDyAEQQV0aiIEIAs2Ahwg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KAKYAygCmAMoApgDKAKYAygCmAMoApgDKAKYAygCmAMhBSAEQQhrIgQNAAsLIAUhBEEAIQULAkAgBC8BkgMgCUsEQCAEIQEMAQsDQCAEKAKIAiIBRQ0NIAVBAWohBSAELwGQAyEJIAkgASIELwGSA08NAAsLIAlBAWohBwJAIAVFBEAgASEEDAELIAEgB0ECdGpBmANqIQICQCAFQQdxIgdFBEAgBSEGDAELIAUhBgNAIAZBAWshBiACKAIAIgRBmANqIQIgB0EBayIHDQALC0EAIQcgBUEISQ0AA0AgAigCACgCmAMoApgDKAKYAygCmAMoApgDKAKYAygCmAMiBEGYA2ohAiAGQQhrIgYNAAsLAn8gASAJQQxsakGMAmohBiABIAlBGGxqIQUjAEEQayILJAAgA0HID2oiCS0AAEEBRwRAIAYoAgghAiAGKAIEIQEgCSgCBCENIAktAAFBAUcEQCANKAIAIgwoAgAgDCgCCCIGRgRAIAwgBkEBQQFBARDJASAMKAIIIQYLIAwgBkEBajYCCCAMKAIEIAZqQSw6AAALIAlBAjoAASALIA0gASACEGcCfyALLQAAQQRHBEAgCyALKQMANwMIIAtBCGoQpgIMAQsgDSgCACICKAIAIAIoAggiAUYEQCACIAFBAUEBQQEQyQEgAigCCCEBCyACIAFBAWo2AgggAigCBCABakE6OgAAIAUgDRAtCyALQRBqJAAMAQtB3dTAAEEoQYjVwAAQmQIACyIFDQNBACEFIA5BAWsiDg0ACyADKALIDyIBQQFxDQkgAUGA/gNxRQ0BIAMoAswPBSABCygCACIBKAIAIAEoAggiBUYEQCABIAVBAUEBQQEQyQEgASgCCCEFCyABIAVBAWo2AgggASgCBCAFakH9ADoAAAsgAygCNCEFIAMoAjAiD0GAgICAeEYNASADKAI4IQQgA0GAEGpCADcDACADQfgPakIANwMAIANB8A9qQgA3AwAgA0HoD2pCADcDACADQeAPakIANwMAIANB2A9qQgA3AwAgA0HQD2pCADcDACADQZAQakHotsAAKQIAIhM3AwAgA0GYEGpB8LbAACkCACISNwMAIANBoBBqQfi2wAApAgAiETcDACADQThqIBM3AwAgA0FAayASNwMAIANByABqIBE3AwAgA0IANwPIDyADQeC2wAApAgAiETcDiBAgAyARNwMwIANB0ABqIANByA9qIgJB4AD8CgAAIANBtwFqQQA2AAAgA0EANgLIASADQgA3A8ABIANCADcDsAEgA0EwaiIBIAUgBBApIANBwA9qIgtCADcDACADQbgPaiIMQgA3AwAgA0IANwOwDyMAQSBrIgQkAAJAIAEpA5ABUARAIAIgARAwIAJBADoAcCAEQSBqJAAMAQsgBEIANwIUIARCgYCAgMAANwIMIARBzNnAADYCCCABQZABakGI18AAIARBCGpB1NnAABCnAgALIANBsA9qIQFBGCEKIwBBQGoiCCQAAkACQCACIgQtAHAiAgR/IAggBEFAayAEIAQtAGggBCkDYCIRIAQtAGlBCHIQISACQcAASw0BQRhBwAAgAmsiBiAGQRhPGyIGBEAgASACIAhqIAb8CgAACyAEIAIgBmoiAjoAcCABIAZqIQFBGCAGayEKIAJB/wFxQcAARgR/IARBADoAcCAEIBFCAXw3A2BBAAUgAgsFQQALIQ0gCkE/SwRAIARBQGshDkEAIApBQHEiCWshECAELQBpQQhyIQcgBC0AaCEGIAQpA2AiESESIAEhAgNAIAggDiAEIAYgEiAHECEgAkE4aiAIQThqKQAANwAAIAJBMGogCEEwaikAADcAACACQShqIAhBKGopAAA3AAAgAkEgaiAIQSBqKQAANwAAIAJBGGogCEEYaikAADcAACACQRBqIAhBEGopAAA3AAAgAkEIaiAIQQhqKQAANwAAIAIgCCkAADcAACASQgF8IRIgAkFAayECIBBBQGsiEA0ACyAEIBEgCkEGdq18NwNgIApBP3EhCiABIAlqIQELAkAgCkUNACAIIARBQGsgBCAELQBoIAQpA2AgBC0AaUEIchAhIA1B/wFxIgJBwABNBEBBwAAgAmsiBiAKIAYgCkkbIgYEQCABIAIgCGogBvwKAAALIAQgBC0AcCAGaiIBOgBwIAFB/wFxQcAARw0BIARBADoAcCAEIAQpA2BCAXw3A2AMAQsMAQsgCEFAayQADAELIAJBwABBwABBpNfAABCYAgALIABBEGogCykDADcAACAAQQhqIAwpAwA3AAAgACADKQOwDzcAACAPBEAgBSAPQQEQ+gILIANBBHIQRCADQcAQaiQADwsgAygCMCIARQ0AIAMoAjQgAEEBEPoCCyADIAU2AjBBkLfAAEErIANBMGpBgLfAAEG8t8AAEOYBAAtBAUECENsCAAtBAUEJENsCAAtBAUEHENsCAAtBAUECENsCAAtBAUGAARDbAgALQfC4wABBKEGYucAAEJkCAAtB/LfAABD8AgALow8CKH8IfiMAQfACayICJAAgAkGgAmoiAyABEFAgAiACKQPoAiACKQPgAiACKQPYAiACKQPQAiACKQPIAiACKQPAAiIqQhqIfCIsQhmIfCIrQhqIfCIvQhmIfCIwQhqIfCItQhmIQhN+IAIpA6ACIi5C////H4N8IjGnQf///x9xIgQ2AgggAiACKQOoAiAuQhqIfCIuQv///w+DIDFCGoh8pyIINgIMIAIgLEL///8PgyAqQv///x+DIAIpA7gCIAIpA7ACIC5CGYh8IipCGoh8IixCGYh8Ii5CGoh8pyIJNgIcIAIgLqdB////H3EiBTYCGCACICynQf///w9xIgo2AhQgAiAvp0H///8PcSILNgIkIAIgLadB////D3EiDDYCLCACICqnQf///x9xIg02AhAgAiArp0H///8fcSIGNgIgIAIgMKdB////H3EiBzYCKCADIAFBKGoQUCACIAIpA+gCIAIpA+ACIAIpA9gCIAIpA9ACIAIpA8gCIAIpA8ACIipCGoh8IixCGYh8IitCGoh8Ii9CGYh8IjBCGoh8Ii1CGYhCE34gAikDoAIiLkL///8fg3wiMadB////H3EiDjYCMCACIAIpA6gCIC5CGoh8Ii5C////D4MgMUIaiHynIg82AjQgAiAsQv///w+DICpC////H4MgAikDuAIgAikDsAIgLkIZiHwiKkIaiHwiLEIZiHwiLkIaiHynIhA2AkQgAiAup0H///8fcSIRNgJAIAIgLKdB////D3EiEjYCPCACIC+nQf///w9xIhM2AkwgAiAtp0H///8PcSIUNgJUIAIgKqdB////H3EiFTYCOCACICunQf///x9xIhY2AkggAiAwp0H///8fcSIXNgJQIAMgAUHQAGoQUCACIAIpA9ACQgGGIAIpA8gCQgGGIAIpA8ACQgGGIipCGoh8IixCGYh8IiunQf///x9xNgJwIAIgAikDsAJCAYYgAikDqAJCAYYgAikDoAJCAYYiL0IaiHwiMEIZiHwiLadB////H3E2AmAgAiACKQPYAkIBhiArQhqIfCIrp0H///8PcTYCdCACIAIpA7gCQgGGIC1CGoh8Ii2nQf///w9xNgJkIAIgAikD4AJCAYYgK0IZiHwiK6dB////H3E2AnggAiAsQv///w+DICpC/v//H4MgLUIZiHwiKkIaiHw+AmwgAiAqp0H///8fcTYCaCACIAIpA+gCQgGGICtCGoh8IiqnQf///w9xNgJ8IAIgMEL///8PgyAqQhmIQhN+IC9C/v//H4N8IipCGoh8PgJcIAIgKqdB////H3E2AlggASgCKCEYIAEoAgAhGSABKAIsIRogASgCBCEbIAEoAjAhHCABKAIIIR0gASgCNCEeIAEoAgwhHyABKAI4ISAgASgCECEhIAEoAjwhIiABKAIUISMgASgCQCEkIAEoAhghJSABKAJEISYgASgCHCEnIAEoAkghKCABKAIgISkgAiABKAJMIAEoAiRqNgKkASACICggKWo2AqABIAIgJiAnajYCnAEgAiAkICVqNgKYASACICIgI2o2ApQBIAIgICAhajYCkAEgAiAeIB9qNgKMASACIBwgHWo2AogBIAIgGiAbajYChAEgAiAYIBlqNgKAASADIAJBgAFqEFAgAiACKQPQAiACKQPIAiACKQPAAiIqQhqIfCIsQhmIfCIrp0H///8fcTYCwAEgAiACKQOwAiACKQOoAiACKQOgAiIvQhqIfCIwQhmIfCItp0H///8fcTYCsAEgAiACKQPYAiArQhqIfCIrp0H///8PcTYCxAEgAiACKQO4AiAtQhqIfCItp0H///8PcTYCtAEgAiACKQPgAiArQhmIfCIrp0H///8fcTYCyAEgAiAsQv///w+DICpC////H4MgLUIZiHwiKkIaiHw+ArwBIAIgKqdB////H3E2ArgBIAIgAikD6AIgK0IaiHwiKqdB////D3E2AswBIAIgMEL///8PgyAqQhmIQhN+IC9C////H4N8IipCGoh8PgKsASACICqnQf///x9xNgKoASACQfABaiIBIAcgF2o2AgAgAkHoAWoiByAGIBZqNgIAIAJB4AFqIgYgBSARajYCACACQdgBaiIFIA0gFWo2AgAgAiAMIBRqNgL0ASACIAsgE2o2AuwBIAIgCSAQajYC5AEgAiAKIBJqNgLcASACIAggD2o2AtQBIAIgBCAOajYC0AEgAkH4AWoiBCACQTBqIAJBCGoQeiAAIAJBqAFqIAJB0AFqEHogAyACQdgAaiAEEHogAEHIAGogASkCADcCACAAQUBrIAcpAgA3AgAgAEE4aiAGKQIANwIAIABBMGogBSkCADcCACAAIAIpAtABNwIoIAAgAikC+AE3AlAgAEHYAGogAkGAAmopAgA3AgAgAEHgAGogAkGIAmopAgA3AgAgAEHoAGogAkGQAmopAgA3AgAgAEHwAGogAkGYAmopAgA3AgAgAEGYAWogAkHAAmopAgA3AgAgAEGQAWogAkG4AmopAgA3AgAgAEGIAWogAkGwAmopAgA3AgAgAEGAAWogAkGoAmopAgA3AgAgACACKQKgAjcCeCACQfACaiQAC50OAQp/IwBBEGsiCCQAAkACQAJAAkACQAJAAkACQCAALQAAQQFrDgUBAgMEBQALIAEoAgAiACgCACAAKAIIIgJrQQNNBEAgACACQQRBAUEBEMkBIAAoAgghAgsgACACQQRqNgIIIAAoAgQgAmpB7uqx4wY2AAAMBQsgASgCACEBIAAtAAFFBEAgASgCACABKAIIIgBrQQRNBEAgASAAQQVBAUEBEMkBIAEoAgghAAsgASAAQQVqNgIIIAEoAgQgAGoiAEGw0sAAKAAANgAAIABBBGpBtNLAAC0AADoAAAwGCyABKAIAIAEoAggiAGtBA00EQCABIABBBEEBQQEQyQEgASgCCCEACyABIABBBGo2AgggASgCBCAAakH05NWrBjYAAAwECyAAQQhqIAEQPAwDCyAIIAEgACgCCCAAKAIMEGcgCC0AAEEERg0DIAggCCkDADcDCCAIQQhqEKYCIQIMAwsgACgCDCEEIAAoAgghByABKAIAIgAoAgAgACgCCCICRgRAIAAgAkEBQQFBARDJASAAKAIIIQILIAAgAkEBajYCCCAAKAIEIAJqQdsAOgAAAkAgBEUNACAHIAEQLSICDQMgBEEBRg0AIARBGGxBGGshBiAHQRhqIQMDQCAAKAIIIgIgACgCAEYEQCAAIAJBAUEBQQEQyQEgACgCCCECCyAAIAJBAWo2AgggACgCBCACakEsOgAAIAMgARAtIgINBCADQRhqIQMgBkEYayIGDQALCyAAKAIIIgIgACgCAEYEQCAAIAJBAUEBQQEQyQEgACgCCCECCyAAIAJBAWo2AgggACgCBCACakHdADoAAAwBCyAAKAIMIQogASgCACIFKAIAIAUo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CyAGIBN6p0EDdiACaiAKcSICaiwAAEEATgRAIAYpAwBCgIGChIiQoMCAf4N6p0EDdiECCyACIAdrIAUgB2tzIApxQQhPBEAgAiAGaiIHLQAAIAcgEEEZdiIHOgAAIAkgAkEIayAKcWogBzoAACAGIAJBA3RrQQhrIQJB/wFGDQIgAigAACEHIAIgBCgAADYAACAEIAc2AAAgBCgABCEHIAQgAigABDYABCACIAc2AAQMAQsLIA8gEEEZdiICOgAAIAkgBUEIayAKcWogAjoAAAwBCyAPQf8BOgAAIAkgBUEIayAKcWpB/wE6AAAgAiAEKQAANwAACyAIIAggDEkiAmohBCACDQALCyABIA4gDWs2AghBgYCAgHghCQwBCwwBCyAAIA42AgQgACAJNgIAIANBQGskAA8LIANBADYCECADQQE2AgQgA0G4wMAANgIAIANCBDcCCCADQcDAwAAQvwIAC8cMAhJ/BH4jAEHQAWsiAiQAAkAgASgCmAEiBEUEQCAAIAEpA2A3A0AgACABKQMgNwMAIABByABqIAFB6ABqKQMANwMAIABB0ABqIAFB8ABqKQMANwMAIABB2ABqIAFB+ABqKQMANwMAIABBCGogAUEoaikDADcDACAAQRBqIAFBMGopAwA3AwAgAEEYaiABQThqKQMANwMAIABBIGogAUFAaykDADcDACAAQShqIAFByABqKQMANwMAIABBMGogAUHQAGopAwA3AwAgAEE4aiABQdgAaikDADcDACABLQCKASEEIAEtAIkBIQMgACABLQCIAToAaCAAIAEpA4ABNwNgIAAgBCADRXJBAnI6AGkMAQsCQAJAAkACQCABLQCIASIHIAEtAIkBIgZyBEAgAkG4AWogAUHoAGopAwA3AwAgAkHAAWogAUHwAGopAwA3AwAgAkHIAWogAUH4AGopAwA3AwAgAkH4AGogAUEoaikDADcDACACQYABaiABQTBqKQMANwMAIAJBiAFqIAFBOGopAwA3AwAgAkGQAWogAUFAaykDADcDACACQZgBaiABQcgAaikDADcDACACQaABaiABQdAAaikDADcDACACQagBaiABQdgAaikDADcDACACIAEpA2A3A7ABIAIgASkDIDcDcCABLQCKASEDIAEpA4ABIRQgAiACQfAAakHgAPwKAAAgAiADIAZFckECciIFOgBp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IQVBACEJAkAgB0EESQRAQQAhCAwBCyAHQXxxIQpBACEIA0BCASADIAhqIgZBA2oxAACGQgEgBjEAAIYgD4RCASAGQQFqMQAAhoRCASAGQQJqMQAAhoSEIQ8gCiAIQQRqIghHDQALCyAFRQ0AIAMgCGohBgNAQgEgBjEAAIYgD4QhDyAGQQFqIQYgBUEBayIFDQALCyAECyEGIAAgBDYCPCAAIAM2AjggACACNgI0IAAgATYCMCAAIAY2AiggACAJNgIkIAAgAjYCICAAQQA2AhwgACAHNgIYIAAgDDYCFCAAIA02AhAgACAPNwMIIABBATYCAA8LIAUgBEHg0MQAEPIBAAsgBSAEQeDQxAAQ8gEAC0EAIA0gBEGg0cQAEJgCAAsgByAFIARBkNHEABCYAgALIAUgBEHw0MQAEPIBAAsgCyAEQYDRxAAQ8gEACyAFIARB8NDEABDyAQALIAggBEGA0cQAEPIBAAuHDAIGfwZ+IwBBoAZrIgIkACACQdAFaiIFIAEQUCACIAIpA4AGIAIpA/gFIAIpA/AFIghCGoh8IgtCGYh8IgmnQf///x9xNgIYIAIgAikD4AUgAikD2AUgAikD0AUiDEIaiHwiDUIZiHwiCqdB////H3E2AgggAiACKQOIBiAJQhqIfCIJp0H///8PcTYCHCACIAIpA+gFIApCGoh8IgqnQf///w9xNgIMIAIgAikDkAYgCUIZiHwiCadB////H3E2AiAgAiALQv///w+DIAhC////H4MgCkIZiHwiCEIaiHw+AhQgAiAIp0H///8fcTYCECACIAIpA5gGIAlCGoh8IginQf///w9xNgIkIAIgDUL///8PgyAIQhmIQhN+IAxC////H4N8IghCGoh8PgIEIAIgCKdB////H3E2AgAgBSACEFAgAiACKQOABiACKQP4BSACKQPwBSIIQhqIfCILQhmIfCIJp0H///8fcTYCwAUgAiACKQPgBSACKQPYBSACKQPQBSIMQhqIfCINQhmIfCIKp0H///8fcTYCsAUgAiACKQOIBiAJQhqIfCIJp0H///8PcTYCxAUgAiACKQPoBSAKQhqIfCIKp0H///8PcTYCtAUgAiACKQOQBiAJQhmIfCIJp0H///8fcTYCyAUgAiALQv///w+DIAhC////H4MgCkIZiHwiCEIaiHw+ArwFIAIgCKdB////H3E2ArgFIAIgAikDmAYgCUIaiHwiCKdB////D3E2AswFIAIgDUL///8PgyAIQhmIQhN+IAxC////H4N8IghCGoh8PgKsBSACIAinQf///x9xNgKoBSAFIAJBqAVqIgYQUCACIAIpA4AGIAIpA/gFIAIpA/AFIghCGoh8IgtCGYh8IgmnQf///x9xNgJAIAIgAikD4AUgAikD2AUgAikD0AUiDEIaiHwiDUIZiHwiCqdB////H3E2AjAgAiACKQOIBiAJQhqIfCIJp0H///8PcTYCRCACIAIpA+gFIApCGoh8IgqnQf///w9xNgI0IAIgAikDkAYgCUIZiHwiCadB////H3E2AkggAiALQv///w+DIAhC////H4MgCkIZiHwiCEIaiHw+AjwgAiAIp0H///8fcTYCOCACIAIpA5gGIAlCGoh8IginQf///w9xNgJMIAIgDUL///8PgyAIQhmIQhN+IAxC////H4N8IghCGoh8PgIsIAIgCKdB////H3E2AiggAkHQAGoiBCABIAJBKGoQNiACQfgAaiIBIAIgBBA2IAUgARBQIAIgAikDgAYgAikD+AUgAikD8AUiCEIaiHwiC0IZiHwiCadB////H3E2ArgBIAIgAikD4AUgAikD2AUgAikD0AUiDEIaiHwiDUIZiHwiCqdB////H3E2AqgBIAIgAikDiAYgCUIaiHwiCadB////D3E2ArwBIAIgAikD6AUgCkIaiHwiCqdB////D3E2AqwBIAIgAikDkAYgCUIZiHwiCadB////H3E2AsABIAIgC0L///8PgyAIQv///x+DIApCGYh8IghCGoh8PgK0ASACIAinQf///x9xNgKwASACIAIpA5gGIAlCGoh8IginQf///w9xNgLEASACIA1C////D4MgCEIZiEITfiAMQv///x+DfCIIQhqIfD4CpAEgAiAIp0H///8fcTYCoAEgAkHIAWoiAyAEIAJBoAFqEDYgAkHwAWoiBCADQQUQTCACQZgCaiIBIAQgAxA2IAJBwAJqIgMgAUEKEEwgAkHoAmoiBCADIAEQNiACQZADaiIDIARBFBBMIAJBuANqIgcgAyAEEDYgAkHgA2oiAyAHQQoQTCACQYgEaiIEIAMgARA2IAJBsARqIgMgBEEyEEwgAkHYBGoiASADIAQQNiACQYAFaiIDIAFB5AAQTCAGIAMg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fnwgECAafnwgGyAgfnwgAyAOfnwgCSAYfnwgBiALfnwgBSAHfnwgCCAMfnwgCiAdfnwgJUIaiHwiBKdB////D3E2AgwgACASIBR+IBEgE358IA4gFX58IAsgFn58IAMgAa0iDH58IAUgF358IAYgHn58IAcgD358IAggDX58IAkgCn58IB9CGYh8IgWnQf///x9xNgIgIAAgI0L///8PgyAiQv///x+DIARCGYh8IgRCGoh8PgIUIAAgBKdB////H3E2AhAgACAYIB5+IAwgGX58IA8gHH58IA0gGn58IAMgLa1+fCAJIBt+fCAGIBF+fCAHIBR+fCAIIA5+fCAKIAt+fCAFQhqIfCIDp0H///8PcTYCJCAAICRC////D4MgA0IZiEITfiAhQv///x+DfCIDQhqIfD4CBCAAIAOnQf///x9xNgIAC90MAg1/AX4jAEGgAmsiByQAAkACQAJAAkACQCABQYAITQRAIAdBADYCiAEgASABQQAgAUGACEcbIgxrIg5BgAhPBEAgB0EBNgKIASAHIAA2AowBQQEhCgsgB0GMAWohCyADIRQgBSEBIwBBIGsiCCQAIAZBBXYiCSAKIAkgCkkbIg0EQCAEQQJyIQ8gBEEBciEQA0AgCygCACEJIAhBGGoiESACQRhqKQIANwMAIAhBEGoiEiACQRBqKQIANwMAIAhBCGoiEyACQQhqKQIANwMAIAggAikCADcDACAIIAlBwAAgFCAQECIgCCAJQUBrQcAAIBQgBBAiIAggCUGAAWpBwAAgFCAEECIgCCAJQcABakHAACAUIAQQIiAIIAlBgAJqQcAAIBQgBBAiIAggCUHAAmpBwAAgFCAEECIgCCAJQYADakHAACAUIAQQIiAIIAlBwANqQcAAIBQgBBAiIAggCUGABGpBwAAgFCAEECIgCCAJQcAEakHAACAUIAQQIiAIIAlBgAVqQcAAIBQgBBAiIAggCUHABWpBwAAgFCAEECIgCCAJQYAGakHAACAUIAQQIiAIIAlBwAZqQcAAIBQgBBAiIAggCUGAB2pBwAAgFCAEECIgCCAJQcAHakHAACAUIA8QIiABQRhqIBEpAwA3AAAgAUEQaiASKQMANwAAIAFBCGogEykDADcAACABIAgpAwA3AAAgC0EEaiELIAFBIGohASAUQgF8IRQgDUEBayINDQALCyAIQSBq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BjcDCCAAIAZCP4g3AwAMEgsgACABMgEEIgY3AwggACAGQj+INwMADBELIAAgATQCBCIGNwMIIAAgBkI/iDcDAAwQCyAAIAEpAwgiBjcDCCAAIAZCP4g3AwAMDwsgASoCBLsiB71C////////////AINCgICAgICAgPj/AFoEQCAAQbXSwABBERDhATYCCCAAQgM3AwAMDwsgACAHOQMIIABCAjcDAAwOCyABKwMIIge9Qv///////////wCDQoCAgICAgID4/wBaBEAgAEG10sAAQREQ4QE2AgggAEIDNwMADA4LIAAgBzkDCCAAQgI3AwAMDQsgASgCBCEBIAJBADYCBCABQYABSQ0KIAFBP3FBgH9yIQMgAUEGdiEEIAFBgBBJBEAgAiADOgAFIAIgBEHAAXI6AARBAgwMCyABQQx2IQUgBEE/cUGAf3IhBCABQf//A00EQCACIAM6AAYgAiAEOgAFIAIgBUHgAXI6AARBAwwMCyACIAM6AAcgAiAEOgAGIAIgBUE/cUGAf3I6AAUgAiABQRJ2QXByOgAEQQQMCwsgASkDCCEGIAJBBToACCACIAY3AgwgAkEIaiACQR9qQaDSwAAQ1wEhASAAQgM3AwAgACABNgIIDAsLIAEpAgQhBiACQQU6AAggAiAGNwIMIAJBCGogAkEfakGg0sAAENcBIQEgAEIDNwMAIAAgATYCCAwKCyABKQMIIQYgAkEGOgAIIAIgBjcCDCACQQhqIAJBH2pBoNLAABDXASEBIABCAzcDACAAIAE2AggMCQsgASkCBCEGIAJBBjoACCACIAY3AgwgAkEIaiACQR9qQaDSwAAQ1wEhASAAQgM3AwAgACABNgIIDAgLIAJBCDoACCACQQhqIAJBH2pBoNLAABDXASEBIABCAzcDACAAIAE2AggMBwsgAkEIOgAIIAJBCGogAkEfakGg0sAAENcBIQEgAEIDNwMAIAAgATYCCAwGCyACQQc6AAggAkEIaiACQR9qQaDSwAAQ1wEhASAAQgM3AwAgACABNgIIDAULIAJBCToACCACQQhqIAJBH2pBoNLAABDXASEBIABCAzcDACAAIAE2AggMBAsgAkEKOgAIIAJBCGogAkEfakGg0sAAENcBIQEgAEIDNwMAIAAgATYCCAwDCyACQQs6AAggAkEIaiACQR9qQaDSwAAQ1wEhASAAQgM3AwAgACABNgIIDAILIAIgAToABEEBCzYCECACQQU6AAggAiACQQRqNgIMIAJBCGogAkEfakGg0sAAENcBIQEgAEIDNwMAIAAgATYCCAsgAkEgaiQAC5oHAQ1/IwBBoAFrIgMkACADQQA2AgwgA0KAgICAEDcCBCADQRBqIAEgAkGtq8AAQQEQMiADQYgBaiADQcgAaikDADcDACADQYABaiADQUBrKQMANwMAIANB+ABqIANBOGopAwA3AwAgA0HwAGogA0EwaikDADcDACADQegAaiADQShqKQMANwMAIANB4ABqIANBIGopAwA3AwAgA0HYAGoiDyADQRhqKQMANwMAIAMgAykDEDcDUEEBIQsCQANAAkACQAJAAkACQCADKAJQQQFGBEAgAygCjAEhBSADKAKIASEEIAMoAoQBIQcgAygCgAEhCCADKAJ0QX9GDQEgA0GUAWogDyAIIAcgBCAFQQAQcgwFCyADLQBeRQRAIAMtAFwhDCADKAKEASEEIAMoAoABIQgCQCADKAJUIgVFDQAgBCAFTQRAIAQgBUYNAQwJCyAFIAhqLAAAQUBIDQgLIAQgBUcEQAJ/IAUgCGoiDSwAACIHQQBIBEAgDS0AAUE/cSEKIAdBH3EhDiAOQQZ0IApyIAdBYEkNARogDS0AAkE/cSAKQQZ0ciEKIAogDkEMdHIgB0FwSQ0BGiAOQRJ0QYCA8ABxIA0tAANBP3EgCkEGdHJyDAELIAdB/wFxCyEHIAxBAXENAwJAAn9BASAHQYABSQ0AGkECIAdBgBBJDQAaQQNBBCAHQYCABEkbCyAFaiIFRQ0AIAQgBU0EQCAEIAVHDQoMAQsgBSAIaiwAAEFASA0JCyAEIAVGDQQgBSAIaiwAABoMAwsgAyAMQX9zQQFxOgBcIAUhBCAMQQFxDQQgA0EBOgBeCyADQQA2ApQBDAQLIANBlAFqIA8gCCAHIAQgBUEBEHIMAwsgBSEECyADQQA6AFwgAyAENgJUCyADIAQ2ApwBIAMgBDYCmAEgA0EBNgKUAQsgAygClAFBAUYEQCADKAKcASADKAKYASAJayIEIAMoAgQgBmtLBEAgA0EEaiAGIARBAUEBEMkBIAMoAgghCyADKAIMIQYLIAQEQCAGIAtqIAEgCWogBPwKAAALIAMgBCAGaiIGNgIMIQkMAQsLIAIgCWsiAiADKAIEIAZrSwRAIANBBGogBiACQQFBARDJASADKAIIIQsgAygCDCEGCyACBEAgBiALaiABIAlqIAL8CgAACyAAQQhqIAIgBmo2AgAgACADKQIENwIAIANBoAFqJAAPCyAIIAQgBSAEQfSxwAAQ6wIAC9QHAwR/A34BfCMAQTBrIgMkACABKAIAIQICQAJAAkACQAJAAkAgACgCAEEBaw4CAQIAC0EUIQEgACkDCCIHQpDOAFQEQCAHIQYMBAsDQCADQQhqIAFqIgBBBGsgByAHQpDOAIAiBkKQzgB+faciBEH//wNxQeQAbiIFQQF0LwDG0kA7AAAgAEECayAEIAVB5ABsa0H//wNxQQF0LwDG0kA7AAAgAUEEayEBIAdC/8HXL1YgBiEHDQALDAMLQRQhASAAKQMIIgggCEI/hyIGhSAGfSIHQpDOAFQEQCAHIQYMAgsDQCADQQhqIAFqIgBBBGsgByAHQpDOAIAiBkKQzgB+faciBEH//wNxQeQAbiIFQQF0LwDG0kA7AAAgAEECayAEIAVB5ABsa0H//wNxQQF0LwDG0kA7AAAgAUEEayEBIAdC/8HXL1YgBiEHDQALDAELIAArAwgiCb1C////////////AINCgICAgICAgPj/AFoEQCACKAIAIAIoAggiAWtBA00EQCACIAFBBEEBQQEQyQEgAigCCCEBCyACIAFBBGo2AgggAigCBCABakHu6rHjBjYAAAwDCyAJIANBCGoQKCIBIAIoAgAgAigCCCIAa0sEQCACIAAgAUEBQQEQyQEgAigCCCEACyABBEAgAigCBCAAaiADQQhqIAH8CgAACyACIAAgAWo2AggMAgsgBkLjAFYEQCABQQJrIgEgA0EIamogBqciACAAQf//A3FB5ABuIgBB5ABsa0H//wNxQQF0LwDG0kA7AAAgAK0hBgsCQCAGQgpaBEAgAUECayIAIANBCGpqIAanQQF0LwDG0kA7AAAMAQsgAUEBayIAIANBCGpqIAanQTByOgAACyAIQgBTBEAgAEEBayIAIANBCGpqQS06AAALQRQgAGsiBCACKAIAIAIoAggiAWtLBEAgAiABIARBAUEBEMkBIAIoAgghAQsgBARAIAIoAgQgAWogA0EIaiAAaiAE/AoAAAsgAiABIARqNgIIDAELIAZC4wBWBEAgAUECayIBIANBCGpqIAan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KALoAUEBdCIMNgKQAiADIAMoAuwBQQF0Ig02ApQCIAAgBSAGEHogAygCxAEhBSADKAJ4IQYgAygCUCEOIAMoAnwhDyADKAJUIRAgAygCgAEhESADKAJYIRIgAygChAEhEyADKAJcIRQgAygCiAEhFSADKAJgIRcgAygCjAEhGCADKAJkIRkgAygCkAEhGiADKAJoIRsgAygClAEhHCADKAJsIR0gAygCmAEhHiADKAJwIR8gAygCnAEhICADKAJ0ISEgAygCoAEhIiADKAKkASEjIAMoAqgBISQgAygCrAEhJSADKAKwASEmIAMoArQBIScgAygCuAEhKCADKAK8ASEpIAMoAsABISogA0GYAmogA0HwAWogFhB6IAAgBSANajYCdCAAIAwgKmo2AnAgACALIClqNgJsIAAgCiAoajYCaCAAIAkgJ2o2AmQgACAIICZqNgJgIAAgByAlajYCXCAAIAQgJGo2AlggACACICNqNgJUIAAgASAiajYCUCAAICAgIWo2AkwgACAeIB9qNgJIIAAgHCAdajYCRCAAIBogG2o2AkAgACAYIBlqNgI8IAAgFSAXajYCOCAAIBMgFGo2AjQgACARIBJqNgIwIAAgDyAQajYCLCAAIAYgDmo2AiggAEGYAWogA0G4AmopAgA3AgAgAEGQAWogA0GwAmopAgA3AgAgAEGIAWogA0GoAmopAgA3AgAgAEGAAWogA0GgAmopAgA3AgAgACADKQKYAjcCeCADQcACaiQAC9kIAgd/AX4jAEHAA2siByQAAkACQCACQSBGBEAgAUECai0AACELIAEoAAMhCSABKAAHIQIgASgACyEMIAEpAA8hDiABLwAAIQ0gB0HrAWogAUEfai0AADoAACAHIAs6AM4BIAcgDTsBzAEgByAONwDbASAHIAw2ANcBIAcgAjYA0wEgByAJNgDPASAHIAEpABc3AOMBIAdBmAJqIgggB0HMAWoiChBWIAcoApgCRQRAIAdBADYCmAIgByAIEJQCIAcoAgAhAiAHIAcoAgQiAzYCkAIgByACNgKMAiAHQQA2AtQBIAdCgICAgBA3AswBIAdB4LzAADYCnAIgB0KggICADjcCoAIgByAKNgKYAiAHQYwCaiEEIwBBMGsiASQAAn9BASAIQdKewwBBDxDpAg0AGkEAIAQoAgBFDQAaIAEgBDYCDCABQQE2AhQgAUHknsMANgIQIAFCATcCHCABIAFBDGqtQoCAgIDQD4Q3AyggASABQShqNgIYIAgoAgAgCCgCBCABQRBqEGALIAFBMGokAA0CIAcvAdABIAdB0gFqLQAAQRB0ciEBIActANcBIQQgBygA0wEhBSAHKALMASEGAkAgAkUNACADKAIAIggEQCACIAgRBAALIAMoAgQiCEUNACACIAggAygCCBD6AgsgACABOwEIIAAgBDoADyAAIAU2AAsgACAGNgIEIABBBDYCACAAQQpqIAFBEHY6AAAMAwsgB0E4aiAHQagCaigCADYCACAHIAcpAqACNwIwIAcoApwCIQggB0E8aiAHQawCakGQAfwKAAAgB0EraiABQRdqIgFBCGotAAA6AAAgB0EWaiACQRh2OgAAIAcgDjwAGyAHIA5CKIinIgo7ASAgB0EiaiAKQRB2OgAAIAcgASkAADcAIyAHIAJBCHY7ARQgByAINgIsIAcgDDYAFyAHIAJBGHQgCUEIdnI2AhAgByANIAtBEHRyIAlBGHRyNgIMIAcgDkIIiD4CHCAGQcAARgRAIAdBzgFqIAVBAmotAAA6AAAgB0HrAWogBUEfaikAADcAACAHQfMBaiAFQSdqKQAANwAAIAdB+wFqIAVBL2opAAA3AAAgB0GDAmogBUE3aikAADcAACAHQYsCaiAFQT9qLQAAOgAAIAcgBS8AADsBzAEgByAFKQAXNwDjASAFKAADIQEgB0HbAWogBUEPaikAADcAACAHIAE2AM8BIAcgBSkABzcA0wEgB0GYAmoiASAHQcwBahDqASAHQYwCaiAHQQxqIAMgBCABEIEBIABBCjYCACAAIAcoAowCIgBBAXM6AAQgAEUNAyAHKAKQAiIARQ0DIAcoApQCIgEoAgAiAgRAIAAgAhEEAAsgASgCBCICRQ0DIAAgAiABKAIIEPoCDAMLIABBAzYCAAwCCyAAIAI2AgggAEKAgICAgAQ3AgAMAQtBiL3AAEE3IAdBvwNqQfi8wABBwL3AABDmAQALIAdBwANqJAAL/wcBKH8jAEGgAmsiAyQAIAEoAgAhBCABKAIoIQcgASgCBCEIIAEoAiwhCSABKAIIIQogASgCMCELIAEoAgwhDCABKAI0IQ0gASgCECEFIAEoAjghBiABKAIUIQ4gASgCPCEPIAEoAhghECABKAJAIREgASgCHCESIAEoAkQhEyABKAIgIRQgASgCSCEVIAMgASgCJCABKAJMajYCLCADIBQgFWo2AiggAyASIBNqNgIkIAMgECARajYCICADIA4gD2o2AhwgAyAFIAZqNgIYIAMgDCANajYCFCADIAogC2o2AhAgAyAIIAlqNgIMIAMgBCAHajYCCCADQTBqIgQgAUEoaiABEHogA0HYAGoiBSADQQhqIAIQNiADQYABaiIGIAQgAkEoahA2IANBqAFqIhYgAUH4AGogAkHQAGoQNiADIAEoAlBBAXQiAjYC0AEgAyABKAJUQQF0IgQ2AtQBIAMgASgCWEEBdCIHNgLYASADIAEoAlxBAXQiCDYC3AEgAyABKAJgQQF0Igk2AuABIAMgASgCZEEBdCIKNgLkASADIAEoAmhBAXQiCzYC6AEgAyABKAJsQQF0Igw2AuwBIAMgASgCcEEBdCINNgLwASADIAEoAnRBAXQiATYC9AEgACAFIAYQeiADKALMASEFIAMoAoABIQYgAygCWCEOIAMoAoQBIQ8gAygCXCEQIAMoAogBIREgAygCYCESIAMoAowBIRMgAygCZCEUIAMoApABIRUgAygCaCEXIAMoApQBIRggAygCbCEZIAMoApgBIRogAygCcCEbIAMoApwBIRwgAygCdCEdIAMoAqABIR4gAygCeCEfIAMoAqQBISAgAygCfCEhIAMoAqgBISIgAygCrAEhIyADKAKwASEkIAMoArQBISUgAygCuAEhJiADKAK8ASEnIAMoAsABISggAygCxAEhKSADKALIASEqIANB+AFqIANB0AFqIBYQeiAAIAEgBWo2AnQgACANICpqNgJwIAAgDCApajYCbCAAIAsgKGo2AmggACAKICdqNgJkIAAgCSAmajYCYCAAIAggJWo2AlwgACAHICRqNgJYIAAgBCAjajYCVCAAIAIgImo2AlAgACAgICFqNgJMIAAgHiAfajYCSCAAIBwgHWo2AkQgACAaIBtqNgJAIAAgGCAZajYCPCAAIBUgF2o2AjggACATIBRqNgI0IAAgESASajYCMCAAIA8gEGo2AiwgACAGIA5qNgIoIABBmAFqIANBmAJqKQIANwIAIABBkAFqIANBkAJqKQIANwIAIABBiAFqIANBiAJqKQIANwIAIABBgAFqIANBgAJqKQIANwIAIAAgAykC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B0ECa0E3SSEWA0AgACAINgKYASAQIAAgDmoiA0GEAWopAAA3AwAgESADQYwBaikAADcDACASIANBlAFqKQAANwMAIAIgA0H8AGopAAA3AwAgCEUNAiAAIAhBAWsiBzYCmAEgAkGoAWoiBCADQfQAaiIXKQAANwMAIAJBoAFqIgUgA0HsAGoiGCkAADcDACACQZgBaiIGIANB5ABqIhkpAAA3AwAgAiADQdwAaiIaKQAANwOQASAJQRhqIBIpAwA3AAAgCUEQaiARKQMANwAAIAlBCGogECkDADcAACAJIAIpAwA3AAAgCiAAKQMANwMAIApBCGogAEEIaiILKQMANwMAIApBEGogAEEQaiIMKQMANwMAIApBGGogAEEYaiINKQMANwMAIAJBKGogBikDADcDACACQTBqIAUpAwA3AwAgAkE4aiAEKQMANwMAIAJBQGsgCSkDADcDACACQcgAaiACQbgBaikDADcDACACQdAAaiACQcABaikDADcDACACQdgAaiACQcgBaikDADcDACACIAIpA5ABNwMgIAJBwAA6AIgBIAIgDzoAiQEgAkIANwOAASAEIA0pAgA3AwAgBSAMKQIANwMAIAYgCykCADcDACACIAApAgA3A5ABIAJBkAFqIAJBIGpBwABCACAPECIgBCgCACEEIAUoAgAhBSAGKAIAIQYgAigCrAEhCyACKAKkASEMIAIoApwBIQ0gAigClAEhEyACKAKQASEUIBZFDQMgGiAUNgIAIANB+ABqIAs2AgAgFyAENgIAIANB8ABqIAw2AgAgGCAFNgIAIANB6ABqIA02AgAgGSAGNgIAIANB4ABqIBM2AgAgACAINgKYASAOQSBrIQ4gByIIIBVPDQALCyACQdABaiQADwtB5NnAABD8AgALIAIgCzYCrAEgAiAENgKoASACIAw2AqQBIAIgBTYCoAEgAiANNgKcASACIAY2ApgBIAIgEzYClAEgAiAUNgKQAUGs28AAQSsgAkGQAWpBnNzAAEH02cAAEOYBAAvuBgEHfyAAKAIAIgEEQCAAKAIEIQICQCAAKAIIIgcEfwNAAkAgBARAIAEhACAEIQEMAQtBACEAAkAgAkUNACACIQUgAkEHcSIDBEADQCAFQQFrIQUgASgCmAMhASADQQFrIgMNAAsLIAJBCEkNAANAIAEoApgDKAKYAygCmAMo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IAEgBGo2AhAgA0EEaiADQRBqEJ0BIAMoAgRBgICAgHhGBEAgACADKQIINwIEIABBiICAgHg2AgAMAQsgACADKQIENwIEIABBDGogA0EMaigCADYCACAAQYqAgIB4NgIACyADQdAAaiQADwsgCCAFIAQgBUHgzsAAEOsCAAvdBQEBfyAAQQAgAkH/AXFrIgIgACgCACIDIAEoAgBzcSADczYCACAAIAAoAgQiAyABKAIEcyACcSADczYCBCAAIAAoAggiAyABKAIIcyACcSADczYCCCAAIAAoAgwiAyABKAIMcyACcSADczYCDCAAIAAoAhAiAyABKAIQcyACcSADczYCECAAIAAoAhQiAyABKAIUcyACcSADczYCFCAAIAAoAhgiAyABKAIYcyACcSADczYCGCAAIAAoAhwiAyABKAIccyACcSADczYCHCAAIAAoAiAiAyABKAIgcyACcSADczYCICAAIAAoAiQiAyABKAIkcyACcSADczYCJCAAIAAoAigiAyABKAIocyACcSADczYCKCAAIAAoAiwiAyABKAIscyACcSADczYCLCAAIAAoAjAiAyABKAIwcyACcSADczYCMCAAIAAoAjQiAyABKAI0cyACcSADczYCNCAAIAAoAjgiAyABKAI4cyACcSADczYCOCAAIAAoAjwiAyABKAI8cyACcSADczYCPCAAIAAoAkAiAyABKAJAcyACcSADczYCQCAAIAAoAkQiAyABKAJEcyACcSADczYCRCAAIAAoAkgiAyABKAJIcyACcSADczYCSCAAIAAoAkwiAyABKAJMcyACcSADczYCTCAAIAAoAlAiAyABKAJQcyACcSADczYCUCAAIAAoAlQiAyABKAJUcyACcSADczYCVCAAIAAoAlgiAyABKAJYcyACcSADczYCWCAAIAAoAlwiAyABKAJccyACcSADczYCXCAAIAAoAmAiAyABKAJgcyACcSADczYCYCAAIAAoAmQiAyABKAJkcyACcSADczYCZCAAIAAoAmgiAyABKAJocyACcSADczYCaCAAIAAoAmwiAyABKAJscyACcSADczYCbCAAIAAoAnAiAyABKAJwcyACcSADczYCcCAAIAAoAnQiACABKAJ0cyACcSAAczYCdAvaBQIHfwF+An8gAUUEQCAAKAIIIQdBLSELIAVBAWoMAQtBK0GAgMQAIAAoAggiB0GAgIABcSIBGyELIAFBFXYgBWoLIQkCQCAHQYCAgARxRQRAQQAhAgwBCwJAIANBEE8EQCACIAMQQSEBDAELIANFBEBBACEBDAELIANBA3EhCgJAIANBBEkEQEEAIQEMAQsgA0EMcSEMQQAhAQNAIAEgAiAIaiIGLAAAQb9/SmogBkEBaiwAAEG/f0pqIAZBAmosAABBv39KaiAGQQNqLAAAQb9/SmohASAMIAhBBGoiCEcNAAsLIApFDQAgAiAIaiEGA0AgASAGLAAAQb9/SmohASAGQQFqIQYgCkEBayIKDQALCyABIAlqIQkLAkAgAC8BDCIIIAlLBEACQAJAIAdBgICACHFFBEAgCCAJayEIQQAhAUEAIQkCQAJAAkAgB0EddkEDcUEBaw4DAAEAAgsgCCEJDAELIAhB/v8DcUEBdiEJCyAHQf///wBxIQogACgCBCEHIAAoAgAhAANAIAFB//8DcSAJQf//A3FPDQJBASEGIAFBAWohASAAIAogBygCEBEAAEUNAAsMBAsgACAAKQIIIg2nQYCAgP95cUGwgICAAnI2AghBASEGIAAoAgAiByAAKAIEIgogCyACIAMQowINA0EAIQEgCCAJa0H//wNxIQIDQCABQf//A3EgAk8NAiABQQFqIQEgB0EwIAooAhARAABFDQALDAMLQQEhBiAAIAcgCyACIAMQowINAiAAIAQgBSAHKAIMEQEADQJBACEBIAggCWtB//8DcSECA0AgAUH//wNxIgMgAkkhBiACIANNDQMgAUEBaiEBIAAgCiAHKAIQEQAARQ0ACwwCCyAHIAQgBSAKKAIMEQEADQEgACANNwIIQQAPC0EBIQYgACgCACIBIAAoAgQiACALIAIgAxCjAg0AIAEgBCAFIAAoAgwRAQAhBgsgBgvABQIBfwZ+IwBBgAFrIgMkACADQTBqIAEQUCADIAMpA2AgAykDWCADKQNQIgRCGoh8IgdCGYh8IgWnQf///x9xNgIgIAMgAykDQCADKQM4IAMpAzAiCEIaiHwiCUIZiHwiBqdB////H3E2AhAgAyADKQNoIAVCGoh8IgWnQf///w9xNgIkIAMgAykDSCAGQhqIfCIGp0H///8PcTYCFCADIAMpA3AgBUIZiHwiBadB////H3E2AiggAyAHQv///w+DIARC////H4MgBkIZiHwiBEIaiHw+AhwgAyAEp0H///8fcTYCGCADIAMpA3ggBUIaiHwiBKdB////D3E2AiwgAyAJQv///w+DIARCGYhCE34gCEL///8fg3wiBEIaiHw+AgwgAyAEp0H///8fcTYCCCACQQJPBEAgAkEBayECA0AgA0EwaiADQQhqEFAgAyADKQNgIAMpA1ggAykDUCIEQhqIfCIHQhmIfCIFp0H///8fcTYCICADIAMpA0AgAykDOCADKQMwIghCGoh8IglCGYh8IganQf///x9xNgIQIAMgAykDaCAFQhqIfCIFp0H///8PcTYCJCADIAMpA0ggBkIaiHwiBqdB////D3E2AhQgAyADKQNwIAVCGYh8IgWnQf///x9xNgIoIAMgB0L///8PgyAEQv///x+DIAZCGYh8IgRCGoh8PgIcIAMgBKdB////H3E2AhggAyADKQN4IAVCGoh8IgSnQf///w9xNgIsIAMgCUL///8PgyAEQhmIQhN+IAhC////H4N8IgRCGoh8PgIMIAMgBKdB////H3E2AgggAkEBayICDQALCyAAIAMpAgg3AgAgAEEgaiADQShqKQIANwIAIABBGGogA0EgaikCADcCACAAQRBqIANBGGopAgA3AgAgAEEIaiADQRBqKQIANwIAIANBgAFqJAALlwYBBX8gAEEIayIBIABBBGsoAgAiA0F4cSIAaiECAkACQCADQQFxDQAgA0ECcUUNASABKAIAIgMgAGohACABIANrIgFB+OfEACgCAEYEQCACKAIEQQNxQQNHDQFB8OfEACAANgIAIAIgAigCBEF+cTYCBCABIABBAXI2AgQgAiAANgIADwsgASADEIYBCwJAAkACQAJAAkAgAigCBCIDQQJxRQRAIAJB/OfEACgCAEYNAiACQfjnxAAoAgBGDQMgAiADQXhxIgIQhgEgASAAIAJqIgBBAXI2AgQgACABaiAANgIAIAFB+OfEACgCAEcNAUHw58QAIAA2AgAPCyACIANBfnE2AgQgASAAQQFyNgIEIAAgAWogADYCAAsgAEGAAkkNAiABIAAQlQFBACEBQZDoxABBkOjEACgCAEEBayIANgIAIAANBEHY5cQAKAIAIgAEQANAIAFBAWohASAAKAIIIgANAAsLQZDoxABB/x8gASABQf8fTRs2AgAPC0H858QAIAE2AgBB9OfEAEH058QA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AmoiCiAFQQxsaiIJQQhqKAIANgIAIAJBQGsgByAFQRhsaiIDQQhqKQMANwMAIAJByABqIANBEGopAwA3AwAgAiAJKQIANwMoIAIgAykDADcDOCAEQQxPDQEgBUEBaiEDIARBDGwiCQRAIAZBjAJqIAogA0EMbGogCfwKAAALIARBGGwiBARAIAYgByADQRhsaiAE/AoAAAsgByAFOwGSAyACQQhqIAJBMGooAgA2AgAgAkEYaiACQUBrKQMANwMAIAJBIGogAkHIAGopAwA3AwAgAiACKQMoNwMAIAIgAikDODcDECAGLwGSAyIEQQFqIQMgBEEMTw0CIAggBWsgA0cNAyAGQZgDaiEIIANBAnQiAwRAIAggByAFQQJ0akGcA2ogA/wKAAALIAEoAgQhBUEAIQEDQAJAIAggAUECdGooAgAiAyABOwGQAyADIAY2AogCIAEgBE8NACABIAEgBElqIgEgBE0NAQsLIAAgBTYCLCAAIAc2AiggACACKQMANwMAIAAgBTYCNCAAIAY2AjAgAEEIaiACQQhqKQMANwMAIABBEGogAkEQaikDADcDACAAQRhqIAJBGGopAwA3AwAgAEEgaiACQSBqKQMANwMAIAJB0ABqJAAPC0EIQcgDEJoDAAtBACAEQQtB6LXAABCYAgALQQAgA0EMQfi1wAAQmAIAC0GwtcAAQShB2LXAABCZAgALuCACFX8IfiMAQaADayIEJAAgBEGoAWoiAiABEG8gBEHwAWpBkOXAACkCADcDACAEQegBakGI5cAAKQIANwMAIARB4AFqQYDlwAApAgA3AwAgBEHYAWpB+OTAACkCADcDACAEQfDkwAApAgA3A9ABIwBB0ABrIgMkACADIAIQUCAEQfwBaiICIAMpAzAgAykDKCADKQMgIhdCGoh8IhtCGYh8IhinQf///x9xNgIYIAIgAykDECADKQMIIAMpAwAiHEIaiHwiGkIZiHwiGadB////H3E2AgggAiADKQM4IBhCGoh8IhinQf///w9xNgIcIAIgAykDGCAZQhqIfCIZp0H///8PcTYCDCACIAMpA0AgGEIZiHwiGKdB////H3E2AiAgAiAbQv///w+DIBdC////H4MgGUIZiHwiF0IaiHw+AhQgAiAXp0H///8fcTYCECACIAMpA0ggGEIaiHwiF6dB////D3E2AiQgAiAaQv///w+DIBdCGYhCE34gHEL///8fg3wiF0IaiHw+AgQgAiAXp0H///8fcTYCACADQdAAaiQAIARBpAJqIgMgAiAEQdABahB6IARB2ABqIAJByOTAABA2IAQgBCgCfDYC8AIgBCAEKQJ0NwLoAiAEIAQpAmw3AuACIAQgBCkCZDcC2AIgBCAEKQJcNwLQAiAEIAQoAlhBAWo2AswCIARB9AJqIQkjAEHwAmsiAiQAIAJBoAJqIgUgBEHMAmoiCBBQIAIgAikD0AIgAikDyAIgAikDwAIiF0IaiHwiG0IZiHwiGKdB////H3E2ApACIAIgAikDsAIgAikDqAIgAikDoAIiHEIaiHwiGkIZiHwiGadB////H3E2AoACIAIgAikD2AIgGEIaiHwiGKdB////D3E2ApQCIAIgAikDuAIgGUIaiHwiGadB////D3E2AoQCIAIgAikD4AIgGEIZiHwiGKdB////H3E2ApgCIAIgG0L///8PgyAXQv///x+DIBlCGYh8IhdCGoh8PgKMAiACIBenQf///x9xNgKIAiACIAIpA+gCIBhCGoh8IhenQf///w9xNgKcAiACIBpC////D4MgF0IZiEITfiAcQv///x+DfCIXQhqIfD4C/AEgAiAXp0H///8fcTYC+AEgAkEIaiIHIAJB+AFqIgYgCBA2IAUgBxBQIAIgAikD0AIgAikDyAIgAikDwAIiF0IaiHwiG0IZiHwiGKdB////H3E2ApACIAIgAikDsAIgAikDqAIgAikDoAIiHEIaiHwiGkIZiHwiGadB////H3E2AoACIAIgAikD2AIgGEIaiHwiGKdB////D3E2ApQCIAIgAikDuAIgGUIaiHwiGadB////D3E2AoQCIAIgAikD4AIgGEIZiHwiGKdB////H3E2ApgCIAIgG0L///8PgyAXQv///x+DIBlCGYh8IhdCGoh8PgKMAiACIBenQf///x9xNgKIAiACIAIpA+gCIBhCGoh8IhenQf///w9xNgKcAiACIBpC////D4MgF0IZiEITfiAcQv///x+DfCIXQhqIfD4C/AEgAiAXp0H///8fcTYC+AEgAkEwaiIKIAYgCBA2IAJBgAFqIgsgAyAHEDYgAkHQAWoiByADIAoQNiAFIAcQMyACQZgCaiACQcACaikCADcDACACQZACaiACQbgCaikCADcDACACQYgCaiACQbACaikCADcDACACQYACaiACQagCaikCADcDACACIAIpAqACNwP4ASAFIAZBAhBMIAJBqAFqIgogByAFEDYgAkHYAGoiDCALIAoQNiAFIAwQUCACIAIpA9ACIAIpA8gCIAIpA8ACIhdCGoh8IhtCGYh8IhinQf///x9xNgKQAiACIAIpA7ACIAIpA6gCIAIpA6ACIhxCGoh8IhpCGYh8IhmnQf///x9xNgKAAiACIAIpA9gCIBhCGoh8IhinQf///w9xNgKUAiACIAIpA7gCIBlCGoh8IhmnQf///w9xNgKEAiACIAIpA+ACIBhCGYh8IhinQf///x9xNgKYAiACIBtC////D4MgF0L///8fgyAZQhmIfCIXQhqIfD4CjAIgAiAXp0H///8fcTYCiAIgAiACKQPoAiAYQhqIfCIXp0H///8PcTYCnAIgAiAaQv///w+DIBdCGYhCE34gHEL///8fg3wiF0IaiHw+AvwBIAIgF6dB////H3E2AvgBIAcgCCAGEDYgBiAHEEUgBSADEEVBACEFQQEhBgNAIAJB+AFqIgcgBWotAAAgAkGgAmoiCCAFai0AAEYQ5wIgBnEhBiAFQQFqIgVBIEcNAAsgBhDnAiEVIAJB8P///wMgAygCGGutQfD///8BIAMoAhRrrUHw////AyADKAIQa60iF0IaiHwiG0IZiHwiGKdB////H3EiCjYCuAIgAkHw////AyADKAIIa61B8P///wEgAygCBGutQdD9//8DIAMoAgBrrSIcQhqIfCIaQhmIfCIZp0H///8fcSILNgKoAiACQfD///8BIAMoAhxrrSAYQhqIfCIYp0H///8PcSIMNgK8AiACQfD///8BIAMoAgxrrSAZQhqIfCIZp0H///8PcSINNgKsAiACQfD///8DIAMoAiBrrSAYQhmIfCIYp0H///8fcSIONgLAAiACIBdC////H4MgGUIZiHwiF6dB////H3EiDzYCsAIgAiAbQv///w+DIBdCGoh8pyIQNgK0AiACQfD///8BIAMoAiRrrSAYQhqIfCIXp0H///8PcSITNgLEAiACIBdCGYhCE34gHEL///8fg3wiF6dB////H3EiETYCoAIgAiAaQv///w+DIBdCGoh8pyISNgKkAiACQagBaiACQdABahBFIAcgCBBFQQAhBUEBIQYDQCACQagBaiIHIAVqLQAAIAJB+AFqIgMgBWotAABGEOcCIAZxIQYgBUEBaiIFQSBHDQALIAYQ5wIhFCACIBM2AsQCIAIgDjYCwAIgAiAMNgK8AiACIAo2ArgCIAIgEDYCtAIgAiAPNgKwAiACIA02AqwCIAIgCzYCqAIgAiASNgKkAiACIBE2AqACIAMgAkGgAmpB+OPAABA2IAJBgAFqIAJB0AFqEEUgByADEEVBACEFQQEhBgNAIAJBgAFqIAVqLQAAIAJBqAFqIAVqLQAARhDnAiAGcSEGIAVBAWoiBUEgRw0ACyAGEOcCIQMgAkGgAmpB+OPAACACQdgAaiIWEDYgAkHgAGoiBUEAIAMgFHIQ5wJB/wFxayIDIAUoAgAiBiACKAKoAnNxIAZzIgY2AgAgAkHoAGoiByAHKAIAIgggAigCsAJzIANxIAhzIgg2AgAgAkHwAGoiCiAKKAIAIgsgAigCuAJzIANxIAtzIgs2AgAgAiACKAJkIgwgAigCrAJzIANxIAxzIgw2AmQgAiACKAJcIg0gAigCpAJzIANxIA1zIg02AlwgAiACKAJYIg4gAigCoAJzIANxIA5zIg42AlggAiACKAJsIg8gAigCtAJzIANxIA9zIg82AmwgAiACKAJ0IhAgAigCvAJzIANxIBBzIhA2AnQgAkH4AGoiEyATKAIAIhEgAigCwAJzIANxIBFzIhE2AgAgAiADIAIoAnwiEiACKALEAnNxIBJzIhI2AnwgAkH4AWogFhBFIBNBACACLQD4AUEBcRDnAkH/AXFrIgNB8P///wMgEWutQfD///8BIBBrrUHw////AyALa61B8P///wEgD2utQfD///8DIAhrrSIXQhqIfCIbQhmIfCIYQhqIfCIcQhmIfCIap0H///8fcSARc3EgEXM2AgAgCiAYp0H///8fcSALcyADcSALczYCACAHIBdC////H4NB8P///wEgDGutQfD///8DIAZrrUHw////ASANa61B0P3//wMgDmutIhdCGoh8IhhCGYh8IhlCGoh8Ih1CGYh8Ih6nQf///x9xIAhzIANxIAhzNgIAIAUgGadB////H3EgBnMgA3EgBnM2AgAgAkHw////ASASa60gGkIaiHwiGqdB////D3EgEnMgA3EgEnM2AnwgAiAcp0H///8PcSAQcyADcSAQczYCdCACIA8gG0L///8PgyAeQhqIfKdzIANxIA9zNgJsIAIgHadB////D3EgDHMgA3EgDHM2AmQgAiAaQhmIQhN+IBdC////H4N8IhenQf///x9xIA5zIANxIA5zNgJYIAIgDSAYQv///w+DIBdCGoh8p3MgA3EgDXM2AlwgCSAUIBVyEOcCOgAAIAkgAikCWDcCBCAJQQxqIAUpAgA3AgAgCUEUaiAHKQIANwIAIAlBHGogCikCADcCACAJQSRqIBMpAgA3AgAgAkHwAmokACAEQeAAaiIDIARBgANqKQIANwMAIARB6ABqIgIgBEGIA2opAgA3AwAgBEHwAGoiBSAEQZADaikCADcDACAEQfgAaiIGIARBmANqKQIANwMAIARBiAFqIgkgBEGwAWopAgA3AwAgBEGQAWoiByAEQbgBaikCADcDACAEQZgBaiIIIARBwAFqKQIANwMAIARBoAFqIgogBEHIAWopAgA3AwAgBCAEKQL4AjcDWCAEIAQpAqgBNwOAASAELQD0AiELIARBKGogBikDADcDACAEQSBqIAUpAwA3AwAgBEEYaiACKQMANwMAIARBEGogAykDADcDACAEIAQpA1g3AwggBEHQAGogCikDADcDACAEQcgAaiAIKQMANwMAIARBQGsgBykDADcDACAEQThqIAkpAwA3AwAgBCAEKQOAATcDMCAAIAsEfyMAQTBrIgMkACABLQAfQQd2EOcCIQIgA0EIaiAEQQhqIgEQkAEgAUEAIAJB/wFxayICIAEoAgAiBSADKAIIc3EgBXM2AgAgASABKAIEIgUgAygCDHMgAnEgBXM2AgQgAUEIaiIFIAUoAgAiBiADKAIQcyACcSAGczYCACABIAEoAgwiBiADKAIUcyACcSAGczYCDCABQRBqIgYgBigCACIJIAMoAhhzIAJxIAlzNgIAIAEgASgCFCIJIAMoAhxzIAJxIAlzNgIUIAFBGGoiCSAJKAIAIgcgAygCIHMgAnEgB3M2AgAgASABKAIcIgcgAygCJHMgAnEgB3M2AhwgAUEgaiIHIAcoAgAiCCADKAIocyACcSAIczYCACABIAIgASgCJCIIIAMoAixzcSAIczYCJCAAQQRqIgBBIGogBykCADcCACAAQRhqIAkpAgA3AgAgAEEQaiAGKQIANwIAIABBCGogBSkCADcCACAAIAEpAgA3AgAgAEH4AGogASAE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EGoiDSAHNgIAIAIgAzYCHCACQRhqIgcgETYCACACIA42AiQgAkEgaiIDIA82AgAgAiALNgIsIAJBKGoiCyAWNgIAIAIgDDYCNCACQTBqIgwgFzYCACACIAk2AjwgAkE4aiIJIAo2AgAgAiAjNwMAIARBEGogEykDADcDACAEQRhqIA0pAwA3AwAgBEEgaiAHKQMANwMAIARBKGogAykDADcDACAEQTBqIAspAwA3AwAgBEE4aiAMKQMANwMAIARBQGsgCSkDADcDACAEICM3AwggBkEFRg0JIARBBTYCTCAGQfv///8AakH/////AHFBBWogBEHMAGpBwLTAABDgASEGIAJCAzcDACACIAY2AgggASgCECIGBEAgASgCFCAGQQEQ+gILIAEoAhwiBgRAIAEoAiAgBkEBEPoCCyABKAI0IgZBgICAgHhGIAZFckUEQCABKAI4IAZBARD6AgsgASgCKCIGBEAgASgCLCAGQQEQ+gILDAkLQQJB7LPAAEH0s8AAEOABCyEBIAJCAzcDACACIAE2AggMBAtBA0Hss8AAQfSzwAAQ4AEhCgsgAkIDNwMAIAIgCjYCCAwCC0EEQeyzwABB9LPAABDgAQshASACQgM3AwAgAiABNgIIIAxBgICAgHhyQYCAgIB4Rg0AIAogDEEBEPoCCyADRQ0AIA8gA0EBEPoCCyAHRQ0BIA0gB0EBEPoCDAELAkACQAJAAn8CfwJAIAUoAggiAUUEQEGBgICAeCENQYCAgIB4IQoMAQsgAUEFdCEgIAUoAgQhIUGBgICAeCENQYCAgIB4IQpBgICAgHghDEIDISMDQCABIQYCQAJAAkACQAJAAkACQAJAQRUgDyAhaiIDKAIAIg5BgICAgHhzIA5BAE4bQQFrDg8BAAACAAAAAAAAAAMEBQYACyADIARBzABqQYizwAAQwgIhDiAEQQE6AAggBCAONgIMDAYLIARBADoACCAEQQUgA0EEai0AACIOIA5BBU8bOgAJDAULIARBADoACCAEQgUgA0EIaikDACIkICRCBVobPAAJDAQLIARBCGogA0EIaigCACADQQxqKAIAEOQBDAMLIARBCGogA0EEaigCACADQQhqKAIAEOQBDAILIARBCGogA0EIaigCACADQQxqKAIAEHYMAQsgBEEIaiADQQRqKAIAIANBCGooAgAQdgsCQAJA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/////wFxIAZB/////wFxIAVB/////wFxIAJB/////wFxIAxB7afX5wFxIARB/////wFxaiICQR12aiANQdKxzARxaiIDQR12aiAOQZbrnO8BcWoiBEEddmogD0HF+s7vAXFqIgVBHXZqIBBBzQJxaiIGQR12aiIHQR12aiIIQR12aiIJQf////8BcTYCHCAAIAhB/////wFxNgIYIAAgB0H/////AXE2AhQgACAGQf////8BcTYCECAAIAVB/////wFxNgIMIAAgBEH/////AXE2AgggACADQf////8BcTYCBCAAIAJB/////wFxNgIAIAAgCUEddiALaiABQYCAwABxakH/////AXE2AiAL0QQBCn8jAEEwayIGJAACQCABQcABcSIKRQ0AIAZBCGogADYCACAKQcAARgRAQQEhBwwBCyAGIABBQGs2AgwgCkGAAUYEQEECIQcMAQsgBiAAQYABajYCEEGs28AAQSsgBkEQakGM3MAAQbjYwAAQ5gEACyAFQQV2IgkgByAHIAlLGyIIBEAgBkEIaiEJIANBBHIhCyAIQQV0IQxBACEDA0AgCSgCACEIIAZBKGoiDSACQRhqKQIANwMAIAZBIGoiDiACQRBqKQIANwMAIAZBGGoiDyACQQhqKQIANwMAIAYgAikCADcDECAGQRBqIAhBwABCACALECIgAyAEaiIIQRhqIA0pAwA3AAAgCEEQaiAOKQMANwAAIAhBCGogDykDADcAACAIIAYpAxA3AAAgCUEEaiEJIAwgA0EgaiIDRw0ACwsCQAJAAkAgAUE/cSICBEAgBSAHQQV0IgFJDQEgBSABayIDQR9NDQIgAkEgRw0DIAEgBGoiASAAIApqIgApAAA3AAAgAUEYaiAAQRhqKQAANwAAIAFBEGogAEEQaikAADcAACABQQhqIABBCGopAAA3AAAgB0EBaiEHCyAGQTBqJAAgBw8LIAEgBSAFQajYwAAQmAIAC0EAQSAgA0GI2MAAEJgCAAsjAEEwayIAJAAgAEEgNgIEIAAgAjYCACAAQQM2AgwgAEGE0sQANgIIIABCAjcCFCAAIABBBGqtQoCAgIDgCIQ3AyggACAArUKAgICA4AiENwMgIAAgAEEgajYCECAAQQhqQZjYwAAQvwIAC4cEAQV/IAAoAggiBCAAKAIARgRAIAAgBEEBQQFBARDJASAA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IAAoAjRBAEGAgIAIIAIbaiABKAAMQQh2aq0iCCAAKAIcIgJBBWytIgl+fCAAKAIwIAEoAAlBBnZqrSIKIAAoAiAiAUEFbK0iBH58IAMgB34gBSALfnwgBCAGfnwgCCARQQVsrSIMfnwgCSAKfnwgAyAEfiAFIAd+fCAGIAl+fCAIIBBBBWytfnwgCiAMfnwiCUIaiEL/////D4N8IgxCGohC/////w+DfCIOp0H///8fcTYCLCAAIAMgDX4gBSACrSIPfnwgBiALfnwgBCAIfnwgByAKfnwgDkIaiEL/////D4N8IgSnQf///x9xNgIwIAAgAyAPfiAFIAGtfnwgBiANfnwgByAIfnwgCiALfnwgBEIaiEL/////D4N8IgOnQf///x9xNgI0IAAgA0IaiKdBBWwgCadB////H3FqIgFB////H3E2AiQgACAMp0H///8fcSABQRp2ajYCKAvlAwIYfgF/IAExAAghCCABMQAHIQkgATEACSECIAExAAshCiABMQAKIQsgATEAFSEMIAExABQhDSABMQAWIQMgATEAGCEOIAExABchDyABMQAZIQQgATEAGyEQIAExABohESABMQAGIQUgATEABSESIAExAAQhEyABMQAPIRQgATEADiEVIAExAA0hFiABMQAMIQYgATEAHyEXIAExAB4hGCABMQAdIRkgATEAHCEHIAEoAAAhGiAAIAEoABAiAUH///8PcTYCFCAAIBpB////H3E2AgAgACAXQhKGQoCA8A+DIBlCAoYgB0IGiIQgGEIKhoSEPgIkIAAgFkIChiAGQgaIhCAVQgqGhCAUQhKGhD4CECAAIAVCFoZCgICADoMgGkEadq0gE0IGhoQgEkIOhoSEPgIEIAAgEEIMhiARQgSGhCAEQgSIhCAHQhSGhKdB////H3E2AiAgACAOQg2GIA9CBYaEIANCA4iEIARCFYaEp0H///8PcTYCHCAAIAFBGXatIAxCD4YgDUIHhoSEIANCF4aEp0H///8fcTYCGCAAIApCC4YgC0IDhoQgAkIFiIQgBkIThoSnQf///w9xNgIMIAAgCEINhiAJQgWGhCAFQgOIhCACQhWGhKdB////H3E2AggLqyQCE38CfiMAQTBrIhAkAAJAAkACQAJ/IAEoAgAiDQRAIAIoAgghCyACKAIEIQkgASgCBCEFAkADQCANQYwCaiEGIA0vAZIDIgxBDGwhB0F/IQQCQANAIAdFBEAgDCEEDAILIAZBCGohCCAGQQRqIQ8gBEEBaiEEIAdBDGshByAGQQxqIQYgCSAPKAIAIAsgCCgCACIIIAggC0sbEIMCIg8gCyAIayAPGyIIQQBKIAhBAEhrQf8BcSIIQQFGDQALIAhFDQILIAUEQCAFQQFrIQUgDSAEQQJ0aigCmAMhDQwBCwsgECAENgIoIBBBADYCJCACKQIEIRcgECkCJCEYIAIoAgAMAgsgECAFNgIkIBAgDTYCICAQKQMgIRcgAigCACIBRQ0CIAkgAUEBEPoCDAILIAIpAgQhF0EAIQ0gAigCAAsiAkGAgICAeEcNASABIQQLIAAgF6cgBEEYbGoiASkDADcDACABIAMpAwA3AwAgAEEQaiABQRBqIgIpAwA3AwAgAEEIaiABQQhqIgApAwA3AwAgACADQQhqKQMANwMAIAIgA0EQaikDADcDAAwBCyAQIBg3AhggECANNgIUIBAgATYCECAQIBc3AgggECACNgIEIwBBMGsiDyQAAkACQAJ/IBBBBGoiEygCEARAIA9BGGogE0EQaiIBQQhqKAIANgIAIA8gASkCADcDECAPQShqIBNBCGooAgA2AgAgDyATKQIANwMgIA9BBGohESAPQSBqIQcgAyENIBNBDGohFCMAQYABayIGJAACQAJAAkACQAJAAn8CQAJAAn8CQAJAAkACQCAPQRBqIgMoAgAiBC8BkgMiAkELTwRAIAMoAgQhAiADKAIIIQtBmANBCBCBAyIBRQ0GIAFBADsBkgMgAUEANgKIAiALQQVJDQEgC0EFaw4CAwQCCyAEQYwCaiIFIAMoAggiC0EMbGohAQJAIAIgC0EBaiIMSQRAIAEgBykCADcCACABQQhqIAdBCGooAgA2AgAMAQsgAiALayIJQQxsIggEQCAFIAxBDGxqIAEgCPwKAAALIAFBCGogB0EIaigCADYCACABIAcpAgA3AgAgCUEYbCIBRQ0AIAQgDEEYbGogBCALQRhsaiAB/AoAAAsgBCALQRhsaiIBQRBqIA1BEGopAwA3AwAgASANKQMANwMAIAFBCGogDUEIaikDADcDACAEIAJBAWo7AZIDIAMoAgQhDAwICyABIAQvAZIDQQVrIgg7AZIDIAhBDEkEQEEEIQVB+AAhDEHIAiEOQbwCIQlBwAIhA0HgACEKDAYLDAkLIAEgBC8BkgNBB2siBTsBkgMgBUEMTw0JIAtBB2shCyAEQdQCaiEJIARB2AJqIQogBEGQAWohCEGoASEOQeACIQxBBgwCCyABIAQvAZIDQQZrIgg7AZIDIAhBDEkEQEEFIQVBkAEhDEHUAiEOQcgCIQlBzAIhA0H4ACEKDAQLDAcLIAEgBC8BkgNBBmsiBTsBkgMgBUEMTw0HIARByAJqIQkgBEHMAmohCiAEQfgAaiEIQQAhC0GQASEOQdQCIQxBBQshAyABQYwCaiESIAkoAgAhCSAKKQIAIRcgBUEMbCIKBEAgEiAEIAxqIAr8CgAACyAFQRhsIgwEQCABIAQgDmogDPwKAAALIAQgAzsBkgMgBkHUAGogCEEIaikCADcCACAGQdwAaiAIQRBqKQIANwIAIAYgCCkCADcCTCASIAtBDGxqIQMCQCALIAEvAZIDIgxPBEAgAyAHKQIANwIAIANBCGogB0EIaigCADYCAAwBCyAMIAtrIgVBDGwiCARAIAtBDGwgEmpBDGogAyAI/AoAAAsgA0EIaiAHQQhqKAIANgIAIAMgBykCADcCACAFQRhsIgNFDQAgASALQRhsaiIFQRhqIAUgA/wKAAALIAEgC0EYbGoiA0EQaiANQRBqKQMANwMAIAMgDSkDADcDACADQQhqIA1BCGopAwA3AwAgASAMQQFqOwGSA0EAIQwgAQwCC0EIQZgDEJoDAAsgBCAJaigCACEJIAMgBGopAgAhFyAIQQxsIgMEQCABQYwCaiAEIA5qIAP8CgAACyAIQRhsIgMEQCABIAQgDGogA/wKAAALIAQgBTsBkgMgBkHUAGogBCAKaiIDQQhqKQIANwIAIAZB3ABqIANBEGopAgA3AgAgBiADKQIANwJMIARBjAJqIgwgC0EMbGohAwJAIAUgC00EQCADIAcpAgA3AgAgA0EIaiAHQQhqKAIANgIADAELIAUgC2siCEEMbCIKBEAgC0EMbCAMakEMaiADIAr8CgAACyADQQhqIAdBCGooAgA2AgAgAyAHKQIANwIAIAhBGGwiA0UNACAEIAtBGGxqIgxBGGogDCAD/AoAAAsgBCALQRhsaiIDQRBqIA1BEGopAwA3AwAgAyANKQMANwMAIANBCGogDUEIaikDADcDACAEIAVBAWo7AZIDIAIhDCAECyENIAZBGGoiAyAGQeAAaigCADYCACAGQRBqIgUgBkHYAGopAgA3AwAgBkEIaiIHIAZB0ABqKQIANwMAIAYgBikCSDcDACAJQYCAgIB4RgRAIA0hBAwBCyAGQThqIAMoAgA2AgAgBkEwaiAFKQMANwMAIAZBKGogBykDADcDACAGIAYpAwA3AyACQCAEKAKIAiIFRQRAQQAhCgwBCyAGQdQAaiEIIAZBIGpBBHIhB0EAIQogASEDA0ACQAJAIAIgCkYEQCAELwGQAyEBAkACQAJAIAUvAZIDIgpBC08EQCACQQFqIQ5BBCECIAFBBUkNAUEAIQRBBSEKIAEhAiABQQVrDgIBAwILIAVBjAJqIg4gAUEMbGohAiABQQFqIQQgCkEBaiESAkAgASAKTwRAIAIgFzcCBCACIAk2AgAgBSABQRhsaiICIAcpAgA3AgAgAkEQaiAHQRBqKQIANwIAIAJBCGogB0EIaikCADcCAAwBCyAKIAFrIghBDGwiFARAIA4gBEEMbGogAiAU/AoAAAsgAiAXNwIEIAIgCTYCACAFIAFBGGxqIQIgCEEYbCIJBEAgBSAEQRhsaiACIAn8CgAACyACQRBqIAdBEGopAgA3AgAgAkEIaiAHQQhqKQIANwIAIAIgBykCADcCACAIQQJ0IgJFDQAgBUGYA2oiByABQQJ0akEIaiAHIARBAnRqIAL8CgAACyAFIBI7AZIDIAUgBEECdGogAzYCmAMgBCAKQQJqIgNPDQUgCiABayIHQQFqQQNxIgIEQCAFIAFBAnRqQZwDaiEBA0AgASgCACIJIAQ7AZADIAkgBTYCiAIgAUEEaiEBIARBAWohBCACQQFrIgINAAsLIAdBA0kNBSAEQQJ0IAVqQaQDaiEBA0AgAUEMaygCACICIAQ7AZADIAIgBTYCiAIgAUEIaygCACICIARBAWo7AZADIAIgBTYCiAIgAUEEaygCACICIARBAmo7AZADIAIgBTYCiAIgASgCACICIARBA2o7AZADIAIgBTYCiAIgAUEQaiEBIAMgBEEEaiIERw0ACwwFCyAGIAI2AkQgBiAONgJAIAYgBTYCPCAGQcgAaiAGQTxqEFUgBigCcCIEQYwCaiISIAFBDGxqIQIgAUEBaiEFIAQvAZIDIgpBAWohFQJAIAEgCk8EQCACIBc3AgQgAiAJNgIAIAQgAUEYbGoiAiAHKQIANwIAIAJBEGogB0EQaikCADcCACACQQhqIAdBCGopAgA3AgAMAQsgCiABayIOQQxsIhYEQCASIAVBDGxqIAIgFvwKAAALIAIgFzcCBCACIAk2AgAgBCABQRhsaiECIA5BGGwiCQRAIAQgBUEYbGogAiAJ/AoAAAsgAkEQaiAHQRBqKQIANwIAIAJBCGogB0EIaikCADcCACACIAcpAgA3AgAgDkECdCICRQ0AIARBmANqIgkgAUECdGpBCGogCSAFQQJ0aiAC/AoAAAsgBCAVOwGSAyAEIAVBAnRqIAM2ApgDAkAgBSAKQQJqIgNPDQAgCiABayIJQQFqQQNxIgIEQCAEIAFBAnRqQZwDaiEBA0AgASgCACIKIAU7AZADIAogBDYCiAIgAUEEaiEBIAVBAWohBSACQQFrIgINAAsLIAlBA0kNACAEIAVBAnRqQaQDaiEBA0AgAUEMaygCACICIAU7AZADIAIgBDYCiAIgAUEIaygCACICIAVBAWo7AZADIAIgBDYCiAIgAUEEaygCACICIAVBAmo7AZADIAIgBDYCiAIgASgCACICIAVBA2o7AZADIAIgBDYCiAIgAUEQaiEBIAMgBUEEaiIFRw0ACwsgBkEIaiAIQQhqKQIANwMAIAZBEGogCEEQaikCADcDACAGQRhqIAhBGGooAgA2AgAgBiAIKQIANwMAIAYoAnghASAGKAJ0IQIMAwsgAUEHayEEQQYhCgsgBiAKNgJEIAYgDjYCQCAGIAU2AjwgBkHIAGogBkE8ahBVIAYoAngiAUGMAmoiEiAEQQxsaiECIARBAWohBSABLwGSAyIKQQFqIRUCQCAEIApPBEAgAiAXNwIEIAIgCTYCACABIARBGGxqIgIgBykCADcCACACQRBqIAdBEGopAgA3AgAgAkEIaiAHQQhqKQIANwIADAELIAogBGsiDkEMbCIWBEAgEiAFQQxsaiACIBb8CgAACyACIBc3AgQgAiAJNgIAIAEgBEEYbGohAiAOQRhsIgkEQCABIAVBGGxqIAIgCfwKAAALIAJBEGogB0EQaikCADcCACACQQhqIAdBCGopAgA3AgAgAiAHKQIANwIAIA5BAnQiAkUNACABQZgDaiIJIARBAnRqQQhqIAkgBUECdGogAvwKAAALIAEgFTsBkgMgASAFQQJ0aiADNgKYAwJAIAUgCkECaiIDTw0AIAogBGsiCUEBakEDcSICBEAgASAEQQJ0akGcA2ohBANAIAQoAgAiCiAFOwGQAyAKIAE2AogCIARBBGohBCAFQQFqIQUgAkEBayICDQALCyAJQQNJDQAgASAFQQJ0akGkA2ohBANAIARBDGsoAgAiAiAFOwGQAyACIAE2AogCIARBCGsoAgAiAiAFQQFqOwGQAyACIAE2AogCIARBBGsoAgAiAiAFQQJqOwGQAyACIAE2AogCIAQoAgAiAiAFQQNqOwGQAyACIAE2AogCIARBEGohBCADIAVBBGoiBUcNAAsLIAZBCGogCEEIaikCADcDACAGQRBqIAhBEGopAgA3AwAgBkEYaiAIQRhqKAIANgIAIAYgCCkCADcDACAGKAJ0IQIgBigCcCEEDAELQYi2wABBNUHAtsAAEJkCAAsgBikCTCEXIAYoAkgiCUGAgICAeEYNACAGKAJ8IQogBkE4aiAGQRhqKAIANgIAIAZBMGogBkEQaikDADcDACAGQShqIAZBCGopAwA3AwAgBiAGKQMANwMgIAEhAyAEKAKIAiIFDQEMAgsLIBEgCzYCCCARIAw2AgQgESANNgIADAILAkACQAJAIBQoAgAiAygCACIEBEAgAygCBCEFQcgDQQgQgQMiAkUNAiACIAQ2ApgDIAJBADsBkgMgAkEANgKIAiAFQQFqIgdFDQMgBEEAOwGQAyAEIAI2AogCIAMgBzYCBCADIAI2AgAgBSAKRg0BQeC0wABBMEGQtcAAEJkCAAtB0LTAABD8AgALIAIgFzcDkAIgAiAJNgKMAiACQQE7AZIDIAIgBikCJDcCACACIAE2ApwDIAJBCGogBkEsaikCADcCACACQRBqIAZBNGopAgA3AgAgAUEBOwGQAyABIAI2AogCIBEgDTYCACARIAw2AgQgESALNgIIDAMLQQhByAMQmgMAC0GgtcAAEPwCAAsgESALNgIIIBEgDDYCBCARIAQ2AgALIAZBgAFqJAAMAgtBACAIQQtB6LXAABCYAgALQQAgBUELQei1wAAQmAIACyATKAIMIQIgDygCBBogDygCDAwBCyATKAIMIQJBmANBCBCBAyIBRQ0BIAFBADYCiAIgAkEANgIEIAIgATYCACABQQE7AZIDIAEgAykDADcDACABQQhqIANBCGopAwA3AwAgAUEQaiADQRBqKQMANwMAIAFBlAJqIBNBCGooAgA2AgAgASATKQIANwKMAkEACxogAiACKAIIQQFqNgIIIA9BMGokAAwBC0EIQZgDEJoDAAsgAEEGOgAACyAQQTBqJAALqwgCDn8BfiMAQTBrIgQkACABQQxqIQYCQAJAIAEoAhQiAyABKAIQIgVJBEAgASADQQFqIgc2AhQgAyABKAIMIglqLQAAIgNBMEYEQAJAIAUgB0sEQCAHIAlqLQAAQTBrQf8BcUEKSQ0BCyAAIAEgAkIAEEgMBAsgBEENNgIgIARBCGogBhCAAiAEQSBqIAQoAgggBCgCDBCSAiEBIABCAzcDACAAIAE2AggMAwsgA0Exa0H/AXFBCU8EQCAEQQ02AiAgBEEQaiAGEJYCIARBIGogBCgCECAEKAIUEJICIQEgAEIDNwMAIAAgATYCCAwDCyADQTBrrUL/AYMhEQJAIAUgB00NAANAIAcgCWotAABBMGsiBkH/AXEiA0EKTw0BIANBBUsgEUKZs+bMmbPmzBlSciARQpmz5syZs+bMGVpxDQMgASAHQQFqIgc2AhQgEUIKfiAGrUL/AYN8IREgBSAHRw0ACwsgACABIAIgERBIDAILIARBBTYCICAEQRhqIAYQlgIgBEEgaiAEKAIYIAQoAhwQkgIhASAAQgM3AwAgACABNgIIDAELIARBIGohBiACIQdBACECAkACQAJAIAEoAhAiBSABKAIUIgNNDQAgA0EBaiEJIAUgA2shBSABKAIMIANqIQgDQCACIAhqLQAAIgNBMGtB/wFxQQpPBEAgA0EuRg0DIANBxQBHIANB5QBHcQ0CIAYgASAHIBEgAhB4DAQLIAEgAiAJajYCFCAFIAJBAWoiAkcNAAsgBSECCyAGIAEgByARIAIQoQEMAQsjAEEgayIFJAAgASABKAIUIghBAWoiCjYCFAJAIAEoAhAiAyAKSwRAIAhBAmohCSABKAIMIgwgCmohCyAIIANrQQFqIQ1BACEIAkADQCALLQAAIg5BMGsiD0H/AXEiEEEKTwRAIAhFBEAgBUENNgIUIAUgDCADIAkgAyADIAlLGxBeIAVBFGogBSgCACAFKAIEEJICIQEgBkEBNgIAIAYgATYCBAwFCyACIAhqIQIgDkEgckHlAEcEQCAGIAEgByARIAIQoQEMBQsgBiABIAcgESACEHgMBAsgEEEFSyARQpmz5syZs+bMGVJyIBFCmLPmzJmz5swZVnENASABIAk2AhQgC0EBaiELIAlBAWohCSARQgp+IA+tQv8Bg3whESANIAhBAWsiCEcNAAsgBiABIAcgESACIApqIANrEKEBDAILIAYgASAHIBEgAiAIahDpAQwBCyAFQQU2AhQgBUEIaiABKAIMIAMgCEECaiIBIAMgASADSRsQXiAFQRRqIAUoAgggBSgCDBCSAiEBIAZBATYCACAGIAE2AgQLIAVBIGokAAsgBCgCIEEBRgRAIAAgBCgCJDYCCCAAQgM3AwAMAQsgACAEKwMoOQMIIABCADcDAAsgBEEwaiQAC8kDAgx/AX4gAyABKAIUIgggBUEBayINaiIHSwRAIAUgASgCECIOayEPIAEoAhwhCyABKAIIIQogASkDACETA0ACQAJAIBMgAiAHajEAAIhCAYNQBEAgASAFIAhqIgg2AhRBACEHIAYNAgwBCyAKIAsgCiAKIAtJGyAGGyIJIAUgBSAJSRshDCACIAhqIRAgCSEHAkADQCAHIAxGBEBBACALIAYbIQwgCiEHAkACQAJAA0AgByAMTQ0BIAdBAWsiByAFTw0CIAcgCGoiCSADTw0DIAQgB2otAAAgAiAJai0AAEYNAAsgASAIIA5qIgg2AhQgDyEHIAZFDQYMBwsgASAFIAhqIgI2AhQgBkUEQCABQQA2AhwLIAAgAjYCCCAAIAg2AgQgAEEBNgIADwsgByAFQZSvwAAQ8gEACyAJIANBpK/AABDyAQALIAcgCGogA08NASAHIBBqIREgBCAHaiAHQQFqIQctAAAgES0AAEYNAAsgCCAKayAHaiEIIAYNAkEAIQcMAQsgAyAIIAlqIgAgACADSRsgA0G0r8AAEPIBAAsgASAHNgIcIAchCwsgCCANaiIHIANJDQALCyABIAM2AhQgAEEANgIAC8kDAgx/AX4gAyABKAIUIgggBUEBayINaiIHSwRAIAUgASgCECIOayEPIAEoAhwhCyABKAIIIQogASkDACETA0ACQAJAIBMgAiAHajEAAIhCAYNQBEAgASAFIAhqIgg2AhRBACEHIAYNAgwBCyAKIAsgCiAKIAtJGyAGGyIJIAUgBSAJSRshDCACIAhqIRAgCSEHAkADQCAHIAxGBEBBACALIAYbIQwgCiEHAkACQAJAA0AgByAMTQ0BIAdBAWsiByAFTw0CIAcgCGoiCSADTw0DIAQgB2otAAAgAiAJai0AAEYNAAsgASAIIA5qIgg2AhQgDyEHIAZFDQYMBwsgASAFIAhqIgI2AhQgBkUEQCABQQA2AhwLIAAgAjYCCCAAIAg2AgQgAEEBNgIADwsgByAFQdjLwAAQ8gEACyAJIANB6MvAABDyAQALIAcgCGogA08NASAHIBBqIREgBCAHaiAHQQFqIQctAAAgES0AAEYNAAsgCCAKayAHaiEIIAYNAkEAIQcMAQsgAyAIIAlqIgAgACADSRsgA0H4y8AAEPIBAAsgASAHNgIcIAchCwsgCCANaiIHIANJDQALCyABIAM2AhQgAEEANgIAC9UDARh/IAEvAAQhCCABLQAGIQkgAS0AGCEKIAEtABYhCyABLQAXIQwgAS8ACCECIAEtAAchDSABLwAMIQMgAS0ACyEOIAEtAAohDyABLwAQIQQgAS0ADyEQIAEtAA4hESABLQAUIQUgAS0AFSEGIAEtABMhEiABLQASIRMgAS0AHCEHIAEtABkhFCABLQAaIRUgAS0AGyEWIAEvAAAhFyABLQACIRggAS0AAyEZIAAgAS8AHSABLQAfQRB0cjYCICAAIBlBGHQiAUGAgID4AXEgFyAYQRB0cnI2AgAgACAHQRV0IBRBCHQiByAVQRB0IBZBGHRyckELdnI2AhwgACAFIAZBCHQiBnJBD3QgE0EQdCIFIBJBGHRyQRF2ckH/////AXE2AhQgACAEIAVyQQx0IBFBEHQiBCAQQRh0ckEUdnJB/////wFxNgIQIAAgAyAEckEJdCAPQRB0IgMgDkEYdHJBF3ZyQf////8BcTYCDCAAIAIgA3JBBnQgDUEYdCICQRp2ckH/////AXE2AgggACAHIApyQRJ0IAtBEHQgDEEYdHIgBnJBDnZyQf////8BcTYCGCAAIAggCUEQdHIgAnJBA3QgAUEddnJB/////wFxNgIEC5IEAQJ/IAAgAWohAgJAAkAgACgCBCIDQQFxDQAgA0ECcUUNASAAKAIAIgMgAWohASAAIANrIgBB+OfEACgCAEYEQCACKAIEQQNxQQNHDQFB8OfEACABNgIAIAIgAigCBEF+cTYCBCAAIAFBAXI2AgQgAiABNgIADAILIAAgAxCGAQsCQAJAAkAgAigCBCIDQQJxRQRAIAJB/OfEACgCAEYNAiACQfjnxAAoAgBGDQMgAiADQXhxIgIQhgEgACABIAJqIgFBAXI2AgQgACABaiABNgIAIABB+OfEACgCAEcNAUHw58QAIAE2AgAPCyACIANBfnE2AgQgACABQQFyNgIEIAAgAWogATYCAAsgAUGAAk8EQCAAIAEQlQEPCwJAQejnxAAoAgAiAkEBIAFBA3Z0IgNxRQRAQejnxAAgAiADcjYCACABQfgBcUHg5cQAaiIBIQIMAQsgAUH4AXEiAUHg5cQAaiECIAFB6OXEAGooAgAhAQsgAiAANgIIIAEgADYCDCAAIAI2AgwgACABNgIIDwtB/OfEACAANgIAQfTnxABB9OfEACgCACABaiIBNgIAIAAgAUEBcjYCBCAAQfjnxAAoAgBHDQFB8OfEAEEANgIAQfjnxABBADYCAA8LQfjnxAAgADYCAEHw58QAQfDnxAAoAgAgAWoiATYCACAAIAFBAXI2AgQgACABaiABNgIACwuJBAACfwJAAkACQAJAAkAgAkEEaw4NAwQCAQQEBAQEBAQEAAQLIAEtAABB5QBHDQMgAS0AAUHuAEcNAyABLQACQeMARw0DIAEtAANB8gBHDQMgAS0ABEH5AEcNAyABLQAFQfAARw0DIAEtAAZB9ABHDQMgAS0AB0HlAEcNAyABLQAIQeQARw0DIAEtAAlBwwBHDQMgAS0ACkHoAEcNAyABLQALQeEARw0DIAEtAAxB7gBHDQMgAS0ADUHnAEcNAyABLQAOQeUARw0DIAEtAA9B8wBHDQNBAAwECwJAAkAgAS0AAEHrAGsOBgAEBAQEAQQLIAEtAAFB5QBHDQMgAS0AAkH5AEcNAyABLQADQdUARw0DIAEtAARB8wBHDQMgAS0ABUHlAEcNAyABLQAGQeQARw0DQQEMBAsgAS0AAUHyAEcNAiABLQACQekARw0CIAEtAANB9gBHDQIgAS0ABEHhAEcNAiABLQAFQeMARw0CIAEtAAZB+QBHDQJBBAwDCyABLQAAQe0ARw0BIAEtAAFB4QBHDQEgAS0AAkHkAEcNASABLQADQeUARw0BIAEtAARBwQBHDQEgAS0ABUH0AEcNAUECDAILIAEtAABB7QBHDQAgAS0AAUHlAEcNACABLQACQfQARw0AIAEtAANB4QBHDQBBAwwBC0EFCyEBIABBADoAACAAIAE6AAEL9AMCBH8BfiMAQZADayIFJAACQCAAAn8gAkEgRgRAIAVB6gFqIAFBAmotAAAiAjoAACAFQYcCaiABQR9qIgYtAAA6AAAgBUEKaiACOgAAIAUgAS8AACICOwHoASAFIAEpABc3AP8BIAUgAjsBCCAFIAEoAAMiAjYACyAFIAEoAAciBzYADyAFIAEoAAsiCDYAEyAFIAEpAA8iCTcAFyAFQSdqIAYtAAA6AAAgBSABKQAXNwAfIAVBzAJqIgEgBUEIahA5IAVBKGoiBiABEKICIAEQwAEgBSAJNwD3ASAFIAg2APMBIAUgBzYA7wEgBSACNgDrASABIAYgAyAEECYgBS0AzAJBAUYNAiAFQcACaiAFQYUDaikAADcDACAFQbgCaiAFQf0CaikAADcDACAFQbACaiAFQfUCaikAADcDACAFQagCaiAFQe0CaikAADcDACAFQaACaiAFQeUCaikAADcDACAFQZgCaiAFQd0CaikAADcDACAFQZACaiAFQdUCaikAADcDACAFIAUpAM0CNwOIAiAAQQFqIAVBiAJqENwBIAYQwwFBAAwBCyAAIAI2AgwgAEKAgICAgAQ3AgRBAQs6AAAgBUGQA2okAA8LIAUgBSkC0AI3AogCQaS/wABBGiAFQYgCakGUv8AAQcC/wAAQ5gEAC8gDAQd/IwBBIGsiByQAQQEhCSABIAEoAhQiBkEBaiIFNgIUAkAgBSABKAIQIghPDQACQAJAIAEoAgwgBWotAABBK2sOAwECAAILQQAhCQsgASAGQQJqIgU2AhQLAkACQCAFIAhJBEAgASAFQQFqIgY2AhQgASgCDCIKIAVqLQAAQTBrQf8BcSIFQQpPBEAgB0ENNgIUIAcgCiAIIAYQXiAHQRRqIAcoAgAgBygCBBCSAiEBIABBATYCACAAIAE2AgQMAwsgBiAITw0BA0AgBiAKai0AAEEwa0H/AXEiC0EKTw0CIAEgBkEBaiIGNgIUIAVBzJmz5gBHIAtBB0tyIAVBy5mz5gBKcUUEQCAFQQpsIAtqIQUgBiAIRw0BDAMLCyAAIAEgAiADUCAJEMcBDAILIAdBBTYCFCAHQQhqIAEoAgwgCCAFEF4gB0EUaiAHKAIIIAcoAgwQkgIhASAAQQE2AgAgACABNgIEDAELIAAgASACIAMCfyAJRQRAIAQgBWsiBkEfdUGAgICAeHMgBiAFQQBKIAQgBkpzGwwBCyAEIAVqIgZBH3VBgICAgHhzIAYgBUEASCAEIAZKcxsLEKEBCyAHQSBqJAALsgMBB38jAEEwayIEJAACQAJAAkACQCABKAIEIgIEQCABKAIAIQYgAkEDcSEFAkAgAkEESQRAQQAhAgwBCyAGQRxqIQMgAkF8cSEIQQAhAgNAIAMoAgAgA0EIaygCACADQRBrKAIAIANBGGsoAgAgAmpqamohAiADQSBqIQMgCCAHQQRqIgdHDQALCyAFBEAgB0EDdCAGakEEaiEDA0AgAygCACACaiECIANBCGohAyAFQQFrIgUNAAsLIAEoAgxFDQIgAkEPSw0BIAYoAgQNAQwDC0EAIQIgASgCDEUNAgsgAkEAIAJBAEobQQF0IQILQQAhAyACQQBOBEAgAkUNAUEBIQMgAkEBEIEDIgUNAgsgAyACENsCAAtBASEFQQAhAgsgBEEANgIMIAQgBTYCCCAEIAI2AgQgBEEgaiABQRBqKQIANwMAIARBGGogAUEIaikCADcDACAEIAEpAgA3AxAgBEEEakHYrcQAIARBEGoQYEUEQCAAIAQpAgQ3AgAgAEEIaiAEQQxqKAIANgIAIARBMGokAA8LQcSsxABB1gAgBEEvakG0rMQAQZytxAAQ5gEAC+EDAgZ+Dn8gAigCJCEJIAEoAiQhCiACKAIgIQsgASgCICEMIAIoAgwhDSABKAIMIQ4gAigCHCEPIAEoAhwhECACKAIIIREgASgCCCESIAIoAgQhEyABKAIEIRQgAigCACEVIAEoAgAhFiAAIAEoAhggAigCGGtB8P///wNqrSABKAIUIAIoAhRrQfD///8Baq0gASgCECACKAIQa0Hw////A2qtIgNCGoh8IgZCGYh8IgSnQf///x9xNgIYIAAgEiARa0Hw////A2qtIBQgE2tB8P///wFqrSAWIBVrQdD9//8Daq0iB0IaiHwiCEIZiHwiBadB////H3E2AgggACAQIA9rQfD///8Baq0gBEIaiHwiBKdB////D3E2AhwgACAOIA1rQfD///8Baq0gBUIaiHwiBadB////D3E2AgwgACAMIAtrQfD///8Daq0gBEIZiHwiBKdB////H3E2AiAgACAGQv///w+DIANC////H4MgBUIZiHwiA0IaiHw+AhQgACADp0H///8fcTYCECAAIAogCWtB8P///wFqrSAEQhqIfCIDp0H///8PcTYCJCAAIAhC////D4MgA0IZiEITfiAHQv///x+DfCIDQhqIfD4CBCAAIAOnQf///x9xNgIAC8kDAQN/IAAoAgAiASgCqAEEQCABQQA2AqgBCyABKAKcECICBEAgASgCmBAhAANAIAAoAgAiAwRAIABBBGooAgAgA0EBEPoCCyAAQQxqIQAgAkEBayICDQALCyABKAKUECIABEAgASgCmBAgAEEMbEEEEPoCCyABKAKIECIAQYCAgIB4RiAARXJFBEAgASgCjBAgAEEBEPoCCyABKALwDyIABEAgASgC9A8gAEEBEPoCCyABKAL8DyIABEAgASgCgBAgAEEBEPoCCyABQZgPaiICEJEBAkAgASgCnA8iAEUNACAAIABBA3RBD2pBeHEiA2pBCWoiAEUNACACKAIAIANrIABBCBD6AgsgAUHID2oiAhCFAQJAIAEoAswPIgBFDQAgACAAQQN0QQ9qQXhxIgNqQQlqIgBFDQAgAigCACADayAAQQgQ+gILIAEoAqgQIgIEQCABKAKkECEAA0AgACgCACIDBEAgAEEEaigCACADQQEQ+gILIABBDGohACACQQFrIgINAAsLIAEoAqAQIgAEQCABKAKkECAAQQxsQQQQ+gILAkAgAUF/Rg0AIAEgASgCBEEBayIANgIEIAANACABQfARQQgQ+gILC+cCAQV/IwBB8AFrIgIkACACQaABaiIDIAFB0ABqEDMgAkHwAGogAkHAAWopAgA3AwAgAkHoAGogAkG4AWopAgA3AwAgAkHgAGogAkGwAWopAgA3AwAgAkHYAGogAkGoAWopAgA3AwAgAiACKQKgATcDUCACQZgBaiACQegBaikCADcDACACQZABaiACQeABaikCADcDACACQYgBaiACQdgBaikCADcDACACQYABaiACQdABaikCADcDACACIAIpAsgBNwN4IAMgAkHQAGoiBkEFEEwgAkEIaiIEIAMgAkH4AGoiBRA2IAUgASAEEDYgAyABQShqIAQQNiACQTBqIAMQRSAGIAUQRSACLQBQQQFxEOcCIQEgACACKQAwNwAAIABBCGogAkE4aikAADcAACAAQRBqIAJBQGspAAA3AAAgAiACLQBPIAFBB3RzOgBPIABBGGogAkHIAGopAAA3AAAgAkHwAWokAAuWAwEEfwJAAkACQAJAAkACQCAHIAhWBEAgByAIfSAIWA0DIAYgByAGfVQgByAGQgGGfSAIQgGGWnENAiAGIAhYDQYgByAGIAh9IgZ9IAZWDQYgAiADTw0BQQAgAyACQcDExAAQmAIACyAAQQA2AgAPCyABIANqIQwgASEKAkACQAJAA0AgAyAJRg0BIAlBAWohCSAKQQFrIgogA2oiCy0AAEE5Rg0ACyALIAstAABBAWo6AAAgAyAJa0EBaiIFIANNDQEgBSADIANB/LnEABCYAgALAkAgA0UEQEExIQkMAQsgAUExOgAAQTAhCSADQQFrIgpFDQAgAUEBakEwIAr8CwALIARBAWrBIgQgBcFMIAIgA01yDQEgDCAJOgAAIANBAWohAwwBCyAJQQFrIgVFDQAgC0EBakEwIAX8CwALIAIgA0kNAgwDCyACIANPDQJBACADIAJB0MTEABCYAgALIABBADYCAA8LQQAgAyACQbDExAAQmAIACyAAIAQ7AQggACADNgIEIAAgATYCAA8LIABBADYCAAuZAwECfwJAAkACQCAALQBoIgMEQCADQcEATw0DIAJBwAAgA2siBCACIARJGyIEBEAgACADaiABIAT8CgAACyAAIAAtAGggBGoiAzoAaCABIARqIQEgAiAEayICRQRAQQAhAgwCCyAAQUBrIABBwAAgACkDYCAALQBqIAAtAGlFchAiIABCADcDACAAQQA6AGggAEEIakIANwMAIABBEGpCADcDACAAQRhqQgA3AwAgAEEgakIANwMAIABBKGpCADcDACAAQTBqQgA3AwAgAEE4akIANwMAIAAgAC0AaUEBajoAaQtBACEDIAJBwQBJDQEgAEFAayEEIAAtAGkhAwNAIAQgAUHAACAAKQNgIAAtAGogA0H/AXFFchAiIAAgAC0AaUEBaiIDOgBpIAFBQGshASACQUBqIgJBwABLDQALIAAtAGghAwsgA0H/AXEiA0HBAE8NAQsgAkHAACADayIEIAIgBEkbIgIEQCAAIANqIAEgAvwKAAALIAAgAC0AaCACajoAaCAADwsgA0HAAEHAAEGU18AAEJgCAAuVAwEHfyAAIAEoAiAiAjoAHSAAIAEoAgAiBToAACAAIAJBEHY6AB8gACACQQh2OgAeIAAgASgCHCIGQRV2OgAcIAAgBkENdjoAGyAAIAZB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KAI8ISIgBigCHCEYIAYoAkQhGSABIAYoAiQgBigCTGo2AowOIAEgFSAXajYCiA4gASAYIBlqNgKEDiABIA0gEmo2AoAOIAEgISAiajYC/A0gASAKIAxqNgL4DSABIB8gIGo2AvQNIAEgAyAHajYC8A0gASAeICVqNgLsDSABIBYgHWo2AugNIAFBkA5qIgcgBkEoaiAGEHogAUHYDmogBkHwAGoiFSkCADcCACABQdAOaiAGQegAaiIXKQIANwIAIAFByA5qIAZB4ABqIhIpAgA3AgAgAUHADmogBkHYAGoiFikCADcCACABIAYpAlA3ArgOIAFBCGoiSiIDIAZB+ABqQdDjwAAQNiABQYAPaiABQShqKQIANwIAIAFB+A5qIAFBIGopAgA3AgAgAUHwDmogAUEYaikCADcCACABQegOaiABQRBqKQIANwIAIAEgASkCCDcC4A4gAyABQegNaiIDQaAB/AoAACABQagBaiInIANBoAH8CgAAIAFByAJqIjggA0GgAfwKAAAgAUHoA2oiQSADQaAB/AoAACABQYgFaiJFIANBoAH8CgAAIAFBqAZqIkcgA0GgAfwKAAAgAUHIB2oiSyADQaAB/AoAACABQegIaiJNIANBoAH8CgAAIAFBkA1qIgogECkCADcDACABQYgNaiIMIBQpAgA3AwAgAUGADWoiDSARKQIANwMAIAFB+AxqIhEgEykCADcDACABQaANaiITIBYpAgA3AwAgAUGoDWoiFCASKQIANwMAIAFBsA1qIhIgFykCADcDACABQbgNaiIXIBUpAgA3AwAgASAGKQIoNwPwDCABIAYpAlA3A5gNIAFB6AxqIA8pAgA3AwAgAUHgDGogDikCADcDACABQdgMaiAaKQIANwMAIAFB0AxqIAkpAgA3AwAgASAGKQIANwPIDCADIAFByAxqIhoQLCABQYgKaiIdIAMgAUHgDmoiBhA2IAFBsA9qIh4gByABQbgOaiIJEDYgAUHYD2oiDiAJIAYQNiABQagLaiIlIAMgBxA2IAFB0ApqIAFB0A9qIh8pAgA3AgAgAUHICmogAUHID2oiICkCADcCACABQcAKaiABQcAPaiIhKQIANwIAIAFBuApqIAFBuA9qIiIpAgA3AgAgAUHgCmogAUHgD2oiDykCADcCACABQegKaiABQegPaiIQKQIANwIAIAFB8ApqIAFB8A9qIhUpAgA3AgAgAUH4CmogAUH4D2oiFikCADcCACABIAEpArAPNwKwCiABIAEpAtgPNwLYCiABQaALaiABQcgLaikCADcCACABQZgLaiABQcALaikCADcCACABQZALaiABQbgLaikCADcCACABQYgLaiABQbALaikCADcCACABIAEpAqgLNwKACyADIB0gShA+IBogAyAGEDYgAUGID2oiGCAHIAkQNiAeIAkgBhA2IA4gAyAHEDYgCiABQagPaiIZKQIANwIAIAwgAUGgD2oiGykCADcCACANIAFBmA9qIhwpAgA3AgAgESABQZAPaiIjKQIANwIAIBMgIikCADcCACAUICEpAgA3AgAgEiAgKQIANwIAIBcgHykCADcCACABIAEpAogPNwLwDCABIAEpArAPNwKYDSABQeANaiIkIBYpAgA3AgAgAUHYDWoiJiAVKQIANwIAIAFB0A1qIjkgECkCADcCACABQcgNaiI6IA8pAgA3AgAgASABKQLYDzcCwA0gESgCACEoIA0oAgAhKSAMKAIAISogCigCACErIAEoAsgMISwgASgC8AwhLSABKALMDCEuIAEoAvQMIS8gASgC0AwhMCABKALUDCFCIAEoAvwMIUMgASgC2AwhMSABKALcDCEyIAEoAoQNITMgASgC4AwhNCABKALkDCE1IAEoAowNITYgASgC6AwhNyABIAEoAuwMIAEoApQNajYCzAsgASArIDdqNgLICyABIDUgNmo2AsQLIAEgKiA0ajYCwAsgASAyIDNqNgK8CyABICkgMWo2ArgLIAEgQiBDajYCtAsgASAoIDBqNgKwCyABIC4gL2o2AqwLIAEgLCAtajYCqAsgAUHQC2oiKCABQfAMaiIpIBoQeiABQZgMaiIqIBcpAgA3AgAgAUGQDGoiKyASKQIANwIAIAFBiAxqIiwgFCkCADcCACABQYAMaiItIBMpAgA3AgAgASABKQKYDTcC+AsgDiABQcANaiIuQdDjwAAQNiABQcAMaiIvIBYpAgA3AgAgAUG4DGoiMCAVKQIANwIAIAFBsAxqIkIgECkCADcCACABQagMaiJDIA8pAgA3AgAgASABKQLYDzcCoAwgJyAlQaAB/AoAACADIB0gJxA+IBogAyAGEDYgGCAHIAkQNiAeIAkgBhA2IA4gAyAHEDYgCiAZKQIANwIAIAwgGykCADcCACANIBwpAgA3AgAgESAjKQIANwIAIBMgIikCADcCACAUICEpAgA3AgAgEiAgKQIANwIAIBcgHykCADcCACABIAEpAogPNwLwDCABIAEpArAPNwKYDSAkIBYpAgA3AgAgJiAVKQIANwIAIDkgECkCADcCACA6IA8pAgA3AgAgASABKQLYDzcCwA0gESgCACEnIA0oAgAhMSAMKAIAITIgCigCACEzIAEoAsgMITQgASgC8AwhNSABKALMDCE2IAEoAvQMITcgASgC0AwhOyABKALUDCE8IAEoAvwMIT0gASgC2AwhPiABKALcDCE/IAEoAoQNIUAgASgC4AwhRCABKALkDCFGIAEoAowNIUggASgC6AwhTiABIAEoAuwMIAEoApQNajYCzAsgASAzIE5qNgLICyABIEYgSGo2AsQLIAEgMiBEajYCwAsgASA/IEBqNgK8CyABIDEgPmo2ArgLIAEgPCA9ajYCtAsgASAnIDtqNgKwCyABIDYgN2o2AqwLIAEgNCA1ajYCqAsgKCApIBoQeiAqIBcpAgA3AgAgKyASKQIANwIAICwgFCkCADcCACAtIBMpAgA3AgAgASABKQKYDTcC+AsgDiAuQdDjwAAQNiAvIBYpAgA3AgAgMCAVKQIANwIAIEIgECkCADcCACBDIA8pAgA3AgAgASABKQLYDzcCoAwgOCAlQaAB/AoAACADIB0gOBA+IBogAyAGEDYgGCAHIAkQNiAeIAkgBhA2IA4gAyAHEDYgCiAZKQIANwIAIAwgGykCADcCACANIBwpAgA3AgAgESAjKQIANwIAIBMgIikCADcCACAUICEpAgA3AgAgEiAgKQIANwIAIBcgHykCADcCACABIAEpAogPNwLwDCABIAEpArAPNwKYDSAkIBYpAgA3AgAgJiAVKQIANwIAIDkgECkCADcCACA6IA8pAgA3AgAgASABKQLYDzcCwA0gESgCACEnIA0oAgAhOCAMKAIAITEgCigCACEyIAEoAsgMITMgASgC8AwhNCABKALMDCE1IAEoAvQMITYgASgC0AwhNyABKALUDCE7IAEoAvwMITwgASgC2AwhPSABKALcDCE+IAEoAoQNIT8gASgC4AwhQCABKALkDCFEIAEoAowNIUYgASgC6AwhSCABIAEoAuwMIAEoApQNajYCzAsgASAyIEhqNgLICyABIEQgRmo2AsQLIAEgMSBAajYCwAsgASA+ID9qNgK8CyABIDggPWo2ArgLIAEgOyA8ajYCtAsgASAnIDdqNgKwCyABIDUgNmo2AqwLIAEgMyA0ajYCqAsgKCApIBoQeiAqIBcpAgA3AgAgKyASKQIANwIAICwgFCkCADcCACAtIBMpAgA3AgAgASABKQKYDTcC+AsgDiAuQdDjwAAQNiAvIBYpAgA3AgAgMCAVKQIANwIAIEIgECkCADcCACBDIA8pAgA3AgAgASABKQLYDzcCoAwgQSAlQaAB/AoAACADIB0gQRA+IBogAyAGEDYgGCAHIAkQNiAeIAkgBhA2IA4gAyAHEDYgCiAZKQIANwIAIAwgGykCADcCACANIBwpAgA3AgAgESAjKQIANwIAIBMgIikCADcCACAUICEpAgA3AgAgEiAgKQIANwIAIBcgHykCADcCACABIAEpAogPNwLwDCABIAEpArAPNwKYDSAkIBYpAgA3AgAgJiAVKQIANwIAIDkgECkCADcCACA6IA8pAgA3AgAgASABKQLYDzcCwA0gESgCACEnIA0oAgAhOCAMKAIAIUEgCigCACExIAEoAsgMITIgASgC8AwhMyABKALMDCE0IAEoAvQMITUgASgC0AwhNiABKALUDCE3IAEoAvwMITsgASgC2AwhPCABKALcDCE9IAEoAoQNIT4gASgC4AwhPyABKALkDCFAIAEoAowNIUQgASgC6AwhRiABIAEoAuwMIAEoApQNajYCzAsgASAxIEZqNgLICyABIEAgRGo2AsQLIAEgPyBBajYCwAsgASA9ID5qNgK8CyABIDggPGo2ArgLIAEgNyA7ajYCtAsgASAnIDZqNgKwCyABIDQgNWo2AqwLIAEgMiAzajYCqAsgKCApIBoQeiAqIBcpAgA3AgAgKyASKQIANwIAICwgFCkCADcCACAtIBMpAgA3AgAgASABKQKYDTcC+AsgDiAuQdDjwAAQNiAvIBYpAgA3AgAgMCAVKQIANwIAIEIgECkCADcCACBDIA8pAgA3AgAgASABKQLYDzcCoAwgRSAlQaAB/AoAACADIB0gRRA+IBogAyAGEDYgGCAHIAkQNiAeIAkgBhA2IA4gAyAHEDYgCiAZKQIANwIAIAwgGykCADcCACANIBwpAgA3AgAgESAjKQIANwIAIBMgIikCADcCACAUICEpAgA3AgAgEiAgKQIANwIAIBcgHykCADcCACABIAEpAogPNwLwDCABIAEpArAPNwKYDSAkIBYpAgA3AgAgJiAVKQIANwIAIDkgECkCADcCACA6IA8pAgA3AgAgASABKQLYDzcCwA0gESgCACEnIA0oAgAhOCAMKAIAIUEgCigCACFFIAEoAsgMITEgASgC8AwhMiABKALMDCEzIAEoAvQMITQgASgC0AwhNSABKALUDCE2IAEoAvwMITcgASgC2AwhOyABKALcDCE8IAEoAoQNIT0gASgC4AwhPiABKALkDCE/IAEoAowNIUAgASgC6AwhRCABIAEoAuwMIAEoApQNajYCzAsgASBEIEVqNgLICyABID8gQGo2AsQLIAEgPiBBajYCwAsgASA8ID1qNgK8CyABIDggO2o2ArgLIAEgNiA3ajYCtAsgASAnIDVqNgKwCyABIDMgNGo2AqwLIAEgMSAyajYCqAsgKCApIBoQeiAqIBcpAgA3AgAgKyASKQIANwIAICwgFCkCADcCACAtIBMpAgA3AgAgASABKQKYDTcC+AsgDiAuQdDjwAAQNiAvIBYpAgA3AgAgMCAVKQIANwIAIEIgECkCADcCACBDIA8pAgA3AgAgASABKQLYDzcCoAwgRyAlQaAB/AoAACADIB0gRxA+IBogAyAGEDYgGCAHIAkQNiAeIAkgBhA2IA4gAyAHEDYgCiAZKQIANwIAIAwgGykCADcCACANIBwpAgA3AgAgESAjKQIANwIAIBMgIikCADcCACAUICEpAgA3AgAgEiAgKQIANwIAIBcgHykCADcCACABIAEpAogPNwLwDCABIAEpArAPNwKYDSAkIBYpAgA3AgAgJiAVKQIANwIAIDkgECkCADcCACA6IA8pAgA3AgAgASABKQLYDzcCwA0gESgCACEnIA0oAgAhOCAMKAIAIUEgCigCACFFIAEoAsgMIUcgASgC8AwhMSABKALMDCEyIAEoAvQMITMgASgC0AwhNCABKALUDCE1IAEoAvwMITYgASgC2AwhNyABKALcDCE7IAEoAoQNITwgASgC4AwhPSABKALkDCE+IAEoAowNIT8gASgC6AwhQCABIAEoAuwMIAEoApQNajYCzAsgASBAIEVqNgLICyABID4gP2o2AsQLIAEgPSBBajYCwAsgASA7IDxqNgK8CyABIDcgOGo2ArgLIAEgNSA2ajYCtAsgASAnIDRqNgKwCyABIDIgM2o2AqwLIAEgMSBHajYCqAsgKCApIBoQeiAqIBcpAgA3AgAgKyASKQIANwIAICwgFCkCADcCACAtIBMpAgA3AgAgASABKQKYDTcC+AsgDiAuQdDjwAAQNiAvIBYpAgA3AgAgMCAVKQIANwIAIEIgECkCADcCACBDIA8pAgA3AgAgASABKQLYDzcCoAwgSyAlQaAB/AoAACADIB0gSxA+IBogAyAGEDYgGCAHIAkQNiAeIAkgBhA2IA4gAyAHEDYgCiAZKQIANwIAIAwgGykCADcCACANIBwpAgA3AgAgESAjKQIANwIAIBMgIikCADcCACAUICEpAgA3AgAgEiAgKQIANwIAIBcgHykCADcCACABIAEpAogPNwLwDCABIAEpArAPNwKYDSAkIBYpAgA3AgAgJiAVKQIANwIAIDkgECkCADcCACA6IA8pAgA3AgAgASABKQLYDzcCwA0gESgCACEDIA0oAgAhBiAMKAIAIQcgCigCACEJIAEoAsgMIQogASgC8AwhDCABKALMDCENIAEoAvQMIREgASgC0AwhHSABKALUDCEeIAEoAvwMIR8gASgC2AwhICABKALcDCEhIAEoAoQNISIgASgC4AwhGCABKALkDCEZIAEoAowNIRsgASgC6AwhHCABIAEoAuwMIAEoApQNajYCzAsgASAJIBxqNgLICyABIBkgG2o2AsQLIAEgByAYajYCwAsgASAhICJqNgK8CyABIAYgIGo2ArgLIAEgHiAfajYCtAsgASADIB1qNgKwCyABIA0gEWo2AqwLIAEgCiAMajYCqAsgKCApIBoQeiAqIBcpAgA3AgAgKyASKQIANwIAICwgFCkCADcCACAtIBMpAgA3AgAgASABKQKYDTcC+AsgDiAuQdDjwAAQNiAvIBYpAgA3AgAgMCAVKQIANwIAIEIgECkCADcCACBDIA8pAgA3AgAgASABKQLYDzcCoAwgTSAlQaAB/AoAACAEQYAEaiBKQYAK/AoAACABQYAQaiQAIARBoA5qQgA3AwAgBEGYDmpCADcDACAEQZAOakIANwMAIARBiA5qQgA3AwAgBEGwDmpB+OTAACkCACJPNwMAIARBuA5qQYDlwAApAgAiUDcDACAEQcAOakGI5cAAKQIA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KAKwASEZIAMoArQBIRsgAygCuAEhHCADKAK8ASEjIAMoAsABISQgAygCxAEhJiABQfAAaiADQbgCaikCADcCACABQegAaiADQbACaikCADcCACABQeAAaiADQagCaikCADcCACABQdgAaiADQaACaikCADcCACABIAMpApgCNwJQIAEgIiAmajYCnAEgASAhICRqNgKYASABICAgI2o2ApQBIAEgHCAfajYCkAEgASAbICVqNgKMASABIBkgHmo2AogBIAEgGCAdajYChAEgASAQIBZqNgKAASABIA8gFWo2AnwgASAGIA5qNgJ4IANBwAJqJAAgBEH4DmogAUGgAfwKAAALAkACQAJAAkAgBEGAAmogAmosAAAiAUEASiABQQBIa0H/AXEOAgMBAAsgBEHYEmogBEH4DmoiAyAUEDYgBEH4E2ogEiATEDYgBEGYEGogEyAUEDYgBEG4EWogAyASEDYgCUEgaiAEQZgUaikCADcCACAJQRhqIARBkBRqKQIANwIAIAlBEGogBEGIFGopAgA3AgAgCUEIaiAEQYAUaikCADcCACAJIAQpAvgTNwIAIAcgBCkCmBA3AgAgB0EIaiAEQaAQaikCADcCACAHQRBqIARBqBBqKQIANwIAIAdBGGogBEGwEGopAgA3AgAgB0EgaiAEQbgQaikCADcCACAKQSBqIARB2BFqKQIANwIAIApBGGogBEHQEWopAgA3AgAgCkEQaiAEQcgRaikCADcCACAKQQhqIARBwBFqKQIANwIAIAogBCkCuBE3AgBBACABa8AiA0EBdiEBIANBAE4NASABQcAAQaihwQAQ8gEACyAEQdgSaiAEQfgOaiIDIBQQNiAEQfgTaiASIBMQNiAEQZgQaiATIBQQNiAEQbgRaiADIBIQNiAJQSBqIARBmBRqKQIANwIAIAlBGGogBEGQFGopAgA3AgAgCUEQaiAEQYgUaikCADcCACAJQQhqIARBgBRqKQIANwIAIAkgBCkC+BM3AgAgByAEKQKYEDcCACAHQQhqIARBoBBqKQIANwIAIAdBEGogBEGoEGopAgA3AgAgB0EYaiAEQbAQaikCADcCACAHQSBqIARBuBBqKQIANwIAIApBIGogBEHYEWopAgA3AgAgCkEYaiAEQdARaikCADcCACAKQRBqIARByBFqKQIANwIAIApBCGogBEHAEWopAgA3AgAgCiAEKQK4ETcCACABQQF2IQMgAUEASARAIANBwABBqKHBABDyAQALIARBmBBqIgEgA0H4AGxBmOXAAGpB+AD8CgAAIARBuBFqIgMgBEHYEmogARBAIARB+A5qIANBoAH8CgAADAELIARBmBBqIgYgAUH4AGxBmOXAAGpB+AD8CgAAIwBBoAJrIgEkACAEQdgSaiIDKAIAIQ4gAygCKCEPIAMoAgQhECADKAIsIRUgAygCCCEWIAMoAjAhHSADKAIMIR4gAygCNCElIAMoAhAhHyADKAI4ISAgAygCFCEhIAMoAjwhIiADKAIYIRggAygCQCEZIAMoAhwhGyADKAJEIRwgAygCICEjIAMoAkghJCABIAMoAiQgAygCTGo2AiwgASAjICRqNgIoIAEgGyAcajYCJCABIBggGWo2AiAgASAhICJqNgIcIAEgHyAgajYCGCABIB4gJWo2AhQgASAWIB1qNgIQIAEgECAVajYCDCABIA4gD2o2AgggAUEwaiIOIANBKGogAxB6IAFB2ABqIg8gAUEIaiAGQShqEDYgAUGAAWoiECAOIAYQNiABQagBaiIOIANB+ABqIAZB0ABqEDYgASADKAJQQQF0IgY2AtABIAEgAygCVEEBdCIVNgLUASABIAMoAlhBAXQiFjYC2AEgASADKAJcQQF0Ih02AtwBIAEgAygCYEEBdCIeNgLgASABIAMoAmRBAXQiJTYC5AEgASADKAJoQQF0Ih82AugBIAEgAygCbEEBdCIgNgLsASABIAMoAnBBAXQiITYC8AEgASADKAJ0QQF0IiI2AvQBIARBuBFqIgMgDyAQEHogASgCfCEPIAEoAqQBIRAgASgCgAEhGCABKAJYIRkgASgChAEhGyABKAJcIRwgASgCiAEhIyABKAJgISQgASgCjAEhJiABKAJkITkgASgCkAEhOiABKAJoISggASgClAEhKSABKAJsISogASgCmAEhKyABKAJwISwgASgCnAEhLSABKAJ0IS4gASgCoAEhLyABKAJ4ITAgAUH4AWogAUHQAWogDhB6IAMgDyAQajYCTCADIC8gMGo2AkggAyAtIC5qNgJEIAMgKyAsajYCQCADICkgKmo2AjwgAyAoIDpqNgI4IAMgJiA5ajYCNCADICMgJGo2AjAgAyAbIBxqNgIsIAMgGCAZajYCKCABKAKoASEOIAEoAqwBIQ8gASgCsAEhECABKAK0ASEYIAEoArgBIRkgASgCvAEhGyABKALAASEcIAEoAsQBISMgASgCyAEhJCABKALMASEmIANB8ABqIAFBmAJqKQIANwIAIANB6ABqIAFBkAJqKQIANwIAIANB4ABqIAFBiAJqKQIANwIAIANB2ABqIAFBgAJqKQIANwIAIAMgASkC+AE3AlAgAyAiICZqNgKcASADICEgJGo2ApgBIAMgICAjajYClAEgAyAcIB9qNgKQASADIBsgJWo2AowBIAMgGSAeajYCiAEgAyAYIB1qNgKEASADIBAgFmo2AoABIAMgDyAVajYCfCADIAYgDmo2AnggAUGgAmokACAEQfgOaiADQaAB/AoAAAsgBEHYEmoiASAEQfgOaiAUEDYgBEGYEGogEiATEDYgBEG4EWogEyAUEDYgCUEgaiAEQbgQaikCADcCACAJQRhqIARBsBBqKQIANwIAIAlBEGogBEGoEGopAgA3AgAgCUEIaiAEQaAQaikCADcCACAJIAQpApgQNwIAIAcgBCkCuBE3AgAgB0EIaiAEQcARaikCADcCACAHQRBqIARByBFqKQIANwIAIAdBGGogBEHQEWopAgA3AgAgB0EgaiAEQdgRaikCADcCACAEQYAOaiABQfgA/AoAACACBEAgAkEBayECDAELCyAIIARBgA5qIgEgFxA2IARBuBFqIBogFxA2IARB2BJqIgIgFxBQIAQpA6ATIVIgBCkDmBMhUSAEKQPwEiFTIAQpA5ATIVQgBCkD6BIhVSAEKQPgEiFWIAQpA9gSIU8gBCkDiBMhVyAEKQOAEyFYIAQpA/gSIVAgAiABIBoQNiAIQcgAaiAEQdgRaikCADcCACAIQUBrIARB0BFqKQIANwIAIAhBOGogBEHIEWopAgA3AgAgCEEwaiAEQcARaikCADcCACAIIAQpArgRNwIoIAggVyBYIFBCGoh8IlhCGYh8IlenQf///x9xNgJoIAggVSBWIE9CGoh8IlZCGYh8IlWnQf///x9xNgJYIAggVCBXQhqIfCJUp0H///8PcTYCbCAIIFMgVUIaiHwiU6dB////D3E2AlwgCCBRIFRCGYh8IlGnQf///x9xNgJwIAggWEL///8PgyBQQv///x+DIFNCGYh8IlBCGoh8PgJkIAggUKdB////H3E2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IQUDQCABIARqLQAAQS5GBEAgBCEDDAMLIAIgBEEBaiIERw0ACwtBACEFCyAHIAM2AgQgByAFNgIAIAYoAghBAUYhAwwBCyABLQAAQS5GIgMgAkEBRnINACABLQABQS5GIgMgAkECRnINACABLQACQS5GIgMgAkEDRnINACABLQADQS5GIgMgAkEERnINACABLQAEQS5GIgMgAkEFRnINACABLQAFQS5GIgMgAkEGRnINACABLQAGQS5GIQMLIAAgAyAALQAEcjoABCAAKAIAIAEgAhDpAiAGQRBqJAAL3wEBA38gAC0AAEEBRwRAIAAoAgQhBiAALQABQQFHBEAgBigCACIEKAIAIAQoAggiBUYEQCAEIAVBAUEBQQEQyQEgBCgCCCEFCyAEIAVBAWo2AgggBCgCBCAFakEsOgAACyAAQQI6AAEgBigCACABIAIQaiADKAIIIQEgAygCBCECIAYoAgAiACgCACAAKAIIIgNGBEAgACADQQFBAUEBEMkBIAAoAgghAwsgACADQQFqNgIIIAAoAgQgA2pBOjoAACAGKAIAIAIgARBqQQAPC0GkpMAAQShBzKTAABCZAgAL8gEBAn8jAEEwayICJAACQCAAKQMAQv///////////wCDQoCAgICAgID4/wBaBEAgAkEBNgIUIAJBsKDEADYCECACQgE3AhwgAiAArUKAgICAgBKENwMoIAIgAkEoajYCGCABKAIAIAEoAgQgAkEQahBgIQMMAQsgAkEAOgAMIAIgATYCCEEBIQMgAkEBNgIUIAJBsKDEADYCECACQgE3AhwgAiAArUKAgICAgBKENwMoIAIgAkEoajYCGCACQQhqQbygxAAgAkEQahBgDQAgAi0ADEUEQCABQbigxABBAhDpAg0BC0EAIQMLIAJBMGokACADC+EBAQN/IwBBkAFrIgIkACABKQOQAVAEQCACIAEQMCACQYgBaiIBIAJB2ABqKQMANwMAIAJBgAFqIgMgAkHQAGopAwA3AwAgAkH4AGoiBCACQcgAaikDADcDACACIAIpA0A3A3AgAkHwAGogAiACLQBoQgAgAi0AaUEIchAiIAAgASkDADcAGCAAIAMpAwA3ABAgACAEKQMANwAIIAAgAikDcDcAACACQZABaiQADwsgAkIANwIMIAJCgYCAgMAANwIEIAJBzNnAADYCACABQZABakGI18AAIAJBnNvAABCnAgAL5wEAIAAQwgEgAEEAOgAgIABBADoAISAAQQA6ACIgAEEAOgAjIABBADoAJCAAQQA6ACUgAEEAOgAmIABBADoAJyAAQQA6ACggAEEAOgApIABBADoAKiAAQQA6ACsgAEEAOgAsIABBADoALSAAQQA6AC4gAEEAOgAvIABBADoAMCAAQQA6ADEgAEEAOgAyIABBADoAMyAAQQA6ADQgAEEAOgA1IABBADoANiAAQQA6ADcgAEEAOgA4IABBADoAOSAAQQA6ADogAEEAOgA7IABBADoAPCAAQQA6AD0gAEEAOgA+IABBADoAPwvOAgEDfyMAQTBrIgMkACADQQxqIAEgAhBPAkACQCADKAIMQQFGBEAgAyACNgIgIAMgATYCHCADQQY6ABgjAEFAaiIBJAAgAUHguMAANgIEIAEgA0EvajYCACABQShqIANBGGoiAkEIaikDADcDACABIAIpAwA3AyAgAUECNgIMIAFBmLjDADYCCCABQgI3AhQgASABrUKAgICAgBCENwM4IAEgAUEgaq1CgICAgJAQhDcDMCABIAFBMGo2AhAgAUEIahCyASECIAFBQGskACAAQYCAgIB4NgIAIAAgAjYCBAwBC0EAIQEgAygCFCICQQBIDQEgAygCECEFAkAgAkUEQEEBIQQMAQtBASEBIAJBARCBAyIERQ0CCyACBEAgBCAFIAL8CgAACyAAIAI2AgggACAENgIEIAAgAjYCAAsgA0EwaiQADwsgASACENsCAAviAQAgAEEAOgAAIABBADoAASAAQQA6AAIgAEEAOgADIABBADoABCAAQQA6AAUgAEEAOgAGIABBADoAByAAQQA6AAggAEEAOgAJIABBADoACiAAQQA6AAsgAEEAOgAMIABBADoADSAAQQA6AA4gAEEAOgAPIABBADoAECAAQQA6ABEgAEEAOgASIABBADoAEyAAQQA6ABQgAEEAOgAVIABBADoAFiAAQQA6ABcgAEEAOgAYIABBADoAGSAAQQA6ABogAEEAOgAbIABBADoAHCAAQQA6AB0gAEEAOgAeIABBADoAHwuCAgAgAEEAOgDAASAAQQA6AMEBIABBADoAwgEgAEEAOgDDASAAQQA6AMQBIABBADoAxQEgAEEAOgDGASAAQQA6AMcBIABBADoAyAEgAEEAOgDJASAA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aikAADcDACAUQTBqIAFBEGopAAA3AwAgFEEoaiABQQhqKQAANwMAIBQgASkAADcDICMAQSBrIi0kACAUQSBqIgEgAS0AH0E/cUHAAHI6AB8gASABLQAAQfgBcToAACAtQQhqIAFBCGopAAA3AwAgLUEQaiABQRBqKQAANwMAIC1BGGogAUEYaikAADcDACAtIAEpAAA3AwAgACECQQAhASMAQaADayIDJAAgA0EIaiAUEG8gA0HQAGpB2JHDACkCACI3NwMAIANByABqQdCRwwApAgAiOTcDACADQUBrQciRwwApAgAiODcDACADQThqQcCRwwApAgAiOjcDACADQeAAakIANwMAIANB6ABqQgA3AwAgA0HwAGpCADcDACADQfgAakIANwMAIANBuJHDACkCACI7NwMwIANCADcDWCADQaABaiADQShqKQIANwMAIANBmAFqIANBIGopAgA3AwAgA0GQAWogA0EYaikCADcDACADQYgBaiADQRBqKQIANwMAIANBsAFqIDo3AwAgA0G4AWogODcDACADQcABaiA5NwMAIANByAFqIDc3AwAgAyADKQIINwOAASADIDs3A6gBIANBADoA1wEgA0EBNgLcAiADQoCAgICAIDcC1AIgAyAtNgLQAiADQdgAaiEvQQEhBgJAAkADQAJAAkAgBkUEQCADKALYAiIAIAMoAtQCTQ0CIAMgAEEBayIENgLYAiAEQQN2IQUgAEGBAk8NBCADKALQAiAFai0AACAEQQdxdkEBcSEADAELIANBADYC3AICf0EAIQAgA0HQAmoiBCgCBCIHIAQoAggiBSAFIAdLGyAFayEVAkACQAJAA0BBAiEIIAAgFUYNASAEIAAgBWoiE0EBazYCCCATQYECTw0CIAYgAEEBayIAag0ACyAHIAAgBWoiAE8NACAEIABBAWsiBTYCCCAFQQN2IQYgAEGBAk8NAiAEKAIAIAZqLQAAIAVBB3F2QQFxIQgLIAgMAgsgE0EBa0EDdkEgQYiSwwAQ8gEACyAGQSBBiJLDABDyAQALQf8BcSIAQQJGDQELIAAgAXMQ5wIhASADKAKAASEEIAMoAjAhBSADKAKEASEGIAMoAjQhByADKAKIASEIIAMoAjghEyADKAKMASEVIAMoAjwhICADKAKQASEhIAMoAkAhIiADKAKUASEWIAMoAkQhIyAD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KQOIBSA9QhqIfCI9Qv///w+DID5CGoh8pyILNgLMASABIDdC////H4MgASkDmAUgASkDkAUgPUIZiHwiN0IaiHwiPUIZiHwiPqdB////H3EiDDYC2AEgASA5Qv///w+DID5CGoh8pyINNgLcASABIDenQf///x9xIg42AtABIAEgPadB////D3EiDzYC1AEgASA4p0H///8fcSIQNgLgASABIDqnQf///w9xIhE2AuQBIAEgO6dB////H3EiEjYC6AEgASA8p0H///8PcSIaNgLsASABQfABaiIIIAFBoAFqIhsgAUHIAWoiHBB6IAFBmAJqIh0gASAJEDYgAUHAAmoiCSAHIAFB0ABqEDYgASgCmAIhByABKALAAiEeIAEoApwCIR8gASgCxAIhJiABKAKgAiEnIAEoAsgCISggASgCpAIhKSABKALMAiEqIAEoAqgCISsgASgC0AIhLCABKAKsAiEuIAEoAtQCITAgASgCsAIhMSABKALYAiEyIAEoArQCITMgASgC3AIhNCABKAK4AiE1IAEoAuACITYgASABKALkAiABKAK8Amo2AowDIAEgNSA2ajYCiAMgASAzIDRqNgKEAyABIDEgMmo2AoADIAEgLiAwajYC/AIgASArICxqNgL4AiABICkgKmo2AvQCIAEgJyAoajYC8AIgASAfICZqNgLsAiABIAcgHmo2AugCIAFBkANqIgcgHSAJEHogBiABQegCahBQIAEpA5gFITggASkDkAUhOiABKQOIBSE7IAEpA4AFITcgASkDyAUhPCABKQPABSE9IAEpA7gFIT4gASkDsAUhQSABKQOoBSFCIAEpA6AFITkgBiAHEFAgASABKQOwBSABKQOoBSABKQOgBSI/QhqIfCJEQhmIfCJAp0H///8fcTYC0AMgASABKQOQBSABKQOIBSABKQOABSJFQhqIfCJGQhmIfCJDp0H///8fcTYCwAMgASABKQO4BSBAQhqIfCJAp0H///8PcTYC1AMgASABKQOYBSBDQhqIfCJDp0H///8PcTYCxAMgASABKQPABSBAQhmIfCJAp0H///8fcTYC2AMgASBEQv///w+DID9C////H4MgQ0IZiHwiP0IaiHw+AswDIAEgP6dB////H3E2AsgDIAEgASkDyAUgQEIaiHwiP6dB////D3E2AtwDIAEgRkL///8PgyA/QhmIQhN+IEVC////H4N8Ij9CGoh8PgK8AyABID+nQf///x9xNgK4AyABQeADakHgkcMAIAgQNiABQYgEaiAbIBwQNiABIAEoAoQEIBpqNgKkBSABIAEoAoAEIBJqNgKgBSABIAEoAvwDIBFqNgKcBSABIAEoAvgDIBBqNgKYBSABIAEoAvQDIA1qNgKUBSABIAEoAvADIAxqNgKQBSABIAEoAuwDIA9qNgKMBSABIAEoAugDIA5qNgKIBSABIAEoAuQDIAtqNgKEBSABIAEoAuADIApqNgKABSABQbAEaiAIIAYQNiABQdgEaiADQQhqIAFBuANqEDYgJSABQagEaikCADcCACAjIAFBoARqKQIANwIAICEgAUGYBGopAgA3AgAgFSABQZAEaikCADcCACAFIAEpAogENwIAIAUgASkCsAQ3AiggEyABQbgEaikCADcCACAgIAFBwARqKQIANwIAICIgAUHIBGopAgA3AgAgJCABQdAEaikCADcCACAEIDwgPSA+IEEgQiA5QhqIfCJCQhmIfCJBQhqIfCI+QhmIfCI9QhqIfCI8p0H///8PcTYCJCAEID2nQf///x9xNgIgIAQgPqdB////D3E2AhwgBCBBp0H///8fcTYCGCAEIEJC////D4MgOUL///8fgyA4IDogOyA3QhqIfCI5QhmIfCI6QhqIfCI4QhmIfCI7QhqIfD4CFCAEIDunQf///x9xNgIQIAQgOKdB////D3E2AgwgBCA6p0H///8fcTYCCCAEIDlC////D4MgPEIZiEITfiA3Qv///x+DfCI3QhqIfD4CBCAEIDenQf///x9xNgIAIAQgASkC2AQ3AiggFiABQeAEaikCADcCACAXIAFB6ARqKQIANwIAIBggAUHwBGopAgA3AgAgGSABQfgEaikCADcCACABQdAFaiQAIAMgADoA1wEgAygC3AIhBiAAIQEMAQsLIAEQ5wIhACADKAKAASEBIAMoAjAhBCADKAKEASEFIAMoAjQhBiADKAKIASEHIAMoAjghCCADKAKMASETIAMoAjwhFSADKAKQASEgIAMoAkAhISADKAKUASEiIAMoAkQhFiADKAKYASEjIAMoAkghFyADKAKcASEkIAMoAkwhGCADKAKgASElIAMoAlAhCSADKAKkASEZIAMoAlQhCiADKAKoASELIAMoAlghDCADKAKsASENIAMoAlwhDiADKAKwASEPIAMoAmAhECADKAK0ASERIAMoAmQhEiADKAK4ASEaIAMoAmghGyADKAK8ASEcIAMoAmwhHSADKALAASEeIAMoAnAhHyADKALEASEmIAMoAnQhJyADKALIASEoIAMoAnghKSADQQAgAEH/AXFrIgAgAygCzAEiKiADKAJ8IitzcSIsICtzNgJ8IAMgKSAoIClzIABxIitzNgJ4IAMgJyAmICdzIABxIilzNgJ0IAMgHyAeIB9zIABxIidzNgJwIAMgHSAcIB1zIABxIh9zNgJsIAMgGyAaIBtzIABxIh1zNgJoIAMgEiARIBJzIABxIhtzNgJkIAMgECAPIBBzIABxIhJzNgJgIAMgDiANIA5zIABxIhBzNgJcIAMgDCALIAxzIABxIg5zNgJYIAMgCiAKIBlzIABxIgxzNgJUIAMgCSAJICVzIABxIgpzNgJQIAMgGCAYICRzIABxIglzNgJMIAMgFyAXICNzIABxIhhzNgJIIAMgFiAWICJzIABxIhdzNgJEIAMgISAgICFzIABxIhZzNgJAIAMgFSATIBVzIABxIiFzNgI8IAMgCCAHIAhzIABxIhVzNgI4IAMgBiAFIAZzIABxIghzNgI0IAMgBCABIARzIABxIgBzNgIwIAMgKiAsczYCzAEgAyAoICtzNgLIASADICYgKXM2AsQBIAMgHiAnczYCwAEgAyAcIB9zNgK8ASADIBogHXM2ArgBIAMgESAbczYCtAEgAyAPIBJzNgKwASADIA0gEHM2AqwBIAMgCyAOczYCqAEgAyAMIBlzNgKkASADIAogJXM2AqABIAMgCSAkczYCnAEgAyAYICNzNgKYASADIBcgInM2ApQBIAMgFiAgczYCkAEgAyATICFzNgKMASADIAcgFXM2AogBIAMgBSAIczYChAEgAyAAIAFzNgKAASADQQA6ANcBIANB0AJqIgAgLxAzIANBoAJqIANB8AJqKQIANwMAIANBmAJqIANB6AJqKQIANwMAIANBkAJqIANB4AJqKQIANwMAIANBiAJqIANB2AJqKQIANwMAIAMgAykC0AI3A4ACIANByAJqIANBmANqKQIANwMAIANBwAJqIANBkANqKQIANwMAIANBuAJqIANBiANqKQIANwMAIANBsAJqIANBgANqKQIANwMAIAMgAykC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AEEIaikDADcDACADIAApAwA3AyAgA0ECNgIMIANB+LfDADYCCCADQgI3AhQgAyADrUKAgICAgBCENwM4IAMgA0Egaq1CgICAgJAQhDcDMCADIANBMGo2AhAgA0EIahCyASADQUBrJAALjQEBBH8jAEEQayICJAACf0EBIAEoAgAiA0EnIAEoAgQiBSgCECIBEQAADQAaIAIgACgCAEGBAhBSAkAgAi0ADSIAQYEBTwRAIAMgAigCACABEQAARQ0BQQEMAgsgAyACIAItAAwiBGogACAEayAFKAIMEQEARQ0AQQEMAQsgA0EnIAERAAALIAJBEGokAAuGAQEBfyMAQRBrIgMkACACIAEgAmoiAUsEQEEAQQAQ2wIACyADQQRqIAAoAgAiAiAAKAIEQQggASACQQF0IgIgASACSxsiASABQQhNGyIBEN8BIAMoAgRBAUYEQCADKAIIIAMoAgwQ2wIACyADKAIIIQIgACABNgIAIAAgAjYCBCADQRBqJAALpQEBAX8jAEEQayICJAACfwJAAkACQAJAAkAgACgCAEEBaw4EAQIDBAALIAFBqN7AAEESEOkCDAQLIAFBut7AAEEMEOkCDAMLIAIgAEEEajYCDCABQejewABBC0Hz3sAAQQQgAEEIakHI3sAAQffewABBBiACQQxqQdjewAAQyAEMAgsgAUH93sAAQQYQ6QIMAQsgAUGD38AAQREQ6QILIAJBEGokAAuHAQEEfyAAKAIEIQIgACgCCCIDBEAgAkEEaiEBA0ACQAJAAkACQCABQQRrLQAADgUDAwMBAgALIAEQRAwCCyABKAIAIgRFDQEgAUEEaigCACAEQQEQ+gIMAQsgARDbAQsgAUEYaiEBIANBAWsiAw0ACwsgACgCACIABEAgAiAAQRhsQQgQ+gILC3kAIAAgASkAADcAACAAQSBqIAEpACA3AAAgAEEIaiABQQhqKQAANwAAIABBEGogAUEQaikAADcAACAAQRhqIAFBGGopAAA3AAAgAEEoaiABQShqKQAANwAAIABBMGogAUEwaikAADcAACAAQThqIAFBOGopAAA3AAALiwEBBH8CQAJAAkAgACgCACIAKAIADgIAAQILIAAoAggiAUUNASAAKAIEIAFBARD6AgwBCyAALQAEQQNHDQAgACgCCCIBKAIAIQMgAUEEaigCACIEKAIAIgIE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AQsgAkECNgIEIAJBqJ7EADYCACACQgE3AgwgAiAArUKAgICA4AiENwMYIAIgAkEYajYCCCABKAIAIAEoAgQgAhBgCyACQSBqJAALvQMBB38jAEEQayIDJAAgACgCCCEFIAAoAgQhACABKAIAQb+2xABBASABKAIEKAIMEQEAIQQgA0EEaiICQQA6AAUgAiAEOgAEIAIgATYCACAFBEADQCADIAA2AgwgA0EMaiEHIwBBIGsiASQAQQEhBgJAIANBBGoiBC0ABA0AIAQtAAUhCAJAIAQoAgAiAi0ACkGAAXFFBEAgCEEBcUUNASACKAIAQZG2xABBAiACKAIEKAIMEQEARQ0BDAILIAhBAXFFBEAgAigCAEGTtsQAQQEgAigCBCgCDBEBAA0CCyABQQE6AA8gAUGctsQANgIUIAEgAikCADcCACABIAIpAgg3AhggASABQQ9qNgIIIAEgATYCECAHIAFBEGpBiNLAACgCABEAAA0BIAEoAhBBlLbEAEECIAEoAhQoAgwRAQAhBgwBCyAHIAJBiNLAACgCABEAACEGCyAEQQE6AAUgBCAGOgAEIAFBIGokACAAQQFqIQAgBUEBayIFDQALC0EBIQAgA0EEaiIBLQAERQRAIAEoAgAiACgCAEHAtsQAQQEgACgCBCgCDBEBACEACyABIAA6AAQgA0EQaiQAIAALugUBE38jAEHAAWsiAyQAIANBuAFqIAFBGGopAAA3AwAgA0GwAWogAUEQaikAADcDACADQagBaiABQQhqKQAANwMAIAMgASkAADcDoAEjAEEgayIBJAAgA0GgAWoiBCAELQAfQT9xQcAAcjoAHyAEIAQtAABB+AFxOgAAIAFBCGogBEEIaikAADcDACABQRBqIARBEGopAAA3AwAgAUEYaiAEQRhqKQAANwMAIAEgBCkAADcDACADIAEQJyABQSBqJAAjAEGgAmsiAiQAIAMoAighBSADKAJQIQYgAygCLCEHIAMoAlQhCCADKAIwIQkgAygCWCEKIAMoAjQhCyADKAJcIQwgAygCOCENIAMoAmAhDiADKAI8IQ8gAygCZCEQIAMoAkAhESADKAJoIRIgAygCRCETIAMoAmwhFCADKAJIIQQgAygCcCEBIAIgAygCTCADKAJ0ajYCLCACIAEgBGo2AiggAiATIBRqNgIkIAIgESASajYCICAC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AgggAygCDBCSAiEBIABBATsBACAAIAE2AgQgA0EQaiQAC0kBAX8jAEEQayIDJAAgA0EIaiABKAIAIAEoAgQgASgCCBBeIAIgAygCCCADKAIMEJICIQEgAEECNgIAIAAgATYCBCADQRBqJAALvw8CBn8CfiMAQRBrIg0kACMAQeAAayIMJAACQAJAAkACQCAABEAgAEEIayIPIA8oAgBBAWoiDjYCACAORQ0BIAAoAgANAiAAQX82AgAgDCAPNgJQIAwgADYCTCAMIAQ2AgwgDCADNgIIIAwgBDYCBCAMIAY2AhggDCAFNgIUIAwgBjYCECAMIAg2AiQgDCAHNgIgIAwgCDYCHCAMIABBCGoiBDYCSAJAIApFBEBBgICAgHghCwwBCyAMIAs2AjAgDCAKNgIsCyAMIAs2AiggDEE0aiEFIwBB0AFrIgMkACADQQhqIAxBHGoiBkEIaigCADYCACADQRRqIAxBEGoiB0EIaigCADYCACADIAYpAgA3AwAgAyAHKQIANwIMIANByAFqIAxBBGoiBkEIaigCADYCACADIAYpAgA3A8ABIANB8ABqIAQgASACIAMgA0HAAWogCfwHIAxBKGoQJAJAIAMpA4ABIhJCBFEEQCADQcgAaiADQZABaikDACISNwMAIANB0ABqIANBmAFqKAIAIgQ2AgAgAyADKQOIASITNwNAIAVBEGogBDYCACAFQQhqIBI3AgAgBSATNwIAIAMoAsABIgRFDQEgAygCxAEgBEEBEPoCDAELIANB4ABqIgQgA0GQAWopAwA3AwAgA0HoAGoiByADQZgBaigCADYCACADIAMpA4gBNwNYIAMoAnghCCADKAJ0IQogAygCcCEGIANBPGogA0G8AWooAgA2AgAgA0E0aiADQbQBaikCADcCACADQSxqIANBrAFqKQIANwIAIANBJGogA0GkAWopAgA3AgAgAyADKQKcATcCHCADQdAAaiILIAcoAgA2AgAgA0HIAGoiByAEKQMANwMAIAMgAykDWDcDQCADQRhqIAsoAgA2AgAgA0EQaiAHKQMANwMAIAMgAykDQDcDCCADIBI3AwAgAygCwAEiBARAIAMoAsQBIARBARD6AgsCQCASQgNSBEAgA0GEAWogA0EYaigCADYCACADIAg2AnggAyAKNgJ0IAMgBjYCcCADIAMpAxA3AnwgAyAD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KCACIAKtQoCAgIDgCIQ3AyAgAiACQSBqNgIQIAJBCGogAxC/AgALIwBBMGsiASQAIAEgAjYCBCABIAA2AgAgAUECNgIMIAFBqNPEADYCCCABQgI3AhQgASABQQRqrUKAgICA4AiENwMoIAEgAa1CgICAgOAIhDcDICABIAFBIGo2AhAgAUEIaiADEL8CAAsjAEEwayIAJAAgACACNgIEIAAgATYCACAAQQI2AgwgAEHQ0sQANgIIIABCAjcCFCAAIABBBGqtQoCAgIDgCIQ3AyggACAArUKAgICA4AiENwMgIAAgAEEgajYCECAAQQhqIAMQvwIAC0IBAX8jAEEgayIDJAAgA0EANgIQIANBATYCBCADQgQ3AgggAyABNgIcIAMgADYCGCADIANBGGo2AgAgAyACEL8CAAtBAQF/IAAoAgAiACgCqAEEQCAAQQA2AqgBCwJAIABBf0YNACAAIAAoAgRBAWsiATYCBCABDQAgAEGQD0EIEPoCCws9AQJ/AkAgACgCACICRQ0AIAAoAgQiACgCACIBBEAgAiABEQQACyAAKAIEIgFFDQAgAiABIAAoAggQ+gILCzkBAX8jAEEQayICJAAgAkEIaiAAKAIAIAAoAgQgACgCCBBeIAEgAigCCCACKAIMEJICIAJBEGokAAvfBwIEfwJ+IwBBEGsiCSQAIwBB0ABrIggkAAJAAkACQAJAIAAEQCAAQQhrIgsgCygCAEEBaiIKNgIAIApFDQEgACgCAA0CIABBfzYCACAIIAs2AkAgCCAANgI8IAggBDYCFCAIIAM2AhAgCCAENgIMIAggAEEIaiIKNgI4AkAgBkUEQEGAgICAeCEHDAELIAggBzYCICAIIAY2AhwLIAggBzYCGCAIQSRqIQQjAEGAAmsiAyQAIANBgICAgHg2AtgBIANB+AFqIAhBDGoiBkEIaigCADYCACADIAYpAgA3A/ABIANBiAFqIAogASACIANB2AFqIANB8AFqIAX8ByAIQRhqECQCQCADKQOYASINQgRRBEAgA0HgAGogA0GoAWopAwAiDTcDACADQegAaiADQbABaigCACIGNgIAIAMgAykDoAEiDDcDWCAEQRBqIAY2AgAgBEEIaiANNwIAIAQgDDcCACADKALwASIERQ0BIAMoAvQBIARBARD6AgwBCyADQRBqIgYgA0GQAWopAwA3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BUEKNgIAIAVBDGogAkEsaigCADYCACAHRQ0CIAogB0EBEPoCDAILIAVBDTYCECAFQdvCwAA2AgwgBUEONgIIIAVBzcLAADYCBCAFQQg2AgAMAQtByL7AAEErIAJB/wBqQbi+wABB9L7AABDmAQALIAJBgAFqJAAMAQtByMPAAEE3IAJB/wBqQbjDwABBgMTAABDmAQALIANBKGoiAiADQcQAaiIEKAIANgIAIAMgAykCPDcDICADKAI4IgdBCkcEQCADKAJIIQogBCACKAIANgIAIAMgAykDIDcCPCADIAo2AkggAyAHNgI4IAUQywEhAiAJQYCAgIB4NgIAIAkgAjYCBAwBCyAJIAMpAyA3AgAgCUEIaiACKAIANgIACyADQdAAaiQAIAEEQCAAIAFBARD6AgsCQAJAIAYCfyAIKAIEIgJBgICAgHhGBEBBACEBIAgoAgghAEEBDAELIAgoAgghAAJAIAgoAgwiCyACTwRAIAAhAQwBCyALRQRAQQEhASAAIAJBARD6AgwBCyAAIAJBASALEO0CIgFFDQILQQAhAEEACzYCDCAGIAA2AgggBiALNgIEIAYgATYCACAIQRBqJAAMAQtBASALENsCAAsgBigCACAGKAIEIAYoAgggBigCDCAGQRBqJAALlwQCB38CfiMAQRBrIgQkACMAQdAAayICJAAjAEEgayIDJAAgAkEoaiIFAn8gAUEgRgRAIANBAmogAEECai0AADoAACADQR9qIABBH2otAAA6AAAgAyAALwAAOwEAIAMgACkAFzcAFyADIAApAA83AA8gAyAAKAALNgALIAMgACkAAzcAAyAFQQFqIAMQ7gEgAxDCAUEADAELIAUgATYCDCAFQoCAgICABDcCBEEBCzoAACADQSBqJAACQAJAAkAgAi0AKCIGQQFGBEAgAkEbaiACQTxqKAIAIgM2AAAgAkETaiACQTRqKQIAIgk3AAAgAiACKQIsIgo3AAsgAkE4aiADNgIAIAJBMGogCTcDACACIAo3AyggBRDLASEDDAELIAJBIGoiByACQcEAaikAADcDACACQRhqIgggAkE5aikAADcDACACQRBqIgUgAkExaikAADcDACACIAIpACk3AwhBIEEBEIEDIgNFDQEgAyACKQMINwAAIANBGGogBykDADcAACADQRBqIAgpAwA3AAAgA0EIaiAF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IAAgARDcAkUNACAABEAgACABEIEDIgFFDQELIAEPCwALJwECfyMAQRBrIgAkACAAQQo2AgQgAEEEakEAQQAQkgIgAEEQaiQAC6QJAhJ/An4jAEEwayIPJAAgD0EMaiEQIwBBsAFrIgIkACACQThqQgA3AwAgAkEwakIANwMAIAJBKGpCADcDACACQSBqQgA3AwAgAkEYakIANwMAIAJBEGpCADcDACACQQhqQgA3AwAgAkIANwMAQQEhBwNAIAIgBWoiAyADKAIAIAEgBWoiAy0AAHIgA0EBai0AAEEIdHIgA0ECai0AAEEQdHIgA0EDai0AAEEYdHI2AgAgBUEEaiEFIAdBEEkgB0EBaiEHDQALIAJByABqIgEgAigCCCIKQQZ0IAIoAgQiBkEadnJB/////wFxNgIAIAJB0ABqIgUgAigCECILQQx0IAIoAgwiDEEUdnJB/////wFxNgIAIAJB2ABqIgcgAigCGCIEQRJ0IAIoAhQiDUEOdnJB/////wFxNgIAIAJB4ABqIgMgAigCICIOQRh0IAIoAhwiCEEIdnJB/////wFxNgIAIAIgAigCACIJQf////8BcTYCQCACIAZBA3QgCUEddnJB/////wFxNgJEIAIgDEEJdCAKQRd2ckH/////AXE2AkwgAiANQQ90IAtBEXZyQf////8BcTYCVCACIAhBFXQgBEELdnJB/////wFxNgJcIAJBiAFqIgogAigCPCIEQQ12NgIAIAJB8ABqIg0gAigCKCIIQQF0IAIoAiQiBkEfdnJB/////wFxNgIAIAJB+ABqIgsgAigCMCIJQQd0IAIoAiwiEUEZdnJB/////wFxNgIAIAJBgAFqIgwgAigCOCISQQ10IAIoAjQiE0ETdnJB/////wFxNgIAIAIgBkECdkH/////AXE2AmwgAiAGQRt0IA5BBXZyQf////8BcTYCaCACIBFBBHQgCEEcdnJB/////wFxNgJ0IAIgE0EKdCAJQRZ2ckH/////AXE2AnwgAiAEQRB0IBJBEHZyQf////8BcTYChAEgAkGMAWoiBiACQUBrQbzhwAAQMSADIAJBrAFqIgQoAgA2AgAgByACQaQBaiIOKQIANwMAIAUgAkGcAWoiCCkCADcDACABIAJBlAFqIgkpAgA3AwAgAiACKQKMATcDQCAGIAJB6ABqQZjhwAAQMSAKIAQoAgA2AgAgDCAOKQIANwMAIAsgCCkCADcDACANIAkpAgAiFDcDACACIAIpAowBIhU3A2ggAiACKAJAIBWnaiIEQf////8BcTYCjAEgAiACKAJEIAIoAmwgBEEddmpqIgRB/////wFxNgKQASACIAEoAgAgFKcgBEEddmpqIgFB/////wFxNgKUASACIAIoAkwgAigCdCABQR12amoiAUH/////AXE2ApgBIAIgBSgCACALKAIAIAFBHXZqaiIBQf////8BcTYCnAEgAiACKAJUIAIoAnwgAUEddmpqIgFB/////wFxNgKgASACIAcoAgAgDCgCACABQR12amoiAUH/////AXE2AqQBIAIgAigCXCACKAKEASABQR12amoiAUH/////AXE2AqgBIAIgAygCACAKKAIAIAFBHXZqakH/////AXE2AqwBIBAgBkHg4cAAEGggAkGwAWokACAAIBAQfyAPQTBqJAAL/AECAn8BfiMAQRBrIgIkACACQQE7AQwgAiABNgIIIAIgADYCBCMAQRBrIgEkACACQQRqIgApAgAhBCABIAA2AgwgASAENwIEIwBBEGsiACQAIAFBBGoiASgCACICKAIMIQMCQAJAAkACQCACKAIEDgIAAQILIAMNAUEBIQJBACEDDAILIAMNACACKAIAIgIoAgQhAyACKAIAIQIMAQsgAEGAgICAeDYCACAAIAE2AgwgAEH8p8QAIAEoAgQgASgCCCIALQAIIAAtAAkQxAEACyAAIAM2AgQgACACNgIAIABB4KfEACABKAIEIAEoAggiAC0ACCAALQAJEMQBAAu3FwIYfwd+IwBBEGsiEiQAIAEhFyMAQUBqIggkAAJAAkACQCAABEAgAEEIayITIBMoAgBBAWoiBDYCACAERQ0BIAAoAgANAiAAQX82AgAgCCATNgIMIAggADYCCCAIIABBCGoiBDYCBCAIIAI2AiggCCABNgIkIAggAjYCICAIQSxqIQ0gBCEBIAhBIGohFCMAQcAtayIEJAACQAJAIAMEQCABKAKUECEMIAEoApgQIQoMAQsgASgCmBAhCiABKAKUECEMIARBkBBqIAFBGGopAwA3AwAgBEGIEGogAUEQaikDADcDACAEQYAQaiABQQhqKQMANwMAIAQgASkDADcD+A8gBEHQH2ogAUH4AGopAwA3AwAgBEHIH2og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BjoAAAwHCyADQQc6AAAMBgsgA0EJOgAADAULIANBCjoAAAwEC0ELIQQLIAMgBDoAAAwCCyADQQE6AAAMAQsgA0ECOgAACyADIAEgAhDXASADQRBqJAALZAEEfyMAQRBrIgIkACMAQRBrIgMkACADQQhqIAAgARCJASADKAIMIQQgAygCCCEFIAEEQCAAIAFBARD6AgsgAiAFNgIAIAIgBDYCBCADQRBqJAAgAigCACACKAIEIAJBEGokAAvkAwIFfwN+IwBBEGsiBCQAIwBBEGsiBSQAIAVBCGohBiMAQYAQayICJAAgAkE4akIANwMAIAJBMGpCADcDACACQShqQgA3AwAgAkEgakIANwMAIAJBGGpCADcDACACQRBqQgA3AwAgAkEIakIANwMAIAJByABqQcDLwAApAgAiBzcDACACQdAAakHIy8AAKQIAIgg3AwAgAkHYAGpB0MvAACkCACIJNwMAIAJBiA9qIAc3AwAgAkGQD2ogCDcDACACQZgPaiAJNwMAIAJCADcDACACQbjLwAApAgAiBzcDQCACIAc3A4APIAJBoA9qIAJB4AD8CgAAIAIgAkGAD2oiA0GAAfwKAAAgAkGHAWpBADYAACACQQA2ApgBIAJCADcDkAEgAkIANwOAASACIAAgARApIAMgAhC/AUEgQQEQgQMiA0UEQEEBQSAQ2wIACyADIAIpAIAPNwAAIANBGGogAkGYD2opAAA3AAAgA0EQaiACQZAPaikAADcAACADQQhqIAJBiA9qKQAANwAAIAZBIDYCBCAGIAM2AgAgAkGAEGokACAFKAIMIQIgBSgCCCEDIAEEQCAAIAFBARD6AgsgBCADNgIAIAQgAjYCBCAFQRBqJAAgBCgCACAEKAIEIARBEGokAAshAAJAIAEgAxDcAgRAIAAgASADIAIQ7QIiAA0BCwALIAALogIBBH8jAEEQayIDJAAjAEEwayICJAACQAJAAkACQCAABEAgAEEIayIEIAQoAgBBAWoiATYCACABRQ0BIAAoAgAiAUF/Rg0CIAAgAUEBajYCACACIAQ2AgwgAiAANgIIIAIgAEEIaiIBNgIEIAJBEGogARC/AUEgQQEQgQMiAUUNAyABIAIpABA3AAAgAUEYaiACQShqKQAANwAAIAFBEGogAkEgaikAADcAACABQQhqIAJBGGopAAA3AAAgACAAKAIAQQFrNgIAIAQgBCgCAEEBayIANgIAIABFBEAgAkEMahCaAgsgA0EgNgIEIAMgATYCACACQTBqJAAMBAsQkAMLAAsQkQMAC0EBQSAQ2wIACyADKAIAIAMoAgQgA0EQaiQACyUAIABFBEBB9JvDAEEyEJIDAAsgACACIAMgBCAFIAEoAhAREAALxwIBCX8jAEEQayIDJAAjAEEQayIEJAAgBEEIaiEFIwBB0AJrIgAkACAAQYACaiICQgA3AwAgAEH4AWoiBkIANwMAIABB8AFqIgdCADcDACAAQgA3A+gBIABB6AFqIggQ1QEgAEGPAmoiASAIEDkgAEEIaiABEKICIAEQwAEgAEHQAWogBykDADcCACAAQdgBaiAGKQMANwIAIABB4AFqIAIpAwA3AgAgACAAKQPoATcCyAFBIEEBEIEDIgFFBEBBAUEgEJoDAAsgASAAQcgBaiICKQAANwAAIAFBGGogAkEYaikAADcAACABQRBqIAJBEGopAAA3AAAgAUEIaiACQQhqKQAANwAAIABBCGoQwwEgBUEgNgIEIAUgATYCACAAQdACaiQAIAMgBCkDCDcCACAEQRBqJAAgAygCACADKAIEIANBEGokAAulAgEIfyMAQRBrIgIkACMAQRBrIgMkACADQQhqIQQjAEEgayIBJAAjAEEwayIAJAAgAEEgaiIFQgA3AwAgAEEYaiIGQgA3AwAgAEEQaiIHQgA3AwAgAEIANwMIIABBCGoQ1QEgAUEYaiAFKQMANwAAIAFBEGogBikDADcAACABQQhqIAcpAwA3AAAgASAAKQMINwAAIABBMGokAEEgQQEQgQMiAEUEQEEBQSAQmgMACyAAIAEpAAA3AAAgAEEYaiABQRhqKQAANwAAIABBEGogAUEQaikAADcAACAAQQhqIAFBCGopAAA3AAAgARDCASAEQSA2AgQgBCAANgIAIAFBIGokACACIAMpAwg3AgAgA0EQaiQAIAIoAgAgAigCBCACQRBqJAALIwAgAEUEQEH0m8MAQTIQkgMACyAAIAIgAyAEIAEoAhARCgALIwAgAEUEQEH0m8MAQTIQkgMACyAAIAIgAyAEIAEoAhAREQALIwAgAEUEQEH0m8MAQTIQkgMACyAAIAIgAyAEIAEoAhAROAALIwAgAEUEQEH0m8MAQTIQkgMACyAAIAIgAyAEIAEoAhAROgALIwAgAEUEQEH0m8MAQTIQkgMACyAAIAIgAyAEIAEoAhARPAALKAEBfyAAKAIAIgFBgICAgHhyQYCAgIB4RwRAIAAoAgQgAUEBEPoCCwshACAARQRAQfSbwwBBMhCSAwALIAAgAiADIAEoAhARAwALIgAgAC0AAEUEQCABQZy0xABBBRBTDwsgAUGhtMQAQQQQUwsbACAAKAIAIgBBBGooAgAgAEEIaigCACABEEILHwAgAEUEQEH0m8MAQTIQkgMACyAAIAIgASgCEBEAAAscACAAIAAtAAQgAUEuRnI6AAQgACgCACABEOoCCxoBAX8gACgCACIBBEAgACgCBCABQQEQ+gILCxwAIAAoAgAiACgCACABIABBBGooAgAoAhARAAALHwAgAEEIakGg3sAAKQIANwIAIABBmN7AACkCADcCAAsfACAAQQhqQciSwwApAgA3AgAgAEHAksMAKQIANwIACx8AIABBCGpB5KDEACkCADcCACAAQdygxAApAgA3AgALHwAgAEEIakH0oMQAKQIANwIAIABB7KDEACkCADcCAAtFACAABEAgACABEJoDAAsjAEEgayIAJAAgAEEANgIYIABBATYCDCAAQcCtxAA2AgggAEIENwIQIABBCGpByK3EABC/AgALFQAgAWlBAUYgAEGAgICAeCABa01xCxcBAX8gABAVIgE2AgQgACABQQBHNgIACxcBAX8gABAYIgE2AgQgACABQQBHNgIACxcBAX8gABAZIgE2AgQgACABQQBHNgIACxcBAX8gABAaIgE2AgQgACABQQBHNgIACxwAIABBADYCECAAQgA3AgggAEKAgICAwAA3AgALFwEBbyAAIAEQACECEI8BIgAgAiYBIAALFwEBbyAAIAEQASECEI8BIgAgAiYBIAALFwEBbyAAJQEQECEBEI8BIgAgASYBIAALFgAgACgCACIAKAIEIAAoAgggARCbAwsWACAAKAIAIgAoAgAgACgCBCABEJsDCxUBAX8jAEEQayIBIAA6AA8gAS0ADwsQACABBEAgACABIAIQ+gILCxYAIAAoAgAgASACIAAoAgQoAgwRAQALFAAgACgCACABIAAoAgQoAhARAAALnAcBA38jAEHwAGsiBSQAIAUgAzYCDCAFIAI2AggCfwJAAkAgAUGBAk8EQEH9ASEGA0ACQCAAIAZq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ARCbAwsTACAAQSg2AgQgAEHw3cAANgIACxAAIAAoAgAgACgCBCABEEILEwAgAEEoNgIEIABBmJLDADYCAAsWAEHM5MQAIAA2AgBByOTEAEEBNgIACxAAIAAoAgQgACgCCCABEEILEQAgASAAKAIAIAAoAgQQ6QILEwAgAEG8qMQANgIEIAAgATYCAAsQACABIAAoAgAgACgCBBBTCxAAIAEoAgAgASgCBCAAEGALEQEBfxCPASIBIAAlASYBIAELYQEBfwJAAkAgAEEEaygCACICQXhxIgNBBEEIIAJBA3EiAhsgAWpPBEAgAkEAIAMgAUEnaksbDQEgABBNDAILQcyoxABBLkH8qMQAEJkCAAtBjKnEAEEuQbypxAAQmQIACwsPAEGs3MAAQS8gABCZAgALDwBBuNPEAEErIAAQmQIACw4AIAFB9KHAAEEFEOkCC6gBAQJ/IAAoAgAjAEEwayIAJAAoAgAhAiAAQgA3AyggAEEoaiIDIAIlARAeIAAgACgCLCICNgIkIAAgACgCKDYCICAAIAI2AhwgAEECNgIIIABBiJ7DADYCBCAAQgE3AhAgACAAQRxqrUKAgICAwA+ENwMoIAAgAzYCDCABKAIAIAEoAgQgAEEEahBgIAAoAhwiAgRAIAAoAiAgAkEBEPoCCyAAQTBqJAALDQAgAEGApcAAIAEQYAsOACABQfClwABBBRDpAgsaAAJ/IAFBCU8EQCABIAAQggEMAQsgABAjCwsOACABQc+uwABBGRDpAgsOACABQeiuwABBEBDpAgsOACABQfiuwABBGhDpAgsOACABQcSvwABBERDpAgsOACABQay4wABBERDpAgsOACABQfS5wABBERDpAgsOACABQdC9wABBBRDpAgsOACABQYS/wABBDhDpAgsNACAAQaDDwAAgARBgCw4AIAFBkMTAAEEFEOkCCw4AIAFB9MfAAEEFEOkCCwwAIAAoAgAgARCxAQsMACAAKAIAIAEQmwELCAAgACABECcLDQBBppzDAEEbEJIDAAsOAEHBnMMAQc8AEJIDAAsJACAAIAEQHQALDgAgAUHstsMAQQUQ6QILDQAgAEGsvcMAIAEQYAsNACAAQbygxAAgARBgCw0AIABByKfEACABEGALDAAgACABKQIANwMACw0AIABB2K3EACABEGALDgAgAUGsrMQAQQUQ6QILGgAgACABQZToxAAoAgAiAEGUASAAGxECAAALCgAgAiAAIAEQUwsNACAAQZy2xAAgARBgCw0AIAFB9uLEAEEYEFMLDQAgAUHU4sQAQSAQUwsOACABQdSgxABBCBDpAgsOACABQd7IwwBBDRDpAgsJACAAQQA2AgALTQEBfyMAQTBrIgEkACABQQE2AgwgAUHws8QANgIIIAFCATcCFCABIAFBL2qtQoCAgIDQFYQ3AyAgASABQSBqNgIQIAFBCGogABC/AgALUAEBfyMAQTBrIgAkACAAQQE2AgwgAEHws8QANgIIIABCATcCFCAAIABBL2qtQoCAgIDgFYQ3AyAgACAAQSBqNgIQIABBCGpB5J/AABC/AgALCAAgACUBEAILFQIBbwF/EBwhABCPASIBIAAmASABCwIACwur3wRAAEGAgMAAC4MfL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2FsbG9jL3NyYy9jb2xsZWN0aW9ucy9idHJlZS9tYXAvZW50cnkucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9iYXNlNjQtMC4yMi4xL3NyYy9lbmdpbmUvZ2VuZXJhbF9wdXJwb3NlL2RlY29kZV9zdWZmaXgucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9jdXJ2ZTI1NTE5LWRhbGVrLTQuMS4zL3NyYy93aW5kb3cucnMAbGlicmFyeS9jb3JlL3NyYy9udW0vZmx0MmRlYy9zdHJhdGVneS9ncmlzdS5ycwBsaWJyYXJ5L2FsbG9jL3NyYy9mbXQucnMAbGlicmFyeS9jb3JlL3NyYy9udW0vZGl5X2Zsb2F0LnJzAGNvanNvbi1jb3JlL3NyYy9jb3JlL2tleXMucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9yYW5kX2NvcmUtMC42LjQvc3JjL29zLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvY3VydmUyNTUxOS1kYWxlay00LjEuMy9zcmMvZWR3YXJkcy5ycwAvVXNlcnMvYW50b25pby5tdXNvbGluby8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvc3RkL3NyYy9zeXMvdGhyZWFkX2xvY2FsL25vX3RocmVhZHMucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9zZXJkZV9qc29uLTEuMC4xNDIvc3JjL2Vycm9yLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2Yvc2VyZGVfanNvbi0xLjAuMTQyL3NyYy9zZXIucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9zaWduYXR1cmUtMi4yLjAvc3JjL3NpZ25lci5ycwAvVXNlcnMvYW50b25pby5tdXNvbGluby8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL2N1cnZlMjU1MTktZGFsZWstNC4xLjMvc3JjL3NjYWxhci5ycwAvVXNlcnMvYW50b25pby5tdXNvbGluby8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvY29yZS9zcmMvc3RyL3BhdHRlcm4ucnMAbGlicmFyeS9jb3JlL3NyYy9udW0vZmx0MmRlYy9zdHJhdGVneS9kcmFnb24ucnMAbGlicmFyeS9jb3JlL3NyYy9udW0vYmlnbnVtLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvY2lwaGVyLTAuNC40L3NyYy9zdHJlYW0ucnMAY29qc29uLWNvcmUvc3JjL2NvcmUvc2Vzc2lvbl9sb2cucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2FsbG9jL3NyYy9zdHJpbmcucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2FsbG9jL3NyYy9jb2xsZWN0aW9ucy9idHJlZS9uYXZpZ2F0ZS5ycwBsaWJyYXJ5L2NvcmUvc3JjL3VuaWNvZGUvcHJpbnRhYmxlLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vL1dvcmtzcGFjZS9naXRodWIvamF6ei9jcmF0ZXMvY29qc29uLWNvcmUvc3JjL2NvcmUvY2FjaGUucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2FsbG9jL3NyYy9jb2xsZWN0aW9ucy9idHJlZS9ub2RlLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvYnM1OC0wLjUuMS9zcmMvZW5jb2RlLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvYmFzZTY0LTAuMjIuMS9zcmMvZW5jb2RlLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvYmFzZTY0LTAuMjIuMS9zcmMvZW5naW5lL2dlbmVyYWxfcHVycG9zZS9kZWNvZGUucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9iczU4LTAuNS4xL3NyYy9kZWNvZGUucnMAY29qc29uLWNvcmUvc3JjL2NvcmUvbm9uY2UucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9oYXNoYnJvd24tMC4xNS41L3NyYy9yYXcvbW9kLnJzAGxpYnJhcnkvY29yZS9zcmMvZm10L21vZC5ycwAvVXNlcnMvYW50b25pby5tdXNvbGluby8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL2Jhc2U2NC0wLjIyLjEvc3JjL2VuZ2luZS9nZW5lcmFsX3B1cnBvc2UvbW9kLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvYmFzZTY0LTAuMjIuMS9zcmMvZW5naW5lL21vZC5ycwBsaWJyYXJ5L2FsbG9jL3NyYy9yYXdfdmVjL21vZC5ycwBsaWJyYXJ5L2NvcmUvc3JjL251bS9mbHQyZGVjL21vZC5ycwAvVXNlcnMvYW50b25pby5tdXNvbGluby8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL3NlcmRlX2pzb24tMS4wLjE0Mi9zcmMvcmVhZC5ycwAvcnVzdC9kZXBzL2RsbWFsbG9jLTAuMi4xMC9zcmMvZGxtYWxsb2MucnMAbGlicmFyeS9zdGQvc3JjL2FsbG9jLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvYXJyYXl2ZWMtMC43LjYvc3JjL2FycmF5dmVjLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvZm9sZGhhc2gtMC4xLjUvc3JjL2xpYi5ycwAvVXNlcnMvYW50b25pby5tdXNvbGluby8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL29uY2VfY2VsbC0xLjIxLjMvc3JjL2xpYi5ycwAvVXNlcnMvYW50b25pby5tdXNvbGluby8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL2JsYWtlMy0xLjguMi9zcmMvbGliLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvbHJ1LTAuMTYuMS9zcmMvbGliLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvY3J5cHRvX3NlY3JldGJveC0wLjEuMS9zcmMvbGliLnJzAAAAAF8OEABiAAAAlAEAADYAAABIYXNoIHRhYmxlIGNhcGFjaXR5IG92ZXJmbG93RA8QABwAAABWChAAbAAAACUAAAAoAAAA//////////94DxAAQZCfwAALiQJ9RXhwZWN0ZWQgcHJpdmF0ZSB0cmFuc2FjdGlvbnNpZ25hdHVyZWVuY3J5cHRlZF9jaGFuZ2VzbWV0YUpzVmFsdWUgRXJyb3I6IAAAyw8QAA8AAACoBxAAUgAAAAgAAAARAAAAYXR0ZW1wdGVkIHRvIHRha2Ugb3duZXJzaGlwIG9mIFJ1c3QgdmFsdWUgd2hpbGUgaXQgd2FzIGJvcnJvd2VkSW52YWxpZCBzaWduYXR1cmUgbGVuZ3RoSW52YWxpZCBzaWduaW5nIGtleSBsZW5ndGhJbnZhbGlkIHZlcmlmeWluZyBrZXkgbGVuZ3RoAAAAAgAAAAwAAAAEAAAAAwAAAAQAAAAFAEGkocAAC/EDAQAAAAYAAABhIERpc3BsYXkgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3IgdW5leHBlY3RlZGx5AH4GEAB3AAAASwsAAA4AAABFcnJvckludmFsaWQgVVRGLTggaW4gc2VjcmV0OiAAAPkQEAAZAAAASW52YWxpZCBVVEYtOCBpbiBzaWduYXR1cmU6IBwREAAcAAAASW52YWxpZCBVVEYtOCBpbiBpZDogAAAAQBEQABUAAAAAAAAABAAAAAQAAAAIAAAAAAAAAAQAAAAEAAAACQAAAFV0ZjhFcnJvcnZhbGlkX3VwX3RvZXJyb3JfbGVuYXR0ZW1wdGVkIHRvIHRha2Ugb3duZXJzaGlwIG9mIFJ1c3QgdmFsdWUgd2hpbGUgaXQgd2FzIGJvcnJvd2VkZ+YJaoWuZ7ty8248OvVPpX9SDlGMaAWbq9mDHxnN4Fu+DBAAawAAAHsEAAAPAAAAAAAAAAQAAAAEAAAACgAAAE5vbmVTb21laW50ZXJuYWwgZXJyb3I6IGVudGVyZWQgdW5yZWFjaGFibGUgY29kZd8DEABqAAAAgQIAACoAAABJbnZhbGlkIFVURi04IGluIHNlY3JldDogAAAAXBIQABkAAAAMAAAADAAAAAQAAAANAAAADgAAAAUAQaClwAAL/wMBAAAADwAAAGEgRGlzcGxheSBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvciB1bmV4cGVjdGVkbHkAfgYQAHcAAABLCwAADgAAAEVycm9yAAAAAAAAAAQAAAAEAAAAEAAAAAAAAAAEAAAABAAAAAkAAABVdGY4RXJyb3J2YWxpZF91cF90b2Vycm9yX2xlblZlcmlmeWluZ0tleX0BAAFBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1f////////////////////////////////////////////////////////////Pv//NDU2Nzg5Ojs8Pf////////8AAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGf////8//xobHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIz/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////2VuY3J5cHRlZF9VhRQQAAsAAABwcml2YXRlAEGoqcAAC50JAQAAABIAAABjYWxsZWQgYFJlc3VsdDo6dW53cmFwKClgIG9uIGFuIGBFcnJgIHZhbHVlAPIFEABnAAAAeAAAACcAAAD/////////////////////////////////////////////////////////////////AAECAwQFBgcI/////////wkKCwwNDg8Q/xESExQV/xYXGBkaGxwdHh8g////////ISIjJCUmJygpKiv/LC0uLzAxMjM0NTY3ODn//////zEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXoiaGFzaF96IgAAphUQAAcAAACtFRAAAQAAABMAAAAEAAAABAAAABQAAABaBhAAIwAAANEAAAA2AAAAWgYQACMAAADAAQAAOAAAAFoGEAAjAAAAlQEAADQAAABn5glqha5nu3Lzbjw69U+lf1IOUYxoBZur2YMfGc3gWxUAAAAIAAAABAAAABYAAABJbnZhbGlkIHB1YmxpYyBrZXkAAFoGEAAjAAAAagAAABIAAAAXAAAAFAAAAAQAAAAYAAAAWgYQACMAAABnAAAAGgAAAFByaXZhdGVUcmFuc2FjdGlvbmVuY3J5cHRlZENoYW5nZXNrZXlVc2VkbWFkZUF0bWV0YXByaXZhY3kAAIYWEAAQAAAAlhYQAAcAAACdFhAABgAAAKMWEAAEAAAApxYQAAcAAABUcnVzdGluZ1RyYW5zYWN0aW9uY2hhbmdlcwAA6xYQAAcAAACdFhAABgAAAKMWEAAEAAAApxYQAAcAAABkYXRhIGRpZCBub3QgbWF0Y2ggYW55IHZhcmlhbnQgb2YgdW50YWdnZWQgZW51bSBUcmFuc2FjdGlvbnN0cnVjdCBQcml2YXRl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C7UBAQAAADEAAABhIERpc3BsYXkgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3IgdW5leHBlY3RlZGx5AH4GEAB3AAAASwsAAA4AAABFcnJvcgAAAN0HEAAdAAAAGQAAADEAAADdBxAAHQAAACcAAAA4AAAAgwgQAGUAAADRAQAAEAAAAIMIEABlAAAA0AEAABsAAACDCBAAZQAAAMwBAAAJAAAAgwgQAGUAAAC5AQAAIABBwL7AAAv1BAEAAAAyAAAAY2FsbGVkIGBSZXN1bHQ6OnVud3JhcCgpYCBvbiBhbiBgRXJyYCB2YWx1ZQCDCBAAZQAAAD0BAAAgAAAAQnVmZmVyVG9vU21hbGwAADMAAAAIAAAABAAAABYAAABzaWduYXR1cmUgb3BlcmF0aW9uIGZhaWxlZAAASgQQAGoAAAAQAAAAHAAAAHVzaXplIG92ZXJmbG93IHdoZW4gY2FsY3VsYXRpbmcgYjY0IGxlbmd0aAAA6QgQAGgAAABXAAAACgAAAOkIEABoAAAAUAAAADMAAABIYXNoIHRhYmxlIGNhcGFjaXR5IG92ZXJmbG93HCAQABwAAABWChAAbAAAACUAAAAoAAAAc2VhbGVyU2VjcmV0X3pzZWFsZXIgc2VjcmV0/////////////////////////////////////////////////////////////////wABAgMEBQYHCP////////8JCgsMDQ4PEP8REhMUFf8WFxgZGhscHR4fIP///////yEiIyQlJicoKSor/ywtLi8wMTIzNDU2Nzg5//////8xMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6c2VhbGVyX3oAAAAlIRAACAAAAGtleVNlY3JldF96a2V5IHNlY3JldHNpZ25lclNlY3JldF96c2lnbmVyIHNlY3JldHNpZ25lcl96aCEQAAgAAABzaWduYXR1cmVfegB4IRAACwAAAHNpZ25hdHVyZXNpZ25lciBJRAAANQAAAAwAAAAEAAAANgAAADcAAAAwAEHAw8AAC9kDAQAAADgAAABhIERpc3BsYXkgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3IgdW5leHBlY3RlZGx5AH4GEAB3AAAASwsAAA4AAABFcnJvcgAAADUAAAAMAAAABAAAADkAAAAAAAAABAAAAAQAAAA6AAAARnJvbVV0ZjhFcnJvcmJ5dGVzZXJyb3IAOwAAABQAAAAEAAAAPAAAAGNhbGxlZCBgUmVzdWx0Ojp1bndyYXAoKWAgb24gYW4gYEVycmAgdmFsdWUAgwgQAGUAAACTAAAAKwAAAHNlYWxlclNlY3JldF96c2VhbGVyIHNlY3JldP////////////////////////////////////////////////////////////////8AAQIDBAUGBwj/////////CQoLDA0ODxD/ERITFBX/FhcYGRobHB0eHyD///////8hIiMkJSYnKCkqK/8sLS4vMDEyMzQ1Njc4Of//////MTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5enNlYWxlcl96c2VhbGVyIElEAAA9AAAADAAAAAQAAAA+AAAAPwAAADAAQaTHwAAL4Q8BAAAAQAAAAGEgRGlzcGxheSBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvciB1bmV4cGVjdGVkbHkAfgYQAHcAAABLCwAADgAAAEVycm9yAAAAAAAAAAQAAAAEAAAAQQAAAAAAAAAEAAAABAAAAEIAAABJbnZhbGlkQnl0ZQAAAAAABAAAAAQAAAAfAAAASW52YWxpZExlbmd0aEludmFsaWRMYXN0U3ltYm9sSW52YWxpZFBhZGRpbmf/////////////////////////////////////////////////////////////////AAECAwQFBgcI/////////wkKCwwNDg8Q/xESExQV/xYXGBkaGxwdHh8g////////ISIjJCUmJygpKiv/LC0uLzAxMjM0NTY3ODn//////zEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpzaWduYXR1cmVfegAAAB4lEAALAAAAbWlzc2luZyBmaWVsZCBgYDQlEAAPAAAAQyUQAAEAAABpbnZhbGlkIGxlbmd0aCAsIGV4cGVjdGVkIAAAVCUQAA8AAABjJRAACwAAAGR1cGxpY2F0ZSBm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cmU6IFZ4V29ya3MgUk5HIG1vZHVsZSBpcyBub3QgaW5pdGlhbGl6ZWROb2RlLmpzIGNyeXB0byBDb21tb25KUyBtb2R1bGUgaXMgdW5hdmFpbGFibGVDYWxsaW5nIE5vZGUuanMgQVBJIGNyeXB0by5yYW5kb21GaWxsU3luYyBmYWlsZWROb2RlLmpzIEVTIG1vZHVsZXMgYXJlIG5vdCBkaXJlY3RseSBzdXBwb3J0ZWQsIHNlZSBodHRwczovL2RvY3MucnMvZ2V0cmFuZG9tI25vZGVqcy1lcy1tb2R1bGUtc3VwcG9ydAAAAAAAAAQAAAAEAAAAZwAAAGludGVybmFsX2NvZGUAAAAAAAAACAAAAAQAAABoAAAAZGVzY3JpcHRpb251bmtub3duX2NvZGUAAAAAAAQAAAAEAAAAaQAAAG9zX2Vycm9yVW5rbm93biBFcnJvcjogAMDMEAAPAAAAT1MgRXJyb3I6IAAA2MwQAAoAAABjcnlwdG8AABHKEAA4yhAAXsoQAHLKEACkyhAA0coQAADLEAAhyxAAPssQAEGgmsMACzFryxAAnMsQAMnLEAD5yxAAJwAAACYAAAAUAAAAMgAAAC0AAAAvAAAAIQAAAB0AAAAtAEHcmsMAC70GMQAAAC0AAAAwAAAAZQAAAKwxEQC4MREAxDERANAxEQByZXR1cm4gdGhpc0xhenkgaW5zdGFuY2UgaGFzIHByZXZpb3VzbHkgYmVlbiBwb2lzb25lZAAAAIfNEAAqAAAAkQ0QAGgAAAAIAwAAGQAAAHJlZW50cmFudCBpbml0AADMzRAADgAAAJENEABoAAAAegIAAA0AAABjbG9zdXJlIGludm9rZWQgcmVjdXJzaXZlbHkgb3IgYWZ0ZXIgYmVpbmcgZHJvcHBlZG51bGwgcG9pbnRlciBwYXNzZWQgdG8gcnVzdHJlY3Vyc2l2ZSB1c2Ugb2YgYW4gb2JqZWN0IGRldGVjdGVkIHdoaWNoIHdvdWxkIGxlYWQgdG8gdW5zYWZlIGFsaWFzaW5nIGluIHJ1c3RMYXp5IGluc3RhbmNlIGhhcyBwcmV2aW91c2x5IGJlZW4gcG9pc29uZWQAAJDOEAAqAAAAkQ0QAGgAAAAIAwAAGQAAAHJlZW50cmFudCBpbml0AADUzhAADgAAAJENEABoAAAAegIAAA0A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ZiByYW5nZWludmFsaWQgdW5pY29kZSBjb2RlIHBvaW50Y29udHJvbCBjaGFyYWN0ZXIgKFx1MDAwMC1cdTAwMUYpIGZvdW5kIHdoaWxlIHBhcnNpbmcgYSBzdHJpbmdrZXkgbXVzdCBiZSBhIHN0cmluZ2ludmFsaWQgdmFsdWU6IGV4cGVjdGVkIGtleSB0byBiZSBhIG51bWJlciBpbiBxdW90ZXNmbG9hdCBrZXkgbXVzdCBiZSBmaW5pdGUgKGdvdCBOYU4gb3IgKy8taW5mKWxvbmUgbGVhZGluZyBzdXJyb2dhdGUgaW4gaGV4IGVzY2FwZXRyYWlsaW5nIGNvbW1hdHJhaWxpbmcgY2hhcmFjdGVyc3VuZXhwZWN0ZWQgZW5kIG9mIGhleCBlc2NhcGVyZWN1cnNpb24gbGltaXQgZXhjZWVkZWQBAAAAAAAAAEjaEAAJAAAAdNoQAAgAAABmbG9hdGluZyBwb2ludCBgYAAAAHTeEAAQAAAAhN4QAAEAAABudWxsJwUQAHsAAAC9BAAAJAAAAIgAAAAMAAAABAAAAIkAAACKAAAAhgAAAP///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////wAAAQACAAMABAAFAAYABwAIAAkA//////////////////8KAAsADAANAA4ADwD/////////////////////////////////////////////////////////////////////CgALAAwADQAOAA8A////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////AAAQACAAMABAAFAAYABwAIAAkAD//////////////////6AAsADAANAA4ADwAP////////////////////////////////////////////////////////////////////+gALAAwADQAOAA8AD///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8ODBAAawAAALMBAAAaAAAADgwQAGsAAAAAAgAAEwAAAA4MEABrAAAABQIAADMAAAAODBAAawAAAAkCAAA+AAAADgwQAGsAAAAPAgAAOgAAAA4MEABrAAAAqwEAAD0AAAAODBAAawAAAKYBAABFAAAADgwQAGsAAABuAgAAGQAAAGluZi1pbmZOYU51dXV1dXV1dWJ0bnVmcnV1dXV1dXV1dXV1dXV1dXV1dQAAIgBBqsfDAAsBXABBzsjDAAvlATAxMjM0NTY3ODlhYmNkZWZhIEpTT04gbnVtYmVyMDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5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ZyBwb2ludCBgcA8RABAAAAA4DxEAAQAAAGNoYXJhY3RlciBgAJAPEQALAAAAOA8RAAEAAABzdHJpbmcgAKwPEQAHAAAAYnl0ZSBhcnJheXVuaXQgdmFsdWVPcHRpb24gdmFsdWVuZXd0eXBlIHN0cnVjdHNlcXVlbmNlbWFwZW51bXVuaXQgdmFyaWFudG5ld3R5cGUgdmFyaWFudHR1cGxlIHZhcmlhbnRzdHJ1Y3QgdmFyaWFudAABAAAAAAAAAC4wAAAAAAAACAAAAAQAAACRAAAAkgAAAJMAAABhIHN0cmluZ3z9izJX5lf5At9Ev+NI569tXcvWLFDrY3hBpldxG4u5AQAAAAAAAABlbnRpdHkgbm90IGZvdW5kcGVybWlzc2lvbiBkZW5pZWRjb25uZWN0aW9uIHJlZnVzZWRjb25uZWN0aW9uIHJlc2V0aG9zdCB1bnJlYWNoYWJsZW5ldHdvcmsgdW5yZWFjaGFibGVjb25uZWN0aW9uIGFib3J0ZWRub3QgY29ubmVjdGVkYWRkcmVzcyBpbiB1c2VhZGRyZXNzIG5vdCBhdmFpbGFibGVuZXR3b3JrIGRvd25icm9rZW4gcGlwZWVudGl0eSBhbHJlYWR5IGV4aXN0c29wZXJhdGlvbiB3b3VsZCBibG9ja25vdCBhIGRpcmVjdG9yeWlzIGEgZGlyZWN0b3J5ZGlyZWN0b3J5IG5vdCBlbXB0eXJlYWQtb25seSBmaWxlc3lzdGVtIG9yIHN0b3JhZ2UgbWVkaXVtZmlsZXN5c3RlbSBsb29wIG9yIGluZGlyZWN0aW9uIGxpbWl0IChlLmcuIHN5bWxpbmsgbG9vcClzdGFsZSBuZXR3b3JrIGZpbGUgaGFuZGxlaW52YWxpZCBpbnB1dCBwYXJhbWV0ZXJpbnZhbGlkIGRhdGF0aW1lZCBvdXR3cml0ZSB6ZXJvbm8gc3RvcmFnZSBzcGFjZXNlZWsgb24gdW5zZWVrYWJsZSBmaWxlcXVvdGEgZXhjZWVkZWRmaWxlIHRvbyBsYXJnZXJlc291cmNlIGJ1c3lleGVjdXRhYmxlIGZpbGUgYnVzeWRlYWRsb2NrY3Jvc3MtZGV2aWNlIGxpbmsgb3IgcmVuYW1ldG9vIG1hbnkgbGlua3NpbnZhbGlkIGZpbGVuYW1lYXJndW1lbnQgbGlz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";
async function rQ() {
  const A = await (await fetch(Og)).arrayBuffer();
  return await Tg({ module_or_path: A });
}
function nQ(t) {
  if (typeof Buffer < "u")
    return Buffer.from(t, "base64").buffer;
  if (typeof globalThis < "u" && typeof globalThis.atob == "function") {
    const A = globalThis.atob(t), e = new Uint8Array(A.length);
    for (let i = 0; i < A.length; i++) e[i] = A.charCodeAt(i);
    return e.buffer;
  }
  throw new Error("Unable to decode base64 WASM payload: no atob() or Buffer available.");
}
function sQ() {
  const t = Og.split(",")[1], A = nQ(t);
  return oQ({ module: A });
}
function Pg() {
  return (
    // @ts-ignore
    !!(typeof navigator < "u" && // @ts-ignore
    navigator?.userAgent?.includes("Cloudflare"))
  );
}
const aQ = () => {
  if (Pg())
    return !1;
  try {
    const t = Function;
    return new t(""), !0;
  } catch {
    return !1;
  }
};
let jg = rQ, us = sQ;
const Vg = (t) => `Critical Error: Failed to load WASM module

${aQ() ? t.message : `You need to add \`import "jazz-tools/load-edge-wasm";\` on top of your entry module to make Jazz work with ${Pg() ? "Cloudflare workers" : "this runtime"}`}

A native crypto module is required for Jazz to work. See https://jazz.tools/docs/react/reference/performance#use-the-best-crypto-implementation-for-your-platform for possible alternatives.`;
async function gQ() {
  try {
    await jg();
  } catch (t) {
    throw new Error(Vg(t), { cause: t });
  }
}
class Ie extends RC {
  constructor() {
    super();
  }
  static setInit(A) {
    jg = A;
  }
  static setInitSync(A) {
    us = A;
  }
  static createSync() {
    try {
      us();
    } catch (A) {
      throw new Error(Vg(A), { cause: A });
    }
    return new Ie();
  }
  // TODO: Remove this method and use createSync instead, this is not necessary since we can use createSync in the browser and in the worker.
  // @deprecated
  static async create() {
    return await gQ(), new Ie();
  }
  blake3HashOnce(A) {
    return WB(A);
  }
  blake3HashOnceWithContext(A, { context: e }) {
    return zB(A, e);
  }
  newEd25519SigningKey() {
    return PB();
  }
  getSignerID(A) {
    return jB(SA.encode(A));
  }
  sign(A, e) {
    return VB(SA.encode(LA(e)), SA.encode(A));
  }
  verify(A, e, i) {
    return $B(SA.encode(A), SA.encode(LA(e)), SA.encode(i));
  }
  newX25519StaticSecret() {
    return tQ();
  }
  getSealerID(A) {
    return eQ(SA.encode(A));
  }
  encrypt(A, e, i) {
    return `encrypted_U${lr(XB(SA.encode(LA(A)), e, SA.encode(LA(i))))}`;
  }
  decryptRaw(A, e, i) {
    return es.decode(AQ(Er(A.substring(11)), e, SA.encode(LA(i))));
  }
  seal({ message: A, from: e, to: i, nOnceMaterial: o }) {
    return `sealed_U${lr(ZB(SA.encode(LA(A)), e, i, SA.encode(LA(o))))}`;
  }
  unseal(A, e, i, o) {
    const r = es.decode(_B(Er(A.substring(8)), e, i, SA.encode(LA(o))));
    try {
      return JSON.parse(r);
    } catch (n) {
      AA.error("Failed to decrypt/parse sealed message", { err: n });
      return;
    }
  }
  createSessionLog(A, e, i) {
    return new Qn(new Io(A, e, i));
  }
}
class Qn {
  constructor(A) {
    this.sessionLog = A;
  }
  tryAdd(A, e, i) {
    for (const o of A)
      o.privacy === "private" ? this.sessionLog.addExistingPrivateTransaction(o.encryptedChanges, o.keyUsed, o.madeAt, o.meta) : this.sessionLog.addExistingTrustingTransaction(o.changes, o.madeAt, o.meta);
    this.sessionLog.commitTransactions(e, i);
  }
  addNewPrivateTransaction(A, e, i, o, r, n) {
    const s = this.sessionLog.addNewPrivateTransaction(
      // We can avoid stableStringify because it will be encrypted.
      JSON.stringify(e),
      A.currentSignerSecret(),
      o,
      i,
      r,
      // We can avoid stableStringify because it will be encrypted.
      n ? JSON.stringify(n) : void 0
    ), a = JSON.parse(s), g = {
      privacy: "private",
      madeAt: r,
      encryptedChanges: a.encrypted_changes,
      keyUsed: i,
      meta: a.meta
    };
    return { signature: a.signature, transaction: g };
  }
  addNewTrustingTransaction(A, e, i, o) {
    const r = JSON.stringify(e), n = o ? JSON.stringify(o) : void 0;
    return { signature: this.sessionLog.addNewTrustingTransaction(r, A.currentSignerSecret(), i, n), transaction: {
      privacy: "trusting",
      madeAt: i,
      changes: r,
      meta: n
    } };
  }
  decryptNextTransactionChangesJson(A, e) {
    return this.sessionLog.decryptNextTransactionChangesJson(A, e);
  }
  decryptNextTransactionMetaJson(A, e) {
    return this.sessionLog.decryptNextTransactionMetaJson(A, e);
  }
  free() {
    this.sessionLog.free();
  }
  clone() {
    return new Qn(this.sessionLog.clone());
  }
}
const $g = { comap: { description: "CoMap - CRDT-based collaborative map/object", type: "object", properties: {}, additionalProperties: { anyOf: [{ type: "string", description: "Standard string value" }, { type: "number", description: "Standard number value" }, { type: "integer", description: "Standard integer value" }, { type: "boolean", description: "Standard boolean value" }, { type: "null", description: "Null value" }, { type: "object", description: "Nested object value" }, { type: "array", description: "Array value" }, { type: "string", pattern: "^co_z[a-zA-Z0-9]+$", description: "Co-id reference to another CoValue" }, { type: "string", pattern: "^key_[a-zA-Z0-9_]+$", description: "Key reference" }, { type: "string", pattern: "^sealed_", description: "Sealed/encrypted value" }] } }, costream: { description: "CoStream - CRDT-based append-only stream", type: "array", items: { anyOf: [{ type: "object", description: "Stream item object" }, { type: "string", description: "Stream item string" }, { type: "number", description: "Stream item number" }, { type: "boolean", description: "Stream item boolean" }, { type: "null", description: "Stream item null" }] } }, colist: { description: "CoList - CRDT-based collaborative list/array", type: "array", items: { anyOf: [{ type: "object", description: "List item object" }, { type: "string", description: "List item string (can be co-id reference)" }, { type: "number", description: "List item number" }, { type: "integer", description: "List item integer" }, { type: "boolean", description: "List item boolean" }, { type: "null", description: "List item null" }, { type: "array", description: "Nested array" }] } } }, Ot = {
  $defs: $g
}, IQ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  $defs: $g,
  default: Ot
}, Symbol.toStringTag, { value: "Module" }));
let wA = class {
  constructor(A) {
    this._value = A, this._subscribers = /* @__PURE__ */ new Set(), this._unsubscribe = null;
  }
  /**
   * Get current value
   * @returns {any} Current store value
   */
  get value() {
    return this._value;
  }
  /**
   * Subscribe to value changes
   * Callback is called immediately with current value, then on every update
   * Automatically calls _unsubscribe() when the last subscriber unsubscribes
   * @param {Function} callback - Function called with new value
   * @param {Object} [options] - Subscription options
   * @param {boolean} [options.skipInitial=false] - If true, don't call callback immediately with current value
   * @returns {Function} Unsubscribe function
   */
  subscribe(A, e = {}) {
    return this._subscribers.add(A), e.skipInitial || A(this._value), () => {
      this._subscribers.delete(A), this._subscribers.size === 0 && this._unsubscribe && this._unsubscribe();
    };
  }
  /**
   * Internal method to update store value
   * Notifies all subscribers of the change
   * @param {any} newValue - New value to set
   * @private
   */
  _set(A) {
    this._value = A, this._subscribers.forEach((e) => e(A));
  }
};
async function cQ(t, A) {
  return !A || typeof A != "string" ? null : await eA(t, A, { returnType: "coId" });
}
async function En(t, A) {
  const e = await cQ(t, A);
  if (!e)
    return console.warn(`[getSchemaIndexColistId]  Failed to resolve schema "${A.substring(0, 30)}..." to co-id`), null;
  const { getSparkOsId: i } = await Promise.resolve().then(() => ce), o = t?.systemSpark ?? "@maia", r = await i(t, o);
  if (!r)
    return console.warn("[getSchemaIndexColistId]  spark.os not found"), null;
  const n = await nA(t, r);
  if (!n || !t.isAvailable(n))
    return console.warn(`[getSchemaIndexColistId]  spark.os not available (loaded: ${!!n}, available: ${n ? t.isAvailable(n) : !1})`), null;
  const s = t.getCurrentContent(n);
  if (!s || typeof s.get != "function")
    return console.warn("[getSchemaIndexColistId]  spark.os content not available"), null;
  const a = s.get("indexes");
  if (!a)
    return console.warn("[getSchemaIndexColistId]  spark.os.indexes not found"), null;
  const g = await nA(t, a);
  if (!g || !t.isAvailable(g))
    return console.warn(`[getSchemaIndexColistId]  spark.os.indexes not available (loaded: ${!!g}, available: ${g ? t.isAvailable(g) : !1})`), null;
  const I = t.getCurrentContent(g);
  if (!I || typeof I.get != "function")
    return console.warn("[getSchemaIndexColistId]  spark.os.indexes content not available"), null;
  let c = I.get(e);
  if (c && typeof c == "string" && c.startsWith("co_"))
    return c;
  try {
    const { ensureSchemaIndexColist: C } = await Promise.resolve().then(() => DI), B = await C(t, e);
    return B && B.id ? B.id : null;
  } catch {
    return null;
  }
}
async function po(t, A) {
  if (!A || typeof A != "string")
    return null;
  const e = /^@[a-zA-Z0-9_-]+\/schema\//.test(A);
  return !A.startsWith("co_z") && !e ? (console.warn(`[getCoListId]  Invalid collection identifier: "${A}". Must be schema co-id (co_z...) or namekey (@domain/schema/...). Use schema registry to resolve collection names.`), null) : await En(t, A);
}
async function nA(t, A, e = {}) {
  const { waitForAvailable: i = !1, timeoutMs: o = 2e3 } = e;
  if (!A || !A.startsWith("co_"))
    return null;
  const r = t.getCoValue(A);
  return r ? (r.isAvailable() || (t.node.loadCoValueCore(A).catch((n) => {
    console.error(`[CoJSONBackend] Failed to load CoValue ${A}:`, n);
  }), i && await new Promise((n, s) => {
    let a;
    const g = setTimeout(() => {
      console.warn(`[CoJSONBackend] Timeout waiting for CoValue ${A} to load`), a(), s(new Error(`Timeout waiting for CoValue ${A} to load after ${o}ms`));
    }, o);
    a = r.subscribe((I) => {
      I.isAvailable() && (clearTimeout(g), a(), n());
    });
  })), r) : null;
}
const CQ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ensureCoValueLoaded: nA,
  getCoListId: po,
  getSchemaIndexColistId: En
}, Symbol.toStringTag, { value: "Module" }));
function ln(t, A, e = null) {
  const i = t.getCurrentContent(A), o = t.getHeader(A), r = o?.meta || null, n = A.ruleset || o?.ruleset, s = i?.type || "unknown";
  let a = r?.$schema || null;
  if (e === "@group" || n && n.type === "group" ? a = "@group" : e === "@account" || r && r.type === "account" ? a = "@account" : (e === "@metaSchema" || a === "@metaSchema") && (a = "@metaSchema"), s === "colist" && i && i.toJSON)
    try {
      const g = i.toJSON();
      return {
        id: A.id,
        $schema: a,
        // Use $schema for consistency with headerMeta.$schema
        type: "colist",
        items: g
        // Items ARE the CoList content (not a property)
        // No properties array - CoLists don't have custom key-value properties, only items
      };
    } catch {
      return {
        id: A.id,
        $schema: a,
        // Use $schema for consistency with headerMeta.$schema
        type: "colist",
        items: []
      };
    }
  else if (s === "costream" && i)
    try {
      const g = i.toJSON(), I = [];
      if (g && typeof g == "object" && !(g instanceof Uint8Array))
        for (const c in g)
          Array.isArray(g[c]) && I.push(...g[c]);
      return console.log(`[CoJSONBackend]  Read CoStream ${A.id} (${I.length} items)`), I.length > 0 ? console.log("[CoJSONBackend]   First item:", JSON.stringify(I[0]).substring(0, 100)) : (console.log("[CoJSONBackend]   Stream data type:", typeof g, g instanceof Uint8Array ? "Uint8Array" : "object"), g && typeof g == "object" && !(g instanceof Uint8Array) && (console.log("[CoJSONBackend]   Session keys:", Object.keys(g)), console.log("[CoJSONBackend]   Session counts:", Object.fromEntries(Object.entries(g).map(([c, C]) => [c, Array.isArray(C) ? C.length : "not array"]))))), {
        id: A.id,
        schema: a,
        type: "costream",
        items: I
        // Items ARE the CoStream content (not a property)
        // No properties array - CoStreams don't have custom key-value properties, only items
      };
    } catch (g) {
      return console.error(`[CoJSONBackend]  Error reading CoStream ${A.id.substring(0, 12)}...:`, g), {
        id: A.id,
        $schema: a,
        // Use $schema for consistency with headerMeta.$schema
        type: "costream",
        items: []
      };
    }
  else if (i && i.get && typeof i.get == "function") {
    const g = r?.type || null, I = {
      id: A.id,
      // Always add id field (derived from co-id)
      $schema: a,
      // Use $schema for consistency with headerMeta.$schema
      type: s,
      // Add type for DB viewer
      displayName: g === "account" ? "Account" : a || "CoMap",
      // Display name for DB viewer
      properties: []
      // Properties array for DB viewer
    };
    g && (I.headerMeta = { type: g });
    const c = i.keys && typeof i.keys == "function" ? i.keys() : Object.keys(i);
    for (const C of c)
      try {
        const B = i.get && typeof i.get == "function" ? i.get(C) : i[C];
        let Q = typeof B, f = B;
        typeof B == "string" && B.startsWith("co_") ? Q = "co-id" : typeof B == "string" && B.startsWith("key_") ? Q = "key" : typeof B == "string" && B.startsWith("sealed_") ? (Q = "sealed", f = "sealed_***") : B === null ? Q = "null" : B === void 0 ? Q = "undefined" : typeof B == "object" && B !== null ? (Q = "object", f = JSON.stringify(B)) : Array.isArray(B) && (Q = "array", f = JSON.stringify(B)), I.properties.push({
          key: C,
          value: f,
          type: Q
        });
      } catch (B) {
        I.properties.push({
          key: C,
          value: `<error: ${B.message}>`,
          type: "error"
        });
      }
    return I;
  }
  return {
    id: A.id,
    type: s,
    $schema: a,
    headerMeta: r
  };
}
function Ft(t) {
  if (typeof t == "string" && (t.startsWith("{") || t.startsWith("[")))
    try {
      const A = JSON.parse(t);
      return Ft(A);
    } catch {
      return t;
    }
  else {
    if (Array.isArray(t))
      return t.map((A) => Ft(A));
    if (typeof t == "object" && t !== null) {
      const A = {};
      for (const [e, i] of Object.entries(t))
        A[e] = Ft(i);
      return A;
    }
  }
  return t;
}
function $A(t, A, e = null) {
  const i = t.getHeader(A), o = i?.meta || null;
  A.ruleset || i?.ruleset;
  const r = e === "@account" || o && o.type === "account" || t.account && t.account.id === A.id;
  if (r && t.account && t.account.id === A.id) {
    const C = (t.getHeader(A)?.meta || null)?.$schema || null, B = {
      id: t.account.id,
      type: "comap",
      // Accounts are CoMaps
      $schema: C
      // Include $schema for metadata lookup
    };
    try {
      const Q = t.account.keys && typeof t.account.keys == "function" ? t.account.keys() : Object.keys(t.account);
      for (const f of Q)
        try {
          B[f] = t.account.get(f);
        } catch (l) {
          console.warn(`[CoJSONBackend] Failed to read account key ${f}:`, l);
        }
    } catch (Q) {
      console.warn("[CoJSONBackend] Failed to extract account keys:", Q);
    }
    return B;
  }
  const n = t.getCurrentContent(A);
  if (!n) {
    if (r && t.account && t.account.id === A.id) {
      const f = (t.getHeader(A)?.meta || null)?.$schema || null, l = {
        id: t.account.id,
        type: "comap",
        $schema: f
      };
      try {
        const u = t.account.keys && typeof t.account.keys == "function" ? t.account.keys() : Object.keys(t.account);
        for (const d of u)
          l[d] = t.account.get(d);
      } catch {
      }
      return l;
    }
    const C = (t.getHeader(A)?.meta || null)?.$schema || null;
    return {
      id: A.id,
      type: "unknown",
      $schema: C
    };
  }
  const s = n?.type || "unknown", a = o?.$schema || null;
  if (s === "colist" && n && n.toJSON)
    try {
      const I = n.toJSON(), c = {
        id: A.id,
        cotype: "colist",
        type: "colist",
        $schema: a,
        items: I
      };
      try {
        if (typeof t.getGroupInfo == "function") {
          const C = t.getGroupInfo(A);
          C && (c.groupInfo = C);
        }
      } catch {
      }
      return c;
    } catch {
      const c = {
        id: A.id,
        cotype: "colist",
        type: "colist",
        $schema: a,
        items: []
      };
      try {
        if (typeof t.getGroupInfo == "function") {
          const C = t.getGroupInfo(A);
          C && (c.groupInfo = C);
        }
      } catch {
      }
      return c;
    }
  if (s === "costream" && n)
    try {
      const I = n.toJSON(), c = [];
      if (I && typeof I == "object" && !(I instanceof Uint8Array))
        for (const B in I)
          Array.isArray(I[B]) && c.push(...I[B]);
      const C = {
        id: A.id,
        cotype: "costream",
        type: "costream",
        $schema: a,
        items: c
      };
      try {
        if (typeof t.getGroupInfo == "function") {
          const B = t.getGroupInfo(A);
          B && (C.groupInfo = B);
        }
      } catch {
      }
      return C;
    } catch (I) {
      console.error(`[CoJSONBackend] Error extracting CoStream ${A.id.substring(0, 12)}...:`, I);
      const c = {
        id: A.id,
        cotype: "costream",
        type: "costream",
        $schema: a,
        items: []
      };
      try {
        if (typeof t.getGroupInfo == "function") {
          const C = t.getGroupInfo(A);
          C && (c.groupInfo = C);
        }
      } catch {
      }
      return c;
    }
  if (n && n.get && typeof n.get == "function") {
    const I = n.get("cotype") || s, c = {
      id: A.id,
      cotype: I === "comap" ? "comap" : I,
      type: s,
      // Keep for backward compat; DB viewer prefers cotype
      $schema: a
    }, C = n.keys && typeof n.keys == "function" ? n.keys() : Object.keys(n);
    for (const B of C) {
      let Q = n.get(B);
      (B === "allMessages" || a && a.includes("context")) && console.log(`[extractCoValueDataFlat]  Raw value for key "${B}":`, {
        type: typeof Q,
        isString: typeof Q == "string",
        isObject: typeof Q == "object" && Q !== null,
        startsWithBrace: typeof Q == "string" && Q.startsWith("{"),
        valueSample: typeof Q == "string" ? Q.substring(0, 200) : typeof Q == "object" ? JSON.stringify(Q).substring(0, 200) : Q,
        hasOptions: typeof Q == "object" && Q !== null ? "options" in Q : !1,
        optionsType: typeof Q == "object" && Q !== null && "options" in Q ? typeof Q.options : "N/A"
      });
      const f = ["error", "message", "content", "addAgentError"];
      if (typeof Q == "string" && (Q.startsWith("{") || Q.startsWith("[")) && !f.includes(B))
        try {
          const l = JSON.parse(Q);
          console.log(`[extractCoValueDataFlat]  Parsed JSON string for "${B}":`, {
            parsedType: typeof l,
            parsedKeys: typeof l == "object" && l !== null ? Object.keys(l) : [],
            hasOptions: typeof l == "object" && l !== null ? "options" in l : !1,
            optionsType: typeof l == "object" && l !== null && "options" in l ? typeof l.options : "N/A",
            parsedSample: JSON.stringify(l).substring(0, 300)
          }), Q = Ft(l), console.log(`[extractCoValueDataFlat]  After recursive parse for "${B}":`, {
            finalType: typeof Q,
            finalKeys: typeof Q == "object" && Q !== null ? Object.keys(Q) : [],
            hasOptions: typeof Q == "object" && Q !== null ? "options" in Q : !1,
            optionsKeys: typeof Q == "object" && Q !== null && "options" in Q && typeof Q.options == "object" ? Object.keys(Q.options) : [],
            hasMap: typeof Q == "object" && Q !== null && "options" in Q && typeof Q.options == "object" ? "map" in Q.options : !1,
            finalSample: JSON.stringify(Q).substring(0, 400)
          });
        } catch (l) {
          console.warn(`[extractCoValueDataFlat] Failed to parse JSON string for "${B}":`, l);
        }
      else if (typeof Q == "object" && Q !== null && !Array.isArray(Q)) {
        if (B === "allMessages" || a && a.includes("context")) {
          const d = "options" in Q, h = d ? typeof Q.options : "N/A", p = d && typeof Q.options == "string" && (Q.options.startsWith("{") || Q.options.startsWith("["));
          console.log(`[extractCoValueDataFlat]  Before recursive parse for "${B}":`, {
            hasOptions: d,
            optionsType: h,
            optionsIsString: p,
            optionsValue: d ? typeof Q.options == "string" ? Q.options.substring(0, 200) : JSON.stringify(Q.options).substring(0, 200) : "N/A",
            allKeys: Object.keys(Q)
          });
        }
        const l = JSON.stringify(Q).substring(0, 200);
        Q = Ft(Q);
        const u = JSON.stringify(Q).substring(0, 200);
        if (B === "allMessages" || a && a.includes("context")) {
          const d = "options" in Q, h = d ? typeof Q.options : "N/A", p = d && typeof Q.options == "object" && Q.options !== null ? "map" in Q.options : !1;
          console.log(`[extractCoValueDataFlat]  After recursive parse for "${B}":`, {
            hasOptions: d,
            optionsType: h,
            hasMap: p,
            optionsKeys: d && typeof Q.options == "object" && Q.options !== null ? Object.keys(Q.options) : [],
            mapKeys: p ? Object.keys(Q.options.map) : [],
            changed: l !== u,
            finalSample: JSON.stringify(Q).substring(0, 400)
          });
        }
      }
      c[B] = Q;
    }
    try {
      if (typeof t.getGroupInfo == "function") {
        const B = t.getGroupInfo(A);
        B && (c.groupInfo = B);
      }
    } catch (B) {
      console.warn("[extractCoValueDataFlat] Failed to get group info:", B);
    }
    return c;
  }
  const g = {
    id: A.id,
    type: s,
    $schema: a
  };
  try {
    if (typeof t.getGroupInfo == "function") {
      const I = t.getGroupInfo(A);
      I && (g.groupInfo = I);
    }
  } catch {
  }
  return g;
}
async function BQ(t, A, e = {}, i = /* @__PURE__ */ new Set()) {
  const { timeoutMs: o = 2e3 } = e;
  if (i.has(A)) return { id: A };
  i.add(A);
  try {
    await nA(t, A, { waitForAvailable: !0, timeoutMs: o });
    const r = t.getCoValue(A);
    if (!r || !t.isAvailable(r)) return { id: A };
    let n = $A(t, r);
    n = { ...n, id: n.id || A };
    const s = t.getHeader(r), a = r.ruleset || s?.ruleset;
    if (a && a.type === "group") {
      const g = t.getCurrentContent(r);
      if (g && typeof g.addMember == "function") {
        const { getGroupInfoFromGroup: I } = await Promise.resolve().then(() => ce), c = I(g);
        c && Object.assign(n, {
          accountMembers: c.accountMembers || [],
          groupMembers: c.groupMembers || [],
          id: c.groupId || n.id
        });
      }
    }
    return n;
  } catch {
    return { id: A };
  }
}
async function Jt(t, A, e = {}, i = /* @__PURE__ */ new Set(), o = 15, r = 0) {
  const { fields: n = null, schemas: s = null, timeoutMs: a = 2e3 } = e;
  if (r > o || A == null)
    return A;
  if (typeof A != "object")
    return typeof A == "string" && A.startsWith("co_z") ? await hs(t, A, e, i, o, r) : A;
  if (Array.isArray(A))
    return Promise.all(A.map(
      (I) => Jt(t, I, e, i, o, r + 1)
    ));
  const g = {};
  for (const [I, c] of Object.entries(A)) {
    if (I === "id" || I === "$schema" || I === "type" || I === "loading" || I === "error") {
      g[I] = c;
      continue;
    }
    const C = n === null || n.includes(I);
    if (c == null) {
      g[I] = c;
      continue;
    }
    if (C && typeof c == "string" && c.startsWith("co_z")) {
      const B = await hs(t, c, { ...e, timeoutMs: a, maxDepth: o, currentDepth: r }, i, o, r + 1);
      g[I] = B;
    } else
      g[I] = await Jt(t, c, e, i, o, r + 1);
  }
  return g;
}
async function hs(t, A, e = {}, i = /* @__PURE__ */ new Set(), o = 15, r = 0) {
  const { schemas: n = null, timeoutMs: s = 2e3 } = e;
  if (i.has(A))
    return { id: A };
  const a = t.subscriptionCache, g = {
    deepResolve: !1,
    // We don't need deep resolution here
    resolveReferences: e,
    // Use the same resolution options
    map: null,
    // No map transform in resolveCoId
    maxDepth: o,
    timeoutMs: s
  }, I = a.getResolvedData(A, g);
  if (I) {
    if (n !== null && n.length > 0) {
      const c = I.$schema;
      if (!n.includes(c))
        return { id: A };
    }
    return I;
  }
  try {
    const { waitForStoreReady: c } = await Promise.resolve().then(() => hQ), C = await t.read(null, A, null, null, {
      deepResolve: !1,
      // Don't deep resolve here - we'll resolve nested refs ourselves
      timeoutMs: s
    });
    if (!C)
      return console.warn(`[resolveCoId] No store returned for ${A.substring(0, 12)}...`), { id: A };
    try {
      await c(C, A, s);
    } catch (u) {
      return console.warn(`[resolveCoId] Store not ready for ${A.substring(0, 12)}...:`, u.message), { id: A };
    }
    const B = C.value;
    if (!B)
      return console.warn(`[resolveCoId] No data in store for ${A.substring(0, 12)}...`), { id: A };
    if (B.error)
      return console.warn(`[resolveCoId] Store has error for ${A.substring(0, 12)}...:`, B.error), { id: A, error: B.error };
    if (typeof B != "object" || Array.isArray(B))
      return console.warn(`[resolveCoId] Invalid data type for ${A.substring(0, 12)}...:`, typeof B), { id: A };
    if (n !== null && n.length > 0) {
      const u = B.$schema;
      if (!n.includes(u))
        return { id: A };
    }
    i.add(A);
    const Q = await Jt(
      t,
      B,
      e,
      i,
      o,
      r + 1
    ), f = t.getCoValue(A);
    if (f) {
      const u = t.getHeader(f), d = f.ruleset || u?.ruleset;
      if (d && d.type === "group") {
        const h = t.getCurrentContent(f);
        if (h && typeof h.addMember == "function") {
          const { getGroupInfoFromGroup: p } = await Promise.resolve().then(() => ce), E = p(h);
          E && Object.assign(Q, {
            accountMembers: E.accountMembers || [],
            groupMembers: E.groupMembers || []
          });
        }
      }
    }
    const l = {
      ...Q,
      id: Q.id || B.id || A
    };
    return a.setResolvedData(A, g, l), l;
  } catch (c) {
    return console.error(`[resolveCoId]  Error resolving ${A.substring(0, 12)}...:`, c), { id: A };
  }
}
function QQ(t, A) {
  const e = t.getCurrentContent(A), o = t.getHeader(A)?.meta || null;
  if ((e?.type || "unknown") !== "costream" || !e)
    return null;
  if (e.items && typeof e.items == "object") {
    const n = {};
    for (const [s, a] of Object.entries(e.items))
      Array.isArray(a) && (n[s] = a.map((g) => typeof g.value == "string" && g.value.startsWith("co_z") ? {
        _coId: g.value,
        // Message CoMap co-id (native co-id)
        _sessionID: s,
        // Internal metadata: session ID
        _madeAt: g.madeAt,
        // Internal metadata: CRDT madeAt timestamp
        _tx: g.tx
        // Internal metadata: transaction ID
      } : {
        ...g.value,
        // Message data (type, payload, from, id)
        _sessionID: s,
        // Internal metadata: session ID
        _madeAt: g.madeAt,
        // Internal metadata: CRDT madeAt timestamp
        _tx: g.tx
        // Internal metadata: transaction ID
      }));
    return {
      id: A.id,
      type: "costream",
      $schema: o?.$schema || null,
      sessions: n
      // Preserve session structure: { sessionID: [messages...] }
    };
  }
  return {
    id: A.id,
    type: "costream",
    $schema: o?.$schema || null,
    sessions: {}
  };
}
function EQ(t) {
  if (!t) return null;
  const A = t.type || "unknown", e = {};
  if (t.get && typeof t.get == "function") {
    const o = t.keys && typeof t.keys == "function" ? t.keys() : Object.keys(t);
    for (const r of o)
      e[r] = t.get(r);
  } else {
    const o = Object.keys(t);
    for (const r of o)
      e[r] = t[r];
  }
  let i = null;
  if (A === "colist" && t.toJSON)
    try {
      i = t.toJSON();
    } catch {
    }
  return {
    id: t.id,
    type: A,
    properties: e,
    items: i,
    content: t
  };
}
function dn(t, A) {
  if (Array.isArray(t))
    return t.some((e) => {
      for (const [i, o] of Object.entries(A))
        if (e[i] !== o)
          return !1;
      return !0;
    });
  if (t && typeof t == "object") {
    for (const [e, i] of Object.entries(A))
      if (t[e] !== i)
        return !1;
    return !0;
  }
  return !1;
}
class Sr {
  /**
   * Create a new unified cache
   * 
   * @param {number} cleanupTimeout - Time in ms before cleaning up unused entries (default: 5000)
   */
  constructor(A = 5e3) {
    this.cache = /* @__PURE__ */ new Map(), this.cleanupTimeout = A, this.cleanupTimers = /* @__PURE__ */ new Map();
  }
  /**
   * Get existing entry or create new one (unified getOrCreate for all types)
   * 
   * @param {string} key - Cache key (MUST be namespaced: `subscription:${id}`, `store:${key}`, etc.)
   * @param {Function} factory - Function that creates new entry
   * @returns {any} Cached or newly created entry
   */
  getOrCreate(A, e) {
    const i = this.cache.get(A);
    if (i)
      return this.cancelCleanup(A), i;
    const o = e();
    return this._maybeWarnSubscriptionBuildup(), this.cache.set(A, o), o;
  }
  /**
   * Get existing subscription or create new one (backward compatibility)
   * 
   * @param {string} id - CoValue ID
   * @param {Function} factory - Function that creates new subscription
   * @returns {Object} Subscription object
   */
  getOrCreateSubscription(A, e) {
    return this.getOrCreate(`subscription:${A}`, e);
  }
  /**
   * Get existing store or create new one
   * 
   * @param {string} key - Store cache key (schema+filter+options)
   * @param {Function} factory - Function that creates new ReactiveStore
   * @returns {ReactiveStore} ReactiveStore instance
   */
  getOrCreateStore(A, e) {
    return this.getOrCreate(`store:${A}`, e);
  }
  /**
   * Get existing resolution promise or create new one
   * 
   * @param {string} coId - CoValue ID
   * @param {Function} factory - Function that creates resolution Promise
   * @returns {Promise|true} Resolution promise or true if already resolved
   */
  getOrCreateResolution(A, e) {
    const i = `resolution:${A}`, o = this.cache.get(i);
    if (o === !0)
      return !0;
    if (o && typeof o.then == "function")
      return o;
    const r = e();
    return this.cache.set(i, r), r;
  }
  /**
   * Mark resolution as completed
   * 
   * @param {string} coId - CoValue ID
   */
  markResolved(A) {
    this.cache.set(`resolution:${A}`, !0);
  }
  /**
   * Check if CoValue is already resolved or being resolved
   * 
   * @param {string} coId - CoValue ID
   * @returns {boolean} True if already resolved or being resolved
   */
  isResolved(A) {
    const e = this.cache.get(`resolution:${A}`);
    return e === !0 || e && typeof e.then == "function";
  }
  /**
   * Get cached resolved+mapped data
   * 
   * @param {string} coId - CoValue ID
   * @param {Object} options - Options object (for cache key)
   * @returns {any|null} Cached resolved data or null
   */
  getResolvedData(A, e) {
    const i = `resolved:${A}:${JSON.stringify(e || {})}`, o = this.cache.get(i);
    return o && typeof o.then == "function" ? null : o || null;
  }
  /**
   * Get or create resolved data (prevents concurrent processing)
   * 
   * @param {string} coId - CoValue ID
   * @param {Object} options - Options object (for cache key)
   * @param {Function} factory - Async function that creates/resolves the data
   * @returns {Promise<any>} Resolved data (from cache or factory)
   */
  async getOrCreateResolvedData(A, e, i) {
    const o = `resolved:${A}:${JSON.stringify(e || {})}`;
    let r = this.cache.get(o);
    if (r && typeof r.then != "function")
      return r;
    if (r && typeof r.then == "function")
      try {
        return await r;
      } catch {
        this.cache.delete(o);
      }
    const n = (async () => {
      try {
        const s = await i();
        return this.cache.set(o, s), s;
      } catch (s) {
        throw this.cache.delete(o), s;
      }
    })();
    return this.cache.set(o, n), n;
  }
  /**
   * Cache resolved+mapped data
   * 
   * @param {string} coId - CoValue ID
   * @param {Object} options - Options object (for cache key)
   * @param {any} data - Resolved+mapped data to cache
   */
  setResolvedData(A, e, i) {
    const o = `resolved:${A}:${JSON.stringify(e || {})}`;
    this.cache.set(o, i);
  }
  /**
   * Invalidate all cached resolved data for a CoValue
   * Used when CoValue changes to force re-processing
   * 
   * @param {string} coId - CoValue ID
   */
  invalidateResolvedData(A) {
    const e = `resolved:${A}:`, i = [];
    for (const o of this.cache.keys())
      o.startsWith(e) && i.push(o);
    for (const o of i)
      this.cache.delete(o);
  }
  /**
   * Schedule cleanup for unused entry
   * 
   * @param {string} key - Cache key (MUST be namespaced)
   */
  scheduleCleanup(A) {
    this.cancelCleanup(A);
    const e = setTimeout(() => {
      this.destroy(A), this._maybeLogStats();
    }, this.cleanupTimeout);
    this.cleanupTimers.set(A, e);
  }
  /**
   * Debug: Log cache stats when window._maiaDebugSubscriptions is true
   * Helps diagnose subscription buildup / vibe freeze issues
   * @private
   */
  _maybeLogStats() {
    if (typeof window < "u" && window._maiaDebugSubscriptions) {
      const A = Array.from(this.cache.keys()).filter((i) => i.startsWith("subscription:")), e = Array.from(this.cache.keys()).filter((i) => i.startsWith("store:"));
      console.debug("[CoCache]", {
        cacheSize: this.cache.size,
        subscriptions: A.length,
        stores: e.length,
        pendingCleanups: this.cleanupTimers.size
      });
    }
  }
  /**
   * Debug: Warn when subscription count exceeds threshold (indicates possible leak)
   * Set window._maiaDebugSubscriptions = true; threshold via window._maiaDebugSubscriptionThreshold (default 80)
   * Throttled to once per 10s to avoid spam.
   * @private
   */
  _maybeWarnSubscriptionBuildup() {
    if (typeof window > "u" || !window._maiaDebugSubscriptions) return;
    const A = Array.from(this.cache.keys()).filter((o) => o.startsWith("subscription:")), e = window._maiaDebugSubscriptionThreshold ?? 80;
    if (A.length < e) return;
    const i = Date.now();
    this._lastBuildupWarn && i - this._lastBuildupWarn < 1e4 || (this._lastBuildupWarn = i, console.warn(`[CoCache] Subscription buildup: ${A.length} active (threshold ${e}). May cause freeze on tab switch.`));
  }
  /**
   * Cancel scheduled cleanup
   * 
   * @param {string} key - Cache key (MUST be namespaced)
   */
  cancelCleanup(A) {
    const e = this.cleanupTimers.get(A);
    e && (clearTimeout(e), this.cleanupTimers.delete(A));
  }
  /**
   * Manually destroy entry and remove from cache
   * 
   * @param {string} key - Cache key (MUST be namespaced)
   */
  destroy(A) {
    const e = this.cache.get(A);
    if (e) {
      if (e && typeof e == "object") {
        if (e.unsubscribe && typeof e.unsubscribe == "function")
          try {
            e.unsubscribe();
          } catch {
          }
        if (e._unsubscribe && typeof e._unsubscribe == "function")
          try {
            e._unsubscribe();
          } catch {
          }
      }
      this.cache.delete(A), this.cancelCleanup(A);
    }
  }
  /**
   * Check if entry exists in cache
   * 
   * @param {string} key - Cache key (MUST be namespaced)
   * @returns {boolean}
   */
  has(A) {
    return this.cache.has(A);
  }
  /**
   * Get entry from cache without creating
   * 
   * @param {string} key - Cache key (MUST be namespaced)
   * @returns {any|null} Entry or null
   */
  get(A) {
    return this.cache.get(A) || null;
  }
  /**
   * Get cache size (number of active entries)
   * 
   * @returns {number}
   */
  get size() {
    return this.cache.size;
  }
  /**
   * Debug: Get cache stats for subscription/freeze investigation
   * Call via: maia.dbEngine.backend.subscriptionCache.getStats()
   * @returns {{ cacheSize: number, subscriptions: number, stores: number, pendingCleanups: number }}
   */
  getStats() {
    const A = Array.from(this.cache.keys());
    return {
      cacheSize: this.cache.size,
      subscriptions: A.filter((e) => e.startsWith("subscription:")).length,
      stores: A.filter((e) => e.startsWith("store:")).length,
      pendingCleanups: this.cleanupTimers.size
    };
  }
  /**
   * Clear all entries and timers
   * 
   * Useful for cleanup on app shutdown or context switch
   * CRITICAL: Properly unsubscribes from all entries before clearing
   */
  clear() {
    const A = Array.from(this.cache.keys());
    for (const e of A)
      this.destroy(e);
    this.cache.clear(), this.cleanupTimers.clear();
  }
}
let xe = null, Ar = null;
function Wg(t, A) {
  if (!t)
    throw new Error("[getGlobalCoCache] node is required for node-aware caching");
  return Ar !== t ? (xe && xe.clear(), Ar = t, xe = new Sr(A)) : xe || (Ar = t, xe = new Sr(A)), xe;
}
function kr(t, A = /* @__PURE__ */ new Set(), e = 0, i = 15) {
  const o = /* @__PURE__ */ new Set();
  if (e > i || !t || typeof t != "object")
    return o;
  if (Array.isArray(t)) {
    for (const r of t)
      kr(r, A, e + 1, i).forEach((s) => {
        A.has(s) || o.add(s);
      });
    return o;
  }
  for (const [r, n] of Object.entries(t))
    r === "id" || r === "$schema" || r === "type" || r === "loading" || r === "error" || (typeof n == "string" && n.startsWith("co_") ? A.has(n) || o.add(n) : typeof n == "object" && n !== null && kr(n, A, e + 1, i).forEach((a) => {
      A.has(a) || o.add(a);
    }));
  return o;
}
async function it(t, A, e = /* @__PURE__ */ new Set(), i = {}) {
  const {
    maxDepth: o = 15,
    // TODO: temporarily scaled up from 10 for @maia spark detail
    timeoutMs: r = 5e3,
    // Kept for API compatibility but not used in progressive mode
    currentDepth: n = 0
  } = i, s = `[DeepResolution:depth${n}]`;
  if (n > o) {
    console.warn(`${s}  Max depth ${o} reached, stopping recursion`);
    return;
  }
  const a = kr(A, e, n, o);
  if (a.size === 0)
    return;
  const g = Array.from(a).map(async (I) => {
    if (!e.has(I)) {
      e.add(I);
      try {
        const c = t.getCoValue(I);
        if (!c)
          return;
        if (!t.isAvailable(c)) {
          nA(t, I, { waitForAvailable: !1 }).catch((f) => {
          });
          const Q = c.subscribe(async (f) => {
            if (t.isAvailable(f))
              try {
                const l = $A(t, f);
                await it(t, l, e, {
                  maxDepth: o,
                  timeoutMs: r,
                  currentDepth: n + 1
                });
                const u = f.subscribe(() => {
                });
                t.subscriptionCache.getOrCreate(`subscription:${I}`, () => ({ unsubscribe: u })), Q();
              } catch {
              }
          });
          return;
        }
        const C = $A(t, c);
        await it(t, C, e, {
          maxDepth: o,
          timeoutMs: r,
          currentDepth: n + 1
        });
        const B = c.subscribe(async (Q) => {
          if (t.isAvailable(Q))
            try {
              const f = $A(t, Q);
              it(t, f, e, {
                maxDepth: o,
                timeoutMs: r,
                currentDepth: n + 1
              }).catch((l) => {
              });
            } catch {
            }
        });
        t.subscriptionCache.getOrCreate(`subscription:${I}`, () => ({ unsubscribe: B }));
      } catch {
      }
    }
  });
  Promise.all(g).catch((I) => {
  });
}
async function lQ(t, A, e = {}) {
  const {
    deepResolve: i = !0,
    maxDepth: o = 15,
    // TODO: temporarily scaled up from 10 for @maia spark detail
    timeoutMs: r = 5e3
  } = e;
  if (`${A.substring(0, 12)}`, !i)
    return;
  const n = t.subscriptionCache;
  if (n.isResolved(A))
    return;
  const s = n.getOrCreateResolution(A, () => (async () => {
    try {
      const a = Date.now();
      await nA(t, A, { waitForAvailable: !0, timeoutMs: r });
      const g = t.getCoValue(A);
      if (!g || !t.isAvailable(g))
        throw new Error(`CoValue ${A} failed to load`);
      const I = $A(t, g);
      it(t, I, /* @__PURE__ */ new Set([A]), {
        maxDepth: o,
        timeoutMs: r,
        currentDepth: 0
      }).catch((C) => {
      }), n.markResolved(A);
    } catch (a) {
      throw n.destroy(`resolution:${A}`), a;
    }
  })());
  s !== !0 && await s;
}
async function dQ(t, A, e = {}) {
  return await it(t, A, /* @__PURE__ */ new Set(), e);
}
async function uQ(t, A, e, i, o = {}) {
  const r = e.split(".");
  let n = A;
  for (const s of r) {
    if (n == null) return;
    const a = /^\d+$/.test(s) ? parseInt(s, 10) : s;
    let g = n[a];
    for (; typeof g == "string" && g.startsWith("co_z"); ) {
      if (i.has(g)) return;
      g = await BQ(t, g, o, i);
    }
    n = g;
  }
  return n;
}
async function zg(t, A, e, i = {}) {
  if (!e || typeof e != "object")
    return A;
  const { timeoutMs: o = 2e3 } = i, r = /* @__PURE__ */ new Set(), n = { ...A }, s = /* @__PURE__ */ new Set();
  for (const [a, g] of Object.entries(e))
    try {
      if (typeof g != "string" || !g.startsWith("$$"))
        throw new Error(`Map expression for "${a}" must use strict $$ syntax. Got: "${g}". Expected format: "$$property.path"`);
      const I = g.substring(2), c = I.split(".")[0];
      if (c && c in A) {
        const B = A[c];
        B && typeof B == "string" && B.startsWith("co_z") && s.add(c);
      }
      const C = await uQ(t, A, I, r, { timeoutMs: o });
      n[a] = C;
    } catch (I) {
      console.warn(`[applyMapTransform] Failed to evaluate expression "${g}" for field "${a}":`, I), n[a] = void 0;
    }
  for (const a of s)
    delete n[a];
  return n;
}
async function rt(t, A, e) {
  if (typeof t == "string" && t.startsWith("$"))
    return await A.evaluate(t, e);
  if (t === null || typeof t != "object")
    return t;
  if (Array.isArray(t))
    return Promise.all(t.map((r) => rt(r, A, e)));
  const i = Object.keys(t);
  if (i.length === 1 && i[0].startsWith("$"))
    return await A.evaluate(t, e);
  const o = {};
  for (const [r, n] of Object.entries(t))
    n && typeof n == "object" ? A.isDSLOperation(n) ? o[r] = await A.evaluate(n, e) : o[r] = await rt(n, A, e) : o[r] = await A.evaluate(n, e);
  return o;
}
function nt(t) {
  if (t == null)
    return !1;
  if (typeof t == "string")
    return !!(t.startsWith("$") || t.includes("?") && t.includes(":"));
  if (typeof t != "object")
    return !1;
  if (Array.isArray(t))
    return t.some((e) => nt(e));
  const A = Object.keys(t);
  if (A.length === 1 && A[0].startsWith("$"))
    return !0;
  for (const [e, i] of Object.entries(t))
    if (nt(i))
      return !0;
  return !1;
}
async function dA(t, A, e = 5e3) {
  const i = t.value;
  if (!(i && !i.loading && !i.error && (i.hasProperties !== !1 || i.properties || typeof i == "object" && Object.keys(i).length > 0 && i.id))) {
    if (i?.error)
      throw new Error(`CoValue error (co-id: ${A}): ${i.error}`);
    return new Promise((r, n) => {
      let s = !1, a;
      a = t.subscribe((I) => {
        if (s) return;
        if (I?.error) {
          s = !0, a(), n(new Error(`CoValue error (co-id: ${A}): ${I.error}`));
          return;
        }
        !I?.loading && I !== null && (I?.hasProperties !== !1 || I?.properties || typeof I == "object" && Object.keys(I).length > 0 && I.id) && (s = !0, a(), r());
      });
      const g = t.value;
      g?.error ? (s = !0, a(), n(new Error(`CoValue error (co-id: ${A}): ${g.error}`))) : !g?.loading && g !== null && (g?.hasProperties !== !1 || g?.properties || typeof g == "object" && Object.keys(g).length > 0 && g.id) && (s = !0, a(), r()), setTimeout(() => {
        s || (s = !0, a(), n(new Error(`CoValue timeout loading (co-id: ${A}). Make sure the CoValue was seeded correctly.`)));
      }, e);
    });
  }
}
const hQ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  waitForStoreReady: dA
}, Symbol.toStringTag, { value: "Module" }));
async function sA(t, A = null, e = null, i = null, o = null, r = {}) {
  const {
    deepResolve: n = !0,
    maxDepth: s = 15,
    // TODO: temporarily scaled up from 10 for @maia spark detail deep resolution
    timeoutMs: a = 5e3,
    resolveReferences: g = null,
    map: I = null,
    onChange: c = null
  } = r, C = { deepResolve: n, maxDepth: s, timeoutMs: a, resolveReferences: g, map: I, onChange: c };
  if (A)
    return await io(t, A, o || e, C);
  if (e) {
    const B = await eA(t, "@maia/schema/data/spark", { returnType: "coId" }), Q = await eA(t, e, { returnType: "coId" });
    return B && Q === B ? await fQ(t, C) : await pQ(t, e, i, C);
  }
  return await wQ(t, i, { deepResolve: n, maxDepth: s, timeoutMs: a });
}
async function er(t, A, e) {
  return !t || typeof t != "object" ? t : await rt(t, e, { context: A, item: {} });
}
async function ei(t, A, e = {}) {
  const i = new wA({}), o = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), { timeoutMs: a = 5e3, onChange: g } = e, { Evaluator: I } = await Promise.resolve().then(() => cD), c = new I();
  let C = null, B = null;
  const Q = () => {
    B || (B = queueMicrotask(() => {
      B = null;
      const h = { ...A.value || {} };
      delete h["@stores"];
      const p = {};
      for (const [y, m] of r.entries())
        p[y] = m;
      Object.keys(p).length > 0 && (h.$op = p);
      for (const [y, m] of o.entries())
        if (m && typeof m.subscribe == "function" && "value" in m) {
          delete h[y];
          const k = n.get(y) || !1, b = m.value;
          k ? Array.isArray(b) ? h[y] = b.length > 0 ? b[0] : null : b && typeof b == "object" ? h[y] = b : h[y] = null : h[y] = b;
        }
      const E = JSON.stringify(h), w = C ? JSON.stringify(C) : null;
      E !== w && (C = h, i._set(h));
    }));
  }, f = async (d) => {
    if (!d || typeof d != "object" || Array.isArray(d)) {
      Q();
      return;
    }
    const h = /* @__PURE__ */ new Set();
    for (const [p, E] of Object.entries(d))
      if (!(p === "$schema" || p === "$id" || p === "@stores" || p === "properties" || p === "items" || p === "$defs" || p === "cotype" || p === "indexing" || p === "title" || p === "description") && E && typeof E == "object" && !Array.isArray(E) && E.schema) {
        h.add(p);
        const w = o.get(p), y = await er(E.filter || null, d, c), m = y && typeof y == "object" && Object.keys(y).length === 1 && y.id && typeof y.id == "string" && y.id.startsWith("co_z"), k = m ? y.id : null, q = r.get(p)?.filter || null, P = JSON.stringify(y) !== JSON.stringify(q);
        try {
          let J = E.schema;
          if (J && typeof J == "object" && J.$id && (J = J.$id), typeof J != "string") {
            console.error(`[createUnifiedStore] Invalid schema type for query "${p}": expected string, got ${typeof J}`, J);
            continue;
          }
          if (J.startsWith("co_z")) {
            if (J && typeof J == "string" && J.startsWith("co_z") && (P || !w)) {
              w && w._queryUnsubscribe && w._queryUnsubscribe();
              const W = {
                ...e,
                timeoutMs: a,
                ...E.options || {}
              }, X = m && k ? await sA(t, k, J, null, null, W) : await sA(t, null, J, y, null, W);
              n.set(p, m), r.set(p, {
                schema: E.schema,
                ...E.options ? { options: E.options } : {},
                filter: y
              });
              const z = X.subscribe(() => {
                Q();
              });
              X._queryUnsubscribe = z, o.set(p, X);
            }
          } else if (J.startsWith("@maia/schema/")) {
            const X = ee(t, J, { timeoutMs: a }).subscribe(async (z) => {
              if (z.loading) {
                if (!o.has(p)) {
                  const O = await er(E.filter || null, d, c), Z = O && typeof O == "object" && Object.keys(O).length === 1 && O.id && typeof O.id == "string" && O.id.startsWith("co_z"), T = new wA(Z ? null : []);
                  o.set(p, T), n.set(p, Z), r.set(p, {
                    schema: E.schema,
                    ...E.options ? { options: E.options } : {},
                    filter: O
                  }), Q();
                }
                return;
              }
              if (z.error || !z.schemaCoId) {
                console.error(`[createUnifiedStore] Failed to resolve schema ${E.schema} for query "${p}": ${z.error || "Schema not found"}`), X();
                return;
              }
              const _ = z.schemaCoId;
              try {
                const O = {
                  ...e,
                  timeoutMs: a,
                  ...E.options || {}
                }, Z = await er(E.filter || null, d, c), T = Z && typeof Z == "object" && Object.keys(Z).length === 1 && Z.id && typeof Z.id == "string" && Z.id.startsWith("co_z"), F = T ? Z.id : null, R = r.get(p)?.filter || null;
                if (JSON.stringify(Z) !== JSON.stringify(R) || !o.has(p)) {
                  const N = o.get(p);
                  N && N._queryUnsubscribe && N._queryUnsubscribe();
                  const Y = T && F ? await sA(t, F, _, null, null, O) : await sA(t, null, _, Z, null, O);
                  n.set(p, T), r.set(p, {
                    schema: E.schema,
                    ...E.options ? { options: E.options } : {},
                    filter: Z
                  });
                  const j = Y.subscribe(() => {
                    Q();
                  });
                  Y._queryUnsubscribe = j, o.set(p, Y), Q();
                }
                X();
              } catch (O) {
                console.error(`[createUnifiedStore] Failed to execute query "${p}" after schema resolution:`, O), X();
              }
            });
            s.set(p, X);
            continue;
          } else {
            console.error(`[createUnifiedStore] Invalid schema format for query "${p}": ${J}`);
            continue;
          }
        } catch (J) {
          console.error(`[createUnifiedStore] Failed to resolve query "${p}":`, J);
        }
      }
    for (const [p, E] of o.entries())
      h.has(p) || (E._queryUnsubscribe && (E._queryUnsubscribe(), delete E._queryUnsubscribe), o.delete(p), r.delete(p), n.delete(p));
    for (const [p, E] of s.entries())
      h.has(p) || (E && E(), s.delete(p));
    Q();
  }, l = A.subscribe(async (d) => {
    await f(d);
  }), u = i._unsubscribe;
  return i._unsubscribe = () => {
    u && u(), l();
    for (const d of s.values())
      d && d();
    s.clear();
    for (const d of o.values())
      d._queryUnsubscribe && (d._queryUnsubscribe(), delete d._queryUnsubscribe), d._cacheKey && t.subscriptionCache && t.subscriptionCache.scheduleCleanup(d._cacheKey);
    o.clear();
  }, await f(A.value), i;
}
function fs(t, A) {
  if (!A || typeof A != "object" || !t || typeof t != "object")
    return /* @__PURE__ */ new Set();
  const e = /* @__PURE__ */ new Set();
  for (const i of Object.values(A))
    if (typeof i == "string" && i.startsWith("$$")) {
      const o = i.substring(2).split(".")[0];
      if (o && o in t) {
        const r = t[o];
        typeof r == "string" && r.startsWith("co_z") && e.add(r);
      }
    }
  return e;
}
async function ps(t, A, e, i, o = /* @__PURE__ */ new Set()) {
  const {
    deepResolve: r = !0,
    maxDepth: n = 15,
    // TODO: temporarily scaled up from 10 for @maia spark detail deep resolution
    timeoutMs: s = 5e3,
    resolveReferences: a = null,
    map: g = null
  } = i;
  let I = $A(t, A, e);
  if (r)
    try {
      lQ(t, A.id, { deepResolve: r, maxDepth: n, timeoutMs: s }).catch((c) => {
      });
    } catch {
    }
  if (a)
    try {
      const c = { ...a, timeoutMs: s };
      I = await Jt(t, I, c, o, n, 0);
    } catch {
    }
  if (g)
    try {
      I = await zg(t, I, g, { timeoutMs: s });
    } catch (c) {
      console.warn("[processCoValueData] Failed to apply map transform:", c);
    }
  return I;
}
async function io(t, A, e = null, i = {}) {
  const {
    deepResolve: o = !0,
    maxDepth: r = 15,
    // TODO: temporarily scaled up from 10 for @maia spark detail deep resolution
    timeoutMs: n = 5e3,
    resolveReferences: s = null,
    map: a = null
  } = i, g = t.subscriptionCache, I = { deepResolve: o, resolveReferences: s, map: a, maxDepth: r, timeoutMs: n }, c = g.getResolvedData(A, I);
  if (c) {
    const E = c && typeof c == "object" && Object.values(c).some(
      (m) => m && typeof m == "object" && !Array.isArray(m) && m.schema
    ), w = new wA(c), y = t.getCoValue(A);
    if (y) {
      const m = async (J) => {
        const W = await ps(t, J, e, i, /* @__PURE__ */ new Set());
        return g.setResolvedData(A, I, W), W;
      }, k = /* @__PURE__ */ new Map(), b = (J) => {
        if (!a) return;
        const W = $A(t, J, e), X = fs(W, a);
        for (const z of X) {
          if (k.has(z)) continue;
          const _ = t.getCoValue(z);
          if (!_) continue;
          const O = _.subscribe(async () => {
            if (!J.isAvailable()) return;
            g.invalidateResolvedData(z);
            const Z = await m(J);
            w._set(Z);
          });
          k.set(z, O);
        }
        for (const [z, _] of k.entries())
          X.has(z) || (_(), k.delete(z));
      }, q = y.subscribe(async (J) => {
        if (J.isAvailable()) {
          const W = await m(J);
          b(J), w._set(W);
        }
      });
      if (b(y), t.subscriptionCache.getOrCreate(`subscription:${A}`, () => ({ unsubscribe: q })), E) {
        const J = await ei(t, w, i), W = J._unsubscribe;
        return J._unsubscribe = () => {
          W && W(), q();
          for (const X of k.values()) X();
          k.clear(), t.subscriptionCache.scheduleCleanup(`subscription:${A}`);
        }, J;
      }
      const P = w._unsubscribe;
      w._unsubscribe = () => {
        P && P(), q();
        for (const J of k.values()) J();
        k.clear(), t.subscriptionCache.scheduleCleanup(`subscription:${A}`);
      };
    }
    return E ? await ei(t, w, i) : w;
  }
  const C = t.getCoValue(A);
  if (!C)
    return new wA({ error: "CoValue not found", id: A });
  const B = async (E) => {
    const w = await ps(t, E, e, i, /* @__PURE__ */ new Set());
    return g.setResolvedData(A, I, w), w;
  }, Q = /* @__PURE__ */ new Map(), f = new wA(null);
  let l = null, u = null;
  const d = (E) => {
    if (!a) return;
    const w = $A(t, E, e), y = fs(w, a);
    for (const m of y) {
      if (Q.has(m)) continue;
      const k = t.getCoValue(m);
      if (!k) continue;
      const b = k.subscribe(async () => {
        if (!E.isAvailable()) return;
        g.invalidateResolvedData(m);
        const q = await B(E);
        u ? u._set(q) : f._set(q);
      });
      Q.set(m, b);
    }
    for (const [m, k] of Q.entries())
      y.has(m) || (k(), Q.delete(m));
  }, h = C.subscribe(async (E) => {
    if (!E.isAvailable()) {
      f._set({ id: A, loading: !0 });
      return;
    }
    const w = await B(E);
    if (d(E), w && typeof w == "object" && Object.values(w).some(
      (m) => m && typeof m == "object" && !Array.isArray(m) && m.schema
    ))
      if (u)
        u._set(w);
      else {
        u = new wA(w);
        const m = await ei(t, u, i);
        l = m.subscribe((k) => f._set(k)), f._set(m.value);
      }
    else
      f._set(w);
  });
  if (t.subscriptionCache.getOrCreate(`subscription:${A}`, () => ({ unsubscribe: h })), C.isAvailable()) {
    const E = await B(C);
    if (d(C), E && typeof E == "object" && Object.values(E).some(
      (m) => m && typeof m == "object" && !Array.isArray(m) && m.schema
    )) {
      f._set(E);
      const m = await ei(t, f, i), k = m._unsubscribe;
      return m._unsubscribe = () => {
        k && k(), h();
        for (const b of Q.values()) b();
        Q.clear(), t.subscriptionCache.scheduleCleanup(`subscription:${A}`);
      }, m;
    }
    f._set(E);
    const y = f._unsubscribe;
    return f._unsubscribe = () => {
      y && y(), h();
      for (const m of Q.values()) m();
      Q.clear(), t.subscriptionCache.scheduleCleanup(`subscription:${A}`);
    }, f;
  }
  f._set({ id: A, loading: !0 }), nA(t, A).then(() => {
  }).catch((E) => {
    f._set({ error: E.message, id: A });
  });
  const p = f._unsubscribe;
  return f._unsubscribe = () => {
    p && p(), l && (l(), l = null), h();
    for (const E of Q.values()) E();
    Q.clear(), t.subscriptionCache.scheduleCleanup(`subscription:${A}`);
  }, f;
}
async function fQ(t, A = {}) {
  const { deepResolve: e = !0, maxDepth: i = 15, timeoutMs: o = 5e3 } = A, r = t.subscriptionCache.getOrCreateStore("sparks:account", () => new wA([])), n = t.account?.get?.("sparks");
  if (!n || !n.startsWith("co_"))
    return r;
  const s = async () => {
    const I = await io(t, n, null, { deepResolve: !1 });
    try {
      await dA(I, n, o);
    } catch {
      return;
    }
    const c = I?.value ?? {};
    if (c?.error) return;
    const C = [];
    for (const Q of Object.keys(c)) {
      if (Q === "id" || Q === "loading" || Q === "error" || Q === "$schema" || Q === "type") continue;
      const f = c[Q], l = typeof f == "string" && f.startsWith("co_") ? f : Q.startsWith("co_") ? Q : null;
      l && C.push(l);
    }
    const B = [];
    for (const Q of C)
      try {
        const f = await io(t, Q, null, { deepResolve: e, maxDepth: i, timeoutMs: o });
        await dA(f, Q, Math.min(o, 2e3));
        const l = f?.value;
        l && !l.error && B.push({ id: Q, name: l.name ?? Q, ...l });
      } catch {
        B.push({ id: Q, name: Q });
      }
    r._set(B);
  };
  await s();
  const g = (await io(t, n, null, { deepResolve: !1 }))?.subscribe?.(() => s());
  return g && t.subscriptionCache.getOrCreate(`subscription:sparks:${n}`, () => ({ unsubscribe: g })), r;
}
async function pQ(t, A, e = null, i = {}) {
  const {
    deepResolve: o = !0,
    maxDepth: r = 15,
    // TODO: temporarily scaled up from 10 for @maia spark detail deep resolution
    timeoutMs: n = 5e3,
    resolveReferences: s = null,
    map: a = null
  } = i, g = i && (i.map || i.resolveReferences) ? JSON.stringify({ map: i.map || null, resolveReferences: i.resolveReferences || null }) : "", I = `${A}:${JSON.stringify(e || {})}:${g}`, c = t.subscriptionCache.getOrCreateStore(I, () => {
    const E = new wA([]);
    return E._cacheKey = `store:${I}`, E;
  }), C = await po(t, A);
  if (!C)
    return c;
  let B = t.getCoValue(C);
  if (!B)
    return c;
  const Q = /* @__PURE__ */ new Set(), f = /* @__PURE__ */ new Set(), l = t.subscriptionCache;
  let u = async () => {
  };
  if (!t.isAvailable(B)) {
    if (nA(t, C, { waitForAvailable: !1 }).catch((E) => {
      console.warn(`[readCollection] Failed to load CoList ${C.substring(0, 12)}...:`, E);
    }), B) {
      const E = B.subscribe((w) => {
        w && t.isAvailable(w) && u().catch((y) => {
          console.warn("[readCollection] Error updating store after colist load:", y);
        });
      });
      t.subscriptionCache.getOrCreate(`subscription:${C}`, () => ({ unsubscribe: E }));
    }
    return c;
  }
  const d = (E) => {
    if (Q.has(E))
      return;
    Q.add(E);
    const w = t.getCoValue(E);
    if (!w || !t.isAvailable(w)) {
      nA(t, E, { waitForAvailable: !0, timeoutMs: 2e3 }).then(() => {
        const m = t.getCoValue(E);
        if (m && t.isAvailable(m)) {
          const k = m.subscribe(() => {
            l.invalidateResolvedData(E), u && u().catch((b) => {
              console.warn("[CoJSONBackend] Error updating store:", b);
            });
          });
          t.subscriptionCache.getOrCreate(`subscription:${E}`, () => ({ unsubscribe: k })), u && u().catch((b) => {
            console.warn("[CoJSONBackend] Error updating store after item load:", b);
          });
        }
      }).catch((m) => {
        console.error(`[CoJSONBackend] Failed to load item ${E}:`, m);
      });
      return;
    }
    const y = w.subscribe(() => {
      l.invalidateResolvedData(E), u && u().catch((m) => {
        console.warn("[CoJSONBackend] Error updating store:", m);
      });
    });
    t.subscriptionCache.getOrCreate(`subscription:${E}`, () => ({ unsubscribe: y }));
  };
  u = async () => {
    const E = [];
    if (!t.isAvailable(B)) {
      nA(t, C).catch((y) => {
        console.error("[readCollection] Failed to reload CoList:", y);
      });
      return;
    }
    const w = t.getCurrentContent(B);
    if (!(!w || !w.toJSON)) {
      try {
        const y = w.toJSON();
        let m = 0, k = 0;
        for (const b of y) {
          if (typeof b != "string" || !b.startsWith("co_"))
            continue;
          d(b);
          const q = t.getCoValue(b);
          if (!q) {
            k++;
            continue;
          }
          if (t.isAvailable(q)) {
            m++;
            const P = { deepResolve: o, resolveReferences: s, map: a, maxDepth: r, timeoutMs: n }, J = t.getCoValue(b);
            if (!J || !t.isAvailable(J))
              continue;
            const W = await l.getOrCreateResolvedData(b, P, async () => {
              let z = $A(t, J);
              if (Object.keys(z).filter(
                (O) => !["id", "type", "$schema"].includes(O)
              ).length === 0 && z.type === "comap")
                return z;
              if (o && !a && !l.isResolved(b))
                try {
                  await it(t, z, f, {
                    maxDepth: r,
                    timeoutMs: n,
                    currentDepth: 0
                  });
                } catch {
                }
              if (s)
                try {
                  const O = { ...s, timeoutMs: n }, Z = await Jt(t, z, O, f, r, 0);
                  Object.assign(z, Z);
                } catch {
                }
              if (a)
                try {
                  z = await zg(t, z, a, { timeoutMs: n });
                } catch (O) {
                  console.warn("[readCollection] Failed to apply map transform:", O);
                }
              return z;
            });
            if (Object.keys(W).filter(
              (z) => !["id", "type", "$schema"].includes(z)
            ).length === 0 && W.type === "comap")
              continue;
            (!e || dn(W, e)) && E.push(W);
          } else
            k++;
        }
      } catch (y) {
        console.warn("[readCollection] Error reading CoList items:", y);
      }
      c._set(E);
    }
  };
  const h = B.subscribe(() => {
    u().catch((E) => {
      console.warn("[CoJSONBackend] Error updating store:", E);
    });
  });
  if (t.subscriptionCache.getOrCreate(`subscription:${C}`, () => ({ unsubscribe: h })), t.isAvailable(B)) {
    const E = t.getCurrentContent(B);
    if (E && E.toJSON)
      try {
        const w = E.toJSON();
        for (const y of w)
          if (typeof y == "string" && y.startsWith("co_")) {
            const m = t.getCoValue(y);
            m && !t.isAvailable(m) && nA(t, y).catch((k) => {
              console.error(`[CoJSONBackend] Failed to load item ${y}:`, k);
            });
          }
      } catch {
      }
  }
  await u();
  const p = c._unsubscribe;
  return c._unsubscribe = () => {
    t.subscriptionCache.scheduleCleanup(`store:${I}`), p && p(), t.subscriptionCache.scheduleCleanup(`subscription:${C}`);
    for (const E of Q)
      t.subscriptionCache.scheduleCleanup(`subscription:${E}`);
  }, c;
}
async function wQ(t, A = null, e = {}) {
  const {
    deepResolve: i = !0,
    maxDepth: o = 15,
    // TODO: temporarily scaled up from 10 for @maia spark detail deep resolution
    timeoutMs: r = 5e3
  } = e, n = new wA([]), s = /* @__PURE__ */ new Set();
  let a = async () => {
  };
  const g = (c, C) => {
    if (s.has(c))
      return;
    s.add(c);
    const B = C.subscribe(() => {
      a();
    });
    t.subscriptionCache.getOrCreate(`subscription:${c}`, () => ({ unsubscribe: B }));
  };
  a = async () => {
    const c = t.getAllCoValues(), C = [];
    for (const [B, Q] of c.entries()) {
      if (!B || typeof B != "string" || !B.startsWith("co_"))
        continue;
      if (g(B, Q), !t.isAvailable(Q)) {
        nA(t, B).catch((u) => {
          console.error(`[CoJSONBackend] Failed to load CoValue ${B}:`, u);
        });
        continue;
      }
      const f = $A(t, Q);
      if (!(Object.keys(f).filter(
        (u) => !["id", "type", "$schema"].includes(u)
      ).length === 0 && f.type === "comap")) {
        if (i)
          try {
            await dQ(t, f, { maxDepth: o, timeoutMs: r });
          } catch {
          }
        (!A || dn(f, A)) && C.push(f);
      }
    }
    n._set(C);
  }, await a();
  const I = n._unsubscribe;
  return n._unsubscribe = () => {
    I && I();
    for (const c of s)
      t.subscriptionCache.scheduleCleanup(`subscription:${c}`);
  }, n;
}
function ke(t, A = {}) {
  const { timeoutMs: e = 1e4 } = A;
  return new Promise((i, o) => {
    let r;
    const n = setTimeout(() => {
      r && r(), o(new Error(`Timeout waiting for reactive resolution after ${e}ms`));
    }, e);
    r = t.subscribe((s) => {
      s.loading || (clearTimeout(n), r && r(), s.error ? o(new Error(s.error)) : i(s));
    });
  });
}
function bt(t, A, e = {}) {
  const { timeoutMs: i = 1e4 } = e, o = new wA({ loading: !0 });
  if (A.startsWith("co_z"))
    return o._set({ loading: !1, schemaCoId: A }), o;
  let r = null, n = null;
  const s = async () => {
    const { getSparkOsId: a } = await Promise.resolve().then(() => ce), g = t?.systemSpark ?? "@maia", I = await a(t, g);
    if (!I || typeof I != "string" || !I.startsWith("co_z")) {
      o._set({ loading: !1, error: "spark.os not found" });
      return;
    }
    r = (await sA(t, I, null, null, null, {
      deepResolve: !1,
      timeoutMs: i
    })).subscribe(async (B) => {
      if (!B || B.error)
        return;
      const Q = B.schematas;
      !Q || typeof Q != "string" || !Q.startsWith("co_z") || n || (n = (await sA(t, Q, null, null, null, {
        deepResolve: !1,
        timeoutMs: i
      })).subscribe((l) => {
        if (!l || l.error)
          return;
        const u = A.startsWith("@maia/schema/") ? A : `@maia/schema/${A}`, d = l[u] || l[A];
        d && typeof d == "string" && d.startsWith("co_z") && (o._set({ loading: !1, schemaCoId: d }), n && (n(), n = null), r && (r(), r = null));
      }));
    });
    const C = o._unsubscribe;
    o._unsubscribe = () => {
      C && C(), n && (n(), n = null), r && (r(), r = null);
    };
  };
  return eA(t, A, { returnType: "coId", timeoutMs: 2e3 }).then((a) => {
    a && a.startsWith("co_z") ? o._set({ loading: !1, schemaCoId: a }) : s().catch((g) => {
      o._set({ loading: !1, error: g.message });
    });
  }).catch(() => {
    s().catch((a) => {
      o._set({ loading: !1, error: a.message });
    });
  }), o;
}
function Nr(t, A, e = {}) {
  const i = new wA({ loading: !0 });
  if (!A || !A.startsWith("co_z"))
    return i._set({ loading: !1, error: "Invalid co-id" }), i;
  const o = t.getCoValue(A);
  if (!o)
    return i._set({ loading: !1, error: "CoValueCore not found" }), i;
  if (t.isAvailable(o))
    return i._set({ loading: !1, coValueCore: o }), i;
  nA(t, A, { waitForAvailable: !1 }).catch((s) => {
  });
  const r = o.subscribe((s) => {
    t.isAvailable(s) && (i._set({ loading: !1, coValueCore: s }), r());
  }), n = i._unsubscribe;
  return i._unsubscribe = () => {
    n && n(), r();
  }, i;
}
function _g(t, A, e = {}) {
  const i = new wA({ loading: !0, items: [] });
  if (!A || !A.schema)
    return i._set({ loading: !1, items: [], error: "Invalid query definition" }), i;
  const r = bt(t, A.schema, e).subscribe(async (n) => {
    if (!n.loading) {
      if (n.error || !n.schemaCoId) {
        i._set({ loading: !1, items: [], error: n.error || "Schema not found" }), r();
        return;
      }
      try {
        const a = (await sA(
          t,
          null,
          n.schemaCoId,
          A.filter || null,
          null,
          {
            ...e,
            ...A.options || {}
          }
        )).subscribe((I) => {
          const c = Array.isArray(I) ? I : I?.items || [];
          i._set({ loading: !1, items: c });
        }), g = i._unsubscribe;
        i._unsubscribe = () => {
          g && g(), a(), r();
        };
      } catch (s) {
        i._set({ loading: !1, items: [], error: s.message }), r();
      }
    }
  });
  return i;
}
function yQ(t, A, e = {}) {
  if (A && typeof A == "object" && !Array.isArray(A)) {
    if (A.schema)
      return _g(t, A, e);
    if (A.fromCoValue) {
      const o = Nr(t, A.fromCoValue, e), r = new wA({ loading: !0 });
      let n, s, a;
      n = o.subscribe(async (I) => {
        if (I.loading)
          return;
        if (I.error || !I.coValueCore) {
          r._set({ loading: !1, error: I.error || "CoValue not found" }), n && n();
          return;
        }
        const B = (t.getHeader(I.coValueCore)?.meta || null)?.$schema || null;
        B && typeof B == "string" && B.startsWith("co_z") ? s = bt(t, B, e).subscribe((f) => {
          r._set(f), f.loading || (s && s(), n && n());
        }) : a = I.coValueCore.subscribe((Q) => {
          const u = (t.getHeader(Q)?.meta || null)?.$schema || null;
          u && typeof u == "string" && u.startsWith("co_z") && (s = bt(t, u, e).subscribe((h) => {
            r._set(h), h.loading || (s && s(), a && a(), n && n());
          }));
        });
      });
      const g = r._unsubscribe;
      return r._unsubscribe = () => {
        g && g(), n && n(), s && s(), a && a();
      }, r;
    }
  }
  return typeof A == "string" ? A.startsWith("co_z") ? Nr(t, A, e) : bt(t, A, e) : new wA({ loading: !1, error: "Invalid identifier" });
}
function Mr(t, A = !1) {
  if (t == null || typeof t != "object")
    return t;
  if (Array.isArray(t))
    return t.map((i) => Mr(i, A));
  const e = {};
  for (const [i, o] of Object.entries(t))
    if (!(i === "id" && !A))
      if (o != null && typeof o == "object") {
        const r = i === "properties" || i === "items";
        e[i] = Mr(o, r || A);
      } else
        e[i] = o;
  return e;
}
const tr = /^@[a-zA-Z0-9_-]+\/schema\//, lt = /^@[a-zA-Z0-9_-]+\/vibe\//;
async function eA(t, A, e = {}) {
  const {
    returnType: i = "schema",
    deepResolve: o = !1,
    timeoutMs: r = 5e3,
    spark: n
  } = e;
  if (!t)
    throw new Error("[resolve] backend is required");
  if (A && typeof A == "object" && !Array.isArray(A)) {
    if (A.fromCoValue) {
      if (!A.fromCoValue.startsWith("co_z"))
        throw new Error(`[resolve] fromCoValue must be a valid co-id (co_z...), got: ${A.fromCoValue}`);
      const I = await sA(t, A.fromCoValue, null, null, null, {
        deepResolve: !1,
        timeoutMs: r
      });
      try {
        await dA(I, A.fromCoValue, r);
      } catch {
        return null;
      }
      const c = I.value;
      if (!c || c.error)
        return null;
      const C = c.$schema || null;
      return C ? i === "coId" ? C : await eA(t, C, { returnType: i, deepResolve: o, timeoutMs: r }) : null;
    }
    throw new Error('[resolve] Invalid identifier object. Expected { fromCoValue: "co_z..." }');
  }
  if (typeof A != "string")
    throw new Error(`[resolve] Invalid identifier type. Expected string or object, got: ${typeof A}`);
  if (A.startsWith("co_z")) {
    const I = await sA(t, A, null, null, null, {
      deepResolve: o,
      timeoutMs: r
    });
    try {
      await dA(I, A, r);
    } catch {
      return null;
    }
    const c = I.value;
    if (!c || c.error)
      return null;
    if (i === "coValue")
      return I;
    if (i === "coId")
      return A;
    const C = c.cotype, B = c.properties, Q = c.items, f = c.title;
    if (C || B || Q || f) {
      const { id: u, type: d, ...h } = c;
      return {
        ...Mr(h),
        $id: A
        // Ensure $id is set
      };
    }
    return null;
  }
  const s = tr.test(A), a = lt.test(A), g = !A.startsWith("@") && !A.startsWith("co_z");
  if (s || a || g) {
    const I = n ?? t?.systemSpark;
    if (!I && (s || a || g))
      throw new Error(`[resolve] spark required for registry lookup of ${A}. Pass options.spark or set backend.systemSpark.`);
    let c = A;
    if (!tr.test(c) && !lt.test(c) && !c.startsWith("@") && (c = `@${I?.replace(/^@/, "") ?? "maia"}/schema/${c}`), !t.account || typeof t.account.get != "function")
      return console.warn("[resolve] Account not available for registry lookup"), null;
    if (tr.test(c)) {
      const B = t.account.get("sparks");
      if (!B || typeof B != "string" || !B.startsWith("co_z"))
        return null;
      const Q = await sA(t, B, null, null, null, {
        deepResolve: !1,
        timeoutMs: r
      });
      try {
        await dA(Q, B, r);
      } catch {
        return null;
      }
      const f = Q.value;
      if (!f || f.error) return null;
      const l = f[I];
      if (!l || typeof l != "string" || !l.startsWith("co_z"))
        return null;
      const u = await sA(t, l, null, null, null, {
        deepResolve: !1,
        timeoutMs: r
      });
      try {
        await dA(u, l, r);
      } catch {
        return null;
      }
      const d = u.value;
      if (!d || d.error) return null;
      const h = d.os;
      if (!h || typeof h != "string" || !h.startsWith("co_z"))
        return null;
      const p = await sA(t, h, null, null, null, {
        deepResolve: !1,
        timeoutMs: r
      });
      try {
        await dA(p, h, r);
      } catch {
        return null;
      }
      const E = p.value;
      if (!E || E.error)
        return null;
      const w = E.schematas;
      if (!w || typeof w != "string" || !w.startsWith("co_z"))
        return null;
      const y = await sA(t, w, null, null, null, {
        deepResolve: !1,
        timeoutMs: r
      });
      try {
        await dA(y, w, r);
      } catch {
        return null;
      }
      const m = y.value;
      if (!m || m.error)
        return null;
      const k = m[c] || m[A];
      return k && typeof k == "string" && k.startsWith("co_z") ? i === "coId" ? k : await eA(t, k, { returnType: i, deepResolve: o, timeoutMs: r }) : (/^@[a-zA-Z0-9_-]+\/schema\/index\//.test(c) || console.warn(`[resolve] Schema "${A}" not found in registry`), null);
    } else if (lt.test(A) || !A.startsWith("@")) {
      const B = t.account.get("sparks");
      if (!B || typeof B != "string" || !B.startsWith("co_z"))
        return null;
      const Q = await sA(t, B, null, null, null, {
        deepResolve: !1,
        timeoutMs: r
      });
      try {
        await dA(Q, B, r);
      } catch {
        return null;
      }
      const f = Q.value;
      if (!f || f.error) return null;
      const l = f[I];
      if (!l || typeof l != "string" || !l.startsWith("co_z"))
        return null;
      const u = await sA(t, l, null, null, null, {
        deepResolve: !1,
        timeoutMs: r
      });
      try {
        await dA(u, l, r);
      } catch {
        return null;
      }
      const d = u.value;
      if (!d || d.error) return null;
      const h = d.vibes;
      if (!h || typeof h != "string" || !h.startsWith("co_z"))
        return null;
      const p = await sA(t, h, null, null, null, {
        deepResolve: !1,
        timeoutMs: r
      });
      try {
        await dA(p, h, r);
      } catch {
        return null;
      }
      const E = p.value;
      if (!E || E.error)
        return null;
      const w = lt.test(A) ? A.replace(lt, "") : A, y = E[w];
      return y && typeof y == "string" && y.startsWith("co_z") ? i === "coId" ? y : await eA(t, y, { returnType: i, deepResolve: o, timeoutMs: r }) : null;
    }
  }
  return null;
}
function ee(t, A, e = {}) {
  const { returnType: i = "coId" } = e, o = yQ(t, A, e);
  if (i === "schema" || i === "coValue") {
    const r = new ReactiveStore({ loading: !0 }), n = o.subscribe(async (a) => {
      if (a.loading) {
        r._set({ loading: !0 });
        return;
      }
      if (a.error) {
        r._set({ loading: !1, error: a.error }), n();
        return;
      }
      if (a.schemaCoId)
        if (i === "coId")
          r._set({ loading: !1, schemaCoId: a.schemaCoId }), n();
        else
          try {
            const g = await eA(t, a.schemaCoId, { returnType: i });
            g ? r._set({ loading: !1, [i === "schema" ? "schema" : "coValue"]: g }) : r._set({ loading: !1, error: "Schema not found" }), n();
          } catch (g) {
            r._set({ loading: !1, error: g.message }), n();
          }
      else if (a.coValueCore)
        if (i === "coId") {
          const c = (t.getHeader(a.coValueCore)?.meta || null)?.$schema || null;
          c ? r._set({ loading: !1, schemaCoId: c }) : r._set({ loading: !1, error: "Schema not found in headerMeta" }), n();
        } else
          r._set({ loading: !1, coValue: a.coValueCore }), n();
    }), s = r._unsubscribe;
    return r._unsubscribe = () => {
      s && s(), n();
    }, r;
  }
  return o;
}
async function Rt(t, A, e) {
  const i = await eA(t, A, { returnType: "schema" });
  if (!i)
    throw new Error(`[checkCotype] Schema ${A} not found`);
  return (i.cotype || "comap") === e;
}
const un = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  checkCotype: Rt,
  resolve: eA,
  resolveReactive: ee
}, Symbol.toStringTag, { value: "Module" })), DQ = {
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $id: "https://maia.city/AccountSchema",
  title: "Account",
  description: "Schema for account CoMap (special CoMap with authentication properties)",
  allOf: [
    { $ref: "#/$defs/comap" }
  ],
  properties: {
    sealer: {
      type: "string",
      pattern: "^sealer_",
      description: "Sealer key for encryption"
    },
    signer: {
      type: "string",
      pattern: "^signer_",
      description: "Signer key for signing"
    },
    readKey: {
      type: "string",
      description: "Read key for decryption"
    },
    profile: {
      allOf: [
        {
          type: "string",
          pattern: "^co_z[a-zA-Z0-9]+$",
          description: "Co-id reference to Profile CoMap"
        },
        {
          $ref: "https://maia.city/ProfileSchema"
        }
      ]
    },
    examples: {
      type: "string",
      pattern: "^co_z[a-zA-Z0-9]+$",
      description: "Co-id reference to Examples CoMap (optional)"
    }
  },
  required: ["profile"],
  $defs: Ot.$defs
}, mQ = {
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $id: "https://maia.city/GroupSchema",
  title: "Group",
  description: "Schema for group CoMap (special CoMap with member management)",
  allOf: [
    { $ref: "#/$defs/comap" }
  ],
  properties: {
    // Groups can have members (co-ids) and permissions
    // Structure depends on cojson's group implementation
  },
  $defs: Ot.$defs
}, SQ = {
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $id: "https://maia.city/ProfileSchema",
  title: "Profile",
  description: "Schema for profile CoMap (account-owned, identity only)",
  allOf: [
    { $ref: "#/$defs/comap" }
  ],
  properties: {
    name: {
      type: "string",
      minLength: 1,
      description: "User's display name"
    }
  },
  required: ["name"],
  $defs: Ot.$defs
}, hn = {
  AccountSchema: DQ,
  GroupSchema: mQ,
  ProfileSchema: SQ
};
function wo() {
  return { ...hn };
}
function fn(t) {
  return ["@account", "@group", "@metaSchema"].includes(t) ? !0 : t in hn;
}
function yo(t, A = "createCoValue") {
  if (!t || typeof t != "string")
    throw new Error(`[${A}] Schema name is REQUIRED.`);
  if (!(He(t) || t.startsWith("co_z") || fn(t)))
    throw new Error(`[${A}] Schema '${t}' not found in registry. Available: AccountSchema, GroupSchema, ProfileSchema`);
}
const yA = {
  ACCOUNT: "@account",
  GROUP: "@group",
  META_SCHEMA: "@metaSchema"
};
function He(t) {
  return t === yA.ACCOUNT || t === yA.GROUP || t === yA.META_SCHEMA;
}
function at(t) {
  return !He(t) && !t.startsWith("co_z") && !fn(t) && console.warn(`[createSchemaMeta] Schema '${t}' not found in registry`), {
    $schema: t
    // Schema name, co-id, or exception schema
  };
}
function Zg(t) {
  return t.headerMeta?.$schema || null;
}
function Xg(t) {
  return Zg(t);
}
const Pt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  EXCEPTION_SCHEMAS: yA,
  SCHEMA_REGISTRY: hn,
  assertSchemaValidForCreate: yo,
  createSchemaMeta: at,
  getAllSchemas: wo,
  getSchema: Xg,
  getSchemaFromCoValue: Zg,
  hasSchemaInRegistry: fn,
  isExceptionSchema: He
}, Symbol.toStringTag, { value: "Module" }));
async function pn(t, A, e) {
  const i = e?.name ?? "Maia";
  let o = t.get("profile"), r;
  if (o) {
    let n = A.getCoValue(o);
    if (n || (n = await A.loadCoValueCore(o)), n && n.type === "comap")
      if (n.isAvailable?.()) {
        const s = n.getCurrentContent?.();
        s && typeof s.get == "function" && (r = s);
      } else {
        await new Promise((a, g) => {
          const I = setTimeout(() => g(new Error("Timeout waiting for profile")), 15e3), c = n.subscribe((C) => {
            C?.isAvailable?.() && (clearTimeout(I), c?.(), a());
          });
        });
        const s = n.getCurrentContent?.();
        s && typeof s.get == "function" && (r = s);
      }
  }
  if (r) {
    if (e?.name != null) {
      const n = r.get("name");
      n !== e.name && (r.set("name", e.name), console.log(`    Updated profile name from "${n}" to "${e.name}"`));
    }
  } else {
    const n = at("ProfileSchema"), s = A.createGroup();
    s.addMember("everyone", "reader");
    const a = s.createMap({ name: i }, n);
    t.set("profile", a.id);
  }
  await kQ(t, A), await NQ(t, A);
}
async function kQ(t, A) {
  const e = t.get?.("sparks");
  if (!e || typeof e != "string" || !e.startsWith("co_z")) return;
  const i = A.getCoValue(e) || await A.loadCoValueCore(e);
  if (!i?.isAvailable?.()) return;
  const o = i.getCurrentContent?.();
  if (!o || typeof o.get != "function") return;
  let r = 0;
  const n = typeof o.keys == "function" ? Array.from(o.keys()) : Object.keys(o ?? {});
  for (const s of n) {
    const a = o.get(s);
    if (!a || typeof a != "string" || !a.startsWith("co_z")) continue;
    const g = A.getCoValue(a) || await A.loadCoValueCore(a);
    if (!g?.isAvailable?.()) continue;
    const I = g.getCurrentContent?.();
    if (!I || typeof I.get != "function") continue;
    const c = I.get("os");
    if (!c || typeof c != "string" || !c.startsWith("co_z")) continue;
    const C = A.getCoValue(c) || await A.loadCoValueCore(c);
    if (!C?.isAvailable?.()) continue;
    const B = C.getCurrentContent?.();
    if (!B || typeof B.get != "function") continue;
    const Q = B.get("capabilities");
    if (!Q || typeof Q != "string" || !Q.startsWith("co_z")) continue;
    const f = A.getCoValue(Q) || await A.loadCoValueCore(Q);
    if (!f?.isAvailable?.()) continue;
    const l = f.getCurrentContent?.();
    if (!l || typeof l.set != "function") continue;
    const u = l.get("sparkGuardian");
    !u || typeof u != "string" || !u.startsWith("co_z") || l.get("guardian") || (l.set("guardian", u), l.delete?.("sparkGuardian"), r++);
  }
  r > 0 && console.log(`    Migrated capabilities sparkGuardian -> guardian (${r} sparks)`);
}
async function NQ(t, A) {
  const e = t.get?.("sparks");
  if (!e || typeof e != "string" || !e.startsWith("co_z")) return;
  const i = A.getCoValue(e) || await A.loadCoValueCore(e);
  if (!i?.isAvailable?.()) return;
  const o = i.getCurrentContent?.();
  if (!o || typeof o.get != "function") return;
  const r = typeof o.keys == "function" ? Array.from(o.keys()) : Object.keys(o ?? {});
  for (const n of r) {
    const s = o.get(n);
    if (!s || typeof s != "string" || !s.startsWith("co_z")) continue;
    const a = A.getCoValue(s) || await A.loadCoValueCore(s);
    if (!a?.isAvailable?.()) continue;
    const g = a.getCurrentContent?.();
    if (!g || typeof g.get != "function") continue;
    const I = g.get("registries");
    if (!I || typeof I != "string" || !I.startsWith("co_z")) continue;
    const c = A.getCoValue(I) || await A.loadCoValueCore(I);
    if (!c?.isAvailable?.()) continue;
    const C = c.getCurrentContent?.();
    if (!C || typeof C.set != "function" || C.get("humans")) continue;
    const B = g.get("os");
    if (!B?.startsWith("co_z")) continue;
    const Q = A.getCoValue(B) || await A.loadCoValueCore(B);
    if (!Q?.isAvailable?.()) continue;
    const f = Q.getCurrentContent?.();
    if (!f?.get) continue;
    const l = f.get("capabilities");
    if (!l?.startsWith("co_z")) continue;
    const u = A.getCoValue(l) || await A.loadCoValueCore(l);
    if (!u?.isAvailable?.()) continue;
    const d = u.getCurrentContent?.();
    if (!d?.get) continue;
    const h = d.get("guardian"), p = d.get("publicReaders");
    if (!h?.startsWith("co_z") || !p?.startsWith("co_z")) continue;
    const E = A.getCoValue(h) || await A.loadCoValueCore(h), w = A.getCoValue(p) || await A.loadCoValueCore(p);
    if (!E?.isAvailable?.() || !w?.isAvailable?.()) continue;
    const y = E.getCurrentContent?.(), m = w.getCurrentContent?.();
    if (!y?.createMap || !m) continue;
    const { EXCEPTION_SCHEMAS: k } = await Promise.resolve().then(() => Pt), b = { $schema: k.META_SCHEMA }, q = A.createGroup();
    q.extend(y, "extend"), q.extend(m, "reader");
    const P = q.createMap({}, b), J = typeof A.getCurrentAccountOrAgentID == "function" ? A.getCurrentAccountOrAgentID() : t?.id ?? t?.$jazz?.id;
    try {
      const { removeGroupMember: W } = await Promise.resolve().then(() => ce);
      await W(q, J);
    } catch {
    }
    C.set("humans", P.id), console.log(`    Created spark.registries.humans for spark ${n}`);
  }
}
function MQ(t) {
  t.addKeyword({
    keyword: "$co",
    macro: (A) => ({
      type: "string",
      pattern: "^co_z[a-zA-Z0-9]+$",
      _schemaRef: A
      // Store schema co-id for metadata
    }),
    metaSchema: {
      type: "string",
      anyOf: [
        {
          pattern: "^co_z[a-zA-Z0-9]+$",
          description: "Co-id reference (after transformation)"
        },
        {
          pattern: "^@[a-zA-Z0-9_-]+/schema/",
          description: "Human-readable schema ID (before transformation)"
        }
      ],
      description: "Reference to schema that this property value must conform to (human-readable ID or co-id)"
    }
  }), t.addKeyword({
    keyword: "cotype",
    validate: (A, e) => e === null || typeof e != "object" ? !0 : A === "comap" ? !Array.isArray(e) : A === "colist" || A === "costream" ? !!(Array.isArray(e) || typeof e == "object" && e !== null && Array.isArray(e.items)) : !1,
    metaSchema: {
      enum: ["comap", "colist", "costream"]
    }
  }), t.addKeyword({
    keyword: "indexing",
    validate: () => !0,
    // Always pass - it's metadata, not a validation rule
    metaSchema: {
      type: "boolean",
      description: "Whether instances of this schema should be indexed in account.os.{schemaCoId}"
    }
  });
}
const Do = /^@[a-zA-Z0-9_-]+\/schema\//, AI = /^@[a-zA-Z0-9_-]+\/vibe\//;
function MA(t) {
  return typeof t == "string" && Do.test(t);
}
function eI(t) {
  return typeof t == "string" && AI.test(t);
}
const GQ = "https://json-schema.org/draft/2020-12/schema", FQ = "@maia/schema/meta", bQ = { "https://json-schema.org/draft/2020-12/vocab/core": !0, "https://json-schema.org/draft/2020-12/vocab/applicator": !0, "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0, "https://json-schema.org/draft/2020-12/vocab/validation": !0, "https://json-schema.org/draft/2020-12/vocab/meta-data": !0, "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0, "https://json-schema.org/draft/2020-12/vocab/content": !0, "https://maiaos.dev/vocab/cojson": !0 }, RQ = [{ $ref: "https://json-schema.org/draft/2020-12/schema" }], KQ = "@maia/schema/meta", vQ = ["object", "boolean"], YQ = !1, UQ = { title: { type: "string", description: "Human-readable schema title (required)" }, cotype: { enum: ["comap", "colist", "costream"], description: "CRDT type at schema root. Schemas can be comap (with properties), colist (with items), or costream (with items). CoText is modeled as colist with string items." }, $co: { type: "string", anyOf: [{ pattern: "^co_z[a-zA-Z0-9]+$", description: "Co-id reference (after transformation)" }, { pattern: "^@[a-zA-Z0-9_-]+/schema/", description: "Human-readable schema ID (before transformation)" }], description: "Reference to schema that this property value must conform to (human-readable ID or co-id). Use $co in properties to reference separate CoValues, never use cotype in properties." }, indexing: { type: "boolean", default: !1, description: "Whether instances of this schema should be indexed in account.os.{schemaCoId}" } }, JQ = ["title", "cotype"], HQ = { comap: { description: "CoMap - CRDT-based collaborative map/object", type: "object", properties: {}, additionalProperties: { anyOf: [{ type: "string", description: "Standard string value" }, { type: "number", description: "Standard number value" }, { type: "integer", description: "Standard integer value" }, { type: "boolean", description: "Standard boolean value" }, { type: "null", description: "Null value" }, { type: "object", description: "Nested object value" }, { type: "array", description: "Array value" }, { type: "string", pattern: "^co_z[a-zA-Z0-9]+$", description: "Co-id reference to another CoValue" }, { type: "string", pattern: "^key_[a-zA-Z0-9_]+$", description: "Key reference" }, { type: "string", pattern: "^sealed_", description: "Sealed/encrypted value" }] } }, costream: { description: "CoStream - CRDT-based append-only stream", type: "array", items: { anyOf: [{ type: "object", description: "Stream item object" }, { type: "string", description: "Stream item string" }, { type: "number", description: "Stream item number" }, { type: "boolean", description: "Stream item boolean" }, { type: "null", description: "Stream item null" }] } }, colist: { description: "CoList - CRDT-based collaborative list/array", type: "array", items: { anyOf: [{ type: "object", description: "List item object" }, { type: "string", description: "List item string (can be co-id reference)" }, { type: "number", description: "List item number" }, { type: "integer", description: "List item integer" }, { type: "boolean", description: "List item boolean" }, { type: "null", description: "List item null" }, { type: "array", description: "Nested array" }] } } }, oo = {
  $schema: GQ,
  $id: FQ,
  $vocabulary: bQ,
  allOf: RQ,
  title: KQ,
  type: vQ,
  indexing: YQ,
  properties: UQ,
  required: JQ,
  $defs: HQ
};
class Ye {
  constructor(A = {}) {
    this.ajv = null, this.ajvPromise = null, this.initialized = !1, this.schemas = /* @__PURE__ */ new Map(), this.schemaResolver = null, this.registrySchemas = A.registrySchemas || null;
  }
  /**
   * Set schema resolver function for resolving $schema references from IndexedDB
   * @param {Function} resolver - Async function that takes a schema key and returns the schema
   */
  setSchemaResolver(A) {
    this.schemaResolver = A;
  }
  /**
   * Initialize AJV (loads from CDN in browser, uses import in Node/Bun)
   * @returns {Promise<void>}
   */
  async initialize() {
    if (!this.initialized) {
      if (this.ajvPromise) {
        await this.ajvPromise;
        return;
      }
      this.ajvPromise = (async () => {
        let A;
        try {
          const e = await Promise.resolve().then(() => A0);
          A = e.default || e.Ajv2020 || e;
        } catch {
          try {
            A = (await Promise.resolve().then(() => C0)).default;
          } catch {
            try {
              const o = await import("https://esm.sh/ajv@8.12.0/dist/2020.js");
              A = o.default || o.Ajv2020 || o;
            } catch {
              const r = await import("https://esm.sh/ajv@8.12.0");
              A = r.default || r;
            }
          }
        }
        this.ajv = new A({
          allErrors: !0,
          // Collect all errors, not just first
          verbose: !0,
          // Include schema and data paths in errors
          strict: !1,
          // Be permissive initially
          validateSchema: !0,
          // Validate schemas themselves (meta-schema will be loaded)
          validateFormats: !0,
          // Enable format validation
          removeAdditional: !1,
          // Don't remove extra properties
          useDefaults: !1,
          // Don't add defaults
          coerceTypes: !1,
          // Don't coerce types
          loadSchema: async (e) => {
            if (e.startsWith("co_z")) {
              if (this.schemaResolver)
                try {
                  let i = await this.schemaResolver(e);
                  return i && i.$coId && !i.$schema && (i = await this.schemaResolver(i.$coId)), i || void 0;
                } catch (i) {
                  console.warn(`[ValidationEngine] loadSchema failed for ${e}:`, i);
                  return;
                }
              return;
            }
          }
        }), this.ajv.addFormat("uri-reference", {
          type: "string",
          validate: (e) => {
            if (!e || typeof e != "string") return !1;
            if (e === "") return !0;
            try {
              return new URL(e), !0;
            } catch {
              return !0;
            }
          }
        }), this.ajv.addFormat("regex", {
          type: "string",
          validate: (e) => {
            if (!e || typeof e != "string") return !1;
            try {
              return new RegExp(e), !0;
            } catch {
              return !1;
            }
          }
        }), this._loadMetaSchema(), this._loadCoJsonMetaSchema(), MQ(this.ajv), await this._loadCoTypeDefinitions(), this.registrySchemas && await this.registerAllSchemas(this.registrySchemas), this.initialized = !0;
      })(), await this.ajvPromise;
    }
  }
  /**
   * Get the CoJSON custom meta-schema (extends JSON Schema Draft 2020-12)
   * @returns {Object} Meta schema object
   */
  static getMetaSchema() {
    return oo;
  }
  /**
   * Get the base JSON Schema Draft 2020-12 meta-schema
   * @returns {Object} Meta schema object
   */
  static getBaseMetaSchema() {
    return oo;
  }
  /**
   * Load JSON Schema Draft 2020-12 meta-schema (hardcoded)
   * @private
   */
  _loadMetaSchema() {
    const A = "https://json-schema.org/draft/2020-12/schema", e = "@maia/schema/meta-schema", i = Ye.getBaseMetaSchema();
    try {
      ne(this.ajv, () => {
        if (this.ajv.getSchema(A) || this.ajv.addMetaSchema(i, i.$id), !this.ajv.getSchema(e)) {
          const o = JSON.parse(JSON.stringify(i));
          o.$id = e, this.ajv.addMetaSchema(o, e);
        }
      });
    } catch (o) {
      if (!o.message || !o.message.includes("already exists")) {
        console.warn("[ValidationEngine] Failed to add meta-schema:", o.message);
        return;
      }
    }
  }
  /**
   * Load CoJSON custom meta-schema
   * @private
   */
  _loadCoJsonMetaSchema() {
    const A = "@maia/schema/meta";
    try {
      ne(this.ajv, () => {
        this.ajv.getSchema(A) || this.ajv.addMetaSchema(oo, A);
      });
    } catch (e) {
      (!e.message || !e.message.includes("already exists")) && console.warn("[ValidationEngine] Failed to add CoJSON meta-schema:", e.message);
    }
  }
  /**
   * Resolve meta-schema ID from co-id or return as-is
   * @private
   * @param {string} schemaMetaSchemaId - Meta-schema ID (may be co-id)
   * @returns {Promise<{resolvedMetaSchemaId: string, metaSchemaObject: Object|null}>}
   */
  async _resolveMetaSchemaId(A) {
    let e = A, i = null;
    if (A.startsWith("co_z"))
      if (this.schemaResolver)
        if (i = await this.schemaResolver(A), i && i.$id)
          e = i.$id;
        else if (this.ajv.getSchema(A))
          e = A;
        else
          throw new Error(`[ValidationEngine] Could not resolve meta-schema co-id '${A}'. Schema resolver returned null or undefined.`);
      else if (this.ajv.getSchema(A))
        e = A;
      else
        throw new Error(`[ValidationEngine] Meta-schema co-id '${A}' not found and no schema resolver available.`);
    return { resolvedMetaSchemaId: e, metaSchemaObject: i };
  }
  /**
   * Determine meta-schema type (CoJSON vs standard JSON Schema)
   * @private
   * @param {Object} metaSchemaObject - Resolved meta-schema object
   * @returns {string} Target meta-schema ID ('@maia/schema/meta' or standard meta-schema ID)
   */
  _determineMetaSchemaType(A) {
    const e = A.properties && A.properties.cotype && A.properties.cotype.enum && Array.isArray(A.properties.cotype.enum) && A.properties.cotype.enum.includes("comap"), i = A.$vocabulary && A.$vocabulary["https://maiaos.dev/vocab/cojson"] === !0;
    return e || i ? "@maia/schema/meta" : A.$vocabulary ? "https://json-schema.org/draft/2020-12/schema" : "@maia/schema/meta";
  }
  /**
   * Get meta-schema validator, registering if necessary
   * @private
   * @param {string} resolvedMetaSchemaId - Resolved meta-schema ID
   * @param {Object|null} metaSchemaObject - Resolved meta-schema object (if available)
   * @returns {Function|null} Meta-schema validator function
   */
  _getMetaSchemaValidator(A, e) {
    if (A === "@maia/schema/meta" || A === "@maia/schema/meta-schema")
      return this.ajv.getSchema("@maia/schema/meta");
    if (A === "https://json-schema.org/draft/2020-12/schema")
      return this.ajv.getSchema("https://json-schema.org/draft/2020-12/schema");
    if (A.startsWith("co_z")) {
      let i = this.ajv.getSchema(A);
      if (!i && e) {
        const o = this._determineMetaSchemaType(e);
        if (i = this.ajv.getSchema(o), !i && e)
          try {
            ne(this.ajv, () => {
              this.ajv.addSchema(e, A), o !== A && this.ajv.addSchema(e, o), i = this.ajv.getSchema(o);
            });
          } catch {
            i = this.ajv.getSchema(o);
          }
      }
      if (!i)
        throw new Error(`[ValidationEngine] Meta-schema validator not found for co-id '${A}'. Make sure the meta-schema is registered in AJV.`);
      return i;
    } else
      throw new Error(`[ValidationEngine] Unknown meta schema (resolved to '${A}'). Expected '@maia/schema/meta' or standard JSON Schema meta schema.`);
  }
  /**
   * Validate a schema against its meta-schema
   * @param {Object} schema - Schema to validate
   * @returns {{valid: boolean, errors: Array|null}} Validation result
   */
  async validateSchemaAgainstMeta(A) {
    await this.initialize();
    const e = A.$schema;
    if (!e)
      throw new Error("[ValidationEngine] Schema missing required $schema field. All schemas must declare their meta schema.");
    const { resolvedMetaSchemaId: i, metaSchemaObject: o } = await this._resolveMetaSchemaId(e), r = this._getMetaSchemaValidator(i, o);
    if (!r)
      return console.warn(`[ValidationEngine] Meta schema '${e}' not available, skipping schema validation`), { valid: !0, errors: null };
    const n = "https://json-schema.org/draft/2020-12/schema";
    if (A.$id === n || A.$id === "@maia/schema/meta" || A.$schema === n && A.$id && A.$id.includes("schema"))
      return ne(this.ajv, () => {
        if (r(A))
          return { valid: !0, errors: null };
        const C = r.errors || [];
        return {
          valid: !1,
          errors: be(C)
        };
      });
    if (r(A))
      return { valid: !0, errors: null };
    const g = r.errors || [];
    return {
      valid: !1,
      errors: be(g)
    };
  }
  /**
   * Load a schema for a given type
   * @param {string} type - Schema type identifier (e.g., 'actor', 'context', 'state')
   * @param {object} schema - JSON Schema object
   */
  async loadSchema(A, e) {
    if (await this.initialize(), !A || typeof A != "string")
      throw new Error("Schema type must be a non-empty string");
    if (!e || typeof e != "object")
      throw new Error("Schema must be an object");
    if (this.schemas.has(A))
      return this.schemas.get(A);
    if (await this._resolveAndRegisterSchemaDependencies(e), e.$id) {
      const i = this.ajv.getSchema(e.$id);
      if (i)
        return this.schemas.set(A, i), i;
    }
    try {
      const i = this.ajv.compile(e);
      return this.schemas.set(A, i), i;
    } catch (i) {
      if (i.message && i.message.includes("already exists") && e.$id) {
        const o = this.ajv.getSchema(e.$id);
        if (o)
          return this.schemas.set(A, o), o;
      }
      throw new Error(`Failed to load schema for type '${A}': ${i.message}`);
    }
  }
  /**
   * Resolve $schema reference (co-id) and register meta-schema
   * @private
   * @param {string} coId - Co-id of the meta-schema
   * @param {Set} resolvedSchemas - Set of already resolved schema co-ids
   * @param {Set} resolvingSchemas - Set of schemas currently being resolved
   * @param {Function} resolveRecursive - Recursive resolution function
   * @returns {Promise<void>}
   */
  async _resolveSchemaReference(A, e, i, o) {
    if (!(e.has(A) || i.has(A))) {
      i.add(A);
      try {
        let r = await this.schemaResolver(A);
        r && r.$coId && !r.$schema && (r = await this.schemaResolver(r.$coId)), r ? (await o(r), r.$id && (this.ajv.getSchema(r.$id) || this.ajv.addMetaSchema(r, r.$id)), this.ajv.getSchema(A) || this.ajv.addMetaSchema(r, A), e.add(A)) : console.warn(`[ValidationEngine] Schema resolver returned null for $schema co-id ${A}`);
      } catch (r) {
        throw console.error(`[ValidationEngine] Failed to resolve $schema co-id ${A}:`, r), r;
      } finally {
        i.delete(A);
      }
    }
  }
  /**
   * Register a resolved schema in AJV
   * @private
   * @param {Object} schema - Schema to register
   * @param {string} ref - Reference ID (should be co-id after transformation)
   * @param {string} coId - Co-id of the schema
   */
  _registerResolvedSchema(A, e, i) {
    if (e && MA(e) && console.warn(`[ValidationEngine] Warning: Registering schema with @maia/schema/ reference: ${e}. This should be a co-id after seeding. Schema may be from source files instead of database.`), e !== i && e && !this.ajv.getSchema(e))
      try {
        ne(this.ajv, () => {
          this.ajv.addSchema(A, e);
        });
      } catch (o) {
        if (!(o.message && o.message.includes("already exists"))) throw o;
      }
    if (i && !this.ajv.getSchema(i))
      try {
        ne(this.ajv, () => {
          this.ajv.addSchema(A, i);
        });
      } catch (o) {
        if (!(o.message && o.message.includes("already exists"))) throw o;
      }
  }
  /**
   * Resolve $co reference and register schema
   * @private
   * @param {string} ref - Reference (co-id or human-readable ID)
   * @param {Set} resolvedSchemas - Set of already resolved schema co-ids
   * @param {Set} resolvingSchemas - Set of schemas currently being resolved
   * @param {Function} resolveRecursive - Recursive resolution function
   * @returns {Promise<void>}
   */
  async _resolveCoReference(A, e, i, o) {
    if (!(e.has(A) || i.has(A))) {
      A && MA(A) && console.warn(`[ValidationEngine] Warning: Resolving $co reference with @maia/schema/ pattern: ${A}. This should be a co-id after seeding. The schema may not have been transformed correctly.`), i.add(A);
      try {
        let r = await this.schemaResolver(A);
        if (r && r.$coId && !r.$schema && (r = await this.schemaResolver(r.$coId)), !r) {
          const s = `[ValidationEngine] Schema resolver returned null for $co reference ${A}. This schema must be registered before it can be referenced. If this is an @domain/schema/... reference, ensure schemas were transformed correctly during seeding.`;
          throw console.error(s), new Error(s);
        }
        const n = r.$id;
        if (n && e.has(n)) {
          i.delete(A);
          return;
        }
        await o(r), n && e.add(n), e.add(A), this._registerResolvedSchema(r, A, n);
      } catch (r) {
        if (r.message && r.message.includes("already exists"))
          console.warn(`[ValidationEngine] Duplicate registration handled for ${A}`);
        else
          throw console.error(`[ValidationEngine] Failed to resolve $co reference ${A}:`, r), r;
      } finally {
        i.delete(A);
      }
    }
  }
  /**
   * Resolve and register all schema dependencies ($schema and $co references)
   * @private
   * @param {Object} schema - Schema object
   */
  async _resolveAndRegisterSchemaDependencies(A) {
    !A || typeof A != "object" || !this.schemaResolver || await ne(this.ajv, async () => {
      const e = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set(), o = async (r) => {
        if (!(!r || typeof r != "object")) {
          r.$schema && typeof r.$schema == "string" && r.$schema.startsWith("co_z") && await this._resolveSchemaReference(r.$schema, e, i, o), r.$co && typeof r.$co == "string" && await this._resolveCoReference(r.$co, e, i, o);
          for (const n of Object.values(r))
            if (Array.isArray(n))
              for (const s of n)
                await o(s);
            else n && typeof n == "object" && await o(n);
        }
      };
      await o(A);
    });
  }
  /**
   * Check if a schema is loaded
   * @param {string} type - Schema type identifier
   * @returns {boolean} True if schema is loaded
   */
  hasSchema(A) {
    return this.schemas.has(A);
  }
  /**
   * Validate data against a schema
   * @param {string} type - Schema type identifier
   * @param {any} data - Data to validate
   * @returns {{valid: boolean, errors: Array|null}} Validation result
   */
  async validate(A, e) {
    if (await this.initialize(), !this.schemas.has(A))
      throw new Error(`Schema '${A}' not loaded. Call loadSchema() first.`);
    const i = this.schemas.get(A);
    if (i(e))
      return {
        valid: !0,
        errors: null
      };
    const r = i.errors || [];
    return {
      valid: !1,
      errors: be(r)
    };
  }
  /**
   * Validate data and throw if invalid
   * @param {string} type - Schema type identifier
   * @param {any} data - Data to validate
   * @param {string} context - Optional context for error message (e.g., file path)
   * @throws {Error} If validation fails
   */
  async validateOrThrow(A, e, i = "") {
    const o = await this.validate(A, e);
    if (!o.valid) {
      const r = i ? ` in ${i}` : "", n = o.errors.map((s) => `  - ${s.instancePath}: ${s.message}`).join(`
`);
      throw new Error(
        `Validation failed for '${A}'${r}:
${n}`
      );
    }
    return o;
  }
  /**
   * Load co-type definitions into AJV (REQUIRED for all CoValue validation)
   * @private
   */
  async _loadCoTypeDefinitions() {
    const e = {
      $id: "https://maia.city/schemas/co-types",
      $defs: (await Promise.resolve().then(() => IQ)).$defs
    };
    if (!this.ajv.getSchema(e.$id))
      try {
        ne(this.ajv, () => {
          this.ajv.addSchema(e, e.$id);
        });
      } catch (i) {
        (!i.message || !i.message.includes("already exists")) && console.warn("[ValidationEngine] Failed to add co-type definitions:", i.message);
      }
  }
  /**
   * Register all schemas from registry into AJV (MIGRATIONS/SEEDING ONLY)
   * @param {Object} schemas - Map of schema names to schema definitions
   * @returns {Promise<void>}
   */
  async registerAllSchemas(A) {
    if (await this.initialize(), !A || typeof A != "object")
      return;
    const e = this.ajv, i = e.opts.validateSchema;
    e.opts.validateSchema = !1;
    try {
      for (const [o, r] of Object.entries(A))
        if (r && r.$id && !e.getSchema(r.$id))
          try {
            e.addSchema(r, r.$id);
          } catch (n) {
            n.message.includes("already exists") || console.warn(`[ValidationEngine] Failed to add schema ${o}:`, n);
          }
    } finally {
      e.opts.validateSchema = i;
    }
  }
  /**
   * Validate data against a schema by name (MIGRATIONS/SEEDING ONLY)
   * CRITICAL: This method is ONLY for migrations/seeding
   * Runtime validation MUST use validateAgainstSchema() with schema loaded from CoValue header metadata
   * 
   * @param {string} schemaName - Schema name (human-readable ID from registry)
   * @param {any} data - Data to validate
   * @returns {Promise<{valid: boolean, errors: Array|null}>} Validation result
   */
  async validateData(A, e) {
    if (await this.initialize(), !this.registrySchemas)
      throw new Error("[ValidationEngine] validateData() requires registrySchemas. This method is ONLY for migrations/seeding. Runtime validation must use validateAgainstSchema() with schema from CoValue header metadata.");
    const i = this.registrySchemas[A];
    if (!i)
      return {
        valid: !1,
        errors: [{ message: `Schema '${A}' not found in registry` }]
      };
    let o;
    if (i.$id && (o = this.ajv.getSchema(i.$id)), !o)
      try {
        await this._resolveAndRegisterSchemaDependencies(i), o = this.ajv.compile(i);
      } catch (r) {
        return {
          valid: !1,
          errors: [{ message: `Failed to compile schema '${A}': ${r.message}` }]
        };
      }
    try {
      if (o(e))
        return {
          valid: !0,
          errors: null
        };
      const n = o.errors || [];
      return {
        valid: !1,
        errors: be(n)
      };
    } catch (r) {
      return {
        valid: !1,
        errors: [{ message: `Validation error: ${r.message}` }]
      };
    }
  }
}
function tI(t, A, e = {}) {
  if (!t || typeof t != "object")
    return t;
  const i = t.$schema;
  if (typeof i == "string" && /\/schema\/meta$/.test(i) || typeof i == "string" && i.startsWith("https://json-schema.org/") || typeof i == "string" && i.startsWith("https://"))
    return Fe(t, A);
  const r = t.actor !== void 0 || t.context !== void 0 || t.view !== void 0 || t.state !== void 0 || t.brand !== void 0 || t.style !== void 0 || t.inbox !== void 0 || t.subscribers !== void 0 || t.name !== void 0 && t.description !== void 0;
  return i && MA(i) && !/\/schema\/meta$/.test(i) || r ? ws(t, A, e) : t.properties !== void 0 || t.$defs !== void 0 || t.items !== void 0 && typeof t.items == "object" && !Array.isArray(t.items) || t.cotype !== void 0 ? Fe(t, A) : ws(t, A, e);
}
function Fe(t, A) {
  if (!t || typeof t != "object")
    return t;
  const e = JSON.parse(JSON.stringify(t));
  if (e.$schema) {
    const o = e.$schema;
    if (MA(o)) {
      const r = A.get(o);
      r && (e.$schema = r);
    }
  }
  if (e.$id && typeof e.$id == "string" && (MA(e.$id) || e.$id.startsWith("https://"))) {
    const o = A.get(e.$id);
    o && (e.$id = o);
  }
  if (e.properties && qQ(e.properties, A), e.$defs)
    for (const [o, r] of Object.entries(e.$defs))
      e.$defs[o] = Fe(r, A);
  return Gr(e, A, e.$id || "root") > 0 && e.$id, e.items && (e.items = Fe(e.items, A)), e.additionalProperties && typeof e.additionalProperties == "object" && (e.additionalProperties = Fe(e.additionalProperties, A)), ["allOf", "anyOf", "oneOf"].forEach((o) => {
    e[o] && Array.isArray(e[o]) && (e[o] = e[o].map(
      (r) => Fe(r, A)
    ));
  }), e;
}
function qQ(t, A) {
  for (const [e, i] of Object.entries(t))
    i && typeof i == "object" && (t[e] = Fe(i, A));
}
function Gr(t, A, e = "") {
  if (!t || typeof t != "object")
    return 0;
  let i = 0;
  if (t.$co && typeof t.$co == "string") {
    const o = t.$co;
    if (o.startsWith("co_z"))
      return 0;
    if (MA(o)) {
      const r = A.get(o);
      if (r)
        t.$co = r, i++;
      else {
        const n = Array.from(A.keys()).filter((s) => MA(s)).slice(0, 10).join(", ");
        throw console.error(`[SchemaTransformer]  No co-id found for $co reference at ${e || "root"}: ${o}. Available schema keys (first 10): ${n}`), new Error(`[SchemaTransformer] Failed to transform $co reference: ${o}. Schema must be registered before it can be referenced.`);
      }
    }
  }
  for (const [o, r] of Object.entries(t))
    if (!(o === "$schema" || o === "$id" || o.startsWith("$")))
      if (r && typeof r == "object" && !Array.isArray(r)) {
        const n = e ? `${e}.${o}` : o;
        i += Gr(r, A, n);
      } else Array.isArray(r) && r.forEach((n, s) => {
        if (n && typeof n == "object") {
          const a = e ? `${e}.${o}[${s}]` : `${o}[${s}]`;
          i += Gr(n, A, a);
        }
      });
  return i;
}
function ws(t, A, e = {}) {
  if (!t || typeof t != "object")
    return t;
  const i = JSON.parse(JSON.stringify(t));
  if (i.$schema) {
    const r = i.$schema;
    if (MA(r)) {
      const n = A.get(r);
      n && (i.$schema = n);
    }
  }
  if (i.$id && typeof i.$id == "string" && !i.$id.startsWith("co_z")) {
    const r = MA(i.$id) || i.$id.startsWith("vibe/") || i.$id.startsWith("actor/") || i.$id.startsWith("view/") || i.$id.startsWith("context/") || i.$id.startsWith("state/") || i.$id.startsWith("interface/") || i.$id.startsWith("style/") || i.$id.startsWith("brand/") || i.$id.startsWith("tool/"), n = A.get(i.$id);
    n ? i.$id = n : r && console.warn(`[SchemaTransformer] No co-id found for $id: ${i.$id}`);
  }
  const o = ["actor", "context", "view", "state", "brand", "style", "inbox", "subscribers"];
  for (const r of o)
    if (i[r] && typeof i[r] == "string") {
      const n = i[r];
      if (n.startsWith("co_z"))
        continue;
      if (!n.startsWith("@"))
        throw new Error(`[SchemaTransformer] ${r} reference must use @maiatype/instance format, got: ${n}`);
      const s = A.get(n);
      if (s)
        i[r] = s;
      else {
        const a = Array.from(A.keys()).filter((g) => g.startsWith("@")).slice(0, 10).join(", ");
        throw new Error(
          `[SchemaTransformer] No co-id found for ${r} reference: ${n}. Make sure the referenced instance exists and has a unique $id. Available refs (first 10): ${a}`
        );
      }
    }
  if (i.actors && typeof i.actors == "object" && !Array.isArray(i.actors)) {
    for (const [r, n] of Object.entries(i.actors))
      if (typeof n == "string") {
        if (n.startsWith("co_z"))
          continue;
        if (!n.match(/^@[^/]+.*\/actor\//))
          throw new Error(`[SchemaTransformer] context.actors[${r}] must use @namespace/actor/instance format, got: ${n}`);
        const s = A.get(n);
        if (s)
          i.actors[r] = s;
        else
          throw new Error(
            `[SchemaTransformer] No co-id found for context.actors[${r}] reference: ${n}. Make sure the referenced actor exists and has a unique $id.`
          );
      }
  }
  if (i.children && typeof i.children == "object") {
    for (const [r, n] of Object.entries(i.children))
      if (typeof n == "string" && !n.startsWith("co_z")) {
        if (!n.match(/^@[^/]+.*\/actor\//))
          throw new Error(`[SchemaTransformer] children[${r}] reference must use @namespace/actor/instance format, got: ${n}`);
        const s = A.get(n);
        if (s)
          i.children[r] = s;
        else {
          const a = Array.from(A.keys()).filter((g) => g.startsWith("@actor/")).slice(0, 10).join(", ");
          throw new Error(
            `[SchemaTransformer] No co-id found for children[${r}] reference: ${n}. Available actors (first 10): ${a}`
          );
        }
      }
  }
  if (i.items && Array.isArray(i.items) && i.items.some(
    (n) => typeof n == "string" && n.startsWith("@") && !n.startsWith("co_z")
  ) && (i.items = i.items.map((n) => {
    if (typeof n == "string" && !n.startsWith("co_z")) {
      if (!n.startsWith("@"))
        throw new Error(`[SchemaTransformer] items array reference must use @maiatype/instance format, got: ${n}`);
      const s = A.get(n);
      if (s)
        return s;
      throw new Error(`[SchemaTransformer] No co-id found for items reference: ${n}. Make sure the referenced instance exists and has a unique $id.`);
    }
    return n;
  })), i.source && typeof i.source == "string" && !i.source.startsWith("co_z")) {
    if (!i.source.startsWith("@"))
      throw new Error(`[SchemaTransformer] source reference must use @actor/instance format, got: ${i.source}`);
    const r = A.get(i.source);
    if (r)
      i.source = r;
    else
      throw new Error(`[SchemaTransformer] No co-id found for source reference: ${i.source}`);
  }
  if (i.target && typeof i.target == "string" && !i.target.startsWith("co_z")) {
    if (!i.target.match(/^@[^/]+.*\/actor\//))
      throw new Error(`[SchemaTransformer] target reference must use @namespace/actor/instance format, got: ${i.target}`);
    const r = A.get(i.target);
    if (r)
      i.target = r;
    else
      throw new Error(`[SchemaTransformer] No co-id found for target reference: ${i.target}`);
  }
  if (i.states && typeof i.states == "object" && !Array.isArray(i.states)) {
    for (const [r, n] of Object.entries(i.states))
      if (!(!n || typeof n != "object")) {
        if (n.entry)
          if (n.entry.tool && n.entry.payload)
            qt(n.entry.payload, A, jA);
          else if (n.entry.mapData && typeof n.entry.mapData == "object") {
            const s = n.entry.mapData;
            for (const [a, g] of Object.entries(s)) {
              if (g && typeof g == "object" && g.schema && typeof g.schema == "string") {
                const I = st(g.schema, A, `mapData.${a}.schema`);
                I && (g.schema = I);
              }
              g && typeof g == "object" && jA(g, A);
            }
          } else Array.isArray(n.entry) ? Fr(n.entry, A, jA) : n.entry.payload && qt(n.entry.payload, A, jA);
        if (n.on && typeof n.on == "object")
          for (const [s, a] of Object.entries(n.on))
            a && typeof a == "object" && Array.isArray(a.actions) && Fr(a.actions, A, jA);
      }
  }
  return jA(i, A), i;
}
function st(t, A, e = "") {
  if (MA(t) && !t.startsWith("co_z")) {
    const i = A.get(t);
    return i || (console.warn(`[SchemaTransformer] No co-id found for ${e} schema: ${t}. Make sure data collections are registered before transformation.`), null);
  }
  return t;
}
function Ht(t, A, e = "") {
  if (t.match(/^@[^/]+.*\/actor\//) && !t.startsWith("co_z")) {
    const i = A.get(t);
    if (i)
      return i;
    {
      const o = Array.from(A.keys()).filter((a) => a.includes("actor") || a.includes("vibe") || a.includes("composite")), r = o.length, n = o.slice(0, e.includes("array") ? 10 : 20).join(", "), s = r > (e.includes("array") ? 10 : 20) ? "..." : "";
      return console.warn(`[SchemaTransformer]  No co-id found for ${e} target: ${t}. Available actor keys (${r}): ${n}${s}`), null;
    }
  }
  return t;
}
function xQ(t, A) {
  if (!("key" in t && !("op" in t)) && t.schema && typeof t.schema == "string") {
    const e = st(t.schema, A, "query object");
    e && (t.schema = e);
  }
}
function qt(t, A, e) {
  if (!(!t || typeof t != "object")) {
    if (e(t, A), t.schema && typeof t.schema == "string") {
      const i = st(t.schema, A, "tool payload");
      i && (t.schema = i);
    }
    if (t.target && typeof t.target == "string") {
      const i = Ht(t.target, A, "tool payload");
      i && (t.target = i);
    }
  }
}
function iI(t, A, e) {
  if (!(!t.payload || typeof t.payload != "object")) {
    if (t.payload.target && typeof t.payload.target == "string") {
      const i = Ht(t.payload.target, A, "tool action");
      i && (t.payload.target = i);
    }
    e(t.payload, A);
  }
}
function Fr(t, A, e) {
  for (let i = 0; i < t.length; i++) {
    const o = t[i];
    if (o && typeof o == "object")
      if (o.mapData && typeof o.mapData == "object")
        for (const [r, n] of Object.entries(o.mapData)) {
          if (n && typeof n == "object" && n.schema && typeof n.schema == "string") {
            const s = st(n.schema, A, `mapData.${r}.schema in array`);
            s && (n.schema = s);
          }
          n && typeof n == "object" && e(n, A);
        }
      else if (o.tool && typeof o.tool == "string" && o.payload && typeof o.payload == "object")
        iI(o, A, e), qt(o.payload, A, e);
      else if (o.payload && typeof o.payload == "object") {
        if (o.payload.target && typeof o.payload.target == "string") {
          const r = Ht(o.payload.target, A, "action payload.target in array");
          r && (o.payload.target = r);
        }
        qt(o.payload, A, e);
      } else
        e(o, A);
    else if (typeof o == "string" && o.startsWith("@actor/") && !o.startsWith("co_z")) {
      const r = A.get(o);
      r && (t[i] = r);
    }
  }
}
function jA(t, A, e = 0) {
  if (!(!t || typeof t != "object" || Array.isArray(t))) {
    for (const [i, o] of Object.entries(t))
      if (!(i === "$schema" || i === "$id" || i.startsWith("$"))) {
        if (i === "schema" && typeof o == "string") {
          const r = st(o, A, "top-level schema field");
          r && (t[i] = r);
          continue;
        }
        if (i === "@actors" && o && typeof o == "object" && !Array.isArray(o)) {
          for (const [r, n] of Object.entries(o))
            if (typeof n == "string") {
              if (n.startsWith("co_z"))
                continue;
              if (!n.match(/^@[^/]+.*\/actor\//))
                throw new Error(`[SchemaTransformer] context.@actors[${r}] must use @namespace/actor/instance format, got: ${n}`);
              const s = Ht(n, A, `context.@actors[${r}]`);
              s && (o[r] = s);
            }
          continue;
        }
        if (i === "actors" && o && typeof o == "object" && !Array.isArray(o))
          throw new Error('[SchemaTransformer] Legacy "actors" property found. Please migrate to "@actors" system property.');
        if (i === "target" && typeof o == "string") {
          const r = Ht(o, A, "target field");
          r && (t[i] = r);
          continue;
        }
        if (o && typeof o == "object" && !Array.isArray(o))
          if (o.mapData && typeof o.mapData == "object") {
            const r = o.mapData;
            for (const [n, s] of Object.entries(r)) {
              if (s && typeof s == "object" && s.schema && typeof s.schema == "string") {
                const a = st(s.schema, A, `mapData.${n}.schema`);
                a && (s.schema = a);
              }
              s && typeof s == "object" && jA(s, A, e + 1);
            }
            continue;
          } else o.schema && typeof o.schema == "string" && !("key" in o) && !("op" in o) ? xQ(o, A) : o.payload && typeof o.payload == "object" ? qt(o.payload, A, jA) : o.tool && typeof o.tool == "string" && o.payload && typeof o.payload == "object" ? iI(o, A, jA) : jA(o, A, e + 1);
        else o && typeof o == "object" && Array.isArray(o) && Fr(o, A, jA);
      }
  }
}
function co(t, A = "", e = {}) {
  const { checkSchemaReferences: i = !0, checkNestedCoTypes: o = !0 } = e, r = [];
  if (!t || typeof t != "object")
    return r;
  if (i && (t.$co && typeof t.$co == "string" && MA(t.$co) && r.push(`Found @maia/schema/ reference in $co at ${A || "root"}: ${t.$co}. All $co references must be transformed to co-ids.`), t.$schema && typeof t.$schema == "string" && MA(t.$schema) && r.push(`Found @maia/schema/ reference in $schema at ${A || "root"}: ${t.$schema}. $schema must be transformed to co-id.`), t.$id && typeof t.$id == "string" && MA(t.$id) && r.push(`Found @maia/schema/ reference in $id at ${A || "root"}: ${t.$id}. $id must be transformed to co-id.`)), o && t.cotype && A !== "")
    return r.push(`Nested co-type detected at ${A}. Use \`$co\` keyword to reference a separate CoValue entity instead.`), r;
  for (const [n, s] of Object.entries(t))
    if (s && typeof s == "object" && !Array.isArray(s)) {
      const a = A ? `${A}.${n}` : n, g = co(s, a, e);
      r.push(...g);
    } else Array.isArray(s) && s.forEach((a, g) => {
      if (a && typeof a == "object") {
        const I = A ? `${A}.${n}[${g}]` : `${n}[${g}]`, c = co(a, I, e);
        r.push(...c);
      }
    });
  return r;
}
const wn = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  transformForSeeding: tI,
  validateSchemaStructure: co
}, Symbol.toStringTag, { value: "Module" }));
class oI {
  constructor() {
    this.registry = /* @__PURE__ */ new Map(), this.reverseRegistry = /* @__PURE__ */ new Map();
  }
  /**
   * Register a co-id for a human-readable ID
   * @param {string} humanId - Human-readable ID (e.g., "@maia/schema/actor", "actor_001")
   * @param {string} coId - Generated co-id
   */
  register(A, e) {
    if (this.registry.has(A)) {
      const i = this.registry.get(A);
      if (i !== e)
        throw new Error(`Co-id already registered for ${A}: ${i} (trying to register ${e})`);
      return;
    }
    this.registry.set(A, e), this.reverseRegistry.has(e) || this.reverseRegistry.set(e, A);
  }
  /**
   * Get co-id for a human-readable ID
   * @param {string} humanId - Human-readable ID
   * @returns {string|null} Co-id or null if not found
   */
  get(A) {
    return this.registry.get(A) || null;
  }
  /**
   * Get human-readable ID for a co-id
   * @param {string} coId - Co-id
   * @returns {string|null} Human-readable ID or null if not found
   */
  getHumanId(A) {
    return this.reverseRegistry.get(A) || null;
  }
  /**
   * Check if human-readable ID is registered
   * @param {string} humanId - Human-readable ID
   * @returns {boolean}
   */
  has(A) {
    return this.registry.has(A);
  }
  /**
   * Get all registered mappings
   * @returns {Map<string, string>} Map of human-readable ID  co-id
   */
  getAll() {
    return new Map(this.registry);
  }
  /**
   * Clear all registrations
   */
  clear() {
    this.registry.clear(), this.reverseRegistry.clear();
  }
}
const rI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CoIdRegistry: oI
}, Symbol.toStringTag, { value: "Module" })), LQ = "@maia/schema/meta", TQ = "@maia/schema/actor", OQ = "@maia/schema/actor", PQ = "Pure declarative actor specification", jQ = "comap", VQ = !0, $Q = { role: { type: "string", description: "Actor role (e.g., 'kanban-view', 'vibe', 'composite', 'leaf')" }, context: { $co: "@maia/schema/context", description: "Co-id reference to context definition" }, view: { $co: "@maia/schema/view", description: "Co-id reference to view definition" }, state: { $co: "@maia/schema/state", description: "Co-id reference to state machine definition" }, brand: { $co: "@maia/schema/style", description: "Co-id reference to brand style definition (uses style schema)" }, style: { $co: "@maia/schema/style", description: "Co-id reference to local style definition" }, inbox: { $co: "@maia/schema/inbox", description: "Co-id reference to message inbox costream (append-only message feed)" }, messageTypes: { type: "array", items: { type: "string" }, description: "REQUIRED: Message types this actor accepts (exhaustive list - like sealed protocol). All actors must declare their message contracts." } }, WQ = {
  $schema: LQ,
  $id: TQ,
  title: OQ,
  description: PQ,
  cotype: jQ,
  indexing: VQ,
  properties: $Q
}, zQ = "@maia/schema/meta", _Q = "@maia/schema/context", ZQ = "@maia/schema/context", XQ = "Runtime data for an actor (flexible JSON structure). The context itself is a comap CoValue (for CRDT sync/versioning), but all inner properties are plain JS objects/arrays/strings - NOT CoJSON types.", AE = "comap", eE = !0, tE = { description: "Any context fields (query objects, collections, UI state, form values, etc.). Query objects have schema + options properties. All inner properties are plain JS types (objects/arrays/strings/primitives) - NOT CoJSON types.", anyOf: [{ type: "object", description: "Query object for reactive subscription (has schema property). Can include nested options object with map, filter, etc.", properties: { schema: { type: "string", description: "Schema reference (e.g., '@maia/schema/message' or co-id)" }, options: { type: "object", description: "Query options (map, filter, etc.)", properties: { map: { type: "object", description: "Map transformation expressions (e.g., { sender: '$$source.role' })", additionalProperties: { type: "string" } }, filter: { description: "Filter criteria", oneOf: [{ type: "object" }, { type: "null" }] } }, additionalProperties: !0 }, filter: { description: "Filter criteria (legacy - use options.filter instead)", oneOf: [{ type: "object" }, { type: "null" }] } }, required: ["schema"], additionalProperties: !0 }, { type: "array", description: "Array of data items (after SubscriptionEngine processes the query object)" }, { type: "string" }, { type: "number" }, { type: "boolean" }, { type: "null" }, { type: "object", description: "Any other nested object (UI state, form values, etc.)" }] }, iE = {
  $schema: zQ,
  $id: _Q,
  title: ZQ,
  description: XQ,
  cotype: AE,
  indexing: eE,
  additionalProperties: tE
}, oE = "@maia/schema/meta", rE = "@maia/schema/state", nE = "@maia/schema/state", sE = "XState-like state machine with states, transitions, guards, and actions", aE = "comap", gE = !0, IE = ["initial", "states"], cE = { initial: { type: "string", description: "Initial state name" }, states: { type: "object", description: "State definitions", additionalProperties: { type: "object", properties: { entry: { oneOf: [{ type: "object", description: "Inline tool action object", properties: { tool: { type: "string", description: "Tool identifier" }, payload: { type: "object", description: "Tool payload", additionalProperties: !0 } }, required: ["tool"] }, { type: "object", description: "Infrastructure context update action", properties: { updateContext: { type: "object", description: "Context updates (infrastructure, not a tool)", additionalProperties: !0 } }, required: ["updateContext"] }, { type: "object", description: "Map operations engine configs to context keys (universal API)", properties: { mapData: { type: "object", description: "Map operations engine configs to context keys (universal API)", additionalProperties: { type: "object", description: "Operations engine config (op, schema, filter, key, keys, etc.)", properties: { op: { type: "string", description: "Operation type (read, create, update, delete, schema, resolve, etc.)", default: "read" } }, additionalProperties: !0 } } }, required: ["mapData"] }, { type: "array", description: "Array of inline action objects", items: { oneOf: [{ type: "object", properties: { tool: { type: "string", description: "Tool identifier" }, payload: { type: "object", description: "Tool payload", additionalProperties: !0 } }, required: ["tool"] }, { type: "object", properties: { updateContext: { type: "object", description: "Context updates (infrastructure, not a tool)", additionalProperties: !0 } }, required: ["updateContext"] }, { type: "object", properties: { mapData: { type: "object", description: "Map operations engine configs to context keys (universal API)", additionalProperties: { type: "object", description: "Operations engine config (op, schema, filter, key, keys, etc.)", properties: { op: { type: "string", description: "Operation type (read, create, update, delete, schema, resolve, etc.)", default: "read" } }, additionalProperties: !0 } } }, required: ["mapData"] }] } }, { $co: "@maia/schema/action", description: "Co-id reference to action CoValue" }, { type: "array", description: "Array of action co-id references", items: { $co: "@maia/schema/action" } }] }, exit: { oneOf: [{ type: "object", description: "Inline tool action object", properties: { tool: { type: "string", description: "Tool identifier" }, payload: { type: "object", description: "Tool payload", additionalProperties: !0 } }, required: ["tool"] }, { type: "object", description: "Infrastructure context update action", properties: { updateContext: { type: "object", description: "Context updates (infrastructure, not a tool)", additionalProperties: !0 } }, required: ["updateContext"] }, { type: "object", description: "Map operations engine configs to context keys (universal API)", properties: { mapData: { type: "object", description: "Map operations engine configs to context keys (universal API)", additionalProperties: { type: "object", description: "Operations engine config (op, schema, filter, key, keys, etc.)", properties: { op: { type: "string", description: "Operation type (read, create, update, delete, schema, resolve, etc.)", default: "read" } }, additionalProperties: !0 } } }, required: ["mapData"] }, { type: "array", description: "Array of inline action objects", items: { oneOf: [{ type: "object", properties: { tool: { type: "string", description: "Tool identifier" }, payload: { type: "object", description: "Tool payload", additionalProperties: !0 } }, required: ["tool"] }, { type: "object", properties: { updateContext: { type: "object", description: "Context updates (infrastructure, not a tool)", additionalProperties: !0 } }, required: ["updateContext"] }, { type: "object", properties: { mapData: { type: "object", description: "Map operations engine configs to context keys (universal API)", additionalProperties: { type: "object", description: "Operations engine config (op, schema, filter, key, keys, etc.)", properties: { op: { type: "string", description: "Operation type (read, create, update, delete, schema, resolve, etc.)", default: "read" } }, additionalProperties: !0 } } }, required: ["mapData"] }] } }, { $co: "@maia/schema/action", description: "Co-id reference to action CoValue" }, { type: "array", description: "Array of action co-id references", items: { $co: "@maia/schema/action" } }] }, on: { type: "object", description: "Event handlers (transitions)", additionalProperties: { oneOf: [{ type: "string", description: "Simple target state name" }, { type: "object", description: "Inline transition object", properties: { target: { type: "string", description: "Target state name" }, guard: { type: "object", description: "Guard condition", additionalProperties: !0 }, actions: { type: "array", description: "Transition actions", items: { oneOf: [{ type: "object", properties: { tool: { type: "string", description: "Tool identifier" }, payload: { type: "object", additionalProperties: !0 } }, required: ["tool"] }, { type: "object", properties: { updateContext: { type: "object", description: "Context updates (infrastructure, not a tool)", additionalProperties: !0 } }, required: ["updateContext"] }, { $co: "@maia/schema/action" }] } } }, required: ["target"] }, { $co: "@maia/schema/transition", description: "Co-id reference to transition CoValue" }] } } }, additionalProperties: !1 } } }, CE = {
  $schema: oE,
  $id: rE,
  title: nE,
  description: sE,
  cotype: aE,
  indexing: gE,
  required: IE,
  properties: cE
}, BE = "@maia/schema/meta", QE = "@maia/schema/view", EE = "@maia/schema/view", lE = "UI structure definition with DOM tree, expressions, loops, and event handlers (recursive viewNode structure)", dE = "comap", uE = !0, hE = { content: { type: "object", description: "View content structure (recursive viewNode)", $ref: "#/$defs/viewNode" } }, fE = { viewNode: { type: "object", description: "Recursive DOM node structure", properties: { tag: { type: "string" }, class: { type: "string" }, text: { anyOf: [{ type: "string", pattern: "^\\$\\$" }, { type: "string", pattern: "^@" }, { type: "string", pattern: "^\\$[^$]" }, { type: "string" }, { type: "number" }, { type: "boolean" }, { type: "null" }] }, value: { anyOf: [{ type: "string", pattern: "^\\$\\$" }, { type: "string", pattern: "^@" }, { type: "string", pattern: "^\\$[^$]" }, { type: "string" }, { type: "number" }, { type: "boolean" }, { type: "null" }] }, attrs: { type: "object", additionalProperties: { anyOf: [{ type: "string", pattern: "^\\$\\$" }, { type: "string", pattern: "^@" }, { type: "string", pattern: "^\\$[^$]" }, { type: "string" }, { type: "number" }, { type: "boolean" }, { type: "null" }, { type: "object", additionalProperties: { anyOf: [{ type: "string", pattern: "^\\$\\$" }, { type: "string", pattern: "^@" }, { type: "string", pattern: "^\\$[^$]" }, { type: "string" }, { type: "number" }, { type: "boolean" }, { type: "null" }] } }] } }, children: { type: "array", items: { $ref: "#/$defs/viewNode" } }, $on: { type: "object", additionalProperties: { type: "object", properties: { send: { type: "string" }, payload: { type: "object", additionalProperties: !0 }, key: { type: "string" } }, required: ["send"] } }, $each: { type: "object", properties: { items: { anyOf: [{ type: "string", pattern: "^\\$\\$" }, { type: "string", pattern: "^@" }, { type: "string", pattern: "^\\$[^$]" }, { type: "string" }, { type: "number" }, { type: "boolean" }, { type: "null" }] }, template: { $ref: "#/$defs/viewNode" } }, required: ["items", "template"] }, $slot: { anyOf: [{ type: "string", pattern: "^\\$\\$" }, { type: "string", pattern: "^@" }, { type: "string", pattern: "^\\$[^$]" }, { type: "string" }, { type: "number" }, { type: "boolean" }, { type: "null" }] } }, additionalProperties: !1 } }, pE = !1, wE = {
  $schema: BE,
  $id: QE,
  title: EE,
  description: lE,
  cotype: dE,
  indexing: uE,
  properties: hE,
  $defs: fE,
  additionalProperties: pE
}, yE = "@maia/schema/meta", DE = "@maia/schema/style", mE = "@maia/schema/style", SE = "Style definition (brand or actor-specific). Brand styles typically include selectors, actor styles are overrides.", kE = "comap", NE = !0, ME = { tokens: { type: "object", description: "Design tokens (colors, spacing, typography, etc.)", additionalProperties: !0 }, components: { type: "object", description: "Component styles", additionalProperties: !0 }, selectors: { type: "object", description: "CSS selector-based styles (typically used in brand styles)", additionalProperties: { type: "object", description: "CSS properties and values", additionalProperties: { oneOf: [{ type: "string" }, { type: "number" }, { type: "object", additionalProperties: !0 }] } } } }, ti = {
  $schema: yE,
  $id: DE,
  title: mE,
  description: SE,
  cotype: kE,
  indexing: NE,
  properties: ME
}, GE = "@maia/schema/meta", FE = "@maia/schema/tool", bE = "@maia/schema/tool", RE = "Tool metadata (AI-compatible JSON schema)", KE = "comap", vE = !0, YE = ["name", "description", "parameters"], UE = { name: { type: "string", description: "Tool identifier (e.g., '@mutation/create')", pattern: "^@" }, description: { type: "string", description: "Tool description" }, parameters: { type: "object", description: "JSON Schema for tool parameters (standard JSON Schema format)", properties: { type: { type: "string", enum: ["object", "array", "string", "number", "boolean", "null"] }, properties: { type: "object", additionalProperties: { type: "object", description: "Parameter property schema", properties: { type: { type: "string" }, description: { type: "string" }, required: { type: "boolean" }, properties: { type: "object", additionalProperties: !0 } }, additionalProperties: !0 } }, required: { type: "array", items: { type: "string" } } }, required: ["type"], additionalProperties: !0 } }, JE = {
  $schema: GE,
  $id: FE,
  title: bE,
  description: RE,
  cotype: KE,
  indexing: vE,
  required: YE,
  properties: UE
}, HE = "@maia/schema/meta", qE = "@maia/schema/vibe", xE = "@maia/schema/vibe", LE = "Vibe manifest/metadata", TE = "comap", OE = !0, PE = ["name", "description", "actor"], jE = { name: { type: "string", description: "Vibe name" }, description: { type: "string", description: "Vibe description" }, actor: { $co: "@maia/schema/actor", description: "Co-id reference to actor definition (root actor for this vibe)" } }, VE = {
  $schema: HE,
  $id: qE,
  title: xE,
  description: LE,
  cotype: TE,
  indexing: OE,
  required: PE,
  properties: jE
}, $E = "@maia/schema/meta", WE = "@maia/schema/message", zE = "@maia/schema/message", _E = "Actor message for state machine transitions", ZE = "comap", XE = !0, Al = ["type"], el = { type: { type: "string", description: "Message type (event name)" }, payload: { type: "object", description: "Message payload data" }, source: { $co: "@maia/schema/actor", description: "Co-id reference to source actor" }, target: { $co: "@maia/schema/actor", description: "Co-id reference to target actor (required for direct messaging)" }, processed: { type: "boolean", description: "Whether this message has been processed", default: !1 } }, tl = {
  $schema: $E,
  $id: WE,
  title: zE,
  description: _E,
  cotype: ZE,
  indexing: XE,
  required: Al,
  properties: el
}, il = "@maia/schema/meta", ol = "@maia/schema/guard", rl = "@maia/schema/guard", nl = "JSON Schema guard for conditional logic - checks state/context conditions (NOT payload validation)", sl = "comap", al = !0, gl = ["schema"], Il = { schema: { type: "object", description: "JSON Schema to validate against current state/context (for conditional logic only, NOT payload validation)", additionalProperties: !0 } }, cl = !1, Cl = {
  $schema: il,
  $id: ol,
  title: rl,
  description: nl,
  cotype: sl,
  indexing: al,
  required: gl,
  properties: Il,
  additionalProperties: cl
}, Bl = "@maia/schema/meta", Ql = "@maia/schema/action", El = "@maia/schema/action", ll = "Action (tool invocation, context update, or data mapping)", dl = "comap", ul = !0, hl = [{ type: "object", properties: { tool: { type: "string", description: "Tool identifier (e.g., '@mutation/create')" }, payload: { description: "Tool payload (can contain expressions)", type: "object", additionalProperties: !0 } }, required: ["tool"] }, { type: "object", properties: { updateContext: { type: "object", description: "Context updates (infrastructure, not a tool)", additionalProperties: !0 } }, required: ["updateContext"] }, { type: "object", properties: { mapData: { type: "object", description: "Map operations engine configs to context keys (universal API)", additionalProperties: { type: "object", description: "Operations engine config (op, schema, filter, key, keys, etc.)", properties: { op: { type: "string", description: "Operation type (read, create, update, delete, schema, resolve, etc.)", default: "read" } }, additionalProperties: !0 } } }, required: ["mapData"] }], fl = {
  $schema: Bl,
  $id: Ql,
  title: El,
  description: ll,
  cotype: dl,
  indexing: ul,
  oneOf: hl
}, pl = "@maia/schema/meta", wl = "@maia/schema/transition", yl = "@maia/schema/transition", Dl = "State machine transition", ml = "comap", Sl = !0, kl = { target: { type: "string", description: "Target state name" }, guard: { $co: "@maia/schema/guard" }, actions: { type: "array", items: { $co: "@maia/schema/action" } } }, Nl = ["target"], Ml = {
  $schema: pl,
  $id: wl,
  title: yl,
  description: Dl,
  cotype: ml,
  indexing: Sl,
  properties: kl,
  required: Nl
}, Gl = "@maia/schema/meta", Fl = "@maia/schema/messagePayload", bl = "@maia/schema/messagePayload", Rl = "Message payload definition", Kl = "comap", vl = !0, Yl = {}, Ul = !0, Jl = {
  $schema: Gl,
  $id: Fl,
  title: bl,
  description: Rl,
  cotype: Kl,
  indexing: vl,
  properties: Yl,
  additionalProperties: Ul
}, Hl = "@maia/schema/meta", ql = "@maia/schema/messageType", xl = "@maia/schema/messageType", Ll = "Message type schemas are standard JSON Schemas that validate message payloads. The schema ID (e.g., '@maia/schema/message/CREATE_BUTTON') identifies the message type.", Tl = "comap", Ol = !0, Pl = "object", jl = !0, Vl = {
  $schema: Hl,
  $id: ql,
  title: xl,
  description: Ll,
  cotype: Tl,
  indexing: Ol,
  type: Pl,
  additionalProperties: jl
}, $l = "@maia/schema/meta", Wl = "@maia/schema/maia-script-expression", zl = "@maia/schema/maia-script-expression", _l = "comap", Zl = !1, Xl = "JSON-based DSL expression schema for MaiaScript runtime logic. Supports data access, comparisons, logical operations, control flow, and nested expressions.", Ad = [{ description: "Primitive value", type: ["number", "boolean", "null"] }, { description: "String value (including shortcut syntax $key or $$key)", type: "string" }, { $ref: "#/$defs/expressionObject" }], ed = { expressionObject: { description: "MaiaScript expression object (DSL operation)", type: "object", oneOf: [{ description: "$context operation - access context data", properties: { $context: { type: "string", description: "Dot-separated path in context object (e.g., 'user.name')", pattern: "^[a-zA-Z_][a-zA-Z0-9_]*(\\.[a-zA-Z_][a-zA-Z0-9_]*)*$" } }, required: ["$context"], additionalProperties: !1 }, { description: "$item operation - access item data", properties: { $item: { type: "string", description: "Dot-separated path in item object (e.g., 'id', 'status.value')", pattern: "^[a-zA-Z_][a-zA-Z0-9_]*(\\.[a-zA-Z_][a-zA-Z0-9_]*)*$" } }, required: ["$item"], additionalProperties: !1 }, { description: "$eq operation - equality comparison", properties: { $eq: { type: "array", description: "Array of two expressions to compare", items: { $ref: "#" }, minItems: 2, maxItems: 2 } }, required: ["$eq"], additionalProperties: !1 }, { description: "$ne operation - inequality comparison", properties: { $ne: { type: "array", description: "Array of two expressions to compare", items: { $ref: "#" }, minItems: 2, maxItems: 2 } }, required: ["$ne"], additionalProperties: !1 }, { description: "$not operation - logical NOT (negate boolean)", properties: { $not: { $ref: "#", description: "Expression to negate (evaluated to boolean, then negated)" } }, required: ["$not"], additionalProperties: !1 }, { description: "$and operation - logical AND (all operands must be truthy)", properties: { $and: { type: "array", description: "Array of expressions to evaluate (all must be truthy)", items: { $ref: "#" }, minItems: 1 } }, required: ["$and"], additionalProperties: !1 }, { description: "$or operation - logical OR (at least one operand must be truthy)", properties: { $or: { type: "array", description: "Array of expressions to evaluate (at least one must be truthy)", items: { $ref: "#" }, minItems: 1 } }, required: ["$or"], additionalProperties: !1 }, { description: "$trim operation - trim whitespace from string", properties: { $trim: { $ref: "#", description: "Expression to trim (evaluated to string, then trimmed of leading/trailing whitespace)" } }, required: ["$trim"], additionalProperties: !1 }, { description: "$gt operation - greater than comparison", properties: { $gt: { type: "array", description: "Array of two expressions to compare (left > right)", items: { $ref: "#" }, minItems: 2, maxItems: 2 } }, required: ["$gt"], additionalProperties: !1 }, { description: "$length operation - get array or string length", properties: { $length: { $ref: "#", description: "Expression to get length of (evaluated to array or string)" } }, required: ["$length"], additionalProperties: !1 }, { description: "$concat operation - concatenate arrays", properties: { $concat: { type: "array", description: "Array of expressions, arrays, or objects to concatenate (all evaluated to arrays, then flattened)", items: { anyOf: [{ $ref: "#" }, { type: ["array", "object", "string", "number", "boolean", "null"] }] }, minItems: 1 } }, required: ["$concat"], additionalProperties: !1 }, { description: "$map operation - map over array", properties: { $map: { type: "object", description: "Map configuration object", properties: { array: { $ref: "#", description: "Expression evaluating to array to map over" }, as: { type: "string", description: "Variable name for each item in the array (default: 'item')" }, return: { description: "Expression, object, or array to evaluate for each item (result becomes item in returned array). 'do' is also supported as an alias.", anyOf: [{ $ref: "#" }, { type: ["object", "array", "string", "number", "boolean", "null"] }] }, do: { description: "Alias for 'return' - expression, object, or array to evaluate for each item", anyOf: [{ $ref: "#" }, { type: ["object", "array", "string", "number", "boolean", "null"] }] } }, required: ["array"], additionalProperties: !1 } }, required: ["$map"], additionalProperties: !1 }, { description: "$if operation - conditional expression", properties: { $if: { type: "object", description: "Conditional expression object", properties: { condition: { $ref: "#", description: "Condition expression (evaluated to boolean)" }, then: { $ref: "#", description: "Expression to evaluate if condition is true" }, else: { $ref: "#", description: "Expression to evaluate if condition is false" } }, required: ["condition", "then", "else"], additionalProperties: !1 } }, required: ["$if"], additionalProperties: !1 }] } }, td = {
  $schema: $l,
  $id: Wl,
  title: zl,
  cotype: _l,
  indexing: Zl,
  description: Xl,
  anyOf: Ad,
  $defs: ed
}, id = "@maia/schema/meta", od = "@maia/schema/subscribers", rd = "@maia/schema/subscribers", nd = "A colist of actor co-ids subscribed to a topic", sd = "colist", ad = !0, gd = { $co: "@maia/schema/actor", description: "Each item is a co-id reference to an actor subscribed to this topic" }, Id = {
  $schema: id,
  $id: od,
  title: rd,
  description: nd,
  cotype: sd,
  indexing: ad,
  items: gd
}, cd = "@maia/schema/meta", Cd = "@maia/schema/inbox", Bd = "@maia/schema/inbox", Qd = "A costream (append-only stream) of messages received by this actor", Ed = "costream", ld = !0, dd = { $co: "@maia/schema/message", description: "Each item is a co-id reference to a message" }, ud = {
  $schema: cd,
  $id: Cd,
  title: Bd,
  description: Qd,
  cotype: Ed,
  indexing: ld,
  items: dd
}, hd = "@maia/schema/meta", fd = "@maia/schema/children", pd = "@maia/schema/children", wd = "A comap of child actors (namekey  actor co-id)", yd = "comap", Dd = !0, md = {}, Sd = { $co: "@maia/schema/actor", description: "Each value is a co-id reference to a child actor" }, kd = {
  $schema: hd,
  $id: fd,
  title: pd,
  description: wd,
  cotype: yd,
  indexing: Dd,
  properties: md,
  additionalProperties: Sd
}, Nd = "@maia/schema/meta", Md = "@maia/schema/os/schematas-registry", Gd = "@maia/schema/os/schematas-registry", Fd = "Schema registry CoMap - maps schema namekeys (e.g., @maia/schema/data/todos) to schema co-ids (co_z...). Stored in account.os.schematas", bd = "comap", Rd = !1, Kd = { "@maia/schema/meta": { type: "string", description: "Metaschema co-id (co_z...)" } }, vd = { type: "string", description: "Schema namekey  schema co-id mapping (e.g., @maia/schema/data/todos  co_z123...)" }, Yd = {
  $schema: Nd,
  $id: Md,
  title: Gd,
  description: Fd,
  cotype: bd,
  indexing: Rd,
  properties: Kd,
  additionalProperties: vd
}, Ud = "@maia/schema/meta", Jd = "@maia/schema/os/os-registry", Hd = "@maia/schema/os/os-registry", qd = "OS CoMap - contains capabilities, schematas, indexes. Stored in spark.os", xd = "comap", Ld = !1, Td = { capabilities: { type: "string", pattern: "^co_z[a-zA-Z0-9]+$", description: "Capabilities CoMap co-id (guardian, publicReaders)" }, schematas: { type: "string", pattern: "^co_z[a-zA-Z0-9]+$", description: "Schemata registry CoMap co-id" }, indexes: { type: "string", pattern: "^co_z[a-zA-Z0-9]+$", description: "Indexes registry CoMap co-id" } }, Od = {
  $schema: Ud,
  $id: Jd,
  title: Hd,
  description: qd,
  cotype: xd,
  indexing: Ld,
  properties: Td
}, Pd = "@maia/schema/meta", jd = "@maia/schema/os/capabilities", Vd = "@maia/schema/os/capabilities", $d = "Capabilities CoMap - guardian, publicReaders. Stored in spark.os.capabilities", Wd = "comap", zd = !1, _d = { guardian: { type: "string", pattern: "^co_z[a-zA-Z0-9]+$", description: "Guardian group co-id" }, publicReaders: { type: "string", pattern: "^co_z[a-zA-Z0-9]+$", description: "Public readers group co-id" } }, Zd = {
  $schema: Pd,
  $id: jd,
  title: Vd,
  description: $d,
  cotype: Wd,
  indexing: zd,
  properties: _d
}, Xd = "@maia/schema/meta", Au = "@maia/schema/os/indexes-registry", eu = "@maia/schema/os/indexes-registry", tu = "Indexes registry CoMap - schema co-id -> index colist. Stored in spark.os.indexes", iu = "comap", ou = !1, ru = { type: "string", pattern: "^co_z[a-zA-Z0-9]+$", description: "Schema co-id -> index colist co-id" }, nu = {
  $schema: Xd,
  $id: Au,
  title: eu,
  description: tu,
  cotype: iu,
  indexing: ou,
  additionalProperties: ru
}, su = "@maia/schema/meta", au = "@maia/schema/os/vibes-registry", gu = "@maia/schema/os/vibes-registry", Iu = "Vibes registry CoMap - vibe key -> vibe co-id. Stored in spark.vibes", cu = "comap", Cu = !1, Bu = { type: "string", pattern: "^co_z[a-zA-Z0-9]+$", description: "Vibe key -> vibe CoMap co-id" }, Qu = {
  $schema: su,
  $id: au,
  title: gu,
  description: Iu,
  cotype: cu,
  indexing: Cu,
  additionalProperties: Bu
}, Eu = "@maia/schema/meta", lu = "@maia/schema/os/sparks-registry", du = "@maia/schema/os/sparks-registry", uu = "Sparks registry CoMap - spark name -> spark co-id. Stored in account.sparks", hu = "comap", fu = !1, pu = { type: "string", pattern: "^co_z[a-zA-Z0-9]+$", description: "Spark name -> spark CoMap co-id" }, wu = {
  $schema: Eu,
  $id: lu,
  title: du,
  description: uu,
  cotype: hu,
  indexing: fu,
  additionalProperties: pu
}, yu = "@maia/schema/meta", Du = "@maia/schema/os/humans-registry", mu = "@maia/schema/os/humans-registry", Su = "Humans registry CoMap - username -> account co-id. Stored in spark.registries.humans", ku = "comap", Nu = !1, Mu = { type: "string", pattern: "^co_z[a-zA-Z0-9]{20,}$", description: "Username -> account co-id" }, Gu = {
  $schema: yu,
  $id: Du,
  title: mu,
  description: Su,
  cotype: ku,
  indexing: Nu,
  additionalProperties: Mu
}, Fu = "@maia/schema/meta", bu = "@maia/schema/os/registries", Ru = "@maia/schema/os/registries", Ku = "Registries CoMap - contains sparks, etc. Stored in spark.registries", vu = "comap", Yu = !1, Uu = { sparks: { type: "string", pattern: "^co_z[a-zA-Z0-9]+$", description: "Sparks registry CoMap co-id (spark name -> spark co-id)" } }, Ju = { type: "string", pattern: "^co_z[a-zA-Z0-9]+$", description: "Registry name -> registry CoMap co-id" }, Hu = {
  $schema: Fu,
  $id: bu,
  title: Ru,
  description: Ku,
  cotype: vu,
  indexing: Yu,
  properties: Uu,
  additionalProperties: Ju
}, qu = "@maia/schema/data/todos", xu = "@maia/schema/meta", Lu = "@maia/schema/data/todos", Tu = "comap", Ou = !0, Pu = { text: { type: "string", minLength: 1, pattern: ".*\\S.*", description: "The todo item text content (must contain at least one non-whitespace character)" }, done: { type: "boolean", description: "Whether the todo item is completed" } }, ju = ["text", "done"], Vu = !1, $u = {
  $id: qu,
  $schema: xu,
  title: Lu,
  cotype: Tu,
  indexing: Ou,
  properties: Pu,
  required: ju,
  additionalProperties: Vu
}, Wu = "@maia/schema/data/chat", zu = "@maia/schema/meta", _u = "@maia/schema/data/chat", Zu = "comap", Xu = !0, Ah = { role: { type: "string", enum: ["user", "assistant", "system"], description: "The role of the message sender" }, content: { type: "string", minLength: 1, description: "The message content" } }, eh = ["role", "content"], th = !1, ih = {
  $id: Wu,
  $schema: zu,
  title: _u,
  cotype: Zu,
  indexing: Xu,
  properties: Ah,
  required: eh,
  additionalProperties: th
}, oh = "@maia/schema/meta", rh = "@maia/schema/data/spark", nh = "@maia/schema/data/spark", sh = "Spark CoMap. Guardian (admin) group is spark.os.capabilities.guardian.", ah = "comap", gh = !0, Ih = ["name"], ch = { name: { type: "string", description: "Spark name e.g. @maia" }, os: { type: "string", pattern: "^co_z[a-zA-Z0-9]+$", description: "OS CoMap - contains schematas, indexes, capabilities (guardian, publicReaders)." }, vibes: { type: "string", pattern: "^co_z[a-zA-Z0-9]+$", description: "Vibes registry CoMap for this spark." } }, Ch = {
  $schema: oh,
  $id: rh,
  title: nh,
  description: sh,
  cotype: ah,
  indexing: gh,
  required: Ih,
  properties: ch
}, Bh = "@maia/schema/meta", Qh = "@maia/schema/message/CREATE_BUTTON", Eh = "@maia/schema/message/CREATE_BUTTON", lh = "Message type for creating a new item via button click (generic, reusable across vibes)", dh = "comap", uh = !0, hh = "object", fh = { value: { type: "string", minLength: 1, pattern: "^\\S", description: "Item value/text (required, non-empty, must contain at least one non-whitespace character). Generic property name for reuse across vibes." } }, ph = ["value"], wh = !0, yh = {
  $schema: Bh,
  $id: Qh,
  title: Eh,
  description: lh,
  cotype: dh,
  indexing: uh,
  type: hh,
  properties: fh,
  required: ph,
  additionalProperties: wh
}, Dh = "@maia/schema/meta", mh = "@maia/schema/message/TOGGLE_BUTTON", Sh = "@maia/schema/message/TOGGLE_BUTTON", kh = "Message type for toggling a todo item's done status", Nh = "comap", Mh = !0, Gh = "object", Fh = { id: { type: "string", pattern: "^co_z", description: "Todo item co-id (required)" }, done: { type: "boolean", description: "Current done status (optional, will be toggled)" } }, bh = ["id"], Rh = !1, Kh = {
  $schema: Dh,
  $id: mh,
  title: Sh,
  description: kh,
  cotype: Nh,
  indexing: Mh,
  type: Gh,
  properties: Fh,
  required: bh,
  additionalProperties: Rh
}, vh = "@maia/schema/meta", Yh = "@maia/schema/message/DELETE_BUTTON", Uh = "@maia/schema/message/DELETE_BUTTON", Jh = "Message type for deleting a todo item", Hh = "comap", qh = !0, xh = "object", Lh = { id: { type: "string", pattern: "^co_z", description: "Todo item co-id (required)" } }, Th = ["id"], Oh = !1, Ph = {
  $schema: vh,
  $id: Yh,
  title: Uh,
  description: Jh,
  cotype: Hh,
  indexing: qh,
  type: xh,
  properties: Lh,
  required: Th,
  additionalProperties: Oh
}, jh = "@maia/schema/meta", Vh = "@maia/schema/message/UPDATE_INPUT", $h = "@maia/schema/message/UPDATE_INPUT", Wh = "Message type for updating input field value (generic, reusable across vibes)", zh = "comap", _h = !0, Zh = "object", Xh = { value: { type: "string", description: "New input field value (generic property name for reuse across vibes)" } }, Af = !0, ef = {
  $schema: jh,
  $id: Vh,
  title: $h,
  description: Wh,
  cotype: zh,
  indexing: _h,
  type: Zh,
  properties: Xh,
  additionalProperties: Af
}, tf = "@maia/schema/meta", of = "@maia/schema/message/SWITCH_VIEW", rf = "@maia/schema/message/SWITCH_VIEW", nf = "Message type for switching view mode", sf = "comap", af = !0, gf = "object", If = { viewMode: { type: "string", enum: ["list", "logs", "comingSoon"], description: "View mode to switch to (required)" } }, cf = ["viewMode"], Cf = !1, Bf = {
  $schema: tf,
  $id: of,
  title: rf,
  description: nf,
  cotype: sf,
  indexing: af,
  type: gf,
  properties: If,
  required: cf,
  additionalProperties: Cf
}, Qf = "@maia/schema/meta", Ef = "@maia/schema/message/SUCCESS", lf = "@maia/schema/message/SUCCESS", df = "Message type for successful operation completion", uf = "comap", hf = !0, ff = "object", pf = { result: { description: "Tool execution result (optional, can be any type - object, boolean, string, etc.)" }, value: { type: "string", description: "Original event payload property (optional, for CREATE_BUTTON, UPDATE_INPUT - generic property name)" }, text: { type: "string", description: "Original event payload property (optional, legacy - use 'value' instead)" }, id: { type: "string", pattern: "^co_z", description: "Original event payload property (optional, for TOGGLE_BUTTON, DELETE_BUTTON)" }, done: { type: "boolean", description: "Original event payload property (optional, for TOGGLE_BUTTON)" }, viewMode: { type: "string", enum: ["list", "logs"], description: "Original event payload property (optional, for SWITCH_VIEW)" }, newTodoText: { type: "string", description: "Original event payload property (optional, legacy - use 'value' instead)" } }, wf = !0, yf = {
  $schema: Qf,
  $id: Ef,
  title: lf,
  description: df,
  cotype: uf,
  indexing: hf,
  type: ff,
  properties: pf,
  additionalProperties: wf
}, Df = "@maia/schema/meta", mf = "@maia/schema/message/ERROR", Sf = "@maia/schema/message/ERROR", kf = "Message type for operation errors. Aligned with OperationResult createErrorEntry shape.", Nf = "comap", Mf = !0, Gf = "object", Ff = { errors: { type: "array", description: "Structured error entries. Same shape as OperationResult.", items: { type: "object", required: ["type", "message"], properties: { type: { type: "string", description: "Error type: schema | permission | structural" }, message: { type: "string", description: "Error message" }, path: { type: "string", description: "Optional path (e.g. /field)" } } } } }, bf = ["errors"], Rf = !1, Kf = {
  $schema: Df,
  $id: mf,
  title: Sf,
  description: kf,
  cotype: Nf,
  indexing: Mf,
  type: Gf,
  properties: Ff,
  required: bf,
  additionalProperties: Rf
}, vf = "@maia/schema/meta", Yf = "@maia/schema/message/SEND_MESSAGE", Uf = "@maia/schema/message/SEND_MESSAGE", Jf = "Message type for sending a chat message", Hf = "comap", qf = !0, xf = "object", Lf = { inputText: { type: "string", minLength: 1, description: "Message text (required, non-empty)" } }, Tf = ["inputText"], Of = !1, Pf = {
  $schema: vf,
  $id: Yf,
  title: Uf,
  description: Jf,
  cotype: Hf,
  indexing: qf,
  type: xf,
  properties: Lf,
  required: Tf,
  additionalProperties: Of
}, jf = "@maia/schema/meta", Vf = "@maia/schema/message/RETRY", $f = "@maia/schema/message/RETRY", Wf = "Message type for retrying a failed operation", zf = "comap", _f = !0, Zf = "object", Xf = {}, Ap = !1, ep = {
  $schema: jf,
  $id: Vf,
  title: $f,
  description: Wf,
  cotype: zf,
  indexing: _f,
  type: Zf,
  properties: Xf,
  additionalProperties: Ap
}, tp = "@maia/schema/meta", ip = "@maia/schema/message/DISMISS", op = "@maia/schema/message/DISMISS", rp = "Message type for dismissing an error or notification", np = "comap", sp = !0, ap = "object", gp = {}, Ip = !1, cp = {
  $schema: tp,
  $id: ip,
  title: op,
  description: rp,
  cotype: np,
  indexing: sp,
  type: ap,
  properties: gp,
  additionalProperties: Ip
}, Cp = "@maia/schema/meta", Bp = "@maia/schema/message/SELECT_NAV", Qp = "@maia/schema/message/SELECT_NAV", Ep = "Message type for selecting a navigation item", lp = "comap", dp = !0, up = "object", hp = { navId: { type: "string", description: "Navigation item ID (required)" } }, fp = ["navId"], pp = !1, wp = {
  $schema: Cp,
  $id: Bp,
  title: Qp,
  description: Ep,
  cotype: lp,
  indexing: dp,
  type: up,
  properties: hp,
  required: fp,
  additionalProperties: pp
}, yp = "@maia/schema/meta", Dp = "@maia/schema/message/SELECT_ROW", mp = "@maia/schema/message/SELECT_ROW", Sp = "Message type for selecting a table row", kp = "comap", Np = !0, Mp = "object", Gp = { rowId: { type: "string", description: "Row ID (required)" } }, Fp = ["rowId"], bp = !1, Rp = {
  $schema: yp,
  $id: Dp,
  title: mp,
  description: Sp,
  cotype: kp,
  indexing: Np,
  type: Mp,
  properties: Gp,
  required: Fp,
  additionalProperties: bp
}, Kp = "@maia/schema/meta", vp = "@maia/schema/message/SELECT_SPARK", Yp = "@maia/schema/message/SELECT_SPARK", Up = "Message type for selecting a spark (generic, reusable across vibes)", Jp = "comap", Hp = !0, qp = "object", xp = { sparkId: { type: "string", description: "Spark co-id (required, generic property name for reuse across vibes)" } }, Lp = ["sparkId"], Tp = !0, Op = {
  $schema: Kp,
  $id: vp,
  title: Yp,
  description: Up,
  cotype: Jp,
  indexing: Hp,
  type: qp,
  properties: xp,
  required: Lp,
  additionalProperties: Tp
}, Pp = "@maia/schema/meta", jp = "@maia/schema/message/LOAD_ACTOR", Vp = "@maia/schema/message/LOAD_ACTOR", $p = "Generic message type for loading actor data (reusable across vibes)", Wp = "comap", zp = !0, _p = "object", Zp = { id: { type: "string", description: "Entity co-id to load (required, generic property name for reuse across vibes)" } }, Xp = ["id"], Aw = !0, ew = {
  $schema: Pp,
  $id: jp,
  title: Vp,
  description: $p,
  cotype: Wp,
  indexing: zp,
  type: _p,
  properties: Zp,
  required: Xp,
  additionalProperties: Aw
}, tw = "@maia/schema/meta", iw = "@maia/schema/message/UPDATE_AGENT_INPUT", ow = "@maia/schema/message/UPDATE_AGENT_INPUT", rw = "Message type for updating agent ID input field in Spark detail view", nw = "comap", sw = !0, aw = "object", gw = { value: { type: "string", description: "Agent account co-id input value" } }, Iw = !0, cw = {
  $schema: tw,
  $id: iw,
  title: ow,
  description: rw,
  cotype: nw,
  indexing: sw,
  type: aw,
  properties: gw,
  additionalProperties: Iw
}, Cw = "@maia/schema/meta", Bw = "@maia/schema/message/ADD_AGENT", Qw = "@maia/schema/message/ADD_AGENT", Ew = "Message type for adding an agent as writer member to a Spark's group", lw = "comap", dw = !0, uw = "object", hw = { agentId: { type: "string", description: "Agent account co-id to add as writer (co_z...). Operation validates format." } }, fw = ["agentId"], pw = !0, ww = {
  $schema: Cw,
  $id: Bw,
  title: Qw,
  description: Ew,
  cotype: lw,
  indexing: dw,
  type: uw,
  properties: hw,
  required: fw,
  additionalProperties: pw
}, yw = "@maia/schema/meta", Dw = "@maia/schema/message/REMOVE_MEMBER", mw = "@maia/schema/message/REMOVE_MEMBER", Sw = "Message type for removing a member from a Spark's group", kw = "comap", Nw = !0, Mw = "object", Gw = { memberId: { type: "string", description: "Account co-id of member to remove (co_z...). Operation validates format." } }, Fw = ["memberId"], bw = !0, Rw = {
  $schema: yw,
  $id: Dw,
  title: mw,
  description: Sw,
  cotype: kw,
  indexing: Nw,
  type: Mw,
  properties: Gw,
  required: Fw,
  additionalProperties: bw
};
function br() {
  return Ye.getMetaSchema();
}
const Rr = {
  actor: WQ,
  context: iE,
  state: CE,
  view: wE,
  style: ti,
  brand: ti,
  "brand.style": ti,
  "actor.style": ti,
  tool: JE,
  vibe: VE,
  message: tl,
  // Extracted $defs as separate schemas (expression is inline type definition, not a CoValue)
  guard: Cl,
  action: fl,
  transition: Ml,
  messagePayload: Jl,
  messageType: Vl,
  // MaiaScript expression schema (for validating DSL expressions)
  "maia-script-expression": td,
  // CoValue schemas (separate CoValues referenced via $co)
  subscribers: Id,
  inbox: ud,
  children: kd,
  // OS infrastructure schemas
  "os/schematas-registry": Yd,
  "os/os-registry": Od,
  "os/capabilities": Zd,
  "os/indexes-registry": nu,
  "os/vibes-registry": Qu,
  "os/sparks-registry": wu,
  "os/humans-registry": Gu,
  "os/registries": Hu
}, Kr = {
  "data/todos": $u,
  "data/chat": ih,
  "data/spark": Ch
}, vr = {
  "message/CREATE_BUTTON": yh,
  "message/TOGGLE_BUTTON": Kh,
  "message/DELETE_BUTTON": Ph,
  "message/UPDATE_INPUT": ef,
  "message/SWITCH_VIEW": Bf,
  "message/SUCCESS": yf,
  "message/ERROR": Kf,
  "message/SEND_MESSAGE": Pf,
  "message/RETRY": ep,
  "message/DISMISS": cp,
  "message/SELECT_NAV": wp,
  "message/SELECT_ROW": Rp,
  "message/SELECT_SPARK": Op,
  "message/LOAD_ACTOR": ew,
  "message/UPDATE_AGENT_INPUT": cw,
  "message/ADD_AGENT": ww,
  "message/REMOVE_MEMBER": Rw
};
function Kw(t) {
  if (t.startsWith("@maia/schema/")) {
    const A = t.replace("@maia/schema/", "");
    return A.startsWith("message/") ? vr[A] || null : Rr[A] || Kr[A] || null;
  }
  return t.startsWith("message/") ? vr[t] || null : Rr[t] || Kr[t] || null;
}
function Yr() {
  const t = {};
  for (const [A, e] of Object.entries(vr))
    t[`@maia/schema/${A}`] = e;
  return { ...Rr, ...Kr, ...t };
}
const jt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CoIdRegistry: oI,
  SCHEMA_REF_PATTERN: Do,
  VIBE_REF_PATTERN: AI,
  ValidationEngine: Ye,
  coTypesDefs: Ot,
  getAllSchemas: Yr,
  getMetaSchema: br,
  getSchema: Kw,
  getValidationEngine: mo,
  isSchemaRef: MA,
  isVibeRef: eI,
  resolve: eA,
  setSchemaResolver: nI,
  transformForSeeding: tI,
  validateAgainstSchema: Vt,
  validateAgainstSchemaOrThrow: gt,
  validateSchemaStructure: co
}, Symbol.toStringTag, { value: "Module" }));
function be(t) {
  return t.map((A) => ({
    instancePath: A.instancePath || "/",
    schemaPath: A.schemaPath || "",
    keyword: A.keyword || "",
    message: A.message || "",
    params: A.params || {}
  }));
}
async function ne(t, A) {
  const e = t.opts.validateSchema;
  t.opts.validateSchema = !1;
  try {
    return await A();
  } finally {
    t.opts.validateSchema = e;
  }
}
let XA = null, Ur = null;
function nI(t) {
  if (!t || typeof t != "object")
    throw new Error("[setSchemaResolver] Options object required: { dbEngine }");
  const { dbEngine: A } = t;
  if (!A)
    throw new Error("[setSchemaResolver] dbEngine is REQUIRED. No fallbacks allowed.");
  const e = async (i) => {
    try {
      if (!A.backend)
        throw new Error("[SchemaResolver] dbEngine.backend is required");
      const { resolve: o } = await Promise.resolve().then(() => Mo), r = await o(A.backend, i, { returnType: "schema" });
      if (!r)
        throw new Error(`[SchemaResolver] Schema ${i} not found`);
      return r;
    } catch (o) {
      throw new Error(`[SchemaResolver] Failed to load schema ${i}: ${o.message}`);
    }
  };
  Ur = e, XA && XA.setSchemaResolver(e);
}
async function mo(t = null) {
  let A = null;
  t && typeof t == "object" && (A = t.registrySchemas || null);
  let e = null;
  return Ur && (e = Ur), XA ? A && !XA.registrySchemas && (XA = new Ye({ registrySchemas: A })) : XA = new Ye({ registrySchemas: A }), e && !XA.schemaResolver && XA.setSchemaResolver(e), await XA.initialize(), XA;
}
async function Vt(t, A, e = "", i = !1) {
  const o = await mo();
  await o.initialize();
  try {
    await o._resolveAndRegisterSchemaDependencies(t);
    let r;
    if (t.$id) {
      const g = o.ajv.getSchema(t.$id);
      g ? r = g : r = o.ajv.compile(t);
    } else
      r = o.ajv.compile(t);
    if (r(A))
      return { valid: !0, errors: null };
    const s = r.errors || [], a = be(s);
    if (i) {
      const g = e ? ` for '${e}'` : "", I = a.map((c) => `  - ${c.instancePath}: ${c.message}`).join(`
`);
      throw new Error(
        `Validation failed${g}:
${I}`
      );
    }
    return {
      valid: !1,
      errors: a
    };
  } catch (r) {
    if (r.message && r.message.includes("already exists") && t.$id) {
      const n = o.ajv.getSchema(t.$id);
      if (n) {
        if (n(A))
          return { valid: !0, errors: null };
        const a = n.errors || [], g = be(a);
        if (i) {
          const I = e ? ` for '${e}'` : "", c = g.map((C) => `  - ${C.instancePath}: ${C.message}`).join(`
`);
          throw new Error(
            `Validation failed${I}:
${c}`
          );
        }
        return {
          valid: !1,
          errors: g
        };
      }
    }
    throw new Error(`[Validation] Failed to compile schema for ${e}: ${r.message}`);
  }
}
async function gt(t, A, e = "") {
  return await Vt(t, A, e, !0);
}
function sI(t, A) {
  if (!Array.isArray(A))
    throw new Error("[validateItems] Items must be an array");
  if (t.items && t.items.$co) {
    for (const e of A)
      if (typeof e != "string" || !e.startsWith("co_z"))
        throw new Error(`[validateItems] Items must be co-ids when schema.items.$co is specified, got: ${e}`);
  }
}
function uA(t, A) {
  if (!t)
    throw new Error(`[${A}] coId required`);
  if (!t.startsWith("co_z"))
    throw new Error(`[${A}] coId must be a valid co-id (co_z...), got: ${t}`);
}
function BA(t, A, e) {
  if (t == null)
    throw new Error(`[${e}] ${A} required`);
}
function JA(t, A, e = "") {
  if (!t) {
    const i = e ? ` (${e})` : "";
    throw new Error(`[${A}] dbEngine required${i}`);
  }
}
async function $t(t, A, e, i, o = {}) {
  const { dbEngine: r, registrySchemas: n, getAllSchemas: s } = o, { resolve: a } = await Promise.resolve().then(() => Mo);
  if (A.startsWith("co_z")) {
    if (!r)
      throw new Error(`[${i}] dbEngine is REQUIRED for co-id schema validation. Schema: ${A}. Pass dbEngine in options.`);
    const g = await a(t, A, { returnType: "schema" });
    if (!g)
      throw new Error(`[${i}] Schema not found in database: ${A}`);
    return await gt(g, e, `${i} for schema ${A}`), g;
  } else {
    if (!s || typeof s != "function")
      throw new Error(`[${i}] getAllSchemas function is REQUIRED for name-based schema validation. Schema: ${A}. This is only for migrations/seeding.`);
    const g = s(), c = await (await mo({
      registrySchemas: n || g
    })).validateData(A, e);
    if (!c.valid) {
      const B = c.errors.map((Q) => `  - ${Q.instancePath}: ${Q.message}`).join(`
`);
      throw new Error(`[${i}] Data validation failed for schema '${A}':
${B}`);
    }
    return (n || g)[A];
  }
}
async function aI(t, A, e) {
  const i = t.getCoValue(A);
  if (!i)
    throw new Error(`[${e}] CoValue not found: ${A}`);
  if (!i.isAvailable()) {
    await t.node.loadCoValueCore(A);
    let o = 0;
    for (; !i.isAvailable() && o < 10; )
      await new Promise((r) => setTimeout(r, 100)), o++;
    if (!i.isAvailable())
      throw new Error(`[${e}] CoValue ${A} is not available (may still be loading)`);
  }
  return i;
}
const vw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ensureCoValueAvailable: aI,
  formatValidationErrors: be,
  getValidationEngine: mo,
  loadSchemaAndValidate: $t,
  requireDbEngine: JA,
  requireParam: BA,
  setSchemaResolver: nI,
  validateAgainstSchema: Vt,
  validateAgainstSchemaOrThrow: gt,
  validateCoId: uA,
  validateItems: sI,
  withSchemaValidationDisabled: ne
}, Symbol.toStringTag, { value: "Module" }));
async function gI(t, A = {}, e, i = null, o = null) {
  let r = t;
  if (t && typeof t.createMap == "function")
    r = t;
  else if (t && typeof t.get == "function" && t.get("profile")) {
    const g = o?.backend;
    if (!g)
      throw new Error("[createCoMap] dbEngine.backend required when passing account (to resolve @maia spark group)");
    const { getSparkGroup: I } = await Promise.resolve().then(() => ce);
    if (r = await I(g, "@maia"), !r)
      throw new Error("[createCoMap] @maia spark group not found. Ensure schemaMigration has run.");
  }
  if (e === yA.META_SCHEMA) {
    const a = { $schema: yA.META_SCHEMA };
    return r.createMap(A, a);
  }
  yo(e, "createCoMap"), He(e) || await $t(
    o?.backend || null,
    e,
    A,
    "createCoMap",
    { dbEngine: o, getAllSchemas: wo }
  );
  const n = at(e);
  return r.createMap(A, n);
}
async function II(t, A = [], e, i = null, o = null) {
  let r = t;
  if (t && typeof t.get == "function" && t.get("profile")) {
    const g = o?.backend;
    if (!g)
      throw new Error("[createCoList] dbEngine.backend required when passing account (to resolve @maia spark group)");
    const { getSparkGroup: I } = await Promise.resolve().then(() => ce);
    if (r = await I(g, "@maia"), !r)
      throw new Error("[createCoList] @maia spark group not found. Ensure schemaMigration has run.");
  }
  yo(e, "createCoList"), He(e) || await $t(
    o?.backend || null,
    e,
    A,
    "createCoList",
    { dbEngine: o, getAllSchemas: wo }
  );
  const n = at(e);
  return r.createList(A, n);
}
async function cI(t, A, e = null, i = null) {
  let o = t;
  if (t && typeof t.get == "function" && t.get("profile")) {
    const s = i?.backend;
    if (!s)
      throw new Error("[createCoStream] dbEngine.backend required when passing account");
    const { getSparkGroup: a } = await Promise.resolve().then(() => ce);
    if (o = await a(s, "@maia"), !o)
      throw new Error("[createCoStream] @maia spark group not found. Ensure schemaMigration has run.");
  }
  yo(A, "createCoStream");
  const r = at(A);
  return o.createStream(r);
}
async function CI(t, A) {
  const e = t.getCoValue(A);
  if (!e || !e?.isAvailable())
    return null;
  const i = e?.getCurrentContent();
  return !i || typeof i.addMember != "function" ? null : i;
}
async function yn(t, A, e) {
  if (!A || typeof A != "string" || !A.startsWith("co_z")) return null;
  const i = await t.read(null, A);
  await dA(i, A, 15e3);
  const o = t.getCoValue(A);
  if (!o || !t.isAvailable(o)) return null;
  const r = t.getCurrentContent(o);
  if (!r || typeof r.get != "function") return null;
  const n = r.get("capabilities");
  if (!n || typeof n != "string" || !n.startsWith("co_z")) return null;
  const s = await t.read(null, n);
  await dA(s, n, 15e3);
  const a = t.getCoValue(n);
  if (!a || !t.isAvailable(a)) return null;
  const g = t.getCurrentContent(a);
  if (!g || typeof g.get != "function") return null;
  const I = g.get(e);
  return !I || typeof I != "string" || !I.startsWith("co_z") ? null : I;
}
async function BI(t, A, e) {
  const i = await KA(t, A);
  return yn(t, i, e);
}
async function Dn(t, A, e) {
  if (!A || typeof A != "string" || !A.startsWith("co_z")) return null;
  const i = t.getCoValue(A) || await t.node?.loadCoValueCore?.(A);
  if (!i || !t.isAvailable?.(i)) return null;
  const o = t.getCurrentContent?.(i);
  if (!o || typeof o.get != "function") return null;
  const r = o.get("os");
  return yn(t, r, e);
}
async function mn(t, A) {
  if (!A || typeof A != "string")
    throw new Error("[getSparkGroup] spark is required");
  const e = `_cachedSparkGroup_${A}`;
  if (t[e])
    return t[e];
  const i = await BI(t, A, "guardian");
  if (!i || typeof i != "string" || !i.startsWith("co_z"))
    throw new Error(`[getSparkGroup] Spark ${A} has no guardian in os.capabilities`);
  const o = await t.read("@group", i);
  if (!o || o.error)
    throw new Error(`[getSparkGroup] Group for spark ${A} not available: ${i}`);
  await new Promise((s, a) => {
    if (!o.loading) {
      s();
      return;
    }
    let g;
    const I = setTimeout(() => {
      a(new Error(`[getSparkGroup] Timeout waiting for group ${i}`));
    }, 1e4);
    g = o.subscribe(() => {
      o.loading || (clearTimeout(I), g(), s());
    });
  });
  const r = t.getCoValue(i);
  if (!r)
    throw new Error(`[getSparkGroup] Group core not found: ${i}`);
  const n = t.getCurrentContent(r);
  if (!n || typeof n.createMap != "function")
    throw new Error(`[getSparkGroup] Group content not available: ${i}`);
  return t[e] = n, n;
}
async function KA(t, A) {
  const e = t.account.get("sparks");
  if (!e?.startsWith("co_z")) return null;
  const i = await t.read(null, e);
  await new Promise((s, a) => {
    if (!i.loading) return s();
    let g;
    const I = setTimeout(() => a(new Error("Timeout")), 1e4);
    g = i.subscribe(() => {
      i.loading || (clearTimeout(I), g?.(), s());
    });
  });
  const o = i.value?.[A];
  if (!o?.startsWith("co_z")) return null;
  const r = await t.read(null, o);
  await new Promise((s, a) => {
    if (!r.loading) return s();
    let g;
    const I = setTimeout(() => a(new Error("Timeout")), 1e4);
    g = r.subscribe(() => {
      r.loading || (clearTimeout(I), g?.(), s());
    });
  });
  const n = r.value?.os || null;
  return n && (t._cachedMaiaOsId = n), n;
}
async function So(t, A) {
  const e = t.account.get("sparks");
  if (!e?.startsWith("co_z")) return null;
  const i = await t.read(null, e);
  await new Promise((n, s) => {
    if (!i.loading) return n();
    let a;
    const g = setTimeout(() => s(new Error("Timeout")), 1e4);
    a = i.subscribe(() => {
      i.loading || (clearTimeout(g), a?.(), n());
    });
  });
  const o = i.value?.[A];
  if (!o?.startsWith("co_z")) return null;
  const r = await t.read(null, o);
  return await new Promise((n, s) => {
    if (!r.loading) return n();
    let a;
    const g = setTimeout(() => s(new Error("Timeout")), 1e4);
    a = r.subscribe(() => {
      r.loading || (clearTimeout(g), a?.(), n());
    });
  }), r.value?.vibes || null;
}
async function QI(t, A, e) {
  const i = t.account.get("sparks");
  if (!i?.startsWith("co_z")) throw new Error("[setSparkVibesId] account.sparks not found");
  const o = await t.read(null, i);
  await new Promise((a, g) => {
    if (!o.loading) return a();
    let I;
    const c = setTimeout(() => g(new Error("Timeout")), 1e4);
    I = o.subscribe(() => {
      o.loading || (clearTimeout(c), I?.(), a());
    });
  });
  const r = o.value?.[A];
  if (!r?.startsWith("co_z")) throw new Error(`[setSparkVibesId] Spark ${A} not found`);
  const n = t.getCoValue(r);
  if (!n) throw new Error(`[setSparkVibesId] Spark core not found: ${r}`);
  const s = t.getCurrentContent(n);
  if (!s || typeof s.set != "function") throw new Error("[setSparkVibesId] Spark content not available");
  s.set("vibes", e);
}
async function ko(t) {
  return mn(t, "@maia");
}
function Sn(t) {
  const A = [], e = /* @__PURE__ */ new Set();
  try {
    if (typeof t.getMemberKeys == "function") {
      const i = t.getMemberKeys();
      for (const o of i) {
        if (e.has(o)) continue;
        e.add(o);
        let r = null;
        if (typeof t.roleOf == "function")
          try {
            r = t.roleOf(o);
          } catch {
            try {
              const s = t.get(o);
              s && s !== "revoked" && (r = s);
            } catch {
            }
          }
        else if (typeof t.get == "function") {
          const n = t.get(o);
          n && n !== "revoked" && (r = n);
        }
        if (r && r !== "revoked") {
          const n = t.get ? t.get(o) : null, s = n === "revoked" || n !== r;
          A.push({
            id: o,
            role: r,
            isInherited: s || !1
          });
        }
      }
    }
    if (A.length === 0 && t.members && typeof t.members[Symbol.iterator] == "function") {
      for (const i of t.members)
        if (i && i.account) {
          const o = i.account, r = typeof o == "string" ? o : o.id || o.$jazz && o.$jazz.id || "unknown";
          if (e.has(r)) continue;
          e.add(r);
          let n = null;
          if (typeof t.roleOf == "function")
            try {
              n = t.roleOf(r);
            } catch {
            }
          n && n !== "revoked" && A.push({
            id: r,
            role: n,
            isInherited: !1
          });
        }
    }
  } catch (i) {
    console.warn("[CoJSONBackend] Error extracting account members:", i);
  }
  return A;
}
function EI(t) {
  try {
    let A = null;
    if (typeof t.getRoleOf == "function")
      try {
        const e = t.getRoleOf("everyone");
        e && typeof e == "string" && e !== "revoked" && (A = e);
      } catch {
      }
    if (!A && typeof t.get == "function")
      try {
        const e = t.get("everyone");
        e && typeof e == "string" && e !== "revoked" && (A = e);
      } catch {
      }
    if (!A && t.everyone !== void 0) {
      const e = t.everyone;
      e && typeof e == "string" && e !== "revoked" && (A = e);
    }
    return A;
  } catch {
    return null;
  }
}
function kn(t) {
  const A = [];
  try {
    if (typeof t.getParentGroups == "function") {
      const e = t.getParentGroups();
      if (e && typeof e[Symbol.iterator] == "function")
        for (const i of e) {
          const o = typeof i == "string" ? i : i.id || i.$jazz && i.$jazz.id || "unknown";
          let r = null;
          const n = `parent_${o}`;
          if (typeof t.get == "function")
            try {
              r = t.get(n);
            } catch {
            }
          let s = "";
          r === "extend" ? s = "Inherits roles from this group" : r === "reader" ? s = "All members of this group get reader access" : r === "writer" ? s = "All members of this group get writer access" : r === "manager" ? s = "All members of this group get manager access" : r === "admin" ? s = "All members of this group get admin access" : r === "revoked" ? s = "Delegation revoked" : s = "Delegated access";
          const a = [];
          try {
            const g = typeof i.getMemberKeys == "function" ? i.getMemberKeys() : [], I = typeof i.get == "function" && i.get("everyone"), c = [...g];
            I && c.push("everyone");
            for (const C of c) {
              const B = typeof i.roleOf == "function" ? i.roleOf(C) : null;
              if (!B || B === "revoked") continue;
              const Q = r === "extend" || r === "inherit" ? B : r;
              a.push({ id: C, role: Q });
            }
          } catch {
          }
          A.push({
            id: o,
            role: r || "extend",
            roleDescription: s,
            members: a
          });
        }
    }
  } catch (e) {
    console.warn("[CoJSONBackend] Error extracting group members:", e);
  }
  return A;
}
function Jr(t) {
  if (!t || typeof t.addMember != "function")
    return null;
  try {
    const A = t.id || t.$jazz && t.$jazz.id;
    if (!A)
      return null;
    const e = Sn(t), i = EI(t);
    i && (e.some((n) => n.id === "everyone") || e.push({
      id: "everyone",
      role: i
    }));
    const o = kn(t);
    return {
      groupId: A,
      accountMembers: e,
      groupMembers: o
    };
  } catch (A) {
    return console.warn("[CoJSONBackend] Error getting group info from group:", A), null;
  }
}
async function Nn(t, A, e, i, o = null) {
  if (typeof A.addMember != "function")
    throw new Error("[CoJSONBackend] Group does not support addMember");
  if (!e || !e.startsWith("co_z"))
    throw new Error("[CoJSONBackend] Agent account co-id required (co_z...). Sealer/signer IDs are not supported - agents must use their account.");
  if (o) {
    const { ensureCoValueLoaded: s } = await Promise.resolve().then(() => CQ);
    await s(o, e, { waitForAvailable: !0, timeoutMs: 1e4 });
  }
  const n = t.expectCoValueLoaded(e, "Expected account to be loaded for addMember").getCurrentContent();
  A.addMember(n, i);
}
function lI(t, A) {
  return !(Sn(t).filter(
    (n) => (n.role === "admin" || n.role === "manager") && n.id !== A
  ).length > 0 || kn(t).some((n) => n.role === "admin" || n.role === "extend"));
}
async function Mn(t, A) {
  const e = typeof A == "string" ? A : A?.id ?? A?.$jazz?.id;
  if (!e || !e.startsWith("co_z"))
    throw new Error("[removeGroupMember] member must be co-id (co_z...) or account content with .id");
  if (typeof t.removeMember != "function")
    throw new Error("[CoJSONBackend] Group does not support removeMember");
  if (lI(t, e))
    throw new Error("[removeGroupMember] Cannot remove last admin. Group must have at least one admin.");
  t.removeMember(e);
}
async function dI(t, A, e, i) {
  if (typeof A.setRole == "function")
    A.setRole(e, i);
  else if (typeof A.removeMember == "function" && typeof A.addMember == "function")
    A.removeMember(e), await Nn(t, A, e, i, null);
  else
    throw new Error("[CoJSONBackend] Group does not support role changes");
}
const ce = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addGroupMember: Nn,
  extractAccountMembers: Sn,
  extractEveryoneRole: EI,
  extractGroupMembers: kn,
  getCapabilityGroupIdFromOsId: yn,
  getGroup: CI,
  getGroupInfoFromGroup: Jr,
  getMaiaGroup: ko,
  getSparkCapabilityGroupId: BI,
  getSparkCapabilityGroupIdFromSparkCoId: Dn,
  getSparkGroup: mn,
  getSparkOsId: KA,
  getSparkVibesId: So,
  removeGroupMember: Mn,
  setGroupMemberRole: dI,
  setSparkVibesId: QI,
  wouldLeaveNoAdmins: lI
}, Symbol.toStringTag, { value: "Module" }));
async function Yw(t, A) {
  if (t.node && t.account && t.guardian)
    return {
      node: t.node,
      account: t.account,
      guardian: t.guardian
    };
  if (t.node && t.account && A) {
    const e = await mn(t, A);
    return { node: t.node, account: t.account, guardian: e };
  }
  throw new Error(
    "[createCoValueForSpark] Invalid context. Provide backend (with node, account) + spark, or { node, account, guardian }."
  );
}
async function pA(t, A, e) {
  const { schema: i, cotype: o, data: r, dbEngine: n } = e;
  if (!i || typeof i != "string")
    throw new Error("[createCoValueForSpark] options.schema is required");
  if (!o || !["comap", "colist", "costream"].includes(o))
    throw new Error("[createCoValueForSpark] options.cotype must be comap, colist, or costream");
  const { node: s, account: a, guardian: g } = await Yw(t, A);
  if (!a)
    throw new Error("[createCoValueForSpark] Account required");
  const I = s.createGroup();
  I.extend(g, "admin");
  let c;
  switch (o) {
    case "comap":
      c = await gI(I, r ?? {}, i, s, n);
      break;
    case "colist":
      c = await II(I, Array.isArray(r) ? r : [], i, s, n);
      break;
    case "costream":
      c = await cI(I, i, s, n);
      break;
    default:
      throw new Error("[createCoValueForSpark] Unsupported cotype: " + o);
  }
  const C = typeof s.getCurrentAccountOrAgentID == "function" ? s.getCurrentAccountOrAgentID() : a?.id ?? a?.$jazz?.id;
  try {
    await Mn(I, C);
  } catch (B) {
    throw new Error(`[createCoValueForSpark] Failed to remove account from group: ${B.message}`);
  }
  return { coValue: c };
}
const Re = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createCoValueForSpark: pA
}, Symbol.toStringTag, { value: "Module" }));
async function Uw(t, A, e) {
  try {
    const i = await nA(t, A, { waitForAvailable: !0 });
    if (i && t.isAvailable(i)) {
      const o = t.getCurrentContent(i);
      if (o && o.get) {
        const r = o.get("definition");
        if (r && r.cotype) {
          if (r.cotype === "cotext" || r.cotype === "coplaintext")
            throw new Error(`[CoJSONBackend] CoText (cotext) support has been eliminated. Schema ${A} specifies cotext, which is no longer supported.`);
          return r.cotype;
        }
      }
    }
  } catch (i) {
    console.warn(`[CoJSONBackend] Failed to load schema ${A} for cotype:`, i);
  }
  if (Array.isArray(e))
    return "colist";
  if (typeof e == "string")
    throw new Error(`[CoJSONBackend] Cannot determine cotype from data type for schema ${A}. String data type is not supported (CoText/cotext support has been eliminated). Use CoMap or CoList instead.`);
  if (typeof e == "object" && e !== null)
    return "comap";
  throw new Error(`[CoJSONBackend] Cannot determine cotype from data type for schema ${A}`);
}
async function Gn(t, A, e, i = {}) {
  const o = i.spark ?? "@maia", r = await Uw(t, A, e);
  if (!t.account)
    throw new Error("[CoJSONBackend] Account required for create");
  if (r === "comap" && (!e || typeof e != "object" || Array.isArray(e)))
    throw new Error("[CoJSONBackend] Data must be object for comap");
  if (r === "colist" && !Array.isArray(e))
    throw new Error("[CoJSONBackend] Data must be array for colist");
  const { coValue: n } = await pA(t, o, {
    schema: A,
    cotype: r,
    data: r === "comap" || r === "colist" ? e : void 0,
    dbEngine: t.dbEngine
  }), s = t.node.getCoValue(n.id);
  if (s && t.isAvailable(s)) {
    const a = t.getCurrentContent(s);
    if (a && typeof a.get == "function") {
      const I = { id: n.id, ...e }, c = a.keys && typeof a.keys == "function" ? a.keys() : Object.keys(a);
      for (const C of c)
        I[C] = a.get(C);
      return I;
    }
    const g = ln(t, s);
    return { ...e, id: n.id, ...g };
  }
  return {
    id: n.id,
    ...e,
    // Include original data to ensure text and other properties are available
    type: r,
    schema: A
  };
}
const Fn = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  create: Gn
}, Symbol.toStringTag, { value: "Module" })), Jw = /^@([a-zA-Z0-9_-]+)\/schema\/(.+)$/;
async function bn(t, A) {
  const e = t?.systemSpark ?? "@maia";
  if (!t.account)
    throw new Error("[SchemaIndexManager] Account required");
  const i = await KA(t, e);
  if (i)
    try {
      const o = await sA(t, i, null, null, null, {
        deepResolve: !1,
        // Don't need deep resolution for infrastructure
        timeoutMs: 1e4
        // 10 second timeout for critical infrastructure
      });
      if (!o || o.value?.error)
        return console.warn(`[SchemaIndexManager] spark.os CoValue not found or error: ${i.substring(0, 12)}...`), null;
      const r = t.getCoValue(i);
      if (!r || !r.isAvailable())
        return console.warn(`[SchemaIndexManager] spark.os (${i.substring(0, 12)}...) is not available after read()`), null;
      const n = r.getCurrentContent?.();
      if (!n)
        return console.warn(`[SchemaIndexManager] spark.os (${i.substring(0, 12)}...) is available but getCurrentContent() returned nothing`), null;
      const s = n.cotype || n.type, I = (t.getHeader(r)?.meta || null)?.$schema || null;
      return s === "comap" && typeof n.get == "function" ? n : (console.warn(`[SchemaIndexManager] spark.os (${i.substring(0, 12)}...) is not a CoMap (cotype: ${s}, schema: ${I}, has get: ${typeof n.get})`), null);
    } catch (o) {
      return console.warn(`[SchemaIndexManager] Failed to load spark.os (${i.substring(0, 12)}...):`, o.message), null;
    }
  return null;
}
async function No(t) {
  const A = await bn(t);
  if (!A)
    return null;
  const e = A.get("indexes");
  if (e)
    try {
      const r = await sA(t, e, null, null, null, {
        deepResolve: !1,
        timeoutMs: 1e4
      });
      if (!r || r.value?.error)
        return console.warn(`[SchemaIndexManager] spark.os.indexes CoValue not found or error: ${e.substring(0, 12)}...`), null;
      const n = t.getCoValue(e);
      if (!n || !n.isAvailable())
        return console.warn(`[SchemaIndexManager] spark.os.indexes (${e.substring(0, 12)}...) is not available after read()`), null;
      const s = n.getCurrentContent?.();
      if (!s)
        return console.warn(`[SchemaIndexManager] spark.os.indexes (${e.substring(0, 12)}...) is available but getCurrentContent() returned nothing`), null;
      const a = s.cotype || s.type, c = (t.getHeader(n)?.meta || null)?.$schema || null;
      return a === "comap" && typeof s.get == "function" ? s : (console.warn(`[SchemaIndexManager] spark.os.indexes (${e.substring(0, 12)}...) is not a CoMap (cotype: ${a}, schema: ${c}, has get: ${typeof s.get})`), null);
    } catch (r) {
      return console.warn(`[SchemaIndexManager] Failed to load spark.os.indexes (${e.substring(0, 12)}...):`, r.message), null;
    }
  let i = await eA(t, "@maia/schema/os/indexes-registry", { returnType: "coId" }), o;
  if (i && typeof i == "string" && i.startsWith("co_z") && t.dbEngine) {
    const { create: r } = await Promise.resolve().then(() => Fn);
    o = (await r(t, i, {})).id;
  } else {
    const { createCoValueForSpark: r } = await Promise.resolve().then(() => Re), { coValue: n } = await r(t, "@maia", {
      schema: yA.META_SCHEMA,
      cotype: "comap",
      data: {}
    });
    o = n.id;
  }
  A.set("indexes", o);
  try {
    const r = await sA(t, o, null, null, null, {
      deepResolve: !1,
      timeoutMs: 5e3
    });
    if (r && !r.value?.error) {
      const n = t.getCoValue(o);
      if (n && t.isAvailable(n)) {
        const s = n.getCurrentContent?.();
        if (s && typeof s.get == "function")
          return s;
      }
    }
  } catch (r) {
    console.warn("[SchemaIndexManager] Failed to load newly created spark.os.indexes:", r.message);
  }
  return null;
}
async function Hw(t, A, e = null) {
  if (!A || !A.startsWith("co_z"))
    throw new Error(`[SchemaIndexManager] Invalid schema co-id: ${A}`);
  if (!e) {
    const c = t.getCoValue(A);
    c && (e = t.getHeader(c)?.meta?.$schema, e && !e.startsWith("co_z") && (e = await eA(t, e, { returnType: "coId" }))), (!e || !e.startsWith("co_z")) && (e = await uI(t));
  }
  if (!e || !e.startsWith("co_z"))
    return console.warn("[SchemaIndexManager] Cannot create schema-specific index colist schema - metaSchema not available"), null;
  const i = await eA(t, A, { returnType: "schema" });
  if (!i)
    return console.warn(`[SchemaIndexManager] Cannot load schema definition for ${A.substring(0, 12)}...`), null;
  const o = i.title || i.$id;
  if (!o || typeof o != "string" || !Do.test(o))
    return console.warn(`[SchemaIndexManager] Schema ${A.substring(0, 12)}... has invalid title: ${o}`), null;
  const r = o.match(Jw);
  if (!r)
    return console.warn(`[SchemaIndexManager] Schema ${A.substring(0, 12)}... has invalid title format: ${o}`), null;
  const [, n, s] = r, a = `@${n}/schema/index/${s}`, g = await eA(t, a, { returnType: "coId" });
  if (g && g.startsWith("co_z"))
    return g;
  const I = {
    title: a,
    description: `Schema-specific index colist for ${o} - only allows instances of this schema`,
    cotype: "colist",
    indexing: !1,
    // Index colist schemas themselves should not be indexed
    items: {
      $co: o
      // Enforces type safety - only co-ids referencing the target schema are allowed
    }
  };
  try {
    const C = (await Gn(t, e, I)).id, B = await hI(t);
    return B && B.set(a, C), C;
  } catch (c) {
    return console.error(`[SchemaIndexManager] Failed to create schema-specific index colist schema for ${o}:`, c), null;
  }
}
async function Rn(t, A, e = null) {
  if (!A || typeof A != "string" || !A.startsWith("co_z"))
    throw new Error(`[SchemaIndexManager] Invalid schema co-id: expected string starting with 'co_z', got ${typeof A}: ${A}`);
  const i = await eA(t, A, { returnType: "schema" });
  if (!i)
    return console.warn(`[SchemaIndexManager] Cannot load schema definition for ${A.substring(0, 12)}...`), null;
  if (i.indexing !== !0)
    return null;
  const o = await No(t);
  if (!o)
    return null;
  let r = o.get(A);
  if (r) {
    try {
      const I = await sA(t, r, null, null, null, {
        deepResolve: !1,
        // Don't need deep resolution for index colists
        timeoutMs: 5e3
      });
      if (I && !I.value?.error) {
        const c = t.getCoValue(r);
        if (c && c.isAvailable()) {
          const C = c.getCurrentContent?.();
          if (C && typeof C.append == "function" && (C.cotype || C.type) === "colist")
            return C;
        }
      }
    } catch (I) {
      console.warn(`[SchemaIndexManager] Failed to read index colist (${r.substring(0, 12)}...):`, I.message);
    }
    return console.warn(`[SchemaIndexManager] Index colist (${r.substring(0, 12)}...) exists but could not be loaded. Skipping to prevent overwriting.`), null;
  }
  const n = await Hw(t, A, e);
  if (!n)
    return console.warn(`[SchemaIndexManager] Cannot create index colist - schema-specific index colist schema not available for ${A.substring(0, 12)}...`), null;
  const { createCoValueForSpark: s } = await Promise.resolve().then(() => Re), { coValue: a } = await s(t, "@maia", {
    schema: n,
    cotype: "colist",
    data: [],
    dbEngine: t.dbEngine
  });
  r = a.id, o.set(A, r);
  const g = t.node.getCoValue(r);
  if (g && g.type === "colist") {
    const I = g.getCurrentContent?.();
    if (I && typeof I.append == "function")
      return I;
  }
  return a;
}
async function Kn(t) {
  const A = await bn(t);
  if (!A)
    return console.warn("[SchemaIndexManager] Cannot create unknown colist - spark.os not available"), null;
  const e = A.get("unknown");
  if (e) {
    const r = t.node.getCoValue(e);
    if (r && r.type === "colist") {
      const n = r.getCurrentContent?.();
      if (n && typeof n.append == "function")
        return n;
    }
  }
  const { createCoValueForSpark: i } = await Promise.resolve().then(() => Re), { coValue: o } = await i(t, "@maia", {
    schema: yA.META_SCHEMA,
    cotype: "colist",
    data: []
  });
  return A.set("unknown", o.id), o;
}
async function qw(t, A) {
  if (!t.account || !A)
    return !1;
  const e = await KA(t, t?.systemSpark ?? "@maia");
  if (A === e)
    return !0;
  if (e) {
    const i = t.node.getCoValue(e);
    if (i && i.type === "comap") {
      const o = i.getCurrentContent?.();
      if (o && typeof o.get == "function") {
        const r = o.get("schematas");
        if (A === r)
          return !0;
        const n = o.get("unknown");
        if (A === n)
          return !0;
        const s = o.get("indexes");
        if (A === s)
          return !0;
        if (s) {
          const a = t.node.getCoValue(s);
          if (a && a.type === "comap") {
            const g = a.getCurrentContent?.();
            if (g && typeof g.get == "function") {
              const I = g.keys && typeof g.keys == "function" ? g.keys() : Object.keys(g);
              for (const c of I)
                if (g.get(c) === A)
                  return !0;
            }
          }
        }
      }
    }
  }
  return !1;
}
async function vn(t, A) {
  if (!A)
    return { shouldIndex: !1, schemaCoId: null };
  if (await qw(t, A.id))
    return { shouldIndex: !1, schemaCoId: null };
  const i = t.getHeader(A);
  if (!i || !i.meta)
    return { shouldIndex: !1, schemaCoId: null };
  const o = i.meta, r = o.$schema;
  if (yA.ACCOUNT === r || yA.GROUP === r || yA.META_SCHEMA === r)
    return { shouldIndex: !1, schemaCoId: null };
  if (o.type === "account" || r === yA.ACCOUNT)
    return { shouldIndex: !1, schemaCoId: null };
  const n = A.ruleset || i?.ruleset;
  if (n && n.type === "group")
    return { shouldIndex: !1, schemaCoId: null };
  if (r && typeof r == "string" && r.startsWith("co_z")) {
    try {
      const s = await eA(t, r, { returnType: "schema" });
      if (s && s.indexing !== !0)
        return { shouldIndex: !1, schemaCoId: r };
    } catch {
    }
    return { shouldIndex: !0, schemaCoId: r };
  }
  return r ? { shouldIndex: !1, schemaCoId: null } : { shouldIndex: !1, schemaCoId: null };
}
async function uI(t) {
  const A = t?.systemSpark ?? "@maia", e = await KA(t, A);
  if (!e)
    return null;
  const i = t.node.getCoValue(e);
  if (!i || i.type !== "comap")
    return null;
  const o = i.getCurrentContent?.();
  if (!o || typeof o.get != "function")
    return null;
  const r = o.get("schematas");
  if (!r)
    return null;
  const n = t.node.getCoValue(r);
  if (!n || n.type !== "comap")
    return null;
  const s = n.getCurrentContent?.();
  if (!s || typeof s.get != "function")
    return null;
  const a = s.get("@maia/schema/meta");
  return a && typeof a == "string" && a.startsWith("co_z") ? a : null;
}
async function hI(t) {
  const A = await bn(t);
  if (!A)
    return null;
  const e = A.get("schematas");
  if (e) {
    try {
      const s = await sA(t, e, null, null, null, {
        deepResolve: !1,
        // Don't need deep resolution for registry
        timeoutMs: 5e3
      });
      if (s && !s.value?.error) {
        const a = t.getCoValue(e);
        if (a && a.isAvailable()) {
          const g = a.getCurrentContent?.();
          if (g && typeof g.set == "function" && (g.cotype || g.type) === "comap")
            return g;
        }
      }
    } catch (s) {
      console.warn(`[SchemaIndexManager] Failed to read schematas registry (${e.substring(0, 12)}...):`, s.message);
    }
    return console.warn(`[SchemaIndexManager] spark.os.schematas (${e.substring(0, 12)}...) exists but could not be loaded. Skipping to prevent overwriting.`), null;
  }
  const o = await eA(t, "@maia/schema/os/schematas-registry", { returnType: "coId" }) || yA.META_SCHEMA, { createCoValueForSpark: r } = await Promise.resolve().then(() => Re), { coValue: n } = await r(t, "@maia", {
    schema: o,
    cotype: "comap",
    data: {},
    dbEngine: t.dbEngine
  });
  return A.set("schematas", n.id), n;
}
async function fI(t, A) {
  if (!A || !A.id)
    return;
  const e = t.getCurrentContent(A);
  if (!e || typeof e.get != "function")
    return;
  const i = e.get("title");
  if (!i || typeof i != "string" || !Do.test(i))
    return;
  const o = await hI(t);
  if (!o)
    return;
  const r = o.get(i);
  if (r === A.id || r && r !== A.id || (o.set(i, A.id), e.get("indexing") !== !0))
    return;
  let g = t.getHeader(A)?.meta?.$schema;
  g && !g.startsWith("co_z") && (g = await eA(t, g, { returnType: "coId" })), await Rn(t, A.id, g);
}
async function pI(t, A) {
  if (!A)
    return !1;
  const e = t.getHeader(A);
  if (!e || !e.meta)
    return !1;
  const o = e.meta.$schema;
  if (!o)
    return !1;
  if (o === yA.META_SCHEMA) {
    const r = t.getCurrentContent(A);
    return !!(r && typeof r.get == "function" && r.get("title") === "@maia/schema/meta");
  }
  if (o && typeof o == "string" && o.startsWith("co_z")) {
    try {
      const n = await sA(t, o, null, null, null, {
        deepResolve: !1,
        // Don't need deep resolution for schema detection
        timeoutMs: 5e3
        // 5 second timeout - metaschema should be available but may need more time during seeding
      });
      if (n && !n.value?.error) {
        const s = t.getCoValue(o);
        if (s && s.isAvailable()) {
          const a = t.getCurrentContent(s);
          if (a && typeof a.get == "function" && a.get("title") === "@maia/schema/meta")
            return !0;
        }
      }
    } catch {
    }
    const r = await uI(t);
    if (r && o === r)
      return !0;
  }
  return !1;
}
const ir = /* @__PURE__ */ new Set();
async function wI(t, A) {
  let e = A, i = null;
  if (typeof A == "string") {
    if (i = A, e = t.getCoValue(i), !e || !t.isAvailable(e))
      return;
  } else
    i = A?.id;
  if (!(!e || !i) && !ir.has(i)) {
    ir.add(i);
    try {
      const { shouldIndex: o, schemaCoId: r } = await vn(t, e);
      if (o && r) {
        const n = await Rn(t, r);
        if (!n)
          return;
        const g = t.getHeader(e)?.meta?.$schema;
        if (!g || g !== r)
          return;
        try {
          const I = n.toJSON ? n.toJSON() : [];
          if (Array.isArray(I) && I.includes(i))
            return;
        } catch {
        }
        try {
          n.append(i);
        } catch {
          return;
        }
      } else {
        const n = await Kn(t);
        if (!n)
          return;
        try {
          const s = n.toJSON ? n.toJSON() : [];
          if (Array.isArray(s) && s.includes(i))
            return;
        } catch {
        }
        n.append(i);
      }
    } finally {
      ir.delete(i);
    }
  }
}
async function xw(t, A) {
  if (!A || !A.startsWith("co_z") || !t.account)
    return null;
  const e = await No(t);
  if (!e)
    return null;
  const i = e.get(A);
  if (!i || typeof i != "string" || !i.startsWith("co_"))
    return null;
  try {
    const o = await sA(t, i, null, null, null, {
      deepResolve: !1,
      // Don't need deep resolution for removal
      timeoutMs: 2e3
    });
    if (o && !o.value?.error) {
      const r = t.getCoValue(i);
      if (r && t.isAvailable(r)) {
        const n = t.getCurrentContent(r);
        if (n && typeof n.toJSON == "function" && typeof n.delete == "function" && (n.cotype || n.type) === "colist")
          return n;
      }
    }
  } catch {
  }
  return null;
}
async function yI(t, A, e = null) {
  if (!(!A || !A.startsWith("co_z"))) {
    if (!e) {
      const i = t.getCoValue(A);
      if (i && t.isAvailable(i)) {
        const o = t.getHeader(i);
        o && o.meta && (e = o.meta.$schema);
      }
    }
    if (e && typeof e == "string" && e.startsWith("co_z")) {
      const i = await xw(t, e);
      if (i && typeof i.toJSON == "function" && typeof i.delete == "function") {
        const r = i.toJSON().indexOf(A);
        r !== -1 && i.delete(r);
      }
    } else {
      const i = await Kn(t);
      if (i && typeof i.toJSON == "function" && typeof i.delete == "function") {
        const r = i.toJSON().indexOf(A);
        r !== -1 && i.delete(r);
      }
    }
  }
}
const DI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ensureIndexesCoMap: No,
  ensureSchemaIndexColist: Rn,
  ensureUnknownColist: Kn,
  indexCoValue: wI,
  isSchemaCoValue: pI,
  registerSchemaCoValue: fI,
  removeFromIndex: yI,
  shouldIndexCoValue: vn
}, Symbol.toStringTag, { value: "Module" }));
async function ro(t, A, e) {
  const i = await nA(t, e, { waitForAvailable: !0 });
  if (!i)
    throw new Error(`[CoJSONBackend] CoValue not found: ${e}`);
  if (!t.isAvailable(i))
    throw new Error(`[CoJSONBackend] CoValue not available: ${e}`);
  const o = t.getCurrentContent(i), r = o?.cotype || o?.type, a = (t.getHeader(i)?.meta || null)?.$schema || A;
  await yI(t, e, a);
  let g = !1;
  if (r === "comap" && o.set) {
    if (o.keys && typeof o.keys == "function") {
      const I = Array.from(o.keys());
      for (const c of I)
        typeof o.delete == "function" && o.delete(c);
    } else if (typeof o.delete == "function") {
      const I = Object.keys(o);
      for (const c of I)
        o.delete(c);
    }
    g = !0;
  } else if (r === "colist" && o.delete) {
    if (typeof o.toJSON == "function") {
      const I = o.toJSON();
      for (let c = I.length - 1; c >= 0; c--)
        typeof o.delete == "function" && o.delete(c);
    }
    g = !0;
  } else if (r === "costream")
    g = !0;
  else if (r === "coplaintext" && o.delete) {
    if (typeof o.toString == "function") {
      const I = o.toString();
      for (let c = I.length - 1; c >= 0; c--)
        typeof o.delete == "function" && o.delete(c, 1);
    }
    g = !0;
  } else
    throw new Error(`[CoJSONBackend] Delete not supported for type: ${r}. Supported types: comap, colist, costream, coplaintext`);
  return g && t.node.storage && await t.node.syncManager.waitForStorageSync(e), g;
}
const kA = "@maia";
async function Lw(t, A) {
  const { EXCEPTION_SCHEMAS: e } = await Promise.resolve().then(() => Pt), i = A.createGroup(), o = { node: A, account: t, guardian: i }, { coValue: r } = await pA(o, null, {
    schema: e.META_SCHEMA,
    cotype: "comap",
    data: {}
  });
  t.set("sparks", r.id), console.log(" Agent minimal bootstrap: account.sparks (empty, connect via /on-added)");
}
async function Tw(t, A, e, i = null) {
  const { EXCEPTION_SCHEMAS: o } = await Promise.resolve().then(() => Pt), { getAllSchemas: r } = await Promise.resolve().then(() => jt), n = e || r(), s = A.createGroup(), a = A.createGroup();
  a.extend(s, "extend");
  const g = a.createMap({}, { $schema: o.META_SCHEMA });
  t.set("temp", g.id), g.set("guardian", s.id), o.META_SCHEMA;
  const I = le("co_zTEMP"), c = { definition: RA(I.definition || I) }, { coValue: C } = await pA(
    { node: A, account: t, guardian: s },
    null,
    { schema: o.META_SCHEMA, cotype: "comap", data: c, dbEngine: i }
  ), B = C.id, Q = le(B), { $schema: f, $id: l, id: u, ...d } = Q.definition || Q;
  for (const [j, G] of Object.entries(RA(d))) C.set(j, G);
  g.set("metaschema", B);
  const h = /* @__PURE__ */ new Map();
  for (const [j, G] of Object.entries(n)) {
    const L = G.$id || `@maia/schema/${j}`;
    h.has(L) || h.set(L, { name: j, schema: G });
  }
  const p = (j, G = /* @__PURE__ */ new Set()) => {
    if (!j || typeof j != "object" || G.has(j)) return /* @__PURE__ */ new Set();
    G.add(j);
    const L = /* @__PURE__ */ new Set();
    j.$co && typeof j.$co == "string" && j.$co.startsWith("@maia/schema/") && L.add(j.$co);
    for (const v of Object.values(j))
      v && typeof v == "object" && (Array.isArray(v) ? v : [v]).forEach((S) => {
        S && typeof S == "object" && p(S, G).forEach((M) => L.add(M));
      });
    return L;
  }, E = /* @__PURE__ */ new Map();
  for (const [j, { schema: G }] of h) E.set(j, p(G));
  const w = [], y = /* @__PURE__ */ new Set(), m = /* @__PURE__ */ new Set(), k = (j) => {
    if (!y.has(j) && !m.has(j)) {
      m.add(j);
      for (const G of E.get(j) || [])
        G.startsWith("@maia/schema/") && h.has(G) && k(G);
      m.delete(j), y.add(j), w.push(j);
    }
  };
  for (const j of h.keys())
    j !== "@maia/schema/meta" && k(j);
  const b = /* @__PURE__ */ new Map();
  for (const j of w) {
    const { schema: G } = h.get(j), { $schema: L, $id: v, id: S, ...M } = G, K = RA(M), { coValue: H } = await pA(
      { node: A, account: t, guardian: s },
      null,
      { schema: B, cotype: "comap", data: K, dbEngine: i }
    ), V = H.id;
    b.set(j, V), g.set(j, V);
  }
  const q = g.get("@maia/schema/data/spark") || o.META_SCHEMA, P = g.get("@maia/schema/os/schematas-registry") || o.META_SCHEMA, J = g.get("@maia/schema/os/os-registry") || o.META_SCHEMA, W = g.get("@maia/schema/os/capabilities") || o.META_SCHEMA, X = g.get("@maia/schema/os/indexes-registry") || o.META_SCHEMA, z = g.get("@maia/schema/os/vibes-registry") || o.META_SCHEMA, _ = g.get("@maia/schema/os/sparks-registry") || o.META_SCHEMA, O = { node: A, account: t, guardian: s }, Z = (j, G) => ({ schema: j, cotype: "comap", data: G, dbEngine: i }), { coValue: T } = await pA(O, null, Z(q, { name: kA })), { coValue: F } = await pA(O, null, Z(J, {})), { coValue: x } = await pA(O, null, Z(W, {}));
  x.set("guardian", s.id), F.set("capabilities", x.id);
  const { coValue: R } = await pA(O, null, Z(P, {})), { coValue: D } = await pA(O, null, Z(X, {})), { coValue: N } = await pA(O, null, Z(z, {}));
  F.set("schematas", R.id), F.set("indexes", D.id), T.set("os", F.id), T.set("vibes", N.id), R.set("@maia/schema/meta", B);
  for (const [j, G] of b) R.set(j, G);
  const { coValue: Y } = await pA(O, null, Z(_, {}));
  Y.set(kA, T.id), t.set("sparks", Y.id), typeof t.delete == "function" && t.delete("temp"), console.log(" Bootstrap scaffold complete: account.sparks, @maia spark, os, schematas, indexes, vibes");
}
async function Ow(t, A) {
  const e = t.account?.get("sparks");
  if (!e?.startsWith("co_z")) return;
  const i = await t.read(null, e);
  await new Promise((O, Z) => {
    if (!i.loading) return O();
    let T;
    const F = setTimeout(() => Z(new Error("Timeout")), 1e4);
    T = i.subscribe(() => {
      i.loading || (clearTimeout(F), T?.(), O());
    });
  });
  const o = i?.value;
  if (!o || o.error) return;
  const r = o[kA];
  if (!r || !r.startsWith("co_z")) return;
  const n = t.getCoValue(r);
  if (!n) return;
  t.isAvailable(n) || await new Promise((O, Z) => {
    const T = setTimeout(() => Z(new Error("Timeout")), 1e4), F = n.subscribe((x) => {
      x && t.isAvailable(x) && (clearTimeout(T), F?.(), O());
    });
  });
  const s = t.getCurrentContent(n);
  if (!s || typeof s.set != "function") return;
  const { EXCEPTION_SCHEMAS: a } = await Promise.resolve().then(() => Pt), g = t.node, I = s.get("os");
  if (!I || !I.startsWith("co_z")) return;
  const c = t.getCoValue(I);
  if (!c || !t.isAvailable(c)) return;
  const C = t.getCurrentContent(c);
  if (!C || typeof C.get != "function") return;
  const B = C.get("capabilities");
  if (!B || !B.startsWith("co_z")) return;
  const Q = t.getCoValue(B);
  if (!Q || !t.isAvailable(Q)) return;
  const f = t.getCurrentContent(Q);
  if (!f || typeof f.set != "function") return;
  let l = null;
  const u = f.get("publicReaders");
  if (u && u.startsWith("co_z")) {
    const O = g.getCoValue(u);
    O?.isGroup?.() && t.isAvailable(O) && (l = t.getCurrentContent(O));
  }
  if (!l || typeof l.createMap != "function") {
    const O = g.createGroup();
    O.addMember("everyone", "reader"), l = g.createGroup(), l.extend(A, "extend"), l.extend(O, "reader"), f.set("publicReaders", l.id);
  }
  const { resolve: d } = await Promise.resolve().then(() => un), h = await d(t, "@maia/schema/os/registries", { returnType: "coId" }), p = await d(t, "@maia/schema/os/sparks-registry", { returnType: "coId" }), E = await d(t, "@maia/schema/os/humans-registry", { returnType: "coId" }), w = h ? { $schema: h } : { $schema: a.META_SCHEMA }, y = p ? { $schema: p } : { $schema: a.META_SCHEMA }, m = E ? { $schema: E } : { $schema: a.META_SCHEMA }, { removeGroupMember: k } = await Promise.resolve().then(() => ce), b = t.account, q = typeof g.getCurrentAccountOrAgentID == "function" ? g.getCurrentAccountOrAgentID() : b?.id ?? b?.$jazz?.id;
  let P = s.get("registries"), J = null;
  if (P) {
    const O = t.getCoValue(P);
    O && t.isAvailable(O) && (J = t.getCurrentContent(O));
  }
  if (!J || typeof J.set != "function") {
    const O = g.createGroup();
    O.extend(A, "extend"), O.extend(l, "reader");
    const Z = O.createMap({}, w);
    try {
      await k(O, q);
    } catch {
    }
    s.set("registries", Z.id), J = Z;
  }
  let W = J.get("sparks"), X = null;
  if (W) {
    const O = t.getCoValue(W);
    O && t.isAvailable(O) && (X = t.getCurrentContent(O));
  }
  if (!X || typeof X.set != "function") {
    const O = g.createGroup();
    O.extend(A, "extend"), O.extend(l, "reader");
    const Z = O.createMap({}, y);
    try {
      await k(O, q);
    } catch {
    }
    J.set("sparks", Z.id), X = Z;
  }
  X.set(kA, r);
  let z = J.get("humans"), _ = null;
  if (z) {
    const O = t.getCoValue(z);
    O && t.isAvailable(O) && (_ = t.getCurrentContent(O));
  }
  if (!_ || typeof _.set != "function") {
    const O = g.createGroup();
    O.extend(A, "extend"), O.extend(l, "reader");
    const Z = O.createMap({}, m);
    try {
      await k(O, q);
    } catch {
    }
    J.set("humans", Z.id);
  }
}
function RA(t, A = !1) {
  if (t == null || typeof t != "object") return t;
  if (Array.isArray(t)) return t.map((i) => RA(i, A));
  const e = {};
  for (const [i, o] of Object.entries(t)) {
    if (i === "id" && !A) continue;
    const r = i === "properties" || i === "items";
    e[i] = o != null && typeof o == "object" ? RA(o, r || A) : o;
  }
  return e;
}
async function Pw(t, A, e) {
  let i = 0, o = 0;
  try {
    const r = await KA(e, kA);
    if (!r)
      return { deleted: 0, errors: 0 };
    const n = await nA(e, r, {
      waitForAvailable: !0,
      timeoutMs: 5e3
    });
    if (!n || !e.isAvailable(n))
      return { deleted: 0, errors: 0 };
    const s = e.getCurrentContent(n);
    if (!s || typeof s.get != "function")
      return { deleted: 0, errors: 0 };
    const a = s.get("schematas"), g = /* @__PURE__ */ new Set();
    if (a) {
      const E = await nA(e, a, {
        waitForAvailable: !0,
        timeoutMs: 5e3
      });
      if (E && e.isAvailable(E)) {
        const w = e.getCurrentContent(E);
        if (w && typeof w.get == "function") {
          const y = w.keys && typeof w.keys == "function" ? w.keys() : Object.keys(w);
          for (const m of y) {
            const k = w.get(m);
            k && typeof k == "string" && k.startsWith("co_z") && g.add(k);
          }
        }
      }
    }
    const I = s.get("metaSchema");
    I && typeof I == "string" && I.startsWith("co_z") && g.add(I);
    const c = /* @__PURE__ */ new Set();
    let C = null;
    const B = s.get("indexes");
    if (B)
      try {
        const E = await nA(e, B, {
          waitForAvailable: !0,
          timeoutMs: 5e3
        });
        if (E && e.isAvailable(E) && (C = e.getCurrentContent(E), C && typeof C.get == "function")) {
          const w = C.keys && typeof C.keys == "function" ? C.keys() : Object.keys(C);
          console.log(`[Seed] Found ${w.length} schema index colists in account.os.indexes`);
          for (const y of w)
            if (y.startsWith("co_z")) {
              const m = C.get(y);
              if (m)
                try {
                  const k = await nA(e, m, {
                    waitForAvailable: !0,
                    timeoutMs: 2e3
                  });
                  if (k && e.isAvailable(k)) {
                    const b = e.getCurrentContent(k);
                    if (b && typeof b.toJSON == "function") {
                      const q = b.toJSON();
                      for (const P of q)
                        P && typeof P == "string" && P.startsWith("co_z") && c.add(P);
                    }
                  }
                } catch (k) {
                  console.warn(`[Seed] Failed to read index colist ${y ? y.substring(0, 12) : "undefined"}...:`, k.message), o++;
                }
            }
        }
      } catch (E) {
        console.warn("[Seed] Failed to read account.os.indexes:", E.message), o++;
      }
    let Q = null;
    const f = s.get("unknown");
    if (f)
      try {
        const E = await nA(e, f, {
          waitForAvailable: !0,
          timeoutMs: 2e3
        });
        if (E && e.isAvailable(E) && (Q = e.getCurrentContent(E), Q && typeof Q.toJSON == "function")) {
          const w = Q.toJSON();
          console.log(`[Seed] Found ${w.length} co-values in account.os.unknown`);
          for (const y of w)
            y && typeof y == "string" && y.startsWith("co_z") && c.add(y);
        }
      } catch (E) {
        console.warn("[Seed] Failed to read unknown colist:", E.message), o++;
      }
    const l = Array.from(c).filter((E) => !g.has(E));
    console.log(`[Seed] Deleting ${l.length} co-values (filtered from ${c.size} total, preserving ${g.size} schemas)`);
    for (const E of l)
      try {
        const w = e.getCoValue(E);
        if (!w)
          continue;
        const k = (e.getHeader(w)?.meta || null)?.$schema;
        if (k && g.has(E))
          continue;
        try {
          await ro(e, k || null, E), i++;
        } catch (b) {
          if (b.message && (b.message.includes("Cannot access") || b.message.includes("before initialization") || b.message.includes("ReferenceError")))
            i++;
          else
            throw b;
        }
      } catch (w) {
        console.warn(`[Seed] Failed to delete co-value ${E ? E.substring(0, 12) : "undefined"}...:`, w.message), o++;
      }
    let u = null;
    const d = await So(e, kA);
    if (d)
      try {
        const E = await nA(e, d, {
          waitForAvailable: !0,
          timeoutMs: 2e3
        });
        if (E && e.isAvailable(E) && (u = e.getCurrentContent(E), u && typeof u.get == "function")) {
          const w = u.keys && typeof u.keys == "function" ? u.keys() : Object.keys(u);
          console.log(`[Seed] Deleting ${w.length} vibes from account.vibes`);
          for (const y of w) {
            const m = u.get(y);
            if (m && typeof m == "string" && m.startsWith("co_z"))
              try {
                const k = e.getCoValue(m);
                if (k) {
                  const P = (e.getHeader(k)?.meta || null)?.$schema;
                  await ro(e, P || null, m), i++;
                }
              } catch (k) {
                console.warn(`[Seed] Failed to delete vibe ${m ? m.substring(0, 12) : "undefined"}...:`, k.message), o++;
              }
          }
          for (const y of w)
            typeof u.delete == "function" && u.delete(y);
        }
      } catch (E) {
        console.warn("[Seed] Failed to delete vibes:", E.message), o++;
      }
    const h = [];
    let p = null;
    if (C)
      p = C;
    else {
      const E = s.get("indexes");
      if (E)
        try {
          const w = await nA(e, E, {
            waitForAvailable: !0,
            timeoutMs: 5e3
          });
          w && e.isAvailable(w) && (p = e.getCurrentContent(w));
        } catch (w) {
          console.warn("[Seed] Failed to read account.os.indexes for index colist deletion:", w.message), o++;
        }
    }
    if (p && typeof p.get == "function") {
      const E = p.keys && typeof p.keys == "function" ? p.keys() : Object.keys(p);
      console.log(`[Seed] Deleting ${E.length} index colists from account.os.indexes`);
      for (const w of E)
        if (w.startsWith("co_z")) {
          const y = p.get(w);
          if (y && typeof y == "string" && y.startsWith("co_z")) {
            const m = w;
            h.push({ schemaCoId: m, indexColistId: y });
          }
        }
    }
    for (const { schemaCoId: E, indexColistId: w } of h)
      try {
        const y = await eA(e, E, { returnType: "schema" });
        if (!y || !y.title) {
          console.warn(`[Seed] Cannot get schema title for ${E ? E.substring(0, 12) : "undefined"}..., skipping index colist deletion`);
          continue;
        }
        const m = y.title;
        if (!m.startsWith("@maia/schema/")) {
          console.warn(`[Seed] Invalid schema title format: ${m}, skipping index colist deletion`);
          continue;
        }
        const b = `@maia/schema/index/${m.replace("@maia/schema/", "")}`, q = await eA(e, b, { returnType: "coId" });
        if (!q) {
          console.warn(`[Seed] Cannot resolve index colist schema ${b}, skipping index colist deletion`);
          continue;
        }
        try {
          await ro(e, q, w), i++, p && typeof p.delete == "function" && p.delete(E);
        } catch (P) {
          if (P.message && (P.message.includes("Cannot access") || P.message.includes("before initialization") || P.message.includes("ReferenceError")))
            i++, p && typeof p.delete == "function" && p.delete(E);
          else
            throw P;
        }
      } catch (y) {
        console.warn(`[Seed] Failed to delete index colist ${w ? w.substring(0, 12) : "undefined"}...:`, y.message), o++;
      }
    if (p && typeof p.delete == "function")
      try {
        const E = p.keys && typeof p.keys == "function" ? Array.from(p.keys()) : Object.keys(p);
        if (E.length > 0) {
          console.log(`[Seed] Clearing ${E.length} remaining entries from account.os.indexes`);
          for (const w of E)
            p.delete(w);
        }
      } catch (E) {
        console.warn("[Seed] Failed to clear account.os.indexes:", E.message), o++;
      }
    if (Q && typeof Q.delete == "function")
      try {
        const E = Q.toJSON ? Q.toJSON() : [];
        E.length > 0 && console.log(`[Seed] Clearing ${E.length} remaining entries from account.os.unknown`);
      } catch (E) {
        console.warn("[Seed] Failed to clear account.os.unknown:", E.message), o++;
      }
    if (u && typeof u.get == "function") {
      const E = u.keys && typeof u.keys == "function" ? Array.from(u.keys()) : Object.keys(u);
      E.length > 0 ? console.warn(`[Seed] Warning: ${E.length} entries still remain in account.vibes after clearing`) : console.log("[Seed] account.vibes cleared successfully");
    }
    return console.log(`[Seed] Cleanup complete: deleted ${i} co-values, ${o} errors`), { deleted: i, errors: o };
  } catch (r) {
    return console.error("[Seed] Error during cleanup:", r), { deleted: i, errors: o + 1 };
  }
}
function le(t) {
  const A = t ? `https://maia.city/${t}` : "https://json-schema.org/draft/2020-12/schema";
  return {
    definition: {
      ...oo,
      $id: A,
      $schema: A
    }
  };
}
async function jw(t, A, e, i, o, r = null) {
  const { CoJSONBackend: n } = await Promise.resolve().then(() => Lr), s = r || new n(A, t, { systemSpark: "@maia" });
  if (!t.get("sparks") || !String(t.get("sparks")).startsWith("co_z")) {
    const { getAllSchemas: G } = await Promise.resolve().then(() => jt);
    await Tw(t, A, i || G(), r?.dbEngine);
  }
  try {
    const G = await KA(s, kA);
    if (G) {
      const L = await nA(s, G, {
        waitForAvailable: !0,
        timeoutMs: 2e3
      });
      if (L && s.isAvailable(L)) {
        const v = s.getCurrentContent(L);
        if (v && typeof v.get == "function") {
          const S = v.get("schematas");
          if (S) {
            const M = await nA(s, S, {
              waitForAvailable: !0,
              timeoutMs: 2e3
            });
            if (M && s.isAvailable(M)) {
              const K = s.getCurrentContent(M);
              if (K && typeof K.get == "function" && (K.keys && typeof K.keys == "function" ? K.keys() : Object.keys(K)).length > 0 && (!e || !e.vibes?.length && Object.keys(e.actors || {}).length === 0))
                return console.log("  Account already seeded and no configs provided, skipping"), { skipped: !0, reason: "already_seeded_no_configs" };
            }
          }
        }
      }
    }
  } catch (G) {
    console.warn("[Seed] Idempotency check failed, proceeding with seeding:", G.message);
  }
  const { CoIdRegistry: a } = await Promise.resolve().then(() => rI), { transformForSeeding: g, validateSchemaStructure: I } = await Promise.resolve().then(() => wn), c = new a(), C = await KA(s, kA);
  if (C)
    try {
      const G = await nA(s, C, {
        waitForAvailable: !0,
        timeoutMs: 2e3
      });
      if (G && s.isAvailable(G)) {
        const L = s.getCurrentContent(G);
        if (L && typeof L.get == "function" && L.get("schematas")) {
          console.log(" Cleaning up existing seeded data before reseeding...");
          const S = await Pw(t, A, s);
          console.log(`[Seed] Cleanup complete: deleted ${S.deleted} co-values, ${S.errors} errors`);
        }
      }
    } catch (G) {
      console.warn("[Seed] Cleanup check failed, proceeding with seeding:", G.message);
    }
  const B = await ko(s);
  if (!B || typeof B.createMap != "function")
    throw new Error("[CoJSONSeed] @maia spark group not found. Ensure schemaMigration has created @maia spark.");
  await Ow(s, B);
  const Q = /* @__PURE__ */ new Map();
  for (const [G, L] of Object.entries(i)) {
    const v = L.$id || `@maia/schema/${G}`;
    Q.has(v) || Q.set(v, { name: G, schema: L });
  }
  const f = (G, L = /* @__PURE__ */ new Set()) => {
    const v = /* @__PURE__ */ new Set();
    if (!G || typeof G != "object" || L.has(G))
      return v;
    L.add(G), G.$co && typeof G.$co == "string" && G.$co.startsWith("@maia/schema/") && v.add(G.$co);
    for (const S of Object.values(G))
      if (S && typeof S == "object")
        if (Array.isArray(S))
          for (const M of S)
            M && typeof M == "object" && f(M, L).forEach((H) => v.add(H));
        else
          f(S, L).forEach((K) => v.add(K));
    return v;
  }, l = /* @__PURE__ */ new Map();
  for (const [G, { schema: L }] of Q) {
    const v = f(L);
    l.set(G, v);
  }
  const u = [], d = /* @__PURE__ */ new Set(), h = /* @__PURE__ */ new Set(), p = (G) => {
    if (d.has(G) || h.has(G))
      return;
    h.add(G);
    const L = l.get(G) || /* @__PURE__ */ new Set();
    for (const v of L)
      v.startsWith("@maia/schema/") && Q.has(v) && p(v);
    h.delete(G), d.add(G), u.push(G);
  };
  for (const G of Q.keys())
    G !== "@maia/schema/meta" && p(G);
  await Hr(t, A, B, s, void 0);
  let E = null;
  const w = await KA(s, kA);
  if (w) {
    const G = await nA(s, w, {
      waitForAvailable: !0,
      timeoutMs: 2e3
    });
    if (G && s.isAvailable(G)) {
      const L = s.getCurrentContent(G);
      if (L && typeof L.get == "function" && !E) {
        const v = L.get("schematas");
        if (v) {
          const S = await nA(s, v, {
            waitForAvailable: !0,
            timeoutMs: 2e3
          });
          if (S && s.isAvailable(S)) {
            const M = s.getCurrentContent(S);
            M && typeof M.get == "function" && (E = M.get("@maia/schema/meta"));
          }
        }
      }
    }
  }
  if (E) {
    const G = le(E), { $schema: L, $id: v, id: S, ...M } = G.definition || G, K = RA(M), H = await nA(s, E, {
      waitForAvailable: !0,
      timeoutMs: 2e3
    });
    if (H && s.isAvailable(H)) {
      const V = s.getCurrentContent(H);
      if (V && typeof V.set == "function")
        for (const [$, iA] of Object.entries(K))
          V.set($, iA);
    }
  } else {
    EXCEPTION_SCHEMAS.META_SCHEMA;
    const G = le("co_zTEMP"), L = {
      definition: RA(G.definition || G)
    }, { coValue: v } = await pA(
      { node: A, account: t, guardian: B },
      null,
      { schema: EXCEPTION_SCHEMAS.META_SCHEMA, cotype: "comap", data: L }
    ), S = v.id, M = le(S), { $schema: K, $id: H, id: V, ...$ } = M.definition || M, iA = RA($);
    for (const [gA, IA] of Object.entries(iA))
      v.set(gA, IA);
    E = S;
  }
  if (!c.has("@maia/schema/meta"))
    c.register("@maia/schema/meta", E);
  else {
    const G = c.get("@maia/schema/meta");
    G !== E && (console.warn(`[Seed] Metaschema already registered with different co-id: ${G}, using existing instead of ${E}`), E = G);
  }
  const y = /* @__PURE__ */ new Map(), m = /* @__PURE__ */ new Map(), k = await Promise.resolve().then(() => Fn), b = await Promise.resolve().then(() => MI), q = /* @__PURE__ */ new Map();
  if (w) {
    const G = await nA(s, w, {
      waitForAvailable: !0,
      timeoutMs: 2e3
    });
    if (G && s.isAvailable(G)) {
      const L = s.getCurrentContent(G);
      if (L && typeof L.get == "function") {
        const v = L.get("schematas");
        if (v) {
          const S = await nA(s, v, {
            waitForAvailable: !0,
            timeoutMs: 2e3
          });
          if (S && s.isAvailable(S)) {
            const M = s.getCurrentContent(S);
            if (M && typeof M.get == "function") {
              const K = M.keys && typeof M.keys == "function" ? M.keys() : Object.keys(M);
              for (const H of K) {
                const V = M.get(H);
                V && typeof V == "string" && V.startsWith("co_z") && q.set(H, V);
              }
            }
          }
        }
      }
    }
  }
  for (const G of u) {
    const { name: L, schema: v } = Q.get(G), { $schema: S, $id: M, id: K, ...H } = v, V = RA(H), $ = q.get(G);
    let iA;
    $ ? (await b.update(s, E, $, V), iA = $) : iA = (await k.create(s, E, V)).id, y.set(G, iA);
    const gA = s.getCoValue(iA);
    if (gA && s.isAvailable(gA)) {
      const IA = s.getCurrentContent(gA);
      IA && typeof IA.set == "function" && m.set(G, IA);
    }
    c.register(G, iA);
  }
  E && !y.has("@maia/schema/meta") && y.set("@maia/schema/meta", E);
  const P = /* @__PURE__ */ new Map();
  for (const G of u) {
    const { name: L, schema: v } = Q.get(G), S = y.get(G), M = m.get(G), K = g(v, y);
    K.$id = `https://maia.city/${S}`;
    const H = I(K, G, { checkSchemaReferences: !0, checkNestedCoTypes: !1 });
    if (H.length > 0) {
      const QA = `[Seed] Schema ${G} still contains @maia/schema/ references after transformation:
${H.join(`
`)}`;
      throw console.error(QA), new Error(QA);
    }
    P.set(G, K);
    const { $schema: V, $id: $, id: iA, ...gA } = K, IA = RA(gA);
    for (const [QA, fA] of Object.entries(IA))
      M.set(QA, fA);
  }
  const J = [];
  for (const G of u) {
    const { name: L } = Q.get(G), v = y.get(G), S = m.get(G);
    J.push({
      name: L,
      key: G,
      coId: v,
      coMapId: S.id
    });
  }
  await Hr(t, A, B, s, y);
  const W = /* @__PURE__ */ new Map();
  let z = await (async () => {
    const G = /* @__PURE__ */ new Map(), L = await KA(s, kA);
    if (L) {
      const v = A.getCoValue(L);
      if (v && v.type === "comap") {
        const S = v.getCurrentContent?.();
        if (S && typeof S.get == "function") {
          const M = S.get("schematas");
          if (M) {
            const K = A.getCoValue(M);
            if (K && K.type === "comap") {
              const H = K.getCurrentContent?.();
              if (H && typeof H.get == "function") {
                const V = H.keys();
                for (const $ of V) {
                  const iA = H.get($);
                  iA && typeof iA == "string" && iA.startsWith("co_z") && G.set($, iA);
                }
                G.size > 0;
              }
            }
          }
        }
      }
    }
    if (G.size === 0) {
      for (const [v, S] of y.entries())
        G.set(v, S);
      E && G.set("@maia/schema/meta", E);
    }
    return G;
  })();
  if (o)
    for (const [G] of Object.entries(o)) {
      const L = `@maia/schema/${G}`, v = `@maia/schema/data/${G}`, S = z.get(v);
      S && (z.set(L, S), c.register(L, S));
    }
  let _ = { configs: [], count: 0 };
  const O = ["actor", "context", "view", "state", "brand", "style", "inbox", "subscribers"], Z = ["states"], T = (G, L) => {
    if (!G || typeof G != "object")
      return G;
    const v = JSON.parse(JSON.stringify(G));
    if (v.$schema && v.$schema.startsWith("@maia/schema/")) {
      const S = L.get(v.$schema);
      S && (v.$schema = S);
    }
    for (const S of O)
      delete v[S];
    for (const S of Z)
      S === "states" && v.initial ? v.states = Object.fromEntries(
        Object.keys(v.states || {}).map((M) => [M, {}])
      ) : delete v[S];
    return v;
  }, F = () => {
    const G = new Map(z);
    for (const [L, v] of W.entries())
      v && typeof v == "string" && v.startsWith("co_z") && G.set(L, v);
    for (const [L, v] of c.getAll())
      v && typeof v == "string" && v.startsWith("co_z") && G.set(L, v);
    return G;
  }, x = async (G, L, v) => {
    if (!L || typeof L != "object")
      return { configs: [], count: 0 };
    const S = {};
    for (const [H, V] of Object.entries(L))
      S[H] = T(V, z);
    const M = { [G]: S }, K = await ys(t, A, B, s, M, W, m, y);
    for (const H of K.configs || []) {
      const V = H.coId, $ = H.path, iA = H.expectedCoId;
      W.set($, V), iA && (W.set(iA, V), z.set(iA, V), c.register(iA, V)), c.register($, V);
    }
    return K;
  };
  if (e) {
    const G = await x("styles", e.styles);
    _.configs.push(...G.configs || []), _.count += G.count || 0, z = F();
    const L = await x("actors", e.actors);
    _.configs.push(...L.configs || []), _.count += L.count || 0, z = F();
    const v = await x("views", e.views);
    _.configs.push(...v.configs || []), _.count += v.count || 0, z = F();
    const S = await x("contexts", e.contexts);
    _.configs.push(...S.configs || []), _.count += S.count || 0, z = F();
    const M = await x("states", e.states);
    _.configs.push(...M.configs || []), _.count += M.count || 0, z = F();
    const K = await x("interfaces", e.interfaces);
    _.configs.push(...K.configs || []), _.count += K.count || 0, z = F();
    const H = await x("subscriptions", e.subscriptions);
    _.configs.push(...H.configs || []), _.count += H.count || 0, z = F();
    const V = await x("inboxes", e.inboxes);
    _.configs.push(...V.configs || []), _.count += V.count || 0, z = F();
    const $ = await x("children", e.children);
    _.configs.push(...$.configs || []), _.count += $.count || 0, z = F();
    const iA = await x("tool", e.tool);
    _.configs.push(...iA.configs || []), _.count += iA.count || 0, z = F();
  }
  const R = async (G, L) => {
    if (!G || !L)
      return 0;
    const v = F();
    let S = 0;
    for (const M of G) {
      M.coId;
      const K = M.expectedCoId, H = K && L ? Object.values(L).find((gA) => gA.$id === K) : null;
      if (!H)
        continue;
      const V = g(H, v), $ = M.coMap, iA = M.cotype || "comap";
      if (iA === "colist") {
        if ($ && typeof $.append == "function") {
          const gA = V.items || [];
          for (const IA of gA)
            $.append(IA);
          S++;
        }
      } else if (iA === "costream") {
        if ($ && typeof $.push == "function") {
          const gA = V.items || [];
          for (const IA of gA)
            $.push(IA);
          S++;
        }
      } else if ($ && typeof $.set == "function") {
        const { $id: gA, $schema: IA, ...QA } = V;
        QA.states && QA.states;
        for (const [fA, Ce] of Object.entries(QA))
          $.set(fA, Ce);
        S++;
      }
    }
    return S;
  };
  if (e) {
    const G = _.configs.filter(($) => $.type === "subscription");
    await R(G, e.subscriptions);
    const L = _.configs.filter(($) => $.type === "inbox");
    await R(L, e.inboxes);
    const v = _.configs.filter(($) => $.type === "children");
    await R(v, e.children), F();
    const S = _.configs.filter(($) => $.type === "actor");
    await R(S, e.actors);
    const M = _.configs.filter(($) => $.type === "view");
    await R(M, e.views);
    const K = _.configs.filter(($) => $.type === "context");
    await R(K, e.contexts);
    const H = _.configs.filter(($) => $.type === "state");
    await R(H, e.states);
    const V = _.configs.filter(($) => $.type === "interface");
    await R(V, e.interfaces);
  }
  const D = e?.vibes || [];
  if (D.length > 0) {
    z = F();
    let G = await So(s, kA), L;
    if (G) {
      const v = A.getCoValue(G);
      if (v && v.type === "comap") {
        const S = v.getCurrentContent?.();
        S && typeof S.set == "function" && (L = S);
      }
    }
    if (!L) {
      const v = y?.get("@maia/schema/os/vibes-registry") ?? await (await Promise.resolve().then(() => un)).resolve(s, "@maia/schema/os/vibes-registry", { returnType: "coId" }), S = { node: A, account: t, guardian: B }, { coValue: M } = await pA(S, null, {
        schema: v || EXCEPTION_SCHEMAS.META_SCHEMA,
        cotype: "comap",
        data: {},
        dbEngine: s?.dbEngine
      });
      L = M, await QI(s, kA, L.id);
    }
    for (const v of D) {
      const S = v.actor;
      if (S && !S.startsWith("co_z") && !z.get(S)) {
        const gA = Array.from(z.keys()).filter((IA) => IA.startsWith("@actor/")).slice(0, 10).join(", ");
        console.warn(`[CoJSONSeed] Actor reference ${S} not found in registry for vibe ${v.$id || v.name}. Available actor keys (first 10): ${gA}`);
      }
      const M = g(v, z);
      M.actor && !M.actor.startsWith("co_z") && (console.error(`[CoJSONSeed]  Vibe actor transformation failed! Expected co-id, got: ${M.actor}`), console.error(`[CoJSONSeed] Original actor: ${v.actor}, Registry has: ${z.has(v.actor)}`));
      const K = v.$id || "", H = K.startsWith("@maia/vibe/") ? K.replace("@maia/vibe/", "") : (v.name || "default").toLowerCase().replace(/\s+/g, "-"), $ = await ys(t, A, B, s, { vibe: M }, W, m, y);
      if (_.configs.push(...$.configs || []), _.count += $.count || 0, $.configs && $.configs.length > 0) {
        const gA = $.configs[0].coId;
        if (L && typeof L.set == "function") {
          L.set(H, gA);
          const QA = L.get(H);
          QA !== gA && console.warn(`[CoJSONSeed] Vibe ${H} storage verification failed! Expected ${gA}, got ${QA}`);
        } else
          console.error(`[CoJSONSeed]  Cannot store vibe ${H}: vibes CoMap not available`);
        const IA = v.$id;
        IA && (W.set(IA, gA), z.set(IA, gA), c.register(IA, gA));
      }
    }
    if (L && typeof L.get == "function")
      for (const v of D) {
        const S = v.$id || "", M = S.startsWith("@maia/vibe/") ? S.replace("@maia/vibe/", "") : (v.name || "default").toLowerCase().replace(/\s+/g, "-");
        L.get(M) || console.error(`[CoJSONSeed] Missing: ${M} not found in account.vibes!`);
      }
  }
  const N = await Vw(t, A, B, s, o, c);
  await SI(t, A, B, s, c, y);
  const { indexCoValue: Y } = await Promise.resolve().then(() => DI), j = [
    ...(_.configs || []).map((G) => G.coId).filter(Boolean),
    ...N.coIds || []
  ];
  for (const G of j)
    if (G && typeof G == "string" && G.startsWith("co_z"))
      try {
        await Y(s, G);
      } catch (L) {
        console.warn(`[Seed] Index pass failed for ${G.substring(0, 12)}...:`, L.message);
      }
  return {
    metaSchema: E,
    schemas: J,
    configs: _,
    data: N,
    registry: c.getAll()
  };
}
async function mI(t, A, e) {
  if (!t.get("sparks") || !String(t.get("sparks")).startsWith("co_z"))
    return await Lw(t, A), { metaSchema: null, schemas: {}, registry: {} };
  const i = await ko(e), { getAllSchemas: o } = await Promise.resolve().then(() => jt), r = o(), { CoIdRegistry: n } = await Promise.resolve().then(() => rI), { transformForSeeding: s, validateSchemaStructure: a } = await Promise.resolve().then(() => wn), g = new n(), I = /* @__PURE__ */ new Map();
  for (const [k, b] of Object.entries(r)) {
    const q = b.$id || `@maia/schema/${k}`;
    I.has(q) || I.set(q, { name: k, schema: b });
  }
  const c = (k, b = /* @__PURE__ */ new Set()) => {
    if (!k || typeof k != "object" || b.has(k)) return /* @__PURE__ */ new Set();
    b.add(k);
    const q = /* @__PURE__ */ new Set();
    k.$co && typeof k.$co == "string" && k.$co.startsWith("@maia/schema/") && q.add(k.$co);
    for (const P of Object.values(k))
      P && typeof P == "object" && (Array.isArray(P) ? P : [P]).forEach((J) => {
        J && typeof J == "object" && c(J, b).forEach((W) => q.add(W));
      });
    return q;
  }, C = /* @__PURE__ */ new Map();
  for (const [k, { schema: b }] of I) C.set(k, c(b));
  const B = [], Q = /* @__PURE__ */ new Set(), f = /* @__PURE__ */ new Set(), l = (k) => {
    if (!Q.has(k) && !f.has(k)) {
      f.add(k);
      for (const b of C.get(k) || /* @__PURE__ */ new Set())
        b.startsWith("@maia/schema/") && I.has(b) && l(b);
      f.delete(k), Q.add(k), B.push(k);
    }
  };
  for (const k of I.keys())
    k !== "@maia/schema/meta" && l(k);
  await Hr(t, A, i, e);
  const u = await KA(e, kA);
  let d = null;
  if (u) {
    const k = await nA(e, u, { waitForAvailable: !0, timeoutMs: 2e3 });
    if (k && e.isAvailable(k)) {
      const b = e.getCurrentContent(k);
      if (b?.get) {
        const q = b.get("schematas");
        if (q) {
          const P = await nA(e, q, { waitForAvailable: !0, timeoutMs: 2e3 });
          if (P && e.isAvailable(P)) {
            const J = e.getCurrentContent(P);
            J?.get && (d = J.get("@maia/schema/meta"));
          }
        }
      }
    }
  }
  if (d) {
    const k = le(d), { $schema: b, $id: q, id: P, ...J } = k.definition || k, W = await nA(e, d, { waitForAvailable: !0, timeoutMs: 2e3 });
    if (W && e.isAvailable(W)) {
      const X = e.getCurrentContent(W);
      if (X?.set) for (const [z, _] of Object.entries(RA(J))) X.set(z, _);
    }
  } else {
    const k = le("co_zTEMP"), b = { definition: RA(k.definition || k) }, q = { node: A, account: t, guardian: i }, { coValue: P } = await pA(q, null, {
      schema: EXCEPTION_SCHEMAS.META_SCHEMA,
      cotype: "comap",
      data: b
    }), J = P.id, W = le(J), { $schema: X, $id: z, id: _, ...O } = W.definition || W;
    for (const [Z, T] of Object.entries(RA(O))) P.set(Z, T);
    d = J;
  }
  g.register("@maia/schema/meta", d);
  const h = /* @__PURE__ */ new Map(), p = /* @__PURE__ */ new Map(), E = await Promise.resolve().then(() => Fn), w = await Promise.resolve().then(() => MI), y = /* @__PURE__ */ new Map();
  if (u) {
    const k = await nA(e, u, { waitForAvailable: !0, timeoutMs: 2e3 });
    if (k && e.isAvailable(k)) {
      const q = e.getCurrentContent(k)?.get?.("schematas");
      if (q) {
        const P = await nA(e, q, { waitForAvailable: !0, timeoutMs: 2e3 });
        if (P && e.isAvailable(P)) {
          const J = e.getCurrentContent(P);
          if (J?.get)
            for (const W of J.keys?.() || Object.keys(J)) {
              const X = J.get(W);
              X?.startsWith?.("co_z") && y.set(W, X);
            }
        }
      }
    }
  }
  for (const k of B) {
    const { name: b, schema: q } = I.get(k), { $schema: P, $id: J, id: W, ...X } = q, z = RA(X), _ = y.get(k);
    let O;
    _ ? (await w.update(e, d, _, z), O = _) : O = (await E.create(e, d, z)).id, h.set(k, O);
    const Z = e.getCoValue(O);
    if (Z && e.isAvailable(Z)) {
      const T = e.getCurrentContent(Z);
      T?.set && p.set(k, T);
    }
    g.register(k, O);
  }
  d && !h.has("@maia/schema/meta") && h.set("@maia/schema/meta", d);
  for (const k of B) {
    const { name: b, schema: q } = I.get(k), P = h.get(k), J = p.get(k), W = s(q, h);
    W.$id = `https://maia.city/${P}`;
    const X = a(W, k, { checkSchemaReferences: !0, checkNestedCoTypes: !1 });
    if (X.length > 0) throw new Error(`[Seed] Schema ${k} contains @maia/schema/ refs: ${X.join(", ")}`);
    const { $schema: z, $id: _, id: O, ...Z } = W;
    if (J?.set) for (const [T, F] of Object.entries(RA(Z))) J.set(T, F);
  }
  const m = B.map((k) => {
    const { name: b } = I.get(k);
    return { name: b, key: k, coId: h.get(k), coMapId: p.get(k)?.id };
  });
  return await SI(t, A, i, e, g, h), console.log(`[Seed] Agent account seeded: ${m.length} schemas`), { metaSchema: d, schemas: m, registry: g.getAll() };
}
async function ys(t, A, e, i, o, r, n, s) {
  const a = [];
  let g = 0;
  const I = async (C, B, Q) => {
    const f = C.$schema;
    if (!f || !f.startsWith("co_z"))
      throw new Error(`[CoJSONSeed] Config ${B}:${Q} has invalid $schema: ${f}`);
    let l = "comap", u = null;
    for (const [k, b] of s.entries())
      if (b === f) {
        u = n.get(k);
        break;
      }
    if (!u) {
      const k = A.getCoValue(f);
      k && k.type === "comap" && (u = k.getCurrentContent?.());
    }
    u && typeof u.get == "function" ? l = u.get("cotype") || "comap" : console.warn(`     Cannot read schema CoMap for ${f ? f.substring(0, 12) : "undefined"}... (config: ${Q}), schemaCoMap type: ${typeof u}`);
    const { $id: d, $schema: h, ...p } = C, E = { node: A, account: t, guardian: e }, w = l === "colist" ? [] : l === "costream" ? void 0 : p, { coValue: y } = await pA(E, null, {
      schema: f,
      cotype: l,
      data: w,
      dbEngine: i?.dbEngine
    }), m = y.id;
    return d && (r.set(Q, m), r.set(d, m)), {
      type: B,
      path: Q,
      coId: m,
      expectedCoId: d || void 0,
      // Use $id from config (line 899), or undefined if not present
      coMapId: m,
      coMap: y,
      // Store the actual CoValue reference (CoMap, CoList, or CoStream)
      cotype: l
      // Store the type for reference
    };
  };
  if (o.vibe) {
    const C = await I(o.vibe, "vibe", "vibe");
    a.push(C), g++;
  }
  const c = async (C, B) => {
    if (!B || typeof B != "object")
      return 0;
    let Q = 0;
    for (const [f, l] of Object.entries(B))
      if (l && typeof l == "object" && l.$schema) {
        const u = await I(l, C, f);
        a.push(u), Q++;
      }
    return Q;
  };
  return g += await c("style", o.styles), g += await c("actor", o.actors), g += await c("view", o.views), g += await c("context", o.contexts), g += await c("state", o.states), g += await c("interface", o.interfaces), g += await c("subscription", o.subscriptions), g += await c("inbox", o.inboxes), g += await c("children", o.children), {
    count: g,
    types: [...new Set(a.map((C) => C.type))],
    configs: a
  };
}
async function Vw(t, A, e, i, o, r) {
  const { transformForSeeding: n } = await Promise.resolve().then(() => wn);
  if (!o || Object.keys(o).length === 0)
    return {
      collections: [],
      totalItems: 0,
      coIds: []
    };
  const s = [];
  let a = 0;
  for (const [I, c] of Object.entries(o)) {
    if (!Array.isArray(c)) {
      console.warn(`[CoJSONSeed] Skipping ${I}: not an array`);
      continue;
    }
    const C = `data/${I}`, B = `@maia/schema/data/${I}`, Q = `@maia/schema/${I}`, f = r.registry.get(C) || r.registry.get(B) || r.registry.get(Q);
    if (!f) {
      console.warn(`[CoJSONSeed] No schema found for collection ${I} (tried: ${C}, ${B}, ${Q}), skipping`);
      continue;
    }
    let l = 0;
    const u = [];
    for (const d of c) {
      const h = n(d, r.getAll()), { $id: p, ...E } = h, w = { node: A, account: t, guardian: e }, { coValue: y } = await pA(w, null, {
        schema: f,
        cotype: "comap",
        data: E,
        dbEngine: i?.dbEngine
      });
      u.push(y.id), l++;
    }
    s.push({
      name: I,
      schemaCoId: f,
      itemCount: l,
      coIds: u
    }), a += l;
  }
  const g = s.flatMap((I) => I.coIds || []);
  return {
    collections: s,
    totalItems: a,
    coIds: g
  };
}
async function Hr(t, A, e, i, o) {
  const r = await KA(i, kA);
  if (!r)
    throw new Error("[Seed] @maia spark.os not found. Ensure schemaMigration or bootstrap has run.");
  const { resolve: n } = await Promise.resolve().then(() => un), s = o?.get("@maia/schema/os/schematas-registry") ?? await n(i, "@maia/schema/os/schematas-registry", { returnType: "coId" }), a = o?.get("@maia/schema/os/vibes-registry") ?? await n(i, "@maia/schema/os/vibes-registry", { returnType: "coId" });
  s || EXCEPTION_SCHEMAS.META_SCHEMA, a || EXCEPTION_SCHEMAS.META_SCHEMA;
  let g = A.getCoValue(r);
  if (!g && A.loadCoValueCore && (await A.loadCoValueCore(r), g = A.getCoValue(r)), (!g || !g.isAvailable()) && (await new Promise((c) => {
    let C;
    const B = setTimeout(c, 5e3);
    g ? C = g.subscribe((Q) => {
      Q?.isAvailable?.() && (clearTimeout(B), C?.(), c());
    }) : c();
  }), g = A.getCoValue(r)), g && g.isAvailable()) {
    const c = g.getCurrentContent?.();
    if (c && typeof c.get == "function") {
      if (!c.get("schematas")) {
        const Q = { node: A, account: t, guardian: e }, { coValue: f } = await pA(Q, null, {
          schema: s || EXCEPTION_SCHEMAS.META_SCHEMA,
          cotype: "comap",
          data: {},
          dbEngine: i?.dbEngine
        });
        if (c.set("schematas", f.id), A.storage?.syncManager)
          try {
            await A.syncManager.waitForStorageSync(f.id), await A.syncManager.waitForStorageSync(r);
          } catch (l) {
            console.warn("[Seed] Storage sync wait failed for spark.os.schematas:", l);
          }
      }
      !c.get("indexes") && i && await No(i);
    }
  }
  if (!await So(i, kA) && o) {
    const c = i.account?.get("sparks");
    if (c?.startsWith("co_z")) {
      const C = await i.read(null, c);
      await new Promise((f, l) => {
        if (!C.loading) return f();
        const u = setTimeout(() => l(new Error("Timeout")), 1e4), d = C.subscribe(() => {
          C.loading || (clearTimeout(u), d?.(), f());
        });
      });
      const Q = C?.value?.[kA];
      if (Q?.startsWith("co_z")) {
        const f = i.getCoValue(Q);
        if (f && i.isAvailable(f)) {
          const l = i.getCurrentContent(f);
          if (l && typeof l.set == "function") {
            const u = { node: A, account: t, guardian: e }, { coValue: d } = await pA(u, null, {
              schema: a || EXCEPTION_SCHEMAS.META_SCHEMA,
              cotype: "comap",
              data: {},
              dbEngine: i?.dbEngine
            });
            l.set("vibes", d.id);
          }
        }
      }
    }
  }
}
async function SI(t, A, e, i, o, r, n, s, a) {
  const g = await KA(i, kA);
  if (!g) {
    console.warn("[Seed] spark.os not found - should have been created in Phase 0");
    return;
  }
  let I = A.getCoValue(g);
  if (!I && A.loadCoValueCore && (await A.loadCoValueCore(g), I = A.getCoValue(g)), !I || !I.isAvailable()) {
    console.warn(`[Seed] account.os (${g ? g.substring(0, 12) : "undefined"}...) not available`);
    return;
  }
  const c = I.getCurrentContent?.();
  if (!c || typeof c.get != "function") {
    console.warn("[Seed] account.os content not available");
    return;
  }
  let C = c.get("schematas"), B;
  if (C) {
    const f = A.getCoValue(C);
    if (f && f.isAvailable()) {
      const l = f.getCurrentContent?.();
      l && typeof l.set == "function" && (B = l);
    }
  }
  if (!B) {
    let f = null;
    r && r.has("@maia/schema/os/schematas-registry") && (f = r.get("@maia/schema/os/schematas-registry"));
    const l = f || EXCEPTION_SCHEMAS.META_SCHEMA, u = { node: A, account: t, guardian: e }, { coValue: d } = await pA(u, null, {
      schema: l,
      cotype: "comap",
      data: {},
      dbEngine: i?.dbEngine
    });
    if (B = d, c.set("schematas", B.id), A.storage && A.syncManager)
      try {
        await A.syncManager.waitForStorageSync(B.id), await A.syncManager.waitForStorageSync(g);
      } catch (h) {
        console.warn("[Seed] Storage sync wait failed for account.os.schematas:", h);
      }
  }
  const Q = o.get("@maia/schema/meta");
  if (Q) {
    const f = B.get("@maia/schema/meta");
    f ? f !== Q && console.warn(`[Seed] Metaschema already registered with different co-id: ${f ? f.substring(0, 12) : "undefined"}... (new: ${Q ? Q.substring(0, 12) : "undefined"}...). Skipping.`) : B.set("@maia/schema/meta", Q);
  }
}
const $w = [
  "coValues",
  "sessions",
  "transactions",
  "signatureAfter",
  "deletedCoValues"
];
class Ww {
  constructor(A, e = $w) {
    this.db = A, this.storeNames = e, this.pendingRequests = [], this.rejectHandlers = [], this.id = Math.random(), this.running = !1, this.failed = !1, this.done = !1, this.refresh();
  }
  refresh() {
    this.tx = this.db.transaction(this.storeNames, "readwrite"), this.tx.oncomplete = () => {
      this.done = !0;
    }, this.tx.onabort = () => {
      this.done = !0;
    };
  }
  rollback() {
    this.tx.abort();
  }
  getObjectStore(A) {
    try {
      return this.tx.objectStore(A);
    } catch {
      return this.refresh(), this.tx.objectStore(A);
    }
  }
  pushRequest(A) {
    const e = () => {
      const i = this.pendingRequests.shift();
      i ? i(this) : (this.running = !1, this.done = !0);
    };
    return this.running ? new Promise((i, o) => {
      this.rejectHandlers.push(o), this.pendingRequests.push(async () => {
        try {
          const r = await A(this, e);
          i(r);
        } catch (r) {
          o(r);
        }
      });
    }) : (this.running = !0, A(this, e));
  }
  handleRequest(A) {
    return this.pushRequest((e, i) => new Promise((o, r) => {
      const n = A(e);
      n.onerror = () => {
        this.failed = !0, this.tx.abort(), console.error(n.error), r(n.error);
        for (const s of this.rejectHandlers)
          s();
      }, n.onsuccess = () => {
        o(n.result), i();
      };
    }));
  }
  commit() {
    this.done || this.tx.commit();
  }
}
function Le(t, A, e) {
  return new Promise((i, o) => {
    const r = t.transaction(A, "readonly"), n = e(r.objectStore(A));
    n.onerror = () => {
      o(n.error);
    }, n.onsuccess = () => {
      i(n.result), r.commit();
    };
  });
}
function zw(t, A, e) {
  return new Promise((i, o) => {
    const r = t.transaction(A, "readwrite"), n = r.objectStore(A).put(e);
    n.onerror = () => {
      o(n.error);
    }, n.onsuccess = () => {
      i(n.result), r.commit();
    };
  });
}
var Ds = function(t, A, e, i) {
  if (e === "a" && !i) throw new TypeError("Private accessor was defined without a getter");
  if (typeof A == "function" ? t !== A || !i : !A.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return e === "m" ? i : e === "a" ? i.call(t) : i ? i.value : A.get(t);
}, no, qr;
class _w {
  constructor(A) {
    no.add(this), this.tx = A;
  }
  async run(A) {
    return this.tx.handleRequest(A);
  }
  async getSingleCoValueSession(A, e) {
    return this.run((i) => i.getObjectStore("sessions").index("uniqueSessions").get([A, e]));
  }
  async markCoValueAsDeleted(A) {
    await this.run((e) => e.getObjectStore("deletedCoValues").put({
      coValueID: A,
      status: "pending"
    }));
  }
  async deleteCoValueContent(A) {
    const e = A.rowID, o = (await this.run((n) => n.getObjectStore("sessions").index("sessionsByCoValue").getAll(e))).filter((n) => !n.sessionID.endsWith("$")).map((n) => n.rowID), r = [];
    for (const n of o)
      r.push(Ds(this, no, "m", qr).call(this, "transactions", n), Ds(this, no, "m", qr).call(this, "signatureAfter", n), this.run((s) => s.getObjectStore("sessions").delete(n)));
    r.push(this.run((n) => n.getObjectStore("deletedCoValues").put({
      coValueID: A.id,
      status: "done"
    }))), await Promise.all(r);
  }
  async addSessionUpdate({ sessionUpdate: A, sessionRow: e }) {
    return this.run((i) => i.getObjectStore("sessions").put(e?.rowID ? {
      rowID: e.rowID,
      ...A
    } : A));
  }
  async addTransaction(A, e, i) {
    await this.run((o) => o.getObjectStore("transactions").add({
      ses: A,
      idx: e,
      tx: i
    }));
  }
  async addSignatureAfter({ sessionRowID: A, idx: e, signature: i }) {
    return this.run((o) => o.getObjectStore("signatureAfter").put({
      ses: A,
      idx: e,
      signature: i
    }));
  }
  /**
   * Get an unsynced CoValue record by coValueId and peerId.
   */
  async getUnsyncedCoValueRecord(A, e) {
    return this.run((i) => i.getObjectStore("unsyncedCoValues").index("uniqueUnsyncedCoValues").get([A, e]));
  }
  /**
   * Get all unsynced CoValue records for a given coValueId.
   */
  async getAllUnsyncedCoValueRecords(A) {
    return this.run((e) => e.getObjectStore("unsyncedCoValues").index("byCoValueId").getAll(A));
  }
  /**
   * Delete an unsynced CoValue record by rowID.
   */
  async deleteUnsyncedCoValueRecord(A) {
    await this.run((e) => e.getObjectStore("unsyncedCoValues").delete(A));
  }
  /**
   * Insert or update an unsynced CoValue record.
   */
  async putUnsyncedCoValueRecord(A) {
    await this.run((e) => e.getObjectStore("unsyncedCoValues").put(A));
  }
}
no = /* @__PURE__ */ new WeakSet(), qr = async function(A, e) {
  const i = IDBKeyRange.bound([e, 0], [e, Number.POSITIVE_INFINITY]), o = await this.run((r) => r.getObjectStore(A).getAllKeys(i));
  for (const r of o)
    await this.run((n) => n.getObjectStore(A).delete(r));
};
class Zw {
  constructor(A) {
    this.db = A;
  }
  async getCoValue(A) {
    return Le(this.db, "coValues", (e) => e.index("coValuesById").get(A));
  }
  async getCoValueRowID(A) {
    return this.getCoValue(A).then((e) => e?.rowID);
  }
  async getCoValueSessions(A) {
    return Le(this.db, "sessions", (e) => e.index("sessionsByCoValue").getAll(A));
  }
  async getNewTransactionInSession(A, e, i) {
    return Le(this.db, "transactions", (o) => o.getAll(IDBKeyRange.bound([A, e], [A, i])));
  }
  async getSignatures(A, e) {
    return Le(this.db, "signatureAfter", (i) => i.getAll(IDBKeyRange.bound([A, e], [A, Number.POSITIVE_INFINITY])));
  }
  async upsertCoValue(A, e) {
    return e ? zw(this.db, "coValues", {
      id: A,
      header: e
    }).catch(() => this.getCoValueRowID(A)) : this.getCoValueRowID(A);
  }
  async getAllCoValuesWaitingForDelete() {
    return (await Le(this.db, "deletedCoValues", (e) => e.index("deletedCoValuesByStatus").getAll("pending"))).map((e) => e.coValueID);
  }
  async transaction(A, e) {
    const i = new Ww(this.db, e);
    try {
      await A(new _w(i)), i.commit();
    } catch {
      i.rollback();
    }
  }
  async trackCoValuesSyncState(A) {
    A.length !== 0 && await this.transaction(async (e) => {
      await Promise.all(A.map(async (i) => {
        const o = await e.getUnsyncedCoValueRecord(i.id, i.peerId);
        i.synced ? o && await e.deleteUnsyncedCoValueRecord(o.rowID) : await e.putUnsyncedCoValueRecord(o ? {
          rowID: o.rowID,
          coValueId: i.id,
          peerId: i.peerId
        } : {
          coValueId: i.id,
          peerId: i.peerId
        });
      }));
    }, ["unsyncedCoValues"]);
  }
  async eraseCoValueButKeepTombstone(A) {
    const e = await this.getCoValue(A);
    if (!e) {
      console.warn(`CoValue ${A} not found, skipping deletion`);
      return;
    }
    await this.transaction((i) => i.deleteCoValueContent(e));
  }
  async getUnsyncedCoValueIDs() {
    const A = await Le(this.db, "unsyncedCoValues", (i) => i.getAll()), e = /* @__PURE__ */ new Set();
    for (const i of A)
      e.add(i.coValueId);
    return Array.from(e);
  }
  async stopTrackingSyncState(A) {
    await this.transaction(async (e) => {
      const i = e, o = await i.getAllUnsyncedCoValueRecords(A);
      await Promise.all(o.map((r) => i.deleteUnsyncedCoValueRecord(r.rowID)));
    }, ["unsyncedCoValues"]);
  }
  async getCoValueKnownState(A) {
    const e = await this.getCoValue(A);
    if (!e)
      return;
    const i = await this.getCoValueSessions(e.rowID), o = {
      id: A,
      header: !0,
      sessions: {}
    };
    for (const r of i)
      o.sessions[r.sessionID] = r.lastIdx;
    return o;
  }
}
let Xw = "jazz-storage";
async function Ay(t = Xw) {
  const e = await new Promise((i, o) => {
    const r = indexedDB.open(t, 6);
    r.onerror = () => {
      o(r.error);
    }, r.onsuccess = () => {
      i(r.result);
    }, r.onupgradeneeded = async (n) => {
      const s = r.result;
      if (n.oldVersion === 0) {
        s.createObjectStore("coValues", {
          autoIncrement: !0,
          keyPath: "rowID"
        }).createIndex("coValuesById", "id", {
          unique: !0
        });
        const g = s.createObjectStore("sessions", {
          autoIncrement: !0,
          keyPath: "rowID"
        });
        g.createIndex("sessionsByCoValue", "coValue"), g.createIndex("uniqueSessions", ["coValue", "sessionID"], {
          unique: !0
        }), s.createObjectStore("transactions", {
          keyPath: ["ses", "idx"]
        });
      }
      if (n.oldVersion <= 1 && s.createObjectStore("signatureAfter", {
        keyPath: ["ses", "idx"]
      }), n.oldVersion <= 4) {
        const a = s.createObjectStore("unsyncedCoValues", {
          autoIncrement: !0,
          keyPath: "rowID"
        });
        a.createIndex("byCoValueId", "coValueId"), a.createIndex("uniqueUnsyncedCoValues", ["coValueId", "peerId"], {
          unique: !0
        });
      }
      n.oldVersion <= 5 && s.createObjectStore("deletedCoValues", {
        keyPath: "coValueID"
      }).createIndex("deletedCoValuesByStatus", "status", {
        unique: !1
      });
    };
  });
  return new Hg(new Zw(e));
}
async function ey() {
  try {
    return await Ay();
  } catch (t) {
    console.warn("  [STORAGE] IndexedDB unavailable, running without persistence:", t), console.warn("   This may happen in incognito mode or unsupported browsers");
    return;
  }
}
const ms = {
  1: [
    `CREATE TABLE IF NOT EXISTS transactions (
      ses INTEGER,
      idx INTEGER,
      tx TEXT NOT NULL,
      PRIMARY KEY (ses, idx)
    );`,
    `CREATE TABLE IF NOT EXISTS sessions (
      "rowID" SERIAL PRIMARY KEY,
      "coValue" INTEGER NOT NULL,
      "sessionID" TEXT NOT NULL,
      "lastIdx" INTEGER,
      "lastSignature" TEXT,
      UNIQUE ("sessionID", "coValue")
    );`,
    'CREATE INDEX IF NOT EXISTS sessionsByCoValue ON sessions ("coValue");',
    `CREATE TABLE IF NOT EXISTS coValues (
      "rowID" SERIAL PRIMARY KEY,
      id TEXT NOT NULL UNIQUE,
      header TEXT NOT NULL
    );`,
    "CREATE INDEX IF NOT EXISTS coValuesByID ON coValues (id);"
  ],
  3: [
    `CREATE TABLE IF NOT EXISTS signatureAfter (
      ses INTEGER,
      idx INTEGER,
      signature TEXT NOT NULL,
      PRIMARY KEY (ses, idx)
    );`,
    'ALTER TABLE sessions ADD COLUMN IF NOT EXISTS "bytesSinceLastSignature" INTEGER;'
  ],
  4: [
    `CREATE TABLE IF NOT EXISTS unsynced_covalues (
      "rowID" SERIAL PRIMARY KEY,
      "co_value_id" TEXT NOT NULL,
      "peer_id" TEXT NOT NULL,
      UNIQUE ("co_value_id", "peer_id")
    );`,
    'CREATE INDEX IF NOT EXISTS idx_unsynced_covalues_co_value_id ON unsynced_covalues("co_value_id");'
  ],
  5: [
    `CREATE TABLE IF NOT EXISTS deletedCoValues (
      "coValueID" TEXT PRIMARY KEY,
      status INTEGER NOT NULL DEFAULT 0
    );`,
    "CREATE INDEX IF NOT EXISTS deletedCoValuesByStatus ON deletedCoValues (status);"
  ]
};
async function ty(t) {
  try {
    return (await t.query("SELECT version FROM schema_version ORDER BY version DESC LIMIT 1")).rows[0]?.version || 0;
  } catch {
    return 0;
  }
}
async function iy(t, A) {
  await t.exec(`
    CREATE TABLE IF NOT EXISTS schema_version (
      version INTEGER PRIMARY KEY,
      applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
    INSERT INTO schema_version (version) VALUES (${A})
    ON CONFLICT (version) DO NOTHING;
  `);
}
async function oy(t) {
  const A = await ty(t), e = Object.keys(ms).map((i) => parseInt(i, 10)).filter((i) => i > A).sort((i, o) => i - o);
  for (const i of e) {
    const o = ms[i];
    for (const r of o)
      await t.exec(r);
    await iy(t, i);
  }
}
class ry {
  constructor(A) {
    this.db = A;
  }
  async getSingleCoValueSession(A, e) {
    const o = (await this.db.query(
      'SELECT * FROM sessions WHERE "coValue" = $1 AND "sessionID" = $2',
      [A, e]
    )).rows[0];
    if (o)
      return {
        rowID: o.rowID || o.rowid,
        coValue: o.coValue || o.covalue,
        sessionID: o.sessionID || o.sessionid,
        lastIdx: o.lastIdx || o.lastidx,
        lastSignature: o.lastSignature || o.lastsignature,
        bytesSinceLastSignature: o.bytesSinceLastSignature || o.bytessincelastsignature
      };
  }
  async markCoValueAsDeleted(A) {
    await this.db.query(
      "INSERT INTO deletedCoValues (coValueID, status) VALUES ($1, $2) ON CONFLICT (coValueID) DO NOTHING",
      [A, Ut.Pending]
    );
  }
  async addSessionUpdate({ sessionUpdate: A, sessionRow: e }) {
    if (e)
      return (await this.db.query(
        `UPDATE sessions 
         SET "lastIdx" = $1, "lastSignature" = $2, "bytesSinceLastSignature" = $3
         WHERE "rowID" = $4
         RETURNING "rowID"`,
        [
          A.lastIdx,
          A.lastSignature,
          A.bytesSinceLastSignature,
          e.rowID
        ]
      )).rows[0]?.rowID || e.rowID;
    {
      const i = await this.db.query(
        `INSERT INTO sessions ("coValue", "sessionID", "lastIdx", "lastSignature", "bytesSinceLastSignature") 
         VALUES ($1, $2, $3, $4, $5)
         ON CONFLICT ("sessionID", "coValue") 
         DO UPDATE SET "lastIdx" = EXCLUDED."lastIdx", "lastSignature" = EXCLUDED."lastSignature", "bytesSinceLastSignature" = EXCLUDED."bytesSinceLastSignature"
         RETURNING "rowID"`,
        [
          A.coValue,
          A.sessionID,
          A.lastIdx,
          A.lastSignature,
          A.bytesSinceLastSignature
        ]
      );
      if (!i.rows[0])
        throw new Error("Failed to add session update");
      return i.rows[0].rowID;
    }
  }
  async addTransaction(A, e, i) {
    await this.db.query(
      "INSERT INTO transactions (ses, idx, tx) VALUES ($1, $2, $3)",
      [A, e, JSON.stringify(i)]
    );
  }
  async addSignatureAfter({ sessionRowID: A, idx: e, signature: i }) {
    await this.db.query(
      "INSERT INTO signatureAfter (ses, idx, signature) VALUES ($1, $2, $3)",
      [A, e, i]
    );
  }
}
class ny {
  constructor(A) {
    this.db = A;
  }
  async getCoValue(A) {
    const e = await this.db.query(
      "SELECT * FROM coValues WHERE id = $1",
      [A]
    );
    if (!e.rows[0]) return;
    const i = e.rows[0];
    try {
      const o = typeof i.header == "string" ? JSON.parse(i.header) : i.header;
      return {
        rowID: i.rowID || i.rowid,
        id: i.id,
        header: o
      };
    } catch (o) {
      AA.warn(`Invalid JSON in header: ${i.header}`, {
        id: A,
        err: o
      });
      return;
    }
  }
  async upsertCoValue(A, e) {
    if (!e) {
      const r = await this.db.query(
        'SELECT "rowID" FROM coValues WHERE id = $1',
        [A]
      );
      return r.rows[0]?.rowID || r.rows[0]?.rowid;
    }
    const i = await this.db.query(
      `INSERT INTO coValues (id, header) VALUES ($1, $2)
       ON CONFLICT (id) DO NOTHING
       RETURNING "rowID"`,
      [A, JSON.stringify(e)]
    );
    if (i.rows[0])
      return i.rows[0].rowID || i.rows[0].rowid;
    const o = await this.db.query(
      'SELECT "rowID" FROM coValues WHERE id = $1',
      [A]
    );
    return o.rows[0]?.rowID || o.rows[0]?.rowid;
  }
  async getAllCoValuesWaitingForDelete() {
    return (await this.db.query(
      'SELECT "coValueID" FROM deletedCoValues WHERE status = $1',
      [Ut.Pending]
    )).rows.map((e) => e.coValueID || e.covalueid);
  }
  async getCoValueSessions(A) {
    return (await this.db.query(
      'SELECT * FROM sessions WHERE "coValue" = $1',
      [A]
    )).rows.map((i) => ({
      rowID: i.rowID || i.rowid,
      coValue: i.coValue || i.covalue,
      sessionID: i.sessionID || i.sessionid,
      lastIdx: i.lastIdx || i.lastidx,
      lastSignature: i.lastSignature || i.lastsignature,
      bytesSinceLastSignature: i.bytesSinceLastSignature || i.bytessincelastsignature
    }));
  }
  async getNewTransactionInSession(A, e, i) {
    return (await this.db.query(
      "SELECT * FROM transactions WHERE ses = $1 AND idx >= $2 AND idx <= $3 ORDER BY idx",
      [A, e, i]
    )).rows.map((r) => {
      try {
        return {
          ses: r.ses,
          idx: r.idx,
          tx: typeof r.tx == "string" ? JSON.parse(r.tx) : r.tx
        };
      } catch (n) {
        return AA.warn("Invalid JSON in transaction", { err: n }), null;
      }
    }).filter(Boolean);
  }
  async getSignatures(A, e) {
    return (await this.db.query(
      "SELECT * FROM signatureAfter WHERE ses = $1 AND idx >= $2 ORDER BY idx",
      [A, e]
    )).rows.map((o) => ({
      ses: o.ses,
      idx: o.idx,
      signature: o.signature
    }));
  }
  async transaction(A) {
    await this.db.exec("BEGIN");
    try {
      const e = new ry(this.db);
      await A(e), await this.db.exec("COMMIT");
    } catch (e) {
      throw await this.db.exec("ROLLBACK"), e;
    }
  }
  async trackCoValuesSyncState(A) {
    for (const e of A)
      e.synced ? await this.db.query(
        'DELETE FROM unsynced_covalues WHERE "co_value_id" = $1 AND "peer_id" = $2',
        [e.id, e.peerId]
      ) : await this.db.query(
        'INSERT INTO unsynced_covalues ("co_value_id", "peer_id") VALUES ($1, $2) ON CONFLICT ("co_value_id", "peer_id") DO NOTHING',
        [e.id, e.peerId]
      );
  }
  async getUnsyncedCoValueIDs() {
    return (await this.db.query(
      'SELECT DISTINCT "co_value_id" FROM unsynced_covalues'
    )).rows.map((e) => e.co_value_id);
  }
  async stopTrackingSyncState(A) {
    await this.db.query(
      'DELETE FROM unsynced_covalues WHERE "co_value_id" = $1',
      [A]
    );
  }
  async eraseCoValueButKeepTombstone(A) {
    const e = await this.db.query(
      'SELECT "rowID" FROM coValues WHERE id = $1',
      [A]
    );
    if (!e.rows[0]) {
      AA.warn(`CoValue ${A} not found, skipping deletion`);
      return;
    }
    const i = e.rows[0].rowID || e.rows[0].rowid;
    await this.transaction(async (o) => {
      await this.db.query(
        `DELETE FROM transactions
         WHERE ses IN (
           SELECT "rowID" FROM sessions
           WHERE "coValue" = $1 AND "sessionID" NOT LIKE '%$'
         )`,
        [i]
      ), await this.db.query(
        `DELETE FROM signatureAfter
         WHERE ses IN (
           SELECT "rowID" FROM sessions
           WHERE "coValue" = $1 AND "sessionID" NOT LIKE '%$'
         )`,
        [i]
      ), await this.db.query(
        `DELETE FROM sessions
         WHERE "coValue" = $1 AND "sessionID" NOT LIKE '%$'`,
        [i]
      ), await this.db.query(
        `INSERT INTO deletedCoValues ("coValueID", status) VALUES ($1, $2)
         ON CONFLICT ("coValueID") DO UPDATE SET status = $2`,
        [A, Ut.Done]
      );
    });
  }
  async getCoValueKnownState(A) {
    const e = await this.db.query(
      'SELECT "rowID" FROM coValues WHERE id = $1',
      [A]
    );
    if (!e.rows[0])
      return;
    const i = e.rows[0].rowID || e.rows[0].rowid, o = await this.db.query(
      'SELECT "sessionID", "lastIdx" FROM sessions WHERE "coValue" = $1',
      [i]
    ), r = Je(A);
    r.header = !0;
    for (const n of o.rows) {
      const s = n.sessionID || n.sessionid, a = n.lastIdx || n.lastidx;
      r.sessions[s] = a;
    }
    return r;
  }
}
async function sy(t) {
  if (typeof window < "u" || typeof process > "u" || !process.versions?.node)
    throw new Error("[STORAGE] PGlite is only available in Node.js/server environments");
  console.log(`[STORAGE] Initializing PGlite at ${t}...`);
  try {
    let A;
    try {
      const n = await import("@electric-sql/pglite");
      A = n.PGlite || n.default?.PGlite || n.default;
    } catch (n) {
      throw typeof window < "u" ? new Error("[STORAGE] PGlite cannot be imported in browser environment. This is a server-only module.") : n;
    }
    if (!A)
      throw new Error("[STORAGE] Failed to import PGlite - module structure may have changed");
    const e = await Promise.resolve().then(() => sg), o = (await Promise.resolve().then(() => sg)).dirname(t);
    try {
      await e.mkdir(o, { recursive: !0 }), console.log(`[STORAGE] Ensured directory exists: ${o}`);
    } catch (n) {
      n.code !== "EEXIST" && console.warn(`[STORAGE] Could not create directory ${o}:`, n.message);
    }
    console.log("[STORAGE] Creating PGlite instance...");
    const r = await A.create(t);
    return console.log(`[STORAGE] PGlite initialized successfully at ${t}`), console.log("[STORAGE] Running PGlite migrations..."), await oy(r), console.log("[STORAGE] PGlite migrations completed"), new ny(r);
  } catch (A) {
    throw console.error(`[STORAGE] PGlite initialization error at ${t}:`, A), console.error("[STORAGE] Error details:", {
      message: A?.message,
      stack: A?.stack,
      name: A?.name,
      cause: A?.cause
    }), A;
  }
}
async function ay(t) {
  try {
    const A = await sy(t), e = new Hg(A);
    return e.enableDeletedCoValuesErasure(), console.log("[STORAGE] PGlite storage adapter ready"), e;
  } catch (A) {
    throw console.error("[STORAGE] Failed to initialize PGlite storage:", A), console.error("[STORAGE] Error type:", A?.constructor?.name), console.error("[STORAGE] Error message:", A?.message), A?.stack && console.error("[STORAGE] Stack trace:", A.stack), A;
  }
}
async function Be() {
}
const dt = { BASE_URL: "/", DEV: !1, MODE: "production", PROD: !0, SSR: !1 };
function gy() {
  return typeof EdgeRuntime < "u" || typeof Deno < "u" ? "edge" : typeof process < "u" && process.versions && process.versions.node ? "node" : "browser";
}
function Iy(t, A = null) {
  const e = A ? `${A}_${t}` : t;
  if (typeof import.meta < "u" && dt)
    return dt[e] || dt[t] || dt[`VITE_${e}`] || dt[`VITE_${t}`];
  if (typeof process < "u" && process.env)
    return process.env[e] || process.env[t];
}
async function qe(t = {}) {
  const { mode: A = "human", dbPath: e, inMemory: i, servicePrefix: o } = t, r = gy(), n = Iy("MAIA_STORAGE", o);
  if ((r === "node" || r === "browser" && typeof window < "u") && console.log(`[STORAGE] Runtime: ${r}, Mode: ${A}, Storage Type: ${n || "(default)"}, dbPath: ${e || "(none)"}`), i === !0)
    return console.log("[STORAGE] Using in-memory storage (explicit inMemory=true)"), await Be();
  if (r === "edge")
    return console.log("[STORAGE] Edge runtime detected - using in-memory storage (no persistence)"), await Be();
  if (n === "in-memory")
    return console.log("[STORAGE] Using in-memory storage (explicit MAIA_STORAGE=in-memory)"), await Be();
  if (r === "browser") {
    if (n === "indexeddb" || !n && A === "human") {
      const s = await ey();
      return s ? (console.log("[STORAGE] Using IndexedDB storage"), s) : (console.warn("[STORAGE] IndexedDB unavailable, falling back to in-memory"), await Be());
    }
    return await Be();
  }
  if (r === "node") {
    const s = e || typeof process < "u" && process.env?.DB_PATH;
    if ((s && !i || n === "pglite" && !i && s) && s)
      try {
        const g = await ay(s);
        return console.log(`[STORAGE] Using PGlite storage at ${s}`), g;
      } catch (g) {
        if (n === "pglite")
          throw new Error(
            `[STORAGE] PGlite storage initialization FAILED at ${s}. Storage type is explicitly set to 'pglite' via MAIA_STORAGE env var - refusing to fall back to in-memory. Original error: ${g?.message || g}. Check logs above for detailed initialization errors.`
          );
        return console.warn("[STORAGE] PGlite initialization failed, falling back to in-memory"), console.warn("[STORAGE] Fallback reason:", g?.message || g), await Be();
      }
    if (!n || n === "in-memory" || A === "agent" && !s)
      return console.log("[STORAGE] Using in-memory storage (Node.js default)"), await Be();
  }
  return await Be();
}
const or = { BASE_URL: "/", DEV: !1, MODE: "production", PROD: !0, SSR: !1 };
async function Yn({ agentSecret: t, name: A = "Maia", peers: e = [], storage: i = void 0, skipAutoSeeding: o = !1 }) {
  if (!t)
    throw new Error("agentSecret is required. Use signInWithPasskey() to get agentSecret.");
  const r = await Ie.create(), n = i !== void 0 ? i : await qe({ mode: "human" }), s = await Ge.withNewlyCreatedAccount({
    creationProps: { name: A },
    crypto: r,
    initialAgentSecret: t,
    // Use provided secret from passkey!
    peers: e,
    // Use provided sync peers
    storage: n,
    // Use centralized storage if not provided
    migration: pn
    // Handles profile + schemata + Data
  }), a = s.node.expectCurrentAccount("oID/createAccountWithSecret"), g = a.get("profile");
  if (!g)
    throw new Error("Profile not created by account creation migration");
  if (o) {
    console.log("  Auto-seeding skipped (agent mode/server account)");
    try {
      const { CoJSONBackend: I } = await Promise.resolve().then(() => Lr), { DBEngine: c } = await Promise.resolve().then(() => ks), C = new I(s.node, a, { systemSpark: "@maia" });
      C.dbEngine = new c(C), await mI(a, s.node, C);
    } catch (I) {
      console.error("[createAccountWithSecret] Agent seed failed (non-blocking):", I);
    }
  } else
    try {
      const I = typeof import.meta < "u" ? or?.VITE_MAIA_CITY_SEED_VIBES || or?.VITE_SEED_VIBES || or?.SEED_VIBES : null, c = I ? I === "all" ? "all" : I.split(",").map((b) => b.trim()) : "all", { getAllVibeRegistries: C, filterVibesForSeeding: B } = await Promise.resolve().then(() => Qk), Q = await C(), f = B(Q, c);
      if (f.length === 0)
        return Q.length === 0 ? console.log("  No vibe registries found, skipping auto-seeding") : console.log(`  Seeding config filters out all vibes (config: ${JSON.stringify(c)}), skipping vibe seeding`), {
          node: s.node,
          account: a,
          accountID: a.id,
          profile: g,
          group: null
        };
      console.log(` Auto-seeding ${f.length} vibe(s) based on config: ${JSON.stringify(c)}`);
      const l = {
        styles: {},
        actors: {},
        views: {},
        contexts: {},
        states: {},
        inboxes: {},
        vibes: f.map((b) => b.vibe),
        // Pass vibes as array
        data: {}
      };
      for (const b of f)
        Object.assign(l.styles, b.styles || {}), Object.assign(l.actors, b.actors || {}), Object.assign(l.views, b.views || {}), Object.assign(l.contexts, b.contexts || {}), Object.assign(l.states, b.states || {}), Object.assign(l.inboxes, b.inboxes || {}), Object.assign(l.data, b.data || {});
      const { CoJSONBackend: u } = await Promise.resolve().then(() => Lr), d = new u(s.node, a, { systemSpark: "@maia" }), { DBEngine: h } = await Promise.resolve().then(() => ks), p = new h(d);
      d.dbEngine = p;
      const { getAllToolDefinitions: E } = await Promise.resolve().then(() => UI), w = E(), y = {
        ...l,
        tool: w
        // Add tool definitions under 'tool' key
      }, { getAllSchemas: m } = await Promise.resolve().then(() => jt), k = m();
      await p.execute({
        op: "seed",
        configs: y,
        schemas: k,
        data: l.data || {}
      });
    } catch (I) {
      console.error("[createAccountWithSecret] Auto-seeding failed (non-blocking):", I);
    }
  return {
    node: s.node,
    account: a,
    accountID: a.id,
    profile: g,
    group: null
    // No group in minimal setup
  };
}
async function Un({ accountID: t, agentSecret: A, peers: e = [], storage: i = void 0 }) {
  if (!A)
    throw new Error("agentSecret is required. Use signInWithPasskey() to get agentSecret.");
  if (!t)
    throw new Error("accountID is required.");
  const o = await Ie.create(), r = i !== void 0 ? i : await qe({ mode: "human" }), n = performance.now();
  console.log("   Sync peers:", e.length > 0 ? `${e.length} peer(s)` : "none");
  const s = i ? typeof process < "u" && process.versions?.node ? "PGlite available (local-first)" : "IndexedDB available (local-first)" : "no storage (sync-only)";
  console.log("   Storage:", s), performance.now();
  const a = performance.now();
  i && console.log("    Storage available"), performance.now() - a;
  let g = null;
  const I = async (h, p) => (g = pn(h, p).catch((E) => {
    console.error("[loadAccount] Migration error (non-blocking):", E);
  }), Promise.resolve()), c = performance.now(), C = 3e3, B = Ge.withLoadedAccount({
    crypto: o,
    accountID: t,
    accountSecret: A,
    sessionID: o.newRandomSessionID(t),
    peers: e,
    // Use provided sync peers (sync happens in background if storage has data)
    storage: r,
    // Use centralized storage if not provided - enables local-first loading
    migration: I
    //  Runs after account loads, non-blocking
  }).catch((h) => {
    if (h?.message?.includes("Account unavailable from all peers") && e.length === 0 && r) {
      const p = new Error("Account not found in storage (first-time setup - will be created)");
      throw p.originalError = h, p.isAccountNotFound = !0, p;
    }
    throw h;
  }), Q = new Promise((h) => {
    setTimeout(() => {
      performance.now() - c, h(null);
    }, C);
  }), f = await Promise.race([B, Q]).then((h) => h === null ? B : h);
  if (performance.now(), g) {
    const h = performance.now();
    g.then(() => {
      performance.now() - h;
    }).catch(() => {
    });
  }
  const l = f.expectCurrentAccount("oID/loadAccount");
  performance.now();
  const u = l.get("profile");
  if (u) {
    const h = f.getCoValue(u);
    h && !h.isAvailable() && await f.load(u), performance.now();
  }
  performance.now();
  const d = l.get("os");
  if (d && typeof d == "string" && d.startsWith("co_z")) {
    const h = f.getCoValue(d);
    h && !h.isAvailable() ? f.loadCoValueCore(d).catch((p) => {
      console.warn("[loadAccount] Failed to prefetch account.os:", p);
    }) : h && h.isAvailable();
  }
  return performance.now() - n, {
    node: f,
    account: l,
    accountID: l.id
  };
}
function cy(t, A, { name: e = null } = {}) {
  const i = t.createGroup();
  if (A && typeof A.extend == "function")
    try {
      i.extend(A, "admin");
    } catch (o) {
      console.warn("[createChildGroup] Could not extend parent group, account is already admin:", o.message);
    }
  return e && i.set("name", e, "trusting"), console.log(" Child group created:", i.id), e && console.log("   Name:", e), console.log("   Owner:", A?.id), i;
}
const Cy = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createChildGroup: cy
}, Symbol.toStringTag, { value: "Module" }));
function NA(t, A = {}) {
  return { ok: !0, data: t, ...A };
}
function EA(t, A = {}) {
  return { ok: !1, errors: t, ...A };
}
function lA(t, A, e) {
  return { type: t, message: A, path: e ?? void 0 };
}
function $e(t) {
  return t && t.ok === !0;
}
const By = [
  "Transactor has no write permissions",
  "lacks admin permissions",
  "lacks write permissions",
  "lacks read permissions",
  "Cannot verify delete permissions",
  "wouldLeaveNoAdmins",
  "Not a member",
  "NotAdmin",
  "CannotVerifyPermissions",
  "permission"
];
function Jn(t) {
  if (!t || !(t instanceof Error)) return !1;
  const A = (t.message || "").toLowerCase(), e = String(t);
  return By.some(
    (i) => A.includes(i.toLowerCase()) || e.includes(i)
  );
}
async function Hn(t, A, e) {
  try {
    const i = await eA(t, { fromCoValue: A }, { returnType: "coId" });
    return i || null;
  } catch {
    return null;
  }
}
async function Qy(t, A, e) {
  return e ? await rt(t, e, { context: { existing: A }, item: {} }) : t;
}
function Ey(t, A) {
  if (!t || t.error) return null;
  const e = {};
  if (t.properties?.length) {
    for (const g of t.properties)
      if (g?.key !== void 0) {
        let I = g.value;
        if (typeof I == "string" && (I.startsWith("{") || I.startsWith("[")))
          try {
            I = JSON.parse(I);
          } catch {
          }
        e[g.key] = I;
      }
  } else Object.assign(e, t);
  const { id: i, loading: o, error: r, type: n, ...s } = e;
  if (s.definition) {
    const { id: g, type: I, ...c } = s.definition;
    return { ...c, $id: A };
  }
  return s.cotype || s.properties || s.items || s.title || s.description ? { ...s, $id: A } : null;
}
async function ly(t, A) {
  const { schema: e, key: i, keys: o, filter: r, options: n } = A;
  if (e && !e.startsWith("co_z") && !["@account", "@group", "@metaSchema"].includes(e))
    throw new Error(`[ReadOperation] Schema must be a co-id (co_z...) or special schema hint (@account, @group, @metaSchema), got: ${e}. Runtime code must use co-ids only, not '@maia/schema/...' patterns.`);
  if (o !== void 0 && !Array.isArray(o)) throw new Error("[ReadOperation] keys parameter must be an array of co-ids");
  if (i && o) throw new Error("[ReadOperation] Cannot provide both key and keys parameters");
  return await t.read(e, i, o, r, n);
}
async function dy(t, A, e) {
  const { schema: i, data: o, spark: r } = e;
  BA(i, "schema", "CreateOperation"), BA(o, "data", "CreateOperation"), JA(A, "CreateOperation", "runtime schema validation");
  const n = await eA(t, i, { returnType: "coId" });
  if (!n) throw new Error(`[CreateOperation] Could not resolve schema: ${i}`);
  const s = r != null ? { spark: r } : {}, a = await t.create(n, o, s);
  return NA(a, { op: "create" });
}
async function uy(t, A, e, i) {
  const { id: o, data: r } = i;
  BA(o, "id", "UpdateOperation"), uA(o, "UpdateOperation"), BA(r, "data", "UpdateOperation"), JA(A, "UpdateOperation", "schema validation");
  const n = await t.getRawRecord(o);
  if (!n) throw new Error(`[UpdateOperation] Record not found: ${o}`);
  const a = await Hn(t, o) || n.$schema || null, { $schema: g, ...I } = n, c = await Qy(r, I, e), C = await t.update(a, o, c);
  return NA(C, { op: "update" });
}
async function hy(t, A, e) {
  const { id: i } = e;
  BA(i, "id", "DeleteOperation"), uA(i, "DeleteOperation"), JA(A, "DeleteOperation", "extract schema from CoValue headerMeta");
  const o = await Hn(A.backend, i), r = await t.delete(o, i);
  return NA(r, { op: "delete" });
}
async function fy(t, A) {
  const { configs: e, schemas: i, data: o } = A;
  if (!e) throw new Error("[SeedOperation] Configs required");
  if (!i) throw new Error("[SeedOperation] Schemas required");
  const r = await t.seed(e, i, o || {});
  return NA(r, { op: "seed" });
}
async function py(t, A, e) {
  const { coId: i, fromCoValue: o } = e, r = [i, o].filter(Boolean).length;
  if (r === 0) throw new Error("[SchemaOperation] One of coId or fromCoValue must be provided");
  if (r > 1) throw new Error("[SchemaOperation] Only one of coId or fromCoValue can be provided");
  let n = i ? (uA(i, "SchemaOperation"), i) : null;
  if (o && (uA(o, "SchemaOperation"), n = await eA(t, { fromCoValue: o }, { returnType: "coId" }), !n))
    return console.warn(`[SchemaOperation] Could not extract schema co-id from CoValue ${o} headerMeta`), new wA(null);
  const s = await t.read(null, n), a = new wA(null), g = (C) => a._set(Ey(C, n)), I = s.subscribe(g);
  g(s.value);
  const c = a._unsubscribe;
  return a._unsubscribe = () => {
    c && c(), I();
  }, a;
}
async function wy(t, A) {
  const { humanReadableKey: e } = A;
  if (BA(e, "humanReadableKey", "ResolveOperation"), typeof e != "string") throw new Error("[ResolveOperation] humanReadableKey must be a string");
  (MA(e) || e.startsWith("@actor/") || eI(e)) && console.warn(`[ResolveOperation] resolve() called with human-readable key: ${e}. This should only be used during seeding. At runtime, all IDs should already be co-ids.`);
  const i = A.spark ?? t?.systemSpark;
  return await eA(t, e, { returnType: "coId", spark: i });
}
async function Ss(t, A, e) {
  const { coId: i, item: o, items: r, cotype: n } = e;
  BA(i, "coId", "AppendOperation"), uA(i, "AppendOperation"), JA(A, "AppendOperation", "check schema cotype");
  const s = await aI(t, i, "AppendOperation"), a = await Hn(t, i);
  let g = n;
  if (!g) {
    const l = await Rt(t, a, "colist"), u = await Rt(t, a, "costream");
    if (l) g = "colist";
    else if (u) g = "costream";
    else throw new Error(`[AppendOperation] CoValue ${i} must be a CoList (colist) or CoStream (costream), got schema cotype: ${a}`);
  }
  if (!await Rt(t, a, g)) throw new Error(`[AppendOperation] CoValue ${i} is not a ${g} (schema cotype check failed)`);
  const I = await eA(t, a, { returnType: "schema" });
  if (!I) throw new Error(`[AppendOperation] Schema ${a} not found`);
  const c = t.getCurrentContent(s), C = g === "colist" ? "append" : "push";
  if (!c || typeof c[C] != "function") throw new Error(`[AppendOperation] ${g === "colist" ? "CoList" : "CoStream"} ${i} doesn't have ${C} method`);
  const B = r || (o ? [o] : []);
  if (B.length === 0) throw new Error("[AppendOperation] At least one item required (use item or items parameter)");
  sI(I, B);
  let Q = 0;
  if (g === "colist") {
    let l = [];
    try {
      typeof c.toJSON == "function" && (l = c.toJSON() || []);
    } catch (u) {
      console.warn("[AppendOperation] Error checking existing items:", u);
    }
    for (const u of B)
      l.includes(u) || (c.append(u), Q++);
  } else
    for (const l of B) c.push(l), Q++;
  t.node?.storage && await t.node.syncManager.waitForStorageSync(i);
  const f = { coId: i, [g === "colist" ? "itemsAppended" : "itemsPushed"]: Q, ...g === "colist" && { itemsSkipped: B.length - Q } };
  return NA(f, { op: "append" });
}
async function yy(t, A, e) {
  const { actorId: i, inboxCoId: o } = e;
  BA(i, "actorId", "ProcessInboxOperation"), BA(o, "inboxCoId", "ProcessInboxOperation"), uA(i, "ProcessInboxOperation"), uA(o, "ProcessInboxOperation");
  const { processInbox: r } = await Promise.resolve().then(() => Mo);
  return await r(t, i, o);
}
async function Dy(t, A, e) {
  const { name: i } = e;
  return BA(i, "name", "CreateSparkOperation"), JA(A, "CreateSparkOperation", "spark creation"), await t.createSpark(i);
}
async function my(t, A) {
  const { id: e, schema: i } = A;
  if (e)
    return uA(e, "ReadSparkOperation"), await t.readSpark(e);
  const o = i || "@maia/schema/data/spark";
  return await t.readSpark(null, o);
}
async function Sy(t, A, e) {
  const { id: i, data: o } = e;
  return BA(i, "id", "UpdateSparkOperation"), uA(i, "UpdateSparkOperation"), BA(o, "data", "UpdateSparkOperation"), JA(A, "UpdateSparkOperation", "spark update"), await t.updateSpark(i, o);
}
async function ky(t, A, e) {
  const { id: i } = e;
  return BA(i, "id", "DeleteSparkOperation"), uA(i, "DeleteSparkOperation"), JA(A, "DeleteSparkOperation", "spark deletion"), await t.deleteSpark(i);
}
async function It(t, A) {
  uA(A, "GetSparkGroup");
  const e = await Dn(t, A, "guardian");
  if (!e || typeof e != "string" || !e.startsWith("co_z"))
    throw new Error(`[GetSparkGroup] Spark has no guardian in os.capabilities: ${A}`);
  const i = await t.getGroup(e);
  if (!i)
    throw new Error(`[GetSparkGroup] Group not found: ${e}`);
  return i;
}
async function Ny(t, A, e) {
  const { id: i, memberId: o, role: r } = e;
  BA(i, "id", "AddSparkMemberOperation"), uA(i, "AddSparkMemberOperation"), BA(o, "memberId", "AddSparkMemberOperation"), uA(o, "AddSparkMemberOperation"), BA(r, "role", "AddSparkMemberOperation"), JA(A, "AddSparkMemberOperation", "spark member addition");
  const n = ["reader", "writer", "admin", "manager", "writeOnly"];
  if (!n.includes(r))
    throw new Error(`[AddSparkMemberOperation] Invalid role: ${r}. Must be one of: ${n.join(", ")}`);
  const s = await It(t, i);
  return await t.addGroupMember(s, o, r), {
    success: !0,
    sparkId: i,
    memberId: o,
    role: r
  };
}
async function My(t, A, e) {
  const { id: i, memberId: o } = e;
  BA(i, "id", "RemoveSparkMemberOperation"), uA(i, "RemoveSparkMemberOperation"), BA(o, "memberId", "RemoveSparkMemberOperation"), uA(o, "RemoveSparkMemberOperation"), JA(A, "RemoveSparkMemberOperation", "spark member removal");
  const r = await It(t, i);
  return await t.removeGroupMember(r, o), {
    success: !0,
    sparkId: i,
    memberId: o
  };
}
async function Gy(t, A, e) {
  const { id: i, parentGroupId: o, role: r = "extend" } = e;
  BA(i, "id", "AddSparkParentGroupOperation"), uA(i, "AddSparkParentGroupOperation"), BA(o, "parentGroupId", "AddSparkParentGroupOperation"), uA(o, "AddSparkParentGroupOperation"), JA(A, "AddSparkParentGroupOperation", "spark parent group addition");
  const n = ["reader", "writer", "manager", "admin", "extend"];
  if (!n.includes(r))
    throw new Error(`[AddSparkParentGroupOperation] Invalid role: ${r}. Must be one of: ${n.join(", ")}`);
  const s = await It(t, i), a = await t.getGroup(o);
  if (!a)
    throw new Error(`[AddSparkParentGroupOperation] Parent group not found: ${o}`);
  return s.extend(a, r), {
    success: !0,
    sparkId: i,
    parentGroupId: o,
    role: r
  };
}
async function Fy(t, A, e) {
  const { id: i, parentGroupId: o } = e;
  BA(i, "id", "RemoveSparkParentGroupOperation"), uA(i, "RemoveSparkParentGroupOperation"), BA(o, "parentGroupId", "RemoveSparkParentGroupOperation"), uA(o, "RemoveSparkParentGroupOperation"), JA(A, "RemoveSparkParentGroupOperation", "spark parent group removal");
  const r = await It(t, i), n = await t.getGroup(o);
  if (!n)
    throw new Error(`[RemoveSparkParentGroupOperation] Parent group not found: ${o}`);
  return r.revokeExtend(n), {
    success: !0,
    sparkId: i,
    parentGroupId: o
  };
}
async function by(t, A) {
  const { id: e } = A;
  BA(e, "id", "GetSparkMembersOperation"), uA(e, "GetSparkMembersOperation");
  const i = await It(t, e), o = t.getGroupInfoFromGroup(i);
  return {
    sparkId: e,
    groupId: i.id,
    members: o?.accountMembers || [],
    parentGroups: o?.groupMembers || []
  };
}
async function Ry(t, A, e) {
  const { id: i, memberId: o, role: r } = e;
  BA(i, "id", "UpdateSparkMemberRoleOperation"), uA(i, "UpdateSparkMemberRoleOperation"), BA(o, "memberId", "UpdateSparkMemberRoleOperation"), uA(o, "UpdateSparkMemberRoleOperation"), BA(r, "role", "UpdateSparkMemberRoleOperation"), JA(A, "UpdateSparkMemberRoleOperation", "spark member role update");
  const n = ["reader", "writer", "admin", "manager", "writeOnly"];
  if (!n.includes(r))
    throw new Error(`[UpdateSparkMemberRoleOperation] Invalid role: ${r}. Must be one of: ${n.join(", ")}`);
  const s = await It(t, i);
  return await t.setGroupMemberRole(s, o, r), {
    success: !0,
    sparkId: i,
    memberId: o,
    role: r
  };
}
let qn = class {
  /**
   * Create a new DBEngine instance
   * @param {DBAdapter} backend - Backend adapter instance (must implement DBAdapter interface)
   * @param {Object} [options] - Optional configuration
   * @param {Object} [options.evaluator] - Optional MaiaScript evaluator for expression evaluation in updates
   */
  constructor(A, e = {}) {
    this.backend = A;
    const { evaluator: i } = e;
    A && typeof A.setDbEngine == "function" ? A.setDbEngine(this) : A && A.constructor.name === "CoJSONBackend" && (A.dbEngine = this), this.operations = {
      read: { execute: (o) => ly(this.backend, o) },
      create: { execute: (o) => dy(this.backend, this, o) },
      update: { execute: (o) => uy(this.backend, this, i, o) },
      delete: { execute: (o) => hy(this.backend, this, o) },
      seed: { execute: (o) => fy(this.backend, o) },
      schema: { execute: (o) => py(this.backend, this, o) },
      resolve: { execute: (o) => wy(this.backend, o) },
      append: { execute: (o) => Ss(this.backend, this, o) },
      push: { execute: (o) => Ss(this.backend, this, { ...o, cotype: "costream" }) },
      processInbox: { execute: (o) => yy(this.backend, this, o) },
      createSpark: { execute: (o) => Dy(this.backend, this, o) },
      readSpark: { execute: (o) => my(this.backend, o) },
      updateSpark: { execute: (o) => Sy(this.backend, this, o) },
      deleteSpark: { execute: (o) => ky(this.backend, this, o) },
      addSparkMember: { execute: (o) => Ny(this.backend, this, o) },
      removeSparkMember: { execute: (o) => My(this.backend, this, o) },
      addSparkParentGroup: { execute: (o) => Gy(this.backend, this, o) },
      removeSparkParentGroup: { execute: (o) => Fy(this.backend, this, o) },
      getSparkMembers: { execute: (o) => by(this.backend, o) },
      updateSparkMemberRole: { execute: (o) => Ry(this.backend, this, o) }
    };
  }
  /**
   * Execute a database operation
   * @param {Object} payload - Operation payload
   * @param {string} payload.op - Operation name (read, create, update, delete, seed)
   * @param {Object} payload params - Operation-specific parameters
   * @returns {Promise<any>} Operation result
   */
  async execute(A) {
    const { op: e, ...i } = A;
    if (!e)
      throw new Error('[DBEngine] Operation required: {op: "read|create|update|delete|seed|schema|resolve|append|push|createSpark|readSpark|updateSpark|deleteSpark|addSparkMember|removeSparkMember|addSparkParentGroup|removeSparkParentGroup|getSparkMembers|updateSparkMemberRole"}');
    if (e === "push")
      return await this.operations.append.execute({ ...i, cotype: "costream" });
    const o = this.operations[e];
    if (!o)
      throw new Error(`[DBEngine] Unknown operation: ${e}`);
    const r = /* @__PURE__ */ new Set(["create", "update", "delete", "append", "push", "seed"]);
    try {
      return await o.execute(i);
    } catch (n) {
      if (console.error(`[DBEngine] Operation ${e} failed:`, n), r.has(e)) {
        const s = [Jn(n) ? lA("permission", n.message) : lA("schema", n.message)];
        return EA(s, { op: e });
      }
      throw n;
    }
  }
  /**
   * Resolve a human-readable ID to a co-id
   * DEPRECATED: This method should only be used during seeding. At runtime, all IDs should already be co-ids.
   * @deprecated Use co-ids directly at runtime. This method is only for seeding/backward compatibility.
   * @param {string} humanReadableId - Human-readable ID (e.g., '@maia/vibe/todos', 'vibe/vibe')
   * @returns {Promise<string|null>} Co-id (co_z...) or null if not found
   */
};
class kI {
  /**
   * Read data from database
   * @param {string} schema - Schema co-id (co_z...)
   * @param {string} [key] - Specific key (co-id) for single item
   * @param {string[]} [keys] - Array of co-ids for batch reads
   * @param {Object} [filter] - Filter criteria for collection queries
   * @returns {Promise<ReactiveStore|ReactiveStore[]>} Reactive store(s) that hold current value and notify on updates
   */
  async read(A, e, i, o) {
    throw new Error("[DBAdapter] read() must be implemented by backend");
  }
  /**
   * Create new record
   * @param {string} schema - Schema co-id (co_z...) for data collections
   * @param {Object} data - Data to create
   * @returns {Promise<Object>} Created record with generated co-id
   */
  async create(A, e) {
    throw new Error("[DBAdapter] create() must be implemented by backend");
  }
  /**
   * Update existing record (unified for data collections and configs)
   * @param {string} schema - Schema co-id (co_z...) - MUST be a co-id, not '@maia/schema/...'
   * @param {string} id - Record co-id to update
   * @param {Object} data - Data to update
   * @returns {Promise<Object>} Updated record
   */
  async update(A, e, i) {
    throw new Error("[DBAdapter] update() must be implemented by backend");
  }
  /**
   * Delete record
   * @param {string} schema - Schema co-id (co_z...)
   * @param {string} id - Record co-id to delete
   * @returns {Promise<boolean>} true if deleted successfully
   */
  async delete(A, e) {
    throw new Error("[DBAdapter] delete() must be implemented by backend");
  }
  /**
   * Get raw record from database (without normalization)
   * Used for validation - returns stored data as-is (with $schema metadata, without id)
   * @param {string} id - Record co-id
   * @returns {Promise<Object|null>} Raw stored record or null if not found
   */
  async getRawRecord(A) {
    throw new Error("[DBAdapter] getRawRecord() must be implemented by backend");
  }
  /**
   * Seed database with configs, schemas, and initial data (optional - backend-specific)
   * @param {Object} configs - Config registry
   * @param {Object} schemas - Schema definitions
   * @param {Object} data - Initial application data
   * @returns {Promise<void>}
   */
  async seed(A, e, i) {
    throw new Error("[DBAdapter] seed() is optional - backend may not implement this");
  }
}
const ks = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DBAdapter: kI,
  DBEngine: qn,
  ReactiveStore: wA,
  createErrorEntry: lA,
  createErrorResult: EA,
  createSuccessResult: NA,
  isPermissionError: Jn,
  isSuccessResult: $e
}, Symbol.toStringTag, { value: "Module" }));
async function NI(t, A, e, i) {
  const o = await nA(t, e, { waitForAvailable: !0 });
  if (!o)
    throw new Error(`[CoJSONBackend] CoValue not found: ${e}`);
  if (!t.isAvailable(o))
    throw new Error(`[CoJSONBackend] CoValue not available: ${e}`);
  const r = t.getCurrentContent(o), n = r?.type || "unknown";
  let s = null;
  try {
    s = await eA(t, { fromCoValue: e }, { returnType: "coId" });
  } catch (a) {
    console.log(`[Update] Skipping validation for ${e}: ${a.message}`);
  }
  if (s && t.dbEngine && s.startsWith("co_z")) {
    const { isExceptionSchema: a } = await Promise.resolve().then(() => Pt);
    if (!a(s)) {
      const g = await t.getRawRecord(e);
      if (g) {
        const { $schema: I, ...c } = g, C = { ...c, ...i };
        try {
          await $t(
            t,
            s,
            C,
            `update for ${e}`,
            { dbEngine: t.dbEngine }
          );
        } catch (B) {
          throw new Error(`[Update] Validation failed: ${B.message}`);
        }
      }
    }
  }
  if (n === "comap" && r.set)
    for (const [a, g] of Object.entries(i))
      r.set(a, g);
  else
    throw new Error(`[CoJSONBackend] Update not supported for type: ${n}`);
  return ln(t, o);
}
const MI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  update: NI
}, Symbol.toStringTag, { value: "Module" }));
function xn(t, A, e) {
  const i = A?.account && A.account.id === e, o = A?.account && A.account.get && A.account.get("profile") === e, r = t.header?.meta?.type === "account", s = t.header?.ruleset?.type === "group", a = A?.account && !t.header, g = i || r || a, I = s && !i && !r && !a, c = t.header?.meta?.$schema, C = c ? He(c) : !1;
  return {
    isAccount: g,
    isGroup: I,
    isProfile: o,
    isException: C
  };
}
function xr(t) {
  return !t || !t.header || !t.header.meta ? null : t.header.meta.$schema || null;
}
function Ky(t, A, e) {
  const i = xn(t, A, e);
  return i.isAccount || i.isGroup || i.isProfile || i.isException;
}
const ZA = /* @__PURE__ */ new Set();
function vy(t, A) {
  if (!t || !A)
    return t;
  const e = t.store.bind(t), i = new Proxy(t, {
    get(r, n) {
      if (n === "store")
        return function(a, g) {
          return o.call(r, a, g, e);
        };
      const s = r[n];
      return typeof s == "function" ? s.bind(r) : s;
    }
  });
  function o(r, n, s) {
    const a = r.id, g = xn(r, A, a);
    if (!g.isAccount && !g.isGroup && !g.isProfile) {
      if (!r.header || !r.header.meta)
        throw r.header ? console.warn(`[StorageHook] Co-value ${a} has header but no meta. Header structure:`, {
          type: r.header.type,
          ruleset: r.header.ruleset,
          hasMeta: !!r.header.meta,
          headerKeys: Object.keys(r.header || {})
        }) : console.warn(`[StorageHook] Co-value ${a} has no header at all. Message structure:`, {
          id: r.id,
          hasHeader: !!r.header,
          messageKeys: Object.keys(r || {})
        }), console.error(`[StorageHook] REJECTING co-value ${a}: Missing header.meta. Every co-value MUST have headerMeta.$schema (except groups, accounts, and profiles during account creation).`), new Error(`[StorageHook] Co-value ${a} missing header.meta. Every co-value MUST have headerMeta.$schema (except groups, accounts, and profiles during account creation).`);
      if (!xr(r) && !g.isException)
        throw console.error(`[StorageHook] REJECTING co-value ${a}: Missing $schema in headerMeta. Every co-value MUST have a schema (except @account, @group, @metaSchema, and groups/accounts).`), new Error(`[StorageHook] Co-value ${a} missing $schema in headerMeta. Every co-value MUST have a schema (except @account, @group, @metaSchema, and groups/accounts).`);
    }
    let I = Ky(r, A, a);
    if (I && xr(r) === yA.META_SCHEMA && (I = !1), !I && A.account) {
      const C = A._cachedMaiaOsId;
      if (a === C)
        I = !0;
      else if (C) {
        const B = A.node.getCoValue(C);
        if (B && A.isAvailable(B) && B.type === "comap") {
          const Q = B.getCurrentContent?.();
          if (Q && typeof Q.get == "function") {
            const f = Q.get("schematas");
            a === f && (I = !0);
            const l = Q.get("unknown");
            a === l && (I = !0);
            const u = Q.get("indexes");
            if (a === u && (I = !0), u && !I) {
              const d = A.node.getCoValue(u);
              if (d && A.isAvailable(d) && d.type === "comap") {
                const h = d.getCurrentContent?.();
                if (h && typeof h.get == "function")
                  try {
                    const p = h.keys && typeof h.keys == "function" ? h.keys() : Object.keys(h);
                    for (const E of p)
                      if (h.get(E) === a) {
                        I = !0;
                        break;
                      }
                  } catch {
                    I = !0;
                  }
              }
            }
          }
        } else (!B || !A.isAvailable(B)) && (I = !0);
      }
    }
    const c = s(r, n);
    return I || Promise.resolve(c).then(async () => {
      if (!ZA.has(a)) {
        ZA.add(a);
        try {
          let C = A.getCoValue(a), B = 0;
          const Q = 5;
          for (; (!C || !A.isAvailable(C)) && B < Q; )
            A.node?.loadCoValueCore && await A.node.loadCoValueCore(a).catch(() => {
            }), await new Promise((d) => setTimeout(d, 10 * (B + 1))), C = A.getCoValue(a), B++;
          if (!C || !A.isAvailable(C))
            return;
          const f = A.getCoValue(a);
          if (!f || !A.isAvailable(f))
            return;
          if (await pI(A, f)) {
            setTimeout(() => {
              ZA.has(a) && fI(A, f).then(() => {
                ZA.delete(a);
              }).catch(() => {
                ZA.delete(a);
              });
            }, 0);
            return;
          }
          const { shouldIndex: u } = await vn(A, f);
          if (!u)
            return;
          setTimeout(() => {
            ZA.has(a) && wI(A, f).then(() => {
              ZA.delete(a);
            }).catch(() => {
              ZA.delete(a);
            });
          }, 0);
        } catch {
          ZA.delete(a);
        }
      }
    }).catch(() => {
      const C = r.id;
      ZA.delete(C);
    }), c;
  }
  return i;
}
async function Yy(t, A) {
  try {
    const e = t.getCoValue(A);
    if (!e || !t.isAvailable(e))
      return null;
    const i = t.getCurrentContent(e);
    return i ? i && typeof i.toJSON == "function" ? i.toJSON() : i : null;
  } catch (e) {
    return console.warn(`[ValidationHook] Failed to extract content for ${A}:`, e), null;
  }
}
async function Uy(t, A, e = 5e3) {
  const i = Date.now();
  for (; Date.now() - i < e; ) {
    try {
      const o = await eA(t, A, { returnType: "schema" });
      if (o)
        return o;
    } catch {
    }
    await new Promise((o) => setTimeout(o, 100));
  }
  return null;
}
async function Jy(t, A, e) {
  const i = e.id, o = xn(e, t, i);
  if (o.isGroup || o.isAccount || o.isProfile)
    return { valid: !0, error: null };
  const r = xr(e);
  if (!r)
    return {
      valid: !1,
      error: `Co-value ${i} missing $schema in headerMeta. Every co-value MUST have a schema (except @account, @group, @maia, and groups/accounts).`
    };
  if (He(r))
    return { valid: !0, error: null };
  if (!r.startsWith("co_z"))
    return {
      valid: !1,
      error: `Co-value ${i} has invalid schema format: ${r}. Schema must be a co-id (co_z...) or exception schema (@account, @group, @maia).`
    };
  let n = await eA(t, r, { returnType: "schema" });
  if (!n && (console.log(`[ValidationHook] Schema ${r} not available, waiting for sync...`), n = await Uy(t, r, 5e3), !n))
    return {
      valid: !1,
      error: `Schema ${r} not available after timeout. Cannot validate remote transactions for ${i}.`
    };
  const s = await Yy(t, i);
  if (!s)
    return console.log(`[ValidationHook] Cannot extract content for ${i} (likely new co-value) - schema availability verified, allowing transactions`), { valid: !0, error: null };
  try {
    return await $t(
      t,
      r,
      s,
      `remote sync for ${i}`,
      { dbEngine: A }
    ), { valid: !0, error: null };
  } catch (a) {
    return {
      valid: !1,
      error: `Validation failed for remote transactions: ${a.message}`
    };
  }
}
function Hy(t, A, e) {
  if (!t || !A)
    return t;
  const i = t.handleNewContent?.bind(t);
  return i && (t.handleNewContent = async function(o, r) {
    if (o && o.id && e) {
      const n = await Jy(A, e, o);
      if (!n.valid)
        throw console.error(`[ValidationHook] Rejecting remote transactions for ${o.id}: ${n.error}`), new Error(`[ValidationHook] Invalid remote transactions rejected: ${n.error}`);
    }
    return i(o, r);
  }), t;
}
class Ln extends kI {
  constructor(A, e, i = null) {
    super();
    const o = i && typeof i == "object" && !i.backend && typeof i.execute != "function", r = o ? null : i, n = o ? i : {};
    this.node = A, this.account = e, this.dbEngine = r, this.systemSpark = n.systemSpark ?? "@maia", this.subscriptionCache = Wg(A), A.storage && (A.storage = vy(A.storage, this)), A.syncManager && r && Hy(A.syncManager, this, r);
  }
  /**
   * Reset all subscription-related caches
   * 
   * Called when new backend is created to clear stale subscriptions from previous session.
   */
  _resetCaches() {
  }
  /**
   * Get a CoValue by ID
   * @param {string} coId - CoValue ID
   * @returns {CoValueCore|null} CoValueCore or null if not found
   */
  getCoValue(A) {
    return this.node.getCoValue(A);
  }
  /**
   * Get all CoValues from the node
   * @returns {Map<string, CoValueCore>} Map of CoValue IDs to CoValueCore instances
   */
  getAllCoValues() {
    return this.node.coValues || /* @__PURE__ */ new Map();
  }
  /**
   * Check if CoValue is available (has verified state)
   * @param {CoValueCore} coValueCore - CoValueCore instance
   * @returns {boolean} True if available
   */
  isAvailable(A) {
    return A?.isAvailable() || !1;
  }
  /**
   * Get current content from CoValueCore
   * @param {CoValueCore} coValueCore - CoValueCore instance
   * @returns {RawCoValue|null} Current content or null
   */
  getCurrentContent(A) {
    return !A || !A.isAvailable() ? null : A.getCurrentContent();
  }
  /**
   * Get header from CoValueCore
   * @param {CoValueCore} coValueCore - CoValueCore instance
   * @returns {Object|null} Header object or null
   */
  getHeader(A) {
    return A?.verified?.header || null;
  }
  /**
   * Get account (for create operations)
   * @returns {RawAccount} Account CoMap
   */
  getAccount() {
    return this.account;
  }
  /**
   * Get current session ID from the node
   * @returns {string|null} Current session ID or null if node not available
   */
  getCurrentSessionID() {
    return !this.node || !this.node.currentSessionID ? null : this.node.currentSessionID;
  }
  /**
   * Read inbox CoStream with session structure and CRDT metadata preserved
   * Backend-to-backend method for inbox processing
   * @param {string} inboxCoId - Inbox CoStream co-id
   * @returns {Object|null} CoStream data with sessions and CRDT metadata, or null if not found/not a CoStream
   */
  readInboxWithSessions(A) {
    const e = this.getCoValue(A);
    return !e || !this.isAvailable(e) ? null : QQ(this, e);
  }
  /**
   * Get @maia spark's group (for create operations)
   * @returns {Promise<RawGroup|null>} @maia spark's group
   */
  async getMaiaGroup() {
    return ko(this);
  }
  /**
   * Get group information for a CoValue
   * Extracts owner group, account members, and group members with roles
   * @param {CoValueCore} coValueCore - CoValueCore instance
   * @returns {Object|null} Group info object or null if no group found
   */
  getGroupInfo(A) {
    if (!A || !this.isAvailable(A))
      return null;
    try {
      const e = this.getHeader(A), i = this.getCurrentContent(A), o = A.ruleset || e?.ruleset;
      if (!o)
        return null;
      let r = null, n = null, s = null;
      if (o.type === "group")
        r = A.id, n = A, s = i;
      else if (o.type === "ownedByGroup" && o.group)
        r = o.group, n = this.getCoValue(r), n && this.isAvailable(n) && (s = this.getCurrentContent(n));
      else if (i && i.group) {
        const g = i.group;
        r = typeof g == "string" ? g : g.id || g.$jazz && g.$jazz.id, r && (n = this.getCoValue(r), n && this.isAvailable(n) && (s = this.getCurrentContent(n)));
      } else
        return null;
      if (!s || typeof s.addMember != "function")
        return null;
      const a = Jr(s);
      return a && r && (a.groupId = r), a;
    } catch (e) {
      return console.warn("[CoJSONBackend] Error getting group info:", e), null;
    }
  }
  /**
   * Get a Group CoValue by ID
   * @param {string} groupId - Group CoValue ID
   * @returns {Promise<RawGroup|null>} Group CoValue or null if not found
   */
  async getGroup(A) {
    return await CI(this.node, A);
  }
  /**
   * Get group info from a RawGroup
   * @param {RawGroup} group - RawGroup instance
   * @returns {Object|null} Group info object
   */
  getGroupInfoFromGroup(A) {
    return Jr(A);
  }
  /**
   * Add a member to a group
   * @param {RawGroup} group - Group CoValue
   * @param {string} memberId - Member ID (account or group Co-ID)
   * @param {string} role - Role name
   * @returns {Promise<void>}
   */
  async addGroupMember(A, e, i) {
    return await Nn(this.node, A, e, i, this);
  }
  /**
   * Remove a member from a group
   * @param {RawGroup} group - Group CoValue
   * @param {string} memberId - Member ID to remove
   * @returns {Promise<void>}
   */
  async removeGroupMember(A, e) {
    return await Mn(A, e);
  }
  /**
   * Set a member's role in a group
   * @param {RawGroup} group - Group CoValue
   * @param {string} memberId - Member ID
   * @param {string} role - New role name
   * @returns {Promise<void>}
   */
  async setGroupMemberRole(A, e, i) {
    return await dI(this.node, A, e, i);
  }
  // ============================================================================
  // Spark Operations (Group References)
  // ============================================================================
  /**
   * Create a new Spark (CoMap that references a group)
   * Creates a child group owned by @maia spark's group, then creates Spark CoMap
   * @param {string} name - Spark name
   * @returns {Promise<Object>} Created spark with co-id
   */
  async createSpark(A) {
    if (!this.account)
      throw new Error("[CoJSONBackend] Account required for createSpark");
    const e = await this.getMaiaGroup();
    if (!e)
      throw new Error("[CoJSONBackend] @maia spark group not found");
    const { createChildGroup: i } = await Promise.resolve().then(() => Cy), o = i(this.node, e, { name: A }), r = await eA(this, "@maia/schema/data/spark", { returnType: "coId" }), n = await eA(this, "@maia/schema/os/capabilities", { returnType: "coId" }), s = await eA(this, "@maia/schema/os/os-registry", { returnType: "coId" }), a = await eA(this, "@maia/schema/os/vibes-registry", { returnType: "coId" });
    if (!r || !n || !s || !a)
      throw new Error("[CoJSONBackend] Spark scaffold schemas not found");
    const g = { node: this.node, account: this.account, guardian: o }, { createCoValueForSpark: I } = await Promise.resolve().then(() => Re), { coValue: c } = await I(g, null, {
      schema: n,
      cotype: "comap",
      data: { guardian: o.id },
      dbEngine: this.dbEngine
    }), { coValue: C } = await I(g, null, {
      schema: s,
      cotype: "comap",
      data: { capabilities: c.id },
      dbEngine: this.dbEngine
    }), { coValue: B } = await I(g, null, {
      schema: a,
      cotype: "comap",
      data: {},
      dbEngine: this.dbEngine
    }), { coValue: Q } = await I(g, null, {
      schema: r,
      cotype: "comap",
      data: { name: A, os: C.id, vibes: B.id },
      dbEngine: this.dbEngine
    });
    return await this._registerSparkInAccount(Q.id), {
      id: Q.id,
      name: A,
      guardian: o.id
    };
  }
  /**
   * Read Spark(s)
   * @param {string} [id] - Specific spark co-id
   * @param {string} [schema] - Schema co-id (optional)
   * @returns {Promise<ReactiveStore|ReactiveStore[]>} Reactive store(s) with spark data
   */
  async readSpark(A, e = null) {
    if (A)
      return await this.read(null, A);
    const i = e || "@maia/schema/data/spark", o = await eA(this, i, { returnType: "coId" });
    if (!o)
      throw new Error(`[CoJSONBackend] Spark schema not found: ${i}`);
    return await this.read(o);
  }
  /**
   * Update Spark
   * @param {string} id - Spark co-id
   * @param {Object} data - Update data (name only; group is resolved via os.capabilities.guardian)
   * @returns {Promise<Object>} Updated spark
   */
  async updateSpark(A, e) {
    const { group: i, ...o } = e || {}, r = await eA(this, { fromCoValue: A }, { returnType: "coId" });
    return await this.update(r, A, o);
  }
  /**
   * Delete Spark
   * Removes spark from account.sparks and deletes Spark CoMap
   * @param {string} id - Spark co-id
   * @returns {Promise<Object>} Deletion result
   */
  async deleteSpark(A) {
    const e = await eA(this, { fromCoValue: A }, { returnType: "coId" });
    return await this.delete(e, A), await this._unregisterSparkFromAccount(A), { success: !0, id: A };
  }
  /**
   * Register spark in account.sparks CoMap
   * Stores spark keyed by co-id: account.sparks[sparkCoId] = sparkCoId
   * Uses read() + waitForStoreReady (proper $store architecture)
   * @private
   * @param {string} sparkCoId - Spark co-id (key and value)
   */
  async _registerSparkInAccount(A) {
    let e = this.account.get("sparks"), i;
    if (e) {
      const o = await sA(this, e, null, null, null, { deepResolve: !1 });
      await dA(o, e, 15e3);
      const r = this.node.getCoValue(e);
      r && this.isAvailable(r) && (i = this.getCurrentContent(r));
    }
    if (!i && !e) {
      const r = await eA(this, "@maia/schema/os/sparks-registry", { returnType: "coId" }) || yA.META_SCHEMA, { createCoValueForSpark: n } = await Promise.resolve().then(() => Re), { coValue: s } = await n(this, "@maia", {
        schema: r,
        cotype: "comap",
        data: {},
        dbEngine: this.dbEngine
      });
      i = s, this.account.set("sparks", i.id);
    }
    if (!i || typeof i.set != "function")
      throw new Error(`[_registerSparkInAccount] account.sparks not available. sparksId=${e || "null"}`);
    i.set(A, A);
  }
  /**
   * Unregister spark from account.sparks CoMap
   * Uses read() + waitForStoreReady (proper $store architecture)
   * @private
   * @param {string} sparkCoId - Spark co-id (key)
   */
  async _unregisterSparkFromAccount(A) {
    const e = this.account.get("sparks");
    if (e)
      try {
        const i = await sA(this, e, null, null, null, { deepResolve: !1 });
        await dA(i, e, 5e3);
        const o = this.node.getCoValue(e);
        if (!o || !this.isAvailable(o)) return;
        const r = this.getCurrentContent(o);
        r && typeof r.delete == "function" && r.delete(A);
      } catch {
      }
  }
  // ============================================================================
  // DBAdapter Interface Implementation
  // ============================================================================
  /**
   * Read data from database - directly translates to CoJSON raw operations
   * @param {string} schema - Schema co-id (co_z...) or special exceptions:
   *   - '@group' - For groups (no $schema, use ruleset.type === 'group')
   *   - '@account' - For accounts (no $schema, use headerMeta.type === 'account')
   *   - '@metaSchema' - For meta schema
   * @param {string} [key] - Specific key (co-id) for single item
   * @param {string[]} [keys] - Array of co-ids for batch reads
   * @param {Object} [filter] - Filter criteria for collection queries
   * @param {Object} [options] - Options for deep resolution
   * @param {boolean} [options.deepResolve=true] - Enable/disable deep resolution (default: true)
   * @param {number} [options.maxDepth=10] - Maximum depth for recursive resolution (default: 10)
   * @param {number} [options.timeoutMs=5000] - Timeout for waiting for nested CoValues (default: 5000)
   * @param {Object} [options.resolveReferences] - Configuration for resolving CoValue references (e.g., { fields: ['source', 'target'] })
   * @param {Object} [options.map] - Map transformation config (e.g., { sender: '$$source.role', recipient: '$$target.role' })
   * @returns {Promise<ReactiveStore|ReactiveStore[]>} Reactive store(s) that hold current value and notify on updates
   */
  async read(A, e, i, o, r = {}) {
    const {
      deepResolve: n = !0,
      maxDepth: s = 15,
      // TODO: temporarily scaled up from 10 for @maia spark detail deep resolution
      timeoutMs: a = 5e3,
      resolveReferences: g = null,
      map: I = null,
      onChange: c = null
    } = r, C = { deepResolve: n, maxDepth: s, timeoutMs: a, resolveReferences: g, map: I, onChange: c };
    return i && Array.isArray(i) ? await Promise.all(i.map((Q) => sA(this, Q, A, null, A, C))) : e ? await sA(this, e, A, null, A, C) : A ? await sA(this, null, A, o, null, C) : await sA(this, null, null, o, null, C);
  }
  /**
   * Read a single CoValue by ID and wrap in ReactiveStore
   * Waits for CoValue to be loaded before returning store (operations API abstraction)
   * @private
   * @param {string} coId - CoValue ID
   * @param {string} [schemaHint] - Schema hint for special types (@group, @account, @metaSchema)
   * @returns {Promise<ReactiveStore>} ReactiveStore with CoValue data (already loaded)
   */
  async _readSingleItem(A, e = null) {
    return await sA(this, A, e, null, e);
  }
  /**
   * Wait for a ReactiveStore to be ready (loaded and not in error state)
   * Used internally by _readSingleItem to ensure stores are ready before returning
   * @private
   * @param {ReactiveStore} store - Store to wait for
   * @param {string} coId - CoValue ID (for error messages)
   * @param {number} timeoutMs - Timeout in milliseconds (default: 5000)
   * @returns {Promise<void>} Resolves when store is ready, rejects on timeout or error
   */
  async _waitForStoreReady(A, e, i = 5e3) {
    return await dA(A, e, i);
  }
  /**
   * Get CoList ID from schema index (spark.os.indexes.<schemaCoId>)
   * Supports schema co-ids, human-readable schema names, or collection names (legacy fallback)
   * @private
   * @param {string} collectionNameOrSchema - Collection name (e.g., "todos"), schema co-id (co_z...), or namekey (@maia/schema/data/todos)
   * @returns {Promise<string|null>} CoList ID or null if not found
   */
  async _getCoListId(A) {
    return await po(this, A);
  }
  /**
   * Ensure CoValue is loaded from IndexedDB (jazz-tools pattern)
   * Generic method that works for ANY CoValue type (CoMap, CoList, CoStream, etc.)
   * After re-login, CoValues exist in IndexedDB but aren't loaded into node memory
   * This method explicitly loads them before accessing, just like jazz-tools does
   * @private
   * @param {string} coId - CoValue ID (co-id)
   * @param {Object} [options] - Options
   * @param {boolean} [options.waitForAvailable=false] - Wait for CoValue to become available
   * @param {number} [options.timeoutMs=2000] - Timeout in milliseconds
   * @returns {Promise<CoValueCore|null>} CoValueCore or null if not found
   */
  async _ensureCoValueLoaded(A, e = {}) {
    return await nA(this, A, e);
  }
  /**
   * Read a collection of CoValues by schema
   * @private
   * @param {string} schema - Schema co-id (co_z...)
   * @param {Object} [filter] - Filter criteria
   * @returns {Promise<ReactiveStore>} ReactiveStore with array of CoValue data
   */
  async _readCollection(A, e) {
    return await sA(this, null, A, e);
  }
  /**
   * Read all CoValues (no schema filter)
   * @private
   * @param {Object} [filter] - Filter criteria
   * @returns {Promise<ReactiveStore>} ReactiveStore with array of all CoValue data
   */
  async _readAllCoValues(A) {
    return await sA(this, null, null, A);
  }
  /**
   * Extract CoValue data from CoValueCore and normalize (match IndexedDB format)
   * @private
   * @param {CoValueCore} coValueCore - CoValueCore instance
   * @param {string} [schemaHint] - Schema hint for special types (@group, @account, @metaSchema)
   * @returns {Object} Normalized CoValue data (flattened properties, id field added)
   */
  _extractCoValueData(A, e = null) {
    return ln(this, A, e);
  }
  /**
   * Extract CoValue data as flat object (for SubscriptionEngine and UI)
   * Returns flat objects like {id: '...', text: '...', done: false} instead of normalized format
   * @private
   * @param {CoValueCore} coValueCore - CoValueCore instance
   * @param {string} [schemaHint] - Schema hint for special types
   * @returns {Object|Array} Flat object or array of items
   */
  _extractCoValueDataFlat(A, e = null) {
    return $A(this, A, e);
  }
  /**
   * Extract CoValue data from RawCoValue content
   * @private
   * @param {RawCoValue} content - RawCoValue content
   * @returns {Object} Extracted data
   */
  _extractCoValueDataFromContent(A) {
    return EQ(A);
  }
  /**
   * Check if CoValue data matches filter criteria
   * @private
   * @param {Object|Array} data - CoValue data (object for CoMap, array for CoList)
   * @param {Object} filter - Filter criteria
   * @returns {boolean} True if matches filter
   */
  _matchesFilter(A, e) {
    return dn(A, e);
  }
  /**
   * Create new record - directly creates CoValue using CoJSON raw methods
   * @param {string} schema - Schema co-id (co_z...) for data collections
   * @param {Object} data - Data to create
   * @param {Object} [options] - Optional settings
   * @param {string} [options.spark='@maia'] - Spark name for context (e.g. '@maia', '@Maia')
   * @returns {Promise<Object>} Created record with generated co-id
   */
  async create(A, e, i = {}) {
    return await Gn(this, A, e, i);
  }
  /**
   * Update existing record - directly updates CoValue using CoJSON raw methods
   * @param {string} schema - Schema co-id (co_z...)
   * @param {string} id - Record co-id to update
   * @param {Object} data - Data to update
   * @returns {Promise<Object>} Updated record
   */
  async update(A, e, i) {
    return await NI(this, A, e, i);
  }
  /**
   * Delete record - hard delete using CoJSON native operations
   * Removes item from CoList (hard delete) and clears CoMap content
   * @param {string} schema - Schema co-id (co_z...)
   * @param {string} id - Record co-id to delete
   * @returns {Promise<boolean>} true if deleted successfully
   */
  async delete(A, e) {
    return await ro(this, A, e);
  }
  /**
   * Get raw record from database (without normalization)
   * Used for validation - returns stored data as-is (with $schema metadata, without id)
   * @param {string} id - Record co-id
   * @returns {Promise<Object|null>} Raw stored record or null if not found
   */
  async getRawRecord(A) {
    const e = this.getCoValue(A);
    if (!e || !this.isAvailable(e))
      return null;
    const i = this.getCurrentContent(e), n = (this.getHeader(e)?.meta || null)?.$schema || null;
    if (i && i.get && typeof i.get == "function") {
      const s = {
        $schema: n
        // Metadata for querying/validation
      }, a = i.keys && typeof i.keys == "function" ? i.keys() : Object.keys(i);
      for (const g of a)
        s[g] = i.get && typeof i.get == "function" ? i.get(g) : i[g];
      return s;
    }
    if (i && i.toJSON)
      try {
        return i.toJSON();
      } catch {
        return null;
      }
    return null;
  }
  /**
   * Seed database with configs, schemas, and initial data
   * @param {Object} configs - Config registry {vibe, styles, actors, views, contexts, states, interfaces}
   * @param {Object} schemas - Schema definitions
   * @param {Object} data - Initial application data {todos: [], ...}
   * @returns {Promise<Object>} Summary of what was seeded
   */
  async seed(A, e, i) {
    if (!this.account)
      throw new Error("[CoJSONBackend] Account required for seed");
    return await jw(this.account, this.node, A, e, i || {}, this);
  }
  /**
   * Ensure spark.os (account.sparks[@maia].os) is loaded and ready for schema-dependent operations
   * 
   * Progressive loading: spark.os is NOT required for account loading itself
   * It's only needed for schema resolution, which can happen progressively as spark.os becomes available
   * 
   * This function is called non-blocking during boot - MaiaOS boots immediately without waiting
   * Schema resolution will return null until spark.os is ready, then progressively start working
   * 
   * @param {Object} [options] - Options
   * @param {number} [options.timeoutMs=10000] - Timeout for waiting for spark.os to be ready
   * @returns {Promise<boolean>} True if spark.os is ready, false if failed
   */
  async ensureAccountOsReady(A = {}) {
    const { timeoutMs: e = 1e4 } = A;
    if (!this.account)
      return console.warn("[CoJSONBackend.ensureAccountOsReady] Account not available"), !1;
    const i = performance.now(), o = {
      getOsId: 0,
      createOs: 0,
      osReadRequest: 0,
      osReadResponse: 0,
      osWaitForReady: 0,
      osReadTotal: 0,
      getSchematasId: 0,
      createSchematas: 0,
      schematasReadRequest: 0,
      schematasReadResponse: 0,
      schematasWaitForReady: 0,
      schematasReadTotal: 0,
      total: 0
    }, r = performance.now();
    let n = await KA(this, "@maia");
    if (o.getOsId = performance.now() - r, !n || typeof n != "string" || !n.startsWith("co_z"))
      return console.warn("[CoJSONBackend.ensureAccountOsReady] @maia spark.os not found - migration should have created it"), !1;
    const s = performance.now(), a = await sA(this, n, null, null, null, {
      deepResolve: !1,
      timeoutMs: e
    }), g = performance.now();
    o.osReadRequest = s - i, o.osReadResponse = g - i, o.osReadTotal = g - s;
    const I = performance.now();
    try {
      await dA(a, n, e);
      const p = performance.now();
      o.osWaitForReady = p - I;
    } catch (p) {
      const E = performance.now();
      return o.osWaitForReady = E - I, console.error(`[CoJSONBackend.ensureAccountOsReady] Timeout waiting for spark.os to load: ${p.message}`), !1;
    }
    const c = a.value;
    if (!c || c.error)
      return console.error("[CoJSONBackend.ensureAccountOsReady] spark.os data not available or has error"), !1;
    const C = performance.now();
    let B = c.schematas;
    if (o.getSchematasId = performance.now() - C, !B || typeof B != "string" || !B.startsWith("co_z")) {
      const p = performance.now(), E = this.getCoValue(n);
      if (!E || !E.isAvailable())
        return console.error("[CoJSONBackend.ensureAccountOsReady] spark.os not available for creating schematas"), !1;
      const w = this.getCurrentContent(E);
      if (!w || typeof w.set != "function")
        return console.error("[CoJSONBackend.ensureAccountOsReady] spark.os content not available for creating schematas"), !1;
      const m = await eA(this, "@maia/schema/os/schematas-registry", { returnType: "coId" }) || yA.META_SCHEMA, { createCoValueForSpark: k } = await Promise.resolve().then(() => Re), { coValue: b } = await k(this, "@maia", {
        schema: m,
        cotype: "comap",
        data: {},
        dbEngine: this.dbEngine
      });
      w.set("schematas", b.id), B = b.id, o.createSchematas = performance.now() - p;
      const q = await sA(this, n, null, null, null, {
        deepResolve: !1,
        timeoutMs: 2e3
      });
      try {
        await dA(q, n, 2e3);
        const P = q.value;
        P && !P.error && (B = P.schematas || B);
      } catch {
      }
    }
    if (!B || typeof B != "string" || !B.startsWith("co_z"))
      return console.error("[CoJSONBackend.ensureAccountOsReady] Failed to ensure schematas registry exists"), !1;
    const Q = performance.now(), f = await sA(this, B, null, null, null, {
      deepResolve: !1,
      timeoutMs: e
    }), l = performance.now();
    o.schematasReadRequest = Q - i, o.schematasReadResponse = l - i, o.schematasReadTotal = l - Q;
    const u = performance.now();
    try {
      await dA(f, B, e);
      const p = performance.now();
      o.schematasWaitForReady = p - u;
    } catch (p) {
      const E = performance.now();
      return o.schematasWaitForReady = E - u, console.error(`[CoJSONBackend.ensureAccountOsReady] Timeout waiting for schematas registry to load: ${p.message}`), !1;
    }
    const d = f.value;
    if (!d || d.error)
      return console.error("[CoJSONBackend.ensureAccountOsReady] schematas registry data not available or has error"), !1;
    const h = performance.now();
    return o.total = h - i, !0;
  }
}
const Lr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CoJSONBackend: Ln
}, Symbol.toStringTag, { value: "Module" }));
function qy(t, A) {
  if (!t)
    throw new Error("[createCoJSONAPI] Node required");
  if (!A)
    throw new Error("[createCoJSONAPI] Account required");
  const e = new Ln(t, A, { systemSpark: "@maia" }), i = new qn(e);
  return e.dbEngine = i, {
    /**
     * Execute a database operation
     * @param {Object} payload - Operation payload
     * @param {string} payload.op - Operation name (read, create, update, delete)
     * @param {Object} payload params - Operation-specific parameters
     * @returns {Promise<any>} Operation result
     */
    cojson: async (o) => await i.execute(o)
  };
}
async function Tr(t, A, e) {
  if (!t)
    throw new Error("[createAndPushMessage] dbEngine is required");
  if (!A || !A.startsWith("co_z"))
    throw new Error(`[createAndPushMessage] inboxCoId must be a valid co-id (co_z...), got: ${A}`);
  if (!e || typeof e != "object")
    throw new Error("[createAndPushMessage] messageData must be an object");
  let i = null;
  try {
    const c = (await t.execute({
      op: "schema",
      fromCoValue: A
    })).value;
    if (c && c.items && c.items.$co) {
      const C = c.items.$co;
      if (C.startsWith("co_z"))
        i = C;
      else if (C.startsWith("@maia/schema/")) {
        const B = C.replace("@maia/schema/", ""), f = (await t.execute({
          op: "schema",
          schemaName: B
        })).value;
        f && f.$id && (i = f.$id);
      }
    }
    if (i || (i = await t.execute({
      op: "resolve",
      humanReadableKey: "@maia/schema/message"
    })), !i || !i.startsWith("co_z"))
      throw new Error(`[createAndPushMessage] Failed to get message schema co-id. Inbox schema items.$co: ${c?.items?.$co || "not found"}`);
  } catch (I) {
    throw new Error(`[createAndPushMessage] Failed to get message schema co-id: ${I.message}`);
  }
  if (!await eA(t.backend, i, { returnType: "schema" }))
    throw new Error(`[createAndPushMessage] Message schema not found: ${i}`);
  const r = {
    processed: !1,
    ...e
  };
  if (r.payload && nt(r.payload))
    throw new Error(`[createAndPushMessage] Payload contains unresolved expressions. Only resolved values can be persisted to CoJSON. Payload: ${JSON.stringify(r.payload).substring(0, 200)}`);
  const n = await t.execute({
    op: "create",
    schema: i,
    data: r
  });
  if (!n.ok) {
    const I = n.errors?.map((c) => c.message).join("; ") || "Create failed";
    throw new Error(`[createAndPushMessage] Failed to create message: ${I}`);
  }
  const s = n.data;
  if (!s || !s.id)
    throw new Error("[createAndPushMessage] Failed to create message CoMap - create operation returned no id");
  const a = s.id;
  if (!a.startsWith("co_z"))
    throw new Error(`[createAndPushMessage] Invalid message co-id returned: ${a}`);
  const g = await t.execute({
    op: "push",
    coId: A,
    item: a
  });
  if (!g.ok) {
    const I = g.errors?.map((c) => c.message).join("; ") || "Push failed";
    throw new Error(`[createAndPushMessage] Failed to push message to inbox: ${I}`);
  }
  return a;
}
async function xy(t, A, e) {
  if (!t || !A || !e)
    throw new Error("[processInbox] backend, actorId, and inboxCoId are required");
  if (!t.getCurrentSessionID())
    throw new Error("[processInbox] Cannot get current session ID from backend");
  const o = t.dbEngine;
  if (!o)
    throw new Error("[processInbox] Backend must have dbEngine set");
  let r = null;
  try {
    const g = (await o.execute({
      op: "schema",
      fromCoValue: e
    })).value;
    if (g && g.items && g.items.$co) {
      const I = g.items.$co;
      if (I.startsWith("co_z"))
        r = I;
      else if (I.startsWith("@maia/schema/")) {
        const c = I.replace("@maia/schema/", ""), B = (await o.execute({
          op: "schema",
          schemaName: c
        })).value;
        B && B.$id ? r = B.$id : console.warn(`[processInbox] Failed to resolve message schema reference ${I}`);
      } else
        console.warn(`[processInbox] Unknown message schema reference format: ${I}`);
    }
  } catch (a) {
    console.warn("[processInbox] Failed to get message schema:", a);
  }
  const n = t.readInboxWithSessions(e);
  if (!n || !n.sessions)
    return { messages: [] };
  const s = [];
  for (const [a, g] of Object.entries(n.sessions))
    for (const I of g) {
      if (I.type === "INIT" || I.from === "system")
        continue;
      const C = I._madeAt || 0, B = I._coId;
      if (!B) {
        console.error(
          `[processInbox]  REJECTED legacy plain object message in inbox ${e}. All messages must be CoMap references (co-id strings). Message data: ${JSON.stringify(I).substring(0, 200)}`
        );
        continue;
      }
      try {
        const Q = await sA(t, B, r);
        try {
          await dA(Q, B, 2e3);
        } catch (u) {
          console.warn(`[processInbox] Message CoMap not available: ${B} - ${u.message}`);
          continue;
        }
        const f = Q.value;
        if (!f || f.error) {
          console.warn(`[processInbox] Message CoMap error: ${B} - ${f?.error || "unknown error"}`);
          continue;
        }
        if (!(f.processed === !0)) {
          try {
            const h = await o.execute({
              op: "update",
              schema: r,
              id: B,
              data: { processed: !0 }
            });
            if (!h.ok)
              throw new Error(h.errors?.map((p) => p.message).join("; ") || "Update failed");
            try {
              const p = await sA(t, B, r);
              await dA(p, B, 1e3);
              const E = p.value;
              E && E.processed !== !0 && console.warn(`[processInbox] Update verification failed for ${B} - processed flag is still false`);
            } catch (p) {
              console.warn(`[processInbox] Update verification failed for ${B}:`, p.message);
            }
          } catch (h) {
            console.error(`[processInbox] Failed to mark message ${B} as processed:`, h);
          }
          const u = {}, d = Object.keys(f);
          for (const h of d)
            h !== "processed" && !h.startsWith("_") && h !== "id" && h !== "$schema" && h !== "hasProperties" && h !== "properties" && (u[h] = f[h]);
          if (!u.type) {
            console.error(
              `[processInbox]  REJECTED message ${B} - missing required 'type' field. Keys found: [${d.join(", ")}]. All values: ${JSON.stringify(f).substring(0, 300)}`
            );
            continue;
          }
          s.push({
            ...u,
            _coId: B,
            // Keep co-id for reference
            _sessionID: a,
            _madeAt: C
          });
        }
      } catch (Q) {
        console.error(`[processInbox] Failed to read message CoMap ${B}:`, Q);
      }
    }
  return s.sort((a, g) => (a._madeAt || 0) - (g._madeAt || 0)), {
    messages: s
  };
}
const Ly = 1e5, Ty = 10;
function kt(t) {
  return t.readyState === 1;
}
function Or(t) {
  return t.bufferedAmount > Ly && kt(t);
}
function Oy(t) {
  return new Promise((A) => {
    t.readyState === 1 ? A() : t.addEventListener("open", () => A(), { once: !0 });
  });
}
async function Py(t) {
  for (; Or(t); )
    await new Promise((A) => setTimeout(A, Ty));
}
const { CO_VALUE_PRIORITY: jy, getContentMessageSize: Vy, WEBSOCKET_CONFIG: Ns } = Bn;
class $y {
  constructor(A, e, i, o, r) {
    this.websocket = A, this.batching = e, this.meta = o, this.backlog = [], this.processing = !1, this.closed = !1, this.closeListeners = /* @__PURE__ */ new Set(), this.egressBytesCounter = (r ?? ge.getMeter("cojson-transport-ws")).createCounter("jazz.usage.egress", {
      description: "Total egress bytes",
      unit: "bytes",
      valueType: WA.INT
    }), this.queue = new HB(jy.HIGH, "outgoing", {
      peerRole: i
    }), this.egressBytesCounter.add(0, this.meta);
  }
  push(A) {
    if (A === "Disconnected") {
      this.close();
      return;
    }
    if (!this.closed) {
      if (this.processing) {
        this.queue.push(A);
        return;
      }
      if (kt(this.websocket) && !Or(this.websocket)) {
        this.processMessage(A, !0);
        return;
      }
      this.queue.push(A), this.processQueue().catch((e) => {
        AA.error("Error while processing sendMessage queue", { err: e });
      });
    }
  }
  async processQueue() {
    const { websocket: A } = this;
    this.processing = !0;
    let e = this.queue.pull();
    for (; e; ) {
      if (this.closed)
        return;
      kt(A) || await Oy(A), Or(A) && await Py(A), kt(A) && (this.processMessage(e), e = this.queue.pull());
    }
    this.sendMessagesInBulk(), this.processing = !1;
  }
  processMessage(A, e = !1) {
    A.action === "content" && this.egressBytesCounter.add(Vy(A), this.meta);
    const i = this.serializeMessage(A);
    if (!this.batching || e) {
      this.websocket.send(i);
      return;
    }
    const o = i.length, r = this.backlog.length + o;
    this.backlog.length > 0 && r > Ns.MAX_OUTGOING_MESSAGES_CHUNK_BYTES && this.sendMessagesInBulk(), this.appendMessage(i), o >= Ns.MAX_OUTGOING_MESSAGES_CHUNK_BYTES && this.sendMessagesInBulk();
  }
  serializeMessage(A) {
    return JSON.stringify(A);
  }
  appendMessage(A) {
    this.backlog.push(A);
  }
  sendMessagesInBulk() {
    this.backlog.length > 0 && kt(this.websocket) && (this.websocket.send(this.backlog.join(`
`)), this.backlog.length = 0);
  }
  drain() {
    for (; this.queue.pull(); )
      ;
  }
  setBatching(A) {
    this.batching = A;
  }
  onClose(A) {
    this.closeListeners.add(A);
  }
  close() {
    if (this.closed)
      return;
    let A = this.queue.pull();
    for (; A; )
      this.processMessage(A), A = this.queue.pull();
    this.closed = !0, this.sendMessagesInBulk();
    for (const e of this.closeListeners)
      e();
    this.closeListeners.clear();
  }
}
function Wy(t) {
  if (typeof t != "string")
    return {
      ok: !1,
      error: new Error("Expected a string")
    };
  try {
    return {
      ok: !0,
      messages: t.split(`
`).map((A) => JSON.parse(A))
    };
  } catch (A) {
    return AA.error("Error while deserializing messages", { err: A }), {
      ok: !1,
      error: A
    };
  }
}
const { ConnectedPeerChannel: zy, getContentMessageSize: _y } = Bn;
function Zy(t, A, e) {
  if (!t)
    return {
      reset() {
      },
      clear() {
      }
    };
  let i = null;
  return {
    reset() {
      i && clearTimeout(i), i = setTimeout(() => {
        e();
      }, A);
    },
    clear() {
      i && clearTimeout(i);
    }
  };
}
function Xy(t = () => {
}) {
  let A = !1;
  return () => {
    A || (A = !0, t());
  };
}
function AD({ id: t, websocket: A, role: e, expectPings: i = !0, batchingByDefault: o = !0, deletePeerStateOnClose: r = !1, pingTimeout: n = 1e4, onSuccess: s, onClose: a, meter: g, meta: I }) {
  const c = (g ?? ge.getMeter("cojson-transport-ws")).createCounter("jazz.usage.ingress", {
    description: "Total ingress bytes from peer",
    unit: "bytes",
    valueType: WA.INT
  });
  c.add(0, I);
  const C = new zy(), B = Xy(a);
  function Q() {
    A.removeEventListener("message", p), A.removeEventListener("close", f), A.removeEventListener("error", l), u.clear(), d.drain();
  }
  function f() {
    C.push("Disconnected"), B(), Q();
  }
  function l(E) {
    E instanceof Error && E.message && AA.warn("WebSocket error", { err: E }), f();
  }
  A.addEventListener("close", f), A.addEventListener("error", l);
  const u = Zy(i, n, () => {
    f(), AA.warn("Ping timeout from peer", {
      peerId: t,
      peerRole: e
    });
  }), d = new $y(A, o, e, I, g);
  let h = !0;
  function p(E) {
    if (u.reset(), E.data === "")
      return;
    const w = Wy(E.data);
    if (!w.ok) {
      AA.warn("Error while deserializing messages", { err: w.error });
      return;
    }
    h && (s?.(), h = !1);
    const { messages: y } = w;
    y.length > 1 && d.setBatching(!0);
    for (const m of y)
      m && "action" in m && (C.push(m), m.action === "content" && c.add(_y(m), I));
  }
  return A.addEventListener("message", p), d.onClose(() => {
    Q(), B(), A.readyState === 0 ? A.addEventListener("open", function() {
      A.close();
    }, { once: !0 }) : A.readyState === 1 && A.close();
  }), {
    id: t,
    incoming: C,
    outgoing: d,
    role: e,
    persistent: !r
  };
}
class eD {
  constructor(A) {
    this.enabled = !1, this.closed = !0, this.connected = !1, this.currentPeer = void 0, this.unsubscribeNetworkChange = void 0, this.reconnectionAttempts = 0, this.onConnectionChangeListeners = /* @__PURE__ */ new Set(), this.waitUntilConnected = async () => {
      if (this.closed)
        return new Promise((e) => {
          const i = (o) => {
            o && (e(), this.onConnectionChangeListeners.delete(i));
          };
          this.onConnectionChangeListeners.add(i);
        });
    }, this.subscribe = (e) => {
      this.onConnectionChangeListeners.add(e), e(!this.closed);
    }, this.unsubscribe = (e) => {
      this.onConnectionChangeListeners.delete(e);
    }, this.startConnection = async () => {
      if (this.enabled) {
        if (this.currentPeer) {
          this.removePeer(this.currentPeer), this.currentPeer.outgoing.close(), this.reconnectionAttempts++;
          const e = this.reconnectionTimeout * this.reconnectionAttempts;
          AA.debug(`Websocket disconnected, trying to reconnect in ${e}ms`), await this.waitForOnline(e);
        }
        this.enabled && (this.currentPeer = AD({
          websocket: new this.WebSocketConstructor(this.peer),
          pingTimeout: this.pingTimeout,
          id: this.peer,
          role: "server",
          onClose: () => {
            this.closed = !0, this.connected = !1;
            for (const e of this.onConnectionChangeListeners)
              e(!1);
            this.startConnection();
          },
          onSuccess: () => {
            this.closed = !1, this.connected = !0;
            for (const e of this.onConnectionChangeListeners)
              e(!0);
            AA.debug("Websocket connection successful"), this.reconnectionAttempts = 0;
          }
        }), this.addPeer(this.currentPeer));
      }
    }, this.enable = () => {
      this.enabled || (this.connected = !0, this.enabled = !0, this.startConnection());
    }, this.disable = () => {
      this.enabled && (this.enabled = !1, this.reconnectionAttempts = 0, this.unsubscribeNetworkChange?.(), this.unsubscribeNetworkChange = void 0, this.currentPeer && (this.removePeer(this.currentPeer), this.currentPeer.outgoing.close(), this.currentPeer = void 0));
    }, this.peer = A.peer, this.reconnectionTimeout = A.reconnectionTimeout || 500, this.addPeer = A.addPeer, this.removePeer = A.removePeer, this.WebSocketConstructor = A.WebSocketConstructor || WebSocket, this.pingTimeout = A.pingTimeout || 1e4;
  }
  // Basic implementation for environments that don't support network change events (e.g. Node.js)
  // Needs to be extended to handle platform specific APIs
  onNetworkChange(A) {
    return () => {
    };
  }
  waitForOnline(A) {
    return new Promise((e) => {
      const i = this.onNetworkChange((n) => {
        n && o();
      });
      function o() {
        clearTimeout(r), i?.(), e();
      }
      const r = setTimeout(o, A);
    });
  }
}
const Ms = {};
let Ee = {
  connected: !1,
  syncing: !1,
  error: null,
  status: null
  // 'authenticating' | 'loading-account' | 'syncing' | 'connected' | 'error'
};
const Pr = /* @__PURE__ */ new Set();
function tD(t) {
  return Pr.add(t), t(Ee), () => Pr.delete(t);
}
function ii() {
  for (const t of Pr)
    t(Ee);
}
function Wt(t = null) {
  const A = typeof window < "u" && window.location.hostname === "localhost", e = t || typeof window < "u" && window.__PUBLIC_API_DOMAIN__ || Ms?.PUBLIC_API_DOMAIN || typeof process < "u" && process.env?.PUBLIC_API_DOMAIN;
  let i;
  if (typeof window > "u") {
    if (!t)
      return { peers: [], setNode: () => {
      }, wsPeer: null };
    i = `${t.includes("localhost") || t.includes("127.0.0.1") ? "ws:" : "wss:"}//${t}/sync`;
  } else A ? i = `${window.location.protocol === "https:" ? "wss:" : "ws:"}//${window.location.host}/sync` : e ? i = `${window.location.protocol === "https:" ? "wss:" : "ws:"}//${e}/sync` : (console.warn(" [SYNC] Sync domain not set! Falling back to same origin. Sync may not work."), i = `${window.location.protocol === "https:" ? "wss:" : "ws:"}//${window.location.host}/sync`);
  A || (console.log(`   Sync Domain: ${e || "(not set - using same origin fallback)"}`), console.log(`   Source: ${t ? "kernel" : typeof window < "u" && window.__PUBLIC_API_DOMAIN__ ? "runtime env" : Ms?.PUBLIC_API_DOMAIN ? "build-time env" : "fallback"}`));
  let o;
  const r = [];
  let n = null, s = !1, a = null, g = 0;
  const I = 6e4, c = new Promise((B) => {
    a = B;
  });
  if (!i)
    return { peers: [], setNode: () => {
    }, wsPeer: null };
  const C = new eD({
    peer: i,
    reconnectionTimeout: 5e3,
    addPeer: (B) => {
      n && (clearTimeout(n), n = null), r.push(B), o && o.syncManager.addPeer(B);
    },
    removePeer: (B) => {
      const Q = r.indexOf(B);
      Q > -1 && r.splice(Q, 1);
      const f = Date.now();
      Ee.connected && f - g > I && (g = f, console.warn(" [SYNC] Peer removed, connection lost")), s = !1, Ee = { connected: !1, syncing: !1, error: "Disconnected", status: "error" }, ii();
    }
  });
  return C.subscribe((B) => {
    if (B && !s)
      s = !0, g = 0, Ee = { connected: !0, syncing: !0, error: null, status: "syncing" }, ii(), a && (a(), a = null);
    else if (!B && s) {
      s = !1;
      const Q = Date.now();
      Q - g > I && (g = Q, console.warn(" [SYNC] WebSocket connection lost")), Ee = { connected: !1, syncing: !1, error: "Offline", status: "error" }, ii();
    }
  }), typeof window < "u" && (n = setTimeout(() => {
    Ee.connected || (console.error(" [SYNC] Connection timeout after 10s. Check:"), console.error(`   1. Sync service is running: curl https://${e || window.location.hostname}/health`), console.error(`   2. PUBLIC_API_DOMAIN is set correctly: ${e || "NOT SET"}`), console.error(`   3. WebSocket URL: ${i}`), Ee = { connected: !1, syncing: !1, error: "Connection timeout", status: "error" }, ii());
  }, 1e4)), C.enable(), {
    peers: r,
    wsPeer: C,
    // Wait for WebSocket to be actually connected (not just peer object created)
    waitForPeer: () => new Promise((B) => {
      if (s && r.length > 0) {
        B(!0);
        return;
      }
      let Q = !1;
      const f = setTimeout(() => {
        Q || (Q = !0, B(!1));
      }, 2e3);
      c.then(() => {
        !Q && r.length > 0 && (Q = !0, clearTimeout(f), B(!0));
      }).catch(() => {
        Q || (Q = !0, clearTimeout(f), B(!1));
      });
    }),
    setNode: (B) => {
      if (o = B, r.length > 0)
        for (const Q of r)
          o.syncManager.addPeer(Q);
    }
  };
}
const Mo = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CoCache: Sr,
  CoJSONBackend: Ln,
  EXCEPTION_SCHEMAS: yA,
  checkCotype: Rt,
  createAccountWithSecret: Yn,
  createAndPushMessage: Tr,
  createCoJSONAPI: qy,
  createCoList: II,
  createCoMap: gI,
  createCoStream: cI,
  createCoValueForSpark: pA,
  createSchemaMeta: at,
  ensureCoValueLoaded: nA,
  getAllSchemas: wo,
  getCoListId: po,
  getGlobalCoCache: Wg,
  getSchema: Xg,
  getSchemaIndexColistId: En,
  getSparkCapabilityGroupIdFromSparkCoId: Dn,
  loadAccount: Un,
  processInbox: xy,
  resolve: eA,
  resolveCoValueReactive: Nr,
  resolveQueryReactive: _g,
  resolveReactive: ee,
  resolveSchemaReactive: bt,
  schemaMigration: pn,
  seedAgentAccount: mI,
  setupSyncPeers: Wt,
  subscribeSyncState: tD,
  waitForReactiveResolution: ke,
  waitForStoreReady: dA
}, Symbol.toStringTag, { value: "Module" })), hA = {
  INITIALIZING: "initializing",
  // Setting up subscriptions, loading initial data
  RENDERING: "rendering",
  // Currently rendering (prevents nested renders)
  READY: "ready",
  // Initial render complete, ready for updates
  UPDATING: "updating"
  // Data changed, queued for rerender
};
class iD {
  constructor(A, e, i, o, r = null) {
    this.styleEngine = A, this.viewEngine = e, this.registry = i, this.toolEngine = o, this.stateEngine = r, this.actors = /* @__PURE__ */ new Map(), this.pendingMessages = /* @__PURE__ */ new Map(), this.dbEngine = null, this.os = null, this._containerActors = /* @__PURE__ */ new Map(), this._vibeActors = /* @__PURE__ */ new Map(), this.viewEngine.setActorEngine(this), this.pendingRerenders = /* @__PURE__ */ new Set(), this.batchTimer = null;
  }
  async updateContextCoValue(A, e) {
    if (!A.contextCoId || !this.dbEngine) {
      A.contextCoId || console.warn(`[ActorEngine] Actor ${A.id} has no contextCoId`);
      return;
    }
    const i = A.contextSchemaCoId || await eA(this.dbEngine.backend, { fromCoValue: A.contextCoId }, { returnType: "coId" }), o = {};
    for (const [n, s] of Object.entries(e))
      o[n] = s === void 0 ? null : s;
    const r = await this.dbEngine.execute({
      op: "update",
      schema: i,
      id: A.contextCoId,
      data: o
    });
    if (!r.ok) {
      const n = r.errors?.map((s) => s.message).join("; ") || "Update failed";
      throw new Error(`[ActorEngine] Context update failed: ${n}`);
    }
  }
  async _loadActorConfigs(A) {
    if (!A.view) throw new Error("[ActorEngine] Actor config must have 'view' property");
    const e = A.id || "temp", i = [], o = ee(this.dbEngine.backend, { fromCoValue: A.view }, { returnType: "coId" }), r = await ke(o, { timeoutMs: 1e4 }), n = r.schemaCoId;
    if (!n)
      throw new Error(`[ActorEngine] Failed to extract schema co-id from view CoValue ${A.view}: ${r.error || "Schema not found"}`);
    await this.dbEngine.execute({ op: "read", schema: null, key: A.view });
    const s = await this.dbEngine.execute({ op: "read", schema: n, key: A.view }), a = s.value, g = s.subscribe((p) => {
      const E = this.actors.get(e);
      E && (E.viewDef = p, E._renderState === hA.READY && (E._renderState = hA.UPDATING, this._scheduleRerender(E.id)));
    }, { skipInitial: !0 });
    i.push(g);
    const I = [];
    let c = null;
    A.context && (c = (async () => {
      const p = A.context;
      let E = p;
      if (typeof p == "string" && !p.startsWith("co_z")) {
        const m = await this.dbEngine.execute({ op: "resolve", humanReadableKey: p });
        if (m && m.startsWith("co_z"))
          E = m;
        else
          throw new Error(`[ActorEngine] Failed to resolve context reference "${p}"`);
      }
      const w = await eA(this.dbEngine.backend, { fromCoValue: E }, { returnType: "coId" }), y = await this.dbEngine.execute({
        op: "read",
        schema: w,
        key: E
      });
      return { context: y, contextCoId: E, contextSchemaCoId: w, store: y };
    })(), I.push(c));
    let C = null, B = null;
    A.style && (C = (async () => {
      try {
        const p = await eA(this.dbEngine.backend, { fromCoValue: A.style }, { returnType: "coId" }), E = await this.dbEngine.execute({ op: "read", schema: p, key: A.style }), w = E.subscribe(async (y) => {
          const m = this.actors.get(e);
          if (m && this.styleEngine)
            try {
              const k = await this.styleEngine.getStyleSheets(m.config, m.id);
              m.shadowRoot.adoptedStyleSheets = k, m._renderState === hA.READY && (m._renderState = hA.UPDATING, this._scheduleRerender(m.id));
            } catch (k) {
              console.error("[ActorEngine] Failed to update stylesheets after style change:", k);
            }
        }, { skipInitial: !0 });
        return i.push(w), E;
      } catch (p) {
        return console.error("[ActorEngine] Failed to load style:", p), null;
      }
    })(), I.push(C)), A.brand && (B = (async () => {
      try {
        const p = await eA(this.dbEngine.backend, { fromCoValue: A.brand }, { returnType: "coId" }), E = await this.dbEngine.execute({ op: "read", schema: p, key: A.brand }), w = E.subscribe(async (y) => {
          const m = this.actors.get(e);
          if (m && this.styleEngine)
            try {
              const k = await this.styleEngine.getStyleSheets(m.config, m.id);
              m.shadowRoot.adoptedStyleSheets = k, m._renderState === hA.READY && (m._renderState = hA.UPDATING, this._scheduleRerender(m.id));
            } catch (k) {
              console.error("[ActorEngine] Failed to update stylesheets after brand change:", k);
            }
        }, { skipInitial: !0 });
        return i.push(w), E;
      } catch (p) {
        return console.error("[ActorEngine] Failed to load brand:", p), null;
      }
    })(), I.push(B));
    let Q = null;
    A.inbox && (Q = (async () => {
      const p = await eA(this.dbEngine.backend, { fromCoValue: A.inbox }, { returnType: "coId" });
      return await this.dbEngine.execute({ op: "read", schema: p, key: A.inbox });
    })(), I.push(Q)), await Promise.all(I);
    let f = null, l = null, u = null;
    if (c) {
      const p = await c;
      f = p.store, l = p.contextCoId, u = p.contextSchemaCoId;
    }
    let d = null, h = null;
    return Q && (h = A.inbox, d = await Q), { viewDef: a, context: f, contextCoId: l, contextSchemaCoId: u, inbox: d, inboxCoId: h, configUnsubscribes: i };
  }
  /**
   * Set up reactive subscriptions for inbox costream
   * @param {Object} actor - Actor instance
   * @param {Object} actorConfig - The actor configuration
   * @returns {Promise<void>}
   * @private
   */
  async _setupMessageSubscriptions(A, e) {
    if (e.inbox)
      try {
        const i = await eA(this.dbEngine.backend, { fromCoValue: e.inbox }, { returnType: "coId" }), r = (await this.dbEngine.execute({
          op: "read",
          schema: i,
          key: e.inbox
        })).subscribe((n) => {
          this.actors.has(A.id) && n?.items && this.processMessages(A.id);
        });
        A._configUnsubscribes && A._configUnsubscribes.push(r);
      } catch (i) {
        console.error("[ActorEngine] Failed to subscribe to inbox:", i);
      }
  }
  /**
   * Initialize actor state (state machine)
   * @param {Object} actor - Actor instance
   * @param {Object} actorConfig - The actor configuration
   * @returns {Promise<void>}
   * @private
   */
  async _initializeActorState(A, e) {
    if (this.stateEngine && e.state && !A.machine)
      try {
        const i = ee(this.dbEngine.backend, { fromCoValue: e.state }, { returnType: "coId" }), o = await ke(i, { timeoutMs: 1e4 }), r = o.schemaCoId;
        if (!r)
          throw new Error(`[ActorEngine] Failed to extract schema co-id from state CoValue ${e.state}: ${o.error || "Schema not found"}`);
        const n = await this.dbEngine.execute({
          op: "read",
          schema: r,
          key: e.state
        }), s = n.value, a = A.id, g = n.subscribe(async (I) => {
          const c = this.actors.get(a);
          if (c && this.stateEngine)
            try {
              c.machine && this.stateEngine.destroyMachine(c.machine.id), c.machine = await this.stateEngine.createMachine(I, c), c._renderState === hA.READY && (c._renderState = hA.UPDATING, this._scheduleRerender(a));
            } catch (C) {
              console.error("[ActorEngine] Failed to update state machine:", C);
            }
        }, { skipInitial: !0 });
        A._configUnsubscribes && A._configUnsubscribes.push(g), A.machine = await this.stateEngine.createMachine(s, A);
      } catch (i) {
        console.error("[ActorEngine] Failed to load state machine:", i);
      }
  }
  // Query resolution handled by backend unified store automatically
  /**
   * Determine if an actor is a service actor (orchestrator) vs UI actor (presentation)
   * Service actors: Have role "agent" OR have minimal view (only renders child actors via $slot)
   * UI actors: Have full view (render actual UI components)
   * @param {Object} actorConfig - Actor configuration
   * @param {Object} viewDef - View definition (optional, will be loaded if not provided)
   * @returns {Promise<boolean>} True if service actor, false if UI actor
   * @private
   */
  async _isServiceActor(A, e = null) {
    if (A.role === "agent" || !A.view) return !0;
    if (!e)
      try {
        try {
          const r = ee(this.dbEngine.backend, { fromCoValue: A.view }, { returnType: "coId" });
          if (!(await ke(r, { timeoutMs: 1e4 })).schemaCoId)
            return !1;
        } catch {
          return !1;
        }
        e = (await this.dbEngine.execute({ op: "read", schema: viewSchemaCoId, key: A.view })).value;
      } catch {
        return !1;
      }
    const i = e.content || e.root || e;
    return !i || i.$slot && !i.children || i.children?.every((o) => o.$slot || o.children?.every((r) => r.$slot)) ? !0 : !(i.tag && (i.text || i.value || i.$on || i.children?.some((o) => o.tag && (o.text || o.value || o.$on))));
  }
  /**
   * Create a child actor lazily if it doesn't exist yet
   * Only creates the child actor when it's actually needed (referenced by context.currentView)
   * @param {Object} actor - Parent actor instance
   * @param {string} namekey - Child actor namekey (e.g., "list", "kanban")
   * @param {string} [vibeKey] - Optional vibe key for tracking child actors
   * @returns {Promise<Object|null>} The child actor instance, or null if not found/created
   * @private
   */
  async _createChildActorIfNeeded(A, e, i = null) {
    if (A.children?.[e]) return A.children[e];
    A.children || (A.children = {});
    const o = A.context.value;
    if (!o["@actors"]?.[e]) return null;
    const r = o["@actors"][e];
    if (!r.startsWith("co_z"))
      throw new Error(`[ActorEngine] Child actor ID must be co-id: ${r}`);
    try {
      const n = ee(this.dbEngine.backend, { fromCoValue: r }, { returnType: "coId" }), s = await ke(n, { timeoutMs: 1e4 }), a = s.schemaCoId;
      if (!a)
        throw new Error(`[ActorEngine] Failed to extract schema co-id from child actor CoValue ${r}: ${s.error || "Schema not found"}`);
      const I = (await this.dbEngine.execute({ op: "read", schema: a, key: r })).value;
      I.$id !== r && (I.$id = r);
      const c = document.createElement("div");
      c.dataset.namekey = e, c.dataset.childActorId = r;
      const C = await this.createActor(I, c, i);
      return C.namekey = e, A.children[e] = C, C;
    } catch (n) {
      return console.error("[ActorEngine] Failed to create child actor:", n), null;
    }
  }
  async createActor(A, e, i = null) {
    const o = A.$id || A.id;
    if (this.actors.has(o))
      return i ? await this.reuseActor(o, e, i) : this.actors.get(o);
    typeof window < "u" && window._maiaDebugFreeze && console.debug("[ActorEngine] createActor", o, i);
    const r = e.attachShadow({ mode: "open" }), n = await this.styleEngine.getStyleSheets(A, o), { viewDef: s, context: a, contextCoId: g, contextSchemaCoId: I, inbox: c, inboxCoId: C, tempSubscriptions: B, configUnsubscribes: Q } = await this._loadActorConfigs(A), f = await this._isServiceActor(A, s) ? "service" : "ui", l = {
      id: o,
      config: A,
      shadowRoot: r,
      context: a,
      contextCoId: g,
      contextSchemaCoId: I,
      containerElement: e,
      actorEngine: this,
      viewDef: s,
      actorType: f,
      vibeKey: i,
      inbox: c,
      inboxCoId: C,
      messageTypes: A.messageTypes || null,
      // REQUIRED: Message types this actor accepts
      _renderState: hA.INITIALIZING,
      // Start in INITIALIZING state
      children: {},
      _configUnsubscribes: Q || []
    };
    if (await this._setupMessageSubscriptions(l, A), this.actors.set(o, l), l.context && typeof l.context.subscribe == "function") {
      let u = JSON.stringify(l.context.value || {});
      l._contextUnsubscribe = l.context.subscribe((d) => {
        const h = JSON.stringify(d || {}), p = h !== u;
        u = h, l._renderState === hA.READY && p && (l._renderState = hA.UPDATING, this._scheduleRerender(o));
      }, { skipInitial: !0 });
    }
    if (e && (this._containerActors.has(e) || this._containerActors.set(e, /* @__PURE__ */ new Set()), this._containerActors.get(e).add(o)), i && this.registerActorForVibe(o, i), await this._initializeActorState(l, A), l._renderState = hA.RENDERING, await this.viewEngine.render(s, l.context, r, n, o), l._renderState = hA.READY, l._needsPostInitRerender && (delete l._needsPostInitRerender, this._scheduleRerender(o)), this.pendingMessages.has(o)) {
      for (const u of this.pendingMessages.get(o))
        await this.sendMessage(o, u);
      this.pendingMessages.delete(o);
    }
    return l;
  }
  /**
   * Schedule a rerender for an actor (batched via microtask queue)
   * Following Svelte's batching pattern: multiple updates in same tick = one rerender
   * CRITICAL: Set-based deduplication ensures each actor only rerenders once per batch
   * This prevents doubled rendering when multiple subscriptions fire simultaneously
   * @param {string} actorId - The actor ID to rerender
   */
  _scheduleRerender(A) {
    this.actors.has(A) && (this.pendingRerenders.add(A), this.batchTimer || (this.batchTimer = queueMicrotask(async () => {
      this.batchTimer = null, await this._flushRerenders();
    })));
  }
  /**
   * Flush all pending rerenders in batch
   * Processes all actors that need rerendering in one microtask
   * CRITICAL: Set-based deduplication ensures each actor only rerenders once
   * This prevents doubled rendering when multiple subscriptions fire simultaneously
   */
  async _flushRerenders() {
    const A = Array.from(this.pendingRerenders);
    this.pendingRerenders.clear();
    const e = A.filter((i) => this.actors.has(i));
    await Promise.all(e.map((i) => this.rerender(i)));
  }
  /**
   * Rerender an actor (private implementation - only called by _flushRerenders)
   * @param {string} actorId - The actor ID to rerender
   * @private
   */
  async rerender(A) {
    const e = this.actors.get(A);
    if (!e || e._renderState !== hA.UPDATING && e._renderState !== hA.READY)
      return;
    e._renderState = hA.RENDERING;
    const i = ee(this.dbEngine.backend, { fromCoValue: e.config.view }, { returnType: "coId" }), o = await ke(i, { timeoutMs: 1e4 }), r = o.schemaCoId;
    if (!r)
      throw new Error(`[ActorEngine] Failed to extract schema co-id from view CoValue ${e.config.view}: ${o.error || "Schema not found"}`);
    const s = (await this.dbEngine.execute({ op: "read", schema: r, key: e.config.view })).value, a = await this.styleEngine.getStyleSheets(e.config, A);
    await this.viewEngine.render(s, e.context, e.shadowRoot, a, A), e._renderState = hA.READY;
  }
  /**
   * Get actor by ID
   * @param {string} actorId - The actor ID
   * @returns {Object|undefined} The actor instance
   */
  getActor(A) {
    return this.actors.get(A);
  }
  /**
   * Register an actor with a vibe key for reuse tracking
   * @param {string} actorId - The actor ID
   * @param {string} vibeKey - The vibe key (e.g., 'todos')
   */
  registerActorForVibe(A, e) {
    e && (this._vibeActors.has(e) || this._vibeActors.set(e, /* @__PURE__ */ new Set()), this._vibeActors.get(e).add(A));
  }
  /**
   * Get all actors for a vibe
   * @param {string} vibeKey - The vibe key (e.g., 'todos')
   * @returns {Set<string>|undefined} Set of actor IDs for the vibe
   */
  getActorsForVibe(A) {
    return this._vibeActors.get(A);
  }
  /**
   * Reuse an existing actor by reattaching it to a new container
   * @param {string} actorId - The actor ID
   * @param {HTMLElement} containerElement - The new container to attach to
   * @param {string} vibeKey - The vibe key (e.g., 'todos')
   * @returns {Promise<Object>} The reused actor instance
   */
  async reuseActor(A, e, i) {
    const o = this.actors.get(A);
    if (!o) throw new Error(`[ActorEngine] Cannot reuse actor ${A}`);
    const r = o.containerElement;
    if (o.containerElement = e, r && this._containerActors.has(r)) {
      const n = this._containerActors.get(r);
      n.delete(A), n.size === 0 && this._containerActors.delete(r);
    }
    if (e && (this._containerActors.has(e) || this._containerActors.set(e, /* @__PURE__ */ new Set()), this._containerActors.get(e).add(A)), this.registerActorForVibe(A, i), o.shadowRoot) {
      const n = o.shadowRoot.host;
      n && n !== e && (n.parentNode && n.parentNode.removeChild(n), e.appendChild(n));
    } else
      o.shadowRoot = e.attachShadow({ mode: "open" });
    return o._initialRenderComplete && this._scheduleRerender(A), o;
  }
  /**
   * Destroy an actor
   * @param {string} actorId - The actor ID
   */
  destroyActor(A) {
    const e = this.actors.get(A);
    if (e) {
      typeof window < "u" && window._maiaDebugFreeze && console.debug("[ActorEngine] destroyActor", A), e.shadowRoot.innerHTML = "", this.viewEngine && this.viewEngine.cleanupActor(A), e._contextUnsubscribe && typeof e._contextUnsubscribe == "function" && (e._contextUnsubscribe(), delete e._contextUnsubscribe);
      for (const i of e._configUnsubscribes || [])
        try {
          typeof i == "function" && i();
        } catch {
        }
      if (delete e._configUnsubscribes, e.context && e.context._unsubscribe && typeof e.context._unsubscribe == "function")
        try {
          e.context._unsubscribe();
        } catch (i) {
          console.warn("[ActorEngine] Error cleaning up context store:", i.message);
        }
      if (e.machine && this.stateEngine && this.stateEngine.destroyMachine(e.machine.id), e._processedMessageKeys && (e._processedMessageKeys.clear(), delete e._processedMessageKeys), e.containerElement && this._containerActors.has(e.containerElement)) {
        const i = this._containerActors.get(e.containerElement);
        i.delete(A), i.size === 0 && this._containerActors.delete(e.containerElement);
      }
      for (const [i, o] of this._vibeActors.entries())
        if (o.has(A)) {
          o.delete(A), o.size === 0 && this._vibeActors.delete(i);
          break;
        }
      this.actors.delete(A);
    }
  }
  /**
   * Destroy all actors for a given container
   * Used when unloading a vibe to clean up all actors associated with that container
   * @param {HTMLElement} containerElement - The container element
   */
  destroyActorsForContainer(A) {
    const e = this._containerActors.get(A);
    if (e?.size) {
      for (const i of Array.from(e))
        this.destroyActor(i);
      this._containerActors.delete(A);
    }
  }
  /**
   * Destroy all actors for a vibe (complete cleanup)
   * Used for explicit cleanup when needed (e.g., app shutdown)
   * @param {string} vibeKey - The vibe key (e.g., 'todos')
   */
  destroyActorsForVibe(A) {
    const e = this._vibeActors.get(A);
    if (!(!A || !e?.size)) {
      for (const i of Array.from(e))
        this.destroyActor(i);
      this._vibeActors.delete(A);
    }
  }
  // ============================================
  // MESSAGE PASSING SYSTEM (v0.2)
  // ============================================
  /**
   * Send a message to an actor's inbox
   * CRDT handles persistence and sync automatically - no MessageQueue needed
   * @param {string} actorId - Target actor ID
   * @param {Object} message - Message object { type, payload, from, timestamp }
   */
  async sendMessage(A, e) {
    if (e.payload && nt(e.payload))
      throw new Error(`[ActorEngine] Message payload contains unresolved expressions. Only resolved values can be sent between actors. Payload: ${JSON.stringify(e.payload).substring(0, 200)}`);
    const i = this.actors.get(A);
    if (!i) {
      this.pendingMessages.has(A) || this.pendingMessages.set(A, []);
      const o = this.pendingMessages.get(A), r = e.id || `${e.type}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      o.some((n) => n.id === r || !n.id && !e.id && n.type === e.type) || o.push(e);
      return;
    }
    if (i.inboxCoId && this.dbEngine)
      try {
        const o = {
          type: e.type,
          payload: e.payload || {},
          source: e.from || e.source,
          target: A,
          processed: !1
        };
        await Tr(this.dbEngine, i.inboxCoId, o), setTimeout(() => {
          this.processMessages(A).catch((r) => {
            console.error("[ActorEngine] Error processing deferred messages:", r);
          });
        }, 0);
      } catch (o) {
        console.error("[ActorEngine] Failed to send message:", o);
      }
  }
  async sendInternalEvent(A, e, i = {}) {
    if (nt(i))
      throw new Error(`[ActorEngine] Payload contains unresolved expressions. Views must resolve all expressions before sending to inbox. Payload: ${JSON.stringify(i).substring(0, 200)}`);
    const o = this.actors.get(A);
    if (!o || !o.inboxCoId || !this.dbEngine) {
      console.warn("[ActorEngine] Cannot send internal event:", {
        hasActor: !!o,
        hasInboxCoId: !!o?.inboxCoId,
        hasDbEngine: !!this.dbEngine
      });
      return;
    }
    try {
      await Tr(this.dbEngine, o.inboxCoId, {
        type: e,
        payload: i,
        source: A,
        target: A,
        processed: !1
      }), setTimeout(() => {
        this.processMessages(A).catch((r) => {
          console.error("[ActorEngine] Error processing deferred messages:", r);
        });
      }, 0);
    } catch (r) {
      console.error("[ActorEngine] Failed to send internal event:", r);
    }
  }
  /**
   * Validate message type against actor's message contract
   * @param {Object} actor - Actor instance
   * @param {string} messageType - Message type to validate
   * @returns {boolean} True if message type is accepted, false otherwise
   */
  _validateMessageType(A, e) {
    return !A.messageTypes || !Array.isArray(A.messageTypes) ? (console.error(`[ActorEngine] Actor "${A.id}" missing required "messageTypes" array. All actors must declare their message contracts.`), !1) : A.messageTypes.includes(e) ? !0 : (console.error(`[ActorEngine] Message type "${e}" not in actor's message contract. Actor: ${A.id}, Accepted types: ${A.messageTypes.join(", ")}`), !1);
  }
  /**
   * Load message type schema from registry
   * @param {string} messageType - Message type name (e.g., 'CREATE_BUTTON')
   * @returns {Promise<Object|null>} Message type schema or null if not found
   */
  async _loadMessageTypeSchema(A) {
    if (!this.dbEngine || !this.dbEngine.backend)
      return console.warn("[ActorEngine] Cannot load message type schema: dbEngine not available"), null;
    try {
      const i = `@${this.dbEngine?.backend?.systemSpark?.replace(/^@/, "") ?? "maia"}/schema/message/${A}`;
      return await eA(this.dbEngine.backend, i, { returnType: "schema" });
    } catch (e) {
      return console.error(`[ActorEngine] Message type schema not found for "${A}". All message types must have schemas registered.`, e), null;
    }
  }
  /**
   * Validate message payload against message type schema
   * Message type schema IS the payload schema (merged concept)
   * @param {Object} messageTypeSchema - Message type schema definition (this IS the payload schema)
   * @param {Object} payload - Message payload to validate
   * @param {string} messageType - Message type name (for error messages)
   * @returns {Promise<{valid: boolean, errors: Array|null}>} Validation result
   */
  async _validateMessagePayload(A, e, i) {
    if (!A)
      return { valid: !1, errors: [`Message type schema is required for ${i}`] };
    try {
      const { groupInfo: o, ...r } = A;
      return await Vt(r, e || {}, `message payload for ${i}`);
    } catch (o) {
      return console.error(`[ActorEngine] Error validating message payload for ${i}:`, o), { valid: !1, errors: [o.message] };
    }
  }
  async processMessages(A) {
    const e = this.actors.get(A);
    if (!(!e || !e.inboxCoId || !this.dbEngine || e._isProcessing)) {
      e._isProcessing = !0;
      try {
        const o = (await this.dbEngine.execute({ op: "processInbox", actorId: A, inboxCoId: e.inboxCoId })).messages || [];
        for (const r of o)
          if (!(r.type === "INIT" || r.from === "system"))
            try {
              if (!this._validateMessageType(e, r.type)) {
                console.error(`[ActorEngine] Message type "${r.type}" rejected by actor "${A}" - not in message contract`);
                continue;
              }
              const n = await this._loadMessageTypeSchema(r.type);
              if (!n) {
                console.error(`[ActorEngine] Message type schema not found for "${r.type}". All message types must have schemas registered.`);
                continue;
              }
              const s = r.payload || {}, a = await this._validateMessagePayload(n, s, r.type);
              if (!a.valid) {
                const g = a.errors?.map((I) => `  - ${I.instancePath || I.path || "root"}: ${I.message || I}`).join(`
`) || "Unknown validation error";
                console.error(`[ActorEngine] Message payload validation failed for "${r.type}":
${g}
Payload:`, JSON.stringify(s, null, 2));
                continue;
              }
              e.machine && this.stateEngine ? await this.stateEngine.send(e.machine.id, r.type, s) : console.error(`[ActorEngine] Actor ${A} has no state machine. All actors must have state machines. Message type: ${r.type}`);
            } catch (n) {
              console.error("[ActorEngine] Failed to process message:", n);
            }
      } catch (i) {
        console.error("[ActorEngine] Error processing messages:", i);
      } finally {
        e._isProcessing = !1;
      }
    }
  }
}
function jr(t, A) {
  if (!t || typeof t != "object")
    return t;
  if (Array.isArray(t))
    return t.map((i) => jr(i, A));
  const e = {};
  for (const [i, o] of Object.entries(t))
    if (o === "@inputValue") {
      let r = A;
      A.tagName !== "INPUT" && A.tagName !== "TEXTAREA" && (r = (A.closest("form") || A.closest('[class*="form"]') || A.parentElement)?.querySelector("input, textarea") ?? A), e[i] = (r?.value ?? "") || "";
    } else o === "@dataColumn" ? e[i] = A.dataset.column || A.getAttribute("data-column") || null : typeof o == "object" && o !== null ? e[i] = jr(o, A) : e[i] = o;
  return e;
}
function oD(t) {
  return t == null ? "" : String(t).replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;").replace(/\//g, "&#x2F;");
}
function rD(t) {
  return typeof t != "string" ? !1 : [/<script/i, /javascript:/i, /on\w+\s*=/i, /<iframe/i, /<object/i, /<embed/i, /<link/i, /<meta/i, /<style/i].some((A) => A.test(t));
}
class nD {
  constructor(A, e, i) {
    this.evaluator = A, this.actorEngine = e, this.moduleRegistry = i, this.dbEngine = null, this.actorInputCounters = /* @__PURE__ */ new Map();
  }
  async loadView(A) {
    const e = ee(this.dbEngine.backend, { fromCoValue: A }, { returnType: "coId" }), i = await ke(e, { timeoutMs: 1e4 }), o = i.schemaCoId;
    if (!o)
      throw new Error(`[ViewEngine] Failed to extract schema co-id from view CoValue ${A}: ${i.error || "Schema not found"}`);
    return await this.dbEngine.execute({
      op: "read",
      schema: null,
      key: A
    }), await this.dbEngine.execute({
      op: "read",
      schema: o,
      key: A
    });
  }
  async render(A, e, i, o, r) {
    this.actorInputCounters.set(r, 0), i.innerHTML = "", i.adoptedStyleSheets = o, this.currentActorId = r;
    const n = A.content || A;
    if (!e) {
      console.error(`[ViewEngine] Context is null/undefined for actor ${r}`);
      return;
    }
    const s = e.value || {}, a = await this.renderNode(n, { context: s }, r);
    a ? (a.dataset.actorId = r, i.appendChild(a)) : console.error(`[ViewEngine.render] renderNode returned null for actor ${r}`, {
      viewNode: n ? { tag: n.tag, hasContent: !!n.content } : null,
      contextKeys: Object.keys(s)
    });
  }
  async renderNode(A, e, i) {
    if (!A) return null;
    const o = A.tag || "div", r = document.createElement(o);
    if (await this._applyNodeAttributes(r, A, e, i), A.$each) {
      r.innerHTML = "";
      const n = await this.renderEach(A.$each, e, i);
      r.appendChild(n);
    }
    if (A.$on && this.attachEvents(r, A.$on, e, i), A.$slot)
      return await this._renderSlot(A, e, r, i), r;
    if (A.slot)
      throw new Error('[ViewEngine] Old "slot" syntax is no longer supported. Use "$slot" instead.');
    return A.$each || await this._renderNodeChildren(r, A, e, i), r;
  }
  async _applyNodeAttributes(A, e, i, o) {
    if (e.class) {
      if (typeof e.class == "object" && this._isDSLOperation(e.class)) {
        const n = Object.keys(e.class)[0];
        throw new Error(`[ViewEngine] Conditional logic (${n}) is not allowed in class property. Use state machines to compute boolean flags and reference them via context, then use data-attributes and CSS.`);
      }
      if (typeof e.class == "string" && e.class.includes("?") && e.class.includes(":"))
        throw new Error("[ViewEngine] Ternary operators are not allowed in class property. Use state machines to compute values and reference them via context.");
      const r = await this.evaluator.evaluate(e.class, i);
      r && (A.className = r);
    }
    if (e.attrs)
      for (const [r, n] of Object.entries(e.attrs))
        if (r === "data")
          await this._resolveDataAttributes(n, i, A);
        else {
          if (typeof n == "object" && this._isDSLOperation(n)) {
            const a = Object.keys(n)[0];
            throw new Error(`[ViewEngine] Conditional logic (${a}) is not allowed in attributes. Use state machines to compute values and reference them via context.`);
          }
          if (typeof n == "string" && n.includes("?") && n.includes(":"))
            throw new Error("[ViewEngine] Ternary operators are not allowed in attributes. Use state machines to compute values and reference them via context.");
          const s = await this.evaluator.evaluate(n, i);
          if (s != null)
            if (["disabled", "readonly", "checked", "selected", "autofocus", "required", "multiple"].includes(r.toLowerCase())) {
              const g = !!s;
              A[r] = g, g ? A.setAttribute(r, "") : A.removeAttribute(r);
            } else {
              let g = String(s);
              rD(g) && (console.warn(`[ViewEngine] Potentially dangerous HTML detected in attribute ${r}, sanitizing`), g = oD(g)), A.setAttribute(r, g);
            }
        }
    if (e.value !== void 0) {
      if (typeof e.value == "object" && this._isDSLOperation(e.value)) {
        const n = Object.keys(e.value)[0];
        throw new Error(`[ViewEngine] Conditional logic (${n}) is not allowed in value property. Use state machines to compute values and reference them via context.`);
      }
      if (typeof e.value == "string" && e.value.includes("?") && e.value.includes(":"))
        throw new Error("[ViewEngine] Ternary operators are not allowed in value property. Use state machines to compute values and reference them via context.");
      const r = await this.evaluator.evaluate(e.value, i);
      if (A.tagName === "INPUT" || A.tagName === "TEXTAREA") {
        const n = r || "";
        document.activeElement === A || (A.tagName === "INPUT" ? A.value = n : A.textContent = n), this.actorInputCounters.has(o) || this.actorInputCounters.set(o, 0);
        const a = this.actorInputCounters.get(o);
        this.actorInputCounters.set(o, a + 1), A.setAttribute("data-actor-input", `${o}_input_${a}`);
      }
    }
    if (e.text !== void 0) {
      if (typeof e.text == "object" && this._isDSLOperation(e.text)) {
        const n = Object.keys(e.text)[0];
        throw new Error(`[ViewEngine] Conditional logic (${n}) is not allowed in text property. Use state machines to compute values and reference them via context.`);
      }
      if (typeof e.text == "string" && e.text.includes("?") && e.text.includes(":"))
        throw new Error("[ViewEngine] Ternary operators are not allowed in text property. Use state machines to compute values and reference them via context.");
      const r = await this.evaluator.evaluate(e.text, i);
      if (r && typeof r == "object")
        if (r.role && r.id && r.id.startsWith("co_z")) {
          const n = r.id.substring(0, 15) + "...";
          A.textContent = `${r.role} (${n})`;
        } else
          try {
            A.textContent = JSON.stringify(r, null, 2);
          } catch {
            A.textContent = String(r);
          }
      else {
        let n = String(r || "");
        n.startsWith("co_z") && n.length > 15 && (n = n.substring(0, 15) + "..."), A.textContent = n;
      }
    }
  }
  async _renderNodeChildren(A, e, i, o) {
    if (e.children && Array.isArray(e.children))
      for (const r of e.children) {
        if (r && typeof r == "object" && this._isDSLOperation(r)) {
          const s = Object.keys(r)[0];
          throw new Error(`[ViewEngine] Conditional logic (${s}) is not allowed in view templates. Use state machines to compute boolean flags and reference them via context, then use data-attributes and CSS.`);
        }
        const n = await this.renderNode(r, i, o);
        n && A.appendChild(n);
      }
  }
  async _resolveDataAttributes(A, e, i) {
    if (typeof A == "string") {
      if (this._containsConditionalLogic(A))
        throw new Error(`[ViewEngine] Conditional logic is not allowed in data attributes. Use state machines to compute boolean flags and reference them via context. Found: ${A}`);
      if (A.includes(".$$")) {
        const [o, r] = A.split("."), n = await this.evaluator.evaluate(o, e), s = await this.evaluator.evaluate(r, e);
        if (n && typeof n == "object" && s) {
          const a = n[s];
          if (a != null) {
            const g = o.substring(1), I = `data-${this._toKebabCase(g)}`;
            i.setAttribute(I, String(a));
          }
        }
      } else {
        const o = await this.evaluator.evaluate(A, e);
        if (o != null) {
          const r = A.startsWith("$$") ? A.substring(2) : A.substring(1), n = `data-${this._toKebabCase(r)}`;
          i.setAttribute(n, String(o));
        }
      }
    } else if (typeof A == "object" && A !== null)
      for (const [o, r] of Object.entries(A)) {
        if (typeof r == "object" && r !== null && this._isDSLOperation(r))
          throw new Error(`[ViewEngine] Conditional logic (${Object.keys(r)[0]}) is not allowed in data attributes. Use state machines to compute boolean flags and reference them via context.`);
        if (typeof r == "string" && r.includes("?") && r.includes(":"))
          throw new Error("[ViewEngine] Ternary operators are not allowed in views. Use state machines to compute values and reference them via context.");
        let n;
        if (typeof r == "string" && r.includes(".$$")) {
          const [s, a] = r.split("."), g = await this.evaluator.evaluate(s, e), I = await this.evaluator.evaluate(a, e);
          g && typeof g == "object" && I && (n = g[I]);
        } else
          n = await this.evaluator.evaluate(r, e);
        if (n != null) {
          const s = `data-${this._toKebabCase(o)}`;
          i.setAttribute(s, String(n));
        }
      }
  }
  /**
   * Check if a value contains conditional logic (DSL operations or ternary operators)
   * Views should only contain simple context/item references
   */
  _containsConditionalLogic(A) {
    return typeof A != "string" ? !1 : !!(A.includes("?") && A.includes(":"));
  }
  /**
   * Check if a value is a DSL operation (conditional logic)
   */
  _isDSLOperation(A) {
    if (!A || typeof A != "object" || Array.isArray(A)) return !1;
    const e = Object.keys(A);
    if (e.length === 0) return !1;
    const i = e[0];
    return i.startsWith("$") ? ["$if", "$eq", "$ne", "$and", "$or", "$not", "$switch", "$gt", "$lt", "$gte", "$lte"].includes(i) : !1;
  }
  _toKebabCase(A) {
    return A.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
  }
  async _renderSlot(A, e, i, o) {
    const r = A.$slot;
    if (!r || !r.startsWith("$")) {
      console.warn(`[ViewEngine] Slot key must start with $: ${r}`);
      return;
    }
    const n = r.slice(1), s = e.context || {}, a = s[n];
    if (!a) {
      console.warn(`[ViewEngine] No context value for slot key: ${n}`, {
        actorId: o,
        availableKeys: Object.keys(s || {}),
        contextType: "ReactiveStore"
      });
      return;
    }
    let g;
    if (typeof a == "string" && a.startsWith("@")) {
      g = a.slice(1);
      const C = s["@actors"];
      C && !C[g] && console.warn(`[ViewEngine] Namekey "${g}" not found in context["@actors"]`, {
        actorId: o,
        contextKey: n,
        contextValue: s,
        availableActors: C ? Object.keys(C) : []
      });
    } else {
      i.textContent = String(s);
      return;
    }
    const I = this.actorEngine?.getActor(o);
    if (!I) {
      console.warn(`[ViewEngine] Parent actor not found: ${o}`);
      return;
    }
    let c = I.children?.[g];
    if (!c) {
      const C = I.vibeKey || null;
      if (c = await this.actorEngine._createChildActorIfNeeded(I, g, C), !c) {
        I._renderState === hA.READY && console.warn(`[ViewEngine] Failed to create child actor for namekey: ${g}`, {
          actorId: o,
          availableChildren: I?.children ? Object.keys(I.children) : [],
          contextValue: s,
          namekey: g
        });
        return;
      }
    }
    if (c.containerElement) {
      if (I?.children)
        for (const [C, B] of Object.entries(I.children))
          C !== g && B.actorType === "ui" && (this.actorEngine.destroyActor(B.id), delete I.children[C]);
      c._renderState === hA.READY && this.actorEngine && (c._renderState = hA.UPDATING, this.actorEngine._scheduleRerender(c.id)), c.containerElement.parentNode !== i && (c.containerElement.parentNode && c.containerElement.parentNode.removeChild(c.containerElement), i.innerHTML = "", i.appendChild(c.containerElement));
    } else
      console.warn(`[ViewEngine] Child actor ${g} has no containerElement`, {
        actorId: o,
        namekey: g,
        childActorId: c.id
      });
  }
  async renderEach(A, e, i) {
    const o = document.createDocumentFragment(), r = await this.evaluator.evaluate(A.items, e);
    if (!r || !Array.isArray(r) || r.length === 0)
      return o;
    for (let n = 0; n < r.length; n++) {
      const s = r[n], a = {
        context: e.context,
        item: s,
        index: n
      }, g = await this.renderNode(A.template, a, i);
      g && o.appendChild(g);
    }
    return o;
  }
  attachEvents(A, e, i, o) {
    for (const [r, n] of Object.entries(e))
      A.addEventListener(r, async (s) => {
        try {
          await this._handleEvent(s, n, i, A, o);
        } catch (a) {
          console.error(`[ViewEngine] Error handling event ${r}:`, a);
        }
      });
  }
  async _handleEvent(A, e, i, o, r) {
    const n = e.send;
    let s = e.payload || {};
    if ((A.type === "dragover" || A.type === "drop" || A.type === "dragenter") && (A.preventDefault(), A.type === "dragover" && (A.dataTransfer.dropEffect = "move")), n === "STOP_PROPAGATION") {
      A.stopPropagation();
      return;
    }
    if (e.key && A.key !== e.key || n === "UPDATE_INPUT" && A.type === "input")
      return;
    const a = n === "UPDATE_INPUT" || n === "UPDATE_AGENT_INPUT";
    if (this.actorEngine) {
      const g = this.actorEngine.getActor(r);
      if (g && g.machine) {
        s = jr(s, o);
        const I = g.context.value, c = {
          context: I,
          item: i.item || {},
          result: null
          // $$result not available in view events (only in state machine actions after tool execution)
        };
        if (s = await rt(s, this.evaluator, c), nt(s))
          throw new Error(`[ViewEngine] Payload contains unresolved expressions. Views must resolve all expressions before sending to inbox. Payload: ${JSON.stringify(s).substring(0, 200)}`);
        if (a && A.type === "blur" && s && typeof s == "object") {
          let C = !0;
          for (const [B, Q] of Object.entries(s)) {
            const f = I[B];
            if (Q !== f) {
              C = !1;
              break;
            }
          }
          if (C)
            return;
        }
        await this.actorEngine.sendInternalEvent(r, n, s), a || this._clearInputFields(o, r);
      } else
        console.warn(`Cannot send event ${n}: Actor has no state machine`);
    } else
      console.warn("No actorEngine set, cannot handle event:", n);
  }
  /**
   * Clear all input and textarea fields in the form containing the element
   * If no form found, clears inputs in the actor's shadow root
   * @param {HTMLElement} element - The element that triggered the event
   * @param {string} actorId - The actor ID
   * @private
   */
  _clearInputFields(A, e) {
    let i = A.closest("form");
    if (!i && this.actorEngine) {
      const r = this.actorEngine.getActor(e);
      r && r.shadowRoot && (i = r.shadowRoot);
    }
    if (!i) return;
    i.querySelectorAll("input, textarea").forEach((r) => {
      r.hasAttribute("data-actor-input") && (r.tagName === "INPUT" || r.tagName === "TEXTAREA") && (r.value = "");
    });
  }
  setActorEngine(A) {
    this.actorEngine = A;
  }
  cleanupActor(A) {
  }
}
function sD(t, A) {
  if (!(!t || !A))
    return A.split(".").reduce((e, i) => e?.[i], t);
}
class aD {
  constructor() {
    this.cache = /* @__PURE__ */ new Map(), this.dbEngine = null;
  }
  resolveStyleRef(A) {
    if (!A || !A.startsWith("co_z"))
      throw new Error(`[StyleEngine] Style reference must be a co-id (starts with 'co_z'), got: ${A}`);
    return A;
  }
  deepMerge(A, e) {
    const i = { ...A };
    for (const o in e)
      e[o] instanceof Object && !Array.isArray(e[o]) && o in A ? i[o] = this.deepMerge(A[o], e[o]) : i[o] = e[o];
    return i;
  }
  _interpolateTokens(A, e) {
    return typeof A != "string" ? A : A.replace(/\{([^}]+)\}/g, (i, o) => {
      const r = sD(e, o);
      return r !== void 0 ? r : i;
    });
  }
  _toKebabCase(A) {
    return A.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
  }
  /**
   * Convert camelCase class selectors to kebab-case
   * Preserves special selectors (:host, @container, @media, pseudo-selectors)
   * @param {string} selector - CSS selector (e.g., ".todoCategory", ":host", ".buttonViewSwitch:hover")
   * @returns {string} Converted selector (e.g., ".todo-category", ":host", ".button-view-switch:hover")
   */
  _toKebabCaseSelector(A) {
    return !A || typeof A != "string" || A.startsWith(":host") || A.startsWith("@container") || A.startsWith("@media") || A.startsWith("@") ? A : A.replace(/\.([a-zA-Z][a-zA-Z0-9]*)/g, (e, i) => `.${i.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase()}`);
  }
  compileModifierStyles(A, e) {
    return typeof A != "object" || A === null || Array.isArray(A) ? "" : Object.entries(A).map(([i, o]) => {
      const r = i.replace(/([A-Z])/g, "-$1").toLowerCase(), n = this._interpolateTokens(o, e);
      return `  ${r}: ${n};`;
    }).join(`
`);
  }
  _flattenTokens(A, e = "") {
    const i = {};
    for (const [o, r] of Object.entries(A)) {
      const n = e ? `${e}-${o}` : o;
      typeof r == "object" && r !== null && !Array.isArray(r) ? Object.assign(i, this._flattenTokens(r, n)) : i[`--${n}`] = r;
    }
    return i;
  }
  compileTokensToCSS(A, e = null) {
    const i = this._flattenTokens(A), o = Object.entries(i).map(([s, a]) => `  ${s}: ${a};`).join(`
`);
    let r = "";
    A.typography?.fontFaces && Array.isArray(A.typography.fontFaces) && (r = A.typography.fontFaces.map((s) => `@font-face {
${Object.entries(s).map(([g, I]) => `  ${g.replace(/([A-Z])/g, "-$1").toLowerCase()}: ${I};`).join(`
`)}
}`).join(`

`) + `

`);
    let n = "";
    return e ? n = `  container-type: inline-size;
  container-name: ${e.replace(/[^a-zA-Z0-9-_]/g, "-").replace(/-+/g, "-")};
` : n = `  container-type: inline-size;
`, `${r}:host {
${n}${o}
}
`;
  }
  _compileDataAttributeSelectors(A, e, i, o = "") {
    const r = [];
    if (!e || typeof e != "object" || Array.isArray(e)) return r;
    for (const [n, s] of Object.entries(e)) {
      if (typeof s != "object" || s === null || Array.isArray(s)) continue;
      const a = this._toKebabCase(n);
      for (const [g, I] of Object.entries(s)) {
        if (typeof I != "object" || I === null || Array.isArray(I)) continue;
        const c = this._toKebabCase(g), C = `[data-${a}="${c}"]`, B = `${A}${o}${C}`, Q = {}, f = {};
        let l = null;
        for (const [u, d] of Object.entries(I))
          u === "data" ? l = d : u.startsWith(":") ? f[u] = d : Q[u] = d;
        Object.keys(Q).length > 0 && r.push(`${B} {
${this.compileModifierStyles(Q, i)}
}`);
        for (const [u, d] of Object.entries(f))
          r.push(`${B}${u} {
${this.compileModifierStyles(d, i)}
}`);
        l && typeof l == "object" && !Array.isArray(l) && r.push(...this._compileDataAttributeSelectors(A, l, i, `${o}${C}`));
      }
    }
    return r;
  }
  compileComponentsToCSS(A, e) {
    if (!A || Object.keys(A).length === 0) return "";
    const i = [];
    for (const [o, r] of Object.entries(A)) {
      const n = o.replace(/([A-Z])/g, "-$1").toLowerCase(), s = r.data, a = { ...r };
      delete a.data;
      const g = {}, I = {};
      for (const [c, C] of Object.entries(a))
        c.startsWith(":") || c.startsWith("[") || typeof C == "object" && C !== null && !Array.isArray(C) ? I[c] = C : g[c] = C;
      if (Object.keys(g).length > 0) {
        const c = Object.entries(g).map(([B, Q]) => `  ${B.replace(/([A-Z])/g, "-$1").toLowerCase()}: ${this._interpolateTokens(Q, e)};`).join(`
`), C = `.${n} {
${c}
}`;
        i.push(C);
      }
      for (const [c, C] of Object.entries(I)) {
        let B;
        c.startsWith(":") ? B = `.${n}${c}` : c.startsWith("[") ? B = `.${n}${c}` : c.includes(" ") ? B = `.${n} ${c}` : B = `.${n}[${c}]`, i.push(`${B} {
${this.compileModifierStyles(C, e)}
}`);
      }
      s && typeof s == "object" && !Array.isArray(s) && i.push(...this._compileDataAttributeSelectors(`.${n}`, s, e));
    }
    return i.join(`

`);
  }
  compileSelectors(A, e) {
    if (!A || Object.keys(A).length === 0) return "";
    const i = [];
    for (const [o, r] of Object.entries(A)) {
      const n = this._interpolateTokens(o, e);
      if (n.startsWith("@container") || n.startsWith("@media")) {
        const a = [];
        for (const [g, I] of Object.entries(r))
          if (typeof I == "object" && I !== null && !Array.isArray(I))
            if (g.startsWith("@container") || g.startsWith("@media")) {
              const C = this._interpolateTokens(g, e), B = this.compileSelectors({ [C]: I }, e);
              a.push(B.split(`
`).map((Q) => `  ${Q}`).join(`
`));
            } else {
              const C = this._toKebabCaseSelector(g), B = Object.entries(I).map(([Q, f]) => `    ${Q.replace(/([A-Z])/g, "-$1").toLowerCase()}: ${this._interpolateTokens(f, e)};`).join(`
`);
              a.push(`  ${C} {
${B}
  }`);
            }
        i.push(`${n} {
${a.join(`
`)}
}`);
      } else {
        const a = this._toKebabCaseSelector(n), g = Object.entries(r).map(([I, c]) => `  ${I.replace(/([A-Z])/g, "-$1").toLowerCase()}: ${this._interpolateTokens(c, e)};`).join(`
`);
        i.push(`${a} {
${g}
}`);
      }
    }
    return i.join(`

`);
  }
  compileToCSS(A, e, i = {}, o = "", r = null) {
    let n = `${this.compileTokensToCSS(A, r)}
${this.compileComponentsToCSS(e, A)}`;
    const s = this.compileSelectors(i, A);
    return s && (n += `

/* State-based selectors */
${s}`), o && (n += `

/* Raw CSS fallback */
${o}`), n;
  }
  async getStyleSheets(A, e = null) {
    const i = A.brand, o = A.style;
    if (!i)
      throw new Error(`[StyleEngine] Actor config must have 'brand' property with co-id. Config keys: ${Object.keys(A).join(", ")}. Config: ${JSON.stringify(A, null, 2)}`);
    const r = e || A.$id || A.id || "actor", n = `${i}_${o || "none"}_${r}`;
    if (this.cache.has(n))
      return this.cache.get(n);
    const s = this.resolveStyleRef(i), a = await eA(this.dbEngine.backend, { fromCoValue: s }, { returnType: "coId" }), I = (await this.dbEngine.execute({ op: "read", schema: a, key: s })).value;
    let c = { tokens: {}, components: {} };
    if (o) {
      const w = this.resolveStyleRef(o), y = await eA(this.dbEngine.backend, { fromCoValue: w }, { returnType: "coId" });
      c = (await this.dbEngine.execute({ op: "read", schema: y, key: w })).value;
    }
    const C = r.replace(/[^a-zA-Z0-9-_]/g, "-").replace(/-+/g, "-"), B = {
      containers: {
        xs: "240px",
        sm: "360px",
        md: "480px",
        lg: "640px",
        xl: "768px",
        "2xl": "1024px"
      },
      containerName: C
      // Inject container name so queries can reference root :host container
    }, Q = this.deepMerge(B, I.tokens || {}), f = this.deepMerge(Q, c.tokens || {}), l = this.deepMerge(I.components || {}, c.components || {}), u = this.deepMerge(I.selectors || {}, c.selectors || {}), d = [I.rawCSS, c.rawCSS].filter(Boolean).join(`

`), h = this.compileToCSS(f, l, u, d, C), p = new CSSStyleSheet();
    p.replaceSync(h);
    const E = [p];
    return this.cache.set(n, E), E;
  }
  clearCache() {
    this.cache.clear();
  }
}
class gD {
  constructor(A, e, i = null) {
    this.toolEngine = A, this.evaluator = e, this.actorEngine = i, this.machines = /* @__PURE__ */ new Map(), this.dbEngine = null;
  }
  async createMachine(A, e) {
    const i = `${e.id}_machine`;
    let o = A.initial;
    const r = e.context?.value?._currentState;
    r && typeof r == "string" && A.states?.[r] && (o = r);
    const n = {
      id: i,
      definition: A,
      actor: e,
      currentState: o,
      history: [],
      eventPayload: {}
    };
    return this.machines.set(i, n), n._isInitialCreation = !0, await this._executeEntry(n, o), n._isInitialCreation = !1, n;
  }
  async send(A, e, i = {}) {
    const o = this.machines.get(A);
    if (!o) {
      console.warn(`[StateEngine] Machine not found: ${A}`);
      return;
    }
    o.eventPayload = i || {};
    const r = o.definition.states[o.currentState];
    if (!r) {
      console.warn(`[StateEngine] State definition not found for state: ${o.currentState}`);
      return;
    }
    const n = (r.on || {})[e];
    if (!n) {
      console.warn(`[StateEngine] No transition handler for event '${e}' in state '${o.currentState}'`);
      return;
    }
    await this._executeTransition(o, n, e, i);
  }
  async _executeTransition(A, e, i, o) {
    A.eventPayload || (A.eventPayload = o || {}), i === "SUCCESS" && (A.lastToolResult = o.result || null);
    const r = typeof e == "string" ? e : e.target, n = typeof e == "object" ? e.guard : null, s = typeof e == "object" ? e.actions : null;
    if (n != null && !await this._evaluateGuard(n, A.actor.context, A.eventPayload, A.actor))
      return;
    await this._executeExit(A, A.currentState), s && await this._executeActions(A, s, A.eventPayload), A.history.push({ from: A.currentState, to: r, event: i, timestamp: Date.now() });
    const a = A.currentState;
    if (A.currentState = r, A.actor.contextCoId && A.actor.actorEngine)
      try {
        await A.actor.actorEngine.updateContextCoValue(A.actor, { _currentState: r });
      } catch (c) {
        console.warn("[StateEngine] Failed to persist _currentState to context:", c.message);
      }
    const g = A.eventPayload;
    a !== r && (A.eventPayload = g, await this._executeEntry(A, r)), a !== r && r !== "dragging" && !A._isInitialCreation && !(a === "init" && r === "idle") && A.actor._renderState === hA.READY && A.actor.actorEngine && (A.actor._renderState = hA.UPDATING, A.actor.actorEngine._scheduleRerender(A.actor.id));
  }
  /**
   * Clean tool result by removing CoJSON metadata (groupInfo)
   * Tool results from database operations include groupInfo which is metadata, not data
   * @param {any} result - Tool result (can be any type)
   * @returns {any} Cleaned result without groupInfo
   */
  _cleanToolResult(A) {
    if (!A || typeof A != "object")
      return A;
    if (Array.isArray(A))
      return A.map((r) => this._cleanToolResult(r));
    const { groupInfo: e, ...i } = A, o = {};
    for (const [r, n] of Object.entries(i))
      o[r] = this._cleanToolResult(n);
    return o;
  }
  /**
   * Evaluate guard using JSON Schema validation
   * Guards check state/context conditions (NOT payload validation)
   * 
   * CRITICAL ARCHITECTURAL SEPARATION:
   * - Guards are for CONDITIONAL LOGIC (should transition happen given current state/context?)
   * - Payload validation happens in ActorEngine BEFORE reaching state machine
   * 
   * @param {Object} guard - Guard definition with schema property
   * @param {ReactiveStore} context - Actor context (ReactiveStore)
   * @param {Object} payload - Event payload (NOT validated here - already validated in ActorEngine)
   * @param {Object} actor - Actor instance (for state access)
   * @returns {Promise<boolean>} True if guard passes, false otherwise
   */
  async _evaluateGuard(A, e, i, o = null) {
    if (typeof A == "boolean") return A;
    if (!A || typeof A != "object" || !A.schema)
      return console.warn('[StateEngine] Guard must be an object with a "schema" property. Guards are schema-based only (no MaiaScript expressions).', { guard: A }), !1;
    try {
      const r = e.value, n = {
        state: o?.machine?.currentState || null,
        ...r
      };
      return (await Vt(A.schema, n, "guard")).valid;
    } catch (r) {
      return console.error("[StateEngine] Guard evaluation error:", r), !1;
    }
  }
  async _executeStateActions(A, e, i) {
    try {
      if (!A || !A.definition || !A.definition.states) {
        console.warn("[StateEngine] Invalid machine or definition in _executeStateActions", { machine: A, stateName: e, type: i });
        return;
      }
      if (!e || typeof e != "string") {
        console.warn("[StateEngine] Invalid stateName in _executeStateActions", { stateName: e, type: i });
        return;
      }
      const o = A.definition.states[e];
      if (!o || typeof o != "object") {
        console.warn("[StateEngine] State not found or invalid in definition", {
          stateName: e,
          stateDef: o,
          availableStates: Object.keys(A.definition.states || {})
        });
        return;
      }
      if (i == null || typeof i != "string") {
        console.warn("[StateEngine] Type is undefined/null or not a string in _executeStateActions", { stateName: e, type: i, typeOf: typeof i });
        return;
      }
      const r = o?.[i];
      if (!r)
        return;
      if (!A.actor) {
        console.warn("[StateEngine] Machine has no actor in _executeStateActions", { machineId: A.id, stateName: e, type: i });
        return;
      }
      if (r.tool) {
        const n = i === "entry", s = await this._invokeTool(A, r.tool, r.payload, !0, n);
        if (s && $e(s) && (A.lastToolResult = s.data), n && $e(s) && o.on?.SUCCESS && A.actor?.actorEngine) {
          const a = A.eventPayload || {}, g = A.lastToolResult != null ? this._cleanToolResult(A.lastToolResult) : null, I = {
            ...a,
            result: g
          };
          try {
            await A.actor.actorEngine.sendInternalEvent(A.actor.id, "SUCCESS", I);
          } catch (c) {
            console.error("[StateEngine]  Failed to send SUCCESS event:", c);
          }
        }
      } else if (Array.isArray(r)) {
        const n = A.eventPayload || {};
        if (await this._executeActions(A, r, A.eventPayload), i === "entry" && o.on?.SUCCESS && A.actor?.actorEngine) {
          const a = A.lastToolResult ? this._cleanToolResult(A.lastToolResult) : null, g = {
            ...n,
            result: a
            // CRITICAL: result must come AFTER spread to override any result in originalEventPayload
          };
          try {
            await A.actor.actorEngine.sendInternalEvent(A.actor.id, "SUCCESS", g);
          } catch (I) {
            console.error("[StateEngine]  Failed to send SUCCESS event:", I);
          }
        }
      } else if (typeof r == "object" && r !== null) {
        const n = A.eventPayload || {};
        if (await this._executeActions(A, r, A.eventPayload), i === "entry" && o.on?.SUCCESS && A.actor?.actorEngine) {
          const s = A.lastToolResult ? this._cleanToolResult(A.lastToolResult) : null, a = {
            ...n,
            result: s
            // CRITICAL: result must come AFTER spread to override any result in originalEventPayload
          };
          await A.actor.actorEngine.sendInternalEvent(A.actor.id, "SUCCESS", a);
        }
      }
    } catch (o) {
      console.error("[StateEngine] Error in _executeStateActions", {
        error: o.message,
        stack: o.stack,
        machineId: A?.id,
        stateName: e,
        type: i,
        machine: A ? { id: A.id, hasActor: !!A.actor, hasDefinition: !!A.definition } : null
      });
    }
  }
  async _executeEntry(A, e) {
    await this._executeStateActions(A, e, "entry");
  }
  async _executeExit(A, e) {
    await this._executeStateActions(A, e, "exit");
  }
  _sanitizeUpdates(A, e = {}) {
    return typeof A == "string" && A === "$$result" ? e : typeof A != "object" || A === null || Array.isArray(A) ? {} : Object.fromEntries(Object.entries(A).map(([i, o]) => [i, o === void 0 ? null : o]));
  }
  async _executeActions(A, e, i = {}) {
    if (!A || !A.actor) {
      console.warn("[StateEngine] Machine has no actor in _executeActions", { machineId: A?.id });
      return;
    }
    Array.isArray(e) || (e = [e]);
    const o = {};
    for (const r of e)
      if (typeof r == "string")
        await this._executeNamedAction(A, r, i);
      else if (r?.mapData)
        await this._executeMapData(A, r.mapData, i);
      else if (r?.updateContext) {
        const n = await this._evaluatePayload(r.updateContext, A.actor.context, i, A.lastToolResult, A.actor);
        Object.assign(o, this._sanitizeUpdates(n, A.lastToolResult || {}));
      } else if (r?.tool) {
        const n = await this._invokeTool(A, r.tool, r.payload, !1);
        if (n && $e(n) && (A.lastToolResult = n.data), r.onSuccess?.updateContext && $e(n)) {
          const s = await this._evaluatePayload(r.onSuccess.updateContext, A.actor.context, A.eventPayload, n.data, A.actor);
          Object.assign(o, this._sanitizeUpdates(s, n.data || {}));
        }
      }
    Object.keys(o).length > 0 && A.actor?.actorEngine && await A.actor.actorEngine.updateContextCoValue(A.actor, o);
  }
  /**
   * Execute mapData action - map operations engine configs to context keys
   * Universal API that supports any operation (read, create, update, etc.)
   * @param {Object} machine - State machine instance
   * @param {Object} mapData - Map of context keys to operation configs: { contextKey: { op: 'read', schema: '...', ... } }
   * @param {Object} payload - Event payload for expression evaluation
   */
  async _executeMapData(A, e, i = {}) {
    if (!A || !A.actor) {
      console.warn("[StateEngine] Machine has no actor in _executeMapData", { machineId: A?.id });
      return;
    }
    if (!this.dbEngine) {
      console.error("[StateEngine] Cannot execute mapData: dbEngine not available");
      return;
    }
    if (!e || typeof e != "object") {
      console.error("[StateEngine] mapData must be an object mapping context keys to operation configs", { mapData: e });
      return;
    }
    for (const [o, r] of Object.entries(e)) {
      if (!o || typeof o != "string") {
        console.error("[StateEngine] mapData context keys must be strings", { contextKey: o, operationConfig: r });
        continue;
      }
      if (!r || typeof r != "object") {
        console.error("[StateEngine] mapData operation config must be an object", { contextKey: o, operationConfig: r });
        continue;
      }
      const n = await this._evaluatePayload(
        r,
        A.actor.context,
        i,
        A.lastToolResult,
        A.actor
      ), { op: s = "read", ...a } = n;
      if (!s || typeof s != "string") {
        console.error('[StateEngine] mapData operation config must have an "op" property', { contextKey: o, operationConfig: r });
        continue;
      }
      if (a.schema && typeof a.schema == "string" && !a.schema.startsWith("co_z"))
        if (MA(a.schema))
          try {
            const g = await this.dbEngine.execute({ op: "resolve", humanReadableKey: a.schema });
            if (g?.startsWith("co_z"))
              a.schema = g;
            else {
              console.error(`[StateEngine] Failed to resolve schema ${a.schema} for context key ${o}`);
              continue;
            }
          } catch (g) {
            console.error(`[StateEngine] Error resolving schema ${a.schema} for context key ${o}:`, g);
            continue;
          }
        else {
          console.error(`[StateEngine] Invalid schema format for context key ${o}: ${a.schema}. Expected co-id or @domain/schema/... pattern.`);
          continue;
        }
      try {
        const g = { op: s, ...a }, I = await this.dbEngine.execute(g);
        if (I && typeof I == "object" && typeof I.subscribe == "function" && "value" in I) {
          const c = A.actor;
          if (c && c.contextCoId && c.contextSchemaCoId && this.actorEngine) {
            const C = e[o];
            C && C.op === "read" && C.schema && await this.actorEngine.updateContextCoValue(c, {
              [o]: {
                schema: C.schema,
                filter: C.filter || null,
                options: C.options || null
              }
            });
          }
        } else
          console.warn(`[StateEngine] mapData operation "${s}" did not return a ReactiveStore. Mutations should use tool calls instead.`);
      } catch (g) {
        console.error(`[StateEngine] Failed to execute ${s} operation for context key ${o}:`, g);
      }
    }
  }
  async _executeNamedAction(A, e, i) {
    const r = {
      resetError: { error: null },
      setLoading: { isLoading: !0 },
      clearLoading: { isLoading: !1 }
    }[e];
    if (r && await A.actor.actorEngine.updateContextCoValue(A.actor, r), e === "sendToDetailActor") {
      const n = i?.sparkId || A.actor.context.value?.selectedSparkId;
      if (n && A.actor?.children?.detail) {
        const s = A.actor.children.detail;
        await A.actor.actorEngine.sendMessage(s.id, {
          type: "LOAD_ACTOR",
          payload: { id: n },
          from: A.actor.id
        });
      }
    }
  }
  async _invokeTool(A, e, i = {}, o = !0, r = !1) {
    const n = A.eventPayload || {}, s = A.definition.states[A.currentState];
    try {
      const a = await this._evaluatePayload(i, A.actor.context, A.eventPayload || {}, A.lastToolResult, A.actor), g = await this.toolEngine.execute(e, A.actor, a);
      if (!$e(g))
        return o && s?.on?.ERROR && A.actor?.actorEngine ? await A.actor.actorEngine.sendInternalEvent(A.actor.id, "ERROR", { errors: g.errors }) : o && !s?.on?.ERROR && console.warn(`[StateEngine] No ERROR handler for ${e} in state ${A.currentState}`), g;
      const I = g.data;
      if (A.lastToolResult = I, o && !r && s?.on?.SUCCESS && A.actor?.actorEngine) {
        const c = I != null ? this._cleanToolResult(I) : null;
        await A.actor.actorEngine.sendInternalEvent(A.actor.id, "SUCCESS", {
          ...n,
          result: c
        });
      }
      return g;
    } catch (a) {
      if (console.error(`[StateEngine] Tool execution failed: ${e}`, {
        error: a.message,
        stack: a.stack,
        currentState: A.currentState,
        autoTransition: o
      }), o && s?.on?.ERROR && A.actor?.actorEngine) {
        const g = a.errors ?? [
          lA(Jn(a) ? "permission" : "structural", a.message)
        ];
        await A.actor.actorEngine.sendInternalEvent(A.actor.id, "ERROR", { errors: g });
      } else o && !s?.on?.ERROR && console.warn(`[StateEngine] No ERROR handler for ${e} in state ${A.currentState}`);
      throw a;
    }
  }
  async _evaluatePayload(A, e, i = {}, o = null, r = null) {
    const n = e.value, s = i?.result || o || null, a = { context: n, item: i || {}, result: s };
    return await rt(A, this.evaluator, a);
  }
  getCurrentState(A) {
    return this.machines.get(A)?.currentState || null;
  }
  getMachine(A) {
    return this.machines.get(A) || null;
  }
  destroyMachine(A) {
    this.machines.delete(A);
  }
}
class ID {
  constructor(A) {
    this.moduleRegistry = A, this.tools = /* @__PURE__ */ new Map();
  }
  async registerTool(A, e, i = {}) {
    !i.definition || !i.function || this.tools.set(e, { definition: i.definition, function: i.function, namespacePath: A });
  }
  async execute(A, e, i) {
    const o = this.tools.get(A);
    if (!o) {
      const n = Array.from(this.tools.keys());
      throw console.error(`[ToolEngine] Tool not found: ${A}`, {
        availableTools: n,
        totalTools: n.length
      }), new Error(`Tool not found: ${A}. Available tools: ${n.join(", ")}`);
    }
    const r = o.definition.parameters || o.definition.params;
    return r && await gt(this._normalizeToolSchema(r), i, "tool-payload"), await o.function.execute(e, i);
  }
  _normalizeToolSchema(A) {
    const e = (s) => {
      const a = {}, g = [];
      for (const [I, c] of Object.entries(s))
        if (c && typeof c == "object" && c.type !== "function") {
          const { required: C, type: B, ...Q } = c;
          a[I] = { type: B, ...Q }, C === !0 && g.push(I);
        } else c && typeof c == "object" && (a[I] = c);
      return { cleaned: a, required: g };
    };
    if (A.type === "object" && !A.properties) return A;
    const i = A.properties || A, { cleaned: o, required: r } = e(i), n = Array.isArray(A.required) ? A.required : [];
    return {
      type: "object",
      properties: o,
      required: [.../* @__PURE__ */ new Set([...n, ...r])]
    };
  }
  getToolDefinition(A) {
    return this.tools.get(A)?.definition || null;
  }
  getAllTools() {
    return Array.from(this.tools.values()).map((A) => A.definition);
  }
}
function ue(t, A) {
  if (!(!t || !A))
    return A.split(".").reduce((e, i) => e?.[i], t);
}
class Tn {
  constructor(A = null, e = {}) {
    this.registry = A, this.maxDepth = e.maxDepth || 50, this.validateExpressions = e.validateExpressions !== !1, this.dbEngine = e.dbEngine || null;
  }
  /**
   * Evaluate a MaiaScript expression
   * @param {any} expression - The expression to evaluate
   * @param {Object} data - The data context { context, item }
   * @param {number} depth - Current recursion depth (internal)
   * @returns {Promise<any>} The evaluated result
   */
  async evaluate(A, e, i = 0) {
    if (i > this.maxDepth)
      throw new Error(`[Evaluator] Maximum recursion depth (${this.maxDepth}) exceeded. Expression may be malicious or too complex.`);
    if (this.validateExpressions && i === 0 && typeof A == "object" && A !== null && !Array.isArray(A))
      try {
        const { getSchema: o } = await Promise.resolve().then(() => jt), r = o("maia-script-expression");
        r && await gt(r, A, "maia-script-expression");
      } catch (o) {
        throw console.error("[Evaluator] Expression validation failed:", o), new Error(`[Evaluator] Invalid MaiaScript expression: ${o.message}`);
      }
    if (typeof A == "number" || typeof A == "boolean" || A === null || A === void 0)
      return A;
    if (typeof A == "string" && A.startsWith("$"))
      return this.evaluateShortcut(A, e);
    if (typeof A != "object") return A;
    if ("$context" in A)
      return ue(e.context, A.$context);
    if ("$item" in A)
      return ue(e.item, A.$item);
    if ("$eq" in A) {
      const [o, r] = A.$eq, n = await this.evaluate(o, e, i + 1), s = await this.evaluate(r, e, i + 1);
      return n === s;
    }
    if ("$ne" in A) {
      const [o, r] = A.$ne, n = await this.evaluate(o, e, i + 1), s = await this.evaluate(r, e, i + 1);
      return n !== s;
    }
    if ("$not" in A)
      return !await this.evaluate(A.$not, e, i + 1);
    if ("$and" in A) {
      const o = Array.isArray(A.$and) ? A.$and : [A.$and];
      for (const r of o)
        if (!await this.evaluate(r, e, i + 1))
          return !1;
      return !0;
    }
    if ("$or" in A) {
      const o = Array.isArray(A.$or) ? A.$or : [A.$or];
      for (const r of o)
        if (await this.evaluate(r, e, i + 1))
          return !0;
      return !1;
    }
    if ("$trim" in A) {
      const o = await this.evaluate(A.$trim, e, i + 1);
      return typeof o == "string" ? o.trim() : o;
    }
    if ("$gt" in A) {
      const [o, r] = A.$gt, n = await this.evaluate(o, e, i + 1), s = await this.evaluate(r, e, i + 1);
      return n > s;
    }
    if ("$length" in A) {
      const o = await this.evaluate(A.$length, e, i + 1);
      return Array.isArray(o) || typeof o == "string" ? o.length : 0;
    }
    if ("$concat" in A) {
      const o = Array.isArray(A.$concat) ? A.$concat : [A.$concat];
      return (await Promise.all(o.map((s) => this.evaluate(s, e, i + 1)))).filter((s) => s != null).map((s) => Array.isArray(s) ? s : [s]).flat();
    }
    if ("$map" in A) {
      const o = A.$map, r = await this.evaluate(o.array, e, i + 1);
      if (!r || !Array.isArray(r))
        return [];
      const n = o.as || "item", s = o.return || o.do;
      if (!s)
        throw new Error('[Evaluator] $map operation requires either "return" or "do" property');
      const a = [];
      for (const g of r) {
        const I = {
          ...e,
          item: g
        }, c = await this.evaluateMapReturn(s, I, n, g, i + 1);
        a.push(c);
      }
      return a;
    }
    if ("$if" in A) {
      let o = A.$if.condition;
      return typeof o == "string" && o.startsWith("$") ? o = this.evaluateShortcut(o, e) : o = await this.evaluate(o, e, i + 1), o ? await this.evaluate(A.$if.then, e, i + 1) : await this.evaluate(A.$if.else, e, i + 1);
    }
    if (typeof A == "string" && A.includes("?") && A.includes(":")) {
      const [o, r] = A.split("?").map((n) => n.trim());
      if (r) {
        const [n, s] = r.split(":").map((g) => g.trim());
        return (o.startsWith("$") ? this.evaluateShortcut(o, e) : await this.evaluate(o, e, i + 1)) ? await this.evaluate(n, e, i + 1) : await this.evaluate(s, e, i + 1);
      }
    }
    return A;
  }
  /**
   * Evaluate return expression in $map context with custom item key
   * Handles shortcuts like $$msg.role when as="msg" by treating $$itemKey.path as item.path
   * @param {any} returnExpr - The return expression to evaluate
   * @param {Object} data - The data context { context, item, result }
   * @param {string} itemKey - The 'as' variable name (e.g., "msg")
   * @param {any} currentItem - The current array item being mapped
   * @param {number} depth - Current recursion depth
   * @returns {Promise<any>} The evaluated result
   */
  async evaluateMapReturn(A, e, i, o, r) {
    if (typeof A == "string" && A.startsWith("$$" + i + ".")) {
      const n = A.substring(2 + i.length + 1);
      return ue(o, n);
    }
    if (typeof A == "object" && A !== null && !Array.isArray(A)) {
      const n = {};
      for (const [s, a] of Object.entries(A))
        if (typeof a == "string" && a.startsWith("$$" + i + ".")) {
          const g = a.substring(2 + i.length + 1);
          n[s] = ue(o, g);
        } else
          n[s] = await this.evaluate(a, e, r + 1);
      return n;
    }
    return await this.evaluate(A, e, r + 1);
  }
  /**
   * Evaluate compact shortcut syntax: $key or $$key
   * v0.2 syntax:
   * - $key  context.key (implicit context)
   * - $$key  item.key (explicit item with double-dollar)
   * - $$result  result (tool result with double-dollar)
   * @param {string} shortcut - The shortcut string (e.g., "$title", "$$text", "$$result.draggedItemId")
   * @param {Object} data - The data context { context, item, result }
   * @returns {any} The evaluated result
   */
  evaluateShortcut(A, e) {
    if (A.startsWith("$$result")) {
      const r = A.substring(8);
      if (r.startsWith(".")) return ue(e.result, r.substring(1));
      if (r === "") return e.result;
    }
    if (A.startsWith("$$"))
      return ue(e.item, A.substring(2));
    const i = A.substring(1), o = ue(e.context, i);
    return o instanceof wA ? o.value : o;
  }
  /**
   * Check if an expression is a DSL operation
   * @param {any} expression - The expression to check
   * @returns {boolean} True if it's a DSL operation
   */
  isDSLOperation(A) {
    return typeof A == "string" && A.startsWith("$") ? !0 : typeof A != "object" || A === null ? !1 : "$context" in A || "$item" in A || "$if" in A || "$eq" in A || "$ne" in A || "$not" in A || "$and" in A || "$or" in A || "$trim" in A || "$gt" in A || "$length" in A || "$concat" in A || "$map" in A;
  }
}
const cD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Evaluator: Tn
}, Symbol.toStringTag, { value: "Module" })), CD = {
  $schema: "@maia/schema/tool",
  $id: "tool_publish_message_001",
  name: "@core/publishMessage",
  description: "Publishes a message to subscribed actors",
  parameters: {
    type: "object",
    properties: {
      type: {
        type: "string",
        description: "Message type"
      },
      payload: {
        type: "object",
        description: "Message payload",
        required: !1
      }
    },
    required: ["type"]
  }
}, BD = {
  $schema: "@maia/schema/tool",
  $id: "@tool/core/computeMessageNames",
  name: "computeMessageNames",
  description: "Computes a lookup object mapping message IDs to display names based on role",
  parameters: {
    type: "object",
    properties: {
      conversations: {
        type: "array",
        description: "Array of conversation messages with id and role properties"
      }
    },
    required: ["conversations"]
  }
}, QD = {
  $schema: "@maia/schema/tool",
  $id: "tool_memory_001",
  name: "@memory",
  description: "Memory tool for interacting with Honcho - persistent agent memory system",
  parameters: {
    type: "object",
    properties: {
      op: {
        type: "string",
        enum: ["createSession", "addMessage", "getContext", "chat"],
        description: "Memory operation to execute"
      },
      workspaceId: {
        type: "string",
        description: "Honcho workspace ID (default: 'maiaos-dev')"
      },
      peerId: {
        type: "string",
        description: "Peer ID ('maia' for agent, 'samuel' for user)"
      },
      sessionId: {
        type: "string",
        description: "Session ID (required for addMessage, optional for chat)"
      },
      content: {
        type: "string",
        description: "Message content (required for addMessage)"
      },
      query: {
        type: "string",
        description: "Query for chat/getContext operations"
      },
      target: {
        type: "string",
        description: "Target peer ID for chat (optional, defaults to querying about the peer)"
      }
    },
    required: ["op"]
  }
}, GI = {
  $schema: "@maia/schema/tool",
  $id: "tool_ai_001",
  name: "@ai/chat",
  description: "Unified AI chat tool using OpenAI-compatible API (RedPill) for LLM interactions. Model can be configured dynamically via payload - RedPill API endpoint is hardcoded, but each call can specify which LLM model to query. LLMs are stateless - each request sends the full context (complete conversation history).",
  parameters: {
    type: "object",
    properties: {
      context: {
        type: "array",
        description: "Complete conversation context to send to the LLM. LLMs are stateless - this represents the full context/history for this request. Each request can have completely different context.",
        items: {
          type: "object",
          properties: {
            role: {
              type: "string",
              enum: ["system", "user", "assistant"],
              description: "Message role"
            },
            content: {
              type: "string",
              description: "Message content"
            }
          },
          required: ["role", "content"]
        }
      },
      model: {
        type: "string",
        description: "LLM model to query (dynamically configurable per call). Default: qwen/qwen3-30b-a3b-instruct-2507. The RedPill API endpoint is hardcoded, but you can specify any model available on RedPill.",
        default: "qwen/qwen3-30b-a3b-instruct-2507"
      },
      temperature: {
        type: "number",
        description: "Temperature for response (0-2, default: 1)",
        default: 1
      }
    },
    required: ["context"]
  }
}, FI = {
  $schema: "@maia/schema/tool",
  $id: "sparks",
  name: "@sparks",
  description: "Sparks tool for managing collaborative spaces (groups). Supports CRUD operations, member management, and parent group management.",
  schema: "@maia/schema/tool",
  params: {
    op: {
      type: "string",
      enum: [
        "createSpark",
        "readSpark",
        "updateSpark",
        "deleteSpark",
        "addSparkMember",
        "removeSparkMember",
        "addSparkParentGroup",
        "removeSparkParentGroup",
        "getSparkMembers",
        "updateSparkMemberRole"
      ],
      description: "Spark operation to execute"
    },
    name: {
      type: "string",
      description: "Spark name (required for createSpark operation)"
    },
    id: {
      type: "string",
      description: "Spark co-id (required for most operations)"
    },
    data: {
      type: "object",
      description: "Update data (name, group) - required for updateSpark operation"
    },
    schema: {
      type: "string",
      description: "Schema co-id (optional for readSpark, defaults to spark schema)"
    },
    memberId: {
      type: "string",
      description: "Member account/group co-id (required for addSparkMember, removeSparkMember, updateSparkMemberRole)"
    },
    role: {
      type: "string",
      enum: ["reader", "writer", "admin", "manager", "writeOnly"],
      description: "Member role (required for addSparkMember, updateSparkMemberRole)"
    },
    parentGroupId: {
      type: "string",
      description: "Parent group co-id (required for addSparkParentGroup, removeSparkParentGroup)"
    }
  },
  returns: {
    type: "any",
    description: "Operation result (created/updated/deleted spark, reactive store for reads, member/group management results)"
  }
}, ED = {
  async execute(t, A) {
    const { type: e, payload: i = {}, target: o } = A;
    return e ? o ? t.actorEngine ? o.startsWith("@actor/") ? EA([lA("structural", `[publishMessage] Target not transformed: ${o}. Should be a co-id. Check schema transformer.`)]) : (await t.actorEngine.sendMessage(o, {
      type: e,
      payload: i,
      from: t.id,
      timestamp: Date.now()
    }), NA({})) : EA([lA("structural", "[publishMessage] Actor has no actorEngine reference")]) : EA([lA("structural", "Target is required. Topics infrastructure removed - use direct messaging with target parameter.")]) : EA([lA("structural", "Message type is required")]);
  }
}, lD = {
  async execute(t, A) {
    const { conversations: e = [] } = A;
    if (!Array.isArray(e))
      return NA({});
    const i = {};
    for (const o of e)
      o && o.id && (i[o.id] = o.role === "user" ? "me" : "Maia");
    return NA(i);
  }
}, Gs = {};
function bI() {
  const t = Gs?.PUBLIC_DOMAIN_API || Gs?.VITE_API_SERVICE_URL || "localhost:4201";
  return t.startsWith("http://") || t.startsWith("https://") ? t : `http://${t}`;
}
function RI(t) {
  if (!t || typeof t != "object")
    return [lA("structural", "Unknown error")];
  const A = t.validationErrors;
  if (Array.isArray(A) && A.length > 0)
    return A.map(
      (i) => lA("schema", i.message || i.msg || "Validation error", i.field ?? i.path ?? void 0)
    );
  const e = t.error || t.message || "Unknown error";
  return [lA("structural", typeof e == "string" ? e : String(e))];
}
const dD = bI();
async function oi(t, A) {
  const e = `${dD}${t}`, i = await fetch(e, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(A)
  });
  if (!i.ok) {
    const o = await i.json().catch(() => ({ error: "Unknown error" }));
    return { ok: !1, errors: RI(o) };
  }
  return { ok: !0, data: await i.json() };
}
const uD = {
  async execute(t, A) {
    const { op: e, workspaceId: i = "maiaos-dev", peerId: o, sessionId: r, content: n, query: s, target: a } = A;
    switch (e) {
      case "createSession": {
        if (!o)
          return EA([lA("structural", "[@memory] peerId is required for createSession")]);
        const g = await oi("/api/v0/memory/create-session", { workspaceId: i, peerId: o, sessionId: r });
        return g.ok ? NA({ sessionId: g.data.sessionId, workspaceId: g.data.workspaceId, peerId: g.data.peerId }) : EA(g.errors);
      }
      case "addMessage": {
        if (!r || !o || !n)
          return EA([lA("structural", "[@memory] sessionId, peerId, and content are required for addMessage")]);
        const g = await oi("/api/v0/memory/add-message", { workspaceId: i, sessionId: r, peerId: o, content: n });
        return g.ok ? NA({ success: g.data.success, sessionId: g.data.sessionId, peerId: g.data.peerId, content: g.data.content }) : EA(g.errors);
      }
      case "getContext": {
        if (!o || !s)
          return EA([lA("structural", "[@memory] peerId and query are required for getContext")]);
        const g = await oi("/api/v0/memory/get-context", { workspaceId: i, peerId: o, sessionId: r, query: s, target: a });
        return g.ok ? NA({ context: g.data.context }) : EA(g.errors);
      }
      case "chat": {
        if (!o || !s)
          return EA([lA("structural", "[@memory] peerId and query are required for chat")]);
        const g = await oi("/api/v0/memory/chat", { workspaceId: i, peerId: o, sessionId: r, query: s, target: a });
        return g.ok ? NA({ response: g.data.response }) : EA(g.errors);
      }
      default:
        return EA([lA("structural", `[@memory] Unknown operation: ${e}`)]);
    }
  }
}, hD = bI(), KI = {
  async execute(t, A) {
    const e = A?.context || A?.messages, { model: i = "qwen/qwen3-30b-a3b-instruct-2507", temperature: o = 1 } = A;
    if (!e || !Array.isArray(e) || e.length === 0)
      return EA([lA("structural", "[@ai/chat] context array is required")]);
    const r = `${hD}/api/v0/llm/chat`, n = await fetch(r, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ model: i, messages: e, temperature: o })
    });
    if (!n.ok) {
      const a = await n.json().catch(() => ({ error: "Unknown error" }));
      return EA(RI(a));
    }
    const s = await n.json();
    return NA({
      content: s.content,
      role: s.role || "assistant",
      usage: s.usage || null
    });
  }
}, vI = {
  async execute(t, A) {
    if (!t)
      return EA([lA("structural", "[@sparks] Actor context required")]);
    const e = t.actorEngine?.os;
    if (!e || !e.db)
      return EA([lA("structural", "[@sparks] Database engine not available")]);
    try {
      const i = await e.db(A);
      return NA(i);
    } catch (i) {
      return EA(i.errors ?? [lA("structural", i.message || "Spark operation failed")]);
    }
  }
}, On = {
  "core/publishMessage": { definition: CD, function: ED },
  "core/computeMessageNames": { definition: BD, function: lD },
  "memory/memory": { definition: QD, function: uD },
  "ai/chat": { definition: GI, function: KI },
  "sparks/sparks": { definition: FI, function: vI }
};
function YI(t) {
  return On[t] || null;
}
function fD() {
  const t = {};
  for (const [A, e] of Object.entries(On))
    t[A] = e.definition;
  return t;
}
const UI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  TOOLS: On,
  getAllToolDefinitions: fD,
  getTool: YI
}, Symbol.toStringTag, { value: "Module" }));
class pD {
  constructor() {
    this.modules = /* @__PURE__ */ new Map(), this.moduleConfigs = /* @__PURE__ */ new Map();
  }
  /**
   * Register a MaiaScript module
   * @param {string} name - Module name (e.g., 'core', 'dragdrop')
   * @param {Object} module - Module instance or class
   * @param {Object} config - Optional module configuration/metadata
   */
  registerModule(A, e, i = {}) {
    this.modules.has(A) && console.warn(`[Registry] Module "${A}" already registered, overwriting`), this.modules.set(A, e), this.moduleConfigs.set(A, {
      name: A,
      version: i.version || "1.0.0",
      description: i.description || "",
      ...i
    });
  }
  /**
   * Get a module by name
   * @param {string} name - Module name
   * @returns {Object|null} Module instance or null
   */
  getModule(A) {
    return this.modules.get(A) || null;
  }
  /**
   * Get module configuration
   * @param {string} name - Module name
   * @returns {Object|null} Module config or null
   */
  getModuleConfig(A) {
    return this.moduleConfigs.get(A) || null;
  }
  /**
   * Check if a module exists
   * @param {string} name - Module name
   * @returns {boolean}
   */
  hasModule(A) {
    return this.modules.has(A);
  }
  /**
   * List all registered modules
   * @returns {Array<string>} Array of module names
   */
  listModules() {
    return Array.from(this.modules.keys());
  }
  /**
   * List all module configs
   * @returns {Array<Object>} Array of module configurations
   */
  listModuleConfigs() {
    return Array.from(this.moduleConfigs.values());
  }
  /**
   * Clear all registered modules
   * @internal For testing purposes only
   */
  clear() {
    this.modules.clear(), this.moduleConfigs.clear(), console.log("[Registry] Cleared all modules");
  }
  /**
   * Load a module (imports and registers)
   * @param {string} moduleName - Module name to load
   * @param {string} modulePath - Path to module file (optional, defaults to modules/{name}.module.js)
   * @returns {Promise<void>}
   */
  async loadModule(A, e = null) {
    if (this.hasModule(A)) {
      console.log(`[Registry] Module "${A}" already loaded`);
      return;
    }
    const i = e || `./${A}.module.js`;
    try {
      const o = await import(
        /* @vite-ignore */
        i
      );
      o.default && typeof o.default.register == "function" ? await o.default.register(this) : typeof o.register == "function" ? await o.register(this) : console.warn(`[Registry] Module "${A}" has no register method`);
    } catch (o) {
      throw console.error(`[Registry] Failed to load module "${A}":`, o), o;
    }
  }
  /**
   * Query module for configuration/data
   * @param {string} moduleName - Module name
   * @param {string} query - Query string
   * @returns {any} Query result or null
   */
  query(A, e) {
    const i = this.getModule(A);
    return i ? typeof i.query == "function" ? i.query(e) : i.config && e in i.config ? i.config[e] : null : null;
  }
  /**
   * Get tool engine from registry
   * @param {string} moduleName - Module name for error messages
   * @returns {Object} ToolEngine instance
   */
  _getToolEngine(A) {
    const e = this._toolEngine;
    if (!e)
      throw new Error(`[${A}] ToolEngine not available in registry`);
    return e;
  }
  /**
   * Register tools from tools registry
   * @param {string} moduleName - Module name
   * @param {Array<string>} toolNames - Array of tool names
   * @param {string} namespace - Namespace prefix (e.g., '@core')
   * @param {Object} options - Options (silent, etc.)
   * @returns {Promise<Array<string>>} Array of registered tool names
   */
  async _registerToolsFromRegistry(A, e, i, o = {}) {
    const { silent: r = !1 } = o, n = this._getToolEngine(A), s = [];
    for (const a of e)
      try {
        const g = YI(`${A}/${a}`);
        g && (await n.registerTool(`${A}/${a}`, `${i}/${a}`, {
          definition: g.definition,
          function: g.function
        }), s.push(`${i}/${a}`));
      } catch (g) {
        r || console.error(`[${A}] Failed to register ${i}/${a}:`, g.message);
      }
    return s;
  }
}
class Fs extends qn {
  constructor(A) {
    const e = new Tn();
    super(A, { evaluator: e });
  }
}
const wD = {
  async execute(t, A) {
    if (!t)
      return EA([lA("structural", "[@db] Actor context required")]);
    const e = t.actorEngine?.os;
    if (!e || !e.db)
      return EA([lA("structural", "[@db] Database engine not available")]);
    if (A.op === "create" && A.schema && !A.schema.startsWith("co_z"))
      return EA([lA("structural", `[@db] Schema must be a co-id (co_z...), got: ${A.schema}`)]);
    try {
      const i = await e.db(A);
      return NA(i);
    } catch (i) {
      return EA(i.errors ?? [lA("structural", i.message || "Database operation failed")]);
    }
  }
}, yD = {
  $schema: "@maia/schema/tool",
  $id: "db",
  name: "Database Tool",
  description: "Unified API for all database operations (query, create, update, delete)",
  schema: "@maia/schema/tool",
  params: {
    op: {
      type: "string",
      enum: ["query", "create", "update", "delete", "seed"],
      description: "Database operation to execute"
    },
    schema: {
      type: "string",
      description: "Schema reference (co-id) - REQUIRED for 'create' operation only (no CoValue exists yet). OPTIONAL for 'update' and 'delete' operations (schema is extracted from CoValue headerMeta internally by operations)."
    },
    key: {
      type: "string",
      description: "Optional: Specific key for config queries"
    },
    filter: {
      type: "object",
      description: "Optional: Filter criteria for data queries"
    },
    callback: {
      description: "Optional: Callback function for reactive subscriptions (not validated - runtime only)"
    },
    id: {
      type: "string",
      description: "Optional: Record ID for update/delete operations"
    },
    data: {
      type: "object",
      description: "Optional: Data for create/update operations"
    }
  },
  returns: {
    type: "any",
    description: "Operation result (data, unsubscribe function, created/updated/deleted record, etc.)"
  }
}, We = {
  version: "1.0.0",
  description: "Unified database operation API",
  namespace: "@db",
  tools: ["@db"]
};
async function DD(t) {
  t._getToolEngine("DBModule").tools.set("@db", {
    definition: yD,
    function: wD,
    namespacePath: "db/db"
  }), t.registerModule("db", { config: We, query: (e) => e === "tools" ? ["@db"] : null }, {
    version: We.version,
    description: We.description,
    namespace: We.namespace,
    tools: We.tools
  });
}
const mD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  config: We,
  register: DD
}, Symbol.toStringTag, { value: "Module" })), me = {
  version: "1.0.0",
  description: "Core UI tools (view modes, modals, utilities)",
  namespace: "@core",
  tools: ["preventDefault", "publishMessage", "computeMessageNames"]
};
async function SD(t) {
  const A = me.tools, e = await t._registerToolsFromRegistry("core", A, me.namespace, { silent: !0 });
  t.registerModule("core", { config: me, query: () => null }, {
    version: me.version,
    description: me.description,
    namespace: me.namespace,
    tools: e
  });
}
const kD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  config: me,
  register: SD
}, Symbol.toStringTag, { value: "Module" })), ze = {
  version: "1.0.0",
  description: "Unified AI tool for OpenAI-compatible API integration (RedPill)",
  namespace: "@ai",
  tools: ["@ai/chat"]
};
async function ND(t) {
  t._getToolEngine("AiModule").tools.set("@ai/chat", {
    definition: GI,
    function: KI,
    namespacePath: "ai/chat"
  }), t.registerModule("ai", { config: ze, query: (e) => e === "tools" ? ["@ai/chat"] : null }, {
    version: ze.version,
    description: ze.description,
    namespace: ze.namespace,
    tools: ze.tools
  });
}
const MD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  config: ze,
  register: ND
}, Symbol.toStringTag, { value: "Module" })), _e = {
  version: "1.0.0",
  description: "Sparks tool for managing collaborative spaces (groups)",
  namespace: "@sparks",
  tools: ["@sparks"]
};
async function GD(t) {
  t._getToolEngine("SparksModule").tools.set("@sparks", {
    definition: FI,
    function: vI,
    namespacePath: "sparks/sparks"
  }), t.registerModule("sparks", { config: _e, query: (e) => e === "tools" ? ["@sparks"] : null }, {
    version: _e.version,
    description: _e.description,
    namespace: _e.namespace,
    tools: _e.tools
  });
}
const FD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  config: _e,
  register: GD
}, Symbol.toStringTag, { value: "Module" })), Te = {}, bs = {
  db: mD,
  core: kD,
  ai: MD,
  sparks: FD
};
class se {
  constructor() {
    this.moduleRegistry = null, this.evaluator = null, this.toolEngine = null, this.stateEngine = null, this.styleEngine = null, this.viewEngine = null, this.actorEngine = null, this.subscriptionEngine = null, this.dbEngine = null, this._node = null, this._account = null, this._syncDomain = null;
  }
  /**
   * Compatibility property for maia-city and other tools
   * Exposes node and account for CoJSON backend access
   */
  get id() {
    return !this._node || !this._account ? null : {
      maiaId: this._account,
      node: this._node
    };
  }
  /**
   * Get all CoValues from the node (for maia-city compatibility)
   * @returns {Array} Array of CoValue metadata
   */
  getAllCoValues() {
    if (!this._node)
      return [];
    const A = [], e = this._node.coValues;
    if (e && typeof e.entries == "function")
      for (const [i, o] of e.entries())
        try {
          if (!o.isAvailable()) {
            A.push({
              id: i,
              type: "loading",
              schema: null,
              headerMeta: null,
              keys: "N/A",
              content: null,
              createdAt: null
            });
            continue;
          }
          const r = o.getCurrentContent(), n = o.verified?.header, s = n?.meta || null, a = s?.$schema || null, g = n?.createdAt || null;
          let I = "N/A";
          if (r && r.keys && typeof r.keys == "function")
            try {
              I = r.keys().length;
            } catch {
            }
          const c = r?.type || "unknown";
          let C = null;
          if (c === "costream")
            try {
              const B = r.toJSON();
              if (B instanceof Uint8Array)
                C = {
                  type: "stream",
                  itemCount: "binary",
                  preview: `${B.length} bytes`
                };
              else if (B && typeof B == "object") {
                const Q = [];
                for (const f in B)
                  Array.isArray(B[f]) && Q.push(...B[f]);
                C = {
                  type: "stream",
                  itemCount: Q.length,
                  preview: Q.slice(0, 3)
                };
              }
            } catch {
            }
          else if (c === "coplaintext")
            try {
              C = {
                type: "plaintext",
                content: r.text || r.toString()
              };
            } catch {
            }
          A.push({
            id: i,
            type: c,
            schema: a,
            headerMeta: s,
            keys: I,
            content: C || r,
            createdAt: g
          });
        } catch (r) {
          console.warn(`Error processing CoValue ${i}:`, r), A.push({
            id: i,
            type: "error",
            schema: null,
            headerMeta: null,
            keys: "N/A",
            content: null,
            createdAt: null,
            error: r.message
          });
        }
    return A;
  }
  /**
   * Boot the operating system
   * @param {Object} config - Boot configuration
   * @param {Object} [config.node] - LocalNode instance (required for CoJSON backend if backend not provided)
   * @param {Object} [config.account] - RawAccount instance (required for CoJSON backend if backend not provided)
   * @param {Object} [config.backend] - Pre-initialized backend (alternative to node+account)
   * @param {Object} [config.registry] - Config registry for seeding
   * @param {string} [config.syncDomain] - Sync service domain (overrides env vars, single source of truth)
   * @param {'human' | 'agent'} [config.mode] - Operational mode (default: detect from env vars)
   * @returns {Promise<MaiaOS>} Booted OS instance
   * @throws {Error} If neither backend nor node+account is provided (or agent mode credentials missing)
   */
  static async boot(A = {}) {
    const e = new se(), i = A.mode || typeof process < "u" && process.env?.MAIA_MODE || typeof import.meta < "u" && Te?.MAIA_MODE || typeof import.meta < "u" && Te?.VITE_MAIA_MODE || "human";
    if (A.syncDomain && (e._syncDomain = A.syncDomain), i === "agent" && !A.node && !A.account && !A.backend) {
      const { loadAgentAccount: r, createAgentAccount: n } = await Promise.resolve().then(() => UD), s = typeof process < "u" && process.env?.MAIA_AGENT_ACCOUNT_ID || typeof import.meta < "u" && Te?.MAIA_AGENT_ACCOUNT_ID || typeof import.meta < "u" && Te?.VITE_MAIA_AGENT_ACCOUNT_ID, a = typeof process < "u" && process.env?.MAIA_AGENT_SECRET || typeof import.meta < "u" && Te?.MAIA_AGENT_SECRET || typeof import.meta < "u" && Te?.VITE_MAIA_AGENT_SECRET;
      if (!s || !a)
        throw new Error(
          "Agent mode requires MAIA_AGENT_ACCOUNT_ID and MAIA_AGENT_SECRET environment variables. For services, use service-specific prefixes: SYNC_MAIA_* for sync service, CITY_MAIA_* for maia-city. Run `bun agent:generate --service <service>` to generate credentials."
        );
      let g;
      try {
        g = await r({
          accountID: s,
          agentSecret: a,
          syncDomain: A.syncDomain || null
        });
      } catch {
        console.log("[MaiaOS.boot] Account not found, creating new agent account..."), g = await n({
          agentSecret: a,
          name: "Maia Agent",
          syncDomain: A.syncDomain || null
        });
      }
      e._node = g.node, e._account = g.account;
    } else
      A.node && A.account && (e._node = A.node, e._account = A.account);
    const o = await se._initializeDatabase(e, A);
    return o && typeof o.ensureAccountOsReady == "function" && o.ensureAccountOsReady({ timeoutMs: 1e4 }).then((r) => {
      r || console.warn("[MaiaOS.boot]  account.os readiness check failed - schema resolution may fail until it loads");
    }).catch((r) => {
      console.warn("[MaiaOS.boot]  account.os loading error (non-blocking):", r);
    }), A.registry && await se._seedDatabase(e, o, A), se._initializeEngines(e, A), await se._loadModules(e, A), e;
  }
  /**
   * Initialize database backend and engine
   * Requires either a pre-initialized backend or CoJSON node+account
   * @param {MaiaOS} os - OS instance
   * @param {Object} config - Boot configuration
   * @param {Object} [config.node] - LocalNode instance (required for CoJSON backend)
   * @param {Object} [config.account] - RawAccount instance (required for CoJSON backend)
   * @param {Object} [config.backend] - Pre-initialized backend (alternative to node+account)
   * @returns {Promise<DBAdapter>} Initialized backend
   * @throws {Error} If neither backend nor node+account is provided
   */
  static async _initializeDatabase(A, e = {}) {
    if (e.backend)
      return A.dbEngine = new Fs(e.backend), e.backend;
    if (e.node && e.account) {
      const { CoJSONBackend: i } = await Promise.resolve().then(() => Mo), o = new i(e.node, e.account, { systemSpark: "@maia" });
      return A.dbEngine = new Fs(o), o.dbEngine = A.dbEngine, o;
    }
    throw new Error(
      "MaiaOS.boot() requires either a backend or node+account for CoJSON backend. Provide either: { backend: <DBAdapter> } or { node: <LocalNode>, account: <RawAccount> }"
    );
  }
  /**
   * Collect schemas from schemata module
   * @returns {Object} Schemas object
   */
  static _collectSchemas() {
    const A = {};
    return typeof Yr == "function" && Object.assign(A, Yr()), typeof br == "function" && (A["meta-schema"] = br()), A;
  }
  /**
   * Validate schemas against meta schema
   * @param {Object} schemas - Schemas to validate
   * @param {ValidationEngine} validationEngine - Validation engine instance
   * @throws {Error} If any schema fails validation
   */
  static async _validateSchemas(A, e) {
    for (const [i, o] of Object.entries(A)) {
      const r = await e.validateSchemaAgainstMeta(o);
      if (!r.valid) {
        const n = r.errors.map((s) => `  - ${s.instancePath}: ${s.message}`).join(`
`);
        throw console.error(` Schema '${i}' failed meta schema validation:
${n}`), new Error(`Schema '${i}' is not valid JSON Schema`);
      }
    }
  }
  /**
   * Seed database with configs, schemas, and tool definitions
   * @param {MaiaOS} os - OS instance
   * @param {DBAdapter} backend - Database backend (CoJSONBackend)
   * @param {Object} config - Boot configuration
   */
  static async _seedDatabase(A, e, i) {
    const { getAllToolDefinitions: o } = await Promise.resolve().then(() => UI), r = o(), n = {
      ...i.registry,
      tool: r
      // Add tool definitions under 'tool' key
    }, s = se._collectSchemas(), a = new Ye();
    await a.initialize(), await se._validateSchemas(s, a);
    const I = i.registry?.data || {}, c = await A.dbEngine.execute({
      op: "seed",
      configs: n,
      schemas: s,
      data: I
    });
    if (!c.ok) {
      const B = c.errors?.map((Q) => Q.message).join("; ") || "Seed failed";
      throw new Error(`[MaiaOS] Seed failed: ${B}`);
    }
    const { setSchemaResolver: C } = await Promise.resolve().then(() => vw);
    C({ dbEngine: A.dbEngine });
  }
  /**
   * Initialize all engines and wire dependencies
   * @param {MaiaOS} os - OS instance
   * @param {Object} config - Boot configuration
   */
  static _initializeEngines(A, e) {
    A.moduleRegistry = new pD(), A.evaluator = new Tn(A.moduleRegistry, { dbEngine: A.dbEngine }), A.toolEngine = new ID(A.moduleRegistry), A.moduleRegistry._toolEngine = A.toolEngine, A.moduleRegistry._dbEngine = A.dbEngine, A.stateEngine = new gD(A.toolEngine, A.evaluator), A.styleEngine = new aD(), e.isDevelopment && A.styleEngine.clearCache(), A.viewEngine = new nD(A.evaluator, null, A.moduleRegistry), A.actorEngine = new iD(
      A.styleEngine,
      A.viewEngine,
      A.moduleRegistry,
      A.toolEngine,
      A.stateEngine
    ), A.actorEngine.dbEngine = A.dbEngine, A.viewEngine.dbEngine = A.dbEngine, A.styleEngine.dbEngine = A.dbEngine, A.stateEngine.dbEngine = A.dbEngine, A.actorEngine.os = A, A.viewEngine.actorEngine = A.actorEngine, A.stateEngine.actorEngine = A.actorEngine;
  }
  /**
   * Load modules
   * @param {MaiaOS} os - OS instance
   * @param {Object} config - Boot configuration
   */
  static async _loadModules(A, e) {
    const i = e.modules || ["db", "core", "sparks"];
    for (const o of i)
      try {
        if (bs[o]) {
          const r = bs[o];
          r.default && typeof r.default.register == "function" ? await r.default.register(A.moduleRegistry) : typeof r.register == "function" && await r.register(A.moduleRegistry);
        } else
          await A.moduleRegistry.loadModule(o);
      } catch (r) {
        console.error(`Failed to load module "${o}":`, r);
      }
  }
  /**
   * Create an actor
   * @param {string} actorPath - Path to actor.maia file
   * @param {HTMLElement} container - Container element
   * @returns {Promise<Object>} Created actor
   */
  async createActor(A, e) {
    let i;
    if (typeof A == "object" && A !== null)
      i = A;
    else if (typeof A == "string" && A.startsWith("co_z")) {
      const r = await eA(this.actorEngine.dbEngine.backend, { fromCoValue: A }, { returnType: "coId" });
      i = (await this.actorEngine.dbEngine.execute({ op: "read", schema: r, key: A })).value;
    } else
      throw new Error(`[MaiaOS] createActor expects co-id (co_z...) or config object, got: ${typeof A}`);
    return await this.actorEngine.createActor(i, e);
  }
  /**
   * Load a vibe (app manifest) from file and create its root actor
   * @param {string} vibePath - Path to vibe manifest
   * @param {HTMLElement} container - Container element
   * @returns {Promise<{vibe: Object, actor: Object}>} Vibe metadata and actor instance
   */
  async loadVibe(A, e) {
    const i = await fetch(A);
    if (!i.ok)
      throw new Error(`Failed to load vibe: ${A}`);
    const o = await i.json(), n = `${A.substring(0, A.lastIndexOf("/"))}/${o.actor}`, s = await this.createActor(n, e);
    return { vibe: o, actor: s };
  }
  /**
   * Load a vibe from account.sparks[spark].vibes using the abstracted operations API
   * @param {string} vibeKey - Vibe key in spark's vibes (e.g., "todos")
   * @param {HTMLElement} container - Container element
   * @param {string} [spark='@maia'] - Spark name (context scope), e.g. '@maia'
   * @returns {Promise<{vibe: Object, actor: Object}>} Vibe metadata and actor instance
   */
  async loadVibeFromAccount(A, e, i = "@maia") {
    if (!this.dbEngine || !this._account)
      throw new Error("[Kernel] Cannot load vibe from account - dbEngine or account not available");
    const o = this._account, n = (await this.dbEngine.execute({
      op: "read",
      schema: "@account",
      key: o.id
    })).value;
    if (!n)
      throw new Error("[Kernel] Failed to read account CoMap");
    const s = n.sparks;
    if (!s || typeof s != "string" || !s.startsWith("co_"))
      throw new Error(`[Kernel] account.sparks not found. Ensure schemaMigration has run. Account data: ${JSON.stringify({ id: n.id, hasSparks: !!n.sparks })}`);
    const g = (await this.dbEngine.execute({
      op: "read",
      schema: s,
      key: s
    })).value;
    if (!g || g.error)
      throw new Error(`[Kernel] account.sparks not available: ${g?.error || "Unknown error"}`);
    const I = g[i];
    if (!I || typeof I != "string" || !I.startsWith("co_")) {
      const u = Object.keys(g).filter((d) => d !== "id" && d !== "$schema" && d !== "type" && typeof g[d] == "string" && g[d].startsWith("co_"));
      throw new Error(`[Kernel] Spark "${i}" not found in account.sparks. Available: ${u.join(", ") || "none"}`);
    }
    const C = (await this.dbEngine.execute({
      op: "read",
      schema: null,
      key: I
    })).value;
    if (!C || C.error)
      throw new Error(`[Kernel] Spark "${i}" not available: ${C?.error || "Unknown error"}`);
    const B = C.vibes;
    if (!B || typeof B != "string" || !B.startsWith("co_"))
      throw new Error(`[Kernel] Spark "${i}" has no vibes registry. Ensure seeding has run.`);
    const f = (await this.dbEngine.execute({
      op: "read",
      schema: B,
      key: B
    })).value;
    if (!f || f.error)
      throw new Error(`[Kernel] Spark "${i}" vibes not available: ${f?.error || "Unknown error"}`);
    const l = f[A];
    if (!l || typeof l != "string" || !l.startsWith("co_")) {
      const u = Object.keys(f).filter((d) => d !== "id" && d !== "$schema" && d !== "type" && typeof f[d] == "string" && f[d].startsWith("co_"));
      throw new Error(`[Kernel] Vibe '${A}' not found in ${i}.vibes. Available: ${u.join(", ") || "none"}`);
    }
    return await this.loadVibeFromDatabase(l, e, A);
  }
  /**
   * Load a vibe from database (maia.db)
   * @param {string} vibeId - Vibe ID (co-id or human-readable like "@maia/vibe/todos")
   * @param {HTMLElement} container - Container element
   * @param {string} [vibeKey] - Optional vibe key for actor reuse tracking (e.g., 'todos')
   * @returns {Promise<{vibe: Object, actor: Object}>} Vibe metadata and actor instance
   */
  async loadVibeFromDatabase(A, e, i = null) {
    if (!A.startsWith("co_z"))
      throw new Error(`[Kernel] Vibe ID must be co-id at runtime: ${A}. This should have been resolved during seeding.`);
    const o = A, r = await this.dbEngine.execute({
      op: "read",
      schema: null,
      // No schema filter - read CoValue directly
      key: o
    }), n = await this.dbEngine.execute({
      op: "schema",
      fromCoValue: o
      //  Extracts headerMeta.$schema internally
    }), s = n.value?.$id || r.value?.$schema;
    if (!s)
      throw new Error(`[Kernel] Failed to extract schema co-id from vibe ${o}. Vibe must have $schema in headerMeta.`);
    let g = r.value;
    if (!g || g.error) {
      console.error("[Kernel] Vibe not found! Trying to debug..."), console.error(`[Kernel] Vibe co-id: ${o}`), console.error(`[Kernel] Schema co-id: ${s}`);
      try {
        const p = (await this.dbEngine.execute({
          op: "read",
          schema: null,
          // Read CoValue directly
          key: o
        })).value;
        console.error("[Kernel] Direct read() result:", p ? "FOUND" : "NULL", p);
      } catch (h) {
        console.error("[Kernel] Direct read() error:", h);
      }
      throw new Error(`Vibe not found in database: ${A} (co-id: ${o})`);
    }
    if (g.properties && Array.isArray(g.properties)) {
      const h = {};
      for (const p of g.properties)
        h[p.key] = p.value;
      g.id && (h.id = g.id), g.$schema && (h.$schema = g.$schema), g.type && (h.type = g.type), g = h;
    }
    const I = n.value;
    I && await gt(I, g, "vibe");
    let c = g.actor;
    if (!c)
      throw new Error(`[MaiaOS] Vibe ${A} (${o}) does not have an 'actor' property. Vibe structure: ${JSON.stringify(Object.keys(g))}`);
    if (!c.startsWith("co_z"))
      throw new Error(`[Kernel] Actor ID must be co-id at runtime: ${c}. This should have been resolved during seeding.`);
    const C = ee(this.dbEngine.backend, { fromCoValue: c }, { returnType: "coId" });
    let B;
    const Q = await new Promise((h, p) => {
      const E = setTimeout(() => {
        B && B(), p(new Error(`[Kernel] Timeout waiting for actor schema to resolve for ${c} after 10000ms`));
      }, 1e4);
      B = C.subscribe((w) => {
        w.loading || (clearTimeout(E), B && B(), w.error || !w.schemaCoId ? p(new Error(`[Kernel] Failed to extract schema co-id from actor ${c}: ${w.error || "Schema not found"}`)) : h(w.schemaCoId));
      });
    }), f = await this.dbEngine.execute({
      op: "read",
      schema: Q,
      key: c
    });
    if (!f.value)
      throw new Error(`[MaiaOS] Actor with co-id ${c} not found in database. The actor may not have been seeded correctly.`);
    i && this.actorEngine.destroyActorsForVibe(i);
    const u = f.value, d = await this.actorEngine.createActor(u, e, i);
    return { vibe: g, actor: d };
  }
  /**
   * Debug helper to list coIdRegistry keys (for troubleshooting)
   * @private
   */
  async _debugCoIdRegistry() {
    try {
      const i = this.dbEngine.backend.db.transaction(["coIdRegistry"], "readonly").objectStore("coIdRegistry").getAllKeys();
      return (await new Promise((r, n) => {
        i.onsuccess = () => r(i.result), i.onerror = () => n(i.error);
      })).filter((r) => r && (r.includes("actor") || r.includes("agent")));
    } catch (A) {
      return [`Error: ${A.message}`];
    }
  }
  /**
   * Get actor by ID
   * @param {string} actorId - Actor ID
   * @returns {Object|null} Actor instance
   */
  getActor(A) {
    return this.actorEngine.getActor(A);
  }
  /**
   * Send message to actor
   * @param {string} actorId - Target actor ID
   * @param {Object} message - Message object
   */
  sendMessage(A, e) {
    this.actorEngine.sendMessage(A, e);
  }
  /**
   * Execute database operation (internal use + @db tool)
   * @param {Object} payload - Operation payload {op: 'query|create|update|delete|seed', ...}
   * @returns {Promise<any>} Operation result; for write ops: throws on error, returns data on success (backward compat for state machines)
   */
  async db(A) {
    const e = await this.dbEngine.execute(A), i = /* @__PURE__ */ new Set(["create", "update", "delete", "append", "push", "seed"]);
    if (e && e.ok === !1 && i.has(A?.op)) {
      const o = e.errors?.map((n) => n.message).join("; ") || "Operation failed", r = new Error(`[db] ${A.op} failed: ${o}`);
      throw r.errors = e.errors, r;
    }
    return e && e.ok === !0 && typeof e.data < "u" ? e.data : e;
  }
  /**
   * Get sync domain (single source of truth)
   * Returns the sync domain configured during boot, or null if not set
   * @returns {string|null} Sync domain or null
   */
  getSyncDomain() {
    return this._syncDomain;
  }
  /**
   * Expose engines for debugging
   */
  getEngines() {
    return {
      actorEngine: this.actorEngine,
      viewEngine: this.viewEngine,
      styleEngine: this.styleEngine,
      stateEngine: this.stateEngine,
      toolEngine: this.toolEngine,
      dbEngine: this.dbEngine,
      evaluator: this.evaluator,
      moduleRegistry: this.moduleRegistry
    };
  }
}
async function JI() {
  if (!window.PublicKeyCredential)
    throw new Error(
      `WebAuthn not supported. Please use:
- Chrome on macOS/Linux/Windows 11
- Safari on macOS 13+/iOS 16+
Firefox and Windows 10 are NOT supported.`
    );
  try {
    if (!await PublicKeyCredential.isConditionalMediationAvailable?.())
      throw new Error(
        `WebAuthn PRF not supported. Please use:
- Chrome on macOS/Linux/Windows 11
- Safari on macOS 13+/iOS 16+
Firefox and Windows 10 are NOT supported.`
      );
    return !0;
  } catch {
    throw new Error(
      `WebAuthn PRF not supported. Please use:
- Chrome on macOS/Linux/Windows 11
- Safari on macOS 13+/iOS 16+
Firefox and Windows 10 are NOT supported.`
    );
  }
}
async function Pn() {
  await JI();
}
function HI(t) {
  const A = new Uint8Array(t);
  let e = "";
  for (let i = 0; i < A.byteLength; i++)
    e += String.fromCharCode(A[i]);
  return btoa(e);
}
function jn(t) {
  return new TextEncoder().encode(t);
}
async function qI({ salt: t, rpId: A = window.location.hostname }) {
  try {
    const e = await navigator.credentials.get({
      publicKey: {
        challenge: crypto.getRandomValues(new Uint8Array(32)),
        rpId: A,
        userVerification: "required",
        authenticatorAttachment: "platform",
        // ONLY platform authenticators!
        // WebAuthn Level 3: Hint the browser UI to show platform authenticator
        hints: ["client-device"],
        // Prioritize local device, suppress QR code UI
        extensions: {
          prf: {
            eval: {
              first: t
              // The salt we want to evaluate
            }
          }
        }
      },
      mediation: "optional"
      // Show passkey picker
    });
    if (!e)
      throw new Error("No passkey selected");
    const i = e.getClientExtensionResults()?.prf;
    if (!i?.results?.first)
      throw new Error("PRF evaluation failed: no results returned");
    return {
      prfOutput: new Uint8Array(i.results.first),
      credentialId: e.rawId
    };
  } catch (e) {
    throw console.error("PRF evaluation error:", e), new Error(`Failed to evaluate PRF: ${e.message}`);
  }
}
async function xI({ name: t, userId: A, rpId: e = window.location.hostname, salt: i }) {
  try {
    const o = i ? {
      prf: {
        eval: {
          first: i
          // Evaluate PRF during creation!
        }
      }
    } : {
      prf: {}
      // Just enable PRF without evaluation
    }, r = await navigator.credentials.create({
      publicKey: {
        challenge: crypto.getRandomValues(new Uint8Array(32)),
        rp: {
          name: "Maia OS",
          id: e
        },
        user: {
          id: A,
          name: t,
          displayName: t
        },
        pubKeyCredParams: [
          { type: "public-key", alg: -7 },
          // ES256
          { type: "public-key", alg: -257 }
          // RS256
        ],
        authenticatorSelection: {
          authenticatorAttachment: "platform",
          // ONLY platform authenticators
          residentKey: "required",
          userVerification: "required"
        },
        // WebAuthn Level 3: Hint the browser UI to show platform authenticator first
        hints: ["client-device"],
        // Prioritize local device authenticator UI
        extensions: o
      }
    }), n = r.getClientExtensionResults();
    if (!n.prf?.enabled)
      throw new Error("PRF extension not enabled on credential");
    const s = n.prf?.results?.first ? new Uint8Array(n.prf.results.first) : null;
    return {
      credentialId: r.rawId,
      response: r.response,
      prfOutput: s
      // May be null if salt wasn't provided
    };
  } catch (o) {
    throw console.error("Passkey creation error:", o), new Error(`Failed to create passkey: ${o.message}`);
  }
}
const { accountHeaderForInitialAgentSecret: Go, idforHeader: Fo } = Bn;
async function bD({ name: t = "maia", salt: A = "maia.city" } = {}) {
  await Pn();
  const e = jn(A), i = await Ie.create(), { credentialId: o, prfOutput: r } = await xI({
    name: t,
    userId: globalThis.crypto.getRandomValues(new Uint8Array(32)),
    // Random userID - we don't store anything!
    salt: e
  });
  if (!r)
    throw new Error("PRF evaluation failed");
  const n = i.agentSecretFromSecretSeed(r), s = Go(n, i), a = Fo(s, i), g = await qe({ mode: "human", servicePrefix: "CITY" }), I = Wt(), c = await Yn({
    agentSecret: n,
    name: t,
    peers: I ? I.peers : [],
    storage: g
  }), { node: C, account: B, accountID: Q } = c;
  if (I && I.setNode(C), Q !== a)
    throw new Error(
      `CRITICAL: AccountID mismatch!
  Computed: ${a}
  Created:  ${Q}
This should never happen - deterministic computation failed!`
    );
  return {
    accountID: Q,
    agentSecret: n,
    node: C,
    account: B,
    credentialId: HI(o)
  };
}
async function RD({ salt: t = "maia.city" } = {}) {
  await Pn();
  const A = jn(t), { prfOutput: e } = await qI({ salt: A });
  if (!e)
    throw new Error("PRF evaluation failed during sign-in");
  const i = await Ie.create(), o = i.agentSecretFromSecretSeed(e), r = Go(o, i), n = Fo(r, i), s = await qe({ mode: "human", servicePrefix: "CITY" }), a = Wt();
  performance.now();
  const g = (async () => {
    try {
      let I = !1;
      a && a.waitForPeer && (I = await a.waitForPeer());
      const c = await Un({
        accountID: n,
        agentSecret: o,
        peers: a ? a.peers : [],
        storage: s
      }), { node: C, account: B } = c;
      return a && a.setNode(C), console.log("    0 secrets retrieved from storage"), console.log("    Everything computed deterministically!"), {
        accountID: B.id,
        agentSecret: o,
        node: C,
        account: B
      };
    } catch (I) {
      throw console.error(" Account loading failed:", I), console.error("   Error message:", I.message), console.error("   Error stack:", I.stack), console.error("   AccountID:", n), console.error("   Peers available:", a ? a.peers.length : 0), a && a.peers.length > 0 && console.error("   Peer IDs:", a.peers.map((c) => c.id || "unknown")), I;
    }
  })();
  return console.log(" Returning from signInWithPasskey() immediately (account loading in background)..."), {
    accountID: n,
    agentSecret: o,
    loadingPromise: g
  };
}
async function KD({ name: t = "Maia Agent" } = {}) {
  const A = await Ie.create(), e = A.newRandomAgentSecret(), i = Go(e, A);
  return {
    accountID: Fo(i, A),
    agentSecret: e,
    name: t
  };
}
async function vD({ agentSecret: t, name: A = "Maia Agent", syncDomain: e = null, servicePrefix: i = null, dbPath: o = null, inMemory: r = !1 } = {}) {
  if (!t)
    throw new Error(
      "agentSecret is required. Set service-specific env var (e.g., SYNC_MAIA_AGENT_SECRET or CITY_MAIA_AGENT_SECRET). Run `bun agent:generate --service <service>` to generate credentials."
    );
  const n = await Ie.create(), s = Go(t, n), a = Fo(s, n), g = await qe({ mode: "agent", servicePrefix: i, dbPath: o, inMemory: r }), I = Wt(e), c = await Yn({
    agentSecret: t,
    name: A,
    peers: I ? I.peers : [],
    storage: g,
    skipAutoSeeding: !0
    // Agent accounts don't need vibes/views seeding
  }), { node: C, account: B, accountID: Q } = c;
  if (I && I.setNode(C), Q !== a)
    throw new Error(
      `CRITICAL: AccountID mismatch!
  Computed: ${a}
  Created:  ${Q}
This should never happen - deterministic computation failed!`
    );
  return {
    accountID: Q,
    agentSecret: t,
    node: C,
    account: B
  };
}
async function YD({ accountID: t, agentSecret: A, syncDomain: e = null, servicePrefix: i = null, dbPath: o = null, inMemory: r = !1 } = {}) {
  if (!A)
    throw new Error(
      "agentSecret is required. Set service-specific env var (e.g., SYNC_MAIA_AGENT_SECRET or CITY_MAIA_AGENT_SECRET). Run `bun agent:generate --service <service>` to generate credentials."
    );
  if (!t)
    throw new Error(
      "accountID is required. Set service-specific env var (e.g., SYNC_MAIA_AGENT_ACCOUNT_ID or CITY_MAIA_AGENT_ACCOUNT_ID). Run `bun agent:generate --service <service>` to generate credentials."
    );
  const n = await qe({ mode: "agent", servicePrefix: i, dbPath: o, inMemory: r }), s = Wt(e), a = await Un({
    accountID: t,
    agentSecret: A,
    peers: s ? s.peers : [],
    storage: n
  }), { node: g, account: I } = a;
  return s && s.setNode(g), {
    accountID: I.id,
    agentSecret: A,
    node: g,
    account: I
  };
}
const UD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  arrayBufferToBase64: HI,
  createAgentAccount: vD,
  createPasskeyWithPRF: xI,
  evaluatePRF: qI,
  generateAgentCredentials: KD,
  getStorage: qe,
  isPRFSupported: JI,
  loadAgentAccount: YD,
  requirePRFSupport: Pn,
  signInWithPasskey: RD,
  signUpWithPasskey: bD,
  stringToUint8Array: jn
}, Symbol.toStringTag, { value: "Module" }));
function LI(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var ri = { exports: {} }, rr = {}, ie = {}, he = {}, nr = {}, sr = {}, ar = {}, Rs;
function Co() {
  return Rs || (Rs = 1, (function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.regexpCode = t.getEsmExportName = t.getProperty = t.safeStringify = t.stringify = t.strConcat = t.addCodeArg = t.str = t._ = t.nil = t._Code = t.Name = t.IDENTIFIER = t._CodeOrName = void 0;
    class A {
    }
    t._CodeOrName = A, t.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    class e extends A {
      constructor(d) {
        if (super(), !t.IDENTIFIER.test(d))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = d;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return !1;
      }
      get names() {
        return { [this.str]: 1 };
      }
    }
    t.Name = e;
    class i extends A {
      constructor(d) {
        super(), this._items = typeof d == "string" ? [d] : d;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return !1;
        const d = this._items[0];
        return d === "" || d === '""';
      }
      get str() {
        var d;
        return (d = this._str) !== null && d !== void 0 ? d : this._str = this._items.reduce((h, p) => `${h}${p}`, "");
      }
      get names() {
        var d;
        return (d = this._names) !== null && d !== void 0 ? d : this._names = this._items.reduce((h, p) => (p instanceof e && (h[p.str] = (h[p.str] || 0) + 1), h), {});
      }
    }
    t._Code = i, t.nil = new i("");
    function o(u, ...d) {
      const h = [u[0]];
      let p = 0;
      for (; p < d.length; )
        s(h, d[p]), h.push(u[++p]);
      return new i(h);
    }
    t._ = o;
    const r = new i("+");
    function n(u, ...d) {
      const h = [B(u[0])];
      let p = 0;
      for (; p < d.length; )
        h.push(r), s(h, d[p]), h.push(r, B(u[++p]));
      return a(h), new i(h);
    }
    t.str = n;
    function s(u, d) {
      d instanceof i ? u.push(...d._items) : d instanceof e ? u.push(d) : u.push(c(d));
    }
    t.addCodeArg = s;
    function a(u) {
      let d = 1;
      for (; d < u.length - 1; ) {
        if (u[d] === r) {
          const h = g(u[d - 1], u[d + 1]);
          if (h !== void 0) {
            u.splice(d - 1, 3, h);
            continue;
          }
          u[d++] = "+";
        }
        d++;
      }
    }
    function g(u, d) {
      if (d === '""')
        return u;
      if (u === '""')
        return d;
      if (typeof u == "string")
        return d instanceof e || u[u.length - 1] !== '"' ? void 0 : typeof d != "string" ? `${u.slice(0, -1)}${d}"` : d[0] === '"' ? u.slice(0, -1) + d.slice(1) : void 0;
      if (typeof d == "string" && d[0] === '"' && !(u instanceof e))
        return `"${u}${d.slice(1)}`;
    }
    function I(u, d) {
      return d.emptyStr() ? u : u.emptyStr() ? d : n`${u}${d}`;
    }
    t.strConcat = I;
    function c(u) {
      return typeof u == "number" || typeof u == "boolean" || u === null ? u : B(Array.isArray(u) ? u.join(",") : u);
    }
    function C(u) {
      return new i(B(u));
    }
    t.stringify = C;
    function B(u) {
      return JSON.stringify(u).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    t.safeStringify = B;
    function Q(u) {
      return typeof u == "string" && t.IDENTIFIER.test(u) ? new i(`.${u}`) : o`[${u}]`;
    }
    t.getProperty = Q;
    function f(u) {
      if (typeof u == "string" && t.IDENTIFIER.test(u))
        return new i(`${u}`);
      throw new Error(`CodeGen: invalid export name: ${u}, use explicit $id name mapping`);
    }
    t.getEsmExportName = f;
    function l(u) {
      return new i(u.toString());
    }
    t.regexpCode = l;
  })(ar)), ar;
}
var gr = {}, Ks;
function vs() {
  return Ks || (Ks = 1, (function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ValueScope = t.ValueScopeName = t.Scope = t.varKinds = t.UsedValueState = void 0;
    const A = Co();
    class e extends Error {
      constructor(g) {
        super(`CodeGen: "code" for ${g} not defined`), this.value = g.value;
      }
    }
    var i;
    (function(a) {
      a[a.Started = 0] = "Started", a[a.Completed = 1] = "Completed";
    })(i || (t.UsedValueState = i = {})), t.varKinds = {
      const: new A.Name("const"),
      let: new A.Name("let"),
      var: new A.Name("var")
    };
    class o {
      constructor({ prefixes: g, parent: I } = {}) {
        this._names = {}, this._prefixes = g, this._parent = I;
      }
      toName(g) {
        return g instanceof A.Name ? g : this.name(g);
      }
      name(g) {
        return new A.Name(this._newName(g));
      }
      _newName(g) {
        const I = this._names[g] || this._nameGroup(g);
        return `${g}${I.index++}`;
      }
      _nameGroup(g) {
        var I, c;
        if (!((c = (I = this._parent) === null || I === void 0 ? void 0 : I._prefixes) === null || c === void 0) && c.has(g) || this._prefixes && !this._prefixes.has(g))
          throw new Error(`CodeGen: prefix "${g}" is not allowed in this scope`);
        return this._names[g] = { prefix: g, index: 0 };
      }
    }
    t.Scope = o;
    class r extends A.Name {
      constructor(g, I) {
        super(I), this.prefix = g;
      }
      setValue(g, { property: I, itemIndex: c }) {
        this.value = g, this.scopePath = (0, A._)`.${new A.Name(I)}[${c}]`;
      }
    }
    t.ValueScopeName = r;
    const n = (0, A._)`\n`;
    class s extends o {
      constructor(g) {
        super(g), this._values = {}, this._scope = g.scope, this.opts = { ...g, _n: g.lines ? n : A.nil };
      }
      get() {
        return this._scope;
      }
      name(g) {
        return new r(g, this._newName(g));
      }
      value(g, I) {
        var c;
        if (I.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const C = this.toName(g), { prefix: B } = C, Q = (c = I.key) !== null && c !== void 0 ? c : I.ref;
        let f = this._values[B];
        if (f) {
          const d = f.get(Q);
          if (d)
            return d;
        } else
          f = this._values[B] = /* @__PURE__ */ new Map();
        f.set(Q, C);
        const l = this._scope[B] || (this._scope[B] = []), u = l.length;
        return l[u] = I.ref, C.setValue(I, { property: B, itemIndex: u }), C;
      }
      getValue(g, I) {
        const c = this._values[g];
        if (c)
          return c.get(I);
      }
      scopeRefs(g, I = this._values) {
        return this._reduceValues(I, (c) => {
          if (c.scopePath === void 0)
            throw new Error(`CodeGen: name "${c}" has no value`);
          return (0, A._)`${g}${c.scopePath}`;
        });
      }
      scopeCode(g = this._values, I, c) {
        return this._reduceValues(g, (C) => {
          if (C.value === void 0)
            throw new Error(`CodeGen: name "${C}" has no value`);
          return C.value.code;
        }, I, c);
      }
      _reduceValues(g, I, c = {}, C) {
        let B = A.nil;
        for (const Q in g) {
          const f = g[Q];
          if (!f)
            continue;
          const l = c[Q] = c[Q] || /* @__PURE__ */ new Map();
          f.forEach((u) => {
            if (l.has(u))
              return;
            l.set(u, i.Started);
            let d = I(u);
            if (d) {
              const h = this.opts.es5 ? t.varKinds.var : t.varKinds.const;
              B = (0, A._)`${B}${h} ${u} = ${d};${this.opts._n}`;
            } else if (d = C?.(u))
              B = (0, A._)`${B}${d}${this.opts._n}`;
            else
              throw new e(u);
            l.set(u, i.Completed);
          });
        }
        return B;
      }
    }
    t.ValueScope = s;
  })(gr)), gr;
}
var Ys;
function oA() {
  return Ys || (Ys = 1, (function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.or = t.and = t.not = t.CodeGen = t.operators = t.varKinds = t.ValueScopeName = t.ValueScope = t.Scope = t.Name = t.regexpCode = t.stringify = t.getProperty = t.nil = t.strConcat = t.str = t._ = void 0;
    const A = Co(), e = vs();
    var i = Co();
    Object.defineProperty(t, "_", { enumerable: !0, get: function() {
      return i._;
    } }), Object.defineProperty(t, "str", { enumerable: !0, get: function() {
      return i.str;
    } }), Object.defineProperty(t, "strConcat", { enumerable: !0, get: function() {
      return i.strConcat;
    } }), Object.defineProperty(t, "nil", { enumerable: !0, get: function() {
      return i.nil;
    } }), Object.defineProperty(t, "getProperty", { enumerable: !0, get: function() {
      return i.getProperty;
    } }), Object.defineProperty(t, "stringify", { enumerable: !0, get: function() {
      return i.stringify;
    } }), Object.defineProperty(t, "regexpCode", { enumerable: !0, get: function() {
      return i.regexpCode;
    } }), Object.defineProperty(t, "Name", { enumerable: !0, get: function() {
      return i.Name;
    } });
    var o = vs();
    Object.defineProperty(t, "Scope", { enumerable: !0, get: function() {
      return o.Scope;
    } }), Object.defineProperty(t, "ValueScope", { enumerable: !0, get: function() {
      return o.ValueScope;
    } }), Object.defineProperty(t, "ValueScopeName", { enumerable: !0, get: function() {
      return o.ValueScopeName;
    } }), Object.defineProperty(t, "varKinds", { enumerable: !0, get: function() {
      return o.varKinds;
    } }), t.operators = {
      GT: new A._Code(">"),
      GTE: new A._Code(">="),
      LT: new A._Code("<"),
      LTE: new A._Code("<="),
      EQ: new A._Code("==="),
      NEQ: new A._Code("!=="),
      NOT: new A._Code("!"),
      OR: new A._Code("||"),
      AND: new A._Code("&&"),
      ADD: new A._Code("+")
    };
    class r {
      optimizeNodes() {
        return this;
      }
      optimizeNames(D, N) {
        return this;
      }
    }
    class n extends r {
      constructor(D, N, Y) {
        super(), this.varKind = D, this.name = N, this.rhs = Y;
      }
      render({ es5: D, _n: N }) {
        const Y = D ? e.varKinds.var : this.varKind, j = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${Y} ${this.name}${j};` + N;
      }
      optimizeNames(D, N) {
        if (D[this.name.str])
          return this.rhs && (this.rhs = W(this.rhs, D, N)), this;
      }
      get names() {
        return this.rhs instanceof A._CodeOrName ? this.rhs.names : {};
      }
    }
    class s extends r {
      constructor(D, N, Y) {
        super(), this.lhs = D, this.rhs = N, this.sideEffects = Y;
      }
      render({ _n: D }) {
        return `${this.lhs} = ${this.rhs};` + D;
      }
      optimizeNames(D, N) {
        if (!(this.lhs instanceof A.Name && !D[this.lhs.str] && !this.sideEffects))
          return this.rhs = W(this.rhs, D, N), this;
      }
      get names() {
        const D = this.lhs instanceof A.Name ? {} : { ...this.lhs.names };
        return J(D, this.rhs);
      }
    }
    class a extends s {
      constructor(D, N, Y, j) {
        super(D, Y, j), this.op = N;
      }
      render({ _n: D }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + D;
      }
    }
    class g extends r {
      constructor(D) {
        super(), this.label = D, this.names = {};
      }
      render({ _n: D }) {
        return `${this.label}:` + D;
      }
    }
    class I extends r {
      constructor(D) {
        super(), this.label = D, this.names = {};
      }
      render({ _n: D }) {
        return `break${this.label ? ` ${this.label}` : ""};` + D;
      }
    }
    class c extends r {
      constructor(D) {
        super(), this.error = D;
      }
      render({ _n: D }) {
        return `throw ${this.error};` + D;
      }
      get names() {
        return this.error.names;
      }
    }
    class C extends r {
      constructor(D) {
        super(), this.code = D;
      }
      render({ _n: D }) {
        return `${this.code};` + D;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(D, N) {
        return this.code = W(this.code, D, N), this;
      }
      get names() {
        return this.code instanceof A._CodeOrName ? this.code.names : {};
      }
    }
    class B extends r {
      constructor(D = []) {
        super(), this.nodes = D;
      }
      render(D) {
        return this.nodes.reduce((N, Y) => N + Y.render(D), "");
      }
      optimizeNodes() {
        const { nodes: D } = this;
        let N = D.length;
        for (; N--; ) {
          const Y = D[N].optimizeNodes();
          Array.isArray(Y) ? D.splice(N, 1, ...Y) : Y ? D[N] = Y : D.splice(N, 1);
        }
        return D.length > 0 ? this : void 0;
      }
      optimizeNames(D, N) {
        const { nodes: Y } = this;
        let j = Y.length;
        for (; j--; ) {
          const G = Y[j];
          G.optimizeNames(D, N) || (X(D, G.names), Y.splice(j, 1));
        }
        return Y.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((D, N) => P(D, N.names), {});
      }
    }
    class Q extends B {
      render(D) {
        return "{" + D._n + super.render(D) + "}" + D._n;
      }
    }
    class f extends B {
    }
    class l extends Q {
    }
    l.kind = "else";
    class u extends Q {
      constructor(D, N) {
        super(N), this.condition = D;
      }
      render(D) {
        let N = `if(${this.condition})` + super.render(D);
        return this.else && (N += "else " + this.else.render(D)), N;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const D = this.condition;
        if (D === !0)
          return this.nodes;
        let N = this.else;
        if (N) {
          const Y = N.optimizeNodes();
          N = this.else = Array.isArray(Y) ? new l(Y) : Y;
        }
        if (N)
          return D === !1 ? N instanceof u ? N : N.nodes : this.nodes.length ? this : new u(z(D), N instanceof u ? [N] : N.nodes);
        if (!(D === !1 || !this.nodes.length))
          return this;
      }
      optimizeNames(D, N) {
        var Y;
        if (this.else = (Y = this.else) === null || Y === void 0 ? void 0 : Y.optimizeNames(D, N), !!(super.optimizeNames(D, N) || this.else))
          return this.condition = W(this.condition, D, N), this;
      }
      get names() {
        const D = super.names;
        return J(D, this.condition), this.else && P(D, this.else.names), D;
      }
    }
    u.kind = "if";
    class d extends Q {
    }
    d.kind = "for";
    class h extends d {
      constructor(D) {
        super(), this.iteration = D;
      }
      render(D) {
        return `for(${this.iteration})` + super.render(D);
      }
      optimizeNames(D, N) {
        if (super.optimizeNames(D, N))
          return this.iteration = W(this.iteration, D, N), this;
      }
      get names() {
        return P(super.names, this.iteration.names);
      }
    }
    class p extends d {
      constructor(D, N, Y, j) {
        super(), this.varKind = D, this.name = N, this.from = Y, this.to = j;
      }
      render(D) {
        const N = D.es5 ? e.varKinds.var : this.varKind, { name: Y, from: j, to: G } = this;
        return `for(${N} ${Y}=${j}; ${Y}<${G}; ${Y}++)` + super.render(D);
      }
      get names() {
        const D = J(super.names, this.from);
        return J(D, this.to);
      }
    }
    class E extends d {
      constructor(D, N, Y, j) {
        super(), this.loop = D, this.varKind = N, this.name = Y, this.iterable = j;
      }
      render(D) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(D);
      }
      optimizeNames(D, N) {
        if (super.optimizeNames(D, N))
          return this.iterable = W(this.iterable, D, N), this;
      }
      get names() {
        return P(super.names, this.iterable.names);
      }
    }
    class w extends Q {
      constructor(D, N, Y) {
        super(), this.name = D, this.args = N, this.async = Y;
      }
      render(D) {
        return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(D);
      }
    }
    w.kind = "func";
    class y extends B {
      render(D) {
        return "return " + super.render(D);
      }
    }
    y.kind = "return";
    class m extends Q {
      render(D) {
        let N = "try" + super.render(D);
        return this.catch && (N += this.catch.render(D)), this.finally && (N += this.finally.render(D)), N;
      }
      optimizeNodes() {
        var D, N;
        return super.optimizeNodes(), (D = this.catch) === null || D === void 0 || D.optimizeNodes(), (N = this.finally) === null || N === void 0 || N.optimizeNodes(), this;
      }
      optimizeNames(D, N) {
        var Y, j;
        return super.optimizeNames(D, N), (Y = this.catch) === null || Y === void 0 || Y.optimizeNames(D, N), (j = this.finally) === null || j === void 0 || j.optimizeNames(D, N), this;
      }
      get names() {
        const D = super.names;
        return this.catch && P(D, this.catch.names), this.finally && P(D, this.finally.names), D;
      }
    }
    class k extends Q {
      constructor(D) {
        super(), this.error = D;
      }
      render(D) {
        return `catch(${this.error})` + super.render(D);
      }
    }
    k.kind = "catch";
    class b extends Q {
      render(D) {
        return "finally" + super.render(D);
      }
    }
    b.kind = "finally";
    class q {
      constructor(D, N = {}) {
        this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...N, _n: N.lines ? `
` : "" }, this._extScope = D, this._scope = new e.Scope({ parent: D }), this._nodes = [new f()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(D) {
        return this._scope.name(D);
      }
      // reserves unique name in the external scope
      scopeName(D) {
        return this._extScope.name(D);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(D, N) {
        const Y = this._extScope.value(D, N);
        return (this._values[Y.prefix] || (this._values[Y.prefix] = /* @__PURE__ */ new Set())).add(Y), Y;
      }
      getScopeValue(D, N) {
        return this._extScope.getValue(D, N);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(D) {
        return this._extScope.scopeRefs(D, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(D, N, Y, j) {
        const G = this._scope.toName(N);
        return Y !== void 0 && j && (this._constants[G.str] = Y), this._leafNode(new n(D, G, Y)), G;
      }
      // `const` declaration (`var` in es5 mode)
      const(D, N, Y) {
        return this._def(e.varKinds.const, D, N, Y);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(D, N, Y) {
        return this._def(e.varKinds.let, D, N, Y);
      }
      // `var` declaration with optional assignment
      var(D, N, Y) {
        return this._def(e.varKinds.var, D, N, Y);
      }
      // assignment code
      assign(D, N, Y) {
        return this._leafNode(new s(D, N, Y));
      }
      // `+=` code
      add(D, N) {
        return this._leafNode(new a(D, t.operators.ADD, N));
      }
      // appends passed SafeExpr to code or executes Block
      code(D) {
        return typeof D == "function" ? D() : D !== A.nil && this._leafNode(new C(D)), this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...D) {
        const N = ["{"];
        for (const [Y, j] of D)
          N.length > 1 && N.push(","), N.push(Y), (Y !== j || this.opts.es5) && (N.push(":"), (0, A.addCodeArg)(N, j));
        return N.push("}"), new A._Code(N);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(D, N, Y) {
        if (this._blockNode(new u(D)), N && Y)
          this.code(N).else().code(Y).endIf();
        else if (N)
          this.code(N).endIf();
        else if (Y)
          throw new Error('CodeGen: "else" body without "then" body');
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(D) {
        return this._elseNode(new u(D));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new l());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(u, l);
      }
      _for(D, N) {
        return this._blockNode(D), N && this.code(N).endFor(), this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(D, N) {
        return this._for(new h(D), N);
      }
      // `for` statement for a range of values
      forRange(D, N, Y, j, G = this.opts.es5 ? e.varKinds.var : e.varKinds.let) {
        const L = this._scope.toName(D);
        return this._for(new p(G, L, N, Y), () => j(L));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(D, N, Y, j = e.varKinds.const) {
        const G = this._scope.toName(D);
        if (this.opts.es5) {
          const L = N instanceof A.Name ? N : this.var("_arr", N);
          return this.forRange("_i", 0, (0, A._)`${L}.length`, (v) => {
            this.var(G, (0, A._)`${L}[${v}]`), Y(G);
          });
        }
        return this._for(new E("of", j, G, N), () => Y(G));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(D, N, Y, j = this.opts.es5 ? e.varKinds.var : e.varKinds.const) {
        if (this.opts.ownProperties)
          return this.forOf(D, (0, A._)`Object.keys(${N})`, Y);
        const G = this._scope.toName(D);
        return this._for(new E("in", j, G, N), () => Y(G));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(d);
      }
      // `label` statement
      label(D) {
        return this._leafNode(new g(D));
      }
      // `break` statement
      break(D) {
        return this._leafNode(new I(D));
      }
      // `return` statement
      return(D) {
        const N = new y();
        if (this._blockNode(N), this.code(D), N.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(y);
      }
      // `try` statement
      try(D, N, Y) {
        if (!N && !Y)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const j = new m();
        if (this._blockNode(j), this.code(D), N) {
          const G = this.name("e");
          this._currNode = j.catch = new k(G), N(G);
        }
        return Y && (this._currNode = j.finally = new b(), this.code(Y)), this._endBlockNode(k, b);
      }
      // `throw` statement
      throw(D) {
        return this._leafNode(new c(D));
      }
      // start self-balancing block
      block(D, N) {
        return this._blockStarts.push(this._nodes.length), D && this.code(D).endBlock(N), this;
      }
      // end the current self-balancing block
      endBlock(D) {
        const N = this._blockStarts.pop();
        if (N === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const Y = this._nodes.length - N;
        if (Y < 0 || D !== void 0 && Y !== D)
          throw new Error(`CodeGen: wrong number of nodes: ${Y} vs ${D} expected`);
        return this._nodes.length = N, this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(D, N = A.nil, Y, j) {
        return this._blockNode(new w(D, N, Y)), j && this.code(j).endFunc(), this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(w);
      }
      optimize(D = 1) {
        for (; D-- > 0; )
          this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
      }
      _leafNode(D) {
        return this._currNode.nodes.push(D), this;
      }
      _blockNode(D) {
        this._currNode.nodes.push(D), this._nodes.push(D);
      }
      _endBlockNode(D, N) {
        const Y = this._currNode;
        if (Y instanceof D || N && Y instanceof N)
          return this._nodes.pop(), this;
        throw new Error(`CodeGen: not in block "${N ? `${D.kind}/${N.kind}` : D.kind}"`);
      }
      _elseNode(D) {
        const N = this._currNode;
        if (!(N instanceof u))
          throw new Error('CodeGen: "else" without "if"');
        return this._currNode = N.else = D, this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const D = this._nodes;
        return D[D.length - 1];
      }
      set _currNode(D) {
        const N = this._nodes;
        N[N.length - 1] = D;
      }
    }
    t.CodeGen = q;
    function P(R, D) {
      for (const N in D)
        R[N] = (R[N] || 0) + (D[N] || 0);
      return R;
    }
    function J(R, D) {
      return D instanceof A._CodeOrName ? P(R, D.names) : R;
    }
    function W(R, D, N) {
      if (R instanceof A.Name)
        return Y(R);
      if (!j(R))
        return R;
      return new A._Code(R._items.reduce((G, L) => (L instanceof A.Name && (L = Y(L)), L instanceof A._Code ? G.push(...L._items) : G.push(L), G), []));
      function Y(G) {
        const L = N[G.str];
        return L === void 0 || D[G.str] !== 1 ? G : (delete D[G.str], L);
      }
      function j(G) {
        return G instanceof A._Code && G._items.some((L) => L instanceof A.Name && D[L.str] === 1 && N[L.str] !== void 0);
      }
    }
    function X(R, D) {
      for (const N in D)
        R[N] = (R[N] || 0) - (D[N] || 0);
    }
    function z(R) {
      return typeof R == "boolean" || typeof R == "number" || R === null ? !R : (0, A._)`!${x(R)}`;
    }
    t.not = z;
    const _ = F(t.operators.AND);
    function O(...R) {
      return R.reduce(_);
    }
    t.and = O;
    const Z = F(t.operators.OR);
    function T(...R) {
      return R.reduce(Z);
    }
    t.or = T;
    function F(R) {
      return (D, N) => D === A.nil ? N : N === A.nil ? D : (0, A._)`${x(D)} ${R} ${x(N)}`;
    }
    function x(R) {
      return R instanceof A.Name ? R : (0, A._)`(${R})`;
    }
  })(sr)), sr;
}
var rA = {}, Us;
function aA() {
  if (Us) return rA;
  Us = 1, Object.defineProperty(rA, "__esModule", { value: !0 }), rA.checkStrictMode = rA.getErrorPath = rA.Type = rA.useFunc = rA.setEvaluated = rA.evaluatedPropsToName = rA.mergeEvaluated = rA.eachItem = rA.unescapeJsonPointer = rA.escapeJsonPointer = rA.escapeFragment = rA.unescapeFragment = rA.schemaRefOrVal = rA.schemaHasRulesButRef = rA.schemaHasRules = rA.checkUnknownRules = rA.alwaysValidSchema = rA.toHash = void 0;
  const t = oA(), A = Co();
  function e(E) {
    const w = {};
    for (const y of E)
      w[y] = !0;
    return w;
  }
  rA.toHash = e;
  function i(E, w) {
    return typeof w == "boolean" ? w : Object.keys(w).length === 0 ? !0 : (o(E, w), !r(w, E.self.RULES.all));
  }
  rA.alwaysValidSchema = i;
  function o(E, w = E.schema) {
    const { opts: y, self: m } = E;
    if (!y.strictSchema || typeof w == "boolean")
      return;
    const k = m.RULES.keywords;
    for (const b in w)
      k[b] || p(E, `unknown keyword: "${b}"`);
  }
  rA.checkUnknownRules = o;
  function r(E, w) {
    if (typeof E == "boolean")
      return !E;
    for (const y in E)
      if (w[y])
        return !0;
    return !1;
  }
  rA.schemaHasRules = r;
  function n(E, w) {
    if (typeof E == "boolean")
      return !E;
    for (const y in E)
      if (y !== "$ref" && w.all[y])
        return !0;
    return !1;
  }
  rA.schemaHasRulesButRef = n;
  function s({ topSchemaRef: E, schemaPath: w }, y, m, k) {
    if (!k) {
      if (typeof y == "number" || typeof y == "boolean")
        return y;
      if (typeof y == "string")
        return (0, t._)`${y}`;
    }
    return (0, t._)`${E}${w}${(0, t.getProperty)(m)}`;
  }
  rA.schemaRefOrVal = s;
  function a(E) {
    return c(decodeURIComponent(E));
  }
  rA.unescapeFragment = a;
  function g(E) {
    return encodeURIComponent(I(E));
  }
  rA.escapeFragment = g;
  function I(E) {
    return typeof E == "number" ? `${E}` : E.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  rA.escapeJsonPointer = I;
  function c(E) {
    return E.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  rA.unescapeJsonPointer = c;
  function C(E, w) {
    if (Array.isArray(E))
      for (const y of E)
        w(y);
    else
      w(E);
  }
  rA.eachItem = C;
  function B({ mergeNames: E, mergeToName: w, mergeValues: y, resultToName: m }) {
    return (k, b, q, P) => {
      const J = q === void 0 ? b : q instanceof t.Name ? (b instanceof t.Name ? E(k, b, q) : w(k, b, q), q) : b instanceof t.Name ? (w(k, q, b), b) : y(b, q);
      return P === t.Name && !(J instanceof t.Name) ? m(k, J) : J;
    };
  }
  rA.mergeEvaluated = {
    props: B({
      mergeNames: (E, w, y) => E.if((0, t._)`${y} !== true && ${w} !== undefined`, () => {
        E.if((0, t._)`${w} === true`, () => E.assign(y, !0), () => E.assign(y, (0, t._)`${y} || {}`).code((0, t._)`Object.assign(${y}, ${w})`));
      }),
      mergeToName: (E, w, y) => E.if((0, t._)`${y} !== true`, () => {
        w === !0 ? E.assign(y, !0) : (E.assign(y, (0, t._)`${y} || {}`), f(E, y, w));
      }),
      mergeValues: (E, w) => E === !0 ? !0 : { ...E, ...w },
      resultToName: Q
    }),
    items: B({
      mergeNames: (E, w, y) => E.if((0, t._)`${y} !== true && ${w} !== undefined`, () => E.assign(y, (0, t._)`${w} === true ? true : ${y} > ${w} ? ${y} : ${w}`)),
      mergeToName: (E, w, y) => E.if((0, t._)`${y} !== true`, () => E.assign(y, w === !0 ? !0 : (0, t._)`${y} > ${w} ? ${y} : ${w}`)),
      mergeValues: (E, w) => E === !0 ? !0 : Math.max(E, w),
      resultToName: (E, w) => E.var("items", w)
    })
  };
  function Q(E, w) {
    if (w === !0)
      return E.var("props", !0);
    const y = E.var("props", (0, t._)`{}`);
    return w !== void 0 && f(E, y, w), y;
  }
  rA.evaluatedPropsToName = Q;
  function f(E, w, y) {
    Object.keys(y).forEach((m) => E.assign((0, t._)`${w}${(0, t.getProperty)(m)}`, !0));
  }
  rA.setEvaluated = f;
  const l = {};
  function u(E, w) {
    return E.scopeValue("func", {
      ref: w,
      code: l[w.code] || (l[w.code] = new A._Code(w.code))
    });
  }
  rA.useFunc = u;
  var d;
  (function(E) {
    E[E.Num = 0] = "Num", E[E.Str = 1] = "Str";
  })(d || (rA.Type = d = {}));
  function h(E, w, y) {
    if (E instanceof t.Name) {
      const m = w === d.Num;
      return y ? m ? (0, t._)`"[" + ${E} + "]"` : (0, t._)`"['" + ${E} + "']"` : m ? (0, t._)`"/" + ${E}` : (0, t._)`"/" + ${E}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return y ? (0, t.getProperty)(E).toString() : "/" + I(E);
  }
  rA.getErrorPath = h;
  function p(E, w, y = E.opts.strictSchema) {
    if (y) {
      if (w = `strict mode: ${w}`, y === !0)
        throw new Error(w);
      E.self.logger.warn(w);
    }
  }
  return rA.checkStrictMode = p, rA;
}
var ni = {}, Js;
function zA() {
  if (Js) return ni;
  Js = 1, Object.defineProperty(ni, "__esModule", { value: !0 });
  const t = oA(), A = {
    // validation function arguments
    data: new t.Name("data"),
    // data passed to validation function
    // args passed from referencing schema
    valCxt: new t.Name("valCxt"),
    // validation/data context - should not be used directly, it is destructured to the names below
    instancePath: new t.Name("instancePath"),
    parentData: new t.Name("parentData"),
    parentDataProperty: new t.Name("parentDataProperty"),
    rootData: new t.Name("rootData"),
    // root data - same as the data passed to the first/top validation function
    dynamicAnchors: new t.Name("dynamicAnchors"),
    // used to support recursiveRef and dynamicRef
    // function scoped variables
    vErrors: new t.Name("vErrors"),
    // null or array of validation errors
    errors: new t.Name("errors"),
    // counter of validation errors
    this: new t.Name("this"),
    // "globals"
    self: new t.Name("self"),
    scope: new t.Name("scope"),
    // JTD serialize/parse name for JSON string and position
    json: new t.Name("json"),
    jsonPos: new t.Name("jsonPos"),
    jsonLen: new t.Name("jsonLen"),
    jsonPart: new t.Name("jsonPart")
  };
  return ni.default = A, ni;
}
var Hs;
function bo() {
  return Hs || (Hs = 1, (function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.extendErrors = t.resetErrorsCount = t.reportExtraError = t.reportError = t.keyword$DataError = t.keywordError = void 0;
    const A = oA(), e = aA(), i = zA();
    t.keywordError = {
      message: ({ keyword: l }) => (0, A.str)`must pass "${l}" keyword validation`
    }, t.keyword$DataError = {
      message: ({ keyword: l, schemaType: u }) => u ? (0, A.str)`"${l}" keyword must be ${u} ($data)` : (0, A.str)`"${l}" keyword is invalid ($data)`
    };
    function o(l, u = t.keywordError, d, h) {
      const { it: p } = l, { gen: E, compositeRule: w, allErrors: y } = p, m = c(l, u, d);
      h ?? (w || y) ? a(E, m) : g(p, (0, A._)`[${m}]`);
    }
    t.reportError = o;
    function r(l, u = t.keywordError, d) {
      const { it: h } = l, { gen: p, compositeRule: E, allErrors: w } = h, y = c(l, u, d);
      a(p, y), E || w || g(h, i.default.vErrors);
    }
    t.reportExtraError = r;
    function n(l, u) {
      l.assign(i.default.errors, u), l.if((0, A._)`${i.default.vErrors} !== null`, () => l.if(u, () => l.assign((0, A._)`${i.default.vErrors}.length`, u), () => l.assign(i.default.vErrors, null)));
    }
    t.resetErrorsCount = n;
    function s({ gen: l, keyword: u, schemaValue: d, data: h, errsCount: p, it: E }) {
      if (p === void 0)
        throw new Error("ajv implementation error");
      const w = l.name("err");
      l.forRange("i", p, i.default.errors, (y) => {
        l.const(w, (0, A._)`${i.default.vErrors}[${y}]`), l.if((0, A._)`${w}.instancePath === undefined`, () => l.assign((0, A._)`${w}.instancePath`, (0, A.strConcat)(i.default.instancePath, E.errorPath))), l.assign((0, A._)`${w}.schemaPath`, (0, A.str)`${E.errSchemaPath}/${u}`), E.opts.verbose && (l.assign((0, A._)`${w}.schema`, d), l.assign((0, A._)`${w}.data`, h));
      });
    }
    t.extendErrors = s;
    function a(l, u) {
      const d = l.const("err", u);
      l.if((0, A._)`${i.default.vErrors} === null`, () => l.assign(i.default.vErrors, (0, A._)`[${d}]`), (0, A._)`${i.default.vErrors}.push(${d})`), l.code((0, A._)`${i.default.errors}++`);
    }
    function g(l, u) {
      const { gen: d, validateName: h, schemaEnv: p } = l;
      p.$async ? d.throw((0, A._)`new ${l.ValidationError}(${u})`) : (d.assign((0, A._)`${h}.errors`, u), d.return(!1));
    }
    const I = {
      keyword: new A.Name("keyword"),
      schemaPath: new A.Name("schemaPath"),
      // also used in JTD errors
      params: new A.Name("params"),
      propertyName: new A.Name("propertyName"),
      message: new A.Name("message"),
      schema: new A.Name("schema"),
      parentSchema: new A.Name("parentSchema")
    };
    function c(l, u, d) {
      const { createErrors: h } = l.it;
      return h === !1 ? (0, A._)`{}` : C(l, u, d);
    }
    function C(l, u, d = {}) {
      const { gen: h, it: p } = l, E = [
        B(p, d),
        Q(l, d)
      ];
      return f(l, u, E), h.object(...E);
    }
    function B({ errorPath: l }, { instancePath: u }) {
      const d = u ? (0, A.str)`${l}${(0, e.getErrorPath)(u, e.Type.Str)}` : l;
      return [i.default.instancePath, (0, A.strConcat)(i.default.instancePath, d)];
    }
    function Q({ keyword: l, it: { errSchemaPath: u } }, { schemaPath: d, parentSchema: h }) {
      let p = h ? u : (0, A.str)`${u}/${l}`;
      return d && (p = (0, A.str)`${p}${(0, e.getErrorPath)(d, e.Type.Str)}`), [I.schemaPath, p];
    }
    function f(l, { params: u, message: d }, h) {
      const { keyword: p, data: E, schemaValue: w, it: y } = l, { opts: m, propertyName: k, topSchemaRef: b, schemaPath: q } = y;
      h.push([I.keyword, p], [I.params, typeof u == "function" ? u(l) : u || (0, A._)`{}`]), m.messages && h.push([I.message, typeof d == "function" ? d(l) : d]), m.verbose && h.push([I.schema, w], [I.parentSchema, (0, A._)`${b}${q}`], [i.default.data, E]), k && h.push([I.propertyName, k]);
    }
  })(nr)), nr;
}
var qs;
function JD() {
  if (qs) return he;
  qs = 1, Object.defineProperty(he, "__esModule", { value: !0 }), he.boolOrEmptySchema = he.topBoolOrEmptySchema = void 0;
  const t = bo(), A = oA(), e = zA(), i = {
    message: "boolean schema is false"
  };
  function o(s) {
    const { gen: a, schema: g, validateName: I } = s;
    g === !1 ? n(s, !1) : typeof g == "object" && g.$async === !0 ? a.return(e.default.data) : (a.assign((0, A._)`${I}.errors`, null), a.return(!0));
  }
  he.topBoolOrEmptySchema = o;
  function r(s, a) {
    const { gen: g, schema: I } = s;
    I === !1 ? (g.var(a, !1), n(s)) : g.var(a, !0);
  }
  he.boolOrEmptySchema = r;
  function n(s, a) {
    const { gen: g, data: I } = s, c = {
      gen: g,
      keyword: "false schema",
      data: I,
      schema: !1,
      schemaCode: !1,
      schemaValue: !1,
      params: {},
      it: s
    };
    (0, t.reportError)(c, i, void 0, a);
  }
  return he;
}
var mA = {}, fe = {}, xs;
function TI() {
  if (xs) return fe;
  xs = 1, Object.defineProperty(fe, "__esModule", { value: !0 }), fe.getRules = fe.isJSONType = void 0;
  const t = ["string", "number", "integer", "boolean", "null", "object", "array"], A = new Set(t);
  function e(o) {
    return typeof o == "string" && A.has(o);
  }
  fe.isJSONType = e;
  function i() {
    const o = {
      number: { type: "number", rules: [] },
      string: { type: "string", rules: [] },
      array: { type: "array", rules: [] },
      object: { type: "object", rules: [] }
    };
    return {
      types: { ...o, integer: !0, boolean: !0, null: !0 },
      rules: [{ rules: [] }, o.number, o.string, o.array, o.object],
      post: { rules: [] },
      all: {},
      keywords: {}
    };
  }
  return fe.getRules = i, fe;
}
var oe = {}, Ls;
function OI() {
  if (Ls) return oe;
  Ls = 1, Object.defineProperty(oe, "__esModule", { value: !0 }), oe.shouldUseRule = oe.shouldUseGroup = oe.schemaHasRulesForType = void 0;
  function t({ schema: i, self: o }, r) {
    const n = o.RULES.types[r];
    return n && n !== !0 && A(i, n);
  }
  oe.schemaHasRulesForType = t;
  function A(i, o) {
    return o.rules.some((r) => e(i, r));
  }
  oe.shouldUseGroup = A;
  function e(i, o) {
    var r;
    return i[o.keyword] !== void 0 || ((r = o.definition.implements) === null || r === void 0 ? void 0 : r.some((n) => i[n] !== void 0));
  }
  return oe.shouldUseRule = e, oe;
}
var Ts;
function Bo() {
  if (Ts) return mA;
  Ts = 1, Object.defineProperty(mA, "__esModule", { value: !0 }), mA.reportTypeError = mA.checkDataTypes = mA.checkDataType = mA.coerceAndCheckDataType = mA.getJSONTypes = mA.getSchemaTypes = mA.DataType = void 0;
  const t = TI(), A = OI(), e = bo(), i = oA(), o = aA();
  var r;
  (function(d) {
    d[d.Correct = 0] = "Correct", d[d.Wrong = 1] = "Wrong";
  })(r || (mA.DataType = r = {}));
  function n(d) {
    const h = s(d.type);
    if (h.includes("null")) {
      if (d.nullable === !1)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!h.length && d.nullable !== void 0)
        throw new Error('"nullable" cannot be used without "type"');
      d.nullable === !0 && h.push("null");
    }
    return h;
  }
  mA.getSchemaTypes = n;
  function s(d) {
    const h = Array.isArray(d) ? d : d ? [d] : [];
    if (h.every(t.isJSONType))
      return h;
    throw new Error("type must be JSONType or JSONType[]: " + h.join(","));
  }
  mA.getJSONTypes = s;
  function a(d, h) {
    const { gen: p, data: E, opts: w } = d, y = I(h, w.coerceTypes), m = h.length > 0 && !(y.length === 0 && h.length === 1 && (0, A.schemaHasRulesForType)(d, h[0]));
    if (m) {
      const k = Q(h, E, w.strictNumbers, r.Wrong);
      p.if(k, () => {
        y.length ? c(d, h, y) : l(d);
      });
    }
    return m;
  }
  mA.coerceAndCheckDataType = a;
  const g = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
  function I(d, h) {
    return h ? d.filter((p) => g.has(p) || h === "array" && p === "array") : [];
  }
  function c(d, h, p) {
    const { gen: E, data: w, opts: y } = d, m = E.let("dataType", (0, i._)`typeof ${w}`), k = E.let("coerced", (0, i._)`undefined`);
    y.coerceTypes === "array" && E.if((0, i._)`${m} == 'object' && Array.isArray(${w}) && ${w}.length == 1`, () => E.assign(w, (0, i._)`${w}[0]`).assign(m, (0, i._)`typeof ${w}`).if(Q(h, w, y.strictNumbers), () => E.assign(k, w))), E.if((0, i._)`${k} !== undefined`);
    for (const q of p)
      (g.has(q) || q === "array" && y.coerceTypes === "array") && b(q);
    E.else(), l(d), E.endIf(), E.if((0, i._)`${k} !== undefined`, () => {
      E.assign(w, k), C(d, k);
    });
    function b(q) {
      switch (q) {
        case "string":
          E.elseIf((0, i._)`${m} == "number" || ${m} == "boolean"`).assign(k, (0, i._)`"" + ${w}`).elseIf((0, i._)`${w} === null`).assign(k, (0, i._)`""`);
          return;
        case "number":
          E.elseIf((0, i._)`${m} == "boolean" || ${w} === null
              || (${m} == "string" && ${w} && ${w} == +${w})`).assign(k, (0, i._)`+${w}`);
          return;
        case "integer":
          E.elseIf((0, i._)`${m} === "boolean" || ${w} === null
              || (${m} === "string" && ${w} && ${w} == +${w} && !(${w} % 1))`).assign(k, (0, i._)`+${w}`);
          return;
        case "boolean":
          E.elseIf((0, i._)`${w} === "false" || ${w} === 0 || ${w} === null`).assign(k, !1).elseIf((0, i._)`${w} === "true" || ${w} === 1`).assign(k, !0);
          return;
        case "null":
          E.elseIf((0, i._)`${w} === "" || ${w} === 0 || ${w} === false`), E.assign(k, null);
          return;
        case "array":
          E.elseIf((0, i._)`${m} === "string" || ${m} === "number"
              || ${m} === "boolean" || ${w} === null`).assign(k, (0, i._)`[${w}]`);
      }
    }
  }
  function C({ gen: d, parentData: h, parentDataProperty: p }, E) {
    d.if((0, i._)`${h} !== undefined`, () => d.assign((0, i._)`${h}[${p}]`, E));
  }
  function B(d, h, p, E = r.Correct) {
    const w = E === r.Correct ? i.operators.EQ : i.operators.NEQ;
    let y;
    switch (d) {
      case "null":
        return (0, i._)`${h} ${w} null`;
      case "array":
        y = (0, i._)`Array.isArray(${h})`;
        break;
      case "object":
        y = (0, i._)`${h} && typeof ${h} == "object" && !Array.isArray(${h})`;
        break;
      case "integer":
        y = m((0, i._)`!(${h} % 1) && !isNaN(${h})`);
        break;
      case "number":
        y = m();
        break;
      default:
        return (0, i._)`typeof ${h} ${w} ${d}`;
    }
    return E === r.Correct ? y : (0, i.not)(y);
    function m(k = i.nil) {
      return (0, i.and)((0, i._)`typeof ${h} == "number"`, k, p ? (0, i._)`isFinite(${h})` : i.nil);
    }
  }
  mA.checkDataType = B;
  function Q(d, h, p, E) {
    if (d.length === 1)
      return B(d[0], h, p, E);
    let w;
    const y = (0, o.toHash)(d);
    if (y.array && y.object) {
      const m = (0, i._)`typeof ${h} != "object"`;
      w = y.null ? m : (0, i._)`!${h} || ${m}`, delete y.null, delete y.array, delete y.object;
    } else
      w = i.nil;
    y.number && delete y.integer;
    for (const m in y)
      w = (0, i.and)(w, B(m, h, p, E));
    return w;
  }
  mA.checkDataTypes = Q;
  const f = {
    message: ({ schema: d }) => `must be ${d}`,
    params: ({ schema: d, schemaValue: h }) => typeof d == "string" ? (0, i._)`{type: ${d}}` : (0, i._)`{type: ${h}}`
  };
  function l(d) {
    const h = u(d);
    (0, e.reportError)(h, f);
  }
  mA.reportTypeError = l;
  function u(d) {
    const { gen: h, data: p, schema: E } = d, w = (0, o.schemaRefOrVal)(d, E, "type");
    return {
      gen: h,
      keyword: "type",
      data: p,
      schema: E.type,
      schemaCode: w,
      schemaValue: w,
      parentSchema: E,
      params: {},
      it: d
    };
  }
  return mA;
}
var ut = {}, Os;
function HD() {
  if (Os) return ut;
  Os = 1, Object.defineProperty(ut, "__esModule", { value: !0 }), ut.assignDefaults = void 0;
  const t = oA(), A = aA();
  function e(o, r) {
    const { properties: n, items: s } = o.schema;
    if (r === "object" && n)
      for (const a in n)
        i(o, a, n[a].default);
    else r === "array" && Array.isArray(s) && s.forEach((a, g) => i(o, g, a.default));
  }
  ut.assignDefaults = e;
  function i(o, r, n) {
    const { gen: s, compositeRule: a, data: g, opts: I } = o;
    if (n === void 0)
      return;
    const c = (0, t._)`${g}${(0, t.getProperty)(r)}`;
    if (a) {
      (0, A.checkStrictMode)(o, `default is ignored for: ${c}`);
      return;
    }
    let C = (0, t._)`${c} === undefined`;
    I.useDefaults === "empty" && (C = (0, t._)`${C} || ${c} === null || ${c} === ""`), s.if(C, (0, t._)`${c} = ${(0, t.stringify)(n)}`);
  }
  return ut;
}
var PA = {}, cA = {}, Ps;
function _A() {
  if (Ps) return cA;
  Ps = 1, Object.defineProperty(cA, "__esModule", { value: !0 }), cA.validateUnion = cA.validateArray = cA.usePattern = cA.callValidateCode = cA.schemaProperties = cA.allSchemaProperties = cA.noPropertyInData = cA.propertyInData = cA.isOwnProperty = cA.hasPropFunc = cA.reportMissingProp = cA.checkMissingProp = cA.checkReportMissingProp = void 0;
  const t = oA(), A = aA(), e = zA(), i = aA();
  function o(d, h) {
    const { gen: p, data: E, it: w } = d;
    p.if(I(p, E, h, w.opts.ownProperties), () => {
      d.setParams({ missingProperty: (0, t._)`${h}` }, !0), d.error();
    });
  }
  cA.checkReportMissingProp = o;
  function r({ gen: d, data: h, it: { opts: p } }, E, w) {
    return (0, t.or)(...E.map((y) => (0, t.and)(I(d, h, y, p.ownProperties), (0, t._)`${w} = ${y}`)));
  }
  cA.checkMissingProp = r;
  function n(d, h) {
    d.setParams({ missingProperty: h }, !0), d.error();
  }
  cA.reportMissingProp = n;
  function s(d) {
    return d.scopeValue("func", {
      // eslint-disable-next-line @typescript-eslint/unbound-method
      ref: Object.prototype.hasOwnProperty,
      code: (0, t._)`Object.prototype.hasOwnProperty`
    });
  }
  cA.hasPropFunc = s;
  function a(d, h, p) {
    return (0, t._)`${s(d)}.call(${h}, ${p})`;
  }
  cA.isOwnProperty = a;
  function g(d, h, p, E) {
    const w = (0, t._)`${h}${(0, t.getProperty)(p)} !== undefined`;
    return E ? (0, t._)`${w} && ${a(d, h, p)}` : w;
  }
  cA.propertyInData = g;
  function I(d, h, p, E) {
    const w = (0, t._)`${h}${(0, t.getProperty)(p)} === undefined`;
    return E ? (0, t.or)(w, (0, t.not)(a(d, h, p))) : w;
  }
  cA.noPropertyInData = I;
  function c(d) {
    return d ? Object.keys(d).filter((h) => h !== "__proto__") : [];
  }
  cA.allSchemaProperties = c;
  function C(d, h) {
    return c(h).filter((p) => !(0, A.alwaysValidSchema)(d, h[p]));
  }
  cA.schemaProperties = C;
  function B({ schemaCode: d, data: h, it: { gen: p, topSchemaRef: E, schemaPath: w, errorPath: y }, it: m }, k, b, q) {
    const P = q ? (0, t._)`${d}, ${h}, ${E}${w}` : h, J = [
      [e.default.instancePath, (0, t.strConcat)(e.default.instancePath, y)],
      [e.default.parentData, m.parentData],
      [e.default.parentDataProperty, m.parentDataProperty],
      [e.default.rootData, e.default.rootData]
    ];
    m.opts.dynamicRef && J.push([e.default.dynamicAnchors, e.default.dynamicAnchors]);
    const W = (0, t._)`${P}, ${p.object(...J)}`;
    return b !== t.nil ? (0, t._)`${k}.call(${b}, ${W})` : (0, t._)`${k}(${W})`;
  }
  cA.callValidateCode = B;
  const Q = (0, t._)`new RegExp`;
  function f({ gen: d, it: { opts: h } }, p) {
    const E = h.unicodeRegExp ? "u" : "", { regExp: w } = h.code, y = w(p, E);
    return d.scopeValue("pattern", {
      key: y.toString(),
      ref: y,
      code: (0, t._)`${w.code === "new RegExp" ? Q : (0, i.useFunc)(d, w)}(${p}, ${E})`
    });
  }
  cA.usePattern = f;
  function l(d) {
    const { gen: h, data: p, keyword: E, it: w } = d, y = h.name("valid");
    if (w.allErrors) {
      const k = h.let("valid", !0);
      return m(() => h.assign(k, !1)), k;
    }
    return h.var(y, !0), m(() => h.break()), y;
    function m(k) {
      const b = h.const("len", (0, t._)`${p}.length`);
      h.forRange("i", 0, b, (q) => {
        d.subschema({
          keyword: E,
          dataProp: q,
          dataPropType: A.Type.Num
        }, y), h.if((0, t.not)(y), k);
      });
    }
  }
  cA.validateArray = l;
  function u(d) {
    const { gen: h, schema: p, keyword: E, it: w } = d;
    if (!Array.isArray(p))
      throw new Error("ajv implementation error");
    if (p.some((b) => (0, A.alwaysValidSchema)(w, b)) && !w.opts.unevaluated)
      return;
    const m = h.let("valid", !1), k = h.name("_valid");
    h.block(() => p.forEach((b, q) => {
      const P = d.subschema({
        keyword: E,
        schemaProp: q,
        compositeRule: !0
      }, k);
      h.assign(m, (0, t._)`${m} || ${k}`), d.mergeValidEvaluated(P, k) || h.if((0, t.not)(m));
    })), d.result(m, () => d.reset(), () => d.error(!0));
  }
  return cA.validateUnion = u, cA;
}
var js;
function qD() {
  if (js) return PA;
  js = 1, Object.defineProperty(PA, "__esModule", { value: !0 }), PA.validateKeywordUsage = PA.validSchemaType = PA.funcKeywordCode = PA.macroKeywordCode = void 0;
  const t = oA(), A = zA(), e = _A(), i = bo();
  function o(C, B) {
    const { gen: Q, keyword: f, schema: l, parentSchema: u, it: d } = C, h = B.macro.call(d.self, l, u, d), p = g(Q, f, h);
    d.opts.validateSchema !== !1 && d.self.validateSchema(h, !0);
    const E = Q.name("valid");
    C.subschema({
      schema: h,
      schemaPath: t.nil,
      errSchemaPath: `${d.errSchemaPath}/${f}`,
      topSchemaRef: p,
      compositeRule: !0
    }, E), C.pass(E, () => C.error(!0));
  }
  PA.macroKeywordCode = o;
  function r(C, B) {
    var Q;
    const { gen: f, keyword: l, schema: u, parentSchema: d, $data: h, it: p } = C;
    a(p, B);
    const E = !h && B.compile ? B.compile.call(p.self, u, d, p) : B.validate, w = g(f, l, E), y = f.let("valid");
    C.block$data(y, m), C.ok((Q = B.valid) !== null && Q !== void 0 ? Q : y);
    function m() {
      if (B.errors === !1)
        q(), B.modifying && n(C), P(() => C.error());
      else {
        const J = B.async ? k() : b();
        B.modifying && n(C), P(() => s(C, J));
      }
    }
    function k() {
      const J = f.let("ruleErrs", null);
      return f.try(() => q((0, t._)`await `), (W) => f.assign(y, !1).if((0, t._)`${W} instanceof ${p.ValidationError}`, () => f.assign(J, (0, t._)`${W}.errors`), () => f.throw(W))), J;
    }
    function b() {
      const J = (0, t._)`${w}.errors`;
      return f.assign(J, null), q(t.nil), J;
    }
    function q(J = B.async ? (0, t._)`await ` : t.nil) {
      const W = p.opts.passContext ? A.default.this : A.default.self, X = !("compile" in B && !h || B.schema === !1);
      f.assign(y, (0, t._)`${J}${(0, e.callValidateCode)(C, w, W, X)}`, B.modifying);
    }
    function P(J) {
      var W;
      f.if((0, t.not)((W = B.valid) !== null && W !== void 0 ? W : y), J);
    }
  }
  PA.funcKeywordCode = r;
  function n(C) {
    const { gen: B, data: Q, it: f } = C;
    B.if(f.parentData, () => B.assign(Q, (0, t._)`${f.parentData}[${f.parentDataProperty}]`));
  }
  function s(C, B) {
    const { gen: Q } = C;
    Q.if((0, t._)`Array.isArray(${B})`, () => {
      Q.assign(A.default.vErrors, (0, t._)`${A.default.vErrors} === null ? ${B} : ${A.default.vErrors}.concat(${B})`).assign(A.default.errors, (0, t._)`${A.default.vErrors}.length`), (0, i.extendErrors)(C);
    }, () => C.error());
  }
  function a({ schemaEnv: C }, B) {
    if (B.async && !C.$async)
      throw new Error("async keyword in sync schema");
  }
  function g(C, B, Q) {
    if (Q === void 0)
      throw new Error(`keyword "${B}" failed to compile`);
    return C.scopeValue("keyword", typeof Q == "function" ? { ref: Q } : { ref: Q, code: (0, t.stringify)(Q) });
  }
  function I(C, B, Q = !1) {
    return !B.length || B.some((f) => f === "array" ? Array.isArray(C) : f === "object" ? C && typeof C == "object" && !Array.isArray(C) : typeof C == f || Q && typeof C > "u");
  }
  PA.validSchemaType = I;
  function c({ schema: C, opts: B, self: Q, errSchemaPath: f }, l, u) {
    if (Array.isArray(l.keyword) ? !l.keyword.includes(u) : l.keyword !== u)
      throw new Error("ajv implementation error");
    const d = l.dependencies;
    if (d?.some((h) => !Object.prototype.hasOwnProperty.call(C, h)))
      throw new Error(`parent schema must have dependencies of ${u}: ${d.join(",")}`);
    if (l.validateSchema && !l.validateSchema(C[u])) {
      const p = `keyword "${u}" value is invalid at path "${f}": ` + Q.errorsText(l.validateSchema.errors);
      if (B.validateSchema === "log")
        Q.logger.error(p);
      else
        throw new Error(p);
    }
  }
  return PA.validateKeywordUsage = c, PA;
}
var re = {}, Vs;
function xD() {
  if (Vs) return re;
  Vs = 1, Object.defineProperty(re, "__esModule", { value: !0 }), re.extendSubschemaMode = re.extendSubschemaData = re.getSubschema = void 0;
  const t = oA(), A = aA();
  function e(r, { keyword: n, schemaProp: s, schema: a, schemaPath: g, errSchemaPath: I, topSchemaRef: c }) {
    if (n !== void 0 && a !== void 0)
      throw new Error('both "keyword" and "schema" passed, only one allowed');
    if (n !== void 0) {
      const C = r.schema[n];
      return s === void 0 ? {
        schema: C,
        schemaPath: (0, t._)`${r.schemaPath}${(0, t.getProperty)(n)}`,
        errSchemaPath: `${r.errSchemaPath}/${n}`
      } : {
        schema: C[s],
        schemaPath: (0, t._)`${r.schemaPath}${(0, t.getProperty)(n)}${(0, t.getProperty)(s)}`,
        errSchemaPath: `${r.errSchemaPath}/${n}/${(0, A.escapeFragment)(s)}`
      };
    }
    if (a !== void 0) {
      if (g === void 0 || I === void 0 || c === void 0)
        throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
      return {
        schema: a,
        schemaPath: g,
        topSchemaRef: c,
        errSchemaPath: I
      };
    }
    throw new Error('either "keyword" or "schema" must be passed');
  }
  re.getSubschema = e;
  function i(r, n, { dataProp: s, dataPropType: a, data: g, dataTypes: I, propertyName: c }) {
    if (g !== void 0 && s !== void 0)
      throw new Error('both "data" and "dataProp" passed, only one allowed');
    const { gen: C } = n;
    if (s !== void 0) {
      const { errorPath: Q, dataPathArr: f, opts: l } = n, u = C.let("data", (0, t._)`${n.data}${(0, t.getProperty)(s)}`, !0);
      B(u), r.errorPath = (0, t.str)`${Q}${(0, A.getErrorPath)(s, a, l.jsPropertySyntax)}`, r.parentDataProperty = (0, t._)`${s}`, r.dataPathArr = [...f, r.parentDataProperty];
    }
    if (g !== void 0) {
      const Q = g instanceof t.Name ? g : C.let("data", g, !0);
      B(Q), c !== void 0 && (r.propertyName = c);
    }
    I && (r.dataTypes = I);
    function B(Q) {
      r.data = Q, r.dataLevel = n.dataLevel + 1, r.dataTypes = [], n.definedProperties = /* @__PURE__ */ new Set(), r.parentData = n.data, r.dataNames = [...n.dataNames, Q];
    }
  }
  re.extendSubschemaData = i;
  function o(r, { jtdDiscriminator: n, jtdMetadata: s, compositeRule: a, createErrors: g, allErrors: I }) {
    a !== void 0 && (r.compositeRule = a), g !== void 0 && (r.createErrors = g), I !== void 0 && (r.allErrors = I), r.jtdDiscriminator = n, r.jtdMetadata = s;
  }
  return re.extendSubschemaMode = o, re;
}
var GA = {}, Ir, $s;
function PI() {
  return $s || ($s = 1, Ir = function t(A, e) {
    if (A === e) return !0;
    if (A && e && typeof A == "object" && typeof e == "object") {
      if (A.constructor !== e.constructor) return !1;
      var i, o, r;
      if (Array.isArray(A)) {
        if (i = A.length, i != e.length) return !1;
        for (o = i; o-- !== 0; )
          if (!t(A[o], e[o])) return !1;
        return !0;
      }
      if (A.constructor === RegExp) return A.source === e.source && A.flags === e.flags;
      if (A.valueOf !== Object.prototype.valueOf) return A.valueOf() === e.valueOf();
      if (A.toString !== Object.prototype.toString) return A.toString() === e.toString();
      if (r = Object.keys(A), i = r.length, i !== Object.keys(e).length) return !1;
      for (o = i; o-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(e, r[o])) return !1;
      for (o = i; o-- !== 0; ) {
        var n = r[o];
        if (!t(A[n], e[n])) return !1;
      }
      return !0;
    }
    return A !== A && e !== e;
  }), Ir;
}
var cr = { exports: {} }, Ws;
function LD() {
  if (Ws) return cr.exports;
  Ws = 1;
  var t = cr.exports = function(i, o, r) {
    typeof o == "function" && (r = o, o = {}), r = o.cb || r;
    var n = typeof r == "function" ? r : r.pre || function() {
    }, s = r.post || function() {
    };
    A(o, n, s, i, "", i);
  };
  t.keywords = {
    additionalItems: !0,
    items: !0,
    contains: !0,
    additionalProperties: !0,
    propertyNames: !0,
    not: !0,
    if: !0,
    then: !0,
    else: !0
  }, t.arrayKeywords = {
    items: !0,
    allOf: !0,
    anyOf: !0,
    oneOf: !0
  }, t.propsKeywords = {
    $defs: !0,
    definitions: !0,
    properties: !0,
    patternProperties: !0,
    dependencies: !0
  }, t.skipKeywords = {
    default: !0,
    enum: !0,
    const: !0,
    required: !0,
    maximum: !0,
    minimum: !0,
    exclusiveMaximum: !0,
    exclusiveMinimum: !0,
    multipleOf: !0,
    maxLength: !0,
    minLength: !0,
    pattern: !0,
    format: !0,
    maxItems: !0,
    minItems: !0,
    uniqueItems: !0,
    maxProperties: !0,
    minProperties: !0
  };
  function A(i, o, r, n, s, a, g, I, c, C) {
    if (n && typeof n == "object" && !Array.isArray(n)) {
      o(n, s, a, g, I, c, C);
      for (var B in n) {
        var Q = n[B];
        if (Array.isArray(Q)) {
          if (B in t.arrayKeywords)
            for (var f = 0; f < Q.length; f++)
              A(i, o, r, Q[f], s + "/" + B + "/" + f, a, s, B, n, f);
        } else if (B in t.propsKeywords) {
          if (Q && typeof Q == "object")
            for (var l in Q)
              A(i, o, r, Q[l], s + "/" + B + "/" + e(l), a, s, B, n, l);
        } else (B in t.keywords || i.allKeys && !(B in t.skipKeywords)) && A(i, o, r, Q, s + "/" + B, a, s, B, n);
      }
      r(n, s, a, g, I, c, C);
    }
  }
  function e(i) {
    return i.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  return cr.exports;
}
var zs;
function Ro() {
  if (zs) return GA;
  zs = 1, Object.defineProperty(GA, "__esModule", { value: !0 }), GA.getSchemaRefs = GA.resolveUrl = GA.normalizeId = GA._getFullPath = GA.getFullPath = GA.inlineRef = void 0;
  const t = aA(), A = PI(), e = LD(), i = /* @__PURE__ */ new Set([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum",
    "const"
  ]);
  function o(f, l = !0) {
    return typeof f == "boolean" ? !0 : l === !0 ? !n(f) : l ? s(f) <= l : !1;
  }
  GA.inlineRef = o;
  const r = /* @__PURE__ */ new Set([
    "$ref",
    "$recursiveRef",
    "$recursiveAnchor",
    "$dynamicRef",
    "$dynamicAnchor"
  ]);
  function n(f) {
    for (const l in f) {
      if (r.has(l))
        return !0;
      const u = f[l];
      if (Array.isArray(u) && u.some(n) || typeof u == "object" && n(u))
        return !0;
    }
    return !1;
  }
  function s(f) {
    let l = 0;
    for (const u in f) {
      if (u === "$ref")
        return 1 / 0;
      if (l++, !i.has(u) && (typeof f[u] == "object" && (0, t.eachItem)(f[u], (d) => l += s(d)), l === 1 / 0))
        return 1 / 0;
    }
    return l;
  }
  function a(f, l = "", u) {
    u !== !1 && (l = c(l));
    const d = f.parse(l);
    return g(f, d);
  }
  GA.getFullPath = a;
  function g(f, l) {
    return f.serialize(l).split("#")[0] + "#";
  }
  GA._getFullPath = g;
  const I = /#\/?$/;
  function c(f) {
    return f ? f.replace(I, "") : "";
  }
  GA.normalizeId = c;
  function C(f, l, u) {
    return u = c(u), f.resolve(l, u);
  }
  GA.resolveUrl = C;
  const B = /^[a-z_][-a-z0-9._]*$/i;
  function Q(f, l) {
    if (typeof f == "boolean")
      return {};
    const { schemaId: u, uriResolver: d } = this.opts, h = c(f[u] || l), p = { "": h }, E = a(d, h, !1), w = {}, y = /* @__PURE__ */ new Set();
    return e(f, { allKeys: !0 }, (b, q, P, J) => {
      if (J === void 0)
        return;
      const W = E + q;
      let X = p[J];
      typeof b[u] == "string" && (X = z.call(this, b[u])), _.call(this, b.$anchor), _.call(this, b.$dynamicAnchor), p[q] = X;
      function z(O) {
        const Z = this.opts.uriResolver.resolve;
        if (O = c(X ? Z(X, O) : O), y.has(O))
          throw k(O);
        y.add(O);
        let T = this.refs[O];
        return typeof T == "string" && (T = this.refs[T]), typeof T == "object" ? m(b, T.schema, O) : O !== c(W) && (O[0] === "#" ? (m(b, w[O], O), w[O] = b) : this.refs[O] = W), O;
      }
      function _(O) {
        if (typeof O == "string") {
          if (!B.test(O))
            throw new Error(`invalid anchor "${O}"`);
          z.call(this, `#${O}`);
        }
      }
    }), w;
    function m(b, q, P) {
      if (q !== void 0 && !A(b, q))
        throw k(P);
    }
    function k(b) {
      return new Error(`reference "${b}" resolves to more than one schema`);
    }
  }
  return GA.getSchemaRefs = Q, GA;
}
var _s;
function zt() {
  if (_s) return ie;
  _s = 1, Object.defineProperty(ie, "__esModule", { value: !0 }), ie.getData = ie.KeywordCxt = ie.validateFunctionCode = void 0;
  const t = JD(), A = Bo(), e = OI(), i = Bo(), o = HD(), r = qD(), n = xD(), s = oA(), a = zA(), g = Ro(), I = aA(), c = bo();
  function C(S) {
    if (E(S) && (y(S), p(S))) {
      l(S);
      return;
    }
    B(S, () => (0, t.topBoolOrEmptySchema)(S));
  }
  ie.validateFunctionCode = C;
  function B({ gen: S, validateName: M, schema: K, schemaEnv: H, opts: V }, $) {
    V.code.es5 ? S.func(M, (0, s._)`${a.default.data}, ${a.default.valCxt}`, H.$async, () => {
      S.code((0, s._)`"use strict"; ${d(K, V)}`), f(S, V), S.code($);
    }) : S.func(M, (0, s._)`${a.default.data}, ${Q(V)}`, H.$async, () => S.code(d(K, V)).code($));
  }
  function Q(S) {
    return (0, s._)`{${a.default.instancePath}="", ${a.default.parentData}, ${a.default.parentDataProperty}, ${a.default.rootData}=${a.default.data}${S.dynamicRef ? (0, s._)`, ${a.default.dynamicAnchors}={}` : s.nil}}={}`;
  }
  function f(S, M) {
    S.if(a.default.valCxt, () => {
      S.var(a.default.instancePath, (0, s._)`${a.default.valCxt}.${a.default.instancePath}`), S.var(a.default.parentData, (0, s._)`${a.default.valCxt}.${a.default.parentData}`), S.var(a.default.parentDataProperty, (0, s._)`${a.default.valCxt}.${a.default.parentDataProperty}`), S.var(a.default.rootData, (0, s._)`${a.default.valCxt}.${a.default.rootData}`), M.dynamicRef && S.var(a.default.dynamicAnchors, (0, s._)`${a.default.valCxt}.${a.default.dynamicAnchors}`);
    }, () => {
      S.var(a.default.instancePath, (0, s._)`""`), S.var(a.default.parentData, (0, s._)`undefined`), S.var(a.default.parentDataProperty, (0, s._)`undefined`), S.var(a.default.rootData, a.default.data), M.dynamicRef && S.var(a.default.dynamicAnchors, (0, s._)`{}`);
    });
  }
  function l(S) {
    const { schema: M, opts: K, gen: H } = S;
    B(S, () => {
      K.$comment && M.$comment && J(S), b(S), H.let(a.default.vErrors, null), H.let(a.default.errors, 0), K.unevaluated && u(S), m(S), W(S);
    });
  }
  function u(S) {
    const { gen: M, validateName: K } = S;
    S.evaluated = M.const("evaluated", (0, s._)`${K}.evaluated`), M.if((0, s._)`${S.evaluated}.dynamicProps`, () => M.assign((0, s._)`${S.evaluated}.props`, (0, s._)`undefined`)), M.if((0, s._)`${S.evaluated}.dynamicItems`, () => M.assign((0, s._)`${S.evaluated}.items`, (0, s._)`undefined`));
  }
  function d(S, M) {
    const K = typeof S == "object" && S[M.schemaId];
    return K && (M.code.source || M.code.process) ? (0, s._)`/*# sourceURL=${K} */` : s.nil;
  }
  function h(S, M) {
    if (E(S) && (y(S), p(S))) {
      w(S, M);
      return;
    }
    (0, t.boolOrEmptySchema)(S, M);
  }
  function p({ schema: S, self: M }) {
    if (typeof S == "boolean")
      return !S;
    for (const K in S)
      if (M.RULES.all[K])
        return !0;
    return !1;
  }
  function E(S) {
    return typeof S.schema != "boolean";
  }
  function w(S, M) {
    const { schema: K, gen: H, opts: V } = S;
    V.$comment && K.$comment && J(S), q(S), P(S);
    const $ = H.const("_errs", a.default.errors);
    m(S, $), H.var(M, (0, s._)`${$} === ${a.default.errors}`);
  }
  function y(S) {
    (0, I.checkUnknownRules)(S), k(S);
  }
  function m(S, M) {
    if (S.opts.jtd)
      return z(S, [], !1, M);
    const K = (0, A.getSchemaTypes)(S.schema), H = (0, A.coerceAndCheckDataType)(S, K);
    z(S, K, !H, M);
  }
  function k(S) {
    const { schema: M, errSchemaPath: K, opts: H, self: V } = S;
    M.$ref && H.ignoreKeywordsWithRef && (0, I.schemaHasRulesButRef)(M, V.RULES) && V.logger.warn(`$ref: keywords ignored in schema at path "${K}"`);
  }
  function b(S) {
    const { schema: M, opts: K } = S;
    M.default !== void 0 && K.useDefaults && K.strictSchema && (0, I.checkStrictMode)(S, "default is ignored in the schema root");
  }
  function q(S) {
    const M = S.schema[S.opts.schemaId];
    M && (S.baseId = (0, g.resolveUrl)(S.opts.uriResolver, S.baseId, M));
  }
  function P(S) {
    if (S.schema.$async && !S.schemaEnv.$async)
      throw new Error("async schema in sync schema");
  }
  function J({ gen: S, schemaEnv: M, schema: K, errSchemaPath: H, opts: V }) {
    const $ = K.$comment;
    if (V.$comment === !0)
      S.code((0, s._)`${a.default.self}.logger.log(${$})`);
    else if (typeof V.$comment == "function") {
      const iA = (0, s.str)`${H}/$comment`, gA = S.scopeValue("root", { ref: M.root });
      S.code((0, s._)`${a.default.self}.opts.$comment(${$}, ${iA}, ${gA}.schema)`);
    }
  }
  function W(S) {
    const { gen: M, schemaEnv: K, validateName: H, ValidationError: V, opts: $ } = S;
    K.$async ? M.if((0, s._)`${a.default.errors} === 0`, () => M.return(a.default.data), () => M.throw((0, s._)`new ${V}(${a.default.vErrors})`)) : (M.assign((0, s._)`${H}.errors`, a.default.vErrors), $.unevaluated && X(S), M.return((0, s._)`${a.default.errors} === 0`));
  }
  function X({ gen: S, evaluated: M, props: K, items: H }) {
    K instanceof s.Name && S.assign((0, s._)`${M}.props`, K), H instanceof s.Name && S.assign((0, s._)`${M}.items`, H);
  }
  function z(S, M, K, H) {
    const { gen: V, schema: $, data: iA, allErrors: gA, opts: IA, self: QA } = S, { RULES: fA } = QA;
    if ($.$ref && (IA.ignoreKeywordsWithRef || !(0, I.schemaHasRulesButRef)($, fA))) {
      V.block(() => j(S, "$ref", fA.all.$ref.definition));
      return;
    }
    IA.jtd || O(S, M), V.block(() => {
      for (const HA of fA.rules)
        Ce(HA);
      Ce(fA.post);
    });
    function Ce(HA) {
      (0, e.shouldUseGroup)($, HA) && (HA.type ? (V.if((0, i.checkDataType)(HA.type, iA, IA.strictNumbers)), _(S, HA), M.length === 1 && M[0] === HA.type && K && (V.else(), (0, i.reportTypeError)(S)), V.endIf()) : _(S, HA), gA || V.if((0, s._)`${a.default.errors} === ${H || 0}`));
    }
  }
  function _(S, M) {
    const { gen: K, schema: H, opts: { useDefaults: V } } = S;
    V && (0, o.assignDefaults)(S, M.type), K.block(() => {
      for (const $ of M.rules)
        (0, e.shouldUseRule)(H, $) && j(S, $.keyword, $.definition, M.type);
    });
  }
  function O(S, M) {
    S.schemaEnv.meta || !S.opts.strictTypes || (Z(S, M), S.opts.allowUnionTypes || T(S, M), F(S, S.dataTypes));
  }
  function Z(S, M) {
    if (M.length) {
      if (!S.dataTypes.length) {
        S.dataTypes = M;
        return;
      }
      M.forEach((K) => {
        R(S.dataTypes, K) || N(S, `type "${K}" not allowed by context "${S.dataTypes.join(",")}"`);
      }), D(S, M);
    }
  }
  function T(S, M) {
    M.length > 1 && !(M.length === 2 && M.includes("null")) && N(S, "use allowUnionTypes to allow union type keyword");
  }
  function F(S, M) {
    const K = S.self.RULES.all;
    for (const H in K) {
      const V = K[H];
      if (typeof V == "object" && (0, e.shouldUseRule)(S.schema, V)) {
        const { type: $ } = V.definition;
        $.length && !$.some((iA) => x(M, iA)) && N(S, `missing type "${$.join(",")}" for keyword "${H}"`);
      }
    }
  }
  function x(S, M) {
    return S.includes(M) || M === "number" && S.includes("integer");
  }
  function R(S, M) {
    return S.includes(M) || M === "integer" && S.includes("number");
  }
  function D(S, M) {
    const K = [];
    for (const H of S.dataTypes)
      R(M, H) ? K.push(H) : M.includes("integer") && H === "number" && K.push("integer");
    S.dataTypes = K;
  }
  function N(S, M) {
    const K = S.schemaEnv.baseId + S.errSchemaPath;
    M += ` at "${K}" (strictTypes)`, (0, I.checkStrictMode)(S, M, S.opts.strictTypes);
  }
  class Y {
    constructor(M, K, H) {
      if ((0, r.validateKeywordUsage)(M, K, H), this.gen = M.gen, this.allErrors = M.allErrors, this.keyword = H, this.data = M.data, this.schema = M.schema[H], this.$data = K.$data && M.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, I.schemaRefOrVal)(M, this.schema, H, this.$data), this.schemaType = K.schemaType, this.parentSchema = M.schema, this.params = {}, this.it = M, this.def = K, this.$data)
        this.schemaCode = M.gen.const("vSchema", v(this.$data, M));
      else if (this.schemaCode = this.schemaValue, !(0, r.validSchemaType)(this.schema, K.schemaType, K.allowUndefined))
        throw new Error(`${H} value must be ${JSON.stringify(K.schemaType)}`);
      ("code" in K ? K.trackErrors : K.errors !== !1) && (this.errsCount = M.gen.const("_errs", a.default.errors));
    }
    result(M, K, H) {
      this.failResult((0, s.not)(M), K, H);
    }
    failResult(M, K, H) {
      this.gen.if(M), H ? H() : this.error(), K ? (this.gen.else(), K(), this.allErrors && this.gen.endIf()) : this.allErrors ? this.gen.endIf() : this.gen.else();
    }
    pass(M, K) {
      this.failResult((0, s.not)(M), void 0, K);
    }
    fail(M) {
      if (M === void 0) {
        this.error(), this.allErrors || this.gen.if(!1);
        return;
      }
      this.gen.if(M), this.error(), this.allErrors ? this.gen.endIf() : this.gen.else();
    }
    fail$data(M) {
      if (!this.$data)
        return this.fail(M);
      const { schemaCode: K } = this;
      this.fail((0, s._)`${K} !== undefined && (${(0, s.or)(this.invalid$data(), M)})`);
    }
    error(M, K, H) {
      if (K) {
        this.setParams(K), this._error(M, H), this.setParams({});
        return;
      }
      this._error(M, H);
    }
    _error(M, K) {
      (M ? c.reportExtraError : c.reportError)(this, this.def.error, K);
    }
    $dataError() {
      (0, c.reportError)(this, this.def.$dataError || c.keyword$DataError);
    }
    reset() {
      if (this.errsCount === void 0)
        throw new Error('add "trackErrors" to keyword definition');
      (0, c.resetErrorsCount)(this.gen, this.errsCount);
    }
    ok(M) {
      this.allErrors || this.gen.if(M);
    }
    setParams(M, K) {
      K ? Object.assign(this.params, M) : this.params = M;
    }
    block$data(M, K, H = s.nil) {
      this.gen.block(() => {
        this.check$data(M, H), K();
      });
    }
    check$data(M = s.nil, K = s.nil) {
      if (!this.$data)
        return;
      const { gen: H, schemaCode: V, schemaType: $, def: iA } = this;
      H.if((0, s.or)((0, s._)`${V} === undefined`, K)), M !== s.nil && H.assign(M, !0), ($.length || iA.validateSchema) && (H.elseIf(this.invalid$data()), this.$dataError(), M !== s.nil && H.assign(M, !1)), H.else();
    }
    invalid$data() {
      const { gen: M, schemaCode: K, schemaType: H, def: V, it: $ } = this;
      return (0, s.or)(iA(), gA());
      function iA() {
        if (H.length) {
          if (!(K instanceof s.Name))
            throw new Error("ajv implementation error");
          const IA = Array.isArray(H) ? H : [H];
          return (0, s._)`${(0, i.checkDataTypes)(IA, K, $.opts.strictNumbers, i.DataType.Wrong)}`;
        }
        return s.nil;
      }
      function gA() {
        if (V.validateSchema) {
          const IA = M.scopeValue("validate$data", { ref: V.validateSchema });
          return (0, s._)`!${IA}(${K})`;
        }
        return s.nil;
      }
    }
    subschema(M, K) {
      const H = (0, n.getSubschema)(this.it, M);
      (0, n.extendSubschemaData)(H, this.it, M), (0, n.extendSubschemaMode)(H, M);
      const V = { ...this.it, ...H, items: void 0, props: void 0 };
      return h(V, K), V;
    }
    mergeEvaluated(M, K) {
      const { it: H, gen: V } = this;
      H.opts.unevaluated && (H.props !== !0 && M.props !== void 0 && (H.props = I.mergeEvaluated.props(V, M.props, H.props, K)), H.items !== !0 && M.items !== void 0 && (H.items = I.mergeEvaluated.items(V, M.items, H.items, K)));
    }
    mergeValidEvaluated(M, K) {
      const { it: H, gen: V } = this;
      if (H.opts.unevaluated && (H.props !== !0 || H.items !== !0))
        return V.if(K, () => this.mergeEvaluated(M, s.Name)), !0;
    }
  }
  ie.KeywordCxt = Y;
  function j(S, M, K, H) {
    const V = new Y(S, K, M);
    "code" in K ? K.code(V, H) : V.$data && K.validate ? (0, r.funcKeywordCode)(V, K) : "macro" in K ? (0, r.macroKeywordCode)(V, K) : (K.compile || K.validate) && (0, r.funcKeywordCode)(V, K);
  }
  const G = /^\/(?:[^~]|~0|~1)*$/, L = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
  function v(S, { dataLevel: M, dataNames: K, dataPathArr: H }) {
    let V, $;
    if (S === "")
      return a.default.rootData;
    if (S[0] === "/") {
      if (!G.test(S))
        throw new Error(`Invalid JSON-pointer: ${S}`);
      V = S, $ = a.default.rootData;
    } else {
      const QA = L.exec(S);
      if (!QA)
        throw new Error(`Invalid JSON-pointer: ${S}`);
      const fA = +QA[1];
      if (V = QA[2], V === "#") {
        if (fA >= M)
          throw new Error(IA("property/index", fA));
        return H[M - fA];
      }
      if (fA > M)
        throw new Error(IA("data", fA));
      if ($ = K[M - fA], !V)
        return $;
    }
    let iA = $;
    const gA = V.split("/");
    for (const QA of gA)
      QA && ($ = (0, s._)`${$}${(0, s.getProperty)((0, I.unescapeJsonPointer)(QA))}`, iA = (0, s._)`${iA} && ${$}`);
    return iA;
    function IA(QA, fA) {
      return `Cannot access ${QA} ${fA} levels up, current level is ${M}`;
    }
  }
  return ie.getData = v, ie;
}
var si = {}, Zs;
function Ko() {
  if (Zs) return si;
  Zs = 1, Object.defineProperty(si, "__esModule", { value: !0 });
  class t extends Error {
    constructor(e) {
      super("validation failed"), this.errors = e, this.ajv = this.validation = !0;
    }
  }
  return si.default = t, si;
}
var ai = {}, Xs;
function _t() {
  if (Xs) return ai;
  Xs = 1, Object.defineProperty(ai, "__esModule", { value: !0 });
  const t = Ro();
  class A extends Error {
    constructor(i, o, r, n) {
      super(n || `can't resolve reference ${r} from id ${o}`), this.missingRef = (0, t.resolveUrl)(i, o, r), this.missingSchema = (0, t.normalizeId)((0, t.getFullPath)(i, this.missingRef));
    }
  }
  return ai.default = A, ai;
}
var vA = {}, Aa;
function vo() {
  if (Aa) return vA;
  Aa = 1, Object.defineProperty(vA, "__esModule", { value: !0 }), vA.resolveSchema = vA.getCompilingSchema = vA.resolveRef = vA.compileSchema = vA.SchemaEnv = void 0;
  const t = oA(), A = Ko(), e = zA(), i = Ro(), o = aA(), r = zt();
  class n {
    constructor(u) {
      var d;
      this.refs = {}, this.dynamicAnchors = {};
      let h;
      typeof u.schema == "object" && (h = u.schema), this.schema = u.schema, this.schemaId = u.schemaId, this.root = u.root || this, this.baseId = (d = u.baseId) !== null && d !== void 0 ? d : (0, i.normalizeId)(h?.[u.schemaId || "$id"]), this.schemaPath = u.schemaPath, this.localRefs = u.localRefs, this.meta = u.meta, this.$async = h?.$async, this.refs = {};
    }
  }
  vA.SchemaEnv = n;
  function s(l) {
    const u = I.call(this, l);
    if (u)
      return u;
    const d = (0, i.getFullPath)(this.opts.uriResolver, l.root.baseId), { es5: h, lines: p } = this.opts.code, { ownProperties: E } = this.opts, w = new t.CodeGen(this.scope, { es5: h, lines: p, ownProperties: E });
    let y;
    l.$async && (y = w.scopeValue("Error", {
      ref: A.default,
      code: (0, t._)`require("ajv/dist/runtime/validation_error").default`
    }));
    const m = w.scopeName("validate");
    l.validateName = m;
    const k = {
      gen: w,
      allErrors: this.opts.allErrors,
      data: e.default.data,
      parentData: e.default.parentData,
      parentDataProperty: e.default.parentDataProperty,
      dataNames: [e.default.data],
      dataPathArr: [t.nil],
      // TODO can its length be used as dataLevel if nil is removed?
      dataLevel: 0,
      dataTypes: [],
      definedProperties: /* @__PURE__ */ new Set(),
      topSchemaRef: w.scopeValue("schema", this.opts.code.source === !0 ? { ref: l.schema, code: (0, t.stringify)(l.schema) } : { ref: l.schema }),
      validateName: m,
      ValidationError: y,
      schema: l.schema,
      schemaEnv: l,
      rootId: d,
      baseId: l.baseId || d,
      schemaPath: t.nil,
      errSchemaPath: l.schemaPath || (this.opts.jtd ? "" : "#"),
      errorPath: (0, t._)`""`,
      opts: this.opts,
      self: this
    };
    let b;
    try {
      this._compilations.add(l), (0, r.validateFunctionCode)(k), w.optimize(this.opts.code.optimize);
      const q = w.toString();
      b = `${w.scopeRefs(e.default.scope)}return ${q}`, this.opts.code.process && (b = this.opts.code.process(b, l));
      const J = new Function(`${e.default.self}`, `${e.default.scope}`, b)(this, this.scope.get());
      if (this.scope.value(m, { ref: J }), J.errors = null, J.schema = l.schema, J.schemaEnv = l, l.$async && (J.$async = !0), this.opts.code.source === !0 && (J.source = { validateName: m, validateCode: q, scopeValues: w._values }), this.opts.unevaluated) {
        const { props: W, items: X } = k;
        J.evaluated = {
          props: W instanceof t.Name ? void 0 : W,
          items: X instanceof t.Name ? void 0 : X,
          dynamicProps: W instanceof t.Name,
          dynamicItems: X instanceof t.Name
        }, J.source && (J.source.evaluated = (0, t.stringify)(J.evaluated));
      }
      return l.validate = J, l;
    } catch (q) {
      throw delete l.validate, delete l.validateName, b && this.logger.error("Error compiling schema, function code:", b), q;
    } finally {
      this._compilations.delete(l);
    }
  }
  vA.compileSchema = s;
  function a(l, u, d) {
    var h;
    d = (0, i.resolveUrl)(this.opts.uriResolver, u, d);
    const p = l.refs[d];
    if (p)
      return p;
    let E = C.call(this, l, d);
    if (E === void 0) {
      const w = (h = l.localRefs) === null || h === void 0 ? void 0 : h[d], { schemaId: y } = this.opts;
      w && (E = new n({ schema: w, schemaId: y, root: l, baseId: u }));
    }
    if (E !== void 0)
      return l.refs[d] = g.call(this, E);
  }
  vA.resolveRef = a;
  function g(l) {
    return (0, i.inlineRef)(l.schema, this.opts.inlineRefs) ? l.schema : l.validate ? l : s.call(this, l);
  }
  function I(l) {
    for (const u of this._compilations)
      if (c(u, l))
        return u;
  }
  vA.getCompilingSchema = I;
  function c(l, u) {
    return l.schema === u.schema && l.root === u.root && l.baseId === u.baseId;
  }
  function C(l, u) {
    let d;
    for (; typeof (d = this.refs[u]) == "string"; )
      u = d;
    return d || this.schemas[u] || B.call(this, l, u);
  }
  function B(l, u) {
    const d = this.opts.uriResolver.parse(u), h = (0, i._getFullPath)(this.opts.uriResolver, d);
    let p = (0, i.getFullPath)(this.opts.uriResolver, l.baseId, void 0);
    if (Object.keys(l.schema).length > 0 && h === p)
      return f.call(this, d, l);
    const E = (0, i.normalizeId)(h), w = this.refs[E] || this.schemas[E];
    if (typeof w == "string") {
      const y = B.call(this, l, w);
      return typeof y?.schema != "object" ? void 0 : f.call(this, d, y);
    }
    if (typeof w?.schema == "object") {
      if (w.validate || s.call(this, w), E === (0, i.normalizeId)(u)) {
        const { schema: y } = w, { schemaId: m } = this.opts, k = y[m];
        return k && (p = (0, i.resolveUrl)(this.opts.uriResolver, p, k)), new n({ schema: y, schemaId: m, root: l, baseId: p });
      }
      return f.call(this, d, w);
    }
  }
  vA.resolveSchema = B;
  const Q = /* @__PURE__ */ new Set([
    "properties",
    "patternProperties",
    "enum",
    "dependencies",
    "definitions"
  ]);
  function f(l, { baseId: u, schema: d, root: h }) {
    var p;
    if (((p = l.fragment) === null || p === void 0 ? void 0 : p[0]) !== "/")
      return;
    for (const y of l.fragment.slice(1).split("/")) {
      if (typeof d == "boolean")
        return;
      const m = d[(0, o.unescapeFragment)(y)];
      if (m === void 0)
        return;
      d = m;
      const k = typeof d == "object" && d[this.opts.schemaId];
      !Q.has(y) && k && (u = (0, i.resolveUrl)(this.opts.uriResolver, u, k));
    }
    let E;
    if (typeof d != "boolean" && d.$ref && !(0, o.schemaHasRulesButRef)(d, this.RULES)) {
      const y = (0, i.resolveUrl)(this.opts.uriResolver, u, d.$ref);
      E = B.call(this, h, y);
    }
    const { schemaId: w } = this.opts;
    if (E = E || new n({ schema: d, schemaId: w, root: h, baseId: u }), E.schema !== E.root.schema)
      return E;
  }
  return vA;
}
const TD = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#", OD = "Meta-schema for $data reference (JSON AnySchema extension proposal)", PD = "object", jD = ["$data"], VD = { $data: { type: "string", anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }] } }, $D = !1, WD = {
  $id: TD,
  description: OD,
  type: PD,
  required: jD,
  properties: VD,
  additionalProperties: $D
};
var gi = {}, ht = { exports: {} }, Cr, ea;
function jI() {
  if (ea) return Cr;
  ea = 1;
  const t = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu), A = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
  function e(C) {
    let B = "", Q = 0, f = 0;
    for (f = 0; f < C.length; f++)
      if (Q = C[f].charCodeAt(0), Q !== 48) {
        if (!(Q >= 48 && Q <= 57 || Q >= 65 && Q <= 70 || Q >= 97 && Q <= 102))
          return "";
        B += C[f];
        break;
      }
    for (f += 1; f < C.length; f++) {
      if (Q = C[f].charCodeAt(0), !(Q >= 48 && Q <= 57 || Q >= 65 && Q <= 70 || Q >= 97 && Q <= 102))
        return "";
      B += C[f];
    }
    return B;
  }
  const i = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
  function o(C) {
    return C.length = 0, !0;
  }
  function r(C, B, Q) {
    if (C.length) {
      const f = e(C);
      if (f !== "")
        B.push(f);
      else
        return Q.error = !0, !1;
      C.length = 0;
    }
    return !0;
  }
  function n(C) {
    let B = 0;
    const Q = { error: !1, address: "", zone: "" }, f = [], l = [];
    let u = !1, d = !1, h = r;
    for (let p = 0; p < C.length; p++) {
      const E = C[p];
      if (!(E === "[" || E === "]"))
        if (E === ":") {
          if (u === !0 && (d = !0), !h(l, f, Q))
            break;
          if (++B > 7) {
            Q.error = !0;
            break;
          }
          p > 0 && C[p - 1] === ":" && (u = !0), f.push(":");
          continue;
        } else if (E === "%") {
          if (!h(l, f, Q))
            break;
          h = o;
        } else {
          l.push(E);
          continue;
        }
    }
    return l.length && (h === o ? Q.zone = l.join("") : d ? f.push(l.join("")) : f.push(e(l))), Q.address = f.join(""), Q;
  }
  function s(C) {
    if (a(C, ":") < 2)
      return { host: C, isIPV6: !1 };
    const B = n(C);
    if (B.error)
      return { host: C, isIPV6: !1 };
    {
      let Q = B.address, f = B.address;
      return B.zone && (Q += "%" + B.zone, f += "%25" + B.zone), { host: Q, isIPV6: !0, escapedHost: f };
    }
  }
  function a(C, B) {
    let Q = 0;
    for (let f = 0; f < C.length; f++)
      C[f] === B && Q++;
    return Q;
  }
  function g(C) {
    let B = C;
    const Q = [];
    let f = -1, l = 0;
    for (; l = B.length; ) {
      if (l === 1) {
        if (B === ".")
          break;
        if (B === "/") {
          Q.push("/");
          break;
        } else {
          Q.push(B);
          break;
        }
      } else if (l === 2) {
        if (B[0] === ".") {
          if (B[1] === ".")
            break;
          if (B[1] === "/") {
            B = B.slice(2);
            continue;
          }
        } else if (B[0] === "/" && (B[1] === "." || B[1] === "/")) {
          Q.push("/");
          break;
        }
      } else if (l === 3 && B === "/..") {
        Q.length !== 0 && Q.pop(), Q.push("/");
        break;
      }
      if (B[0] === ".") {
        if (B[1] === ".") {
          if (B[2] === "/") {
            B = B.slice(3);
            continue;
          }
        } else if (B[1] === "/") {
          B = B.slice(2);
          continue;
        }
      } else if (B[0] === "/" && B[1] === ".") {
        if (B[2] === "/") {
          B = B.slice(2);
          continue;
        } else if (B[2] === "." && B[3] === "/") {
          B = B.slice(3), Q.length !== 0 && Q.pop();
          continue;
        }
      }
      if ((f = B.indexOf("/", 1)) === -1) {
        Q.push(B);
        break;
      } else
        Q.push(B.slice(0, f)), B = B.slice(f);
    }
    return Q.join("");
  }
  function I(C, B) {
    const Q = B !== !0 ? escape : unescape;
    return C.scheme !== void 0 && (C.scheme = Q(C.scheme)), C.userinfo !== void 0 && (C.userinfo = Q(C.userinfo)), C.host !== void 0 && (C.host = Q(C.host)), C.path !== void 0 && (C.path = Q(C.path)), C.query !== void 0 && (C.query = Q(C.query)), C.fragment !== void 0 && (C.fragment = Q(C.fragment)), C;
  }
  function c(C) {
    const B = [];
    if (C.userinfo !== void 0 && (B.push(C.userinfo), B.push("@")), C.host !== void 0) {
      let Q = unescape(C.host);
      if (!A(Q)) {
        const f = s(Q);
        f.isIPV6 === !0 ? Q = `[${f.escapedHost}]` : Q = C.host;
      }
      B.push(Q);
    }
    return (typeof C.port == "number" || typeof C.port == "string") && (B.push(":"), B.push(String(C.port))), B.length ? B.join("") : void 0;
  }
  return Cr = {
    nonSimpleDomain: i,
    recomposeAuthority: c,
    normalizeComponentEncoding: I,
    removeDotSegments: g,
    isIPv4: A,
    isUUID: t,
    normalizeIPv6: s,
    stringArrayToHexStripped: e
  }, Cr;
}
var Br, ta;
function zD() {
  if (ta) return Br;
  ta = 1;
  const { isUUID: t } = jI(), A = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu, e = (
    /** @type {const} */
    [
      "http",
      "https",
      "ws",
      "wss",
      "urn",
      "urn:uuid"
    ]
  );
  function i(E) {
    return e.indexOf(
      /** @type {*} */
      E
    ) !== -1;
  }
  function o(E) {
    return E.secure === !0 ? !0 : E.secure === !1 ? !1 : E.scheme ? E.scheme.length === 3 && (E.scheme[0] === "w" || E.scheme[0] === "W") && (E.scheme[1] === "s" || E.scheme[1] === "S") && (E.scheme[2] === "s" || E.scheme[2] === "S") : !1;
  }
  function r(E) {
    return E.host || (E.error = E.error || "HTTP URIs must have a host."), E;
  }
  function n(E) {
    const w = String(E.scheme).toLowerCase() === "https";
    return (E.port === (w ? 443 : 80) || E.port === "") && (E.port = void 0), E.path || (E.path = "/"), E;
  }
  function s(E) {
    return E.secure = o(E), E.resourceName = (E.path || "/") + (E.query ? "?" + E.query : ""), E.path = void 0, E.query = void 0, E;
  }
  function a(E) {
    if ((E.port === (o(E) ? 443 : 80) || E.port === "") && (E.port = void 0), typeof E.secure == "boolean" && (E.scheme = E.secure ? "wss" : "ws", E.secure = void 0), E.resourceName) {
      const [w, y] = E.resourceName.split("?");
      E.path = w && w !== "/" ? w : void 0, E.query = y, E.resourceName = void 0;
    }
    return E.fragment = void 0, E;
  }
  function g(E, w) {
    if (!E.path)
      return E.error = "URN can not be parsed", E;
    const y = E.path.match(A);
    if (y) {
      const m = w.scheme || E.scheme || "urn";
      E.nid = y[1].toLowerCase(), E.nss = y[2];
      const k = `${m}:${w.nid || E.nid}`, b = p(k);
      E.path = void 0, b && (E = b.parse(E, w));
    } else
      E.error = E.error || "URN can not be parsed.";
    return E;
  }
  function I(E, w) {
    if (E.nid === void 0)
      throw new Error("URN without nid cannot be serialized");
    const y = w.scheme || E.scheme || "urn", m = E.nid.toLowerCase(), k = `${y}:${w.nid || m}`, b = p(k);
    b && (E = b.serialize(E, w));
    const q = E, P = E.nss;
    return q.path = `${m || w.nid}:${P}`, w.skipEscape = !0, q;
  }
  function c(E, w) {
    const y = E;
    return y.uuid = y.nss, y.nss = void 0, !w.tolerant && (!y.uuid || !t(y.uuid)) && (y.error = y.error || "UUID is not valid."), y;
  }
  function C(E) {
    const w = E;
    return w.nss = (E.uuid || "").toLowerCase(), w;
  }
  const B = (
    /** @type {SchemeHandler} */
    {
      scheme: "http",
      domainHost: !0,
      parse: r,
      serialize: n
    }
  ), Q = (
    /** @type {SchemeHandler} */
    {
      scheme: "https",
      domainHost: B.domainHost,
      parse: r,
      serialize: n
    }
  ), f = (
    /** @type {SchemeHandler} */
    {
      scheme: "ws",
      domainHost: !0,
      parse: s,
      serialize: a
    }
  ), l = (
    /** @type {SchemeHandler} */
    {
      scheme: "wss",
      domainHost: f.domainHost,
      parse: f.parse,
      serialize: f.serialize
    }
  ), h = (
    /** @type {Record<SchemeName, SchemeHandler>} */
    {
      http: B,
      https: Q,
      ws: f,
      wss: l,
      urn: (
        /** @type {SchemeHandler} */
        {
          scheme: "urn",
          parse: g,
          serialize: I,
          skipNormalize: !0
        }
      ),
      "urn:uuid": (
        /** @type {SchemeHandler} */
        {
          scheme: "urn:uuid",
          parse: c,
          serialize: C,
          skipNormalize: !0
        }
      )
    }
  );
  Object.setPrototypeOf(h, null);
  function p(E) {
    return E && (h[
      /** @type {SchemeName} */
      E
    ] || h[
      /** @type {SchemeName} */
      E.toLowerCase()
    ]) || void 0;
  }
  return Br = {
    wsIsSecure: o,
    SCHEMES: h,
    isValidSchemeName: i,
    getSchemeHandler: p
  }, Br;
}
var ia;
function _D() {
  if (ia) return ht.exports;
  ia = 1;
  const { normalizeIPv6: t, removeDotSegments: A, recomposeAuthority: e, normalizeComponentEncoding: i, isIPv4: o, nonSimpleDomain: r } = jI(), { SCHEMES: n, getSchemeHandler: s } = zD();
  function a(l, u) {
    return typeof l == "string" ? l = /** @type {T} */
    C(Q(l, u), u) : typeof l == "object" && (l = /** @type {T} */
    Q(C(l, u), u)), l;
  }
  function g(l, u, d) {
    const h = d ? Object.assign({ scheme: "null" }, d) : { scheme: "null" }, p = I(Q(l, h), Q(u, h), h, !0);
    return h.skipEscape = !0, C(p, h);
  }
  function I(l, u, d, h) {
    const p = {};
    return h || (l = Q(C(l, d), d), u = Q(C(u, d), d)), d = d || {}, !d.tolerant && u.scheme ? (p.scheme = u.scheme, p.userinfo = u.userinfo, p.host = u.host, p.port = u.port, p.path = A(u.path || ""), p.query = u.query) : (u.userinfo !== void 0 || u.host !== void 0 || u.port !== void 0 ? (p.userinfo = u.userinfo, p.host = u.host, p.port = u.port, p.path = A(u.path || ""), p.query = u.query) : (u.path ? (u.path[0] === "/" ? p.path = A(u.path) : ((l.userinfo !== void 0 || l.host !== void 0 || l.port !== void 0) && !l.path ? p.path = "/" + u.path : l.path ? p.path = l.path.slice(0, l.path.lastIndexOf("/") + 1) + u.path : p.path = u.path, p.path = A(p.path)), p.query = u.query) : (p.path = l.path, u.query !== void 0 ? p.query = u.query : p.query = l.query), p.userinfo = l.userinfo, p.host = l.host, p.port = l.port), p.scheme = l.scheme), p.fragment = u.fragment, p;
  }
  function c(l, u, d) {
    return typeof l == "string" ? (l = unescape(l), l = C(i(Q(l, d), !0), { ...d, skipEscape: !0 })) : typeof l == "object" && (l = C(i(l, !0), { ...d, skipEscape: !0 })), typeof u == "string" ? (u = unescape(u), u = C(i(Q(u, d), !0), { ...d, skipEscape: !0 })) : typeof u == "object" && (u = C(i(u, !0), { ...d, skipEscape: !0 })), l.toLowerCase() === u.toLowerCase();
  }
  function C(l, u) {
    const d = {
      host: l.host,
      scheme: l.scheme,
      userinfo: l.userinfo,
      port: l.port,
      path: l.path,
      query: l.query,
      nid: l.nid,
      nss: l.nss,
      uuid: l.uuid,
      fragment: l.fragment,
      reference: l.reference,
      resourceName: l.resourceName,
      secure: l.secure,
      error: ""
    }, h = Object.assign({}, u), p = [], E = s(h.scheme || d.scheme);
    E && E.serialize && E.serialize(d, h), d.path !== void 0 && (h.skipEscape ? d.path = unescape(d.path) : (d.path = escape(d.path), d.scheme !== void 0 && (d.path = d.path.split("%3A").join(":")))), h.reference !== "suffix" && d.scheme && p.push(d.scheme, ":");
    const w = e(d);
    if (w !== void 0 && (h.reference !== "suffix" && p.push("//"), p.push(w), d.path && d.path[0] !== "/" && p.push("/")), d.path !== void 0) {
      let y = d.path;
      !h.absolutePath && (!E || !E.absolutePath) && (y = A(y)), w === void 0 && y[0] === "/" && y[1] === "/" && (y = "/%2F" + y.slice(2)), p.push(y);
    }
    return d.query !== void 0 && p.push("?", d.query), d.fragment !== void 0 && p.push("#", d.fragment), p.join("");
  }
  const B = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
  function Q(l, u) {
    const d = Object.assign({}, u), h = {
      scheme: void 0,
      userinfo: void 0,
      host: "",
      port: void 0,
      path: "",
      query: void 0,
      fragment: void 0
    };
    let p = !1;
    d.reference === "suffix" && (d.scheme ? l = d.scheme + ":" + l : l = "//" + l);
    const E = l.match(B);
    if (E) {
      if (h.scheme = E[1], h.userinfo = E[3], h.host = E[4], h.port = parseInt(E[5], 10), h.path = E[6] || "", h.query = E[7], h.fragment = E[8], isNaN(h.port) && (h.port = E[5]), h.host)
        if (o(h.host) === !1) {
          const m = t(h.host);
          h.host = m.host.toLowerCase(), p = m.isIPV6;
        } else
          p = !0;
      h.scheme === void 0 && h.userinfo === void 0 && h.host === void 0 && h.port === void 0 && h.query === void 0 && !h.path ? h.reference = "same-document" : h.scheme === void 0 ? h.reference = "relative" : h.fragment === void 0 ? h.reference = "absolute" : h.reference = "uri", d.reference && d.reference !== "suffix" && d.reference !== h.reference && (h.error = h.error || "URI is not a " + d.reference + " reference.");
      const w = s(d.scheme || h.scheme);
      if (!d.unicodeSupport && (!w || !w.unicodeSupport) && h.host && (d.domainHost || w && w.domainHost) && p === !1 && r(h.host))
        try {
          h.host = URL.domainToASCII(h.host.toLowerCase());
        } catch (y) {
          h.error = h.error || "Host's domain name can not be converted to ASCII: " + y;
        }
      (!w || w && !w.skipNormalize) && (l.indexOf("%") !== -1 && (h.scheme !== void 0 && (h.scheme = unescape(h.scheme)), h.host !== void 0 && (h.host = unescape(h.host))), h.path && (h.path = escape(unescape(h.path))), h.fragment && (h.fragment = encodeURI(decodeURIComponent(h.fragment)))), w && w.parse && w.parse(h, d);
    } else
      h.error = h.error || "URI can not be parsed.";
    return h;
  }
  const f = {
    SCHEMES: n,
    normalize: a,
    resolve: g,
    resolveComponent: I,
    equal: c,
    serialize: C,
    parse: Q
  };
  return ht.exports = f, ht.exports.default = f, ht.exports.fastUri = f, ht.exports;
}
var oa;
function ZD() {
  if (oa) return gi;
  oa = 1, Object.defineProperty(gi, "__esModule", { value: !0 });
  const t = _D();
  return t.code = 'require("ajv/dist/runtime/uri").default', gi.default = t, gi;
}
var ra;
function VI() {
  return ra || (ra = 1, (function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.CodeGen = t.Name = t.nil = t.stringify = t.str = t._ = t.KeywordCxt = void 0;
    var A = zt();
    Object.defineProperty(t, "KeywordCxt", { enumerable: !0, get: function() {
      return A.KeywordCxt;
    } });
    var e = oA();
    Object.defineProperty(t, "_", { enumerable: !0, get: function() {
      return e._;
    } }), Object.defineProperty(t, "str", { enumerable: !0, get: function() {
      return e.str;
    } }), Object.defineProperty(t, "stringify", { enumerable: !0, get: function() {
      return e.stringify;
    } }), Object.defineProperty(t, "nil", { enumerable: !0, get: function() {
      return e.nil;
    } }), Object.defineProperty(t, "Name", { enumerable: !0, get: function() {
      return e.Name;
    } }), Object.defineProperty(t, "CodeGen", { enumerable: !0, get: function() {
      return e.CodeGen;
    } });
    const i = Ko(), o = _t(), r = TI(), n = vo(), s = oA(), a = Ro(), g = Bo(), I = aA(), c = WD, C = ZD(), B = (T, F) => new RegExp(T, F);
    B.code = "new RegExp";
    const Q = ["removeAdditional", "useDefaults", "coerceTypes"], f = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]), l = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    }, u = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    }, d = 200;
    function h(T) {
      var F, x, R, D, N, Y, j, G, L, v, S, M, K, H, V, $, iA, gA, IA, QA, fA, Ce, HA, Yo, Uo;
      const ct = T.strict, Jo = (F = T.code) === null || F === void 0 ? void 0 : F.optimize, zn = Jo === !0 || Jo === void 0 ? 1 : Jo || 0, _n = (R = (x = T.code) === null || x === void 0 ? void 0 : x.regExp) !== null && R !== void 0 ? R : B, sc = (D = T.uriResolver) !== null && D !== void 0 ? D : C.default;
      return {
        strictSchema: (Y = (N = T.strictSchema) !== null && N !== void 0 ? N : ct) !== null && Y !== void 0 ? Y : !0,
        strictNumbers: (G = (j = T.strictNumbers) !== null && j !== void 0 ? j : ct) !== null && G !== void 0 ? G : !0,
        strictTypes: (v = (L = T.strictTypes) !== null && L !== void 0 ? L : ct) !== null && v !== void 0 ? v : "log",
        strictTuples: (M = (S = T.strictTuples) !== null && S !== void 0 ? S : ct) !== null && M !== void 0 ? M : "log",
        strictRequired: (H = (K = T.strictRequired) !== null && K !== void 0 ? K : ct) !== null && H !== void 0 ? H : !1,
        code: T.code ? { ...T.code, optimize: zn, regExp: _n } : { optimize: zn, regExp: _n },
        loopRequired: (V = T.loopRequired) !== null && V !== void 0 ? V : d,
        loopEnum: ($ = T.loopEnum) !== null && $ !== void 0 ? $ : d,
        meta: (iA = T.meta) !== null && iA !== void 0 ? iA : !0,
        messages: (gA = T.messages) !== null && gA !== void 0 ? gA : !0,
        inlineRefs: (IA = T.inlineRefs) !== null && IA !== void 0 ? IA : !0,
        schemaId: (QA = T.schemaId) !== null && QA !== void 0 ? QA : "$id",
        addUsedSchema: (fA = T.addUsedSchema) !== null && fA !== void 0 ? fA : !0,
        validateSchema: (Ce = T.validateSchema) !== null && Ce !== void 0 ? Ce : !0,
        validateFormats: (HA = T.validateFormats) !== null && HA !== void 0 ? HA : !0,
        unicodeRegExp: (Yo = T.unicodeRegExp) !== null && Yo !== void 0 ? Yo : !0,
        int32range: (Uo = T.int32range) !== null && Uo !== void 0 ? Uo : !0,
        uriResolver: sc
      };
    }
    class p {
      constructor(F = {}) {
        this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = /* @__PURE__ */ new Set(), this._loading = {}, this._cache = /* @__PURE__ */ new Map(), F = this.opts = { ...F, ...h(F) };
        const { es5: x, lines: R } = this.opts.code;
        this.scope = new s.ValueScope({ scope: {}, prefixes: f, es5: x, lines: R }), this.logger = P(F.logger);
        const D = F.validateFormats;
        F.validateFormats = !1, this.RULES = (0, r.getRules)(), E.call(this, l, F, "NOT SUPPORTED"), E.call(this, u, F, "DEPRECATED", "warn"), this._metaOpts = b.call(this), F.formats && m.call(this), this._addVocabularies(), this._addDefaultMetaSchema(), F.keywords && k.call(this, F.keywords), typeof F.meta == "object" && this.addMetaSchema(F.meta), y.call(this), F.validateFormats = D;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data: F, meta: x, schemaId: R } = this.opts;
        let D = c;
        R === "id" && (D = { ...c }, D.id = D.$id, delete D.$id), x && F && this.addMetaSchema(D, D[R], !1);
      }
      defaultMeta() {
        const { meta: F, schemaId: x } = this.opts;
        return this.opts.defaultMeta = typeof F == "object" ? F[x] || F : void 0;
      }
      validate(F, x) {
        let R;
        if (typeof F == "string") {
          if (R = this.getSchema(F), !R)
            throw new Error(`no schema with key or ref "${F}"`);
        } else
          R = this.compile(F);
        const D = R(x);
        return "$async" in R || (this.errors = R.errors), D;
      }
      compile(F, x) {
        const R = this._addSchema(F, x);
        return R.validate || this._compileSchemaEnv(R);
      }
      compileAsync(F, x) {
        if (typeof this.opts.loadSchema != "function")
          throw new Error("options.loadSchema should be a function");
        const { loadSchema: R } = this.opts;
        return D.call(this, F, x);
        async function D(v, S) {
          await N.call(this, v.$schema);
          const M = this._addSchema(v, S);
          return M.validate || Y.call(this, M);
        }
        async function N(v) {
          v && !this.getSchema(v) && await D.call(this, { $ref: v }, !0);
        }
        async function Y(v) {
          try {
            return this._compileSchemaEnv(v);
          } catch (S) {
            if (!(S instanceof o.default))
              throw S;
            return j.call(this, S), await G.call(this, S.missingSchema), Y.call(this, v);
          }
        }
        function j({ missingSchema: v, missingRef: S }) {
          if (this.refs[v])
            throw new Error(`AnySchema ${v} is loaded but ${S} cannot be resolved`);
        }
        async function G(v) {
          const S = await L.call(this, v);
          this.refs[v] || await N.call(this, S.$schema), this.refs[v] || this.addSchema(S, v, x);
        }
        async function L(v) {
          const S = this._loading[v];
          if (S)
            return S;
          try {
            return await (this._loading[v] = R(v));
          } finally {
            delete this._loading[v];
          }
        }
      }
      // Adds schema to the instance
      addSchema(F, x, R, D = this.opts.validateSchema) {
        if (Array.isArray(F)) {
          for (const Y of F)
            this.addSchema(Y, void 0, R, D);
          return this;
        }
        let N;
        if (typeof F == "object") {
          const { schemaId: Y } = this.opts;
          if (N = F[Y], N !== void 0 && typeof N != "string")
            throw new Error(`schema ${Y} must be string`);
        }
        return x = (0, a.normalizeId)(x || N), this._checkUnique(x), this.schemas[x] = this._addSchema(F, R, x, D, !0), this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(F, x, R = this.opts.validateSchema) {
        return this.addSchema(F, x, !0, R), this;
      }
      //  Validate schema against its meta-schema
      validateSchema(F, x) {
        if (typeof F == "boolean")
          return !0;
        let R;
        if (R = F.$schema, R !== void 0 && typeof R != "string")
          throw new Error("$schema must be a string");
        if (R = R || this.opts.defaultMeta || this.defaultMeta(), !R)
          return this.logger.warn("meta-schema not available"), this.errors = null, !0;
        const D = this.validate(R, F);
        if (!D && x) {
          const N = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(N);
          else
            throw new Error(N);
        }
        return D;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(F) {
        let x;
        for (; typeof (x = w.call(this, F)) == "string"; )
          F = x;
        if (x === void 0) {
          const { schemaId: R } = this.opts, D = new n.SchemaEnv({ schema: {}, schemaId: R });
          if (x = n.resolveSchema.call(this, D, F), !x)
            return;
          this.refs[F] = x;
        }
        return x.validate || this._compileSchemaEnv(x);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(F) {
        if (F instanceof RegExp)
          return this._removeAllSchemas(this.schemas, F), this._removeAllSchemas(this.refs, F), this;
        switch (typeof F) {
          case "undefined":
            return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
          case "string": {
            const x = w.call(this, F);
            return typeof x == "object" && this._cache.delete(x.schema), delete this.schemas[F], delete this.refs[F], this;
          }
          case "object": {
            const x = F;
            this._cache.delete(x);
            let R = F[this.opts.schemaId];
            return R && (R = (0, a.normalizeId)(R), delete this.schemas[R], delete this.refs[R]), this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(F) {
        for (const x of F)
          this.addKeyword(x);
        return this;
      }
      addKeyword(F, x) {
        let R;
        if (typeof F == "string")
          R = F, typeof x == "object" && (this.logger.warn("these parameters are deprecated, see docs for addKeyword"), x.keyword = R);
        else if (typeof F == "object" && x === void 0) {
          if (x = F, R = x.keyword, Array.isArray(R) && !R.length)
            throw new Error("addKeywords: keyword must be string or non-empty array");
        } else
          throw new Error("invalid addKeywords parameters");
        if (W.call(this, R, x), !x)
          return (0, I.eachItem)(R, (N) => X.call(this, N)), this;
        _.call(this, x);
        const D = {
          ...x,
          type: (0, g.getJSONTypes)(x.type),
          schemaType: (0, g.getJSONTypes)(x.schemaType)
        };
        return (0, I.eachItem)(R, D.type.length === 0 ? (N) => X.call(this, N, D) : (N) => D.type.forEach((Y) => X.call(this, N, D, Y))), this;
      }
      getKeyword(F) {
        const x = this.RULES.all[F];
        return typeof x == "object" ? x.definition : !!x;
      }
      // Remove keyword
      removeKeyword(F) {
        const { RULES: x } = this;
        delete x.keywords[F], delete x.all[F];
        for (const R of x.rules) {
          const D = R.rules.findIndex((N) => N.keyword === F);
          D >= 0 && R.rules.splice(D, 1);
        }
        return this;
      }
      // Add format
      addFormat(F, x) {
        return typeof x == "string" && (x = new RegExp(x)), this.formats[F] = x, this;
      }
      errorsText(F = this.errors, { separator: x = ", ", dataVar: R = "data" } = {}) {
        return !F || F.length === 0 ? "No errors" : F.map((D) => `${R}${D.instancePath} ${D.message}`).reduce((D, N) => D + x + N);
      }
      $dataMetaSchema(F, x) {
        const R = this.RULES.all;
        F = JSON.parse(JSON.stringify(F));
        for (const D of x) {
          const N = D.split("/").slice(1);
          let Y = F;
          for (const j of N)
            Y = Y[j];
          for (const j in R) {
            const G = R[j];
            if (typeof G != "object")
              continue;
            const { $data: L } = G.definition, v = Y[j];
            L && v && (Y[j] = Z(v));
          }
        }
        return F;
      }
      _removeAllSchemas(F, x) {
        for (const R in F) {
          const D = F[R];
          (!x || x.test(R)) && (typeof D == "string" ? delete F[R] : D && !D.meta && (this._cache.delete(D.schema), delete F[R]));
        }
      }
      _addSchema(F, x, R, D = this.opts.validateSchema, N = this.opts.addUsedSchema) {
        let Y;
        const { schemaId: j } = this.opts;
        if (typeof F == "object")
          Y = F[j];
        else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          if (typeof F != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let G = this._cache.get(F);
        if (G !== void 0)
          return G;
        R = (0, a.normalizeId)(Y || R);
        const L = a.getSchemaRefs.call(this, F, R);
        return G = new n.SchemaEnv({ schema: F, schemaId: j, meta: x, baseId: R, localRefs: L }), this._cache.set(G.schema, G), N && !R.startsWith("#") && (R && this._checkUnique(R), this.refs[R] = G), D && this.validateSchema(F, !0), G;
      }
      _checkUnique(F) {
        if (this.schemas[F] || this.refs[F])
          throw new Error(`schema with key or id "${F}" already exists`);
      }
      _compileSchemaEnv(F) {
        if (F.meta ? this._compileMetaSchema(F) : n.compileSchema.call(this, F), !F.validate)
          throw new Error("ajv implementation error");
        return F.validate;
      }
      _compileMetaSchema(F) {
        const x = this.opts;
        this.opts = this._metaOpts;
        try {
          n.compileSchema.call(this, F);
        } finally {
          this.opts = x;
        }
      }
    }
    p.ValidationError = i.default, p.MissingRefError = o.default, t.default = p;
    function E(T, F, x, R = "error") {
      for (const D in T) {
        const N = D;
        N in F && this.logger[R](`${x}: option ${D}. ${T[N]}`);
      }
    }
    function w(T) {
      return T = (0, a.normalizeId)(T), this.schemas[T] || this.refs[T];
    }
    function y() {
      const T = this.opts.schemas;
      if (T)
        if (Array.isArray(T))
          this.addSchema(T);
        else
          for (const F in T)
            this.addSchema(T[F], F);
    }
    function m() {
      for (const T in this.opts.formats) {
        const F = this.opts.formats[T];
        F && this.addFormat(T, F);
      }
    }
    function k(T) {
      if (Array.isArray(T)) {
        this.addVocabulary(T);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const F in T) {
        const x = T[F];
        x.keyword || (x.keyword = F), this.addKeyword(x);
      }
    }
    function b() {
      const T = { ...this.opts };
      for (const F of Q)
        delete T[F];
      return T;
    }
    const q = { log() {
    }, warn() {
    }, error() {
    } };
    function P(T) {
      if (T === !1)
        return q;
      if (T === void 0)
        return console;
      if (T.log && T.warn && T.error)
        return T;
      throw new Error("logger must implement log, warn and error methods");
    }
    const J = /^[a-z_$][a-z0-9_$:-]*$/i;
    function W(T, F) {
      const { RULES: x } = this;
      if ((0, I.eachItem)(T, (R) => {
        if (x.keywords[R])
          throw new Error(`Keyword ${R} is already defined`);
        if (!J.test(R))
          throw new Error(`Keyword ${R} has invalid name`);
      }), !!F && F.$data && !("code" in F || "validate" in F))
        throw new Error('$data keyword must have "code" or "validate" function');
    }
    function X(T, F, x) {
      var R;
      const D = F?.post;
      if (x && D)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES: N } = this;
      let Y = D ? N.post : N.rules.find(({ type: G }) => G === x);
      if (Y || (Y = { type: x, rules: [] }, N.rules.push(Y)), N.keywords[T] = !0, !F)
        return;
      const j = {
        keyword: T,
        definition: {
          ...F,
          type: (0, g.getJSONTypes)(F.type),
          schemaType: (0, g.getJSONTypes)(F.schemaType)
        }
      };
      F.before ? z.call(this, Y, j, F.before) : Y.rules.push(j), N.all[T] = j, (R = F.implements) === null || R === void 0 || R.forEach((G) => this.addKeyword(G));
    }
    function z(T, F, x) {
      const R = T.rules.findIndex((D) => D.keyword === x);
      R >= 0 ? T.rules.splice(R, 0, F) : (T.rules.push(F), this.logger.warn(`rule ${x} is not defined`));
    }
    function _(T) {
      let { metaSchema: F } = T;
      F !== void 0 && (T.$data && this.opts.$data && (F = Z(F)), T.validateSchema = this.compile(F, !0));
    }
    const O = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function Z(T) {
      return { anyOf: [T, O] };
    }
  })(rr)), rr;
}
var Ii = {}, ci = {}, Ci = {}, na;
function XD() {
  if (na) return Ci;
  na = 1, Object.defineProperty(Ci, "__esModule", { value: !0 });
  const t = {
    keyword: "id",
    code() {
      throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
    }
  };
  return Ci.default = t, Ci;
}
var Qe = {}, sa;
function Vn() {
  if (sa) return Qe;
  sa = 1, Object.defineProperty(Qe, "__esModule", { value: !0 }), Qe.callRef = Qe.getValidate = void 0;
  const t = _t(), A = _A(), e = oA(), i = zA(), o = vo(), r = aA(), n = {
    keyword: "$ref",
    schemaType: "string",
    code(g) {
      const { gen: I, schema: c, it: C } = g, { baseId: B, schemaEnv: Q, validateName: f, opts: l, self: u } = C, { root: d } = Q;
      if ((c === "#" || c === "#/") && B === d.baseId)
        return p();
      const h = o.resolveRef.call(u, d, B, c);
      if (h === void 0)
        throw new t.default(C.opts.uriResolver, B, c);
      if (h instanceof o.SchemaEnv)
        return E(h);
      return w(h);
      function p() {
        if (Q === d)
          return a(g, f, Q, Q.$async);
        const y = I.scopeValue("root", { ref: d });
        return a(g, (0, e._)`${y}.validate`, d, d.$async);
      }
      function E(y) {
        const m = s(g, y);
        a(g, m, y, y.$async);
      }
      function w(y) {
        const m = I.scopeValue("schema", l.code.source === !0 ? { ref: y, code: (0, e.stringify)(y) } : { ref: y }), k = I.name("valid"), b = g.subschema({
          schema: y,
          dataTypes: [],
          schemaPath: e.nil,
          topSchemaRef: m,
          errSchemaPath: c
        }, k);
        g.mergeEvaluated(b), g.ok(k);
      }
    }
  };
  function s(g, I) {
    const { gen: c } = g;
    return I.validate ? c.scopeValue("validate", { ref: I.validate }) : (0, e._)`${c.scopeValue("wrapper", { ref: I })}.validate`;
  }
  Qe.getValidate = s;
  function a(g, I, c, C) {
    const { gen: B, it: Q } = g, { allErrors: f, schemaEnv: l, opts: u } = Q, d = u.passContext ? i.default.this : e.nil;
    C ? h() : p();
    function h() {
      if (!l.$async)
        throw new Error("async schema referenced by sync schema");
      const y = B.let("valid");
      B.try(() => {
        B.code((0, e._)`await ${(0, A.callValidateCode)(g, I, d)}`), w(I), f || B.assign(y, !0);
      }, (m) => {
        B.if((0, e._)`!(${m} instanceof ${Q.ValidationError})`, () => B.throw(m)), E(m), f || B.assign(y, !1);
      }), g.ok(y);
    }
    function p() {
      g.result((0, A.callValidateCode)(g, I, d), () => w(I), () => E(I));
    }
    function E(y) {
      const m = (0, e._)`${y}.errors`;
      B.assign(i.default.vErrors, (0, e._)`${i.default.vErrors} === null ? ${m} : ${i.default.vErrors}.concat(${m})`), B.assign(i.default.errors, (0, e._)`${i.default.vErrors}.length`);
    }
    function w(y) {
      var m;
      if (!Q.opts.unevaluated)
        return;
      const k = (m = c?.validate) === null || m === void 0 ? void 0 : m.evaluated;
      if (Q.props !== !0)
        if (k && !k.dynamicProps)
          k.props !== void 0 && (Q.props = r.mergeEvaluated.props(B, k.props, Q.props));
        else {
          const b = B.var("props", (0, e._)`${y}.evaluated.props`);
          Q.props = r.mergeEvaluated.props(B, b, Q.props, e.Name);
        }
      if (Q.items !== !0)
        if (k && !k.dynamicItems)
          k.items !== void 0 && (Q.items = r.mergeEvaluated.items(B, k.items, Q.items));
        else {
          const b = B.var("items", (0, e._)`${y}.evaluated.items`);
          Q.items = r.mergeEvaluated.items(B, b, Q.items, e.Name);
        }
    }
  }
  return Qe.callRef = a, Qe.default = n, Qe;
}
var aa;
function $I() {
  if (aa) return ci;
  aa = 1, Object.defineProperty(ci, "__esModule", { value: !0 });
  const t = XD(), A = Vn(), e = [
    "$schema",
    "$id",
    "$defs",
    "$vocabulary",
    { keyword: "$comment" },
    "definitions",
    t.default,
    A.default
  ];
  return ci.default = e, ci;
}
var Bi = {}, Qi = {}, ga;
function Am() {
  if (ga) return Qi;
  ga = 1, Object.defineProperty(Qi, "__esModule", { value: !0 });
  const t = oA(), A = t.operators, e = {
    maximum: { okStr: "<=", ok: A.LTE, fail: A.GT },
    minimum: { okStr: ">=", ok: A.GTE, fail: A.LT },
    exclusiveMaximum: { okStr: "<", ok: A.LT, fail: A.GTE },
    exclusiveMinimum: { okStr: ">", ok: A.GT, fail: A.LTE }
  }, i = {
    message: ({ keyword: r, schemaCode: n }) => (0, t.str)`must be ${e[r].okStr} ${n}`,
    params: ({ keyword: r, schemaCode: n }) => (0, t._)`{comparison: ${e[r].okStr}, limit: ${n}}`
  }, o = {
    keyword: Object.keys(e),
    type: "number",
    schemaType: "number",
    $data: !0,
    error: i,
    code(r) {
      const { keyword: n, data: s, schemaCode: a } = r;
      r.fail$data((0, t._)`${s} ${e[n].fail} ${a} || isNaN(${s})`);
    }
  };
  return Qi.default = o, Qi;
}
var Ei = {}, Ia;
function em() {
  if (Ia) return Ei;
  Ia = 1, Object.defineProperty(Ei, "__esModule", { value: !0 });
  const t = oA(), e = {
    keyword: "multipleOf",
    type: "number",
    schemaType: "number",
    $data: !0,
    error: {
      message: ({ schemaCode: i }) => (0, t.str)`must be multiple of ${i}`,
      params: ({ schemaCode: i }) => (0, t._)`{multipleOf: ${i}}`
    },
    code(i) {
      const { gen: o, data: r, schemaCode: n, it: s } = i, a = s.opts.multipleOfPrecision, g = o.let("res"), I = a ? (0, t._)`Math.abs(Math.round(${g}) - ${g}) > 1e-${a}` : (0, t._)`${g} !== parseInt(${g})`;
      i.fail$data((0, t._)`(${n} === 0 || (${g} = ${r}/${n}, ${I}))`);
    }
  };
  return Ei.default = e, Ei;
}
var li = {}, di = {}, ca;
function tm() {
  if (ca) return di;
  ca = 1, Object.defineProperty(di, "__esModule", { value: !0 });
  function t(A) {
    const e = A.length;
    let i = 0, o = 0, r;
    for (; o < e; )
      i++, r = A.charCodeAt(o++), r >= 55296 && r <= 56319 && o < e && (r = A.charCodeAt(o), (r & 64512) === 56320 && o++);
    return i;
  }
  return di.default = t, t.code = 'require("ajv/dist/runtime/ucs2length").default', di;
}
var Ca;
function im() {
  if (Ca) return li;
  Ca = 1, Object.defineProperty(li, "__esModule", { value: !0 });
  const t = oA(), A = aA(), e = tm(), o = {
    keyword: ["maxLength", "minLength"],
    type: "string",
    schemaType: "number",
    $data: !0,
    error: {
      message({ keyword: r, schemaCode: n }) {
        const s = r === "maxLength" ? "more" : "fewer";
        return (0, t.str)`must NOT have ${s} than ${n} characters`;
      },
      params: ({ schemaCode: r }) => (0, t._)`{limit: ${r}}`
    },
    code(r) {
      const { keyword: n, data: s, schemaCode: a, it: g } = r, I = n === "maxLength" ? t.operators.GT : t.operators.LT, c = g.opts.unicode === !1 ? (0, t._)`${s}.length` : (0, t._)`${(0, A.useFunc)(r.gen, e.default)}(${s})`;
      r.fail$data((0, t._)`${c} ${I} ${a}`);
    }
  };
  return li.default = o, li;
}
var ui = {}, Ba;
function om() {
  if (Ba) return ui;
  Ba = 1, Object.defineProperty(ui, "__esModule", { value: !0 });
  const t = _A(), A = oA(), i = {
    keyword: "pattern",
    type: "string",
    schemaType: "string",
    $data: !0,
    error: {
      message: ({ schemaCode: o }) => (0, A.str)`must match pattern "${o}"`,
      params: ({ schemaCode: o }) => (0, A._)`{pattern: ${o}}`
    },
    code(o) {
      const { data: r, $data: n, schema: s, schemaCode: a, it: g } = o, I = g.opts.unicodeRegExp ? "u" : "", c = n ? (0, A._)`(new RegExp(${a}, ${I}))` : (0, t.usePattern)(o, s);
      o.fail$data((0, A._)`!${c}.test(${r})`);
    }
  };
  return ui.default = i, ui;
}
var hi = {}, Qa;
function rm() {
  if (Qa) return hi;
  Qa = 1, Object.defineProperty(hi, "__esModule", { value: !0 });
  const t = oA(), e = {
    keyword: ["maxProperties", "minProperties"],
    type: "object",
    schemaType: "number",
    $data: !0,
    error: {
      message({ keyword: i, schemaCode: o }) {
        const r = i === "maxProperties" ? "more" : "fewer";
        return (0, t.str)`must NOT have ${r} than ${o} properties`;
      },
      params: ({ schemaCode: i }) => (0, t._)`{limit: ${i}}`
    },
    code(i) {
      const { keyword: o, data: r, schemaCode: n } = i, s = o === "maxProperties" ? t.operators.GT : t.operators.LT;
      i.fail$data((0, t._)`Object.keys(${r}).length ${s} ${n}`);
    }
  };
  return hi.default = e, hi;
}
var fi = {}, Ea;
function nm() {
  if (Ea) return fi;
  Ea = 1, Object.defineProperty(fi, "__esModule", { value: !0 });
  const t = _A(), A = oA(), e = aA(), o = {
    keyword: "required",
    type: "object",
    schemaType: "array",
    $data: !0,
    error: {
      message: ({ params: { missingProperty: r } }) => (0, A.str)`must have required property '${r}'`,
      params: ({ params: { missingProperty: r } }) => (0, A._)`{missingProperty: ${r}}`
    },
    code(r) {
      const { gen: n, schema: s, schemaCode: a, data: g, $data: I, it: c } = r, { opts: C } = c;
      if (!I && s.length === 0)
        return;
      const B = s.length >= C.loopRequired;
      if (c.allErrors ? Q() : f(), C.strictRequired) {
        const d = r.parentSchema.properties, { definedProperties: h } = r.it;
        for (const p of s)
          if (d?.[p] === void 0 && !h.has(p)) {
            const E = c.schemaEnv.baseId + c.errSchemaPath, w = `required property "${p}" is not defined at "${E}" (strictRequired)`;
            (0, e.checkStrictMode)(c, w, c.opts.strictRequired);
          }
      }
      function Q() {
        if (B || I)
          r.block$data(A.nil, l);
        else
          for (const d of s)
            (0, t.checkReportMissingProp)(r, d);
      }
      function f() {
        const d = n.let("missing");
        if (B || I) {
          const h = n.let("valid", !0);
          r.block$data(h, () => u(d, h)), r.ok(h);
        } else
          n.if((0, t.checkMissingProp)(r, s, d)), (0, t.reportMissingProp)(r, d), n.else();
      }
      function l() {
        n.forOf("prop", a, (d) => {
          r.setParams({ missingProperty: d }), n.if((0, t.noPropertyInData)(n, g, d, C.ownProperties), () => r.error());
        });
      }
      function u(d, h) {
        r.setParams({ missingProperty: d }), n.forOf(d, a, () => {
          n.assign(h, (0, t.propertyInData)(n, g, d, C.ownProperties)), n.if((0, A.not)(h), () => {
            r.error(), n.break();
          });
        }, A.nil);
      }
    }
  };
  return fi.default = o, fi;
}
var pi = {}, la;
function sm() {
  if (la) return pi;
  la = 1, Object.defineProperty(pi, "__esModule", { value: !0 });
  const t = oA(), e = {
    keyword: ["maxItems", "minItems"],
    type: "array",
    schemaType: "number",
    $data: !0,
    error: {
      message({ keyword: i, schemaCode: o }) {
        const r = i === "maxItems" ? "more" : "fewer";
        return (0, t.str)`must NOT have ${r} than ${o} items`;
      },
      params: ({ schemaCode: i }) => (0, t._)`{limit: ${i}}`
    },
    code(i) {
      const { keyword: o, data: r, schemaCode: n } = i, s = o === "maxItems" ? t.operators.GT : t.operators.LT;
      i.fail$data((0, t._)`${r}.length ${s} ${n}`);
    }
  };
  return pi.default = e, pi;
}
var wi = {}, yi = {}, da;
function $n() {
  if (da) return yi;
  da = 1, Object.defineProperty(yi, "__esModule", { value: !0 });
  const t = PI();
  return t.code = 'require("ajv/dist/runtime/equal").default', yi.default = t, yi;
}
var ua;
function am() {
  if (ua) return wi;
  ua = 1, Object.defineProperty(wi, "__esModule", { value: !0 });
  const t = Bo(), A = oA(), e = aA(), i = $n(), r = {
    keyword: "uniqueItems",
    type: "array",
    schemaType: "boolean",
    $data: !0,
    error: {
      message: ({ params: { i: n, j: s } }) => (0, A.str)`must NOT have duplicate items (items ## ${s} and ${n} are identical)`,
      params: ({ params: { i: n, j: s } }) => (0, A._)`{i: ${n}, j: ${s}}`
    },
    code(n) {
      const { gen: s, data: a, $data: g, schema: I, parentSchema: c, schemaCode: C, it: B } = n;
      if (!g && !I)
        return;
      const Q = s.let("valid"), f = c.items ? (0, t.getSchemaTypes)(c.items) : [];
      n.block$data(Q, l, (0, A._)`${C} === false`), n.ok(Q);
      function l() {
        const p = s.let("i", (0, A._)`${a}.length`), E = s.let("j");
        n.setParams({ i: p, j: E }), s.assign(Q, !0), s.if((0, A._)`${p} > 1`, () => (u() ? d : h)(p, E));
      }
      function u() {
        return f.length > 0 && !f.some((p) => p === "object" || p === "array");
      }
      function d(p, E) {
        const w = s.name("item"), y = (0, t.checkDataTypes)(f, w, B.opts.strictNumbers, t.DataType.Wrong), m = s.const("indices", (0, A._)`{}`);
        s.for((0, A._)`;${p}--;`, () => {
          s.let(w, (0, A._)`${a}[${p}]`), s.if(y, (0, A._)`continue`), f.length > 1 && s.if((0, A._)`typeof ${w} == "string"`, (0, A._)`${w} += "_"`), s.if((0, A._)`typeof ${m}[${w}] == "number"`, () => {
            s.assign(E, (0, A._)`${m}[${w}]`), n.error(), s.assign(Q, !1).break();
          }).code((0, A._)`${m}[${w}] = ${p}`);
        });
      }
      function h(p, E) {
        const w = (0, e.useFunc)(s, i.default), y = s.name("outer");
        s.label(y).for((0, A._)`;${p}--;`, () => s.for((0, A._)`${E} = ${p}; ${E}--;`, () => s.if((0, A._)`${w}(${a}[${p}], ${a}[${E}])`, () => {
          n.error(), s.assign(Q, !1).break(y);
        })));
      }
    }
  };
  return wi.default = r, wi;
}
var Di = {}, ha;
function gm() {
  if (ha) return Di;
  ha = 1, Object.defineProperty(Di, "__esModule", { value: !0 });
  const t = oA(), A = aA(), e = $n(), o = {
    keyword: "const",
    $data: !0,
    error: {
      message: "must be equal to constant",
      params: ({ schemaCode: r }) => (0, t._)`{allowedValue: ${r}}`
    },
    code(r) {
      const { gen: n, data: s, $data: a, schemaCode: g, schema: I } = r;
      a || I && typeof I == "object" ? r.fail$data((0, t._)`!${(0, A.useFunc)(n, e.default)}(${s}, ${g})`) : r.fail((0, t._)`${I} !== ${s}`);
    }
  };
  return Di.default = o, Di;
}
var mi = {}, fa;
function Im() {
  if (fa) return mi;
  fa = 1, Object.defineProperty(mi, "__esModule", { value: !0 });
  const t = oA(), A = aA(), e = $n(), o = {
    keyword: "enum",
    schemaType: "array",
    $data: !0,
    error: {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode: r }) => (0, t._)`{allowedValues: ${r}}`
    },
    code(r) {
      const { gen: n, data: s, $data: a, schema: g, schemaCode: I, it: c } = r;
      if (!a && g.length === 0)
        throw new Error("enum must have non-empty array");
      const C = g.length >= c.opts.loopEnum;
      let B;
      const Q = () => B ?? (B = (0, A.useFunc)(n, e.default));
      let f;
      if (C || a)
        f = n.let("valid"), r.block$data(f, l);
      else {
        if (!Array.isArray(g))
          throw new Error("ajv implementation error");
        const d = n.const("vSchema", I);
        f = (0, t.or)(...g.map((h, p) => u(d, p)));
      }
      r.pass(f);
      function l() {
        n.assign(f, !1), n.forOf("v", I, (d) => n.if((0, t._)`${Q()}(${s}, ${d})`, () => n.assign(f, !0).break()));
      }
      function u(d, h) {
        const p = g[h];
        return typeof p == "object" && p !== null ? (0, t._)`${Q()}(${s}, ${d}[${h}])` : (0, t._)`${s} === ${p}`;
      }
    }
  };
  return mi.default = o, mi;
}
var pa;
function WI() {
  if (pa) return Bi;
  pa = 1, Object.defineProperty(Bi, "__esModule", { value: !0 });
  const t = Am(), A = em(), e = im(), i = om(), o = rm(), r = nm(), n = sm(), s = am(), a = gm(), g = Im(), I = [
    // number
    t.default,
    A.default,
    // string
    e.default,
    i.default,
    // object
    o.default,
    r.default,
    // array
    n.default,
    s.default,
    // any
    { keyword: "type", schemaType: ["string", "array"] },
    { keyword: "nullable", schemaType: "boolean" },
    a.default,
    g.default
  ];
  return Bi.default = I, Bi;
}
var Si = {}, Oe = {}, wa;
function zI() {
  if (wa) return Oe;
  wa = 1, Object.defineProperty(Oe, "__esModule", { value: !0 }), Oe.validateAdditionalItems = void 0;
  const t = oA(), A = aA(), i = {
    keyword: "additionalItems",
    type: "array",
    schemaType: ["boolean", "object"],
    before: "uniqueItems",
    error: {
      message: ({ params: { len: r } }) => (0, t.str)`must NOT have more than ${r} items`,
      params: ({ params: { len: r } }) => (0, t._)`{limit: ${r}}`
    },
    code(r) {
      const { parentSchema: n, it: s } = r, { items: a } = n;
      if (!Array.isArray(a)) {
        (0, A.checkStrictMode)(s, '"additionalItems" is ignored when "items" is not an array of schemas');
        return;
      }
      o(r, a);
    }
  };
  function o(r, n) {
    const { gen: s, schema: a, data: g, keyword: I, it: c } = r;
    c.items = !0;
    const C = s.const("len", (0, t._)`${g}.length`);
    if (a === !1)
      r.setParams({ len: n.length }), r.pass((0, t._)`${C} <= ${n.length}`);
    else if (typeof a == "object" && !(0, A.alwaysValidSchema)(c, a)) {
      const Q = s.var("valid", (0, t._)`${C} <= ${n.length}`);
      s.if((0, t.not)(Q), () => B(Q)), r.ok(Q);
    }
    function B(Q) {
      s.forRange("i", n.length, C, (f) => {
        r.subschema({ keyword: I, dataProp: f, dataPropType: A.Type.Num }, Q), c.allErrors || s.if((0, t.not)(Q), () => s.break());
      });
    }
  }
  return Oe.validateAdditionalItems = o, Oe.default = i, Oe;
}
var ki = {}, Pe = {}, ya;
function _I() {
  if (ya) return Pe;
  ya = 1, Object.defineProperty(Pe, "__esModule", { value: !0 }), Pe.validateTuple = void 0;
  const t = oA(), A = aA(), e = _A(), i = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "array", "boolean"],
    before: "uniqueItems",
    code(r) {
      const { schema: n, it: s } = r;
      if (Array.isArray(n))
        return o(r, "additionalItems", n);
      s.items = !0, !(0, A.alwaysValidSchema)(s, n) && r.ok((0, e.validateArray)(r));
    }
  };
  function o(r, n, s = r.schema) {
    const { gen: a, parentSchema: g, data: I, keyword: c, it: C } = r;
    f(g), C.opts.unevaluated && s.length && C.items !== !0 && (C.items = A.mergeEvaluated.items(a, s.length, C.items));
    const B = a.name("valid"), Q = a.const("len", (0, t._)`${I}.length`);
    s.forEach((l, u) => {
      (0, A.alwaysValidSchema)(C, l) || (a.if((0, t._)`${Q} > ${u}`, () => r.subschema({
        keyword: c,
        schemaProp: u,
        dataProp: u
      }, B)), r.ok(B));
    });
    function f(l) {
      const { opts: u, errSchemaPath: d } = C, h = s.length, p = h === l.minItems && (h === l.maxItems || l[n] === !1);
      if (u.strictTuples && !p) {
        const E = `"${c}" is ${h}-tuple, but minItems or maxItems/${n} are not specified or different at path "${d}"`;
        (0, A.checkStrictMode)(C, E, u.strictTuples);
      }
    }
  }
  return Pe.validateTuple = o, Pe.default = i, Pe;
}
var Da;
function cm() {
  if (Da) return ki;
  Da = 1, Object.defineProperty(ki, "__esModule", { value: !0 });
  const t = _I(), A = {
    keyword: "prefixItems",
    type: "array",
    schemaType: ["array"],
    before: "uniqueItems",
    code: (e) => (0, t.validateTuple)(e, "items")
  };
  return ki.default = A, ki;
}
var Ni = {}, ma;
function Cm() {
  if (ma) return Ni;
  ma = 1, Object.defineProperty(Ni, "__esModule", { value: !0 });
  const t = oA(), A = aA(), e = _A(), i = zI(), r = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    error: {
      message: ({ params: { len: n } }) => (0, t.str)`must NOT have more than ${n} items`,
      params: ({ params: { len: n } }) => (0, t._)`{limit: ${n}}`
    },
    code(n) {
      const { schema: s, parentSchema: a, it: g } = n, { prefixItems: I } = a;
      g.items = !0, !(0, A.alwaysValidSchema)(g, s) && (I ? (0, i.validateAdditionalItems)(n, I) : n.ok((0, e.validateArray)(n)));
    }
  };
  return Ni.default = r, Ni;
}
var Mi = {}, Sa;
function Bm() {
  if (Sa) return Mi;
  Sa = 1, Object.defineProperty(Mi, "__esModule", { value: !0 });
  const t = oA(), A = aA(), i = {
    keyword: "contains",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    trackErrors: !0,
    error: {
      message: ({ params: { min: o, max: r } }) => r === void 0 ? (0, t.str)`must contain at least ${o} valid item(s)` : (0, t.str)`must contain at least ${o} and no more than ${r} valid item(s)`,
      params: ({ params: { min: o, max: r } }) => r === void 0 ? (0, t._)`{minContains: ${o}}` : (0, t._)`{minContains: ${o}, maxContains: ${r}}`
    },
    code(o) {
      const { gen: r, schema: n, parentSchema: s, data: a, it: g } = o;
      let I, c;
      const { minContains: C, maxContains: B } = s;
      g.opts.next ? (I = C === void 0 ? 1 : C, c = B) : I = 1;
      const Q = r.const("len", (0, t._)`${a}.length`);
      if (o.setParams({ min: I, max: c }), c === void 0 && I === 0) {
        (0, A.checkStrictMode)(g, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
        return;
      }
      if (c !== void 0 && I > c) {
        (0, A.checkStrictMode)(g, '"minContains" > "maxContains" is always invalid'), o.fail();
        return;
      }
      if ((0, A.alwaysValidSchema)(g, n)) {
        let h = (0, t._)`${Q} >= ${I}`;
        c !== void 0 && (h = (0, t._)`${h} && ${Q} <= ${c}`), o.pass(h);
        return;
      }
      g.items = !0;
      const f = r.name("valid");
      c === void 0 && I === 1 ? u(f, () => r.if(f, () => r.break())) : I === 0 ? (r.let(f, !0), c !== void 0 && r.if((0, t._)`${a}.length > 0`, l)) : (r.let(f, !1), l()), o.result(f, () => o.reset());
      function l() {
        const h = r.name("_valid"), p = r.let("count", 0);
        u(h, () => r.if(h, () => d(p)));
      }
      function u(h, p) {
        r.forRange("i", 0, Q, (E) => {
          o.subschema({
            keyword: "contains",
            dataProp: E,
            dataPropType: A.Type.Num,
            compositeRule: !0
          }, h), p();
        });
      }
      function d(h) {
        r.code((0, t._)`${h}++`), c === void 0 ? r.if((0, t._)`${h} >= ${I}`, () => r.assign(f, !0).break()) : (r.if((0, t._)`${h} > ${c}`, () => r.assign(f, !1).break()), I === 1 ? r.assign(f, !0) : r.if((0, t._)`${h} >= ${I}`, () => r.assign(f, !0)));
      }
    }
  };
  return Mi.default = i, Mi;
}
var Qr = {}, ka;
function Wn() {
  return ka || (ka = 1, (function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.validateSchemaDeps = t.validatePropertyDeps = t.error = void 0;
    const A = oA(), e = aA(), i = _A();
    t.error = {
      message: ({ params: { property: a, depsCount: g, deps: I } }) => {
        const c = g === 1 ? "property" : "properties";
        return (0, A.str)`must have ${c} ${I} when property ${a} is present`;
      },
      params: ({ params: { property: a, depsCount: g, deps: I, missingProperty: c } }) => (0, A._)`{property: ${a},
    missingProperty: ${c},
    depsCount: ${g},
    deps: ${I}}`
      // TODO change to reference
    };
    const o = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: t.error,
      code(a) {
        const [g, I] = r(a);
        n(a, g), s(a, I);
      }
    };
    function r({ schema: a }) {
      const g = {}, I = {};
      for (const c in a) {
        if (c === "__proto__")
          continue;
        const C = Array.isArray(a[c]) ? g : I;
        C[c] = a[c];
      }
      return [g, I];
    }
    function n(a, g = a.schema) {
      const { gen: I, data: c, it: C } = a;
      if (Object.keys(g).length === 0)
        return;
      const B = I.let("missing");
      for (const Q in g) {
        const f = g[Q];
        if (f.length === 0)
          continue;
        const l = (0, i.propertyInData)(I, c, Q, C.opts.ownProperties);
        a.setParams({
          property: Q,
          depsCount: f.length,
          deps: f.join(", ")
        }), C.allErrors ? I.if(l, () => {
          for (const u of f)
            (0, i.checkReportMissingProp)(a, u);
        }) : (I.if((0, A._)`${l} && (${(0, i.checkMissingProp)(a, f, B)})`), (0, i.reportMissingProp)(a, B), I.else());
      }
    }
    t.validatePropertyDeps = n;
    function s(a, g = a.schema) {
      const { gen: I, data: c, keyword: C, it: B } = a, Q = I.name("valid");
      for (const f in g)
        (0, e.alwaysValidSchema)(B, g[f]) || (I.if(
          (0, i.propertyInData)(I, c, f, B.opts.ownProperties),
          () => {
            const l = a.subschema({ keyword: C, schemaProp: f }, Q);
            a.mergeValidEvaluated(l, Q);
          },
          () => I.var(Q, !0)
          // TODO var
        ), a.ok(Q));
    }
    t.validateSchemaDeps = s, t.default = o;
  })(Qr)), Qr;
}
var Gi = {}, Na;
function Qm() {
  if (Na) return Gi;
  Na = 1, Object.defineProperty(Gi, "__esModule", { value: !0 });
  const t = oA(), A = aA(), i = {
    keyword: "propertyNames",
    type: "object",
    schemaType: ["object", "boolean"],
    error: {
      message: "property name must be valid",
      params: ({ params: o }) => (0, t._)`{propertyName: ${o.propertyName}}`
    },
    code(o) {
      const { gen: r, schema: n, data: s, it: a } = o;
      if ((0, A.alwaysValidSchema)(a, n))
        return;
      const g = r.name("valid");
      r.forIn("key", s, (I) => {
        o.setParams({ propertyName: I }), o.subschema({
          keyword: "propertyNames",
          data: I,
          dataTypes: ["string"],
          propertyName: I,
          compositeRule: !0
        }, g), r.if((0, t.not)(g), () => {
          o.error(!0), a.allErrors || r.break();
        });
      }), o.ok(g);
    }
  };
  return Gi.default = i, Gi;
}
var Fi = {}, Ma;
function ZI() {
  if (Ma) return Fi;
  Ma = 1, Object.defineProperty(Fi, "__esModule", { value: !0 });
  const t = _A(), A = oA(), e = zA(), i = aA(), r = {
    keyword: "additionalProperties",
    type: ["object"],
    schemaType: ["boolean", "object"],
    allowUndefined: !0,
    trackErrors: !0,
    error: {
      message: "must NOT have additional properties",
      params: ({ params: n }) => (0, A._)`{additionalProperty: ${n.additionalProperty}}`
    },
    code(n) {
      const { gen: s, schema: a, parentSchema: g, data: I, errsCount: c, it: C } = n;
      if (!c)
        throw new Error("ajv implementation error");
      const { allErrors: B, opts: Q } = C;
      if (C.props = !0, Q.removeAdditional !== "all" && (0, i.alwaysValidSchema)(C, a))
        return;
      const f = (0, t.allSchemaProperties)(g.properties), l = (0, t.allSchemaProperties)(g.patternProperties);
      u(), n.ok((0, A._)`${c} === ${e.default.errors}`);
      function u() {
        s.forIn("key", I, (w) => {
          !f.length && !l.length ? p(w) : s.if(d(w), () => p(w));
        });
      }
      function d(w) {
        let y;
        if (f.length > 8) {
          const m = (0, i.schemaRefOrVal)(C, g.properties, "properties");
          y = (0, t.isOwnProperty)(s, m, w);
        } else f.length ? y = (0, A.or)(...f.map((m) => (0, A._)`${w} === ${m}`)) : y = A.nil;
        return l.length && (y = (0, A.or)(y, ...l.map((m) => (0, A._)`${(0, t.usePattern)(n, m)}.test(${w})`))), (0, A.not)(y);
      }
      function h(w) {
        s.code((0, A._)`delete ${I}[${w}]`);
      }
      function p(w) {
        if (Q.removeAdditional === "all" || Q.removeAdditional && a === !1) {
          h(w);
          return;
        }
        if (a === !1) {
          n.setParams({ additionalProperty: w }), n.error(), B || s.break();
          return;
        }
        if (typeof a == "object" && !(0, i.alwaysValidSchema)(C, a)) {
          const y = s.name("valid");
          Q.removeAdditional === "failing" ? (E(w, y, !1), s.if((0, A.not)(y), () => {
            n.reset(), h(w);
          })) : (E(w, y), B || s.if((0, A.not)(y), () => s.break()));
        }
      }
      function E(w, y, m) {
        const k = {
          keyword: "additionalProperties",
          dataProp: w,
          dataPropType: i.Type.Str
        };
        m === !1 && Object.assign(k, {
          compositeRule: !0,
          createErrors: !1,
          allErrors: !1
        }), n.subschema(k, y);
      }
    }
  };
  return Fi.default = r, Fi;
}
var bi = {}, Ga;
function Em() {
  if (Ga) return bi;
  Ga = 1, Object.defineProperty(bi, "__esModule", { value: !0 });
  const t = zt(), A = _A(), e = aA(), i = ZI(), o = {
    keyword: "properties",
    type: "object",
    schemaType: "object",
    code(r) {
      const { gen: n, schema: s, parentSchema: a, data: g, it: I } = r;
      I.opts.removeAdditional === "all" && a.additionalProperties === void 0 && i.default.code(new t.KeywordCxt(I, i.default, "additionalProperties"));
      const c = (0, A.allSchemaProperties)(s);
      for (const l of c)
        I.definedProperties.add(l);
      I.opts.unevaluated && c.length && I.props !== !0 && (I.props = e.mergeEvaluated.props(n, (0, e.toHash)(c), I.props));
      const C = c.filter((l) => !(0, e.alwaysValidSchema)(I, s[l]));
      if (C.length === 0)
        return;
      const B = n.name("valid");
      for (const l of C)
        Q(l) ? f(l) : (n.if((0, A.propertyInData)(n, g, l, I.opts.ownProperties)), f(l), I.allErrors || n.else().var(B, !0), n.endIf()), r.it.definedProperties.add(l), r.ok(B);
      function Q(l) {
        return I.opts.useDefaults && !I.compositeRule && s[l].default !== void 0;
      }
      function f(l) {
        r.subschema({
          keyword: "properties",
          schemaProp: l,
          dataProp: l
        }, B);
      }
    }
  };
  return bi.default = o, bi;
}
var Ri = {}, Fa;
function lm() {
  if (Fa) return Ri;
  Fa = 1, Object.defineProperty(Ri, "__esModule", { value: !0 });
  const t = _A(), A = oA(), e = aA(), i = aA(), o = {
    keyword: "patternProperties",
    type: "object",
    schemaType: "object",
    code(r) {
      const { gen: n, schema: s, data: a, parentSchema: g, it: I } = r, { opts: c } = I, C = (0, t.allSchemaProperties)(s), B = C.filter((p) => (0, e.alwaysValidSchema)(I, s[p]));
      if (C.length === 0 || B.length === C.length && (!I.opts.unevaluated || I.props === !0))
        return;
      const Q = c.strictSchema && !c.allowMatchingProperties && g.properties, f = n.name("valid");
      I.props !== !0 && !(I.props instanceof A.Name) && (I.props = (0, i.evaluatedPropsToName)(n, I.props));
      const { props: l } = I;
      u();
      function u() {
        for (const p of C)
          Q && d(p), I.allErrors ? h(p) : (n.var(f, !0), h(p), n.if(f));
      }
      function d(p) {
        for (const E in Q)
          new RegExp(p).test(E) && (0, e.checkStrictMode)(I, `property ${E} matches pattern ${p} (use allowMatchingProperties)`);
      }
      function h(p) {
        n.forIn("key", a, (E) => {
          n.if((0, A._)`${(0, t.usePattern)(r, p)}.test(${E})`, () => {
            const w = B.includes(p);
            w || r.subschema({
              keyword: "patternProperties",
              schemaProp: p,
              dataProp: E,
              dataPropType: i.Type.Str
            }, f), I.opts.unevaluated && l !== !0 ? n.assign((0, A._)`${l}[${E}]`, !0) : !w && !I.allErrors && n.if((0, A.not)(f), () => n.break());
          });
        });
      }
    }
  };
  return Ri.default = o, Ri;
}
var Ki = {}, ba;
function dm() {
  if (ba) return Ki;
  ba = 1, Object.defineProperty(Ki, "__esModule", { value: !0 });
  const t = aA(), A = {
    keyword: "not",
    schemaType: ["object", "boolean"],
    trackErrors: !0,
    code(e) {
      const { gen: i, schema: o, it: r } = e;
      if ((0, t.alwaysValidSchema)(r, o)) {
        e.fail();
        return;
      }
      const n = i.name("valid");
      e.subschema({
        keyword: "not",
        compositeRule: !0,
        createErrors: !1,
        allErrors: !1
      }, n), e.failResult(n, () => e.reset(), () => e.error());
    },
    error: { message: "must NOT be valid" }
  };
  return Ki.default = A, Ki;
}
var vi = {}, Ra;
function um() {
  if (Ra) return vi;
  Ra = 1, Object.defineProperty(vi, "__esModule", { value: !0 });
  const A = {
    keyword: "anyOf",
    schemaType: "array",
    trackErrors: !0,
    code: _A().validateUnion,
    error: { message: "must match a schema in anyOf" }
  };
  return vi.default = A, vi;
}
var Yi = {}, Ka;
function hm() {
  if (Ka) return Yi;
  Ka = 1, Object.defineProperty(Yi, "__esModule", { value: !0 });
  const t = oA(), A = aA(), i = {
    keyword: "oneOf",
    schemaType: "array",
    trackErrors: !0,
    error: {
      message: "must match exactly one schema in oneOf",
      params: ({ params: o }) => (0, t._)`{passingSchemas: ${o.passing}}`
    },
    code(o) {
      const { gen: r, schema: n, parentSchema: s, it: a } = o;
      if (!Array.isArray(n))
        throw new Error("ajv implementation error");
      if (a.opts.discriminator && s.discriminator)
        return;
      const g = n, I = r.let("valid", !1), c = r.let("passing", null), C = r.name("_valid");
      o.setParams({ passing: c }), r.block(B), o.result(I, () => o.reset(), () => o.error(!0));
      function B() {
        g.forEach((Q, f) => {
          let l;
          (0, A.alwaysValidSchema)(a, Q) ? r.var(C, !0) : l = o.subschema({
            keyword: "oneOf",
            schemaProp: f,
            compositeRule: !0
          }, C), f > 0 && r.if((0, t._)`${C} && ${I}`).assign(I, !1).assign(c, (0, t._)`[${c}, ${f}]`).else(), r.if(C, () => {
            r.assign(I, !0), r.assign(c, f), l && o.mergeEvaluated(l, t.Name);
          });
        });
      }
    }
  };
  return Yi.default = i, Yi;
}
var Ui = {}, va;
function fm() {
  if (va) return Ui;
  va = 1, Object.defineProperty(Ui, "__esModule", { value: !0 });
  const t = aA(), A = {
    keyword: "allOf",
    schemaType: "array",
    code(e) {
      const { gen: i, schema: o, it: r } = e;
      if (!Array.isArray(o))
        throw new Error("ajv implementation error");
      const n = i.name("valid");
      o.forEach((s, a) => {
        if ((0, t.alwaysValidSchema)(r, s))
          return;
        const g = e.subschema({ keyword: "allOf", schemaProp: a }, n);
        e.ok(n), e.mergeEvaluated(g);
      });
    }
  };
  return Ui.default = A, Ui;
}
var Ji = {}, Ya;
function pm() {
  if (Ya) return Ji;
  Ya = 1, Object.defineProperty(Ji, "__esModule", { value: !0 });
  const t = oA(), A = aA(), i = {
    keyword: "if",
    schemaType: ["object", "boolean"],
    trackErrors: !0,
    error: {
      message: ({ params: r }) => (0, t.str)`must match "${r.ifClause}" schema`,
      params: ({ params: r }) => (0, t._)`{failingKeyword: ${r.ifClause}}`
    },
    code(r) {
      const { gen: n, parentSchema: s, it: a } = r;
      s.then === void 0 && s.else === void 0 && (0, A.checkStrictMode)(a, '"if" without "then" and "else" is ignored');
      const g = o(a, "then"), I = o(a, "else");
      if (!g && !I)
        return;
      const c = n.let("valid", !0), C = n.name("_valid");
      if (B(), r.reset(), g && I) {
        const f = n.let("ifClause");
        r.setParams({ ifClause: f }), n.if(C, Q("then", f), Q("else", f));
      } else g ? n.if(C, Q("then")) : n.if((0, t.not)(C), Q("else"));
      r.pass(c, () => r.error(!0));
      function B() {
        const f = r.subschema({
          keyword: "if",
          compositeRule: !0,
          createErrors: !1,
          allErrors: !1
        }, C);
        r.mergeEvaluated(f);
      }
      function Q(f, l) {
        return () => {
          const u = r.subschema({ keyword: f }, C);
          n.assign(c, C), r.mergeValidEvaluated(u, c), l ? n.assign(l, (0, t._)`${f}`) : r.setParams({ ifClause: f });
        };
      }
    }
  };
  function o(r, n) {
    const s = r.schema[n];
    return s !== void 0 && !(0, A.alwaysValidSchema)(r, s);
  }
  return Ji.default = i, Ji;
}
var Hi = {}, Ua;
function wm() {
  if (Ua) return Hi;
  Ua = 1, Object.defineProperty(Hi, "__esModule", { value: !0 });
  const t = aA(), A = {
    keyword: ["then", "else"],
    schemaType: ["object", "boolean"],
    code({ keyword: e, parentSchema: i, it: o }) {
      i.if === void 0 && (0, t.checkStrictMode)(o, `"${e}" without "if" is ignored`);
    }
  };
  return Hi.default = A, Hi;
}
var Ja;
function XI() {
  if (Ja) return Si;
  Ja = 1, Object.defineProperty(Si, "__esModule", { value: !0 });
  const t = zI(), A = cm(), e = _I(), i = Cm(), o = Bm(), r = Wn(), n = Qm(), s = ZI(), a = Em(), g = lm(), I = dm(), c = um(), C = hm(), B = fm(), Q = pm(), f = wm();
  function l(u = !1) {
    const d = [
      // any
      I.default,
      c.default,
      C.default,
      B.default,
      Q.default,
      f.default,
      // object
      n.default,
      s.default,
      r.default,
      a.default,
      g.default
    ];
    return u ? d.push(A.default, i.default) : d.push(t.default, e.default), d.push(o.default), d;
  }
  return Si.default = l, Si;
}
var qi = {}, je = {}, Ha;
function Ac() {
  if (Ha) return je;
  Ha = 1, Object.defineProperty(je, "__esModule", { value: !0 }), je.dynamicAnchor = void 0;
  const t = oA(), A = zA(), e = vo(), i = Vn(), o = {
    keyword: "$dynamicAnchor",
    schemaType: "string",
    code: (s) => r(s, s.schema)
  };
  function r(s, a) {
    const { gen: g, it: I } = s;
    I.schemaEnv.root.dynamicAnchors[a] = !0;
    const c = (0, t._)`${A.default.dynamicAnchors}${(0, t.getProperty)(a)}`, C = I.errSchemaPath === "#" ? I.validateName : n(s);
    g.if((0, t._)`!${c}`, () => g.assign(c, C));
  }
  je.dynamicAnchor = r;
  function n(s) {
    const { schemaEnv: a, schema: g, self: I } = s.it, { root: c, baseId: C, localRefs: B, meta: Q } = a.root, { schemaId: f } = I.opts, l = new e.SchemaEnv({ schema: g, schemaId: f, root: c, baseId: C, localRefs: B, meta: Q });
    return e.compileSchema.call(I, l), (0, i.getValidate)(s, l);
  }
  return je.default = o, je;
}
var Ve = {}, qa;
function ec() {
  if (qa) return Ve;
  qa = 1, Object.defineProperty(Ve, "__esModule", { value: !0 }), Ve.dynamicRef = void 0;
  const t = oA(), A = zA(), e = Vn(), i = {
    keyword: "$dynamicRef",
    schemaType: "string",
    code: (r) => o(r, r.schema)
  };
  function o(r, n) {
    const { gen: s, keyword: a, it: g } = r;
    if (n[0] !== "#")
      throw new Error(`"${a}" only supports hash fragment reference`);
    const I = n.slice(1);
    if (g.allErrors)
      c();
    else {
      const B = s.let("valid", !1);
      c(B), r.ok(B);
    }
    function c(B) {
      if (g.schemaEnv.root.dynamicAnchors[I]) {
        const Q = s.let("_v", (0, t._)`${A.default.dynamicAnchors}${(0, t.getProperty)(I)}`);
        s.if(Q, C(Q, B), C(g.validateName, B));
      } else
        C(g.validateName, B)();
    }
    function C(B, Q) {
      return Q ? () => s.block(() => {
        (0, e.callRef)(r, B), s.let(Q, !0);
      }) : () => (0, e.callRef)(r, B);
    }
  }
  return Ve.dynamicRef = o, Ve.default = i, Ve;
}
var xi = {}, xa;
function ym() {
  if (xa) return xi;
  xa = 1, Object.defineProperty(xi, "__esModule", { value: !0 });
  const t = Ac(), A = aA(), e = {
    keyword: "$recursiveAnchor",
    schemaType: "boolean",
    code(i) {
      i.schema ? (0, t.dynamicAnchor)(i, "") : (0, A.checkStrictMode)(i.it, "$recursiveAnchor: false is ignored");
    }
  };
  return xi.default = e, xi;
}
var Li = {}, La;
function Dm() {
  if (La) return Li;
  La = 1, Object.defineProperty(Li, "__esModule", { value: !0 });
  const t = ec(), A = {
    keyword: "$recursiveRef",
    schemaType: "string",
    code: (e) => (0, t.dynamicRef)(e, e.schema)
  };
  return Li.default = A, Li;
}
var Ta;
function mm() {
  if (Ta) return qi;
  Ta = 1, Object.defineProperty(qi, "__esModule", { value: !0 });
  const t = Ac(), A = ec(), e = ym(), i = Dm(), o = [t.default, A.default, e.default, i.default];
  return qi.default = o, qi;
}
var Ti = {}, Oi = {}, Oa;
function Sm() {
  if (Oa) return Oi;
  Oa = 1, Object.defineProperty(Oi, "__esModule", { value: !0 });
  const t = Wn(), A = {
    keyword: "dependentRequired",
    type: "object",
    schemaType: "object",
    error: t.error,
    code: (e) => (0, t.validatePropertyDeps)(e)
  };
  return Oi.default = A, Oi;
}
var Pi = {}, Pa;
function km() {
  if (Pa) return Pi;
  Pa = 1, Object.defineProperty(Pi, "__esModule", { value: !0 });
  const t = Wn(), A = {
    keyword: "dependentSchemas",
    type: "object",
    schemaType: "object",
    code: (e) => (0, t.validateSchemaDeps)(e)
  };
  return Pi.default = A, Pi;
}
var ji = {}, ja;
function Nm() {
  if (ja) return ji;
  ja = 1, Object.defineProperty(ji, "__esModule", { value: !0 });
  const t = aA(), A = {
    keyword: ["maxContains", "minContains"],
    type: "array",
    schemaType: "number",
    code({ keyword: e, parentSchema: i, it: o }) {
      i.contains === void 0 && (0, t.checkStrictMode)(o, `"${e}" without "contains" is ignored`);
    }
  };
  return ji.default = A, ji;
}
var Va;
function Mm() {
  if (Va) return Ti;
  Va = 1, Object.defineProperty(Ti, "__esModule", { value: !0 });
  const t = Sm(), A = km(), e = Nm(), i = [t.default, A.default, e.default];
  return Ti.default = i, Ti;
}
var Vi = {}, $i = {}, $a;
function Gm() {
  if ($a) return $i;
  $a = 1, Object.defineProperty($i, "__esModule", { value: !0 });
  const t = oA(), A = aA(), e = zA(), o = {
    keyword: "unevaluatedProperties",
    type: "object",
    schemaType: ["boolean", "object"],
    trackErrors: !0,
    error: {
      message: "must NOT have unevaluated properties",
      params: ({ params: r }) => (0, t._)`{unevaluatedProperty: ${r.unevaluatedProperty}}`
    },
    code(r) {
      const { gen: n, schema: s, data: a, errsCount: g, it: I } = r;
      if (!g)
        throw new Error("ajv implementation error");
      const { allErrors: c, props: C } = I;
      C instanceof t.Name ? n.if((0, t._)`${C} !== true`, () => n.forIn("key", a, (l) => n.if(Q(C, l), () => B(l)))) : C !== !0 && n.forIn("key", a, (l) => C === void 0 ? B(l) : n.if(f(C, l), () => B(l))), I.props = !0, r.ok((0, t._)`${g} === ${e.default.errors}`);
      function B(l) {
        if (s === !1) {
          r.setParams({ unevaluatedProperty: l }), r.error(), c || n.break();
          return;
        }
        if (!(0, A.alwaysValidSchema)(I, s)) {
          const u = n.name("valid");
          r.subschema({
            keyword: "unevaluatedProperties",
            dataProp: l,
            dataPropType: A.Type.Str
          }, u), c || n.if((0, t.not)(u), () => n.break());
        }
      }
      function Q(l, u) {
        return (0, t._)`!${l} || !${l}[${u}]`;
      }
      function f(l, u) {
        const d = [];
        for (const h in l)
          l[h] === !0 && d.push((0, t._)`${u} !== ${h}`);
        return (0, t.and)(...d);
      }
    }
  };
  return $i.default = o, $i;
}
var Wi = {}, Wa;
function Fm() {
  if (Wa) return Wi;
  Wa = 1, Object.defineProperty(Wi, "__esModule", { value: !0 });
  const t = oA(), A = aA(), i = {
    keyword: "unevaluatedItems",
    type: "array",
    schemaType: ["boolean", "object"],
    error: {
      message: ({ params: { len: o } }) => (0, t.str)`must NOT have more than ${o} items`,
      params: ({ params: { len: o } }) => (0, t._)`{limit: ${o}}`
    },
    code(o) {
      const { gen: r, schema: n, data: s, it: a } = o, g = a.items || 0;
      if (g === !0)
        return;
      const I = r.const("len", (0, t._)`${s}.length`);
      if (n === !1)
        o.setParams({ len: g }), o.fail((0, t._)`${I} > ${g}`);
      else if (typeof n == "object" && !(0, A.alwaysValidSchema)(a, n)) {
        const C = r.var("valid", (0, t._)`${I} <= ${g}`);
        r.if((0, t.not)(C), () => c(C, g)), o.ok(C);
      }
      a.items = !0;
      function c(C, B) {
        r.forRange("i", B, I, (Q) => {
          o.subschema({ keyword: "unevaluatedItems", dataProp: Q, dataPropType: A.Type.Num }, C), a.allErrors || r.if((0, t.not)(C), () => r.break());
        });
      }
    }
  };
  return Wi.default = i, Wi;
}
var za;
function bm() {
  if (za) return Vi;
  za = 1, Object.defineProperty(Vi, "__esModule", { value: !0 });
  const t = Gm(), A = Fm(), e = [t.default, A.default];
  return Vi.default = e, Vi;
}
var zi = {}, _i = {}, _a;
function Rm() {
  if (_a) return _i;
  _a = 1, Object.defineProperty(_i, "__esModule", { value: !0 });
  const t = oA(), e = {
    keyword: "format",
    type: ["number", "string"],
    schemaType: "string",
    $data: !0,
    error: {
      message: ({ schemaCode: i }) => (0, t.str)`must match format "${i}"`,
      params: ({ schemaCode: i }) => (0, t._)`{format: ${i}}`
    },
    code(i, o) {
      const { gen: r, data: n, $data: s, schema: a, schemaCode: g, it: I } = i, { opts: c, errSchemaPath: C, schemaEnv: B, self: Q } = I;
      if (!c.validateFormats)
        return;
      s ? f() : l();
      function f() {
        const u = r.scopeValue("formats", {
          ref: Q.formats,
          code: c.code.formats
        }), d = r.const("fDef", (0, t._)`${u}[${g}]`), h = r.let("fType"), p = r.let("format");
        r.if((0, t._)`typeof ${d} == "object" && !(${d} instanceof RegExp)`, () => r.assign(h, (0, t._)`${d}.type || "string"`).assign(p, (0, t._)`${d}.validate`), () => r.assign(h, (0, t._)`"string"`).assign(p, d)), i.fail$data((0, t.or)(E(), w()));
        function E() {
          return c.strictSchema === !1 ? t.nil : (0, t._)`${g} && !${p}`;
        }
        function w() {
          const y = B.$async ? (0, t._)`(${d}.async ? await ${p}(${n}) : ${p}(${n}))` : (0, t._)`${p}(${n})`, m = (0, t._)`(typeof ${p} == "function" ? ${y} : ${p}.test(${n}))`;
          return (0, t._)`${p} && ${p} !== true && ${h} === ${o} && !${m}`;
        }
      }
      function l() {
        const u = Q.formats[a];
        if (!u) {
          E();
          return;
        }
        if (u === !0)
          return;
        const [d, h, p] = w(u);
        d === o && i.pass(y());
        function E() {
          if (c.strictSchema === !1) {
            Q.logger.warn(m());
            return;
          }
          throw new Error(m());
          function m() {
            return `unknown format "${a}" ignored in schema at path "${C}"`;
          }
        }
        function w(m) {
          const k = m instanceof RegExp ? (0, t.regexpCode)(m) : c.code.formats ? (0, t._)`${c.code.formats}${(0, t.getProperty)(a)}` : void 0, b = r.scopeValue("formats", { key: a, ref: m, code: k });
          return typeof m == "object" && !(m instanceof RegExp) ? [m.type || "string", m.validate, (0, t._)`${b}.validate`] : ["string", m, b];
        }
        function y() {
          if (typeof u == "object" && !(u instanceof RegExp) && u.async) {
            if (!B.$async)
              throw new Error("async format in sync schema");
            return (0, t._)`await ${p}(${n})`;
          }
          return typeof h == "function" ? (0, t._)`${p}(${n})` : (0, t._)`${p}.test(${n})`;
        }
      }
    }
  };
  return _i.default = e, _i;
}
var Za;
function tc() {
  if (Za) return zi;
  Za = 1, Object.defineProperty(zi, "__esModule", { value: !0 });
  const A = [Rm().default];
  return zi.default = A, zi;
}
var pe = {}, Xa;
function ic() {
  return Xa || (Xa = 1, Object.defineProperty(pe, "__esModule", { value: !0 }), pe.contentVocabulary = pe.metadataVocabulary = void 0, pe.metadataVocabulary = [
    "title",
    "description",
    "default",
    "deprecated",
    "readOnly",
    "writeOnly",
    "examples"
  ], pe.contentVocabulary = [
    "contentMediaType",
    "contentEncoding",
    "contentSchema"
  ]), pe;
}
var Ag;
function Km() {
  if (Ag) return Ii;
  Ag = 1, Object.defineProperty(Ii, "__esModule", { value: !0 });
  const t = $I(), A = WI(), e = XI(), i = mm(), o = Mm(), r = bm(), n = tc(), s = ic(), a = [
    i.default,
    t.default,
    A.default,
    (0, e.default)(!0),
    n.default,
    s.metadataVocabulary,
    s.contentVocabulary,
    o.default,
    r.default
  ];
  return Ii.default = a, Ii;
}
var Zi = {}, ft = {}, eg;
function vm() {
  if (eg) return ft;
  eg = 1, Object.defineProperty(ft, "__esModule", { value: !0 }), ft.DiscrError = void 0;
  var t;
  return (function(A) {
    A.Tag = "tag", A.Mapping = "mapping";
  })(t || (ft.DiscrError = t = {})), ft;
}
var tg;
function oc() {
  if (tg) return Zi;
  tg = 1, Object.defineProperty(Zi, "__esModule", { value: !0 });
  const t = oA(), A = vm(), e = vo(), i = _t(), o = aA(), n = {
    keyword: "discriminator",
    type: "object",
    schemaType: "object",
    error: {
      message: ({ params: { discrError: s, tagName: a } }) => s === A.DiscrError.Tag ? `tag "${a}" must be string` : `value of tag "${a}" must be in oneOf`,
      params: ({ params: { discrError: s, tag: a, tagName: g } }) => (0, t._)`{error: ${s}, tag: ${g}, tagValue: ${a}}`
    },
    code(s) {
      const { gen: a, data: g, schema: I, parentSchema: c, it: C } = s, { oneOf: B } = c;
      if (!C.opts.discriminator)
        throw new Error("discriminator: requires discriminator option");
      const Q = I.propertyName;
      if (typeof Q != "string")
        throw new Error("discriminator: requires propertyName");
      if (I.mapping)
        throw new Error("discriminator: mapping is not supported");
      if (!B)
        throw new Error("discriminator: requires oneOf keyword");
      const f = a.let("valid", !1), l = a.const("tag", (0, t._)`${g}${(0, t.getProperty)(Q)}`);
      a.if((0, t._)`typeof ${l} == "string"`, () => u(), () => s.error(!1, { discrError: A.DiscrError.Tag, tag: l, tagName: Q })), s.ok(f);
      function u() {
        const p = h();
        a.if(!1);
        for (const E in p)
          a.elseIf((0, t._)`${l} === ${E}`), a.assign(f, d(p[E]));
        a.else(), s.error(!1, { discrError: A.DiscrError.Mapping, tag: l, tagName: Q }), a.endIf();
      }
      function d(p) {
        const E = a.name("valid"), w = s.subschema({ keyword: "oneOf", schemaProp: p }, E);
        return s.mergeEvaluated(w, t.Name), E;
      }
      function h() {
        var p;
        const E = {}, w = m(c);
        let y = !0;
        for (let q = 0; q < B.length; q++) {
          let P = B[q];
          if (P?.$ref && !(0, o.schemaHasRulesButRef)(P, C.self.RULES)) {
            const W = P.$ref;
            if (P = e.resolveRef.call(C.self, C.schemaEnv.root, C.baseId, W), P instanceof e.SchemaEnv && (P = P.schema), P === void 0)
              throw new i.default(C.opts.uriResolver, C.baseId, W);
          }
          const J = (p = P?.properties) === null || p === void 0 ? void 0 : p[Q];
          if (typeof J != "object")
            throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${Q}"`);
          y = y && (w || m(P)), k(J, q);
        }
        if (!y)
          throw new Error(`discriminator: "${Q}" must be required`);
        return E;
        function m({ required: q }) {
          return Array.isArray(q) && q.includes(Q);
        }
        function k(q, P) {
          if (q.const)
            b(q.const, P);
          else if (q.enum)
            for (const J of q.enum)
              b(J, P);
          else
            throw new Error(`discriminator: "properties/${Q}" must have "const" or "enum"`);
        }
        function b(q, P) {
          if (typeof q != "string" || q in E)
            throw new Error(`discriminator: "${Q}" values must be unique strings`);
          E[q] = P;
        }
      }
    }
  };
  return Zi.default = n, Zi;
}
var Xi = {};
const Ym = "https://json-schema.org/draft/2020-12/schema", Um = "https://json-schema.org/draft/2020-12/schema", Jm = { "https://json-schema.org/draft/2020-12/vocab/core": !0, "https://json-schema.org/draft/2020-12/vocab/applicator": !0, "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0, "https://json-schema.org/draft/2020-12/vocab/validation": !0, "https://json-schema.org/draft/2020-12/vocab/meta-data": !0, "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0, "https://json-schema.org/draft/2020-12/vocab/content": !0 }, Hm = "meta", qm = "Core and Validation specifications meta-schema", xm = [{ $ref: "meta/core" }, { $ref: "meta/applicator" }, { $ref: "meta/unevaluated" }, { $ref: "meta/validation" }, { $ref: "meta/meta-data" }, { $ref: "meta/format-annotation" }, { $ref: "meta/content" }], Lm = ["object", "boolean"], Tm = "This meta-schema also defines keywords that have appeared in previous drafts in order to prevent incompatible extensions as they remain in common use.", Om = { definitions: { $comment: '"definitions" has been replaced by "$defs".', type: "object", additionalProperties: { $dynamicRef: "#meta" }, deprecated: !0, default: {} }, dependencies: { $comment: '"dependencies" has been split and replaced by "dependentSchemas" and "dependentRequired" in order to serve their differing semantics.', type: "object", additionalProperties: { anyOf: [{ $dynamicRef: "#meta" }, { $ref: "meta/validation#/$defs/stringArray" }] }, deprecated: !0, default: {} }, $recursiveAnchor: { $comment: '"$recursiveAnchor" has been replaced by "$dynamicAnchor".', $ref: "meta/core#/$defs/anchorString", deprecated: !0 }, $recursiveRef: { $comment: '"$recursiveRef" has been replaced by "$dynamicRef".', $ref: "meta/core#/$defs/uriReferenceString", deprecated: !0 } }, Pm = {
  $schema: Ym,
  $id: Um,
  $vocabulary: Jm,
  $dynamicAnchor: Hm,
  title: qm,
  allOf: xm,
  type: Lm,
  $comment: Tm,
  properties: Om
}, jm = "https://json-schema.org/draft/2020-12/schema", Vm = "https://json-schema.org/draft/2020-12/meta/applicator", $m = { "https://json-schema.org/draft/2020-12/vocab/applicator": !0 }, Wm = "meta", zm = "Applicator vocabulary meta-schema", _m = ["object", "boolean"], Zm = { prefixItems: { $ref: "#/$defs/schemaArray" }, items: { $dynamicRef: "#meta" }, contains: { $dynamicRef: "#meta" }, additionalProperties: { $dynamicRef: "#meta" }, properties: { type: "object", additionalProperties: { $dynamicRef: "#meta" }, default: {} }, patternProperties: { type: "object", additionalProperties: { $dynamicRef: "#meta" }, propertyNames: { format: "regex" }, default: {} }, dependentSchemas: { type: "object", additionalProperties: { $dynamicRef: "#meta" }, default: {} }, propertyNames: { $dynamicRef: "#meta" }, if: { $dynamicRef: "#meta" }, then: { $dynamicRef: "#meta" }, else: { $dynamicRef: "#meta" }, allOf: { $ref: "#/$defs/schemaArray" }, anyOf: { $ref: "#/$defs/schemaArray" }, oneOf: { $ref: "#/$defs/schemaArray" }, not: { $dynamicRef: "#meta" } }, Xm = { schemaArray: { type: "array", minItems: 1, items: { $dynamicRef: "#meta" } } }, AS = {
  $schema: jm,
  $id: Vm,
  $vocabulary: $m,
  $dynamicAnchor: Wm,
  title: zm,
  type: _m,
  properties: Zm,
  $defs: Xm
}, eS = "https://json-schema.org/draft/2020-12/schema", tS = "https://json-schema.org/draft/2020-12/meta/unevaluated", iS = { "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0 }, oS = "meta", rS = "Unevaluated applicator vocabulary meta-schema", nS = ["object", "boolean"], sS = { unevaluatedItems: { $dynamicRef: "#meta" }, unevaluatedProperties: { $dynamicRef: "#meta" } }, aS = {
  $schema: eS,
  $id: tS,
  $vocabulary: iS,
  $dynamicAnchor: oS,
  title: rS,
  type: nS,
  properties: sS
}, gS = "https://json-schema.org/draft/2020-12/schema", IS = "https://json-schema.org/draft/2020-12/meta/content", cS = { "https://json-schema.org/draft/2020-12/vocab/content": !0 }, CS = "meta", BS = "Content vocabulary meta-schema", QS = ["object", "boolean"], ES = { contentEncoding: { type: "string" }, contentMediaType: { type: "string" }, contentSchema: { $dynamicRef: "#meta" } }, lS = {
  $schema: gS,
  $id: IS,
  $vocabulary: cS,
  $dynamicAnchor: CS,
  title: BS,
  type: QS,
  properties: ES
}, dS = "https://json-schema.org/draft/2020-12/schema", uS = "https://json-schema.org/draft/2020-12/meta/core", hS = { "https://json-schema.org/draft/2020-12/vocab/core": !0 }, fS = "meta", pS = "Core vocabulary meta-schema", wS = ["object", "boolean"], yS = { $id: { $ref: "#/$defs/uriReferenceString", $comment: "Non-empty fragments not allowed.", pattern: "^[^#]*#?$" }, $schema: { $ref: "#/$defs/uriString" }, $ref: { $ref: "#/$defs/uriReferenceString" }, $anchor: { $ref: "#/$defs/anchorString" }, $dynamicRef: { $ref: "#/$defs/uriReferenceString" }, $dynamicAnchor: { $ref: "#/$defs/anchorString" }, $vocabulary: { type: "object", propertyNames: { $ref: "#/$defs/uriString" }, additionalProperties: { type: "boolean" } }, $comment: { type: "string" }, $defs: { type: "object", additionalProperties: { $dynamicRef: "#meta" } } }, DS = { anchorString: { type: "string", pattern: "^[A-Za-z_][-A-Za-z0-9._]*$" }, uriString: { type: "string", format: "uri" }, uriReferenceString: { type: "string", format: "uri-reference" } }, mS = {
  $schema: dS,
  $id: uS,
  $vocabulary: hS,
  $dynamicAnchor: fS,
  title: pS,
  type: wS,
  properties: yS,
  $defs: DS
}, SS = "https://json-schema.org/draft/2020-12/schema", kS = "https://json-schema.org/draft/2020-12/meta/format-annotation", NS = { "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0 }, MS = "meta", GS = "Format vocabulary meta-schema for annotation results", FS = ["object", "boolean"], bS = { format: { type: "string" } }, RS = {
  $schema: SS,
  $id: kS,
  $vocabulary: NS,
  $dynamicAnchor: MS,
  title: GS,
  type: FS,
  properties: bS
}, KS = "https://json-schema.org/draft/2020-12/schema", vS = "https://json-schema.org/draft/2020-12/meta/meta-data", YS = { "https://json-schema.org/draft/2020-12/vocab/meta-data": !0 }, US = "meta", JS = "Meta-data vocabulary meta-schema", HS = ["object", "boolean"], qS = { title: { type: "string" }, description: { type: "string" }, default: !0, deprecated: { type: "boolean", default: !1 }, readOnly: { type: "boolean", default: !1 }, writeOnly: { type: "boolean", default: !1 }, examples: { type: "array", items: !0 } }, xS = {
  $schema: KS,
  $id: vS,
  $vocabulary: YS,
  $dynamicAnchor: US,
  title: JS,
  type: HS,
  properties: qS
}, LS = "https://json-schema.org/draft/2020-12/schema", TS = "https://json-schema.org/draft/2020-12/meta/validation", OS = { "https://json-schema.org/draft/2020-12/vocab/validation": !0 }, PS = "meta", jS = "Validation vocabulary meta-schema", VS = ["object", "boolean"], $S = { type: { anyOf: [{ $ref: "#/$defs/simpleTypes" }, { type: "array", items: { $ref: "#/$defs/simpleTypes" }, minItems: 1, uniqueItems: !0 }] }, const: !0, enum: { type: "array", items: !0 }, multipleOf: { type: "number", exclusiveMinimum: 0 }, maximum: { type: "number" }, exclusiveMaximum: { type: "number" }, minimum: { type: "number" }, exclusiveMinimum: { type: "number" }, maxLength: { $ref: "#/$defs/nonNegativeInteger" }, minLength: { $ref: "#/$defs/nonNegativeIntegerDefault0" }, pattern: { type: "string", format: "regex" }, maxItems: { $ref: "#/$defs/nonNegativeInteger" }, minItems: { $ref: "#/$defs/nonNegativeIntegerDefault0" }, uniqueItems: { type: "boolean", default: !1 }, maxContains: { $ref: "#/$defs/nonNegativeInteger" }, minContains: { $ref: "#/$defs/nonNegativeInteger", default: 1 }, maxProperties: { $ref: "#/$defs/nonNegativeInteger" }, minProperties: { $ref: "#/$defs/nonNegativeIntegerDefault0" }, required: { $ref: "#/$defs/stringArray" }, dependentRequired: { type: "object", additionalProperties: { $ref: "#/$defs/stringArray" } } }, WS = { nonNegativeInteger: { type: "integer", minimum: 0 }, nonNegativeIntegerDefault0: { $ref: "#/$defs/nonNegativeInteger", default: 0 }, simpleTypes: { enum: ["array", "boolean", "integer", "null", "number", "object", "string"] }, stringArray: { type: "array", items: { type: "string" }, uniqueItems: !0, default: [] } }, zS = {
  $schema: LS,
  $id: TS,
  $vocabulary: OS,
  $dynamicAnchor: PS,
  title: jS,
  type: VS,
  properties: $S,
  $defs: WS
};
var ig;
function _S() {
  if (ig) return Xi;
  ig = 1, Object.defineProperty(Xi, "__esModule", { value: !0 });
  const t = Pm, A = AS, e = aS, i = lS, o = mS, r = RS, n = xS, s = zS, a = ["/properties"];
  function g(I) {
    return [
      t,
      A,
      e,
      i,
      o,
      c(this, r),
      n,
      c(this, s)
    ].forEach((C) => this.addMetaSchema(C, void 0, !1)), this;
    function c(C, B) {
      return I ? C.$dataMetaSchema(B, a) : B;
    }
  }
  return Xi.default = g, Xi;
}
var og;
function ZS() {
  return og || (og = 1, (function(t, A) {
    Object.defineProperty(A, "__esModule", { value: !0 }), A.MissingRefError = A.ValidationError = A.CodeGen = A.Name = A.nil = A.stringify = A.str = A._ = A.KeywordCxt = A.Ajv2020 = void 0;
    const e = VI(), i = Km(), o = oc(), r = _S(), n = "https://json-schema.org/draft/2020-12/schema";
    class s extends e.default {
      constructor(B = {}) {
        super({
          ...B,
          dynamicRef: !0,
          next: !0,
          unevaluated: !0
        });
      }
      _addVocabularies() {
        super._addVocabularies(), i.default.forEach((B) => this.addVocabulary(B)), this.opts.discriminator && this.addKeyword(o.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        const { $data: B, meta: Q } = this.opts;
        Q && (r.default.call(this, B), this.refs["http://json-schema.org/schema"] = n);
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(n) ? n : void 0);
      }
    }
    A.Ajv2020 = s, t.exports = A = s, t.exports.Ajv2020 = s, Object.defineProperty(A, "__esModule", { value: !0 }), A.default = s;
    var a = zt();
    Object.defineProperty(A, "KeywordCxt", { enumerable: !0, get: function() {
      return a.KeywordCxt;
    } });
    var g = oA();
    Object.defineProperty(A, "_", { enumerable: !0, get: function() {
      return g._;
    } }), Object.defineProperty(A, "str", { enumerable: !0, get: function() {
      return g.str;
    } }), Object.defineProperty(A, "stringify", { enumerable: !0, get: function() {
      return g.stringify;
    } }), Object.defineProperty(A, "nil", { enumerable: !0, get: function() {
      return g.nil;
    } }), Object.defineProperty(A, "Name", { enumerable: !0, get: function() {
      return g.Name;
    } }), Object.defineProperty(A, "CodeGen", { enumerable: !0, get: function() {
      return g.CodeGen;
    } });
    var I = Ko();
    Object.defineProperty(A, "ValidationError", { enumerable: !0, get: function() {
      return I.default;
    } });
    var c = _t();
    Object.defineProperty(A, "MissingRefError", { enumerable: !0, get: function() {
      return c.default;
    } });
  })(ri, ri.exports)), ri.exports;
}
var rc = ZS();
const XS = /* @__PURE__ */ LI(rc), A0 = /* @__PURE__ */ ac({
  __proto__: null,
  default: XS
}, [rc]);
var Ao = { exports: {} }, eo = {}, rg;
function e0() {
  if (rg) return eo;
  rg = 1, Object.defineProperty(eo, "__esModule", { value: !0 });
  const t = $I(), A = WI(), e = XI(), i = tc(), o = ic(), r = [
    t.default,
    A.default,
    (0, e.default)(),
    i.default,
    o.metadataVocabulary,
    o.contentVocabulary
  ];
  return eo.default = r, eo;
}
const t0 = "http://json-schema.org/draft-07/schema#", i0 = "http://json-schema.org/draft-07/schema#", o0 = "Core schema meta-schema", r0 = { schemaArray: { type: "array", minItems: 1, items: { $ref: "#" } }, nonNegativeInteger: { type: "integer", minimum: 0 }, nonNegativeIntegerDefault0: { allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }] }, simpleTypes: { enum: ["array", "boolean", "integer", "null", "number", "object", "string"] }, stringArray: { type: "array", items: { type: "string" }, uniqueItems: !0, default: [] } }, n0 = ["object", "boolean"], s0 = { $id: { type: "string", format: "uri-reference" }, $schema: { type: "string", format: "uri" }, $ref: { type: "string", format: "uri-reference" }, $comment: { type: "string" }, title: { type: "string" }, description: { type: "string" }, default: !0, readOnly: { type: "boolean", default: !1 }, examples: { type: "array", items: !0 }, multipleOf: { type: "number", exclusiveMinimum: 0 }, maximum: { type: "number" }, exclusiveMaximum: { type: "number" }, minimum: { type: "number" }, exclusiveMinimum: { type: "number" }, maxLength: { $ref: "#/definitions/nonNegativeInteger" }, minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, pattern: { type: "string", format: "regex" }, additionalItems: { $ref: "#" }, items: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }], default: !0 }, maxItems: { $ref: "#/definitions/nonNegativeInteger" }, minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, uniqueItems: { type: "boolean", default: !1 }, contains: { $ref: "#" }, maxProperties: { $ref: "#/definitions/nonNegativeInteger" }, minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, required: { $ref: "#/definitions/stringArray" }, additionalProperties: { $ref: "#" }, definitions: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, properties: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, patternProperties: { type: "object", additionalProperties: { $ref: "#" }, propertyNames: { format: "regex" }, default: {} }, dependencies: { type: "object", additionalProperties: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }] } }, propertyNames: { $ref: "#" }, const: !0, enum: { type: "array", items: !0, minItems: 1, uniqueItems: !0 }, type: { anyOf: [{ $ref: "#/definitions/simpleTypes" }, { type: "array", items: { $ref: "#/definitions/simpleTypes" }, minItems: 1, uniqueItems: !0 }] }, format: { type: "string" }, contentMediaType: { type: "string" }, contentEncoding: { type: "string" }, if: { $ref: "#" }, then: { $ref: "#" }, else: { $ref: "#" }, allOf: { $ref: "#/definitions/schemaArray" }, anyOf: { $ref: "#/definitions/schemaArray" }, oneOf: { $ref: "#/definitions/schemaArray" }, not: { $ref: "#" } }, a0 = {
  $schema: t0,
  $id: i0,
  title: o0,
  definitions: r0,
  type: n0,
  properties: s0,
  default: !0
};
var ng;
function g0() {
  return ng || (ng = 1, (function(t, A) {
    Object.defineProperty(A, "__esModule", { value: !0 }), A.MissingRefError = A.ValidationError = A.CodeGen = A.Name = A.nil = A.stringify = A.str = A._ = A.KeywordCxt = A.Ajv = void 0;
    const e = VI(), i = e0(), o = oc(), r = a0, n = ["/properties"], s = "http://json-schema.org/draft-07/schema";
    class a extends e.default {
      _addVocabularies() {
        super._addVocabularies(), i.default.forEach((Q) => this.addVocabulary(Q)), this.opts.discriminator && this.addKeyword(o.default);
      }
      _addDefaultMetaSchema() {
        if (super._addDefaultMetaSchema(), !this.opts.meta)
          return;
        const Q = this.opts.$data ? this.$dataMetaSchema(r, n) : r;
        this.addMetaSchema(Q, s, !1), this.refs["http://json-schema.org/schema"] = s;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(s) ? s : void 0);
      }
    }
    A.Ajv = a, t.exports = A = a, t.exports.Ajv = a, Object.defineProperty(A, "__esModule", { value: !0 }), A.default = a;
    var g = zt();
    Object.defineProperty(A, "KeywordCxt", { enumerable: !0, get: function() {
      return g.KeywordCxt;
    } });
    var I = oA();
    Object.defineProperty(A, "_", { enumerable: !0, get: function() {
      return I._;
    } }), Object.defineProperty(A, "str", { enumerable: !0, get: function() {
      return I.str;
    } }), Object.defineProperty(A, "stringify", { enumerable: !0, get: function() {
      return I.stringify;
    } }), Object.defineProperty(A, "nil", { enumerable: !0, get: function() {
      return I.nil;
    } }), Object.defineProperty(A, "Name", { enumerable: !0, get: function() {
      return I.Name;
    } }), Object.defineProperty(A, "CodeGen", { enumerable: !0, get: function() {
      return I.CodeGen;
    } });
    var c = Ko();
    Object.defineProperty(A, "ValidationError", { enumerable: !0, get: function() {
      return c.default;
    } });
    var C = _t();
    Object.defineProperty(A, "MissingRefError", { enumerable: !0, get: function() {
      return C.default;
    } });
  })(Ao, Ao.exports)), Ao.exports;
}
var I0 = g0();
const c0 = /* @__PURE__ */ LI(I0), C0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: c0
}, Symbol.toStringTag, { value: "Module" })), B0 = {}, sg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: B0
}, Symbol.toStringTag, { value: "Module" })), nc = {
  $schema: "@maia/schema/style",
  $id: "@maia/style/brand",
  tokens: {
    colors: {
      marineBlue: "#001F33",
      marineBlueMuted: "#2D4A5C",
      marineBlueLight: "#5E7A8C",
      paradiseWater: "#00BDD6",
      lushGreen: "#4E9A58",
      terracotta: "#C27B66",
      sunYellow: "#E6B94D",
      softClay: "#E8E1D9",
      tintedWhite: "#F0EDE6",
      background: "transparent",
      foreground: "#001F33",
      primary: "#00BDD6",
      secondary: "#2D4A5C",
      border: "rgba(255, 255, 255, 0.1)",
      surface: "rgba(255, 255, 255, 0.3)",
      glass: "rgba(255, 255, 255, 0.0005)",
      glassStrong: "rgba(255, 255, 255, 0.15)",
      error: "#DC3545",
      errorBg: "rgba(220, 53, 69, 0.1)",
      errorBorder: "rgba(220, 53, 69, 0.2)",
      text: {
        marine: "#D1E8F7",
        water: "#004D59",
        green: "#F0F9F1",
        terracotta: "#FDF2EF",
        yellow: "#4D3810"
      }
    },
    spacing: {
      xs: "0.5rem",
      sm: "0.75rem",
      md: "1rem",
      lg: "1.5rem",
      xl: "2rem",
      "2xl": "3rem"
    },
    typography: {
      fontFamily: {
        heading: "'Indie Flower', cursive",
        body: "'Plus Jakarta Sans', sans-serif"
      },
      fontFaces: [
        {
          fontFamily: "Indie Flower",
          src: "url('/brand/fonts/IndieFlower/IndieFlower-Regular.ttf') format('truetype')",
          fontWeight: "400",
          fontStyle: "normal",
          fontDisplay: "swap"
        },
        {
          fontFamily: "Plus Jakarta Sans",
          src: "url('/brand/fonts/Jarkata/PlusJakartaSans-VariableFont_wght.ttf') format('truetype')",
          fontWeight: "100 900",
          fontStyle: "normal",
          fontDisplay: "swap"
        }
      ],
      fontSize: {
        xs: "0.75rem",
        sm: "0.85rem",
        base: "1rem",
        lg: "1.15rem",
        xl: "1.5rem",
        "2xl": "2rem"
      },
      fontWeight: {
        light: "300",
        normal: "400",
        medium: "500",
        semibold: "600",
        bold: "700"
      }
    },
    radii: {
      sm: "4px",
      md: "12px",
      apple: "18px",
      full: "9999px"
    },
    shadows: {
      sm: "0 4px 30px rgba(0, 0, 0, 0.05)",
      md: "0 10px 30px rgba(0, 0, 0, 0.05)",
      lg: "0 10px 40px rgba(0, 0, 0, 0.1)"
    },
    transitions: {
      fast: "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)",
      standard: "all 0.5s cubic-bezier(0.2, 0, 0.2, 1)"
    }
  },
  components: {
    stack: {
      display: "flex",
      flexDirection: "column",
      gap: "0.25rem",
      width: "100%",
      maxWidth: "100%",
      height: "100vh",
      background: "{colors.softClay}",
      padding: "0.375rem",
      overflowY: "auto",
      overflowX: "hidden",
      fontFamily: "{typography.fontFamily.body}",
      color: "{colors.marineBlue}",
      boxSizing: "border-box"
    },
    headerSection: {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      gap: "0.25rem",
      marginBottom: "0.25rem",
      width: "100%"
    },
    viewSwitcher: {
      display: "flex",
      gap: "0.2rem",
      background: "rgba(255, 255, 255, 0.2)",
      padding: "0.15rem",
      borderRadius: "{radii.full}",
      margin: "0 auto",
      border: "1px solid {colors.border}"
    },
    buttonViewSwitch: {
      padding: "0.25rem 0.6rem",
      background: "transparent",
      border: "none",
      borderRadius: "{radii.full}",
      fontSize: "0.55rem",
      fontWeight: "600",
      textTransform: "uppercase",
      letterSpacing: "0.05em",
      color: "{colors.marineBlueMuted}",
      cursor: "pointer",
      transition: "{transitions.fast}",
      data: {
        active: {
          true: {
            background: "{colors.marineBlue}",
            color: "{colors.softClay}",
            boxShadow: "0 4px 12px rgba(0, 31, 51, 0.2)"
          }
        }
      }
    },
    form: {
      display: "flex",
      flexDirection: "row",
      alignItems: "center",
      gap: "0.25rem",
      padding: "0.25rem 0.375rem",
      background: "rgba(255, 255, 255, 0.4)",
      backdropFilter: "blur(8px) saturate(150%)",
      borderRadius: "{radii.full}",
      border: "1px solid {colors.border}",
      boxShadow: "{shadows.md}",
      width: "100%",
      boxSizing: "border-box",
      marginBottom: "0.25rem"
    },
    input: {
      flex: "1",
      width: "100%",
      padding: "0.25rem 0.5rem",
      border: "none",
      background: "transparent",
      fontSize: "0.6rem",
      color: "{colors.marineBlue}",
      fontFamily: "{typography.fontFamily.body}",
      fontWeight: "{typography.fontWeight.light}",
      outline: "none",
      minHeight: "0",
      minWidth: "0",
      lineHeight: "1.35"
    },
    button: {
      width: "auto",
      padding: "0.25rem 0.5rem",
      background: "{colors.lushGreen}",
      color: "{colors.text.green}",
      border: "none",
      borderRadius: "{radii.full}",
      cursor: "pointer",
      fontSize: "0.5rem",
      fontWeight: "600",
      textTransform: "uppercase",
      letterSpacing: "0.05em",
      transition: "{transitions.fast}",
      boxShadow: "0 4px 12px rgba(78, 154, 88, 0.2)",
      whiteSpace: "nowrap",
      flexShrink: "0",
      ":hover": {
        filter: "brightness(1.1)",
        transform: "translateY(-1px)",
        boxShadow: "0 6px 16px rgba(78, 154, 88, 0.3)"
      }
    },
    errorMessage: {
      padding: "{spacing.sm} {spacing.md}",
      background: "{colors.errorBg}",
      color: "{colors.error}",
      borderRadius: "{radii.md}",
      border: "1px solid {colors.errorBorder}",
      margin: "{spacing.md} 0",
      display: "none",
      data: {
        hasError: {
          true: {
            display: "block"
          }
        }
      }
    },
    buttonDismiss: {
      marginLeft: "{spacing.sm}",
      padding: "0.25rem 0.5rem",
      background: "transparent",
      color: "{colors.error}",
      border: "1px solid {colors.errorBorder}",
      borderRadius: "{radii.sm}",
      cursor: "pointer",
      fontSize: "0.5rem",
      fontWeight: "600",
      transition: "{transitions.fast}",
      ":hover": {
        background: "{colors.error}",
        color: "white"
      }
    },
    card: {
      display: "flex",
      flexDirection: "column",
      alignItems: "flex-start",
      gap: "0.25rem",
      padding: "0.25rem 0.375rem",
      background: "rgba(255, 255, 255, 0.3)",
      backdropFilter: "blur(8px) saturate(150%)",
      borderRadius: "{radii.apple}",
      border: "1px solid {colors.border}",
      transition: "{transitions.fast}",
      marginBottom: "0.25rem",
      ":hover": {
        background: "rgba(255, 255, 255, 0.5)",
        transform: "translateY(-2px)",
        boxShadow: "{shadows.sm}"
      }
    },
    detailContentWrapper: {
      display: "flex",
      flexDirection: "column",
      height: "100%",
      width: "100%"
    },
    detailContainer: {
      background: "rgba(255, 255, 255, 0.4)",
      backdropFilter: "blur(12px) saturate(160%)",
      borderRadius: "{radii.apple}",
      boxShadow: "{shadows.md}",
      overflow: "auto",
      border: "1px solid rgba(255, 255, 255, 0.2)",
      transition: "{transitions.standard}",
      height: "100%",
      display: "flex",
      flexDirection: "column",
      padding: "{spacing.md}"
    },
    detailCategory: {
      fontFamily: "{typography.fontFamily.heading}",
      fontSize: "0.85rem",
      fontStyle: "italic",
      color: "{colors.paradiseWater}",
      marginBottom: "0.5rem",
      display: "block",
      textShadow: "0 0 10px rgba(0, 189, 214, 0.2)"
    },
    detailTitle: {
      fontFamily: "{typography.fontFamily.heading}",
      fontSize: "{typography.fontSize.xl}",
      fontWeight: "{typography.fontWeight.bold}",
      color: "{colors.marineBlue}",
      marginBottom: "{spacing.md}",
      marginTop: "0",
      letterSpacing: "-0.02em"
    },
    detailList: {
      display: "flex",
      flexDirection: "column",
      gap: "{spacing.sm}"
    },
    detailItem: {
      display: "flex",
      flexDirection: "row",
      justifyContent: "space-between",
      alignItems: "center",
      padding: "{spacing.sm}",
      background: "rgba(255, 255, 255, 0.2)",
      borderRadius: "{radii.md}",
      gap: "{spacing.md}"
    },
    detailLabel: {
      fontWeight: "{typography.fontWeight.semibold}",
      color: "{colors.marineBlueLight}",
      fontSize: "0.75rem"
    },
    detailValue: {
      color: "{colors.marineBlue}",
      fontSize: "0.75rem",
      fontFamily: "{typography.fontFamily.body}",
      wordBreak: "break-all"
    },
    tableContainer: {
      background: "rgba(255, 255, 255, 0.4)",
      backdropFilter: "blur(12px) saturate(160%)",
      borderRadius: "{radii.apple}",
      boxShadow: "{shadows.md}",
      overflow: "auto",
      border: "1px solid rgba(255, 255, 255, 0.2)",
      transition: "{transitions.standard}",
      height: "100%",
      display: "flex",
      flexDirection: "column",
      padding: "{spacing.md}"
    }
  },
  selectors: {
    ":host": {
      display: "block",
      height: "100%",
      background: "transparent"
    }
  }
}, Q0 = {
  $schema: "@maia/schema/vibe",
  $id: "@maia/vibe/todos",
  name: "Todos",
  description: "Complete todo list with state machines and AI tools",
  actor: "@maia/todos/actor/vibe"
}, E0 = {
  $schema: "@maia/schema/style",
  $id: "@maia/todos/style/brand",
  tokens: {
    colors: {
      marineBlue: "#001F33",
      marineBlueMuted: "#2D4A5C",
      marineBlueLight: "#5E7A8C",
      paradiseWater: "#00BDD6",
      lushGreen: "#4E9A58",
      terracotta: "#C27B66",
      sunYellow: "#E6B94D",
      softClay: "#E8E1D9",
      tintedWhite: "#F0EDE6",
      background: "transparent",
      foreground: "#001F33",
      primary: "#00BDD6",
      secondary: "#2D4A5C",
      border: "rgba(255, 255, 255, 0.1)",
      surface: "rgba(255, 255, 255, 0.3)",
      glass: "rgba(255, 255, 255, 0.0005)",
      glassStrong: "rgba(255, 255, 255, 0.15)",
      text: {
        marine: "#D1E8F7",
        water: "#004D59",
        green: "#F0F9F1",
        terracotta: "#FDF2EF",
        yellow: "#4D3810"
      }
    },
    spacing: {
      xs: "0.5rem",
      sm: "0.75rem",
      md: "1rem",
      lg: "1.5rem",
      xl: "2rem",
      "2xl": "3rem"
    },
    typography: {
      fontFamily: {
        heading: "'Indie Flower', cursive",
        body: "'Plus Jakarta Sans', sans-serif"
      },
      fontWeight: {
        light: "300",
        normal: "400",
        medium: "500",
        semibold: "600",
        bold: "700"
      }
    },
    radii: {
      sm: "4px",
      md: "12px",
      apple: "18px",
      full: "9999px"
    },
    shadows: {
      sm: "0 4px 30px rgba(0, 0, 0, 0.05)",
      md: "0 10px 30px rgba(0, 0, 0, 0.05)",
      lg: "0 10px 40px rgba(0, 0, 0, 0.1)"
    },
    transitions: {
      fast: "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)",
      standard: "all 0.5s cubic-bezier(0.2, 0, 0.2, 1)"
    }
  },
  components: {
    stack: {
      display: "flex",
      flexDirection: "column",
      gap: "0.25rem",
      width: "100%",
      maxWidth: "100%",
      height: "100vh",
      background: "{colors.softClay}",
      padding: "0.375rem",
      overflowY: "auto",
      overflowX: "hidden",
      fontFamily: "{typography.fontFamily.body}",
      color: "{colors.marineBlue}",
      boxSizing: "border-box"
    },
    headerSection: {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      gap: "0.25rem",
      marginBottom: "0.25rem",
      width: "100%"
    },
    todoCategory: {
      fontFamily: "{typography.fontFamily.heading}",
      fontSize: "0.6rem",
      fontStyle: "italic",
      color: "{colors.paradiseWater}",
      marginBottom: "0.25rem",
      display: "block",
      textAlign: "center",
      width: "100%",
      textShadow: "0 0 10px rgba(0, 189, 214, 0.2)"
    },
    todoTitle: {
      fontFamily: "{typography.fontFamily.heading}",
      fontSize: "0.9rem",
      fontWeight: "{typography.fontWeight.bold}",
      color: "{colors.marineBlue}",
      margin: "0",
      marginBottom: "0.375rem",
      textAlign: "center",
      width: "100%",
      letterSpacing: "-0.02em"
    },
    viewSwitcher: {
      display: "flex",
      gap: "0.2rem",
      background: "rgba(255, 255, 255, 0.2)",
      padding: "0.15rem",
      borderRadius: "{radii.full}",
      margin: "0 auto",
      border: "1px solid {colors.border}"
    },
    buttonViewSwitch: {
      padding: "0.25rem 0.6rem",
      background: "transparent",
      border: "none",
      borderRadius: "{radii.full}",
      fontSize: "0.55rem",
      fontWeight: "600",
      textTransform: "uppercase",
      letterSpacing: "0.05em",
      color: "{colors.marineBlueMuted}",
      cursor: "pointer",
      transition: "{transitions.fast}",
      data: {
        active: {
          true: {
            background: "{colors.marineBlue}",
            color: "{colors.softClay}",
            boxShadow: "0 4px 12px rgba(0, 31, 51, 0.2)"
          }
        }
      }
    },
    form: {
      display: "flex",
      flexDirection: "row",
      alignItems: "center",
      gap: "0.25rem",
      padding: "0.25rem 0.375rem",
      background: "rgba(255, 255, 255, 0.4)",
      backdropFilter: "blur(8px) saturate(150%)",
      borderRadius: "{radii.full}",
      border: "1px solid {colors.border}",
      boxShadow: "{shadows.md}",
      width: "100%",
      boxSizing: "border-box",
      marginBottom: "0.25rem"
    },
    input: {
      flex: "1",
      width: "100%",
      padding: "0.25rem 0.5rem",
      border: "none",
      background: "transparent",
      fontSize: "0.6rem",
      color: "{colors.marineBlue}",
      fontFamily: "{typography.fontFamily.body}",
      fontWeight: "{typography.fontWeight.light}",
      outline: "none",
      minHeight: "0",
      minWidth: "0",
      lineHeight: "1.35"
    },
    button: {
      width: "auto",
      padding: "0.25rem 0.5rem",
      background: "{colors.lushGreen}",
      color: "{colors.text.green}",
      border: "none",
      borderRadius: "{radii.full}",
      cursor: "pointer",
      fontSize: "0.5rem",
      fontWeight: "600",
      textTransform: "uppercase",
      letterSpacing: "0.05em",
      transition: "{transitions.fast}",
      boxShadow: "0 4px 12px rgba(78, 154, 88, 0.2)",
      whiteSpace: "nowrap",
      flexShrink: "0",
      ":hover": {
        filter: "brightness(1.1)",
        transform: "translateY(-1px)",
        boxShadow: "0 6px 16px rgba(78, 154, 88, 0.3)"
      }
    }
  },
  selectors: {
    ":host": {
      display: "block",
      height: "100%",
      background: "transparent"
    },
    "@container {containerName} (min-width: {containers.xs})": {
      ".stack": {
        padding: "0.625rem",
        gap: "0.375rem"
      },
      ".headerSection": {
        gap: "0.375rem",
        marginBottom: "0.375rem"
      },
      ".todoCategory": {
        fontSize: "0.8rem"
      },
      ".todoTitle": {
        fontSize: "1.15rem"
      },
      ".viewSwitcher": {
        gap: "0.375rem",
        padding: "0.25rem",
        minWidth: "fit-content"
      },
      ".buttonViewSwitch": {
        padding: "0.4rem 0.8rem",
        fontSize: "0.7rem"
      },
      ".form": {
        gap: "0.375rem",
        padding: "0.375rem 0.5rem"
      },
      ".input": {
        padding: "0.375rem 0.625rem",
        fontSize: "0.7rem"
      },
      ".button": {
        padding: "0.375rem 0.625rem",
        fontSize: "0.6rem"
      }
    },
    "@container {containerName} (min-width: {containers.sm})": {
      ".stack": {
        padding: "0.75rem",
        gap: "0.5rem"
      },
      ".headerSection": {
        gap: "0.5rem",
        marginBottom: "0.5rem"
      },
      ".todoCategory": {
        fontSize: "0.95rem"
      },
      ".todoTitle": {
        fontSize: "1.3rem"
      },
      ".viewSwitcher": {
        gap: "0.5rem",
        padding: "0.3rem",
        minWidth: "fit-content"
      },
      ".buttonViewSwitch": {
        padding: "0.4rem 0.8rem",
        fontSize: "0.7rem"
      },
      ".form": {
        gap: "0.5rem",
        padding: "0.5rem 0.625rem"
      },
      ".input": {
        padding: "0.5rem 0.75rem",
        fontSize: "0.75rem"
      },
      ".button": {
        padding: "0.5rem 0.75rem",
        fontSize: "0.65rem"
      }
    },
    "@container {containerName} (min-width: {containers.md})": {
      ".stack": {
        padding: "1rem",
        gap: "0.625rem"
      },
      ".headerSection": {
        gap: "0.625rem",
        marginBottom: "0.625rem"
      },
      ".todoCategory": {
        fontSize: "1.1rem"
      },
      ".todoTitle": {
        fontSize: "1.45rem"
      },
      ".viewSwitcher": {
        gap: "0.625rem",
        padding: "0.375rem",
        minWidth: "fit-content"
      },
      ".buttonViewSwitch": {
        padding: "0.6rem 1rem",
        fontSize: "0.85rem"
      },
      ".form": {
        gap: "0.625rem",
        padding: "0.625rem 0.75rem"
      },
      ".input": {
        padding: "0.625rem 0.875rem",
        fontSize: "0.8rem"
      },
      ".button": {
        padding: "0.625rem 0.875rem",
        fontSize: "0.7rem"
      }
    },
    "@container {containerName} (min-width: {containers.lg})": {
      ".stack": {
        padding: "1.25rem",
        gap: "0.75rem"
      },
      ".headerSection": {
        gap: "0.75rem",
        marginBottom: "0.75rem"
      },
      ".todoCategory": {
        fontSize: "1.2rem"
      },
      ".todoTitle": {
        fontSize: "1.55rem"
      },
      ".viewSwitcher": {
        gap: "0.75rem",
        padding: "0.45rem",
        minWidth: "fit-content"
      },
      ".buttonViewSwitch": {
        padding: "0.7rem 1.1rem",
        fontSize: "0.9rem"
      },
      ".form": {
        gap: "0.75rem",
        padding: "0.75rem 0.875rem"
      },
      ".input": {
        padding: "0.75rem 1rem",
        fontSize: "0.85rem"
      },
      ".button": {
        padding: "0.75rem 1rem",
        fontSize: "0.75rem"
      }
    },
    "@container {containerName} (min-width: {containers.xl})": {
      ".stack": {
        padding: "1.5rem",
        gap: "0.875rem"
      },
      ".headerSection": {
        gap: "0.875rem",
        marginBottom: "0.875rem"
      },
      ".todoCategory": {
        fontSize: "1.3rem"
      },
      ".todoTitle": {
        fontSize: "1.65rem"
      },
      ".viewSwitcher": {
        gap: "0.875rem",
        padding: "0.5rem",
        minWidth: "fit-content"
      },
      ".buttonViewSwitch": {
        padding: "0.8rem 1.2rem",
        fontSize: "1rem"
      },
      ".form": {
        gap: "0.875rem",
        padding: "0.875rem 1rem"
      },
      ".input": {
        padding: "0.875rem 1.125rem",
        fontSize: "0.9rem"
      },
      ".button": {
        padding: "0.875rem 1.125rem",
        fontSize: "0.8rem"
      }
    },
    "@container {containerName} (min-width: {containers.2xl})": {
      ".stack": {
        padding: "1.75rem",
        gap: "1rem"
      },
      ".headerSection": {
        gap: "1rem",
        marginBottom: "1rem"
      },
      ".todoCategory": {
        fontSize: "1.4rem"
      },
      ".todoTitle": {
        fontSize: "1.75rem"
      },
      ".viewSwitcher": {
        gap: "1rem",
        padding: "0.55rem",
        minWidth: "fit-content"
      },
      ".buttonViewSwitch": {
        padding: "0.9rem 1.3rem",
        fontSize: "1.1rem"
      },
      ".form": {
        gap: "1rem",
        padding: "1rem 1.125rem"
      },
      ".input": {
        padding: "1rem 1.25rem",
        fontSize: "0.95rem"
      },
      ".button": {
        padding: "1rem 1.25rem",
        fontSize: "0.85rem"
      }
    }
  }
}, l0 = {
  $schema: "@maia/schema/style",
  $id: "@maia/todos/style/list",
  components: {
    list: {
      display: "flex",
      flexDirection: "column",
      gap: "0.25rem",
      overflowY: "auto",
      width: "100%",
      boxSizing: "border-box",
      padding: "0.375rem"
    },
    card: {
      display: "flex",
      flexDirection: "column",
      alignItems: "flex-start",
      gap: "0.25rem",
      padding: "0.25rem 0.375rem",
      background: "rgba(255, 255, 255, 0.3)",
      backdropFilter: "blur(8px) saturate(150%)",
      borderRadius: "{radii.apple}",
      border: "1px solid {colors.border}",
      transition: "{transitions.fast}",
      marginBottom: "0.25rem",
      ":hover": {
        background: "rgba(255, 255, 255, 0.5)",
        transform: "translateY(-2px)",
        boxShadow: "{shadows.sm}"
      }
    },
    body: {
      flex: "1",
      fontSize: "0.75rem",
      fontWeight: "{typography.fontWeight.light}",
      color: "{colors.marineBlue}",
      lineHeight: "1.3",
      width: "100%"
    },
    buttonSmall: {
      width: "12px",
      height: "12px",
      minWidth: "12px",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      background: "rgba(255, 255, 255, 0.2)",
      color: "{colors.marineBlueMuted}",
      border: "1px solid {colors.border}",
      borderRadius: "{radii.full}",
      cursor: "pointer",
      transition: "{transitions.fast}",
      fontSize: "0.5rem",
      ":hover": {
        background: "{colors.marineBlue}",
        color: "{colors.softClay}",
        borderColor: "{colors.marineBlue}"
      }
    },
    buttonDanger: {
      ":hover": {
        background: "{colors.terracotta}",
        color: "{colors.text.terracotta}",
        borderColor: "{colors.terracotta}"
      }
    }
  },
  selectors: {
    "@container {containerName} (min-width: {containers.xs})": {
      ".list": {
        gap: "0.375rem",
        padding: "0.5rem"
      },
      ".card": {
        padding: "0.375rem 0.5rem",
        gap: "0.375rem"
      },
      ".body": {
        fontSize: "0.8rem"
      },
      ".buttonSmall": {
        width: "14px",
        height: "14px",
        minWidth: "14px",
        fontSize: "0.6rem"
      }
    },
    "@container {containerName} (min-width: {containers.sm})": {
      ".list": {
        gap: "0.5rem",
        padding: "0.625rem"
      },
      ".card": {
        flexDirection: "row",
        alignItems: "center",
        padding: "0.5rem 0.625rem",
        gap: "0.5rem"
      },
      ".body": {
        fontSize: "0.85rem",
        width: "auto"
      },
      ".buttonSmall": {
        width: "16px",
        height: "16px",
        minWidth: "16px",
        fontSize: "0.65rem"
      }
    },
    "@container {containerName} (min-width: {containers.md})": {
      ".list": {
        gap: "0.625rem",
        padding: "0.75rem"
      },
      ".card": {
        padding: "0.625rem 0.75rem",
        gap: "0.625rem"
      },
      ".body": {
        fontSize: "0.9rem"
      },
      ".buttonSmall": {
        width: "18px",
        height: "18px",
        minWidth: "18px",
        fontSize: "0.7rem"
      }
    },
    "@container {containerName} (min-width: {containers.lg})": {
      ".list": {
        gap: "0.75rem",
        padding: "1rem"
      },
      ".card": {
        padding: "0.75rem 0.875rem",
        gap: "0.75rem"
      },
      ".body": {
        fontSize: "0.95rem"
      },
      ".buttonSmall": {
        width: "20px",
        height: "20px",
        minWidth: "20px",
        fontSize: "0.75rem"
      }
    },
    "@container {containerName} (min-width: {containers.xl})": {
      ".list": {
        gap: "0.875rem",
        padding: "1.25rem"
      },
      ".card": {
        padding: "0.875rem 1rem",
        gap: "0.875rem"
      },
      ".body": {
        fontSize: "1rem",
        fontWeight: "{typography.fontWeight.medium}"
      },
      ".buttonSmall": {
        width: "22px",
        height: "22px",
        minWidth: "22px",
        fontSize: "0.8rem"
      },
      ".card:hover": {
        transform: "translateY(-1px)",
        boxShadow: "{shadows.md}"
      }
    },
    "@container {containerName} (min-width: {containers.2xl})": {
      ".list": {
        gap: "1rem",
        padding: "1.5rem"
      },
      ".card": {
        padding: "1rem 1.25rem",
        gap: "1rem"
      },
      ".body": {
        fontSize: "1.05rem",
        fontWeight: "{typography.fontWeight.medium}"
      },
      ".buttonSmall": {
        width: "24px",
        height: "24px",
        minWidth: "24px",
        fontSize: "0.85rem"
      },
      ".card:hover": {
        transform: "translateY(-2px)",
        boxShadow: "{shadows.lg}"
      }
    },
    "[data-done=true] .body": {
      textDecoration: "line-through",
      opacity: "0.7"
    },
    "[data-done=true]": {
      opacity: "0.6",
      background: "rgba(255, 255, 255, 0.1)"
    }
  }
}, d0 = {
  $schema: "@maia/schema/style",
  $id: "@maia/todos/style/coming-soon",
  components: {
    comingSoon: {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      justifyContent: "center",
      padding: "{spacing.xl}",
      minHeight: "200px"
    },
    comingSoonText: {
      fontFamily: "{typography.fontFamily.heading}",
      fontSize: "1.2rem",
      color: "{colors.marineBlueLight}",
      fontStyle: "italic"
    }
  }
}, u0 = {
  $schema: "@maia/schema/actor",
  $id: "@maia/todos/actor/vibe",
  role: "agent",
  context: "@maia/todos/context/vibe",
  view: "@maia/todos/view/vibe",
  state: "@maia/todos/state/vibe",
  brand: "@maia/todos/style/brand",
  inbox: "@maia/todos/inbox/vibe",
  messageTypes: ["CREATE_BUTTON", "TOGGLE_BUTTON", "DELETE_BUTTON", "UPDATE_INPUT", "SWITCH_VIEW", "SUCCESS", "ERROR"]
}, h0 = {
  $schema: "@maia/schema/actor",
  $id: "@maia/todos/actor/list",
  role: "todo-list",
  context: "@maia/todos/context/list",
  view: "@maia/todos/view/list",
  state: "@maia/todos/state/list",
  brand: "@maia/todos/style/brand",
  style: "@maia/todos/style/list",
  inbox: "@maia/todos/inbox/list",
  messageTypes: [
    "TOGGLE_BUTTON",
    "DELETE_BUTTON",
    "SUCCESS",
    "RETRY",
    "DISMISS"
  ]
}, f0 = {
  $schema: "@maia/schema/actor",
  $id: "@maia/todos/actor/coming-soon",
  role: "ui",
  context: "@maia/todos/context/coming-soon",
  view: "@maia/todos/view/coming-soon",
  state: "@maia/todos/state/coming-soon",
  brand: "@maia/style/brand",
  style: "@maia/todos/style/coming-soon",
  inbox: "@maia/todos/inbox/coming-soon",
  messageTypes: []
}, p0 = {
  $schema: "@maia/schema/view",
  $id: "@maia/todos/view/vibe",
  content: {
    tag: "div",
    class: "stack",
    children: [
      {
        tag: "div",
        class: "header-section",
        children: [
          { tag: "h2", class: "todo-title", text: "Daily Focus" },
          {
            tag: "div",
            class: "view-switcher",
            children: [
              {
                tag: "button",
                class: "button-view-switch",
                attrs: { "data-view": "list", data: { active: "$listButtonActive" } },
                text: "$listViewLabel",
                $on: { click: { send: "SWITCH_VIEW", payload: { viewMode: "list" } } }
              },
              {
                tag: "button",
                class: "button-view-switch",
                attrs: { "data-view": "comingSoon", data: { active: "$comingSoonButtonActive" } },
                text: "$comingSoonViewLabel",
                $on: { click: { send: "SWITCH_VIEW", payload: { viewMode: "comingSoon" } } }
              }
            ]
          }
        ]
      },
      {
        class: "form",
        children: [
          {
            tag: "input",
            class: "input",
            attrs: { type: "text", placeholder: "$inputPlaceholder" },
            value: "$newTodoText",
            $on: {
              input: { send: "UPDATE_INPUT", payload: { value: "@inputValue" } },
              blur: { send: "UPDATE_INPUT", payload: { value: "@inputValue" } },
              keydown: { send: "CREATE_BUTTON", payload: { value: "@inputValue" }, key: "Enter" }
            }
          },
          { tag: "button", class: "button", text: "$addButtonText", $on: { click: { send: "CREATE_BUTTON", payload: { value: "$newTodoText" } } } }
        ]
      },
      { tag: "main", class: "content-area", $slot: "$currentView" }
    ]
  }
}, w0 = {
  $schema: "@maia/schema/view",
  $id: "@maia/todos/view/list",
  content: {
    class: "list",
    $each: {
      items: "$list",
      template: {
        class: "card",
        attrs: {
          "data-done": "$$done"
        },
        children: [
          {
            tag: "span",
            class: "body",
            text: "$$text"
          },
          {
            tag: "button",
            class: "button-small",
            text: "",
            $on: {
              click: {
                send: "TOGGLE_BUTTON",
                payload: {
                  id: "$$id",
                  done: "$$done"
                }
              }
            }
          },
          {
            tag: "button",
            class: "button-small button-danger",
            text: "$deleteButtonText",
            $on: {
              click: {
                send: "DELETE_BUTTON",
                payload: {
                  id: "$$id"
                }
              }
            }
          }
        ]
      }
    }
  }
}, y0 = {
  $schema: "@maia/schema/view",
  $id: "@maia/todos/view/coming-soon",
  content: {
    tag: "div",
    class: "coming-soon",
    children: [
      {
        tag: "p",
        class: "coming-soon-text",
        text: "$message"
      }
    ]
  }
}, D0 = {
  $schema: "@maia/schema/context",
  $id: "@maia/todos/context/vibe",
  currentView: "@list",
  viewMode: "list",
  listButtonActive: !0,
  comingSoonButtonActive: !1,
  inputPlaceholder: "Add a new todo...",
  addButtonText: "Add",
  listViewLabel: "List",
  comingSoonViewLabel: "Soon",
  newTodoText: "",
  error: null,
  "@actors": {
    list: "@maia/todos/actor/list",
    comingSoon: "@maia/todos/actor/coming-soon"
  }
}, m0 = {
  $schema: "@maia/schema/context",
  $id: "@maia/todos/context/list",
  list: {
    schema: "@maia/schema/data/todos"
  },
  toggleButtonText: "",
  deleteButtonText: ""
}, S0 = {
  $schema: "@maia/schema/context",
  $id: "@maia/todos/context/coming-soon",
  message: "Coming soon"
}, k0 = {
  $schema: "@maia/schema/state",
  $id: "@maia/todos/state/vibe",
  initial: "idle",
  states: {
    idle: {
      on: {
        CREATE_BUTTON: { target: "creating" },
        TOGGLE_BUTTON: { target: "toggling" },
        DELETE_BUTTON: { target: "deleting" },
        SWITCH_VIEW: {
          target: "idle",
          actions: [
            { updateContext: { viewMode: "$$viewMode" } },
            { updateContext: { currentView: { $if: { condition: { $eq: ["$$viewMode", "list"] }, then: "@list", else: "@comingSoon" } } } },
            { updateContext: { listButtonActive: { $eq: ["$$viewMode", "list"] } } },
            { updateContext: { comingSoonButtonActive: { $eq: ["$$viewMode", "comingSoon"] } } }
          ]
        },
        UPDATE_INPUT: { target: "idle", actions: [{ updateContext: { newTodoText: "$$value" } }] }
      }
    },
    creating: {
      entry: { tool: "@db", payload: { op: "create", schema: "@maia/schema/data/todos", data: { text: "$$value", done: !1 } } },
      on: {
        UPDATE_INPUT: { target: "idle" },
        CREATE_BUTTON: { target: "creating" },
        TOGGLE_BUTTON: { target: "toggling" },
        DELETE_BUTTON: { target: "deleting" },
        SWITCH_VIEW: { target: "idle", actions: [{ updateContext: { viewMode: "$$viewMode" } }, { updateContext: { currentView: { $if: { condition: { $eq: ["$$viewMode", "list"] }, then: "@list", else: "@comingSoon" } } } }, { updateContext: { listButtonActive: { $eq: ["$$viewMode", "list"] } } }, { updateContext: { comingSoonButtonActive: { $eq: ["$$viewMode", "comingSoon"] } } }] },
        SUCCESS: { target: "idle", actions: [{ updateContext: { newTodoText: "" } }] },
        ERROR: "error"
      }
    },
    toggling: {
      entry: { tool: "@db", payload: { op: "update", id: "$$id", data: { done: { $not: "$$done" } } } },
      on: { TOGGLE_BUTTON: { target: "toggling" }, DELETE_BUTTON: { target: "deleting" }, UPDATE_INPUT: { target: "idle" }, CREATE_BUTTON: { target: "creating" }, SWITCH_VIEW: { target: "idle" }, SUCCESS: { target: "idle" }, ERROR: "error" }
    },
    deleting: {
      entry: { tool: "@db", payload: { op: "delete", id: "$$id" } },
      on: { DELETE_BUTTON: { target: "deleting" }, UPDATE_INPUT: { target: "idle" }, CREATE_BUTTON: { target: "creating" }, SWITCH_VIEW: { target: "idle" }, TOGGLE_BUTTON: { target: "toggling" }, SUCCESS: { target: "idle" }, ERROR: { target: "error" } }
    },
    error: {
      entry: { updateContext: { error: "$$errors.0.message" } },
      on: { TOGGLE_BUTTON: { target: "toggling" }, DELETE_BUTTON: { target: "deleting" }, RETRY: { target: "idle", actions: [{ updateContext: { error: null } }] }, DISMISS: { target: "idle", actions: [{ updateContext: { error: null } }] } }
    }
  }
}, N0 = {
  $schema: "@maia/schema/state",
  $id: "@maia/todos/state/list",
  initial: "idle",
  states: {
    idle: {
      on: {
        TOGGLE_BUTTON: {
          target: "idle",
          actions: [
            {
              tool: "@core/publishMessage",
              payload: {
                type: "TOGGLE_BUTTON",
                payload: {
                  id: "$$id",
                  done: "$$done"
                },
                target: "@maia/todos/actor/vibe"
              }
            }
          ]
        },
        DELETE_BUTTON: {
          target: "idle",
          actions: [
            {
              tool: "@core/publishMessage",
              payload: {
                type: "DELETE_BUTTON",
                payload: {
                  id: "$$id"
                },
                target: "@maia/todos/actor/vibe"
              }
            }
          ]
        },
        SUCCESS: {
          target: "idle"
        }
      }
    },
    error: {
      entry: {
        updateContext: {
          error: "$$errors.0.message"
        }
      },
      on: {
        RETRY: {
          target: "idle",
          actions: [
            {
              updateContext: {
                error: null
              }
            }
          ]
        },
        DISMISS: {
          target: "idle",
          actions: [
            {
              updateContext: {
                error: null
              }
            }
          ]
        }
      }
    }
  }
}, M0 = {
  $schema: "@maia/schema/state",
  $id: "@maia/todos/state/coming-soon",
  initial: "idle",
  states: {
    idle: {}
  }
}, G0 = {
  $schema: "@maia/schema/inbox",
  $id: "@maia/todos/inbox/vibe",
  items: []
}, F0 = {
  $schema: "@maia/schema/inbox",
  $id: "@maia/todos/inbox/list",
  items: []
}, b0 = {
  $schema: "@maia/schema/inbox",
  $id: "@maia/todos/inbox/coming-soon",
  items: []
}, Vr = {
  vibe: Q0,
  styles: {
    "@maia/style/brand": nc,
    "@maia/todos/style/brand": E0,
    "@maia/todos/style/list": l0,
    "@maia/todos/style/coming-soon": d0
  },
  actors: {
    "@maia/todos/actor/vibe": u0,
    "@maia/todos/actor/list": h0,
    "@maia/todos/actor/coming-soon": f0
  },
  views: {
    "@maia/todos/view/vibe": p0,
    "@maia/todos/view/list": w0,
    "@maia/todos/view/coming-soon": y0
  },
  contexts: {
    "@maia/todos/context/vibe": D0,
    "@maia/todos/context/list": m0,
    "@maia/todos/context/coming-soon": S0
  },
  states: {
    "@maia/todos/state/vibe": k0,
    "@maia/todos/state/list": N0,
    "@maia/todos/state/coming-soon": M0
  },
  inboxes: {
    "@maia/todos/inbox/vibe": G0,
    "@maia/todos/inbox/list": F0,
    "@maia/todos/inbox/coming-soon": b0
  },
  data: {
    todos: [
      { text: "Welcome to MaiaOS! ", done: !1 },
      { text: "Toggle me to mark as complete", done: !1 }
    ]
  }
}, R0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  TodosVibeRegistry: Vr
}, Symbol.toStringTag, { value: "Module" })), K0 = {
  $schema: "@maia/schema/vibe",
  $id: "@maia/vibe/db",
  name: "MaiaDB",
  description: "Database viewer with navigation and detail panels",
  actor: "@maia/db/actor/vibe"
}, v0 = {
  $schema: "@maia/schema/style",
  $id: "@maia/db/style/brand",
  tokens: {
    colors: {
      marineBlue: "#001F33",
      marineBlueMuted: "#2D4A5C",
      marineBlueLight: "#5E7A8C",
      paradiseWater: "#00BDD6",
      lushGreen: "#4E9A58",
      terracotta: "#C27B66",
      sunYellow: "#E6B94D",
      softClay: "#E8E1D9",
      tintedWhite: "#F0EDE6",
      background: "#E8E1D9",
      foreground: "#001F33",
      primary: "#00BDD6",
      secondary: "#2D4A5C",
      border: "rgba(255, 255, 255, 0.1)",
      surface: "rgba(255, 255, 255, 0.3)",
      glass: "rgba(255, 255, 255, 0.0005)",
      glassStrong: "rgba(255, 255, 255, 0.15)",
      text: {
        marine: "#D1E8F7",
        water: "#004D59",
        green: "#F0F9F1",
        terracotta: "#FDF2EF",
        yellow: "#4D3810"
      }
    },
    spacing: {
      xs: "0.5rem",
      sm: "0.75rem",
      md: "1rem",
      lg: "1.5rem",
      xl: "2rem",
      "2xl": "3rem"
    },
    typography: {
      fontFamily: {
        heading: "'Indie Flower', cursive",
        body: "'Plus Jakarta Sans', sans-serif"
      },
      fontFaces: [
        {
          fontFamily: "Indie Flower",
          src: "url('/brand/fonts/IndieFlower/IndieFlower-Regular.ttf') format('truetype')",
          fontWeight: "400",
          fontStyle: "normal",
          fontDisplay: "swap"
        },
        {
          fontFamily: "Plus Jakarta Sans",
          src: "url('/brand/fonts/Jarkata/PlusJakartaSans-VariableFont_wght.ttf') format('truetype')",
          fontWeight: "100 900",
          fontStyle: "normal",
          fontDisplay: "swap"
        }
      ],
      fontSize: {
        xs: "0.75rem",
        sm: "0.85rem",
        base: "1rem",
        lg: "1.15rem",
        xl: "1.5rem",
        "2xl": "2rem"
      },
      fontWeight: {
        light: "300",
        normal: "400",
        medium: "500",
        semibold: "600",
        bold: "700"
      }
    },
    radii: {
      sm: "4px",
      md: "12px",
      apple: "18px",
      full: "9999px"
    },
    shadows: {
      sm: "0 4px 30px rgba(0, 0, 0, 0.05)",
      md: "0 10px 30px rgba(0, 0, 0, 0.05)",
      lg: "0 10px 40px rgba(0, 0, 0, 0.1)"
    },
    transitions: {
      fast: "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)",
      standard: "all 0.5s cubic-bezier(0.2, 0, 0.2, 1)"
    }
  },
  components: {
    dbViewer: {
      display: "grid",
      gridTemplateColumns: "220px 1fr 400px",
      height: "100vh",
      width: "100%",
      background: "transparent",
      fontFamily: "{typography.fontFamily.body}",
      color: "{colors.marineBlue}",
      position: "relative",
      overflow: "hidden",
      padding: "{spacing.md}",
      gap: "{spacing.md}"
    },
    navAside: {
      background: "rgba(255, 255, 255, 0.4)",
      backdropFilter: "blur(12px) saturate(160%)",
      borderRadius: "{radii.apple}",
      border: "1px solid rgba(255, 255, 255, 0.2)",
      boxShadow: "{shadows.md}",
      padding: "{spacing.md}",
      overflowY: "auto",
      display: "flex",
      flexDirection: "column",
      gap: "{spacing.md}",
      zIndex: "10",
      height: "fit-content",
      maxHeight: "100%",
      position: "relative"
    },
    sidebarToggle: {
      display: "none",
      alignItems: "center",
      justifyContent: "center",
      width: "100%",
      padding: "{spacing.sm}",
      background: "rgba(255, 255, 255, 0.2)",
      border: "1px solid rgba(255, 255, 255, 0.2)",
      borderRadius: "{radii.md}",
      cursor: "pointer",
      marginBottom: "{spacing.sm}",
      fontSize: "0.7rem",
      fontWeight: "700",
      textTransform: "uppercase",
      color: "{colors.marineBlue}",
      fontFamily: "{typography.fontFamily.body}",
      transition: "{transitions.fast}",
      ":hover": {
        background: "rgba(255, 255, 255, 0.4)"
      }
    },
    detailContentWrapper: {
      display: "flex",
      flexDirection: "column",
      height: "100%",
      overflowY: "auto"
    },
    navTitle: {
      fontFamily: "{typography.fontFamily.heading}",
      fontSize: "{typography.fontSize.lg}",
      fontWeight: "{typography.fontWeight.normal}",
      fontStyle: "normal",
      color: "{colors.marineBlue}",
      marginBottom: "{spacing.sm}",
      marginTop: "0",
      padding: "0 {spacing.xs}",
      letterSpacing: "-0.02em"
    },
    navList: {
      display: "flex",
      flexDirection: "column",
      gap: "{spacing.sm}"
    },
    navCategory: {
      display: "flex",
      flexDirection: "column",
      gap: "{spacing.sm}"
    },
    navCategoryDivider: {
      fontFamily: "{typography.fontFamily.body}",
      fontSize: "0.6rem",
      fontWeight: "700",
      textTransform: "uppercase",
      letterSpacing: "0.15em",
      color: "{colors.marineBlueLight}",
      padding: "0.5rem {spacing.xs} 0.25rem {spacing.xs}",
      marginTop: "{spacing.sm}",
      marginBottom: "0"
    },
    navItem: {
      display: "flex",
      alignItems: "center",
      width: "100%",
      padding: "0.6rem 1.2rem",
      marginBottom: "{spacing.xs}",
      background: "rgba(255, 255, 255, 0.1)",
      backdropFilter: "blur(8px) saturate(150%)",
      border: "none",
      borderRadius: "{radii.full}",
      cursor: "pointer",
      transition: "{transitions.fast}",
      fontFamily: "{typography.fontFamily.body}",
      fontSize: "0.75rem",
      fontWeight: "{typography.fontWeight.semibold}",
      color: "{colors.marineBlueMuted}",
      textAlign: "left",
      textTransform: "uppercase",
      letterSpacing: "0.05em",
      boxShadow: "0 2px 8px rgba(0, 0, 0, 0.05)",
      ":hover": {
        background: "rgba(255, 255, 255, 0.2)",
        color: "{colors.marineBlue}",
        transform: "translateX(2px)",
        boxShadow: "0 4px 12px rgba(0, 0, 0, 0.1)"
      }
    },
    tableArea: {
      overflowY: "auto",
      display: "flex",
      flexDirection: "column",
      zIndex: "5",
      containerType: "inline-size",
      background: "transparent",
      padding: "0"
    },
    tableContainer: {
      background: "rgba(255, 255, 255, 0.4)",
      backdropFilter: "blur(12px) saturate(160%)",
      borderRadius: "{radii.apple}",
      boxShadow: "{shadows.md}",
      overflow: "auto",
      border: "1px solid rgba(255, 255, 255, 0.2)",
      transition: "{transitions.standard}",
      height: "100%",
      display: "flex",
      flexDirection: "column",
      padding: "{spacing.md}"
    },
    dataTable: {
      width: "100%",
      borderCollapse: "separate",
      borderSpacing: "0",
      fontFamily: "{typography.fontFamily.body}",
      fontSize: "{typography.fontSize.sm}"
    },
    "dataTable th": {
      background: "rgba(255, 255, 255, 0.4)",
      padding: "{spacing.lg}",
      textAlign: "left",
      fontWeight: "700",
      color: "{colors.marineBlue}",
      borderBottom: "1px solid {colors.border}",
      textTransform: "uppercase",
      letterSpacing: "0.12em",
      fontSize: "0.65rem"
    },
    "dataTable td": {
      padding: "{spacing.lg}",
      borderBottom: "1px solid {colors.border}",
      color: "{colors.marineBlueMuted}",
      transition: "{transitions.fast}",
      fontSize: "{typography.fontSize.sm}",
      fontWeight: "{typography.fontWeight.light}"
    },
    tableRow: {
      cursor: "pointer",
      transition: "{transitions.fast}",
      ":hover": {
        background: "rgba(255, 255, 255, 0.5)"
      }
    },
    detailAside: {
      overflowY: "auto",
      display: "flex",
      flexDirection: "column",
      zIndex: "10",
      containerType: "inline-size",
      background: "transparent",
      padding: "0"
    },
    detailContainer: {
      background: "rgba(255, 255, 255, 0.4)",
      backdropFilter: "blur(12px) saturate(160%)",
      borderRadius: "{radii.apple}",
      boxShadow: "{shadows.md}",
      overflow: "auto",
      border: "1px solid rgba(255, 255, 255, 0.2)",
      transition: "{transitions.standard}",
      height: "100%",
      display: "flex",
      flexDirection: "column",
      padding: "{spacing.md}"
    },
    detailTitle: {
      fontFamily: "{typography.fontFamily.heading}",
      fontSize: "{typography.fontSize.xl}",
      fontWeight: "{typography.fontWeight.bold}",
      color: "{colors.marineBlue}",
      marginBottom: "{spacing.md}",
      marginTop: "0",
      letterSpacing: "-0.02em"
    },
    detailCategory: {
      fontFamily: "{typography.fontFamily.heading}",
      fontSize: "0.85rem",
      fontStyle: "italic",
      color: "{colors.paradiseWater}",
      marginBottom: "0.5rem",
      display: "block",
      textShadow: "0 0 10px rgba(0, 189, 214, 0.2)"
    },
    detailList: {
      display: "flex",
      flexDirection: "column",
      gap: "{spacing.sm}"
    },
    detailItem: {
      display: "flex",
      flexDirection: "column",
      gap: "0.15rem",
      padding: "{spacing.md}",
      background: "rgba(255, 255, 255, 0.2)",
      borderRadius: "{radii.md}",
      border: "1px solid {colors.border}",
      transition: "{transitions.fast}",
      ":hover": {
        background: "rgba(255, 255, 255, 0.4)",
        transform: "translateY(-2px)",
        boxShadow: "{shadows.sm}"
      }
    },
    detailLabel: {
      fontSize: "0.65rem",
      textTransform: "uppercase",
      letterSpacing: "0.08em",
      color: "{colors.marineBlueLight}",
      fontWeight: "700"
    },
    detailValue: {
      fontSize: "{typography.fontSize.base}",
      color: "{colors.marineBlue}",
      fontWeight: "{typography.fontWeight.light}"
    }
  },
  selectors: {
    ":host": {
      position: "relative",
      background: "transparent",
      fontFamily: "{typography.fontFamily.body}",
      color: "{colors.foreground}"
    },
    ".nav-item[data-selected='true']": {
      background: "rgba(0, 189, 214, 0.2)",
      backdropFilter: "blur(12px) saturate(160%)",
      color: "{colors.marineBlue}",
      fontWeight: "{typography.fontWeight.semibold}",
      boxShadow: "0 4px 12px rgba(0, 189, 214, 0.2)",
      transform: "translateX(2px)",
      textShadow: "0 0 10px rgba(0, 189, 214, 0.3)",
      marginBottom: "{spacing.xs}"
    },
    ".nav-item:last-child": {
      marginBottom: "0"
    },
    ".nav-category:first-child .nav-category-divider": {
      marginTop: "0"
    },
    ".table-row[data-selected='true']": {
      background: "rgba(0, 189, 214, 0.15)",
      color: "{colors.marineBlue}",
      backdropFilter: "blur(4px)"
    },
    "@container (max-width: 1000px)": {
      ".db-viewer": {
        gridTemplateColumns: "180px 1fr 300px"
      }
    },
    "@container (max-width: 700px)": {
      ".db-viewer": {
        gridTemplateColumns: "1fr",
        gridTemplateRows: "auto 1fr auto",
        position: "relative",
        overflow: "hidden"
      },
      ".sidebar-toggle": {
        display: "flex"
      },
      ".nav-aside": {
        position: "absolute",
        left: "0",
        top: "0",
        bottom: "0",
        width: "280px",
        maxWidth: "85vw",
        zIndex: "100",
        transform: "translateX(-100%)",
        opacity: "0",
        pointerEvents: "none",
        transition: "none",
        boxShadow: "2px 0 20px rgba(0, 0, 0, 0.1)"
      },
      ".nav-aside.sidebar-ready": {
        transition: "{transitions.standard}"
      },
      ".nav-aside:not(.collapsed)": {
        transform: "translateX(0)",
        opacity: "1",
        pointerEvents: "auto"
      },
      ".detail-aside": {
        position: "absolute",
        right: "0",
        top: "0",
        bottom: "0",
        width: "320px",
        maxWidth: "85vw",
        zIndex: "100",
        transform: "translateX(100%)",
        opacity: "0",
        pointerEvents: "none",
        transition: "none",
        boxShadow: "-2px 0 20px rgba(0, 0, 0, 0.1)"
      },
      ".detail-aside.sidebar-ready": {
        transition: "{transitions.standard}"
      },
      ".detail-aside:not(.collapsed)": {
        transform: "translateX(0)",
        opacity: "1",
        pointerEvents: "auto"
      },
      ".nav-aside.collapsed": {
        transform: "translateX(-100%)",
        opacity: "0",
        pointerEvents: "none"
      },
      ".detail-aside.collapsed": {
        transform: "translateX(100%)",
        opacity: "0",
        pointerEvents: "none"
      },
      ".nav-aside.collapsed .nav-title": {
        display: "none"
      },
      ".nav-aside.collapsed .nav-list": {
        display: "none"
      },
      ".detail-aside.collapsed .detail-content-wrapper": {
        display: "none"
      }
    }
  }
}, Y0 = {
  $schema: "@maia/schema/actor",
  $id: "@maia/db/actor/vibe",
  role: "agent",
  context: "@maia/db/context/vibe",
  view: "@maia/db/view/vibe",
  state: "@maia/db/state/vibe",
  brand: "@maia/db/style/brand",
  inbox: "@maia/db/inbox/vibe",
  messageTypes: [
    "SELECT_NAV",
    "SELECT_ROW"
  ]
}, U0 = {
  $schema: "@maia/schema/actor",
  $id: "@maia/db/actor/table",
  role: "ui",
  context: "@maia/db/context/table",
  view: "@maia/db/view/table",
  state: "@maia/db/state/table",
  brand: "@maia/db/style/brand",
  inbox: "@maia/db/inbox/table",
  messageTypes: [
    "SELECT_ROW"
  ]
}, J0 = {
  $schema: "@maia/schema/actor",
  $id: "@maia/db/actor/detail",
  role: "ui",
  context: "@maia/db/context/detail",
  view: "@maia/db/view/detail",
  state: "@maia/db/state/detail",
  brand: "@maia/db/style/brand",
  inbox: "@maia/db/inbox/detail",
  messageTypes: []
}, H0 = {
  $schema: "@maia/schema/view",
  $id: "@maia/db/view/vibe",
  content: {
    tag: "div",
    class: "db-viewer",
    children: [
      {
        tag: "aside",
        class: "nav-aside",
        children: [
          {
            tag: "button",
            class: "sidebar-toggle nav-toggle",
            attrs: {
              "aria-label": "Toggle navigation sidebar"
            },
            text: "Navigation"
          },
          {
            tag: "h2",
            class: "nav-title",
            text: "$navTitle"
          },
          {
            tag: "nav",
            class: "nav-list",
            children: [
              {
                $each: {
                  items: "$navCategories",
                  template: {
                    tag: "div",
                    class: "nav-category",
                    children: [
                      {
                        tag: "div",
                        class: "nav-category-divider",
                        text: "$$category"
                      },
                      {
                        $each: {
                          items: "$$items",
                          template: {
                            tag: "button",
                            class: "nav-item",
                            attrs: {
                              data: {
                                selected: "$selectedNavItems.$$id"
                              }
                            },
                            children: [
                              {
                                tag: "span",
                                class: "nav-label",
                                text: "$$label"
                              }
                            ],
                            $on: {
                              click: {
                                send: "SELECT_NAV",
                                payload: {
                                  navId: "$$id"
                                }
                              }
                            }
                          }
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        ]
      },
      {
        tag: "main",
        class: "table-area",
        $slot: "$currentTable"
      },
      {
        tag: "aside",
        class: "detail-aside",
        children: [
          {
            tag: "button",
            class: "sidebar-toggle detail-toggle",
            attrs: {
              "aria-label": "Toggle detail sidebar"
            },
            text: "Details"
          },
          {
            tag: "div",
            class: "detail-content-wrapper",
            $slot: "$currentDetail"
          }
        ]
      }
    ]
  }
}, q0 = {
  $schema: "@maia/schema/view",
  $id: "@maia/db/view/table",
  content: {
    tag: "div",
    class: "table-container",
    children: [
      {
        tag: "table",
        class: "data-table",
        children: [
          {
            tag: "thead",
            children: [
              {
                tag: "tr",
                children: [
                  {
                    tag: "th",
                    text: "$tableHeaders.name"
                  },
                  {
                    tag: "th",
                    text: "$tableHeaders.email"
                  },
                  {
                    tag: "th",
                    text: "$tableHeaders.role"
                  },
                  {
                    tag: "th",
                    text: "$tableHeaders.status"
                  },
                  {
                    tag: "th",
                    text: "$tableHeaders.createdAt"
                  }
                ]
              }
            ]
          },
          {
            tag: "tbody",
            $each: {
              items: "$table",
              template: {
                tag: "tr",
                class: "table-row",
                attrs: {
                  data: {
                    selected: "$selectedRowItems.$$id"
                  }
                },
                children: [
                  {
                    tag: "td",
                    text: "$$name"
                  },
                  {
                    tag: "td",
                    text: "$$email"
                  },
                  {
                    tag: "td",
                    text: "$$role"
                  },
                  {
                    tag: "td",
                    text: "$$status"
                  },
                  {
                    tag: "td",
                    text: "$$createdAt"
                  }
                ],
                $on: {
                  click: {
                    send: "SELECT_ROW",
                    payload: {
                      rowId: "$$id"
                    }
                  }
                }
              }
            }
          }
        ]
      }
    ]
  }
}, x0 = {
  $schema: "@maia/schema/view",
  $id: "@maia/db/view/detail",
  content: {
    tag: "div",
    class: "detail-container",
    children: [
      {
        tag: "span",
        class: "detail-category",
        text: "Metadata"
      },
      {
        tag: "h2",
        class: "detail-title",
        text: "Entity Insight"
      },
      {
        tag: "div",
        class: "detail-list",
        children: [
          {
            tag: "div",
            class: "detail-item",
            children: [
              {
                tag: "span",
                class: "detail-label",
                text: "$detailLabels.id"
              },
              {
                tag: "span",
                class: "detail-value",
                text: "$detail.id"
              }
            ]
          },
          {
            tag: "div",
            class: "detail-item",
            children: [
              {
                tag: "span",
                class: "detail-label",
                text: "$detailLabels.name"
              },
              {
                tag: "span",
                class: "detail-value",
                text: "$detail.name"
              }
            ]
          },
          {
            tag: "div",
            class: "detail-item",
            children: [
              {
                tag: "span",
                class: "detail-label",
                text: "$detailLabels.email"
              },
              {
                tag: "span",
                class: "detail-value",
                text: "$detail.email"
              }
            ]
          },
          {
            tag: "div",
            class: "detail-item",
            children: [
              {
                tag: "span",
                class: "detail-label",
                text: "$detailLabels.role"
              },
              {
                tag: "span",
                class: "detail-value",
                text: "$detail.role"
              }
            ]
          },
          {
            tag: "div",
            class: "detail-item",
            children: [
              {
                tag: "span",
                class: "detail-label",
                text: "$detailLabels.status"
              },
              {
                tag: "span",
                class: "detail-value",
                text: "$detail.status"
              }
            ]
          },
          {
            tag: "div",
            class: "detail-item",
            children: [
              {
                tag: "span",
                class: "detail-label",
                text: "$detailLabels.createdAt"
              },
              {
                tag: "span",
                class: "detail-value",
                text: "$detail.createdAt"
              }
            ]
          },
          {
            tag: "div",
            class: "detail-item",
            children: [
              {
                tag: "span",
                class: "detail-label",
                text: "$detailLabels.lastLogin"
              },
              {
                tag: "span",
                class: "detail-value",
                text: "$detail.lastLogin"
              }
            ]
          },
          {
            tag: "div",
            class: "detail-item",
            children: [
              {
                tag: "span",
                class: "detail-label",
                text: "$detailLabels.bio"
              },
              {
                tag: "span",
                class: "detail-value",
                text: "$detail.bio"
              }
            ]
          },
          {
            tag: "div",
            class: "detail-item",
            children: [
              {
                tag: "span",
                class: "detail-label",
                text: "$detailLabels.department"
              },
              {
                tag: "span",
                class: "detail-value",
                text: "$detail.department"
              }
            ]
          },
          {
            tag: "div",
            class: "detail-item",
            children: [
              {
                tag: "span",
                class: "detail-label",
                text: "$detailLabels.phone"
              },
              {
                tag: "span",
                class: "detail-value",
                text: "$detail.phone"
              }
            ]
          }
        ]
      }
    ]
  }
}, L0 = {
  $schema: "@maia/schema/context",
  $id: "@maia/db/context/vibe",
  navTitle: "MaiaDB",
  navCategories: [
    {
      category: "Account",
      items: [
        {
          id: "account",
          label: "Owner"
        },
        {
          id: "group",
          label: "Avatar"
        }
      ]
    },
    {
      category: "Vibes",
      items: [
        {
          id: "maia-db",
          label: "MaiaDB"
        },
        {
          id: "todos",
          label: "Todos"
        }
      ]
    },
    {
      category: "OS",
      items: [
        {
          id: "schemata",
          label: "Schemata"
        },
        {
          id: "indexes",
          label: "Indexes"
        }
      ]
    }
  ],
  selectedNavId: "account",
  selectedRowId: "1",
  selectedNavItems: {
    account: !0
  },
  selectedRowItems: {
    1: !0
  },
  currentTable: "@table",
  currentDetail: "@detail",
  "@actors": {
    table: "@maia/db/actor/table",
    detail: "@maia/db/actor/detail"
  }
}, T0 = {
  $schema: "@maia/schema/context",
  $id: "@maia/db/context/table",
  table: [
    {
      id: "1",
      name: "John Doe",
      email: "john@example.com",
      role: "admin",
      status: "active",
      createdAt: "2024-01-15"
    },
    {
      id: "2",
      name: "Jane Smith",
      email: "jane@example.com",
      role: "user",
      status: "active",
      createdAt: "2024-01-20"
    },
    {
      id: "3",
      name: "Bob Johnson",
      email: "bob@example.com",
      role: "user",
      status: "inactive",
      createdAt: "2024-02-01"
    },
    {
      id: "4",
      name: "Alice Williams",
      email: "alice@example.com",
      role: "moderator",
      status: "active",
      createdAt: "2024-02-10"
    },
    {
      id: "5",
      name: "Charlie Brown",
      email: "charlie@example.com",
      role: "user",
      status: "pending",
      createdAt: "2024-02-15"
    }
  ],
  selectedRowId: null,
  tableHeaders: {
    name: "Name",
    email: "Email",
    role: "Role",
    status: "Status",
    createdAt: "Created"
  }
}, O0 = {
  $schema: "@maia/schema/context",
  $id: "@maia/db/context/detail",
  detail: {
    id: "1",
    name: "John Doe",
    email: "john@example.com",
    role: "admin",
    status: "active",
    createdAt: "2024-01-15",
    lastLogin: "2024-02-20",
    bio: "System administrator with 5 years of experience.",
    department: "IT",
    phone: "+1 (555) 123-4567"
  },
  detailLabels: {
    id: "ID",
    name: "Name",
    email: "Email",
    role: "Role",
    status: "Status",
    createdAt: "Created",
    lastLogin: "Last Login",
    bio: "Bio",
    department: "Department",
    phone: "Phone"
  }
}, P0 = {
  $schema: "@maia/schema/state",
  $id: "@maia/db/state/vibe",
  initial: "idle",
  states: {
    idle: {
      on: {
        SELECT_NAV: {
          target: "idle",
          actions: [
            {
              updateContext: {
                selectedNavId: "$$navId",
                selectedNavItems: {
                  $$navId: !0
                }
              }
            },
            {
              updateContext: {
                selectedRowId: null,
                selectedRowItems: {}
              }
            }
          ]
        },
        SELECT_ROW: {
          target: "idle",
          actions: [
            {
              updateContext: {
                selectedRowId: "$$rowId",
                selectedRowItems: {
                  $$rowId: !0
                }
              }
            }
          ]
        }
      }
    }
  }
}, j0 = {
  $schema: "@maia/schema/state",
  $id: "@maia/db/state/table",
  initial: "idle",
  states: {
    idle: {
      on: {
        SELECT_ROW: {
          target: "idle",
          actions: [
            {
              updateContext: {
                selectedRowId: "$$rowId"
              }
            }
          ]
        }
      }
    }
  }
}, V0 = {
  $schema: "@maia/schema/state",
  $id: "@maia/db/state/detail",
  initial: "idle",
  states: {
    idle: {}
  }
}, $0 = {
  $schema: "@maia/schema/inbox",
  $id: "@maia/db/inbox/vibe",
  cotype: "costream"
}, W0 = {
  $schema: "@maia/schema/inbox",
  $id: "@maia/db/inbox/table",
  cotype: "costream"
}, z0 = {
  $schema: "@maia/schema/inbox",
  $id: "@maia/db/inbox/detail",
  cotype: "costream"
}, $r = {
  vibe: K0,
  styles: {
    "@maia/db/style/brand": v0
  },
  actors: {
    "@maia/db/actor/vibe": Y0,
    "@maia/db/actor/table": U0,
    "@maia/db/actor/detail": J0
  },
  views: {
    "@maia/db/view/vibe": H0,
    "@maia/db/view/table": q0,
    "@maia/db/view/detail": x0
  },
  contexts: {
    "@maia/db/context/vibe": L0,
    "@maia/db/context/table": T0,
    "@maia/db/context/detail": O0
  },
  states: {
    "@maia/db/state/vibe": P0,
    "@maia/db/state/table": j0,
    "@maia/db/state/detail": V0
  },
  inboxes: {
    "@maia/db/inbox/vibe": $0,
    "@maia/db/inbox/table": W0,
    "@maia/db/inbox/detail": z0
  },
  // No initial data - this vibe uses mocked data in context
  data: {}
}, _0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DbVibeRegistry: $r
}, Symbol.toStringTag, { value: "Module" })), Z0 = {
  $schema: "@maia/schema/vibe",
  $id: "@maia/vibe/sparks",
  name: "Sparks",
  description: "Create and manage collaborative groups (sparks)",
  actor: "@maia/sparks/actor/vibe"
}, X0 = {
  $schema: "@maia/schema/style",
  $id: "@maia/sparks/style/brand",
  tokens: {
    colors: {
      marineBlue: "#001F33",
      marineBlueMuted: "#2D4A5C",
      marineBlueLight: "#5E7A8C",
      paradiseWater: "#00BDD6",
      lushGreen: "#4E9A58",
      terracotta: "#C27B66",
      sunYellow: "#E6B94D",
      softClay: "#E8E1D9",
      tintedWhite: "#F0EDE6",
      background: "transparent",
      foreground: "#001F33",
      primary: "#00BDD6",
      secondary: "#2D4A5C",
      border: "rgba(255, 255, 255, 0.1)",
      surface: "rgba(255, 255, 255, 0.3)",
      glass: "rgba(255, 255, 255, 0.0005)",
      glassStrong: "rgba(255, 255, 255, 0.15)",
      error: "#DC3545",
      errorBg: "rgba(220, 53, 69, 0.1)",
      errorBorder: "rgba(220, 53, 69, 0.2)",
      text: {
        marine: "#D1E8F7",
        water: "#004D59",
        green: "#F0F9F1",
        terracotta: "#FDF2EF",
        yellow: "#4D3810"
      }
    },
    spacing: {
      xs: "0.5rem",
      sm: "0.75rem",
      md: "1rem",
      lg: "1.5rem",
      xl: "2rem",
      "2xl": "3rem"
    },
    typography: {
      fontFamily: {
        heading: "'Indie Flower', cursive",
        body: "'Plus Jakarta Sans', sans-serif"
      },
      fontWeight: {
        light: "300",
        normal: "400",
        medium: "500",
        semibold: "600",
        bold: "700"
      }
    },
    radii: {
      sm: "4px",
      md: "12px",
      apple: "18px",
      full: "9999px"
    },
    shadows: {
      sm: "0 4px 30px rgba(0, 0, 0, 0.05)",
      md: "0 10px 30px rgba(0, 0, 0, 0.05)",
      lg: "0 10px 40px rgba(0, 0, 0, 0.1)"
    },
    transitions: {
      fast: "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)",
      standard: "all 0.5s cubic-bezier(0.2, 0, 0.2, 1)"
    }
  },
  components: {
    stack: {
      display: "flex",
      flexDirection: "column",
      gap: "0.25rem",
      width: "100%",
      maxWidth: "100%",
      height: "100vh",
      background: "{colors.softClay}",
      padding: "0.375rem",
      overflowY: "auto",
      overflowX: "hidden",
      fontFamily: "{typography.fontFamily.body}",
      color: "{colors.marineBlue}",
      boxSizing: "border-box"
    },
    headerSection: {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      gap: "0.25rem",
      marginBottom: "0.25rem",
      width: "100%"
    },
    sparksTitle: {
      fontFamily: "{typography.fontFamily.heading}",
      fontSize: "0.9rem",
      fontWeight: "{typography.fontWeight.bold}",
      color: "{colors.marineBlue}",
      margin: "0",
      marginBottom: "0.375rem",
      textAlign: "center",
      width: "100%",
      letterSpacing: "-0.02em"
    },
    form: {
      display: "flex",
      flexDirection: "row",
      alignItems: "center",
      gap: "0.25rem",
      padding: "0.25rem 0.375rem",
      background: "rgba(255, 255, 255, 0.4)",
      backdropFilter: "blur(8px) saturate(150%)",
      borderRadius: "{radii.full}",
      border: "1px solid {colors.border}",
      boxShadow: "{shadows.md}",
      width: "100%",
      boxSizing: "border-box",
      marginBottom: "0.25rem"
    },
    input: {
      flex: "1",
      width: "100%",
      padding: "0.25rem 0.5rem",
      border: "none",
      background: "transparent",
      fontSize: "0.6rem",
      color: "{colors.marineBlue}",
      fontFamily: "{typography.fontFamily.body}",
      fontWeight: "{typography.fontWeight.light}",
      outline: "none",
      minHeight: "0",
      minWidth: "0",
      lineHeight: "1.35"
    },
    button: {
      width: "auto",
      padding: "0.25rem 0.5rem",
      background: "{colors.lushGreen}",
      color: "{colors.text.green}",
      border: "none",
      borderRadius: "{radii.full}",
      cursor: "pointer",
      fontSize: "0.5rem",
      fontWeight: "600",
      textTransform: "uppercase",
      letterSpacing: "0.05em",
      transition: "{transitions.fast}",
      boxShadow: "0 4px 12px rgba(78, 154, 88, 0.2)",
      whiteSpace: "nowrap",
      flexShrink: "0",
      ":hover": {
        filter: "brightness(1.1)",
        transform: "translateY(-1px)",
        boxShadow: "0 6px 16px rgba(78, 154, 88, 0.3)"
      }
    },
    errorMessage: {
      padding: "{spacing.sm} {spacing.md}",
      background: "{colors.errorBg}",
      color: "{colors.error}",
      borderRadius: "{radii.md}",
      border: "1px solid {colors.errorBorder}",
      margin: "{spacing.md} 0",
      display: "none",
      data: {
        hasError: {
          true: {
            display: "block"
          }
        }
      }
    },
    buttonDismiss: {
      marginLeft: "{spacing.sm}",
      padding: "0.25rem 0.5rem",
      background: "transparent",
      color: "{colors.error}",
      border: "1px solid {colors.errorBorder}",
      borderRadius: "{radii.sm}",
      cursor: "pointer",
      fontSize: "0.5rem",
      fontWeight: "600",
      transition: "{transitions.fast}",
      ":hover": {
        background: "{colors.error}",
        color: "white"
      }
    },
    sparksList: {
      display: "flex",
      flexDirection: "column",
      gap: "0.25rem",
      width: "100%"
    },
    sparkItem: {
      padding: "0.5rem 0.75rem",
      background: "rgba(255, 255, 255, 0.3)",
      backdropFilter: "blur(4px)",
      borderRadius: "{radii.md}",
      border: "1px solid {colors.border}",
      boxShadow: "{shadows.sm}",
      display: "flex",
      flexDirection: "column",
      gap: "0.25rem"
    },
    sparkName: {
      fontFamily: "{typography.fontFamily.heading}",
      fontSize: "0.75rem",
      fontWeight: "{typography.fontWeight.bold}",
      color: "{colors.marineBlue}",
      margin: "0"
    },
    sparkGroupId: {
      fontSize: "0.6rem",
      color: "{colors.marineBlueLight}",
      fontFamily: "{typography.fontFamily.body}"
    },
    splitContainer: {
      display: "flex",
      flexDirection: "row",
      gap: "{spacing.md}",
      width: "100%",
      height: "100%",
      overflow: "hidden"
    },
    sparksListPanel: {
      width: "50%",
      display: "flex",
      flexDirection: "column",
      overflowY: "auto",
      overflowX: "hidden",
      paddingRight: "{spacing.sm}"
    },
    sparksDetailPanel: {
      width: "50%",
      display: "flex",
      flexDirection: "column",
      overflowY: "auto",
      overflowX: "hidden",
      paddingLeft: "{spacing.sm}"
    },
    detailContentWrapper: {
      display: "flex",
      flexDirection: "column",
      height: "100%",
      width: "100%"
    },
    detailContainer: {
      background: "rgba(255, 255, 255, 0.4)",
      backdropFilter: "blur(12px) saturate(160%)",
      borderRadius: "{radii.apple}",
      boxShadow: "{shadows.md}",
      overflow: "auto",
      border: "1px solid rgba(255, 255, 255, 0.2)",
      transition: "{transitions.standard}",
      height: "100%",
      display: "flex",
      flexDirection: "column",
      padding: "{spacing.md}"
    },
    detailCategory: {
      fontFamily: "{typography.fontFamily.heading}",
      fontSize: "0.85rem",
      fontStyle: "italic",
      color: "{colors.paradiseWater}",
      marginBottom: "0.5rem",
      display: "block",
      textShadow: "0 0 10px rgba(0, 189, 214, 0.2)"
    },
    detailTitle: {
      fontFamily: "{typography.fontFamily.heading}",
      fontSize: "{typography.fontSize.xl}",
      fontWeight: "{typography.fontWeight.bold}",
      color: "{colors.marineBlue}",
      marginBottom: "{spacing.md}",
      marginTop: "0",
      letterSpacing: "-0.02em"
    },
    detailList: {
      display: "flex",
      flexDirection: "column",
      gap: "{spacing.sm}"
    },
    detailItem: {
      display: "flex",
      flexDirection: "row",
      justifyContent: "space-between",
      alignItems: "center",
      padding: "{spacing.sm}",
      background: "rgba(255, 255, 255, 0.2)",
      borderRadius: "{radii.md}",
      gap: "{spacing.md}"
    },
    detailLabel: {
      fontWeight: "{typography.fontWeight.semibold}",
      color: "{colors.marineBlueLight}",
      fontSize: "0.75rem"
    },
    detailValue: {
      color: "{colors.marineBlue}",
      fontSize: "0.75rem",
      fontFamily: "{typography.fontFamily.body}",
      wordBreak: "break-all"
    },
    membersTitle: {
      fontFamily: "{typography.fontFamily.heading}",
      fontSize: "{typography.fontSize.lg}",
      fontWeight: "{typography.fontWeight.bold}",
      color: "{colors.marineBlue}",
      marginTop: "{spacing.lg}",
      marginBottom: "{spacing.md}"
    },
    membersList: {
      display: "flex",
      flexDirection: "column",
      gap: "{spacing.sm}"
    },
    memberItem: {
      display: "flex",
      flexDirection: "row",
      justifyContent: "space-between",
      alignItems: "center",
      padding: "{spacing.sm}",
      background: "rgba(255, 255, 255, 0.3)",
      borderRadius: "{radii.md}",
      border: "1px solid {colors.border}",
      gap: "{spacing.md}"
    },
    memberId: {
      color: "{colors.marineBlue}",
      fontSize: "0.7rem",
      fontFamily: "{typography.fontFamily.body}",
      wordBreak: "break-all",
      flex: "1"
    },
    memberRole: {
      padding: "0.25rem 0.5rem",
      borderRadius: "{radii.sm}",
      fontSize: "0.6rem",
      fontWeight: "{typography.fontWeight.bold}",
      textTransform: "uppercase",
      letterSpacing: "0.05em"
    },
    memberRemoveButton: {
      padding: "0.15rem 0.4rem",
      minWidth: "1.5rem",
      fontSize: "1rem",
      lineHeight: "1",
      color: "#DC3545",
      background: "rgba(220, 53, 69, 0.15)",
      border: "1px solid rgba(220, 53, 69, 0.4)",
      borderRadius: "{radii.sm}",
      cursor: "pointer"
    }
  },
  selectors: {
    ":host": {
      display: "block",
      height: "100%",
      background: "transparent"
    },
    ".spark-item[data-selected='true']": {
      background: "rgba(0, 189, 214, 0.2)",
      borderColor: "{colors.paradiseWater}",
      boxShadow: "0 4px 12px rgba(0, 189, 214, 0.3)"
    },
    ".spark-item:hover": {
      background: "rgba(255, 255, 255, 0.5)",
      cursor: "pointer",
      transform: "translateY(-1px)",
      boxShadow: "{shadows.md}"
    },
    ".member-role[data-role='admin']": {
      background: "rgba(220, 53, 69, 0.2)",
      color: "#DC3545",
      border: "1px solid rgba(220, 53, 69, 0.3)"
    },
    ".member-role[data-role='manager']": {
      background: "rgba(255, 193, 7, 0.2)",
      color: "#FFC107",
      border: "1px solid rgba(255, 193, 7, 0.3)"
    },
    ".member-role[data-role='writer']": {
      background: "rgba(78, 154, 88, 0.2)",
      color: "{colors.lushGreen}",
      border: "1px solid rgba(78, 154, 88, 0.3)"
    },
    ".member-role[data-role='reader']": {
      background: "rgba(0, 189, 214, 0.2)",
      color: "{colors.paradiseWater}",
      border: "1px solid rgba(0, 189, 214, 0.3)"
    },
    ".member-role[data-role='writeOnly']": {
      background: "rgba(230, 185, 77, 0.2)",
      color: "{colors.sunYellow}",
      border: "1px solid rgba(230, 185, 77, 0.3)"
    },
    ".empty-state": {
      display: "none",
      padding: "{spacing.lg}",
      textAlign: "center",
      color: "{colors.marineBlueLight}",
      fontSize: "0.85rem"
    },
    ".empty-state[data-visible='true']": {
      display: "block"
    },
    ".loading-state": {
      display: "none",
      padding: "{spacing.lg}",
      textAlign: "center",
      color: "{colors.marineBlueLight}",
      fontSize: "0.85rem"
    },
    ".loading-state[data-visible='true']": {
      display: "block"
    },
    ".error-state": {
      display: "none",
      padding: "{spacing.md}",
      background: "{colors.errorBg}",
      color: "{colors.error}",
      borderRadius: "{radii.md}",
      border: "1px solid {colors.errorBorder}",
      marginBottom: "{spacing.md}"
    },
    ".error-state[data-visible='true']": {
      display: "block"
    },
    ".detail-content": {
      display: "none"
    },
    ".detail-content[data-visible='true']": {
      display: "flex",
      flexDirection: "column"
    },
    ".empty-members": {
      display: "none",
      padding: "{spacing.md}",
      textAlign: "center",
      color: "{colors.marineBlueLight}",
      fontSize: "0.75rem"
    },
    ".empty-members[data-visible='true']": {
      display: "block"
    },
    "@container {containerName} (min-width: {containers.xs})": {
      ".stack": {
        padding: "0.625rem",
        gap: "0.375rem"
      },
      ".headerSection": {
        gap: "0.375rem",
        marginBottom: "0.375rem"
      },
      ".sparksTitle": {
        fontSize: "1.15rem"
      },
      ".form": {
        gap: "0.375rem",
        padding: "0.375rem 0.5rem"
      },
      ".input": {
        padding: "0.375rem 0.625rem",
        fontSize: "0.7rem"
      },
      ".button": {
        padding: "0.375rem 0.625rem",
        fontSize: "0.6rem"
      },
      ".sparkItem": {
        padding: "0.625rem 0.875rem"
      },
      ".sparkName": {
        fontSize: "0.85rem"
      },
      ".sparkGroupId": {
        fontSize: "0.65rem"
      }
    },
    "@container {containerName} (min-width: {containers.sm})": {
      ".stack": {
        padding: "0.75rem",
        gap: "0.5rem"
      },
      ".headerSection": {
        gap: "0.5rem",
        marginBottom: "0.5rem"
      },
      ".sparksTitle": {
        fontSize: "1.3rem"
      },
      ".form": {
        gap: "0.5rem",
        padding: "0.5rem 0.625rem"
      },
      ".input": {
        padding: "0.5rem 0.75rem",
        fontSize: "0.75rem"
      },
      ".button": {
        padding: "0.5rem 0.75rem",
        fontSize: "0.65rem"
      },
      ".sparkItem": {
        padding: "0.75rem 1rem"
      },
      ".sparkName": {
        fontSize: "0.95rem"
      },
      ".sparkGroupId": {
        fontSize: "0.7rem"
      }
    },
    "@container {containerName} (min-width: {containers.md})": {
      ".stack": {
        padding: "1rem",
        gap: "0.625rem"
      },
      ".headerSection": {
        gap: "0.625rem",
        marginBottom: "0.625rem"
      },
      ".sparksTitle": {
        fontSize: "1.45rem"
      },
      ".form": {
        gap: "0.625rem",
        padding: "0.625rem 0.75rem"
      },
      ".input": {
        padding: "0.625rem 0.875rem",
        fontSize: "0.8rem"
      },
      ".button": {
        padding: "0.625rem 0.875rem",
        fontSize: "0.7rem"
      },
      ".sparkItem": {
        padding: "0.875rem 1.125rem"
      },
      ".sparkName": {
        fontSize: "1.1rem"
      },
      ".sparkGroupId": {
        fontSize: "0.75rem"
      }
    },
    "@container {containerName} (min-width: {containers.lg})": {
      ".stack": {
        padding: "1.25rem",
        gap: "0.75rem"
      },
      ".headerSection": {
        gap: "0.75rem",
        marginBottom: "0.75rem"
      },
      ".sparksTitle": {
        fontSize: "1.55rem"
      },
      ".form": {
        gap: "0.75rem",
        padding: "0.75rem 0.875rem"
      },
      ".input": {
        padding: "0.75rem 1rem",
        fontSize: "0.85rem"
      },
      ".button": {
        padding: "0.75rem 1rem",
        fontSize: "0.75rem"
      },
      ".sparkItem": {
        padding: "1rem 1.25rem"
      },
      ".sparkName": {
        fontSize: "1.2rem"
      },
      ".sparkGroupId": {
        fontSize: "0.8rem"
      }
    },
    "@container {containerName} (min-width: {containers.xl})": {
      ".stack": {
        padding: "1.5rem",
        gap: "0.875rem"
      },
      ".headerSection": {
        gap: "0.875rem",
        marginBottom: "0.875rem"
      },
      ".sparksTitle": {
        fontSize: "1.65rem"
      },
      ".form": {
        gap: "0.875rem",
        padding: "0.875rem 1rem"
      },
      ".input": {
        padding: "0.875rem 1.125rem",
        fontSize: "0.9rem"
      },
      ".button": {
        padding: "0.875rem 1.125rem",
        fontSize: "0.8rem"
      },
      ".sparkItem": {
        padding: "1.125rem 1.375rem"
      },
      ".sparkName": {
        fontSize: "1.3rem"
      },
      ".sparkGroupId": {
        fontSize: "0.85rem"
      }
    },
    "@container {containerName} (min-width: {containers.2xl})": {
      ".stack": {
        padding: "1.75rem",
        gap: "1rem"
      },
      ".headerSection": {
        gap: "1rem",
        marginBottom: "1rem"
      },
      ".sparksTitle": {
        fontSize: "1.75rem"
      },
      ".form": {
        gap: "1rem",
        padding: "1rem 1.125rem"
      },
      ".input": {
        padding: "1rem 1.25rem",
        fontSize: "0.95rem"
      },
      ".button": {
        padding: "1rem 1.25rem",
        fontSize: "0.85rem"
      },
      ".sparkItem": {
        padding: "1.25rem 1.5rem"
      },
      ".sparkName": {
        fontSize: "1.4rem"
      },
      ".sparkGroupId": {
        fontSize: "0.9rem"
      }
    }
  }
}, Ak = {
  $schema: "@maia/schema/actor",
  $id: "@maia/sparks/actor/vibe",
  type: "service",
  state: "@maia/sparks/state/vibe",
  view: "@maia/sparks/view/vibe",
  context: "@maia/sparks/context/vibe",
  brand: "@maia/sparks/style/brand",
  inbox: "@maia/sparks/inbox/vibe",
  messageTypes: [
    "CREATE_BUTTON",
    "UPDATE_INPUT",
    "SELECT_SPARK",
    "SUCCESS",
    "ERROR",
    "DISMISS"
  ]
}, ek = {
  $schema: "@maia/schema/actor",
  $id: "@maia/sparks/actor/detail",
  role: "ui",
  context: "@maia/sparks/context/detail",
  view: "@maia/sparks/view/detail",
  state: "@maia/sparks/state/detail",
  brand: "@maia/sparks/style/brand",
  inbox: "@maia/sparks/inbox/detail",
  messageTypes: [
    "LOAD_ACTOR",
    "SUCCESS",
    "ADD_AGENT",
    "REMOVE_MEMBER",
    "UPDATE_AGENT_INPUT",
    "ERROR"
  ]
}, tk = {
  $schema: "@maia/schema/view",
  $id: "@maia/sparks/view/vibe",
  content: {
    tag: "div",
    class: "stack",
    children: [
      {
        tag: "div",
        class: "header-section",
        children: [
          {
            tag: "h2",
            class: "sparks-title",
            text: "My Sparks"
          }
        ]
      },
      {
        class: "form",
        children: [
          {
            tag: "input",
            class: "input",
            attrs: {
              type: "text",
              placeholder: "$inputPlaceholder"
            },
            value: "$newSparkName",
            $on: {
              input: {
                send: "UPDATE_INPUT",
                payload: {
                  value: "@inputValue"
                }
              },
              blur: {
                send: "UPDATE_INPUT",
                payload: {
                  value: "@inputValue"
                }
              },
              keydown: {
                send: "CREATE_BUTTON",
                payload: {
                  value: "@inputValue"
                },
                key: "Enter"
              }
            }
          },
          {
            tag: "button",
            class: "button",
            text: "$createButtonText",
            $on: {
              click: {
                send: "CREATE_BUTTON",
                payload: {
                  value: "@inputValue"
                }
              }
            }
          }
        ]
      },
      {
        tag: "div",
        class: "error-message",
        attrs: {
          data: {
            hasError: "$hasError"
          }
        },
        children: [
          {
            tag: "strong",
            text: "Error: "
          },
          {
            text: "$error"
          },
          {
            tag: "button",
            class: "button-dismiss",
            text: "Dismiss",
            $on: {
              click: {
                send: "DISMISS"
              }
            }
          }
        ]
      },
      {
        tag: "div",
        class: "split-container",
        children: [
          {
            tag: "div",
            class: "sparks-list-panel",
            children: [
              {
                tag: "div",
                class: "sparks-list",
                $each: {
                  items: "$sparks",
                  template: {
                    tag: "div",
                    class: "spark-item",
                    children: [
                      {
                        tag: "h3",
                        class: "spark-name",
                        text: "$$name"
                      }
                    ],
                    $on: {
                      click: {
                        send: "SELECT_SPARK",
                        payload: {
                          sparkId: "$$id"
                        }
                      }
                    }
                  }
                }
              }
            ]
          },
          {
            tag: "div",
            class: "sparks-detail-panel",
            children: [
              {
                tag: "div",
                class: "detail-content-wrapper",
                $slot: "$currentDetail"
              }
            ]
          }
        ]
      }
    ]
  }
}, ik = {
  $schema: "@maia/schema/view",
  $id: "@maia/sparks/view/detail",
  content: {
    tag: "div",
    class: "detail-container",
    children: [
      {
        tag: "div",
        class: "empty-state",
        attrs: {
          data: {
            visible: "$showEmptyState"
          }
        },
        children: [
          {
            tag: "p",
            text: "Select a spark to view details and members"
          }
        ]
      },
      {
        tag: "div",
        class: "detail-content",
        attrs: {
          data: {
            visible: "$showContent"
          }
        },
        children: [
          {
            tag: "span",
            class: "detail-category",
            text: "Spark Details"
          },
          {
            tag: "h2",
            class: "detail-title",
            text: "$sparkDetails.name"
          },
          {
            tag: "div",
            class: "detail-list",
            children: [
              {
                tag: "div",
                class: "detail-item",
                children: [
                  {
                    tag: "span",
                    class: "detail-label",
                    text: "Group ID"
                  },
                  {
                    tag: "span",
                    class: "detail-value",
                    text: "$sparkDetails.groupId"
                  }
                ]
              }
            ]
          },
          {
            tag: "h3",
            class: "members-title",
            text: "Members"
          },
          {
            tag: "div",
            class: "members-list",
            $each: {
              items: "$sparkDetails.members",
              template: {
                tag: "div",
                class: "member-item",
                children: [
                  {
                    tag: "span",
                    class: "member-id",
                    text: "$$id"
                  },
                  {
                    tag: "span",
                    class: "member-role",
                    attrs: {
                      data: {
                        role: "$$role"
                      }
                    },
                    text: "$$role"
                  },
                  {
                    tag: "button",
                    class: "member-remove-button",
                    text: "",
                    $on: {
                      click: {
                        send: "REMOVE_MEMBER",
                        payload: {
                          memberId: "$$id"
                        }
                      }
                    }
                  }
                ]
              }
            }
          },
          {
            tag: "h3",
            class: "members-title add-agent-title",
            text: "Add Agent"
          },
          {
            tag: "div",
            class: "form add-agent-form",
            children: [
              {
                tag: "input",
                class: "input",
                attrs: {
                  type: "text",
                  placeholder: "Agent account co-id (e.g. co_z...)"
                },
                value: "$agentIdInput",
                $on: {
                  input: {
                    send: "UPDATE_AGENT_INPUT",
                    payload: {
                      value: "@inputValue"
                    }
                  },
                  blur: {
                    send: "UPDATE_AGENT_INPUT",
                    payload: {
                      value: "@inputValue"
                    }
                  },
                  keydown: {
                    send: "ADD_AGENT",
                    payload: {
                      agentId: "@inputValue"
                    },
                    key: "Enter"
                  }
                }
              },
              {
                tag: "button",
                class: "button",
                text: "Add as writer",
                $on: {
                  click: {
                    send: "ADD_AGENT",
                    payload: {
                      agentId: "$agentIdInput"
                    }
                  }
                }
              }
            ]
          },
          {
            tag: "div",
            class: "error-message add-agent-error",
            attrs: {
              data: {
                hasError: "$addAgentHasError"
              }
            },
            children: [
              {
                tag: "strong",
                text: "Error: "
              },
              {
                text: "$addAgentError"
              }
            ]
          }
        ]
      }
    ]
  }
}, ok = {
  $schema: "@maia/schema/context",
  $id: "@maia/sparks/context/vibe",
  sparks: {
    schema: "@maia/schema/data/spark"
  },
  newSparkName: "",
  inputPlaceholder: "Enter spark name...",
  createButtonText: "Create Spark",
  error: null,
  hasError: !1,
  loading: !1,
  selectedSparkId: null,
  selectedSparkItems: {},
  currentDetail: "@detail",
  "@actors": {
    detail: "@maia/sparks/actor/detail"
  }
}, rk = {
  $schema: "@maia/schema/context",
  $id: "@maia/sparks/context/detail",
  sparkId: null,
  sparkDetails: {
    schema: "@maia/schema/data/spark",
    filter: {
      id: "$sparkId"
    },
    options: {
      map: {
        members: "$$os.capabilities.guardian.accountMembers",
        groupId: "$$os.capabilities.guardian.id"
      }
    }
  },
  hasSpark: !1,
  showEmptyState: !0,
  showContent: !1,
  agentIdInput: "",
  addAgentError: null,
  addAgentHasError: !1
}, nk = {
  $schema: "@maia/schema/state",
  $id: "@maia/sparks/state/vibe",
  initial: "idle",
  states: {
    idle: {
      on: {
        CREATE_BUTTON: {
          target: "creating"
        },
        UPDATE_INPUT: {
          target: "idle",
          actions: [
            {
              updateContext: {
                newSparkName: "$$value"
              }
            }
          ]
        },
        SELECT_SPARK: {
          target: "idle",
          actions: [
            {
              updateContext: {
                selectedSparkId: "$$sparkId"
              }
            },
            "sendToDetailActor"
          ]
        }
      }
    },
    creating: {
      entry: {
        tool: "@sparks",
        payload: {
          op: "createSpark",
          name: "$$value"
        }
      },
      on: {
        SUCCESS: {
          target: "idle",
          actions: [
            {
              updateContext: {
                newSparkName: "",
                error: null,
                hasError: !1
              }
            }
          ]
        },
        ERROR: {
          target: "idle",
          actions: [
            {
              updateContext: {
                error: "$$errors.0.message",
                hasError: !0
              }
            }
          ]
        }
      }
    },
    error: {
      entry: {
        updateContext: {
          error: "$$errors.0.message"
        }
      },
      on: {
        DISMISS: {
          target: "idle",
          actions: [
            {
              updateContext: {
                error: null,
                hasError: !1
              }
            }
          ]
        }
      }
    }
  }
}, sk = {
  $schema: "@maia/schema/state",
  $id: "@maia/sparks/state/detail",
  initial: "idle",
  states: {
    idle: {
      on: {
        LOAD_ACTOR: {
          target: "updating",
          actions: [
            {
              updateContext: {
                sparkId: "$$id"
              }
            }
          ]
        },
        UPDATE_AGENT_INPUT: {
          target: "idle",
          actions: [
            {
              updateContext: {
                agentIdInput: "$$value"
              }
            }
          ]
        },
        ADD_AGENT: {
          target: "addingAgent"
        },
        REMOVE_MEMBER: {
          target: "removingMember"
        }
      },
      entry: {
        updateContext: {
          hasSpark: {
            $ne: [
              "$sparkId",
              null
            ]
          },
          showEmptyState: {
            $eq: [
              "$sparkId",
              null
            ]
          },
          showContent: {
            $ne: [
              "$sparkId",
              null
            ]
          }
        }
      }
    },
    updating: {
      entry: {
        updateContext: {
          hasSpark: {
            $ne: [
              "$sparkId",
              null
            ]
          },
          showEmptyState: {
            $eq: [
              "$sparkId",
              null
            ]
          },
          showContent: {
            $ne: [
              "$sparkId",
              null
            ]
          }
        }
      },
      on: {
        SUCCESS: {
          target: "idle"
        }
      }
    },
    addingAgent: {
      entry: {
        tool: "@sparks",
        payload: {
          op: "addSparkMember",
          id: "$sparkId",
          memberId: "$$agentId",
          role: "writer"
        }
      },
      on: {
        SUCCESS: {
          target: "idle",
          actions: [
            {
              updateContext: {
                agentIdInput: "",
                addAgentError: null,
                addAgentHasError: !1
              }
            }
          ]
        },
        ERROR: {
          target: "idle",
          actions: [
            {
              updateContext: {
                addAgentError: "$$errors.0.message",
                addAgentHasError: !0
              }
            }
          ]
        }
      }
    },
    removingMember: {
      entry: {
        tool: "@sparks",
        payload: {
          op: "removeSparkMember",
          id: "$sparkId",
          memberId: "$$memberId"
        }
      },
      on: {
        SUCCESS: {
          target: "idle"
        },
        ERROR: {
          target: "idle"
        }
      }
    }
  }
}, ak = {
  $schema: "@maia/schema/inbox",
  $id: "@maia/sparks/inbox/vibe",
  cotype: "costream"
}, gk = {
  $schema: "@maia/schema/inbox",
  $id: "@maia/sparks/inbox/detail",
  cotype: "costream"
}, Wr = {
  vibe: Z0,
  styles: {
    "@maia/sparks/style/brand": X0
  },
  actors: {
    "@maia/sparks/actor/vibe": Ak,
    "@maia/sparks/actor/detail": ek
  },
  views: {
    "@maia/sparks/view/vibe": tk,
    "@maia/sparks/view/detail": ik
  },
  contexts: {
    "@maia/sparks/context/vibe": ok,
    "@maia/sparks/context/detail": rk
  },
  states: {
    "@maia/sparks/state/vibe": nk,
    "@maia/sparks/state/detail": sk
  },
  inboxes: {
    "@maia/sparks/inbox/vibe": ak,
    "@maia/sparks/inbox/detail": gk
  }
}, Ik = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  SparksVibeRegistry: Wr
}, Symbol.toStringTag, { value: "Module" }));
async function ck() {
  const t = [];
  try {
    const { TodosVibeRegistry: A } = await Promise.resolve().then(() => R0);
    A && A.vibe && t.push(A);
  } catch (A) {
    console.warn("[Vibes] Could not load TodosVibeRegistry:", A.message);
  }
  try {
    const { ChatVibeRegistry: A } = await Promise.resolve().then(() => yk);
    A && A.vibe && t.push(A);
  } catch (A) {
    console.warn("[Vibes] Could not load ChatVibeRegistry:", A.message);
  }
  try {
    const { DbVibeRegistry: A } = await Promise.resolve().then(() => _0);
    A && A.vibe && t.push(A);
  } catch (A) {
    console.warn("[Vibes] Could not load DbVibeRegistry:", A.message);
  }
  try {
    const { SparksVibeRegistry: A } = await Promise.resolve().then(() => Ik);
    A && A.vibe && t.push(A);
  } catch (A) {
    console.warn("[Vibes] Could not load SparksVibeRegistry:", A.message);
  }
  try {
    const { CreatorVibeRegistry: A } = await Promise.resolve().then(() => bk);
    A && A.vibe && t.push(A);
  } catch (A) {
    console.warn("[Vibes] Could not load CreatorVibeRegistry:", A.message);
  }
  return t;
}
function Ck(t) {
  if (!t) return null;
  const A = t.$id || "";
  return A.startsWith("@maia/vibe/") ? A.replace("@maia/vibe/", "") : (t.name || "default").toLowerCase().replace(/\s+/g, "-");
}
function Bk(t, A = null) {
  if (A == null || Array.isArray(A) && A.length === 0)
    return [];
  if (A === "all")
    return t;
  if (Array.isArray(A)) {
    const e = A.map((i) => i.toLowerCase().trim());
    return t.filter((i) => {
      if (!i.vibe) return !1;
      const o = Ck(i.vibe);
      return e.includes(o);
    });
  }
  return console.warn(`[Vibes] Invalid seeding config: ${A}. Expected null, "all", or array of vibe keys.`), [];
}
const Qk = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DbRegistry: $r,
  DbVibeRegistry: $r,
  MaiaOS: se,
  SparksRegistry: Wr,
  SparksVibeRegistry: Wr,
  TodosRegistry: Vr,
  TodosVibeRegistry: Vr,
  filterVibesForSeeding: Bk,
  getAllVibeRegistries: ck
}, Symbol.toStringTag, { value: "Module" })), Ek = {
  $schema: "@maia/schema/vibe",
  $id: "@maia/vibe/chat",
  name: "Chat",
  description: "CTO-level AI assistant for MaiaOS codebase",
  actor: "@maia/chat/actor/vibe"
}, lk = {
  $schema: "@maia/schema/style",
  $id: "@maia/chat/style/brand",
  tokens: {
    colors: {
      marineBlue: "#001F33",
      marineBlueMuted: "#2D4A5C",
      marineBlueLight: "#5E7A8C",
      paradiseWater: "#00BDD6",
      lushGreen: "#4E9A58",
      terracotta: "#C27B66",
      sunYellow: "#E6B94D",
      softClay: "#E8E1D9",
      tintedWhite: "#F0EDE6",
      background: "transparent",
      foreground: "#001F33",
      primary: "#00BDD6",
      secondary: "#2D4A5C",
      border: "rgba(255, 255, 255, 0.1)",
      surface: "rgba(255, 255, 255, 0.3)",
      glass: "rgba(255, 255, 255, 0.0005)",
      glassStrong: "rgba(255, 255, 255, 0.15)",
      text: {
        marine: "#D1E8F7",
        water: "#004D59",
        green: "#F0F9F1",
        terracotta: "#FDF2EF",
        yellow: "#4D3810"
      }
    },
    spacing: {
      xs: "0.5rem",
      sm: "0.75rem",
      md: "1rem",
      lg: "1.5rem",
      xl: "2rem",
      "2xl": "3rem"
    },
    typography: {
      fontFamily: {
        heading: "'Indie Flower', cursive",
        body: "'Plus Jakarta Sans', sans-serif"
      },
      fontWeight: {
        light: "300",
        normal: "400",
        medium: "500",
        semibold: "600",
        bold: "700"
      }
    },
    radii: {
      sm: "4px",
      md: "12px",
      apple: "18px",
      full: "9999px"
    },
    shadows: {
      sm: "0 4px 30px rgba(0, 0, 0, 0.05)",
      md: "0 10px 30px rgba(0, 0, 0, 0.05)",
      lg: "0 10px 40px rgba(0, 0, 0, 0.1)"
    },
    transitions: {
      fast: "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)",
      standard: "all 0.5s cubic-bezier(0.2, 0, 0.2, 1)"
    }
  },
  selectors: {
    ":host": {
      display: "block",
      height: "100%",
      background: "{colors.background}",
      fontFamily: "{typography.fontFamily.body}",
      color: "{colors.marineBlue}"
    },
    ".chatContainer": {
      display: "grid",
      gridTemplateRows: "1fr auto",
      height: "100%",
      minHeight: "0",
      maxHeight: "100%",
      position: "relative",
      overflow: "hidden",
      background: "{colors.softClay}",
      padding: "{spacing.sm}",
      gap: "{spacing.sm}"
    },
    ".messagesContainer": {
      gridRow: "1",
      overflowY: "auto",
      overflowX: "hidden",
      padding: "{spacing.sm}",
      display: "flex",
      flexDirection: "column",
      gap: "{spacing.md}",
      minHeight: "0",
      maxHeight: "100%",
      position: "relative",
      zIndex: "1",
      background: "rgba(255, 255, 255, 0.4)",
      backdropFilter: "blur(8px) saturate(150%)",
      borderRadius: "{radii.apple}",
      border: "1px solid {colors.border}",
      boxShadow: "{shadows.md}"
    },
    ".message-wrapper": {
      display: "flex",
      flexDirection: "column",
      marginBottom: "{spacing.md}"
    },
    ".message-wrapper[data-role='user']": {
      alignItems: "flex-end"
    },
    ".message-wrapper[data-role='assistant']": {
      alignItems: "flex-start"
    },
    ".message-name": {
      fontSize: "0.65rem",
      fontWeight: "{typography.fontWeight.semibold}",
      textTransform: "uppercase",
      letterSpacing: "0.05em",
      marginBottom: "0.25rem",
      opacity: "0.7"
    },
    ".message-wrapper[data-role='user'] .message-name": {
      color: "{colors.marineBlue}",
      textAlign: "right"
    },
    ".message-wrapper[data-role='assistant'] .message-name": {
      color: "{colors.marineBlue}",
      textAlign: "left"
    },
    ".message": {
      padding: "{spacing.sm} {spacing.md}",
      borderRadius: "{radii.apple}",
      maxWidth: "85%",
      wordWrap: "break-word",
      fontSize: "0.75rem",
      fontWeight: "{typography.fontWeight.light}",
      lineHeight: "1.4",
      transition: "{transitions.fast}"
    },
    ".messageAssistant": {
      alignSelf: "flex-start",
      background: "rgba(255, 255, 255, 0.6)",
      color: "{colors.marineBlue}",
      border: "1px solid {colors.border}",
      boxShadow: "{shadows.sm}"
    },
    ".messageUser": {
      alignSelf: "flex-end",
      background: "{colors.marineBlue}",
      color: "{colors.text.marine}",
      boxShadow: "0 4px 12px rgba(0, 31, 51, 0.2)"
    },
    ".message[data-role='assistant']": {
      alignSelf: "flex-start",
      background: "rgba(255, 255, 255, 0.6)",
      color: "{colors.marineBlue}",
      border: "1px solid {colors.border}"
    },
    ".message[data-role='user']": {
      alignSelf: "flex-end",
      background: "{colors.marineBlue}",
      color: "{colors.text.marine}"
    },
    ".welcomeMessage": {
      fontFamily: "{typography.fontFamily.body}",
      fontSize: "0.75rem",
      background: "rgba(0, 189, 214, 0.05)",
      border: "1px solid rgba(0, 189, 214, 0.1)",
      color: "{colors.marineBlue}",
      marginTop: "{spacing.sm}",
      marginBottom: "{spacing.md}",
      data: {
        hasConversations: {
          true: {
            display: "none"
          }
        }
      }
    },
    ".welcomeSection": {
      display: "flex",
      flexDirection: "column",
      marginBottom: "{spacing.md}"
    },
    ".agentCategory": {
      fontFamily: "{typography.fontFamily.heading}",
      fontSize: "0.6rem",
      fontStyle: "italic",
      color: "{colors.paradiseWater}",
      marginBottom: "0.25rem",
      display: "block",
      textShadow: "0 0 10px rgba(0, 189, 214, 0.2)"
    },
    ".agentTitle": {
      fontFamily: "{typography.fontFamily.heading}",
      fontSize: "0.9rem",
      fontWeight: "{typography.fontWeight.bold}",
      color: "{colors.marineBlue}",
      margin: "0",
      letterSpacing: "-0.02em"
    },
    ".inputContainer": {
      gridRow: "2",
      display: "flex",
      gap: "{spacing.sm}",
      padding: "{spacing.sm}",
      background: "rgba(255, 255, 255, 0.4)",
      backdropFilter: "blur(8px) saturate(150%)",
      borderRadius: "{radii.full}",
      border: "1px solid {colors.border}",
      boxShadow: "{shadows.md}",
      flexShrink: "0",
      position: "relative",
      zIndex: "100"
    },
    ".input": {
      flex: "1",
      padding: "{spacing.xs} {spacing.md}",
      border: "none",
      background: "transparent",
      fontSize: "0.7rem",
      color: "{colors.marineBlue}",
      fontFamily: "{typography.fontFamily.body}",
      fontWeight: "{typography.fontWeight.light}",
      outline: "none",
      cursor: "text"
    },
    ".button": {
      padding: "{spacing.xs} {spacing.md}",
      background: "{colors.paradiseWater}",
      color: "{colors.text.water}",
      border: "none",
      borderRadius: "{radii.full}",
      cursor: "pointer",
      fontSize: "0.6rem",
      fontWeight: "600",
      textTransform: "uppercase",
      letterSpacing: "0.05em",
      transition: "{transitions.fast}",
      boxShadow: "0 4px 12px rgba(0, 189, 214, 0.2)",
      ":hover": {
        filter: "brightness(1.1)",
        transform: "translateY(-1px)",
        boxShadow: "0 6px 16px rgba(0, 189, 214, 0.3)"
      },
      ":active": {
        transform: "translateY(0)"
      }
    },
    ".button:disabled": {
      background: "{colors.marineBlueLight}",
      opacity: "0.5",
      cursor: "not-allowed",
      boxShadow: "none"
    },
    ".loading": {
      padding: "{spacing.sm} {spacing.md}",
      color: "{colors.marineBlueLight}",
      fontFamily: "{typography.fontFamily.heading}",
      fontStyle: "italic",
      display: "none",
      position: "absolute",
      top: "{spacing.xl}",
      left: "50%",
      transform: "translateX(-50%)",
      zIndex: "10",
      background: "rgba(232, 225, 217, 0.8)",
      backdropFilter: "blur(4px)",
      borderRadius: "{radii.full}",
      border: "1px solid {colors.border}",
      data: {
        isLoading: {
          true: {
            display: "block"
          }
        }
      }
    },
    ".error": {
      padding: "{spacing.md}",
      background: "rgba(194, 123, 102, 0.1)",
      color: "{colors.terracotta}",
      borderRadius: "{radii.apple}",
      border: "1px solid rgba(194, 123, 102, 0.2)",
      margin: "{spacing.md}",
      display: "none",
      data: {
        hasError: {
          true: {
            display: "block"
          }
        }
      }
    },
    "@container {containerName} (min-width: {containers.xs})": {
      ".chatContainer": {
        padding: "{spacing.sm}",
        gap: "{spacing.sm}"
      },
      ".messagesContainer": {
        padding: "{spacing.sm}",
        gap: "{spacing.md}"
      },
      ".message": {
        padding: "{spacing.sm} {spacing.md}",
        fontSize: "0.7rem"
      },
      ".agentCategory": {
        fontSize: "0.65rem"
      },
      ".agentTitle": {
        fontSize: "0.85rem"
      },
      ".inputContainer": {
        gap: "{spacing.sm}",
        padding: "{spacing.sm}"
      },
      ".input": {
        padding: "{spacing.xs} {spacing.md}",
        fontSize: "0.7rem"
      },
      ".button": {
        padding: "{spacing.xs} {spacing.md}",
        fontSize: "0.65rem"
      },
      ".welcomeMessage": {
        fontSize: "0.7rem"
      }
    },
    "@container {containerName} (min-width: {containers.sm})": {
      ".chatContainer": {
        padding: "{spacing.sm}",
        gap: "{spacing.sm}"
      },
      ".messagesContainer": {
        padding: "{spacing.sm}",
        gap: "{spacing.md}"
      },
      ".message": {
        padding: "{spacing.sm} {spacing.md}",
        fontSize: "0.75rem"
      },
      ".agentCategory": {
        fontSize: "0.7rem"
      },
      ".agentTitle": {
        fontSize: "0.9rem"
      },
      ".inputContainer": {
        gap: "{spacing.sm}",
        padding: "{spacing.sm}"
      },
      ".input": {
        padding: "{spacing.xs} {spacing.md}",
        fontSize: "0.7rem"
      },
      ".button": {
        padding: "{spacing.xs} {spacing.md}",
        fontSize: "0.65rem"
      },
      ".welcomeMessage": {
        fontSize: "0.75rem"
      }
    },
    "@container {containerName} (min-width: {containers.md})": {
      ".chatContainer": {
        padding: "{spacing.sm}",
        gap: "{spacing.sm}"
      },
      ".messagesContainer": {
        padding: "{spacing.sm}",
        gap: "{spacing.md}"
      },
      ".message": {
        padding: "{spacing.sm} {spacing.md}",
        fontSize: "0.8rem"
      },
      ".agentCategory": {
        fontSize: "0.75rem"
      },
      ".agentTitle": {
        fontSize: "0.95rem"
      },
      ".inputContainer": {
        gap: "{spacing.sm}",
        padding: "{spacing.sm}"
      },
      ".input": {
        padding: "{spacing.xs} {spacing.md}",
        fontSize: "0.75rem"
      },
      ".button": {
        padding: "{spacing.xs} {spacing.md}",
        fontSize: "0.7rem"
      },
      ".welcomeMessage": {
        fontSize: "0.8rem"
      }
    },
    "@container {containerName} (min-width: {containers.lg})": {
      ".chatContainer": {
        padding: "{spacing.sm}",
        gap: "{spacing.sm}"
      },
      ".messagesContainer": {
        padding: "{spacing.sm}",
        gap: "{spacing.md}"
      },
      ".message": {
        padding: "{spacing.sm} {spacing.md}",
        fontSize: "0.85rem"
      },
      ".agentCategory": {
        fontSize: "0.8rem"
      },
      ".agentTitle": {
        fontSize: "1rem"
      },
      ".inputContainer": {
        gap: "{spacing.sm}",
        padding: "{spacing.sm}"
      },
      ".input": {
        padding: "{spacing.xs} {spacing.md}",
        fontSize: "0.8rem"
      },
      ".button": {
        padding: "{spacing.xs} {spacing.md}",
        fontSize: "0.75rem"
      },
      ".welcomeMessage": {
        fontSize: "0.85rem"
      }
    },
    "@container {containerName} (min-width: {containers.xl})": {
      ".chatContainer": {
        padding: "{spacing.sm}",
        gap: "{spacing.sm}"
      },
      ".messagesContainer": {
        padding: "{spacing.sm}",
        gap: "{spacing.md}"
      },
      ".message": {
        padding: "{spacing.sm} {spacing.md}",
        fontSize: "0.9rem"
      },
      ".agentCategory": {
        fontSize: "0.85rem"
      },
      ".agentTitle": {
        fontSize: "1.05rem"
      },
      ".inputContainer": {
        gap: "{spacing.sm}",
        padding: "{spacing.sm}"
      },
      ".input": {
        padding: "{spacing.xs} {spacing.md}",
        fontSize: "0.85rem"
      },
      ".button": {
        padding: "{spacing.xs} {spacing.md}",
        fontSize: "0.8rem"
      },
      ".welcomeMessage": {
        fontSize: "0.9rem"
      }
    },
    "@container {containerName} (min-width: {containers.2xl})": {
      ".chatContainer": {
        padding: "{spacing.sm}",
        gap: "{spacing.sm}"
      },
      ".messagesContainer": {
        padding: "{spacing.sm}",
        gap: "{spacing.md}"
      },
      ".message": {
        padding: "{spacing.sm} {spacing.md}",
        fontSize: "0.95rem"
      },
      ".agentCategory": {
        fontSize: "0.9rem"
      },
      ".agentTitle": {
        fontSize: "1.1rem"
      },
      ".inputContainer": {
        gap: "{spacing.sm}",
        padding: "{spacing.sm}"
      },
      ".input": {
        padding: "{spacing.xs} {spacing.md}",
        fontSize: "0.9rem"
      },
      ".button": {
        padding: "{spacing.xs} {spacing.md}",
        fontSize: "0.85rem"
      },
      ".welcomeMessage": {
        fontSize: "0.95rem"
      }
    }
  }
}, dk = {
  $schema: "@maia/schema/actor",
  $id: "@maia/chat/actor/vibe",
  role: "agent",
  context: "@maia/chat/context/vibe",
  view: "@maia/chat/view/vibe",
  state: "@maia/chat/state/vibe",
  brand: "@maia/chat/style/brand",
  inbox: "@maia/chat/inbox/vibe",
  messageTypes: [
    "SEND_MESSAGE",
    "UPDATE_INPUT",
    "RENDER_COMPLETE",
    "SUCCESS",
    "ERROR",
    "RETRY",
    "DISMISS"
  ]
}, uk = {
  $schema: "@maia/schema/view",
  $id: "@maia/chat/view/vibe",
  content: {
    tag: "div",
    class: "chat-container",
    children: [
      {
        tag: "div",
        class: "messages-container",
        children: [
          {
            tag: "div",
            class: "welcome-section",
            children: [
              {
                tag: "h2",
                class: "agent-title",
                text: "Maia"
              },
              {
                tag: "div",
                class: "message message-assistant welcome-message",
                attrs: {
                  data: {
                    hasConversations: "$hasConversations"
                  }
                },
                text: "Hello! I'm Maia, your CTO-level AI assistant. I understand the MaiaOS codebase and learn alongside your coding sessions. How can I help you today?"
              }
            ]
          },
          {
            $each: {
              items: "$conversations",
              template: {
                tag: "div",
                class: "message-wrapper",
                attrs: {
                  data: {
                    role: "$$role"
                  }
                },
                children: [
                  {
                    tag: "div",
                    class: "message-name",
                    text: "$messageNames.$$id"
                  },
                  {
                    tag: "div",
                    class: "message",
                    attrs: {
                      data: {
                        role: "$$role"
                      }
                    },
                    text: "$$content"
                  }
                ]
              }
            }
          }
        ]
      },
      {
        tag: "div",
        class: "loading",
        attrs: {
          data: {
            isLoading: "$isLoading"
          }
        },
        text: "Maia is thinking..."
      },
      {
        tag: "div",
        class: "error",
        attrs: {
          data: {
            hasError: "$hasError"
          }
        },
        children: [
          {
            tag: "strong",
            text: "Error: "
          },
          {
            text: "$error"
          },
          {
            tag: "button",
            class: "button",
            text: "Dismiss",
            $on: {
              click: {
                send: "DISMISS"
              }
            }
          }
        ]
      },
      {
        tag: "div",
        class: "input-container",
        children: [
          {
            tag: "input",
            class: "input",
            attrs: {
              type: "text",
              placeholder: "Type your message...",
              disabled: "$isLoading"
            },
            value: "$inputText",
            $on: {
              input: {
                send: "UPDATE_INPUT",
                payload: {
                  value: "@inputValue"
                }
              },
              keydown: {
                send: "SEND_MESSAGE",
                payload: {
                  inputText: "@inputValue"
                },
                key: "Enter"
              }
            }
          },
          {
            tag: "button",
            class: "button",
            attrs: {
              disabled: "$isLoading"
            },
            text: "Send",
            $on: {
              click: {
                send: "SEND_MESSAGE",
                payload: {
                  inputText: "$inputText"
                }
              }
            }
          }
        ]
      }
    ]
  }
}, hk = {
  $schema: "@maia/schema/context",
  $id: "@maia/chat/context/vibe",
  conversations: {
    schema: "@maia/schema/data/chat"
  },
  inputText: "",
  assistantResponse: null,
  isLoading: !1,
  error: null,
  hasConversations: !1,
  hasError: !1,
  messageNames: {}
}, fk = {
  $schema: "@maia/schema/state",
  $id: "@maia/chat/state/vibe",
  initial: "idle",
  states: {
    idle: {
      entry: [
        {
          updateContext: {
            isLoading: !1
          }
        },
        {
          tool: "@core/computeMessageNames",
          payload: {
            conversations: "$conversations"
          },
          onSuccess: {
            updateContext: {
              messageNames: "$$result"
            }
          }
        }
      ],
      on: {
        RENDER_COMPLETE: {
          target: "idle",
          actions: [
            {
              updateContext: {
                hasConversations: {
                  $gt: [
                    {
                      $length: "$conversations"
                    },
                    0
                  ]
                }
              }
            },
            {
              tool: "@core/computeMessageNames",
              payload: {
                conversations: "$conversations"
              },
              onSuccess: {
                updateContext: {
                  messageNames: "$$result"
                }
              }
            }
          ]
        },
        SEND_MESSAGE: {
          target: "chatting"
        },
        UPDATE_INPUT: {
          target: "idle",
          actions: [
            {
              updateContext: {
                inputText: "$$value"
              }
            }
          ]
        }
      }
    },
    chatting: {
      entry: [
        {
          updateContext: {
            isLoading: !0,
            hasError: !1
          }
        },
        {
          tool: "@db",
          payload: {
            op: "create",
            schema: "@maia/schema/data/chat",
            data: {
              role: "user",
              content: "$$inputText"
            }
          }
        }
      ],
      on: {
        SUCCESS: {
          target: "calling_llm",
          actions: [
            {
              updateContext: {
                inputText: ""
              }
            }
          ]
        },
        ERROR: {
          target: "error",
          actions: [
            {
              updateContext: {
                isLoading: !1
              }
            }
          ]
        }
      }
    },
    calling_llm: {
      entry: {
        tool: "@ai/chat",
        payload: {
          model: "qwen/qwen3-30b-a3b-instruct-2507",
          temperature: 1,
          context: {
            $concat: [
              [
                {
                  role: "system",
                  content: "You are Maia, a CTO-level AI assistant that understands the entire MaiaOS codebase, architecture, and all packages. You learn alongside coding sessions. Be helpful, technical, and concise. Never use emoticons in your responses."
                }
              ],
              {
                $map: {
                  array: "$conversations",
                  as: "msg",
                  return: {
                    role: "$$msg.role",
                    content: "$$msg.content"
                  }
                }
              }
            ]
          }
        }
      },
      on: {
        SUCCESS: {
          target: "saving_response"
        },
        ERROR: {
          target: "error",
          actions: [
            {
              updateContext: {
                isLoading: !1
              }
            }
          ]
        }
      }
    },
    saving_response: {
      entry: [
        {
          tool: "@db",
          payload: {
            op: "create",
            schema: "@maia/schema/data/chat",
            data: {
              role: "assistant",
              content: "$$result.content"
            }
          }
        }
      ],
      on: {
        SUCCESS: {
          target: "idle",
          actions: [
            {
              updateContext: {
                assistantResponse: null,
                isLoading: !1,
                hasError: !1
              }
            },
            {
              updateContext: {
                hasConversations: {
                  $gt: [
                    {
                      $length: "$conversations"
                    },
                    0
                  ]
                }
              }
            },
            {
              tool: "@core/computeMessageNames",
              payload: {
                conversations: "$conversations"
              },
              onSuccess: {
                updateContext: {
                  messageNames: "$$result"
                }
              }
            }
          ]
        },
        ERROR: {
          target: "error",
          actions: [
            {
              updateContext: {
                isLoading: !1
              }
            }
          ]
        }
      }
    },
    error: {
      entry: {
        updateContext: {
          error: "$$errors.0.message",
          isLoading: !1,
          hasError: !0
        }
      },
      on: {
        SEND_MESSAGE: {
          target: "chatting",
          actions: [
            {
              updateContext: {
                error: null,
                hasError: !1
              }
            }
          ]
        },
        RETRY: {
          target: "idle",
          actions: [
            {
              updateContext: {
                error: null,
                hasError: !1
              }
            }
          ]
        },
        DISMISS: {
          target: "idle",
          actions: [
            {
              updateContext: {
                error: null,
                hasError: !1
              }
            }
          ]
        }
      }
    }
  }
}, pk = {
  $schema: "@maia/schema/inbox",
  $id: "@maia/chat/inbox/vibe"
}, wk = {
  vibe: Ek,
  styles: {
    "@maia/chat/style/brand": lk
  },
  actors: {
    "@maia/chat/actor/vibe": dk
  },
  views: {
    "@maia/chat/view/vibe": uk
  },
  contexts: {
    "@maia/chat/context/vibe": hk
  },
  states: {
    "@maia/chat/state/vibe": fk
  },
  inboxes: {
    "@maia/chat/inbox/vibe": pk
  }
}, yk = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ChatVibeRegistry: wk
}, Symbol.toStringTag, { value: "Module" })), Dk = {
  $schema: "@maia/schema/vibe",
  $id: "@maia/vibe/creator",
  name: "Creator",
  description: "Create and manage vibes with logs viewer",
  actor: "@maia/creator/actor/vibe"
}, mk = {
  $schema: "@maia/schema/style",
  $id: "@maia/creator/style/logs",
  components: {
    vibeCreatorTitle: {
      fontFamily: "{typography.fontFamily.heading}",
      fontSize: "0.9rem",
      fontWeight: "{typography.fontWeight.bold}",
      color: "{colors.marineBlue}",
      margin: "0",
      marginBottom: "0.375rem",
      textAlign: "center",
      width: "100%",
      letterSpacing: "-0.02em"
    },
    logs: {
      padding: "0",
      margin: "0",
      background: "transparent",
      color: "#001F33",
      fontFamily: "'Plus Jakarta Sans', sans-serif",
      fontSize: "0.85rem",
      lineHeight: "1.5"
    },
    logEntryContainer: {
      display: "flex",
      flexDirection: "column",
      width: "100%",
      maxWidth: "100%",
      boxSizing: "border-box",
      overflow: "hidden"
    },
    logEntries: {
      display: "flex",
      flexDirection: "column",
      gap: "0.2rem",
      width: "100%",
      maxWidth: "100%",
      boxSizing: "border-box"
    },
    logEntry: {
      padding: "0.1rem 0.75rem",
      margin: "0",
      background: "rgba(255, 255, 255, 0.4)",
      backdropFilter: "blur(8px) saturate(150%)",
      "-webkit-backdrop-filter": "blur(8px) saturate(150%)",
      border: "1px solid rgba(0, 31, 51, 0.05)",
      borderLeft: "4px solid #00BDD6",
      borderRadius: "8px",
      display: "grid",
      gridTemplateColumns: "auto auto auto 1fr auto",
      gridTemplateRows: "auto auto",
      alignItems: "center",
      minHeight: "1.3rem",
      transition: "all 0.2s cubic-bezier(0.4, 0, 0.2, 1)",
      width: "100%",
      maxWidth: "100%",
      boxSizing: "border-box",
      color: "#001F33",
      position: "relative",
      boxShadow: "0 2px 8px rgba(0, 0, 0, 0.02)",
      overflow: "visible",
      ":hover": {
        background: "rgba(255, 255, 255, 0.6)",
        transform: "translateX(4px)",
        boxShadow: "0 4px 12px rgba(0, 0, 0, 0.04)"
      }
    },
    logType: {
      color: "#001F33",
      fontWeight: "700",
      fontSize: "0.6rem",
      textTransform: "uppercase",
      minWidth: "5rem",
      textAlign: "left",
      letterSpacing: "0.1em",
      opacity: "0.8"
    },
    logSource: {
      color: "#2D4A5C",
      fontSize: "0.65rem",
      fontFamily: "monospace",
      minWidth: "8rem",
      flexShrink: "0",
      fontWeight: "500",
      display: "flex",
      alignItems: "center",
      gap: "0.3rem",
      background: "rgba(0, 31, 51, 0.05)",
      padding: "0.1rem 0.4rem",
      borderRadius: "4px"
    },
    logSourceRole: {
      color: "#001F33",
      fontWeight: "700",
      textTransform: "lowercase",
      opacity: "0.6"
    },
    logSourceId: {
      color: "#5E7A8C",
      fontSize: "0.6rem"
    },
    logTarget: {
      color: "#2D4A5C",
      fontSize: "0.65rem",
      fontFamily: "monospace",
      minWidth: "8rem",
      flexShrink: "0",
      fontWeight: "500",
      display: "flex",
      alignItems: "center",
      gap: "0.3rem",
      background: "rgba(0, 189, 214, 0.05)",
      padding: "0.1rem 0.4rem",
      borderRadius: "4px"
    },
    logTargetRole: {
      color: "#004D59",
      fontWeight: "700",
      textTransform: "lowercase",
      opacity: "0.6"
    },
    logTargetId: {
      color: "#00BDD6",
      fontSize: "0.6rem"
    },
    logPayloadDetails: {
      display: "contents"
    },
    logPayloadToggle: {
      gridColumn: "5",
      gridRow: "1",
      color: "#004D59",
      fontSize: "0.6rem",
      fontWeight: "700",
      cursor: "pointer",
      userSelect: "none",
      padding: "0.15rem 0.5rem",
      borderRadius: "9999px",
      background: "rgba(0, 189, 214, 0.15)",
      border: "1px solid rgba(0, 189, 214, 0.2)",
      transition: "all 0.2s ease",
      textTransform: "uppercase",
      letterSpacing: "0.05em",
      justifySelf: "end",
      ":hover": {
        background: "rgba(0, 189, 214, 0.25)",
        transform: "scale(1.05)"
      }
    },
    logPayload: {
      gridRow: "2",
      gridColumn: "4 / 6",
      margin: "0.3rem 0 0.2rem 0",
      padding: "0.6rem 0.8rem",
      background: "rgba(0, 31, 51, 0.03)",
      borderRadius: "8px",
      border: "1px solid rgba(0, 31, 51, 0.05)",
      color: "#2D4A5C",
      fontSize: "0.65rem",
      fontFamily: "monospace",
      whiteSpace: "pre-wrap",
      wordBreak: "break-all",
      overflow: "auto",
      maxHeight: "400px",
      width: "fit-content",
      minWidth: "180px",
      maxWidth: "100%",
      boxSizing: "border-box",
      boxShadow: "inset 0 2px 4px rgba(0, 0, 0, 0.02)",
      textAlign: "left",
      justifySelf: "end",
      display: "flex",
      alignItems: "center"
    }
  },
  selectors: {
    ".log-entry[data-event-type='SUCCESS']": {
      borderLeftColor: "#4E9A58",
      background: "rgba(78, 154, 88, 0.05)"
    },
    ".log-entry[data-event-type='ERROR']": {
      borderLeftColor: "#C27B66",
      background: "rgba(194, 123, 102, 0.05)"
    },
    ".log-entry[data-event-type='SWITCH_VIEW']": {
      borderLeftColor: "#00BDD6"
    },
    "summary::-webkit-details-marker": {
      display: "none"
    },
    "summary::marker": {
      display: "none"
    },
    "details:not([open]) .log-payload": {
      display: "none"
    }
  }
}, Sk = { $schema: "@maia/schema/actor", $id: "@maia/creator/actor/vibe", role: "agent", context: "@maia/creator/context/logs", view: "@maia/creator/view/logs", state: "@maia/creator/state/logs", brand: "@maia/style/brand", style: "@maia/creator/style/logs", inbox: "@maia/creator/inbox/logs", messageTypes: ["RETRY", "DISMISS"] }, kk = { $schema: "@maia/schema/view", $id: "@maia/creator/view/logs", content: { tag: "div", class: "stack", children: [{ tag: "h2", class: "vibe-creator-title", text: "Vibe Creator" }, { tag: "div", class: "logs", attrs: { data: "log-viewer" }, children: [{ tag: "div", class: "log-entries", $each: { items: "$messages", template: { class: "log-entry-container", children: [{ tag: "div", class: "log-entry", attrs: { data: { eventType: "$$type", processed: "$$processed" } }, children: [{ tag: "span", class: "log-type", text: "$$type" }, { tag: "span", class: "log-source", children: [{ tag: "span", class: "log-source-role", text: "$$fromRole" }, { tag: "span", class: "log-source-id", text: "$$fromId" }] }, { tag: "span", class: "log-target", children: [{ tag: "span", class: "log-target-role", text: "$$recipient" }, { tag: "span", class: "log-target-id", text: "$$targetId" }] }, { tag: "details", class: "log-payload-details", children: [{ tag: "summary", class: "log-payload-toggle", text: "$payloadLabel" }, { tag: "pre", class: "log-payload", text: "$$payload" }] }] }] } } }] }] } }, Nk = {
  $schema: "@maia/schema/context",
  $id: "@maia/creator/context/logs",
  messages: {
    schema: "@maia/schema/message",
    options: {
      map: {
        fromRole: "$$source.role",
        toRole: "$$target.role",
        fromId: "$$source.id",
        toId: "$$target.id",
        recipient: "$$target.role",
        targetId: "$$target.id"
      }
    }
  },
  payloadLabel: "payload"
}, Mk = {
  $schema: "@maia/schema/state",
  $id: "@maia/creator/state/logs",
  initial: "idle",
  states: {
    idle: {},
    error: {
      entry: {
        updateContext: {
          error: "$$errors.0.message"
        }
      },
      on: {
        RETRY: {
          target: "idle",
          actions: [
            {
              updateContext: {
                error: null
              }
            }
          ]
        },
        DISMISS: {
          target: "idle",
          actions: [
            {
              updateContext: {
                error: null
              }
            }
          ]
        }
      }
    }
  }
}, Gk = {
  $schema: "@maia/schema/inbox",
  $id: "@maia/creator/inbox/logs",
  items: []
}, Fk = {
  vibe: Dk,
  styles: {
    "@maia/style/brand": nc,
    "@maia/creator/style/logs": mk
  },
  actors: {
    "@maia/creator/actor/vibe": Sk
  },
  views: {
    "@maia/creator/view/logs": kk
  },
  contexts: {
    "@maia/creator/context/logs": Nk
  },
  states: {
    "@maia/creator/state/logs": Mk
  },
  inboxes: {
    "@maia/creator/inbox/logs": Gk
  },
  data: {}
}, bk = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CreatorVibeRegistry: Fk
}, Symbol.toStringTag, { value: "Module" }));
export {
  se as MaiaOS,
  wA as ReactiveStore,
  vD as createAgentAccount,
  qy as createCoJSONAPI,
  KD as generateAgentCredentials,
  wo as getAllSchemas,
  Xg as getSchema,
  En as getSchemaIndexColistId,
  JI as isPRFSupported,
  YD as loadAgentAccount,
  Wt as setupSyncPeers,
  RD as signInWithPasskey,
  bD as signUpWithPasskey,
  tD as subscribeSyncState
};
