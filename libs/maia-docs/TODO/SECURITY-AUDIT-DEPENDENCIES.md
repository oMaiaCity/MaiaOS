# Security Audit: new Function in Dependencies

## Summary

The MaiaOS kernel bundle (`maia-kernel.es.js`) contains `new Function()` at two locations. This audit confirms the sources and assesses risk.

## Findings

### 1. AJV (JSON Schema Validator)

**Package**: `ajv` ^8.12.0 (via `@MaiaOS/schemata`)

**Usage**: AJV compiles JSON Schema into JavaScript validation functions at runtime:

```javascript
const J = new Function(`${e.default.self}`, `${e.default.scope}`, R)(this, this.scope.get());
```

**Code flow**:
- `R` = compiled validation code string generated by AJV from the **schema definition**
- Schemas come from `@MaiaOS/schemata` (e.g. `maia-script-expression.schema.json`, `vibe.schema.json`) - **static, bundled**
- User JSON config is the **data** passed to the compiled validator, not the schema or generated code

**Risk**: **LOW**
- User input never becomes the schema or the generated code
- Only our static schemas drive code generation
- Validation is a read-only check; no user data is executed

### 2. Other new Function (Line ~6904)

**Probable source**: AJV or a related codegen library (e.g. ajv-formats, ajv-keywords)

**Pattern**: `return new Function(VA(A, e));` - similar codegen pattern for type coercion or format validation.

**Risk**: Same as above - schema-driven, not user-data-driven.

### 3. CoJSON

**Package**: `cojson` ^0.20.7 (via `@MaiaOS/db`)

**Audit**: Grep of MaiaOS source and typical cojson usage found **no** `new Function` or `eval` in MaiaOS-owned code. CoJSON uses:
- WebAssembly for crypto (Ed25519, X25519, etc.) - no JS eval
- CRDT logic - no dynamic code generation

CoJSON's "scope" and "self" references in the bundle are from AJV's codegen, not from cojson.

**Risk**: **N/A** - CoJSON does not introduce `new Function` for user data.

### 4. Zod / zod-to-json-schema

**Usage**: Schema transformation (zod → JSON Schema) for validation. Zod does not use `new Function` for validation; AJV does the runtime validation.

**Risk**: **N/A**

## Conclusion

| Component | new Function? | User Data in Code Path? | Verdict |
|-----------|---------------|--------------------------|---------|
| AJV       | Yes (schema compile) | No - schema is static | Safe |
| CoJSON    | No            | N/A                     | Safe |
| MaiaOS Evaluator | No | N/A (no eval) | Safe |

**Recommendation**: No changes required for current dependencies. When adding new schema/runtime libraries, prefer those that avoid dynamic code generation. If `new Function` is used, ensure user input cannot flow into the generated code.

---

# Security Audit: Style Engine Token Interpolation

## Summary

StyleEngine uses `_interpolateTokens()` to substitute `{path}` placeholders in CSS with token values. Tokens come from brand/actor style configs (CoJSON). This audit assesses CSS injection risk.

## Implementation (Post-Mitigation)

### 1. Path Resolution

- `resolvePath(tokens, path)` now includes `assertSafePath()` - blocks `__proto__`, `constructor`, `prototype`
- Matches Evaluator security (fix 1.3)

### 2. Value Sanitization

- `sanitizeCSSInterpolatedValue()` blocks:
  - `javascript:` / `vbscript:` in URLs
  - `data:...base64,` (potential script payloads)
  - `expression()` (legacy IE)
  - `-moz-binding` (Firefox XBL)
  - `@import` (additional stylesheet load)
  - `behavior:` (legacy IE)

### 3. Token Source

- Tokens: `brand.tokens`, `actor.tokens` merged from CoJSON
- CoJSON data is account-scoped; style configs come from seeded vibes or user-created sparks
- If untrusted vibes can write style configs, token values could be attacker-controlled → sanitization is required

## Verdict

**Secured**: Path validation + value sanitization provide defense-in-depth against CSS injection via token interpolation. Safe for vault and general use.
